<h1 id="doc-first-3d-game-killing-the-player">Killing the player</h1> <p>We can kill enemies by jumping on them, but the player still can't die. Let's fix this.</p> <p>We want to detect being hit by an enemy differently from squashing them. We want the player to die when they're moving on the floor, but not if they're in the air. We could use vector math to distinguish the two kinds of collisions. Instead, though, we will use an <em>Area</em> node, which works well for hitboxes.</p> <section id="hitbox-with-the-area-node"> <h2>Hitbox with the Area node</h2> <p>Head back to the <em>Player</em> scene and add a new <em>Area</em> node. Name it <em>MobDetector</em>. Add a <em>CollisionShape</em> node as a child of it.</p> <p><img alt="image0" src="https://docs.godotengine.org/en/3.5/_images/01.adding_area_node.png"></p> <p>In the <em>Inspector</em>, assign a cylinder shape to it.</p> <p><img alt="image1" src="https://docs.godotengine.org/en/3.5/_images/02.cylinder_shape.png"></p> <p>Here is a trick you can use to make the collisions only happen when the player is on the ground or close to it. You can reduce the cylinder's height and move it up to the top of the character. This way, when the player jumps, the shape will be too high up for the enemies to collide with it.</p> <p><img alt="image2" src="https://docs.godotengine.org/en/3.5/_images/03.cylinder_in_editor.png"></p> <p>You also want the cylinder to be wider than the sphere. This way, the player gets hit before colliding and being pushed on top of the monster's collision box.</p> <p>The wider the cylinder, the more easily the player will get killed.</p> <p>Next, select the <em>MobDetector</em> node again, and in the <em>Inspector</em>, turn off its <em>Monitorable</em> property. This makes it so other physics nodes cannot detect the area. The complementary <em>Monitoring</em> property allows it to detect collisions. Then, remove the <em>Collision -&gt; Layer</em> and set the mask to the "enemies" layer.</p> <p><img alt="image3" src="https://docs.godotengine.org/en/3.5/_images/04.mob_detector_properties.png"></p> <p>When areas detect a collision, they emit signals. We're going to connect one to the <em>Player</em> node. In the <em>Node</em> tab, double-click the <code>body_entered</code> signal and connect it to the <em>Player</em>.</p> <p><img alt="image4" src="https://docs.godotengine.org/en/3.5/_images/05.body_entered_signal.png"></p> <p>The <em>MobDetector</em> will emit <code>body_entered</code> when a <em>KinematicBody</em> or a <em>RigidBody</em> node enters it. As it only masks the "enemies" physics layers, it will only detect the <em>Mob</em> nodes.</p> <p>Code-wise, we're going to do two things: emit a signal we'll later use to end the game and destroy the player. We can wrap these operations in a <code>die()</code> function that helps us put a descriptive label on the code.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript"># Emitted when the player was hit by a mob.
# Put this at the top of the script.
signal hit


# And this function at the bottom.
func die():
    emit_signal("hit")
    queue_free()


func _on_MobDetector_body_entered(_body):
    die()
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// Don't forget to rebuild the project so the editor knows about the new signal.

// Emitted when the player was hit by a mob.
[Signal]
public delegate void Hit();

// ...

private void Die()
{
    EmitSignal(nameof(Hit));
    QueueFree();
}

// We also specified this function name in PascalCase in the editor's connection window
public void OnMobDetectorBodyEntered(Node body)
{
    Die();
}
</pre> </div>
</div> <p>Try the game again by pressing <kbd class="kbd docutils literal notranslate">F5</kbd>. If everything is set up correctly, the character should die when an enemy runs into it.</p> <p>However, note that this depends entirely on the size and position of the <em>Player</em> and the <em>Mob</em>'s collision shapes. You may need to move them and resize them to achieve a tight game feel.</p> </section> <section id="ending-the-game"> <h2>Ending the game</h2> <p>We can use the <em>Player</em>'s <code>hit</code> signal to end the game. All we need to do is connect it to the <em>Main</em> node and stop the <em>MobTimer</em> in reaction.</p> <p>Open <code>Main.tscn</code>, select the <em>Player</em> node, and in the <em>Node</em> dock, connect its <code>hit</code> signal to the <em>Main</em> node.</p> <p><img alt="image5" src="https://docs.godotengine.org/en/3.5/_images/06.player_hit_signal.png"></p> <p>Get and stop the timer in the <code>_on_Player_hit()</code> function.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_Player_hit():
    $MobTimer.stop()
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// We also specified this function name in PascalCase in the editor's connection window
public void OnPlayerHit()
{
    GetNode&lt;Timer&gt;("MobTimer").Stop();
}
</pre> </div>
</div> <p>If you try the game now, the monsters will stop spawning when you die, and the remaining ones will leave the screen.</p> <p>You can pat yourself in the back: you prototyped a complete 3D game, even if it's still a bit rough.</p> <p>From there, we'll add a score, the option to retry the game, and you'll see how you can make the game feel much more alive with minimalistic animations.</p> </section> <section id="code-checkpoint"> <h2>Code checkpoint</h2> <p>Here are the complete scripts for the <em>Main</em>, <em>Mob</em>, and <em>Player</em> nodes, for reference. You can use them to compare and check your code.</p> <p>Starting with <code>Main.gd</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends Node

export(PackedScene) var mob_scene


func _ready():
    randomize()


func _on_MobTimer_timeout():
    # Create a new instance of the Mob scene.
    var mob = mob_scene.instance()

    # Choose a random location on the SpawnPath.
    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    # And give it a random offset.
    mob_spawn_location.unit_offset = randf()

    # Communicate the spawn location and the player's location to the mob.
    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    # Spawn the mob by adding it to the Main scene.
    add_child(mob)


func _on_Player_hit():
    $MobTimer.stop()
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Main : Node
{
#pragma warning disable 649
    [Export]
    public PackedScene MobScene;
#pragma warning restore 649

    public override void _Ready()
    {
        GD.Randomize();
    }

    public void OnMobTimerTimeout()
    {
        // Create a new instance of the Mob scene.
        var mob = (Mob)MobScene.Instance();

        // Choose a random location on the SpawnPath.
        // We store the reference to the SpawnLocation node.
        var mobSpawnLocation = GetNode&lt;PathFollow&gt;("SpawnPath/SpawnLocation");
        // And give it a random offset.
        mobSpawnLocation.UnitOffset = GD.Randf();

        // Communicate the spawn location and the player's location to the mob.
        Vector3 playerPosition = GetNode&lt;Player&gt;("Player").Transform.origin;
        mob.Initialize(mobSpawnLocation.Translation, playerPosition);

        // Spawn the mob by adding it to the Main scene.
        AddChild(mob);
    }

    public void OnPlayerHit()
    {
        GetNode&lt;Timer&gt;("MobTimer").Stop();
    }
}
</pre> </div>
</div> <p>Next is <code>Mob.gd</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# Emitted when the player jumped on the mob.
signal squashed

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO


func _physics_process(_delta):
    move_and_slide(velocity)


func initialize(start_position, player_position):
    look_at_from_position(start_position, player_position, Vector3.UP)
    rotate_y(rand_range(-PI / 4, PI / 4))

    var random_speed = rand_range(min_speed, max_speed)
    velocity = Vector3.FORWARD * random_speed
    velocity = velocity.rotated(Vector3.UP, rotation.y)


 func squash():
    emit_signal("squashed")
    queue_free()


func _on_VisibilityNotifier_screen_exited():
    queue_free()
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Mob : KinematicBody
{
    // Emitted when the played jumped on the mob.
    [Signal]
    public delegate void Squashed();

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed = 18;

    private Vector3 _velocity = Vector3.Zero;

    public override void _PhysicsProcess(float delta)
    {
        MoveAndSlide(_velocity);
    }

    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        float randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
        _velocity = Vector3.Forward * randomSpeed;
        _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
    }

    public void Squash()
    {
        EmitSignal(nameof(Squashed));
        QueueFree();
    }

    public void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}
</pre> </div>
</div> <p>Finally, the longest script, <code>Player.gd</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# Emitted when a mob hit the player.
signal hit

# How fast the player moves in meters per second.
export var speed = 14
# The downward acceleration when in the air, in meters per second squared.
export var fall_acceleration = 75
# Vertical impulse applied to the character upon jumping in meters per second.
export var jump_impulse = 20
# Vertical impulse applied to the character upon bouncing over a mob in meters per second.
export var bounce_impulse = 16

var velocity = Vector3.ZERO


func _physics_process(delta):
    var direction = Vector3.ZERO

    if Input.is_action_pressed("move_right"):
        direction.x += 1
    if Input.is_action_pressed("move_left"):
        direction.x -= 1
    if Input.is_action_pressed("move_back"):
        direction.z += 1
    if Input.is_action_pressed("move_forward"):
        direction.z -= 1

    if direction != Vector3.ZERO:
        direction = direction.normalized()
        $Pivot.look_at(translation + direction, Vector3.UP)

    velocity.x = direction.x * speed
    velocity.z = direction.z * speed

    # Jumping.
    if is_on_floor() and Input.is_action_just_pressed("jump"):
        velocity.y += jump_impulse

    velocity.y -= fall_acceleration * delta
    velocity = move_and_slide(velocity, Vector3.UP)

    for index in range(get_slide_count()):
        var collision = get_slide_collision(index)
        if collision.collider.is_in_group("mob"):
            var mob = collision.collider
            if Vector3.UP.dot(collision.normal) &gt; 0.1:
                mob.squash()
                velocity.y = bounce_impulse


func die():
    emit_signal("hit")
    queue_free()


func _on_MobDetector_body_entered(_body):
    die()
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Player : KinematicBody
{
    // Emitted when the player was hit by a mob.
    [Signal]
    public delegate void Hit();

    // How fast the player moves in meters per second.
    [Export]
    public int Speed = 14;
    // The downward acceleration when in the air, in meters per second squared.
    [Export]
    public int FallAcceleration = 75;
    // Vertical impulse applied to the character upon jumping in meters per second.
    [Export]
    public int JumpImpulse = 20;
    // Vertical impulse applied to the character upon bouncing over a mob in meters per second.
    [Export]
    public int BounceImpulse = 16;

    private Vector3 _velocity = Vector3.Zero;

    public override void _PhysicsProcess(float delta)
    {
        var direction = Vector3.Zero;

        if (Input.IsActionPressed("move_right"))
        {
            direction.x += 1f;
        }
        if (Input.IsActionPressed("move_left"))
        {
            direction.x -= 1f;
        }
        if (Input.IsActionPressed("move_back"))
        {
            direction.z += 1f;
        }
        if (Input.IsActionPressed("move_forward"))
        {
            direction.z -= 1f;
        }

        if (direction != Vector3.Zero)
        {
            direction = direction.Normalized();
            GetNode&lt;Spatial&gt;("Pivot").LookAt(Translation + direction, Vector3.Up);
        }

        _velocity.x = direction.x * Speed;
        _velocity.z = direction.z * Speed;

        // Jumping.
        if (IsOnFloor() &amp;&amp; Input.IsActionJustPressed("jump"))
        {
            _velocity.y += JumpImpulse;
        }

        _velocity.y -= FallAcceleration * delta;
        _velocity = MoveAndSlide(_velocity, Vector3.Up);

        for (int index = 0; index &lt; GetSlideCount(); index++)
        {
            KinematicCollision collision = GetSlideCollision(index);
            if (collision.Collider is Mob mob &amp;&amp; mob.IsInGroup("mob"))
            {
                if (Vector3.Up.Dot(collision.Normal) &gt; 0.1f)
                {
                    mob.Squash();
                    _velocity.y = BounceImpulse;
                }
            }
        }
    }

    private void Die()
    {
        EmitSignal(nameof(Hit));
        QueueFree();
    }

    public void OnMobDetectorBodyEntered(Node body)
    {
        Die();
    }
}
</pre> </div>
</div> <p>See you in the next lesson to add the score and the retry option.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/07.killing_player.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/07.killing_player.html</a>
  </p>
</div>
