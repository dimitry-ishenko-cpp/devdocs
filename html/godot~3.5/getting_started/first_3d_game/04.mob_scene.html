<h1 id="doc-first-3d-game-designing-the-mob-scene">Designing the mob scene</h1> <p>In this part, you're going to code the monsters, which we'll call mobs. In the next lesson, we'll spawn them randomly around the playable area.</p> <p>Let's design the monsters themselves in a new scene. The node structure is going to be similar to the <em>Player</em> scene.</p> <p>Create a scene with, once again, a <em>KinematicBody</em> node as its root. Name it <em>Mob</em>. Add a <em>Spatial</em> node as a child of it, name it <em>Pivot</em>. And drag and drop the file <code>mob.glb</code> from the <em>FileSystem</em> dock onto the <em>Pivot</em> to add the monster's 3D model to the scene. You can rename the newly created <em>mob</em> node into <em>Character</em>.</p> <p><img alt="image0" src="https://docs.godotengine.org/en/3.5/_images/01.initial_three_nodes.png"></p> <p>We need a collision shape for our body to work. Right-click on the <em>Mob</em> node, the scene's root, and click <em>Add Child Node</em>.</p> <p><img alt="image1" src="https://docs.godotengine.org/en/3.5/_images/02.add_child_node.png"></p> <p>Add a <em>CollisionShape</em>.</p> <p><img alt="image2" src="https://docs.godotengine.org/en/3.5/_images/03.scene_with_collision_shape.png"></p> <p>In the <em>Inspector</em>, assign a <em>BoxShape</em> to the <em>Shape</em> property.</p> <p><img alt="image3" src="https://docs.godotengine.org/en/3.5/_images/04.create_box_shape.png"></p> <p>We should change its size to fit the 3D model better. You can do so interactively by clicking and dragging on the orange dots.</p> <p>The box should touch the floor and be a little thinner than the model. Physics engines work in such a way that if the player's sphere touches even the box's corner, a collision will occur. If the box is a little too big compared to the 3D model, you may die at a distance from the monster, and the game will feel unfair to the players.</p> <p><img alt="image4" src="https://docs.godotengine.org/en/3.5/_images/05.box_final_size.png"></p> <p>Notice that my box is taller than the monster. It is okay in this game because we're looking at the scene from above and using a fixed perspective. Collision shapes don't have to match the model exactly. It's the way the game feels when you test it that should dictate their form and size.</p> <section id="removing-monsters-off-screen"> <h2>Removing monsters off-screen</h2> <p>We're going to spawn monsters at regular time intervals in the game level. If we're not careful, their count could increase to infinity, and we don't want that. Each mob instance has both a memory and a processing cost, and we don't want to pay for it when the mob's outside the screen.</p> <p>Once a monster leaves the screen, we don't need it anymore, so we can delete it. Godot has a node that detects when objects leave the screen, <em>VisibilityNotifier</em>, and we're going to use it to destroy our mobs.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When you keep instancing an object in games, there's a technique you can use to avoid the cost of creating and destroying instances all the time called pooling. It consists of pre-creating an array of objects and reusing them over and over.</p> <p>When working with GDScript, you don't need to worry about this. The main reason to use pools is to avoid freezes with garbage-collected languages like C# or Lua. GDScript uses a different technique to manage memory, reference counting, which doesn't have that caveat. You can learn more about that here <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_basics.html#doc-gdscript-basics-memory-management"><span class="std std-ref">Memory management</span></a>.</p> </div> <p>Select the <em>Mob</em> node and add a <em>VisibilityNotifier</em> as a child of it. Another box, pink this time, appears. When this box completely leaves the screen, the node will emit a signal.</p> <p><img alt="image5" src="https://docs.godotengine.org/en/3.5/_images/06.visibility_notifier.png"></p> <p>Resize it using the orange dots until it covers the entire 3D model.</p> <p><img alt="image6" src="https://docs.godotengine.org/en/3.5/_images/07.visibility_notifier_bbox_resized.png"></p> <section id="coding-the-mob-s-movement"> <h3>Coding the mob's movement</h3> <p>Let's implement the monster's motion. We're going to do this in two steps. First, we'll write a script on the <em>Mob</em> that defines a function to initialize the monster. We'll then code the randomized spawn mechanism in the <em>Main</em> scene and call the function from there.</p> <p>Attach a script to the <em>Mob</em>.</p> <p><img alt="image7" src="https://docs.godotengine.org/en/3.5/_images/08.mob_attach_script.png"></p> <p>Here's the movement code to start with. We define two properties, <code>min_speed</code> and <code>max_speed</code>, to define a random speed range. We then define and initialize the <code>velocity</code>.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO


func _physics_process(_delta):
    move_and_slide(velocity)
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Mob : KinematicBody
{
    // Don't forget to rebuild the project so the editor knows about the new export variable.

    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed = 18;

    private Vector3 _velocity = Vector3.Zero;

    public override void _PhysicsProcess(float delta)
    {
        MoveAndSlide(_velocity);
    }
}
</pre> </div>
</div> <p>Similarly to the player, we move the mob every frame by calling <code>KinematicBody</code>'s <code>move_and_slide()</code> method. This time, we don't update the <code>velocity</code> every frame: we want the monster to move at a constant speed and leave the screen, even if it were to hit an obstacle.</p> <p>You may see a warning in GDScript that the return value from <code>move_and_slide()</code> is unused. This is expected. You can simply ignore the warning or, if you want to hide it entirely, add the comment <code># warning-ignore:return_value_discarded</code> just above the <code>move_and_slide(velocity)</code> line. To read more about the GDScript warning system, see <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/warning_system.html#doc-gdscript-warning-system"><span class="std std-ref">GDScript warning system</span></a>.</p> <p>We need to define another function to calculate the start velocity. This function will turn the monster towards the player and randomize both its angle of motion and its velocity.</p> <p>The function will take a <code>start_position</code>, the mob's spawn position, and the <code>player_position</code> as its arguments.</p> <p>We position the mob at <code>start_position</code> and turn it towards the player using the <code>look_at_from_position()</code> method, and randomize the angle by rotating a random amount around the Y axis. Below, <code>rand_range()</code> outputs a random value between <code>-PI / 4</code> radians and <code>PI / 4</code> radians.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript"># We will call this function from the Main scene.
func initialize(start_position, player_position):
    # We position the mob and turn it so that it looks at the player.
    look_at_from_position(start_position, player_position, Vector3.UP)
    # And rotate it randomly so it doesn't move exactly toward the player.
    rotate_y(rand_range(-PI / 4, PI / 4))
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// We will call this function from the Main scene
public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // We position the mob and turn it so that it looks at the player.
    LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
    // And rotate it randomly so it doesn't move exactly toward the player.
    RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));
}
</pre> </div>
</div> <p>We then calculate a random speed using <code>rand_range()</code> once again and we use it to calculate the velocity.</p> <p>We start by creating a 3D vector pointing forward, multiply it by our <code>random_speed</code>, and finally rotate it using the <code>Vector3</code> class's <code>rotated()</code> method.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func initialize(start_position, player_position):
    # ...

    # We calculate a random speed.
    var random_speed = rand_range(min_speed, max_speed)
    # We calculate a forward velocity that represents the speed.
    velocity = Vector3.FORWARD * random_speed
    # We then rotate the vector based on the mob's Y rotation to move in the direction it's looking.
    velocity = velocity.rotated(Vector3.UP, rotation.y)
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void Initialize(Vector3 startPosition, Vector3 playerPosition)
{
    // ...

    // We calculate a random speed.
    float randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
    // We calculate a forward velocity that represents the speed.
    _velocity = Vector3.Forward * randomSpeed;
    // We then rotate the vector based on the mob's Y rotation to move in the direction it's looking
    _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
}
</pre> </div>
</div> </section> <section id="leaving-the-screen"> <h3>Leaving the screen</h3> <p>We still have to destroy the mobs when they leave the screen. To do so, we'll connect our <em>VisibilityNotifier</em> node's <code>screen_exited</code> signal to the <em>Mob</em>.</p> <p>Head back to the 3D viewport by clicking on the <em>3D</em> label at the top of the editor. You can also press <kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Ctrl</kbd> + <kbd class="kbd docutils literal notranslate">F2</kbd></kbd> (<kbd class="kbd compound docutils literal notranslate"><kbd class="kbd docutils literal notranslate">Alt</kbd> + <kbd class="kbd docutils literal notranslate">2</kbd></kbd> on macOS).</p> <p><img alt="image8" src="https://docs.godotengine.org/en/3.5/_images/09.switch_to_3d_workspace.png"></p> <p>Select the <em>VisibilityNotifier</em> node and on the right side of the interface, navigate to the <em>Node</em> dock. Double-click the <em>screen_exited()</em> signal.</p> <p><img alt="image9" src="https://docs.godotengine.org/en/3.5/_images/10.node_dock.png"></p> <p>Connect the signal to the <em>Mob</em>.</p> <p><img alt="image10" src="https://docs.godotengine.org/en/3.5/_images/11.connect_signal.png"></p> <p>This will take you back to the script editor and add a new function for you, <code>_on_VisibilityNotifier_screen_exited()</code>. From it, call the <code>queue_free()</code> method. This will destroy the mob instance when the <em>VisibilityNotifier</em> 's box leaves the screen.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_VisibilityNotifier_screen_exited():
    queue_free()
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// We also specified this function name in PascalCase in the editor's connection window
public void OnVisibilityNotifierScreenExited()
{
    QueueFree();
}
</pre> </div>
</div> <p>Our monster is ready to enter the game! In the next part, you will spawn monsters in the game level.</p> <p>Here is the complete <code>Mob.gd</code> script for reference.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends KinematicBody

# Minimum speed of the mob in meters per second.
export var min_speed = 10
# Maximum speed of the mob in meters per second.
export var max_speed = 18

var velocity = Vector3.ZERO


func _physics_process(_delta):
    move_and_slide(velocity)

func initialize(start_position, player_position):
    look_at_from_position(start_position, player_position, Vector3.UP)
    rotate_y(rand_range(-PI / 4, PI / 4))

    var random_speed = rand_range(min_speed, max_speed)
    velocity = Vector3.FORWARD * random_speed
    velocity = velocity.rotated(Vector3.UP, rotation.y)


func _on_VisibilityNotifier_screen_exited():
    queue_free()
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Mob : KinematicBody
{
    // Minimum speed of the mob in meters per second
    [Export]
    public int MinSpeed = 10;
    // Maximum speed of the mob in meters per second
    [Export]
    public int MaxSpeed = 18;

    private Vector3 _velocity = Vector3.Zero;

    public override void _PhysicsProcess(float delta)
    {
        MoveAndSlide(_velocity);
    }

    // We will call this function from the Main scene
    public void Initialize(Vector3 startPosition, Vector3 playerPosition)
    {
        LookAtFromPosition(startPosition, playerPosition, Vector3.Up);
        RotateY((float)GD.RandRange(-Mathf.Pi / 4.0, Mathf.Pi / 4.0));

        var randomSpeed = (float)GD.RandRange(MinSpeed, MaxSpeed);
        _velocity = Vector3.Forward * randomSpeed;
        _velocity = _velocity.Rotated(Vector3.Up, Rotation.y);
    }

    // We also specified this function name in PascalCase in the editor's connection window
    public void OnVisibilityNotifierScreenExited()
    {
        QueueFree();
    }
}
</pre> </div>
</div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/04.mob_scene.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/04.mob_scene.html</a>
  </p>
</div>
