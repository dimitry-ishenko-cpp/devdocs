<h1 id="doc-first-3d-game-score-and-replay">Score and replay</h1> <p>In this part, we'll add the score, music playback, and the ability to restart the game.</p> <p>We have to keep track of the current score in a variable and display it on screen using a minimal interface. We will use a text label to do that.</p> <p>In the main scene, add a new <em>Control</em> node as a child of <em>Main</em> and name it <em>UserInterface</em>. You will automatically be taken to the 2D screen, where you can edit your User Interface (UI).</p> <p>Add a <em>Label</em> node and rename it to <em>ScoreLabel</em>.</p> <p><img alt="image0" src="https://docs.godotengine.org/en/3.5/_images/01.label_node.png"></p> <p>In the <em>Inspector</em>, set the <em>Label</em>'s <em>Text</em> to a placeholder like "Score: 0".</p> <p><img alt="image1" src="https://docs.godotengine.org/en/3.5/_images/02.score_placeholder.png"></p> <p>Also, the text is white by default, like our game's background. We need to change its color to see it at runtime.</p> <p>Scroll down to <em>Theme Overrides</em>, and expand <em>Colors</em> and click the black box next to <em>Font Color</em> to tint the text.</p> <p><img alt="image2" src="https://docs.godotengine.org/en/3.5/_images/02.score_custom_color.png"></p> <p>Pick a dark tone so it contrasts well with the 3D scene.</p> <p><img alt="image3" src="https://docs.godotengine.org/en/3.5/_images/02.score_color_picker.png"></p> <p>Finally, click and drag on the text in the viewport to move it away from the top-left corner.</p> <p><img alt="image4" src="https://docs.godotengine.org/en/3.5/_images/02.score_label_moved.png"></p> <p>The <em>UserInterface</em> node allows us to group our UI in a branch of the scene tree and use a theme resource that will propagate to all its children. We'll use it to set our game's font.</p> <section id="creating-a-ui-theme"> <h2>Creating a UI theme</h2> <p>Once again, select the <em>UserInterface</em> node. In the <em>Inspector</em>, create a new theme resource in <em>Theme -&gt; Theme</em>.</p> <p><img alt="image5" src="https://docs.godotengine.org/en/3.5/_images/03.creating_theme.png"></p> <p>Click on it to open the theme editor In the bottom panel. It gives you a preview of how all the built-in UI widgets will look with your theme resource.</p> <p><img alt="image6" src="https://docs.godotengine.org/en/3.5/_images/04.theme_preview.png"></p> <p>By default, a theme only has one property, the <em>Default Font</em>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>You can add more properties to the theme resource to design complex user interfaces, but that is beyond the scope of this series. To learn more about creating and editing themes, see <a href="https://docs.godotengine.org/en/3.5/tutorials/ui/gui_skinning.html#doc-gui-skinning"><span class="std std-ref">Introduction to GUI skinning</span></a>.</p> </div> <p>Click the <em>Default Font</em> property and create a new <em>DynamicFont</em>.</p> <p><img alt="image7" src="https://docs.godotengine.org/en/3.5/_images/05.dynamic_font.png"></p> <p>Expand the <em>DynamicFont</em> by clicking on it and expand its <em>Font</em> section. There, you will see an empty <em>Font Data</em> field.</p> <p><img alt="image8" src="https://docs.godotengine.org/en/3.5/_images/06.font_data.png"></p> <p>This one expects a font file like the ones you have on your computer. DynamicFont supports the following formats:</p> <ul class="simple"> <li>TrueType (<code>.ttf</code>)</li> <li>OpenType (<code>.otf</code>)</li> <li>Web Open Font Format 1 (<code>.woff</code>)</li> <li>Web Open Font Format 2 (<code>.woff2</code>, since Godot 3.5)</li> </ul> <p>In the <em>FileSystem</em> dock, expand the <code>fonts</code> directory and click and drag the <code>Montserrat-Medium.ttf</code> file we included in the project onto the <em>Font Data</em>. The text will reappear in the theme preview.</p> <p>The text is a bit small. Set the <em>Settings -&gt; Size</em> to <code>22</code> pixels to increase the text's size.</p> <p><img alt="image9" src="https://docs.godotengine.org/en/3.5/_images/07.font_size.png"></p> </section> <section id="keeping-track-of-the-score"> <h2>Keeping track of the score</h2> <p>Let's work on the score next. Attach a new script to the <em>ScoreLabel</em> and define the <code>score</code> variable.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends Label

var score = 0
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class ScoreLabel : Label
{
    private int _score = 0;
}
</pre> </div>
</div> <p>The score should increase by <code>1</code> every time we squash a monster. We can use their <code>squashed</code> signal to know when that happens. However, as we instantiate monsters from the code, we cannot do the connection in the editor.</p> <p>Instead, we have to make the connection from the code every time we spawn a monster.</p> <p>Open the script <code>Main.gd</code>. If it's still open, you can click on its name in the script editor's left column.</p> <p><img alt="image10" src="https://docs.godotengine.org/en/3.5/_images/08.open_main_script.png"></p> <p>Alternatively, you can double-click the <code>Main.gd</code> file in the <em>FileSystem</em> dock.</p> <p>At the bottom of the <code>_on_MobTimer_timeout()</code> function, add the following line.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_MobTimer_timeout():
    #...
    # We connect the mob to the score label to update the score upon squashing one.
    mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnMobTimerTimeout()
{
    // ...
    // We connect the mob to the score label to update the score upon squashing one.
    mob.Connect(nameof(Mob.Squashed), GetNode&lt;ScoreLabel&gt;("UserInterface/ScoreLabel"), nameof(ScoreLabel.OnMobSquashed));
}
</pre> </div>
</div> <p>This line means that when the mob emits the <code>squashed</code> signal, the <em>ScoreLabel</em> node will receive it and call the function <code>_on_Mob_squashed()</code>.</p> <p>Head back to the <code>ScoreLabel.gd</code> script to define the <code>_on_Mob_squashed()</code> callback function.</p> <p>There, we increment the score and update the displayed text.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_Mob_squashed():
    score += 1
    text = "Score: %s" % score
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnMobSquashed()
{
    _score += 1;
    Text = string.Format("Score: {0}", _score);
}
</pre> </div>
</div> <p>The second line uses the value of the <code>score</code> variable to replace the placeholder <code>%s</code>. When using this feature, Godot automatically converts values to text, which is convenient to output text in labels or using the <code>print()</code> function.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>You can learn more about string formatting here: <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/gdscript/gdscript_format_string.html#doc-gdscript-printf"><span class="std std-ref">GDScript format strings</span></a>.</p> </div> <p>You can now play the game and squash a few enemies to see the score increase.</p> <p><img alt="image11" src="https://docs.godotengine.org/en/3.5/_images/09.score_in_game.png"></p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In a complex game, you may want to completely separate your user interface from the game world. In that case, you would not keep track of the score on the label. Instead, you may want to store it in a separate, dedicated object. But when prototyping or when your project is simple, it is fine to keep your code simple. Programming is always a balancing act.</p> </div> </section> <section id="retrying-the-game"> <h2>Retrying the game</h2> <p>We'll now add the ability to play again after dying. When the player dies, we'll display a message on the screen and wait for input.</p> <p>Head back to the <em>Main</em> scene, select the <em>UserInterface</em> node, add a <em>ColorRect</em> node as a child of it and name it <em>Retry</em>. This node fills a rectangle with a uniform color and will serve as an overlay to darken the screen.</p> <p>To make it span over the whole viewport, you can use the <em>Layout</em> menu in the toolbar.</p> <p><img alt="image12" src="https://docs.godotengine.org/en/3.5/_images/10.layout_icon.png"></p> <p>Open it and apply the <em>Full Rect</em> command.</p> <p><img alt="image13" src="https://docs.godotengine.org/en/3.5/_images/11.full_rect_option.png"></p> <p>Nothing happens. Well, almost nothing: only the four green pins move to the corners of the selection box.</p> <p><img alt="image14" src="https://docs.godotengine.org/en/3.5/_images/12.anchors_updated.png"></p> <p>This is because UI nodes (all the ones with a green icon) work with anchors and margins relative to their parent's bounding box. Here, the <em>UserInterface</em> node has a small size and the <em>Retry</em> one is limited by it.</p> <p>Select the <em>UserInterface</em> and apply <em>Layout -&gt; Full Rect</em> to it as well. The <em>Retry</em> node should now span the whole viewport.</p> <p>Let's change its color so it darkens the game area. Select <em>Retry</em> and in the <em>Inspector</em>, set its <em>Color</em> to something both dark and transparent. To do so, in the color picker, drag the <em>A</em> slider to the left. It controls the color's alpha channel, that is to say, its opacity.</p> <p><img alt="image15" src="https://docs.godotengine.org/en/3.5/_images/13.retry_color_picker.png"></p> <p>Next, add a <em>Label</em> as a child of <em>Retry</em> and give it the <em>Text</em> "Press Enter to retry."</p> <p><img alt="image16" src="https://docs.godotengine.org/en/3.5/_images/14.retry_node.png"></p> <p>To move it and anchor it in the center of the screen, apply <em>Layout -&gt; Center</em> to it.</p> <p><img alt="image17" src="https://docs.godotengine.org/en/3.5/_images/15.layout_center.png"></p> <section id="coding-the-retry-option"> <h3>Coding the retry option</h3> <p>We can now head to the code to show and hide the <em>Retry</em> node when the player dies and plays again.</p> <p>Open the script <code>Main.gd</code>. First, we want to hide the overlay at the start of the game. Add this line to the <code>_ready()</code> function.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _ready():
    #...
    $UserInterface/Retry.hide()
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _Ready()
{
    // ...
    GetNode&lt;Control&gt;("UserInterface/Retry").Hide();
}
</pre> </div>
</div> <p>Then, when the player gets hit, we show the overlay.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_Player_hit():
    #...
    $UserInterface/Retry.show()
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnPlayerHit()
{
    //...
    GetNode&lt;Control&gt;("UserInterface/Retry").Show();
}
</pre> </div>
</div> <p>Finally, when the <em>Retry</em> node is visible, we need to listen to the player's input and restart the game if they press enter. To do this, we use the built-in <code>_unhandled_input()</code> callback.</p> <p>If the player pressed the predefined <code>ui_accept</code> input action and <em>Retry</em> is visible, we reload the current scene.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-5-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-5-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _unhandled_input(event):
    if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
        # This restarts the current scene.
        get_tree().reload_current_scene()
</pre> </div>
<div aria-labelledby="tab-5-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public override void _UnhandledInput(InputEvent @event)
{
    if (@event.IsActionPressed("ui_accept") &amp;&amp; GetNode&lt;Control&gt;("UserInterface/Retry").Visible)
    {
        // This restarts the current scene.
        GetTree().ReloadCurrentScene();
    }
}
</pre> </div>
</div> <p>The function <code>get_tree()</code> gives us access to the global <a href="../../classes/class_scenetree.html#class-scenetree"><span class="std std-ref">SceneTree</span></a> object, which allows us to reload and restart the current scene.</p> </section> </section> <section id="adding-music"> <h2>Adding music</h2> <p>To add music that plays continuously in the background, we're going to use another feature in Godot: <a href="https://docs.godotengine.org/en/3.5/tutorials/scripting/singletons_autoload.html#doc-singletons-autoload"><span class="std std-ref">autoloads</span></a>.</p> <p>To play audio, all you need to do is add an <em>AudioStreamPlayer</em> node to your scene and attach an audio file to it. When you start the scene, it can play automatically. However, when you reload the scene, like we do to play again, the audio nodes are also reset, and the music starts back from the beginning.</p> <p>You can use the autoload feature to have Godot load a node or a scene automatically at the start of the game, outside the current scene. You can also use it to create globally accessible objects.</p> <p>Create a new scene by going to the <em>Scene</em> menu and clicking <em>New Scene</em>.</p> <p><img alt="image18" src="https://docs.godotengine.org/en/3.5/_images/16.new_scene.png"></p> <p>Click the <em>Other Node</em> button to create an <em>AudioStreamPlayer</em> and rename it to <em>MusicPlayer</em>.</p> <p><img alt="image19" src="https://docs.godotengine.org/en/3.5/_images/17.music_player_node.png"></p> <p>We included a music soundtrack in the <code>art/</code> directory, <code>House In a Forest
Loop.ogg</code>. Click and drag it onto the <em>Stream</em> property in the <em>Inspector</em>. Also, turn on <em>Autoplay</em> so the music plays automatically at the start of the game.</p> <p><img alt="image20" src="https://docs.godotengine.org/en/3.5/_images/18.music_node_properties.png"></p> <p>Save the scene as <code>MusicPlayer.tscn</code>.</p> <p>We have to register it as an autoload. Head to the <em>Project -&gt; Project Settingsâ€¦</em> menu and click on the <em>Autoload</em> tab.</p> <p>In the <em>Path</em> field, you want to enter the path to your scene. Click the folder icon to open the file browser and double-click on <code>MusicPlayer.tscn</code>. Then, click the <em>Add</em> button on the right to register the node.</p> <p><img alt="image21" src="https://docs.godotengine.org/en/3.5/_images/19.register_autoload.png"></p> <p>If you run the game now, the music will play automatically. And even when you lose and retry, it keeps going.</p> <p>Before we wrap up this lesson, here's a quick look at how it works under the hood. When you run the game, your <em>Scene</em> dock changes to give you two tabs: <em>Remote</em> and <em>Local</em>.</p> <p><img alt="image22" src="https://docs.godotengine.org/en/3.5/_images/20.scene_dock_tabs.png"></p> <p>The <em>Remote</em> tab allows you to visualize the node tree of your running game. There, you will see the <em>Main</em> node and everything the scene contains and the instantiated mobs at the bottom.</p> <p><img alt="image23" src="https://docs.godotengine.org/en/3.5/_images/21.remote_scene_tree.png"></p> <p>At the top are the autoloaded <em>MusicPlayer</em> and a <em>root</em> node, which is your game's viewport.</p> <p>And that does it for this lesson. In the next part, we'll add an animation to make the game both look and feel much nicer.</p> <p>Here is the complete <code>Main.gd</code> script for reference.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-6-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button>
</div>
<div aria-labelledby="tab-6-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends Node

export (PackedScene) var mob_scene


func _ready():
    randomize()
    $UserInterface/Retry.hide()


func _unhandled_input(event):
    if event.is_action_pressed("ui_accept") and $UserInterface/Retry.visible:
        get_tree().reload_current_scene()


func _on_MobTimer_timeout():
    var mob = mob_scene.instance()

    var mob_spawn_location = get_node("SpawnPath/SpawnLocation")
    mob_spawn_location.unit_offset = randf()

    var player_position = $Player.transform.origin
    mob.initialize(mob_spawn_location.translation, player_position)

    add_child(mob)
    mob.connect("squashed", $UserInterface/ScoreLabel, "_on_Mob_squashed")


func _on_Player_hit():
    $MobTimer.stop()
    $UserInterface/Retry.show()
</pre> </div>
<div aria-labelledby="tab-6-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class Main : Node
{
#pragma warning disable 649
    [Export]
    public PackedScene MobScene;
#pragma warning restore 649

    public override void _Ready()
    {
        GD.Randomize();
        GetNode&lt;Control&gt;("UserInterface/Retry").Hide();
    }

    public override void _UnhandledInput(InputEvent @event)
    {
        if (@event.IsActionPressed("ui_accept") &amp;&amp; GetNode&lt;Control&gt;("UserInterface/Retry").Visible)
        {
            GetTree().ReloadCurrentScene();
        }
    }

    public void OnMobTimerTimeout()
    {
        Mob mob = (Mob)MobScene.Instance();

        var mobSpawnLocation = GetNode&lt;PathFollow&gt;("SpawnPath/SpawnLocation");
        mobSpawnLocation.UnitOffset = GD.Randf();

        Vector3 playerPosition = GetNode&lt;Player&gt;("Player").Transform.origin;
        mob.Initialize(mobSpawnLocation.Translation, playerPosition);

        AddChild(mob);
        mob.Connect(nameof(Mob.Squashed), GetNode&lt;ScoreLabel&gt;("UserInterface/ScoreLabel"), nameof(ScoreLabel.OnMobSquashed));
    }

    public void OnPlayerHit()
    {
        GetNode&lt;Timer&gt;("MobTimer").Stop();
        GetNode&lt;Control&gt;("UserInterface/Retry").Show();
    }
}
</pre> </div>
</div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/08.score_and_replay.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_3d_game/08.score_and_replay.html</a>
  </p>
</div>
