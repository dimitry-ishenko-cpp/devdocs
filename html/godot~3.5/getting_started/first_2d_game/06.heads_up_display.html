<h1 id="doc-your-first-2d-game-heads-up-display">Heads up display</h1> <p>The final piece our game needs is a User Interface (UI) to display things like score, a "game over" message, and a restart button.</p> <p>Create a new scene, and add a <a href="../../classes/class_canvaslayer.html#class-canvaslayer"><span class="std std-ref">CanvasLayer</span></a> node named <code>HUD</code>. "HUD" stands for "heads-up display", an informational display that appears as an overlay on top of the game view.</p> <p>The <a href="../../classes/class_canvaslayer.html#class-canvaslayer"><span class="std std-ref">CanvasLayer</span></a> node lets us draw our UI elements on a layer above the rest of the game, so that the information it displays isn't covered up by any game elements like the player or mobs.</p> <p>The HUD needs to display the following information:</p> <ul class="simple"> <li>Score, changed by <code>ScoreTimer</code>.</li> <li>A message, such as "Game Over" or "Get Ready!"</li> <li>A "Start" button to begin the game.</li> </ul> <p>The basic node for UI elements is <a href="../../classes/class_control.html#class-control"><span class="std std-ref">Control</span></a>. To create our UI, we'll use two types of <a href="../../classes/class_control.html#class-control"><span class="std std-ref">Control</span></a> nodes: <a href="../../classes/class_label.html#class-label"><span class="std std-ref">Label</span></a> and <a href="../../classes/class_button.html#class-button"><span class="std std-ref">Button</span></a>.</p> <p>Create the following as children of the <code>HUD</code> node:</p> <ul class="simple"> <li>
<a href="../../classes/class_label.html#class-label"><span class="std std-ref">Label</span></a> named <code>ScoreLabel</code>.</li> <li>
<a href="../../classes/class_label.html#class-label"><span class="std std-ref">Label</span></a> named <code>Message</code>.</li> <li>
<a href="../../classes/class_button.html#class-button"><span class="std std-ref">Button</span></a> named <code>StartButton</code>.</li> <li>
<a href="../../classes/class_timer.html#class-timer"><span class="std std-ref">Timer</span></a> named <code>MessageTimer</code>.</li> </ul> <p>Click on the <code>ScoreLabel</code> and type a number into the <code>Text</code> field in the Inspector. The default font for <code>Control</code> nodes is small and doesn't scale well. There is a font file included in the game assets called "Xolonium-Regular.ttf". To use this font, do the following:</p> <ol class="arabic simple"> <li>Under <strong>Theme overrides &gt; Fonts</strong> click on the empty box and select "New DynamicFont"</li> </ol> <img alt="../../_images/custom_font1.png" src="https://docs.godotengine.org/en/3.5/_images/custom_font1.png"> <ol class="arabic simple" start="2"> <li>Click on the "DynamicFont" you added, and under <strong>Font &gt; FontData</strong>, choose "Load" and select the "Xolonium-Regular.ttf" file.</li> </ol> <img alt="../../_images/custom_font2.png" src="https://docs.godotengine.org/en/3.5/_images/custom_font2.png"> <p>Set the "Size" property under <code>Settings</code>, <code>64</code> works well.</p> <img alt="../../_images/custom_font3.png" src="https://docs.godotengine.org/en/3.5/_images/custom_font3.png"> <p>Once you've done this on the <code>ScoreLabel</code>, you can click the down arrow next to the Font property and choose "Copy", then "Paste" it in the same place on the other two Control nodes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><strong>Anchors and Margins:</strong> <code>Control</code> nodes have a position and size, but they also have anchors and margins. Anchors define the origin - the reference point for the edges of the node. Margins update automatically when you move or resize a control node. They represent the distance from the control node's edges to its anchor.</p> </div> <p>Arrange the nodes as shown below. Click the "Layout" button to set a Control node's layout:</p> <img alt="../../_images/ui_anchor.png" src="https://docs.godotengine.org/en/3.5/_images/ui_anchor.png"> <p>You can drag the nodes to place them manually, or for more precise placement, use the following settings:</p> <section id="scorelabel"> <h2>ScoreLabel</h2> <ul class="simple"> <li>
<em>Layout</em> : "Top Wide"</li> <li>
<em>Text</em> : <code>0</code>
</li> <li>
<em>Align</em> : "Center"</li> </ul> </section> <section id="message"> <h2>Message</h2> <ul class="simple"> <li>
<em>Layout</em> : "HCenter Wide"</li> <li>
<em>Text</em> : <code>Dodge the Creeps!</code>
</li> <li>
<em>Align</em> : "Center"</li> <li>
<em>Autowrap</em> : "On"</li> </ul> </section> <section id="startbutton"> <h2>StartButton</h2> <ul class="simple"> <li>
<em>Text</em> : <code>Start</code>
</li> <li>
<em>Layout</em> : "Center Bottom"</li> <li>
<p><em>Margin</em> :</p> <ul> <li>Top: <code>-200</code>
</li> <li>Bottom: <code>-100</code>
</li> </ul> </li> </ul> <p>On the <code>MessageTimer</code>, set the <code>Wait Time</code> to <code>2</code> and set the <code>One Shot</code> property to "On".</p> <p>Now add this script to <code>HUD</code>:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-0-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-0-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-0-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-0-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-0-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">extends CanvasLayer

signal start_game
</pre> </div>
<div aria-labelledby="tab-0-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public class HUD : CanvasLayer
{
    // Don't forget to rebuild the project so the editor knows about the new signal.

    [Signal]
    public delegate void StartGame();
}
</pre> </div>
<div aria-labelledby="tab-0-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-0-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// Copy `player.gdns` to `hud.gdns` and replace `Player` with `HUD`.
// Attach the `hud.gdns` file to the HUD node.

// Create two files `hud.cpp` and `hud.hpp` next to `entry.cpp` in `src`.
// This code goes in `hud.hpp`. We also define the methods we'll be using here.
#ifndef HUD_H
#define HUD_H

#include &lt;Button.hpp&gt;
#include &lt;CanvasLayer.hpp&gt;
#include &lt;Godot.hpp&gt;
#include &lt;Label.hpp&gt;
#include &lt;Timer.hpp&gt;

class HUD : public godot::CanvasLayer {
    GODOT_CLASS(HUD, godot::CanvasLayer)

    godot::Label *_score_label;
    godot::Label *_message_label;
    godot::Timer *_start_message_timer;
    godot::Timer *_get_ready_message_timer;
    godot::Button *_start_button;
    godot::Timer *_start_button_timer;

public:
    void _init() {}
    void _ready();
    void show_get_ready();
    void show_game_over();
    void update_score(const int score);
    void _on_StartButton_pressed();
    void _on_StartMessageTimer_timeout();
    void _on_GetReadyMessageTimer_timeout();

    static void _register_methods();
};

#endif // HUD_H
</pre> </div>
</div> <p>The <code>start_game</code> signal tells the <code>Main</code> node that the button has been pressed.</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-1-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-1-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-1-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-1-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-1-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func show_message(text):
    $Message.text = text
    $Message.show()
    $MessageTimer.start()
</pre> </div>
<div aria-labelledby="tab-1-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void ShowMessage(string text)
{
    var message = GetNode&lt;Label&gt;("Message");
    message.Text = text;
    message.Show();

    GetNode&lt;Timer&gt;("MessageTimer").Start();
}
</pre> </div>
<div aria-labelledby="tab-1-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-1-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `hud.cpp`.
#include "hud.hpp"

void HUD::_ready() {
    _score_label = get_node&lt;godot::Label&gt;("ScoreLabel");
    _message_label = get_node&lt;godot::Label&gt;("MessageLabel");
    _start_message_timer = get_node&lt;godot::Timer&gt;("StartMessageTimer");
    _get_ready_message_timer = get_node&lt;godot::Timer&gt;("GetReadyMessageTimer");
    _start_button = get_node&lt;godot::Button&gt;("StartButton");
    _start_button_timer = get_node&lt;godot::Timer&gt;("StartButtonTimer");
}

void HUD::_register_methods() {
    godot::register_method("_ready", &amp;HUD::_ready);
    godot::register_method("show_get_ready", &amp;HUD::show_get_ready);
    godot::register_method("show_game_over", &amp;HUD::show_game_over);
    godot::register_method("update_score", &amp;HUD::update_score);
    godot::register_method("_on_StartButton_pressed", &amp;HUD::_on_StartButton_pressed);
    godot::register_method("_on_StartMessageTimer_timeout", &amp;HUD::_on_StartMessageTimer_timeout);
    godot::register_method("_on_GetReadyMessageTimer_timeout", &amp;HUD::_on_GetReadyMessageTimer_timeout);
    godot::register_signal&lt;HUD&gt;("start_game", godot::Dictionary());
}
</pre> </div>
</div> <p>This function is called when we want to display a message temporarily, such as "Get Ready".</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-2-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-2-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-2-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-2-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-2-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-2-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func show_game_over():
    show_message("Game Over")
    # Wait until the MessageTimer has counted down.
    yield($MessageTimer, "timeout")

    $Message.text = "Dodge the\nCreeps!"
    $Message.show()
    # Make a one-shot timer and wait for it to finish.
    yield(get_tree().create_timer(1), "timeout")
    $StartButton.show()
</pre> </div>
<div aria-labelledby="tab-2-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">async public void ShowGameOver()
{
    ShowMessage("Game Over");

    var messageTimer = GetNode&lt;Timer&gt;("MessageTimer");
    await ToSignal(messageTimer, "timeout");

    var message = GetNode&lt;Label&gt;("Message");
    message.Text = "Dodge the\nCreeps!";
    message.Show();

    await ToSignal(GetTree().CreateTimer(1), "timeout");
    GetNode&lt;Button&gt;("StartButton").Show();
}
</pre> </div>
<div aria-labelledby="tab-2-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-2-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `hud.cpp`.
// There is no `yield` in GDNative, so we need to have every
// step be its own method that is called on timer timeout.
void HUD::show_get_ready() {
    _message_label-&gt;set_text("Get Ready");
    _message_label-&gt;show();
    _get_ready_message_timer-&gt;start();
}

void HUD::show_game_over() {
    _message_label-&gt;set_text("Game Over");
    _message_label-&gt;show();
    _start_message_timer-&gt;start();
}
</pre> </div>
</div> <p>This function is called when the player loses. It will show "Game Over" for 2 seconds, then return to the title screen and, after a brief pause, show the "Start" button.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When you need to pause for a brief time, an alternative to using a Timer node is to use the SceneTree's <code>create_timer()</code> function. This can be very useful to add delays such as in the above code, where we want to wait some time before showing the "Start" button.</p> </div> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-3-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-3-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-3-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-3-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-3-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-3-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func update_score(score):
    $ScoreLabel.text = str(score)
</pre> </div>
<div aria-labelledby="tab-3-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void UpdateScore(int score)
{
    GetNode&lt;Label&gt;("ScoreLabel").Text = score.ToString();
}
</pre> </div>
<div aria-labelledby="tab-3-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-3-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `hud.cpp`.
void HUD::update_score(const int p_score) {
    _score_label-&gt;set_text(godot::Variant(p_score));
}
</pre> </div>
</div> <p>This function is called by <code>Main</code> whenever the score changes.</p> <p>Connect the <code>timeout()</code> signal of <code>MessageTimer</code> and the <code>pressed()</code> signal of <code>StartButton</code> and add the following code to the new functions:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-4-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-4-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-4-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-4-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-4-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-4-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">func _on_StartButton_pressed():
    $StartButton.hide()
    emit_signal("start_game")

func _on_MessageTimer_timeout():
    $Message.hide()
</pre> </div>
<div aria-labelledby="tab-4-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">public void OnStartButtonPressed()
{
    GetNode&lt;Button&gt;("StartButton").Hide();
    EmitSignal("StartGame");
}

public void OnMessageTimerTimeout()
{
    GetNode&lt;Label&gt;("Message").Hide();
}
</pre> </div>
<div aria-labelledby="tab-4-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-4-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">// This code goes in `hud.cpp`.
void HUD::_on_StartButton_pressed() {
    _start_button_timer-&gt;stop();
    _start_button-&gt;hide();
    emit_signal("start_game");
}

void HUD::_on_StartMessageTimer_timeout() {
    _message_label-&gt;set_text("Dodge the\nCreeps");
    _message_label-&gt;show();
    _start_button_timer-&gt;start();
}

void HUD::_on_GetReadyMessageTimer_timeout() {
    _message_label-&gt;hide();
}
</pre> </div>
</div> </section> <section id="connecting-hud-to-main"> <h2>Connecting HUD to Main</h2> <p>Now that we're done creating the <code>HUD</code> scene, go back to <code>Main</code>. Instance the <code>HUD</code> scene in <code>Main</code> like you did the <code>Player</code> scene. The scene tree should look like this, so make sure you didn't miss anything:</p> <img alt="../../_images/completed_main_scene.png" src="https://docs.godotengine.org/en/3.5/_images/completed_main_scene.png"> <p>Now we need to connect the <code>HUD</code> functionality to our <code>Main</code> script. This requires a few additions to the <code>Main</code> scene:</p> <p>In the Node tab, connect the HUD's <code>start_game</code> signal to the <code>new_game()</code> function of the Main node by typing "new_game" in the "Receiver Method" in the "Connect a Signal" window. Verify that the green connection icon now appears next to <code>func new_game()</code> in the script.</p> <p>In <code>new_game()</code>, update the score display and show the "Get Ready" message:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-5-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-5-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-5-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-5-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-5-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-5-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">$HUD.update_score(score)
$HUD.show_message("Get Ready")
</pre> </div>
<div aria-labelledby="tab-5-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-5-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">var hud = GetNode&lt;HUD&gt;("HUD");
hud.UpdateScore(Score);
hud.ShowMessage("Get Ready!");
</pre> </div>
<div aria-labelledby="tab-5-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-5-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">_hud-&gt;update_score(score);
_hud-&gt;show_get_ready();
</pre> </div>
</div> <p>In <code>game_over()</code> we need to call the corresponding <code>HUD</code> function:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-6-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-6-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-6-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-6-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-6-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-6-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-6-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">$HUD.show_game_over()
</pre> </div>
<div aria-labelledby="tab-6-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-6-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">GetNode&lt;HUD&gt;("HUD").ShowGameOver();
</pre> </div>
<div aria-labelledby="tab-6-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-6-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">_hud-&gt;show_game_over();
</pre> </div>
</div> <p>Finally, add this to <code>_on_ScoreTimer_timeout()</code> to keep the display in sync with the changing score:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-7-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-7-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-7-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-7-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-7-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-7-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-7-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">$HUD.update_score(score)
</pre> </div>
<div aria-labelledby="tab-7-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-7-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">GetNode&lt;HUD&gt;("HUD").UpdateScore(Score);
</pre> </div>
<div aria-labelledby="tab-7-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-7-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">_hud-&gt;update_score(score);
</pre> </div>
</div> <p>Now you're ready to play! Click the "Play the Project" button. You will be asked to select a main scene, so choose <code>Main.tscn</code>.</p> </section> <section id="removing-old-creeps"> <h2>Removing old creeps</h2> <p>If you play until "Game Over" and then start a new game right away, the creeps from the previous game may still be on the screen. It would be better if they all disappeared at the start of a new game. We just need a way to tell <em>all</em> the mobs to remove themselves. We can do this with the "group" feature.</p> <p>In the <code>Mob</code> scene, select the root node and click the "Node" tab next to the Inspector (the same place where you find the node's signals). Next to "Signals", click "Groups" and you can type a new group name and click "Add".</p> <img alt="../../_images/group_tab.png" src="https://docs.godotengine.org/en/3.5/_images/group_tab.png"> <p>Now all mobs will be in the "mobs" group. We can then add the following line to the <code>new_game()</code> function in <code>Main</code>:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-8-R0RTY3JpcHQ=" aria-selected="true" class="sphinx-tabs-tab code-tab group-tab" id="tab-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tab" tabindex="0">GDScript</button><button aria-controls="panel-8-QyM=" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-8-QyM=" name="QyM=" role="tab" tabindex="-1">C#</button><button aria-controls="panel-8-Qysr" aria-selected="false" class="sphinx-tabs-tab code-tab group-tab" id="tab-8-Qysr" name="Qysr" role="tab" tabindex="-1">C++</button>
</div>
<div aria-labelledby="tab-8-R0RTY3JpcHQ=" class="sphinx-tabs-panel code-tab group-tab" id="panel-8-R0RTY3JpcHQ=" name="R0RTY3JpcHQ=" role="tabpanel" tabindex="0">
<pre data-language="gdscript">get_tree().call_group("mobs", "queue_free")
</pre> </div>
<div aria-labelledby="tab-8-QyM=" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-8-QyM=" name="QyM=" role="tabpanel" tabindex="0">
<pre data-language="csharp">// Note that for calling Godot-provided methods with strings,
// we have to use the original Godot snake_case name.
GetTree().CallGroup("mobs", "queue_free");
</pre> </div>
<div aria-labelledby="tab-8-Qysr" class="sphinx-tabs-panel code-tab group-tab" hidden="true" id="panel-8-Qysr" name="Qysr" role="tabpanel" tabindex="0">
<pre data-language="cpp">get_tree()-&gt;call_group("mobs", "queue_free");
</pre> </div>
</div> <p>The <code>call_group()</code> function calls the named function on every node in a group - in this case we are telling every mob to delete itself.</p> <p>The game's mostly done at this point. In the next and last part, we'll polish it a bit by adding a background, looping music, and some keyboard shortcuts.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur and the Godot community<br>Licensed under the Creative Commons Attribution Unported License v3.0.<br>
    <a href="https://docs.godotengine.org/en/3.5/getting_started/first_2d_game/06.heads_up_display.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/getting_started/first_2d_game/06.heads_up_display.html</a>
  </p>
</div>
