<h1 id="class-transform">Transform</h1> <p>3D transformation (3×4 matrix).</p> <section id="description"> <h2>Description</h2> <p>3×4 matrix (3 rows, 4 columns) used for 3D linear transformations. It can represent transformations such as translation, rotation, or scaling. It consists of a <a href="#class-transform-property-basis"><span class="std std-ref">basis</span></a> (first 3 columns) and a <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> for the <a href="#class-transform-property-origin"><span class="std std-ref">origin</span></a> (last column).</p> <p>For more information, read the "Matrices and transforms" documentation article.</p> </section> <section id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/index.html"><span class="doc">Math tutorial index</span></a></li> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/matrices_and_transforms.html"><span class="doc">Matrices and transforms</span></a></li> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/3d/using_transforms.html"><span class="doc">Using 3D transforms</span></a></li> <li><a href="https://godotengine.org/asset-library/asset/584">Matrix Transform Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/125">3D Platformer Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/583">2.5D Demo</a></li> </ul> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-transform-property-basis"><span class="std std-ref">basis</span></a></p></td> <td><p><code>Basis( 1, 0, 0, 0, 1, 0, 0, 0, 1 )</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-transform-property-origin"><span class="std std-ref">origin</span></a></p></td> <td><p><code>Vector3( 0, 0, 0 )</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-transform"><span class="std std-ref">Transform</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> x_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> y_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> z_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> origin <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-transform"><span class="std std-ref">Transform</span></a> <strong>(</strong> <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> basis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> origin <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-transform"><span class="std std-ref">Transform</span></a> <strong>(</strong> <a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-transform"><span class="std std-ref">Transform</span></a> <strong>(</strong> <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-transform"><span class="std std-ref">Transform</span></a> <strong>(</strong> <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-interpolate-with"><span class="std std-ref">interpolate_with</span></a> <strong>(</strong> <a href="#class-transform"><span class="std std-ref">Transform</span></a> transform, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-inverse"><span class="std std-ref">inverse</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-transform-method-is-equal-approx"><span class="std std-ref">is_equal_approx</span></a> <strong>(</strong> <a href="#class-transform"><span class="std std-ref">Transform</span></a> transform <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-looking-at"><span class="std std-ref">looking_at</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> target, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> up <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-orthonormalized"><span class="std std-ref">orthonormalized</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-rotated"><span class="std std-ref">rotated</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-scaled"><span class="std std-ref">scaled</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> scale <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform"><span class="std std-ref">Transform</span></a></p></td> <td><p><a href="#class-transform-method-translated"><span class="std std-ref">translated</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> offset <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-transform-method-xform"><span class="std std-ref">xform</span></a> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-transform-method-xform-inv"><span class="std std-ref">xform_inv</span></a> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v <strong>)</strong></p></td> </tr>  </table> </section> <section id="constants"> <h2>Constants</h2> <ul class="simple" id="class-transform-constant-flip-z"> <li>
<strong>IDENTITY</strong> = <strong>Transform( 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 )</strong> --- <code>Transform</code> with no translation, rotation or scaling applied. When applied to other data structures, <a href="#class-transform-constant-identity"><span class="std std-ref">IDENTITY</span></a> performs no transformation.</li> <li>
<strong>FLIP_X</strong> = <strong>Transform( -1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0 )</strong> --- <code>Transform</code> with mirroring applied perpendicular to the YZ plane.</li> <li>
<strong>FLIP_Y</strong> = <strong>Transform( 1, 0, 0, 0, -1, 0, 0, 0, 1, 0, 0, 0 )</strong> --- <code>Transform</code> with mirroring applied perpendicular to the XZ plane.</li> <li>
<strong>FLIP_Z</strong> = <strong>Transform( 1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0 )</strong> --- <code>Transform</code> with mirroring applied perpendicular to the XY plane.</li> </ul> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-transform-property-basis"><p><a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> basis</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Basis( 1, 0, 0, 0, 1, 0, 0, 0, 1 )</code></p></td> </tr>  </table> <p>The basis is a matrix containing 3 <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> as its columns: X axis, Y axis, and Z axis. These vectors can be interpreted as the basis vectors of local coordinate system traveling with the object.</p>  <h3 id="class-transform-property-origin"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> origin</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector3( 0, 0, 0 )</code></p></td> </tr>  </table> <p>The translation offset of the transform (column 3, the fourth column). Equivalent to array index <code>3</code>.</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-transform-method-transform"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> Transform ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> x_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> y_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> z_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> origin )</p></h3> <p>Constructs a Transform from four <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> values (matrix columns). Each axis corresponds to local basis vectors (some of which may be scaled).</p>  <ul class="simple"> <li>
<a href="#class-transform"><span class="std std-ref">Transform</span></a> <strong>Transform</strong> <strong>(</strong> <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> basis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> origin <strong>)</strong>
</li> </ul> <p>Constructs a Transform from a <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> and <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>.</p>  <ul class="simple"> <li>
<a href="#class-transform"><span class="std std-ref">Transform</span></a> <strong>Transform</strong> <strong>(</strong> <a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a> from <strong>)</strong>
</li> </ul> <p>Constructs a Transform from a <a href="class_transform2d.html#class-transform2d"><span class="std std-ref">Transform2D</span></a>.</p>  <ul class="simple"> <li>
<a href="#class-transform"><span class="std std-ref">Transform</span></a> <strong>Transform</strong> <strong>(</strong> <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> from <strong>)</strong>
</li> </ul> <p>Constructs a Transform from a <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a>. The origin will be <code>Vector3(0, 0, 0)</code>.</p>  <ul class="simple"> <li>
<a href="#class-transform"><span class="std std-ref">Transform</span></a> <strong>Transform</strong> <strong>(</strong> <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a> from <strong>)</strong>
</li> </ul> <p>Constructs the Transform from a <a href="class_basis.html#class-basis"><span class="std std-ref">Basis</span></a>. The origin will be Vector3(0, 0, 0).</p>  <h3 id="class-transform-method-affine-inverse"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> affine_inverse ( )</p></h3> <p>Returns the inverse of the transform, under the assumption that the transformation is composed of rotation, scaling and translation.</p>  <h3 id="class-transform-method-interpolate-with"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> interpolate_with ( <a href="#class-transform"><span class="std std-ref">Transform</span></a> transform, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight )</p></h3> <p>Returns a transform interpolated between this transform and another by a given <code>weight</code> (on the range of 0.0 to 1.0).</p>  <h3 id="class-transform-method-inverse"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> inverse ( )</p></h3> <p>Returns the inverse of the transform, under the assumption that the transformation is composed of rotation and translation (no scaling, use <a href="#class-transform-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> for transforms with scaling).</p>  <h3 id="class-transform-method-is-equal-approx"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_equal_approx ( <a href="#class-transform"><span class="std std-ref">Transform</span></a> transform )</p></h3> <p>Returns <code>true</code> if this transform and <code>transform</code> are approximately equal, by calling <code>is_equal_approx</code> on each component.</p>  <h3 id="class-transform-method-looking-at"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> looking_at ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> target, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> up )</p></h3> <p>Returns a copy of the transform rotated such that its -Z axis points towards the <code>target</code> position.</p> <p>The transform will first be rotated around the given <code>up</code> vector, and then fully aligned to the target by a further rotation around an axis perpendicular to both the <code>target</code> and <code>up</code> vectors.</p> <p>Operations take place in global space.</p>  <h3 id="class-transform-method-orthonormalized"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> orthonormalized ( )</p></h3> <p>Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1).</p>  <h3 id="class-transform-method-rotated"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> rotated ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle )</p></h3> <p>Returns a copy of the transform rotated around the given <code>axis</code> by the given <code>angle</code> (in radians), using matrix multiplication. The <code>axis</code> must be a normalized vector.</p>  <h3 id="class-transform-method-scaled"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> scaled ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> scale )</p></h3> <p>Returns a copy of the transform with its basis and origin scaled by the given <code>scale</code> factor, using matrix multiplication.</p>  <h3 id="class-transform-method-translated"><p><a href="#class-transform"><span class="std std-ref">Transform</span></a> translated ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> offset )</p></h3> <p>Returns a copy of the transform translated by the given <code>offset</code>, relative to the transform's basis vectors.</p> <p>Unlike <a href="#class-transform-method-rotated"><span class="std std-ref">rotated</span></a> and <a href="#class-transform-method-scaled"><span class="std std-ref">scaled</span></a>, this does not use matrix multiplication.</p>  <h3 id="class-transform-method-xform"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> xform ( <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v )</p></h3> <p>Transforms the given <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>, <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>, <a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a>, or <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> by this transform.</p>  <h3 id="class-transform-method-xform-inv"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> xform_inv ( <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v )</p></h3> <p>Inverse-transforms the given <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a>, <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a>, <a href="class_aabb.html#class-aabb"><span class="std std-ref">AABB</span></a>, or <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> by this transform, under the assumption that the transformation is composed of rotation and translation (no scaling). Equivalent to calling <code>inverse().xform(v)</code> on this transform. For affine transformations (e.g. with scaling) see <a href="#class-transform-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> method.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_transform.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_transform.html</a>
  </p>
</div>
