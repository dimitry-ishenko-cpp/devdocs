<h1 id="class-udpserver">UDPServer</h1> <p><strong>Inherits:</strong> <a href="class_reference.html#class-reference"><span class="std std-ref">Reference</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Helper class to implement a UDP server.</p> <section id="description"> <h2>Description</h2> <p>A simple server that opens a UDP socket and returns connected <a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a> upon receiving new packets. See also <a href="class_packetpeerudp.html#class-packetpeerudp-method-connect-to-host"><span class="std std-ref">PacketPeerUDP.connect_to_host</span></a>.</p> <p>After starting the server (<a href="#class-udpserver-method-listen"><span class="std std-ref">listen</span></a>), you will need to <a href="#class-udpserver-method-poll"><span class="std std-ref">poll</span></a> it at regular intervals (e.g. inside <a href="class_node.html#class-node-method-process"><span class="std std-ref">Node._process</span></a>) for it to process new packets, delivering them to the appropriate <a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a>, and taking new connections.</p> <p>Below a small example of how it can be used:</p> <pre data-language="gdscript"># server.gd
extends Node

var server := UDPServer.new()
var peers = []

func _ready():
    server.listen(4242)

func _process(delta):
    server.poll() # Important!
    if server.is_connection_available():
        var peer : PacketPeerUDP = server.take_connection()
        var pkt = peer.get_packet()
        print("Accepted peer: %s:%s" % [peer.get_packet_ip(), peer.get_packet_port()])
        print("Received data: %s" % [pkt.get_string_from_utf8()])
        # Reply so it knows we received the message.
        peer.put_packet(pkt)
        # Keep a reference so we can keep contacting the remote peer.
        peers.append(peer)

    for i in range(0, peers.size()):
        pass # Do something with the connected peers.
</pre> <pre data-language="gdscript"># client.gd
extends Node

var udp := PacketPeerUDP.new()
var connected = false

func _ready():
    udp.connect_to_host("127.0.0.1", 4242)

func _process(delta):
    if !connected:
        # Try to contact server
        udp.put_packet("The answer is... 42!".to_utf8())
    if udp.get_available_packet_count() &gt; 0:
        print("Connected: %s" % udp.get_packet().get_string_from_utf8())
        connected = true
</pre> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-udpserver-property-max-pending-connections"><span class="std std-ref">max_pending_connections</span></a></p></td> <td><p><code>16</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-udpserver-method-is-connection-available"><span class="std std-ref">is_connection_available</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-udpserver-method-is-listening"><span class="std std-ref">is_listening</span></a> <strong>(</strong> <strong>)</strong> <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></td> </tr> <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-udpserver-method-listen"><span class="std std-ref">listen</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> port, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> bind_address="*" <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a></p></td> <td><p><a href="#class-udpserver-method-poll"><span class="std std-ref">poll</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-udpserver-method-stop"><span class="std std-ref">stop</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a></p></td> <td><p><a href="#class-udpserver-method-take-connection"><span class="std std-ref">take_connection</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr>  </table> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-udpserver-property-max-pending-connections"><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a> max_pending_connections</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>16</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_max_pending_connections(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_max_pending_connections()</p></td> </tr>  </table> <p>Define the maximum number of pending connections, during <a href="#class-udpserver-method-poll"><span class="std std-ref">poll</span></a>, any new pending connection exceeding that value will be automatically dropped. Setting this value to <code>0</code> effectively prevents any new pending connection to be accepted (e.g. when all your players have connected).</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-udpserver-method-is-connection-available"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_connection_available ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></h3> <p>Returns <code>true</code> if a packet with a new address/port combination was received on the socket.</p>  <h3 id="class-udpserver-method-is-listening"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_listening ( ) <abbr title="This method has no side effects. It doesn't modify any of the instance's member variables.">const</abbr></p></h3> <p>Returns <code>true</code> if the socket is open and listening on a port.</p>  <h3 id="class-udpserver-method-listen"><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> listen ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> port, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> bind_address="*" )</p></h3> <p>Starts the server by opening a UDP socket listening on the given port. You can optionally specify a <code>bind_address</code> to only listen for packets sent to that address. See also <a href="class_packetpeerudp.html#class-packetpeerudp-method-listen"><span class="std std-ref">PacketPeerUDP.listen</span></a>.</p>  <h3 id="class-udpserver-method-poll"><p><a href="class_%40globalscope.html#enum-globalscope-error"><span class="std std-ref">Error</span></a> poll ( )</p></h3> <p>Call this method at regular intervals (e.g. inside <a href="class_node.html#class-node-method-process"><span class="std std-ref">Node._process</span></a>) to process new packets. And packet from known address/port pair will be delivered to the appropriate <a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a>, any packet received from an unknown address/port pair will be added as a pending connection (see <a href="#class-udpserver-method-is-connection-available"><span class="std std-ref">is_connection_available</span></a>, <a href="#class-udpserver-method-take-connection"><span class="std std-ref">take_connection</span></a>). The maximum number of pending connection is defined via <a href="#class-udpserver-property-max-pending-connections"><span class="std std-ref">max_pending_connections</span></a>.</p>  <h3 id="class-udpserver-method-stop"><p>void stop ( )</p></h3> <p>Stops the server, closing the UDP socket if open. Will close all connected <a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a> accepted via <a href="#class-udpserver-method-take-connection"><span class="std std-ref">take_connection</span></a> (remote peers will not be notified).</p>  <h3 id="class-udpserver-method-take-connection"><p><a href="class_packetpeerudp.html#class-packetpeerudp"><span class="std std-ref">PacketPeerUDP</span></a> take_connection ( )</p></h3> <p>Returns the first pending connection (connected to the appropriate address/port). Will return <code>null</code> if no new connection is available. See also <a href="#class-udpserver-method-is-connection-available"><span class="std std-ref">is_connection_available</span></a>, <a href="class_packetpeerudp.html#class-packetpeerudp-method-connect-to-host"><span class="std std-ref">PacketPeerUDP.connect_to_host</span></a>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_udpserver.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_udpserver.html</a>
  </p>
</div>
