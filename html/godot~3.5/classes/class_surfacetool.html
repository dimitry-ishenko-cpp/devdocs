<h1 id="class-surfacetool">SurfaceTool</h1> <p><strong>Inherits:</strong> <a href="class_reference.html#class-reference"><span class="std std-ref">Reference</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>Helper tool to create geometry.</p> <section id="description"> <h2>Description</h2> <p>The <code>SurfaceTool</code> is used to construct a <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> by specifying vertex attributes individually. It can be used to construct a <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> from a script. All properties except indices need to be added before calling <a href="#class-surfacetool-method-add-vertex"><span class="std std-ref">add_vertex</span></a>. For example, to add vertex colors and UVs:</p> <pre data-language="gdscript">var st = SurfaceTool.new()
st.begin(Mesh.PRIMITIVE_TRIANGLES)
st.add_color(Color(1, 0, 0))
st.add_uv(Vector2(0, 0))
st.add_vertex(Vector3(0, 0, 0))
</pre> <p>The above <code>SurfaceTool</code> now contains one vertex of a triangle which has a UV coordinate and a specified <a href="class_color.html#class-color"><span class="std std-ref">Color</span></a>. If another vertex were added without calling <a href="#class-surfacetool-method-add-uv"><span class="std std-ref">add_uv</span></a> or <a href="#class-surfacetool-method-add-color"><span class="std std-ref">add_color</span></a>, then the last values would be used.</p> <p>Vertex attributes must be passed <strong>before</strong> calling <a href="#class-surfacetool-method-add-vertex"><span class="std std-ref">add_vertex</span></a>. Failure to do so will result in an error when committing the vertex information to a mesh.</p> <p>Additionally, the attributes used before the first vertex is added determine the format of the mesh. For example, if you only add UVs to the first vertex, you cannot add color to any of the subsequent vertices.</p> <p>See also <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a>, <a href="class_immediategeometry.html#class-immediategeometry"><span class="std std-ref">ImmediateGeometry</span></a> and <a href="class_meshdatatool.html#class-meshdatatool"><span class="std std-ref">MeshDataTool</span></a> for procedural geometry generation.</p> <p><strong>Note:</strong> Godot uses clockwise <a href="https://learnopengl.com/Advanced-OpenGL/Face-culling">winding order</a> for front faces of triangle primitive modes.</p> </section> <section id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://godotengine.org/asset-library/asset/676">3D Voxel Demo</a></li> </ul> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-bones"><span class="std std-ref">add_bones</span></a> <strong>(</strong> <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> bones <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-color"><span class="std std-ref">add_color</span></a> <strong>(</strong> <a href="class_color.html#class-color"><span class="std std-ref">Color</span></a> color <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-index"><span class="std std-ref">add_index</span></a> <strong>(</strong> <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> index <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-normal"><span class="std std-ref">add_normal</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> normal <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-smooth-group"><span class="std std-ref">add_smooth_group</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> smooth <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-tangent"><span class="std std-ref">add_tangent</span></a> <strong>(</strong> <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a> tangent <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-triangle-fan"><span class="std std-ref">add_triangle_fan</span></a> <strong>(</strong> <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> vertices, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> uvs=PoolVector2Array( ), <a href="class_poolcolorarray.html#class-poolcolorarray"><span class="std std-ref">PoolColorArray</span></a> colors=PoolColorArray( ), <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> uv2s=PoolVector2Array( ), <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> normals=PoolVector3Array( ), <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> tangents=[ ] <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-uv"><span class="std std-ref">add_uv</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> uv <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-uv2"><span class="std std-ref">add_uv2</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> uv2 <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-vertex"><span class="std std-ref">add_vertex</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> vertex <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-add-weights"><span class="std std-ref">add_weights</span></a> <strong>(</strong> <a href="class_poolrealarray.html#class-poolrealarray"><span class="std std-ref">PoolRealArray</span></a> weights <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-append-from"><span class="std std-ref">append_from</span></a> <strong>(</strong> <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface, <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a> transform <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-begin"><span class="std std-ref">begin</span></a> <strong>(</strong> <a href="class_mesh.html#enum-mesh-primitivetype"><span class="std std-ref">PrimitiveType</span></a> primitive <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-clear"><span class="std std-ref">clear</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a></p></td> <td><p><a href="#class-surfacetool-method-commit"><span class="std std-ref">commit</span></a> <strong>(</strong> <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> existing=null, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> flags=2194432 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a></p></td> <td><p><a href="#class-surfacetool-method-commit-to-arrays"><span class="std std-ref">commit_to_arrays</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-create-from"><span class="std std-ref">create_from</span></a> <strong>(</strong> <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-create-from-blend-shape"><span class="std std-ref">create_from_blend_shape</span></a> <strong>(</strong> <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> blend_shape <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-deindex"><span class="std std-ref">deindex</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-generate-normals"><span class="std std-ref">generate_normals</span></a> <strong>(</strong> <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> flip=false <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-generate-tangents"><span class="std std-ref">generate_tangents</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-index"><span class="std std-ref">index</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-surfacetool-method-set-material"><span class="std std-ref">set_material</span></a> <strong>(</strong> <a href="class_material.html#class-material"><span class="std std-ref">Material</span></a> material <strong>)</strong></p></td> </tr>  </table> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-surfacetool-method-add-bones"><p>void add_bones ( <a href="class_poolintarray.html#class-poolintarray"><span class="std std-ref">PoolIntArray</span></a> bones )</p></h3> <p>Specifies an array of bones to use for the <em>next</em> vertex. <code>bones</code> must contain 4 integers.</p>  <h3 id="class-surfacetool-method-add-color"><p>void add_color ( <a href="class_color.html#class-color"><span class="std std-ref">Color</span></a> color )</p></h3> <p>Specifies a <a href="class_color.html#class-color"><span class="std std-ref">Color</span></a> to use for the <em>next</em> vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p> <p><strong>Note:</strong> The material must have <a href="class_spatialmaterial.html#class-spatialmaterial-property-vertex-color-use-as-albedo"><span class="std std-ref">SpatialMaterial.vertex_color_use_as_albedo</span></a> enabled for the vertex color to be visible.</p>  <h3 id="class-surfacetool-method-add-index"><p>void add_index ( <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> index )</p></h3> <p>Adds an index to index array if you are using indexed vertices. Does not need to be called before adding vertices.</p>  <h3 id="class-surfacetool-method-add-normal"><p>void add_normal ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> normal )</p></h3> <p>Specifies a normal to use for the <em>next</em> vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p>  <h3 id="class-surfacetool-method-add-smooth-group"><p>void add_smooth_group ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> smooth )</p></h3> <p>Specifies whether the current vertex (if using only vertex arrays) or current index (if also using index arrays) should use smooth normals for normal calculation.</p>  <h3 id="class-surfacetool-method-add-tangent"><p>void add_tangent ( <a href="class_plane.html#class-plane"><span class="std std-ref">Plane</span></a> tangent )</p></h3> <p>Specifies a tangent to use for the <em>next</em> vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p>  <h3 id="class-surfacetool-method-add-triangle-fan"><p>void add_triangle_fan ( <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> vertices, <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> uvs=PoolVector2Array( ), <a href="class_poolcolorarray.html#class-poolcolorarray"><span class="std std-ref">PoolColorArray</span></a> colors=PoolColorArray( ), <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> uv2s=PoolVector2Array( ), <a href="class_poolvector3array.html#class-poolvector3array"><span class="std std-ref">PoolVector3Array</span></a> normals=PoolVector3Array( ), <a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> tangents=[ ] )</p></h3> <p>Inserts a triangle fan made of array data into <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> being constructed.</p> <p>Requires the primitive type be set to <a href="class_mesh.html#class-mesh-constant-primitive-triangles"><span class="std std-ref">Mesh.PRIMITIVE_TRIANGLES</span></a>.</p>  <h3 id="class-surfacetool-method-add-uv"><p>void add_uv ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> uv )</p></h3> <p>Specifies a set of UV coordinates to use for the <em>next</em> vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p>  <h3 id="class-surfacetool-method-add-uv2"><p>void add_uv2 ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> uv2 )</p></h3> <p>Specifies an optional second set of UV coordinates to use for the <em>next</em> vertex. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p>  <h3 id="class-surfacetool-method-add-vertex"><p>void add_vertex ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> vertex )</p></h3> <p>Specifies the position of current vertex. Should be called after specifying other vertex properties (e.g. Color, UV).</p>  <h3 id="class-surfacetool-method-add-weights"><p>void add_weights ( <a href="class_poolrealarray.html#class-poolrealarray"><span class="std std-ref">PoolRealArray</span></a> weights )</p></h3> <p>Specifies weight values to use for the <em>next</em> vertex. <code>weights</code> must contain 4 values. If every vertex needs to have this information set and you fail to submit it for the first vertex, this information may not be used at all.</p>  <h3 id="class-surfacetool-method-append-from"><p>void append_from ( <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface, <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a> transform )</p></h3> <p>Append vertices from a given <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> surface onto the current vertex array with specified <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a>.</p> <p><strong>Note:</strong> Using <a href="#class-surfacetool-method-append-from"><span class="std std-ref">append_from</span></a> on a <a href="class_thread.html#class-thread"><span class="std std-ref">Thread</span></a> is much slower as the GPU must communicate data back to the CPU, while also causing the main thread to stall (as OpenGL is not thread-safe). Consider requesting a copy of the mesh, converting it to an <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> and adding vertices manually instead.</p>  <h3 id="class-surfacetool-method-begin"><p>void begin ( <a href="class_mesh.html#enum-mesh-primitivetype"><span class="std std-ref">PrimitiveType</span></a> primitive )</p></h3> <p>Called before adding any vertices. Takes the primitive type as an argument (e.g. <a href="class_mesh.html#class-mesh-constant-primitive-triangles"><span class="std std-ref">Mesh.PRIMITIVE_TRIANGLES</span></a>).</p>  <h3 id="class-surfacetool-method-clear"><p>void clear ( )</p></h3> <p>Clear all information passed into the surface tool so far.</p>  <h3 id="class-surfacetool-method-commit"><p><a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> commit ( <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> existing=null, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> flags=2194432 )</p></h3> <p>Returns a constructed <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> from current information passed in. If an existing <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> is passed in as an argument, will add an extra surface to the existing <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a>.</p> <p>Default flag is <a href="class_mesh.html#class-mesh-constant-array-compress-default"><span class="std std-ref">Mesh.ARRAY_COMPRESS_DEFAULT</span></a> if compression is enabled. If compression is disabled the default flag is <a href="class_mesh.html#class-mesh-constant-array-flag-use-octahedral-compression"><span class="std std-ref">Mesh.ARRAY_FLAG_USE_OCTAHEDRAL_COMPRESSION</span></a>. See <code>ARRAY_COMPRESS_*</code> constants in <a href="class_mesh.html#enum-mesh-arrayformat"><span class="std std-ref">ArrayFormat</span></a> for other flags.</p>  <h3 id="class-surfacetool-method-commit-to-arrays"><p><a href="class_array.html#class-array"><span class="std std-ref">Array</span></a> commit_to_arrays ( )</p></h3> <p>Commits the data to the same format used by <a href="class_arraymesh.html#class-arraymesh-method-add-surface-from-arrays"><span class="std std-ref">ArrayMesh.add_surface_from_arrays</span></a>. This way you can further process the mesh data using the <a href="class_arraymesh.html#class-arraymesh"><span class="std std-ref">ArrayMesh</span></a> API.</p>  <h3 id="class-surfacetool-method-create-from"><p>void create_from ( <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface )</p></h3> <p>Creates a vertex array from an existing <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a>.</p>  <h3 id="class-surfacetool-method-create-from-blend-shape"><p>void create_from_blend_shape ( <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> existing, <a href="class_int.html#class-int"><span class="std std-ref">int</span></a> surface, <a href="class_string.html#class-string"><span class="std std-ref">String</span></a> blend_shape )</p></h3> <p>Creates a vertex array from the specified blend shape of an existing <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a>. This can be used to extract a specific pose from a blend shape.</p>  <h3 id="class-surfacetool-method-deindex"><p>void deindex ( )</p></h3> <p>Removes the index array by expanding the vertex array.</p>  <h3 id="class-surfacetool-method-generate-normals"><p>void generate_normals ( <a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> flip=false )</p></h3> <p>Generates normals from vertices so you do not have to do it manually. If <code>flip</code> is <code>true</code>, the resulting normals will be inverted. <a href="#class-surfacetool-method-generate-normals"><span class="std std-ref">generate_normals</span></a> should be called <em>after</em> generating geometry and <em>before</em> committing the mesh using <a href="#class-surfacetool-method-commit"><span class="std std-ref">commit</span></a> or <a href="#class-surfacetool-method-commit-to-arrays"><span class="std std-ref">commit_to_arrays</span></a>. For correct display of normal-mapped surfaces, you will also have to generate tangents using <a href="#class-surfacetool-method-generate-tangents"><span class="std std-ref">generate_tangents</span></a>.</p> <p><strong>Note:</strong> <a href="#class-surfacetool-method-generate-normals"><span class="std std-ref">generate_normals</span></a> only works if the primitive type to be set to <a href="class_mesh.html#class-mesh-constant-primitive-triangles"><span class="std std-ref">Mesh.PRIMITIVE_TRIANGLES</span></a>.</p>  <h3 id="class-surfacetool-method-generate-tangents"><p>void generate_tangents ( )</p></h3> <p>Generates a tangent vector for each vertex. Requires that each vertex have UVs and normals set already (see <a href="#class-surfacetool-method-generate-normals"><span class="std std-ref">generate_normals</span></a>).</p>  <h3 id="class-surfacetool-method-index"><p>void index ( )</p></h3> <p>Shrinks the vertex array by creating an index array. This can improve performance by avoiding vertex reuse.</p>  <h3 id="class-surfacetool-method-set-material"><p>void set_material ( <a href="class_material.html#class-material"><span class="std std-ref">Material</span></a> material )</p></h3> <p>Sets <a href="class_material.html#class-material"><span class="std std-ref">Material</span></a> to be used by the <a href="class_mesh.html#class-mesh"><span class="std std-ref">Mesh</span></a> you are constructing.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_surfacetool.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_surfacetool.html</a>
  </p>
</div>
