<h1 id="class-transform2d">Transform2D</h1> <p>2D transformation (2×3 matrix).</p> <section id="description"> <h2>Description</h2> <p>2×3 matrix (2 rows, 3 columns) used for 2D linear transformations. It can represent transformations such as translation, rotation, or scaling. It consists of three <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> values: <a href="#class-transform2d-property-x"><span class="std std-ref">x</span></a>, <a href="#class-transform2d-property-y"><span class="std std-ref">y</span></a>, and the <a href="#class-transform2d-property-origin"><span class="std std-ref">origin</span></a>.</p> <p>For more information, read the "Matrices and transforms" documentation article.</p> </section> <section id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/index.html"><span class="doc">Math tutorial index</span></a></li> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/matrices_and_transforms.html"><span class="doc">Matrices and transforms</span></a></li> <li><a href="https://godotengine.org/asset-library/asset/584">Matrix Transform Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/583">2.5D Demo</a></li> </ul> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-property-origin"><span class="std std-ref">origin</span></a></p></td> <td><p><code>Vector2( 0, 0 )</code></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-property-x"><span class="std std-ref">x</span></a></p></td> <td><p><code>Vector2( 1, 0 )</code></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-property-y"><span class="std std-ref">y</span></a></p></td> <td><p><code>Vector2( 0, 1 )</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>(</strong> <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> x_axis, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> y_axis, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> origin <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> rotation, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> position <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-method-basis-xform"><span class="std std-ref">basis_xform</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> v <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-method-basis-xform-inv"><span class="std std-ref">basis_xform_inv</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> v <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-method-get-origin"><span class="std std-ref">get_origin</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-transform2d-method-get-rotation"><span class="std std-ref">get_rotation</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a></p></td> <td><p><a href="#class-transform2d-method-get-scale"><span class="std std-ref">get_scale</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-interpolate-with"><span class="std std-ref">interpolate_with</span></a> <strong>(</strong> <a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> transform, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-inverse"><span class="std std-ref">inverse</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-transform2d-method-is-equal-approx"><span class="std std-ref">is_equal_approx</span></a> <strong>(</strong> <a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> transform <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-orthonormalized"><span class="std std-ref">orthonormalized</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-rotated"><span class="std std-ref">rotated</span></a> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-scaled"><span class="std std-ref">scaled</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> scale <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a></p></td> <td><p><a href="#class-transform2d-method-translated"><span class="std std-ref">translated</span></a> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> offset <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-transform2d-method-xform"><span class="std std-ref">xform</span></a> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a></p></td> <td><p><a href="#class-transform2d-method-xform-inv"><span class="std std-ref">xform_inv</span></a> <strong>(</strong> <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v <strong>)</strong></p></td> </tr>  </table> </section> <section id="constants"> <h2>Constants</h2> <ul class="simple" id="class-transform2d-constant-flip-y"> <li>
<strong>IDENTITY</strong> = <strong>Transform2D( 1, 0, 0, 1, 0, 0 )</strong> --- The identity <code>Transform2D</code> with no translation, rotation or scaling applied. When applied to other data structures, <a href="#class-transform2d-constant-identity"><span class="std std-ref">IDENTITY</span></a> performs no transformation.</li> <li>
<strong>FLIP_X</strong> = <strong>Transform2D( -1, 0, 0, 1, 0, 0 )</strong> --- The <code>Transform2D</code> that will flip something along the X axis.</li> <li>
<strong>FLIP_Y</strong> = <strong>Transform2D( 1, 0, 0, -1, 0, 0 )</strong> --- The <code>Transform2D</code> that will flip something along the Y axis.</li> </ul> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-transform2d-property-origin"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> origin</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector2( 0, 0 )</code></p></td> </tr>  </table> <p>The origin vector (column 2, the third column). Equivalent to array index <code>2</code>. The origin vector represents translation.</p>  <h3 id="class-transform2d-property-x"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> x</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector2( 1, 0 )</code></p></td> </tr>  </table> <p>The basis matrix's X vector (column 0). Equivalent to array index <code>0</code>.</p>  <h3 id="class-transform2d-property-y"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> y</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector2( 0, 1 )</code></p></td> </tr>  </table> <p>The basis matrix's Y vector (column 1). Equivalent to array index <code>1</code>.</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-transform2d-method-transform2d"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> Transform2D ( <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a> from )</p></h3> <p>Constructs the transform from a 3D <a href="class_transform.html#class-transform"><span class="std std-ref">Transform</span></a>.</p>  <ul class="simple"> <li>
<a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>Transform2D</strong> <strong>(</strong> <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> x_axis, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> y_axis, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> origin <strong>)</strong>
</li> </ul> <p>Constructs the transform from 3 <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> values representing <a href="#class-transform2d-property-x"><span class="std std-ref">x</span></a>, <a href="#class-transform2d-property-y"><span class="std std-ref">y</span></a>, and the <a href="#class-transform2d-property-origin"><span class="std std-ref">origin</span></a> (the three column vectors).</p>  <ul class="simple"> <li>
<a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> <strong>Transform2D</strong> <strong>(</strong> <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> rotation, <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> position <strong>)</strong>
</li> </ul> <p>Constructs the transform from a given angle (in radians) and position.</p>  <h3 id="class-transform2d-method-affine-inverse"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> affine_inverse ( )</p></h3> <p>Returns the inverse of the transform, under the assumption that the transformation is composed of rotation, scaling and translation.</p>  <h3 id="class-transform2d-method-basis-xform"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> basis_xform ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> v )</p></h3> <p>Returns a vector transformed (multiplied) by the basis matrix.</p> <p>This method does not account for translation (the origin vector).</p>  <h3 id="class-transform2d-method-basis-xform-inv"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> basis_xform_inv ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> v )</p></h3> <p>Returns a vector transformed (multiplied) by the inverse basis matrix.</p> <p>This method does not account for translation (the origin vector).</p>  <h3 id="class-transform2d-method-get-origin"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> get_origin ( )</p></h3> <p>Returns the transform's origin (translation).</p>  <h3 id="class-transform2d-method-get-rotation"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> get_rotation ( )</p></h3> <p>Returns the transform's rotation (in radians).</p>  <h3 id="class-transform2d-method-get-scale"><p><a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> get_scale ( )</p></h3> <p>Returns the scale.</p>  <h3 id="class-transform2d-method-interpolate-with"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> interpolate_with ( <a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> transform, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight )</p></h3> <p>Returns a transform interpolated between this transform and another by a given <code>weight</code> (on the range of 0.0 to 1.0).</p>  <h3 id="class-transform2d-method-inverse"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> inverse ( )</p></h3> <p>Returns the inverse of the transform, under the assumption that the transformation is composed of rotation and translation (no scaling, use <a href="#class-transform2d-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> for transforms with scaling).</p>  <h3 id="class-transform2d-method-is-equal-approx"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_equal_approx ( <a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> transform )</p></h3> <p>Returns <code>true</code> if this transform and <code>transform</code> are approximately equal, by calling <code>is_equal_approx</code> on each component.</p>  <h3 id="class-transform2d-method-orthonormalized"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> orthonormalized ( )</p></h3> <p>Returns the transform with the basis orthogonal (90 degrees), and normalized axis vectors (scale of 1 or -1).</p>  <h3 id="class-transform2d-method-rotated"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> rotated ( <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle )</p></h3> <p>Returns a copy of the transform rotated by the given <code>angle</code> (in radians), using matrix multiplication.</p>  <h3 id="class-transform2d-method-scaled"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> scaled ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> scale )</p></h3> <p>Returns a copy of the transform scaled by the given <code>scale</code> factor, using matrix multiplication.</p> <p><strong>Note:</strong> Negative X scales in 2D are not decomposable from the transformation matrix. Due to the way scale is represented with transformation matrices in Godot, negative scales on the X axis will be changed to negative scales on the Y axis and a rotation of 180 degrees when decomposed.</p>  <h3 id="class-transform2d-method-translated"><p><a href="#class-transform2d"><span class="std std-ref">Transform2D</span></a> translated ( <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a> offset )</p></h3> <p>Returns a copy of the transform translated by the given <code>offset</code>, relative to the transform's basis vectors.</p> <p>Unlike <a href="#class-transform2d-method-rotated"><span class="std std-ref">rotated</span></a> and <a href="#class-transform2d-method-scaled"><span class="std std-ref">scaled</span></a>, this does not use matrix multiplication.</p>  <h3 id="class-transform2d-method-xform"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> xform ( <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v )</p></h3> <p>Transforms the given <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>, <a href="class_rect2.html#class-rect2"><span class="std std-ref">Rect2</span></a>, or <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> by this transform.</p>  <h3 id="class-transform2d-method-xform-inv"><p><a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> xform_inv ( <a href="class_variant.html#class-variant"><span class="std std-ref">Variant</span></a> v )</p></h3> <p>Inverse-transforms the given <a href="class_vector2.html#class-vector2"><span class="std std-ref">Vector2</span></a>, <a href="class_rect2.html#class-rect2"><span class="std std-ref">Rect2</span></a>, or <a href="class_poolvector2array.html#class-poolvector2array"><span class="std std-ref">PoolVector2Array</span></a> by this transform, under the assumption that the transformation is composed of rotation and translation (no scaling). Equivalent to calling <code>inverse().xform(v)</code> on this transform. For affine transformations (e.g. with scaling) see <a href="#class-transform2d-method-affine-inverse"><span class="std std-ref">affine_inverse</span></a> method.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_transform2d.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_transform2d.html</a>
  </p>
</div>
