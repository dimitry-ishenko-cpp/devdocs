<h1 id="class-basis">Basis</h1> <p>3×3 matrix datatype.</p> <section id="description"> <h2>Description</h2> <p>3×3 matrix used for 3D rotation and scale. Almost always used as an orthogonal basis for a Transform.</p> <p>Contains 3 vector fields X, Y and Z as its columns, which are typically interpreted as the local basis vectors of a transformation. For such use, it is composed of a scaling and a rotation matrix, in that order (M = R.S).</p> <p>Can also be accessed as array of 3D vectors. These vectors are normally orthogonal to each other, but are not necessarily normalized (due to scaling).</p> <p>For more information, read the "Matrices and transforms" documentation article.</p> </section> <section id="tutorials"> <h2>Tutorials</h2> <ul class="simple"> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/index.html"><span class="doc">Math tutorial index</span></a></li> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/math/matrices_and_transforms.html"><span class="doc">Matrices and transforms</span></a></li> <li><a href="https://docs.godotengine.org/en/3.5/tutorials/3d/using_transforms.html"><span class="doc">Using 3D transforms</span></a></li> <li><a href="https://godotengine.org/asset-library/asset/584">Matrix Transform Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/125">3D Platformer Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/676">3D Voxel Demo</a></li> <li><a href="https://godotengine.org/asset-library/asset/583">2.5D Demo</a></li> </ul> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-property-x"><span class="std std-ref">x</span></a></p></td> <td><p><code>Vector3( 1, 0, 0 )</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-property-y"><span class="std std-ref">y</span></a></p></td> <td><p><code>Vector3( 0, 1, 0 )</code></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-property-z"><span class="std std-ref">z</span></a></p></td> <td><p><code>Vector3( 0, 0, 1 )</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-basis"><span class="std std-ref">Basis</span></a> <strong>(</strong> <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-basis"><span class="std std-ref">Basis</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-basis"><span class="std std-ref">Basis</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-basis"><span class="std std-ref">Basis</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> x_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> y_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> z_axis <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-basis-method-determinant"><span class="std std-ref">determinant</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-method-get-euler"><span class="std std-ref">get_euler</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-basis-method-get-orthogonal-index"><span class="std std-ref">get_orthogonal_index</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a></p></td> <td><p><a href="#class-basis-method-get-rotation-quat"><span class="std std-ref">get_rotation_quat</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-method-get-scale"><span class="std std-ref">get_scale</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-inverse"><span class="std std-ref">inverse</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-basis-method-is-equal-approx"><span class="std std-ref">is_equal_approx</span></a> <strong>(</strong> <a href="#class-basis"><span class="std std-ref">Basis</span></a> b, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> epsilon=1e-05 <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-orthonormalized"><span class="std std-ref">orthonormalized</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-rotated"><span class="std std-ref">rotated</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-scaled"><span class="std std-ref">scaled</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> scale <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-slerp"><span class="std std-ref">slerp</span></a> <strong>(</strong> <a href="#class-basis"><span class="std std-ref">Basis</span></a> to, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-basis-method-tdotx"><span class="std std-ref">tdotx</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-basis-method-tdoty"><span class="std std-ref">tdoty</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-basis-method-tdotz"><span class="std std-ref">tdotz</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="#class-basis"><span class="std std-ref">Basis</span></a></p></td> <td><p><a href="#class-basis-method-transposed"><span class="std std-ref">transposed</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-method-xform"><span class="std std-ref">xform</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> v <strong>)</strong></p></td> </tr> <tr>
<td><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a></p></td> <td><p><a href="#class-basis-method-xform-inv"><span class="std std-ref">xform_inv</span></a> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> v <strong>)</strong></p></td> </tr>  </table> </section> <section id="constants"> <h2>Constants</h2> <h3 id="class-basis-constant-flip-z"><p>IDENTITY = Basis( 1, 0, 0, 0, 1, 0, 0, 0, 1 ) --- The identity basis, with no rotation or scaling applied.</p></h3> <p>This is identical to calling <code>Basis()</code> without any parameters. This constant can be used to make your code clearer, and for consistency with C#.</p> <ul class="simple"> <li>
<strong>FLIP_X</strong> = <strong>Basis( -1, 0, 0, 0, 1, 0, 0, 0, 1 )</strong> --- The basis that will flip something along the X axis when used in a transformation.</li> <li>
<strong>FLIP_Y</strong> = <strong>Basis( 1, 0, 0, 0, -1, 0, 0, 0, 1 )</strong> --- The basis that will flip something along the Y axis when used in a transformation.</li> <li>
<strong>FLIP_Z</strong> = <strong>Basis( 1, 0, 0, 0, 1, 0, 0, 0, -1 )</strong> --- The basis that will flip something along the Z axis when used in a transformation.</li> </ul> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-basis-property-x"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> x</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector3( 1, 0, 0 )</code></p></td> </tr>  </table> <p>The basis matrix's X vector (column 0). Equivalent to array index <code>0</code>.</p>  <h3 id="class-basis-property-y"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> y</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector3( 0, 1, 0 )</code></p></td> </tr>  </table> <p>The basis matrix's Y vector (column 1). Equivalent to array index <code>1</code>.</p>  <h3 id="class-basis-property-z"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> z</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>Vector3( 0, 0, 1 )</code></p></td> </tr>  </table> <p>The basis matrix's Z vector (column 2). Equivalent to array index <code>2</code>.</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-basis-method-basis"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> Basis ( <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> from )</p></h3> <p>Constructs a pure rotation basis matrix from the given quaternion.</p>  <ul class="simple"> <li>
<a href="#class-basis"><span class="std std-ref">Basis</span></a> <strong>Basis</strong> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> from <strong>)</strong>
</li> </ul> <p>Constructs a pure rotation basis matrix from the given Euler angles (in the YXZ convention: when *composing*, first Y, then X, and Z last), given in the vector format as (X angle, Y angle, Z angle).</p> <p>Consider using the <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> constructor instead, which uses a quaternion instead of Euler angles.</p>  <ul class="simple"> <li>
<a href="#class-basis"><span class="std std-ref">Basis</span></a> <strong>Basis</strong> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle <strong>)</strong>
</li> </ul> <p>Constructs a pure rotation basis matrix, rotated around the given <code>axis</code> by <code>angle</code> (in radians). The axis must be a normalized vector.</p>  <ul class="simple"> <li>
<a href="#class-basis"><span class="std std-ref">Basis</span></a> <strong>Basis</strong> <strong>(</strong> <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> x_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> y_axis, <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> z_axis <strong>)</strong>
</li> </ul> <p>Constructs a basis matrix from 3 axis vectors (matrix columns).</p>  <h3 id="class-basis-method-determinant"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> determinant ( )</p></h3> <p>Returns the determinant of the basis matrix. If the basis is uniformly scaled, its determinant is the square of the scale.</p> <p>A negative determinant means the basis has a negative scale. A zero determinant means the basis isn't invertible, and is usually considered invalid.</p>  <h3 id="class-basis-method-get-euler"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> get_euler ( )</p></h3> <p>Returns the basis's rotation in the form of Euler angles (in the YXZ convention: when decomposing, first Z, then X, and Y last). The returned vector contains the rotation angles in the format (X angle, Y angle, Z angle).</p> <p>Consider using the <a href="#class-basis-method-get-rotation-quat"><span class="std std-ref">get_rotation_quat</span></a> method instead, which returns a <a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> quaternion instead of Euler angles.</p>  <h3 id="class-basis-method-get-orthogonal-index"><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a> get_orthogonal_index ( )</p></h3> <p>This function considers a discretization of rotations into 24 points on unit sphere, lying along the vectors (x,y,z) with each component being either -1, 0, or 1, and returns the index of the point best representing the orientation of the object. It is mainly used by the <a href="class_gridmap.html#class-gridmap"><span class="std std-ref">GridMap</span></a> editor. For further details, refer to the Godot source code.</p>  <h3 id="class-basis-method-get-rotation-quat"><p><a href="class_quat.html#class-quat"><span class="std std-ref">Quat</span></a> get_rotation_quat ( )</p></h3> <p>Returns the basis's rotation in the form of a quaternion. See <a href="#class-basis-method-get-euler"><span class="std std-ref">get_euler</span></a> if you need Euler angles, but keep in mind quaternions should generally be preferred to Euler angles.</p>  <h3 id="class-basis-method-get-scale"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> get_scale ( )</p></h3> <p>Assuming that the matrix is the combination of a rotation and scaling, return the absolute value of scaling factors along each axis.</p>  <h3 id="class-basis-method-inverse"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> inverse ( )</p></h3> <p>Returns the inverse of the matrix.</p>  <h3 id="class-basis-method-is-equal-approx"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> is_equal_approx ( <a href="#class-basis"><span class="std std-ref">Basis</span></a> b, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> epsilon=1e-05 )</p></h3> <p>Returns <code>true</code> if this basis and <code>b</code> are approximately equal, by calling <code>is_equal_approx</code> on each component.</p> <p><strong>Note:</strong> For complicated reasons, the epsilon argument is always discarded. Don't use the epsilon argument, it does nothing.</p>  <h3 id="class-basis-method-orthonormalized"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> orthonormalized ( )</p></h3> <p>Returns the orthonormalized version of the matrix (useful to call from time to time to avoid rounding error for orthogonal matrices). This performs a Gram-Schmidt orthonormalization on the basis of the matrix.</p>  <h3 id="class-basis-method-rotated"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> rotated ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> axis, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> angle )</p></h3> <p>Introduce an additional rotation around the given axis by <code>angle</code> (in radians). The axis must be a normalized vector.</p>  <h3 id="class-basis-method-scaled"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> scaled ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> scale )</p></h3> <p>Introduce an additional scaling specified by the given 3D scaling factor.</p>  <h3 id="class-basis-method-slerp"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> slerp ( <a href="#class-basis"><span class="std std-ref">Basis</span></a> to, <a href="class_float.html#class-float"><span class="std std-ref">float</span></a> weight )</p></h3> <p>Assuming that the matrix is a proper rotation matrix, slerp performs a spherical-linear interpolation with another rotation matrix.</p>  <h3 id="class-basis-method-tdotx"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> tdotx ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with )</p></h3> <p>Transposed dot product with the X axis of the matrix.</p>  <h3 id="class-basis-method-tdoty"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> tdoty ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with )</p></h3> <p>Transposed dot product with the Y axis of the matrix.</p>  <h3 id="class-basis-method-tdotz"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> tdotz ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> with )</p></h3> <p>Transposed dot product with the Z axis of the matrix.</p>  <h3 id="class-basis-method-transposed"><p><a href="#class-basis"><span class="std std-ref">Basis</span></a> transposed ( )</p></h3> <p>Returns the transposed version of the matrix.</p>  <h3 id="class-basis-method-xform"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> xform ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> v )</p></h3> <p>Returns a vector transformed (multiplied) by the matrix.</p>  <h3 id="class-basis-method-xform-inv"><p><a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> xform_inv ( <a href="class_vector3.html#class-vector3"><span class="std std-ref">Vector3</span></a> v )</p></h3> <p>Returns a vector transformed (multiplied) by the transposed basis matrix.</p> <p><strong>Note:</strong> This results in a multiplication by the inverse of the matrix only if it represents a rotation-reflection.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_basis.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_basis.html</a>
  </p>
</div>
