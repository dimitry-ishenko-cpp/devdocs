<h1 id="class-roommanager">RoomManager</h1> <p><strong>Inherits:</strong> <a href="class_spatial.html#class-spatial"><span class="std std-ref">Spatial</span></a> <strong>&lt;</strong> <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> <strong>&lt;</strong> <a href="class_object.html#class-object"><span class="std std-ref">Object</span></a></p> <p>The RoomManager node is used to control the portal culling system.</p> <section id="description"> <h2>Description</h2> <p>In order to utilize the portal occlusion culling system, you must build your level using <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s and <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s. Before these can be used at runtime, they must undergo a short conversion process to build the <code>room graph</code>, runtime data needed for portal culling. The <code>room graph</code> is controlled by the <code>RoomManager</code> node, and the <code>RoomManager</code> also contains settings that are common throughout the portal system.</p> </section> <section id="properties"> <h2>Properties</h2> <table class="docutils align-default">   <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-active"><span class="std std-ref">active</span></a></p></td> <td><p><code>true</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-debug-sprawl"><span class="std std-ref">debug_sprawl</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-roommanager-property-default-portal-margin"><span class="std std-ref">default_portal_margin</span></a></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-gameplay-monitor"><span class="std std-ref">gameplay_monitor</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-merge-meshes"><span class="std std-ref">merge_meshes</span></a></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-roommanager-property-overlap-warning-threshold"><span class="std std-ref">overlap_warning_threshold</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p><a href="#class-roommanager-property-portal-depth-limit"><span class="std std-ref">portal_depth_limit</span></a></p></td> <td><p><code>16</code></p></td> </tr> <tr>
<td><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a></p></td> <td><p><a href="#class-roommanager-property-preview-camera"><span class="std std-ref">preview_camera</span></a></p></td> <td><p><code>NodePath("")</code></p></td> </tr> <tr>
<td><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a></p></td> <td><p>process_priority</p></td> <td><p><code>10000</code> (overrides <a href="class_node.html#class-node-property-process-priority"><span class="std std-ref">Node</span></a>)</p></td> </tr> <tr>
<td><p><a href="#enum-roommanager-pvsmode"><span class="std std-ref">PVSMode</span></a></p></td> <td><p><a href="#class-roommanager-property-pvs-mode"><span class="std std-ref">pvs_mode</span></a></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-roommanager-property-roaming-expansion-margin"><span class="std std-ref">roaming_expansion_margin</span></a></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a></p></td> <td><p><a href="#class-roommanager-property-room-simplify"><span class="std std-ref">room_simplify</span></a></p></td> <td><p><code>0.5</code></p></td> </tr> <tr>
<td><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a></p></td> <td><p><a href="#class-roommanager-property-roomlist"><span class="std std-ref">roomlist</span></a></p></td> <td><p><code>NodePath("")</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-show-margins"><span class="std std-ref">show_margins</span></a></p></td> <td><p><code>true</code></p></td> </tr> <tr>
<td><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a></p></td> <td><p><a href="#class-roommanager-property-use-secondary-pvs"><span class="std std-ref">use_secondary_pvs</span></a></p></td> <td><p><code>false</code></p></td> </tr>  </table> </section> <section id="methods"> <h2>Methods</h2> <table class="docutils align-default">   <tr>
<td><p>void</p></td> <td><p><a href="#class-roommanager-method-rooms-clear"><span class="std std-ref">rooms_clear</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr> <tr>
<td><p>void</p></td> <td><p><a href="#class-roommanager-method-rooms-convert"><span class="std std-ref">rooms_convert</span></a> <strong>(</strong> <strong>)</strong></p></td> </tr>  </table> </section> <section id="enumerations"> <h2>Enumerations</h2> <p id="class-roommanager-constant-pvs-mode-full">enum <strong id="enum-roommanager-pvsmode">PVSMode</strong>:</p> <ul class="simple"> <li>
<strong>PVS_MODE_DISABLED</strong> = <strong>0</strong> --- Use only <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s at runtime to determine visibility. PVS will not be generated at <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s conversion, and gameplay notifications cannot be used.</li> <li>
<strong>PVS_MODE_PARTIAL</strong> = <strong>1</strong> --- Use a combination of PVS and <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s to determine visibility (this is usually fastest and most accurate).</li> <li>
<strong>PVS_MODE_FULL</strong> = <strong>2</strong> --- Use only the PVS (potentially visible set) of <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s to determine visibility.</li> </ul> </section> <section id="property-descriptions"> <h2>Property Descriptions</h2> <h3 id="class-roommanager-property-active"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> active</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>true</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>rooms_set_active(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>rooms_get_active()</p></td> </tr>  </table> <p>Switches the portal culling system on and off.</p> <p>It is important to note that when portal culling is active, it is responsible for <strong>all</strong> the 3d culling. Some editor visual debugging helpers may not be available when active, so switching the active flag is intended to be used to ensure your <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> / <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a> layout works within the editor.</p> <p>Switching to <code>active</code> will have no effect when the <code>room graph</code> is unloaded (the rooms have not yet been converted).</p> <p><strong>Note:</strong> For efficiency, the portal system is designed to work with only the core visual object types. In particular, only nodes derived from <a href="class_visualinstance.html#class-visualinstance"><span class="std std-ref">VisualInstance</span></a> are expected to show when the system is active.</p>  <h3 id="class-roommanager-property-debug-sprawl"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> debug_sprawl</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_debug_sprawl(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_debug_sprawl()</p></td> </tr>  </table> <p>Large objects can 'sprawl' over (be present in) more than one room. It can be useful to visualize which objects are sprawling outside the current room.</p> <p>Toggling this setting turns this debug view on and off.</p>  <h3 id="class-roommanager-property-default-portal-margin"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> default_portal_margin</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_default_portal_margin(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_default_portal_margin()</p></td> </tr>  </table> <p>Usually we don't want objects that only <strong>just</strong> cross a boundary into an adjacent <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> to sprawl into that room. To prevent this, each <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a> has an extra margin, or tolerance zone where objects can enter without sprawling to a neighbouring room.</p> <p>In most cases you can set this here for all portals. It is possible to override the margin for each portal.</p>  <h3 id="class-roommanager-property-gameplay-monitor"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> gameplay_monitor</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_gameplay_monitor_enabled(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_gameplay_monitor_enabled()</p></td> </tr>  </table> <p>When using a partial or full PVS, the gameplay monitor allows you to receive callbacks when roaming objects or rooms enter or exit the <strong>gameplay area</strong>. The gameplay area is defined as either the primary, or secondary PVS.</p> <p>These callbacks allow you to, for example, reduce processing for objects that are far from the player, or turn on and off AI.</p> <p>You can either choose to receive callbacks as notifications through the <code>_notification</code> function, or as signals.</p> <p><code>NOTIFICATION_ENTER_GAMEPLAY</code></p> <p><code>NOTIFICATION_EXIT_GAMEPLAY</code></p> <p>Signals: <code>"gameplay_entered"</code>, <code>"gameplay_exited"</code></p>  <h3 id="class-roommanager-property-merge-meshes"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> merge_meshes</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_merge_meshes(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_merge_meshes()</p></td> </tr>  </table> <p>If enabled, the system will attempt to merge similar meshes (particularly in terms of materials) within <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s during conversion. This can significantly reduce the number of drawcalls and state changes required during rendering, albeit at a cost of reduced culling granularity.</p> <p><strong>Note:</strong> This operates at runtime during the conversion process, and will only operate on exported or running projects, in order to prevent accidental alteration to the scene and loss of data.</p>  <h3 id="class-roommanager-property-overlap-warning-threshold"><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a> overlap_warning_threshold</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_overlap_warning_threshold(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_overlap_warning_threshold()</p></td> </tr>  </table> <p>When converting rooms, the editor will warn you if overlap is detected between rooms. Overlap can interfere with determining the room that cameras and objects are within. A small amount can be acceptable, depending on your level. Here you can alter the threshold at which the editor warning appears. There are no other side effects.</p>  <h3 id="class-roommanager-property-portal-depth-limit"><p><a href="class_int.html#class-int"><span class="std std-ref">int</span></a> portal_depth_limit</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>16</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_portal_depth_limit(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_portal_depth_limit()</p></td> </tr>  </table> <p>Portal rendering is recursive - each time a portal is seen through an earlier portal there is some cost. For this reason, and to prevent the possibility of infinite loops, this setting provides a hard limit on the recursion depth.</p> <p><strong>Note:</strong> This value is unused when using <code>Full</code> PVS mode.</p>  <h3 id="class-roommanager-property-preview-camera"><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> preview_camera</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>NodePath("")</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_preview_camera_path(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_preview_camera_path()</p></td> </tr>  </table> <p>Portal culling normally operates using the current <a href="class_camera.html#class-camera"><span class="std std-ref">Camera</span></a> / <a href="class_camera.html#class-camera"><span class="std std-ref">Camera</span></a>s, however for debugging purposes within the editor, you can use this setting to override this behavior and force it to use a particular camera to get a better idea of what the occlusion culling is doing.</p>  <h3 id="class-roommanager-property-pvs-mode"><p><a href="#enum-roommanager-pvsmode"><span class="std std-ref">PVSMode</span></a> pvs_mode</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>1</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_pvs_mode(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_pvs_mode()</p></td> </tr>  </table> <p>Optionally during conversion the potentially visible set (PVS) of rooms that are potentially visible from each room can be calculated. This can be used either to aid in dynamic portal culling, or to totally replace portal culling.</p> <p>In <code>Full</code> PVS Mode, all objects within the potentially visible rooms will be frustum culled, and rendered if they are within the view frustum.</p>  <h3 id="class-roommanager-property-roaming-expansion-margin"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> roaming_expansion_margin</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>1.0</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_roaming_expansion_margin(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_roaming_expansion_margin()</p></td> </tr>  </table> <p>In order to reduce processing for roaming objects, an expansion is applied to their AABB as they move. This expanded volume is used to calculate which rooms the roaming object is within. If the object's exact AABB is still within this expanded volume on the next move, there is no need to reprocess the object, which can save considerable CPU.</p> <p>The downside is that if the expansion is too much, the object may end up unexpectedly sprawling into neighbouring rooms and showing up where it might otherwise be culled.</p> <p>In order to balance roaming performance against culling accuracy, this expansion margin can be customized by the user. It will typically depend on your room and object sizes, and movement speeds. The default value should work reasonably in most circumstances.</p>  <h3 id="class-roommanager-property-room-simplify"><p><a href="class_float.html#class-float"><span class="std std-ref">float</span></a> room_simplify</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>0.5</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_room_simplify(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_room_simplify()</p></td> </tr>  </table> <p>During the conversion process, the geometry of objects within <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s, or a custom specified manual bound, are used to generate a <strong>convex hull bound</strong>.</p> <p>This convex hull is <strong>required</strong> in the visibility system, and is used for many purposes. Most importantly, it is used to decide whether the <a href="class_camera.html#class-camera"><span class="std std-ref">Camera</span></a> (or an object) is within a <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>. The convex hull generating algorithm is good, but occasionally it can create too many (or too few) planes to give a good representation of the room volume.</p> <p>The <code>room_simplify</code> value can be used to gain fine control over this process. It determines how similar planes can be for them to be considered the same (and duplicates removed). The value can be set between 0 (no simplification) and 1 (maximum simplification).</p> <p>The value set here is the default for all rooms, but individual rooms can override this value if desired.</p> <p>The room convex hulls are shown as a wireframe in the editor.</p>  <h3 id="class-roommanager-property-roomlist"><p><a href="class_nodepath.html#class-nodepath"><span class="std std-ref">NodePath</span></a> roomlist</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>NodePath("")</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_roomlist_path(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_roomlist_path()</p></td> </tr>  </table> <p>For the <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> conversion process to succeed, you must point the <code>RoomManager</code> to the parent <a href="class_node.html#class-node"><span class="std std-ref">Node</span></a> of your <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s and <a href="class_roomgroup.html#class-roomgroup"><span class="std std-ref">RoomGroup</span></a>s, which we refer to as the <code>roomlist</code> (the roomlist is not a special node type, it is normally just a <a href="class_spatial.html#class-spatial"><span class="std std-ref">Spatial</span></a>).</p>  <h3 id="class-roommanager-property-show-margins"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> show_margins</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>true</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_show_margins(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_show_margins()</p></td> </tr>  </table> <p>Shows the <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a> margins when the portal gizmo is used in the editor.</p>  <h3 id="class-roommanager-property-use-secondary-pvs"><p><a href="class_bool.html#class-bool"><span class="std std-ref">bool</span></a> use_secondary_pvs</p></h3> <table class="docutils align-default">   <tr>
<td><p><em>Default</em></p></td> <td><p><code>false</code></p></td> </tr> <tr>
<td><p><em>Setter</em></p></td> <td><p>set_use_secondary_pvs(value)</p></td> </tr> <tr>
<td><p><em>Getter</em></p></td> <td><p>get_use_secondary_pvs()</p></td> </tr>  </table> <p>When receiving gameplay callbacks when objects enter and exit gameplay, the <strong>gameplay area</strong> can be defined by either the primary PVS (potentially visible set) of <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s, or the secondary PVS (the primary PVS and their neighbouring <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a>s).</p> <p>Sometimes using the larger gameplay area of the secondary PVS may be preferable.</p> </section> <section id="method-descriptions"> <h2>Method Descriptions</h2> <h3 id="class-roommanager-method-rooms-clear"><p>void rooms_clear ( )</p></h3> <p>This function clears all converted data from the <strong>room graph</strong>. Use this before unloading a level, when transitioning from level to level, or returning to a main menu.</p>  <h3 id="class-roommanager-method-rooms-convert"><p>void rooms_convert ( )</p></h3> <p>This is the most important function in the whole portal culling system. Without it, the system cannot function.</p> <p>First it goes through every <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> that is a child of the <code>room list</code> node (and <a href="class_roomgroup.html#class-roomgroup"><span class="std std-ref">RoomGroup</span></a>s within) and converts and adds it to the <code>room graph</code>.</p> <p>This works for both <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> nodes, and <a href="class_spatial.html#class-spatial"><span class="std std-ref">Spatial</span></a> nodes that follow a special naming convention. They should begin with the prefix <em>'Room_'</em>, followed by the name you wish to give the room, e.g. <em>'Room_lounge'</em>. This will automatically convert such <a href="class_spatial.html#class-spatial"><span class="std std-ref">Spatial</span></a>s to <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> nodes for you. This is useful if you want to build you entire room system in e.g. Blender, and reimport multiple times as you work on the level.</p> <p>The conversion will try to assign <a href="class_visualinstance.html#class-visualinstance"><span class="std std-ref">VisualInstance</span></a>s that are children and grandchildren of the <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> to the room. These should be given a suitable <code>portal mode</code> (see the <a href="class_cullinstance.html#class-cullinstance"><span class="std std-ref">CullInstance</span></a> documentation). The default <code>portal mode</code> is <code>STATIC</code> - objects which are not expected to move while the level is played, which will typically be most objects.</p> <p>The conversion will usually use the geometry of these <a href="class_visualinstance.html#class-visualinstance"><span class="std std-ref">VisualInstance</span></a>s (and the <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s) to calculate a convex hull bound for the room. These bounds will be shown in the editor with a wireframe. Alternatively you can specify a manual custom bound for any room, see the <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> documentation.</p> <p>By definition, <a href="class_camera.html#class-camera"><span class="std std-ref">Camera</span></a>s within a room can see everything else within the room (that is one advantage to using convex hulls). However, in order to see from one room into adjacent rooms, you must place <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s, which represent openings that the camera can see through, like windows and doors.</p> <p><a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s are really just specialized <a href="class_meshinstance.html#class-meshinstance"><span class="std std-ref">MeshInstance</span></a>s. In fact you will usually first create a portal by creating a <a href="class_meshinstance.html#class-meshinstance"><span class="std std-ref">MeshInstance</span></a>, especially a <code>plane</code> mesh instance. You would move the plane in the editor to cover a window or doorway, with the front face pointing outward from the room. To let the conversion process know you want this mesh to be a portal, again we use a special naming convention. <a href="class_meshinstance.html#class-meshinstance"><span class="std std-ref">MeshInstance</span></a>s to be converted to a <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a> should start with the prefix <em>'Portal_'</em>.</p> <p>You now have a choice - you can leave the name as <em>'Portal_'</em> and allow the system to automatically detect the nearest <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> to link. In most cases this will work fine.</p> <p>An alternative method is to specify the <a href="class_room.html#class-room"><span class="std std-ref">Room</span></a> to link to manually, appending a suffix to the portal name, which should be the name of the room you intend to link to. For example <em>'Portal_lounge'</em> will attempt to link to the room named <em>'Room_lounge'</em>.</p> <p>There is a special case here - Godot does not allow two nodes to share the same name. What if you want to manually have more than one portal leading into the same room? Surely they will need to both be called, e.g. <em>'Portal_lounge'</em>?</p> <p>The solution is a wildcard character. After the room name, if you use the character <em>'*'</em>, this character and anything following it will be ignored. So you can use for example <em>'Portal_lounge*0'</em>, <em>'Portal_lounge*1'</em> etc.</p> <p>Note that <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a>s that have already been converted to <a href="class_portal.html#class-portal"><span class="std std-ref">Portal</span></a> nodes (rather than <a href="class_meshinstance.html#class-meshinstance"><span class="std std-ref">MeshInstance</span></a>s) still need to follow the same naming convention, as they will be relinked each time during conversion.</p> <p>It is recommended that you only place objects in rooms that are desired to stay within those rooms - i.e. <code>portal mode</code>s <code>STATIC</code> or <code>DYNAMIC</code> (not crossing portals). <code>GLOBAL</code> and <code>ROAMING</code> objects are best placed in another part of the scene tree, to avoid confusion. See <a href="class_cullinstance.html#class-cullinstance"><span class="std std-ref">CullInstance</span></a> for a full description of portal modes.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2022 Juan Linietsky, Ariel Manzur, Godot Engine contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.godotengine.org/en/3.5/classes/class_roommanager.html" class="_attribution-link">https://docs.godotengine.org/en/3.5/classes/class_roommanager.html</a>
  </p>
</div>
