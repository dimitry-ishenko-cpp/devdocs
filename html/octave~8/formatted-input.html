<div class="subsection" id="Formatted-Input">   <h1 class="subsection">14.2.11 Formatted Input</h1> <p>Octave provides the <code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code> functions to read formatted input. There are two forms of each of these functions. One can be used to extract vectors of data from a file, and the other is more ‘C-like’. </p> <dl class="def"> <dt id="index-fscanf">
<span class="category">: </span><span><em>[<var>val</var>, <var>count</var>, <var>errmsg</var>] =</em> <strong>fscanf</strong> <em>(<var>fid</var>, <var>template</var>, <var>size</var>)</em><a href="#index-fscanf" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fscanf-1">
<span class="category">: </span><span><em>[<var>v1</var>, <var>v2</var>, …, <var>count</var>, <var>errmsg</var>] =</em> <strong>fscanf</strong> <em>(<var>fid</var>, <var>template</var>, "C")</em><a href="#index-fscanf-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>In the first form, read from <var>fid</var> according to <var>template</var>, returning the result in the matrix <var>val</var>. </p> <p>The optional argument <var>size</var> specifies the amount of data to read and may be one of </p> <dl compact> <dt><span><code>Inf</code></span></dt> <dd>
<p>Read as much as possible, returning a column vector. </p> </dd> <dt><span><code><var>nr</var></code></span></dt> <dd>
<p>Read up to <var>nr</var> elements, returning a column vector. </p> </dd> <dt><span><code>[<var>nr</var>, Inf]</code></span></dt> <dd>
<p>Read as much as possible, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p> </dd> <dt><span><code>[<var>nr</var>, <var>nc</var>]</code></span></dt> <dd><p>Read up to <code><var>nr</var> * <var>nc</var></code> elements, returning a matrix with <var>nr</var> rows. If the number of elements read is not an exact multiple of <var>nr</var>, the last column is padded with zeros. </p></dd> </dl> <p>If <var>size</var> is omitted, a value of <code>Inf</code> is assumed. </p> <p>A string is returned if <var>template</var> specifies only character conversions. </p> <p>The number of items successfully read is returned in <var>count</var>. </p> <p>If an error occurs, <var>errmsg</var> contains a system-dependent error message. </p> <p>In the second form, read from <var>fid</var> according to <var>template</var>, with each conversion specifier in <var>template</var> corresponding to a single scalar return value. This form is more “C-like”, and also compatible with previous versions of Octave. The number of successful conversions is returned in <var>count</var> </p> <p>See the Formatted Input section of the GNU Octave manual for a complete description of the syntax of the template string. </p> <p><strong>See also:</strong> <a href="line_002doriented-input.html#XREFfgets">fgets</a>, <a href="line_002doriented-input.html#XREFfgetl">fgetl</a>, <a href="binary-i_002fo.html#XREFfread">fread</a>, <a href="#XREFscanf">scanf</a>, <a href="#XREFsscanf">sscanf</a>, <a href="opening-and-closing-files.html#XREFfopen">fopen</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-scanf">
<span class="category">: </span><span><em>[<var>val</var>, <var>count</var>, <var>errmsg</var>] =</em> <strong>scanf</strong> <em>(<var>template</var>, <var>size</var>)</em><a href="#index-scanf" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-scanf-1">
<span class="category">: </span><span><em>[<var>v1</var>, <var>v2</var>, …, <var>count</var>, <var>errmsg</var>] =</em> <strong>scanf</strong> <em>(<var>template</var>, "C")</em><a href="#index-scanf-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This is equivalent to calling <code>fscanf</code> with <var>fid</var> = <code>stdin</code>. </p> <p>It is currently not useful to call <code>scanf</code> in interactive programs. </p> <p><strong>See also:</strong> <a href="#XREFfscanf">fscanf</a>, <a href="#XREFsscanf">sscanf</a>, <a href="formatted-output.html#XREFprintf">printf</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sscanf">
<span class="category">: </span><span><em>[<var>val</var>, <var>count</var>, <var>errmsg</var>, <var>pos</var>] =</em> <strong>sscanf</strong> <em>(<var>string</var>, <var>template</var>, <var>size</var>)</em><a href="#index-sscanf" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sscanf-1">
<span class="category">: </span><span><em>[<var>v1</var>, <var>v2</var>, …, <var>count</var>, <var>errmsg</var>] =</em> <strong>sscanf</strong> <em>(<var>string</var>, <var>template</var>, "C")</em><a href="#index-sscanf-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>This is like <code>fscanf</code>, except that the characters are taken from the string <var>string</var> instead of from a stream. </p> <p>Reaching the end of the string is treated as an end-of-file condition. In addition to the values returned by <code>fscanf</code>, the index of the next character to be read is returned in <var>pos</var>. </p> <p><strong>See also:</strong> <a href="#XREFfscanf">fscanf</a>, <a href="#XREFscanf">scanf</a>, <a href="formatted-output.html#XREFsprintf">sprintf</a>. </p>
</dd>
</dl> <p>Calls to <code>scanf</code> are superficially similar to calls to <code>printf</code> in that arbitrary arguments are read under the control of a template string. While the syntax of the conversion specifications in the template is very similar to that for <code>printf</code>, the interpretation of the template is oriented more towards free-format input and simple pattern matching, rather than fixed-field formatting. For example, most <code>scanf</code> conversions skip over any amount of “white space” (including spaces, tabs, and newlines) in the input file, and there is no concept of precision for the numeric input conversions as there is for the corresponding output conversions. Ordinarily, non-whitespace characters in the template are expected to match characters in the input stream exactly. For example, note that <code>sscanf</code> parses the string and whitespace differently when using mixed numeric and string output types:  </p> <pre class="example" data-language="matlab">teststr = "1 is a lonely number";
sscanf (teststr, "%s is a %s")
⇒ 1lonelynumber

sscanf (teststr, "%g is a %s")
⇒
     1
   108
   111
   110
   101
   108
   121

[a, b, c] = sscanf ("1 is a lonely number", "%g is a %s %s", "C")
⇒ a =  1
⇒ b = lonely
⇒ c = number</pre> <p>When a <em>matching failure</em> occurs, <code>scanf</code> returns immediately, leaving the first non-matching character as the next character to be read from the stream, and <code>scanf</code> returns all the items that were successfully converted.  </p> <p>The formatted input functions are not used as frequently as the formatted output functions. Partly, this is because it takes some care to use them properly. Another reason is that it is difficult to recover from a matching error. </p> <p>The specific flags and modifiers that are permitted in the template string and their interpretation are all described in more detail in the following sections. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Formatted-Input.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Formatted-Input.html</a>
  </p>
</div>
