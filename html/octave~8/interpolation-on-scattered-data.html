<div class="section" id="Interpolation-on-Scattered-Data">   <h1 class="section">30.4 Interpolation on Scattered Data</h1> <p>An important use of the Delaunay tessellation is that it can be used to interpolate from scattered data to an arbitrary set of points. To do this the N-simplex of the known set of points is calculated with <code>delaunay</code> or <code>delaunayn</code>. Then the simplices in to which the desired points are found are identified. Finally the vertices of the simplices are used to interpolate to the desired points. The functions that perform this interpolation are <code>griddata</code>, <code>griddata3</code> and <code>griddatan</code>. </p> <dl class="def"> <dt id="index-griddata">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>griddata</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>xi</var>, <var>yi</var>)</em><a href="#index-griddata" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata-1">
<span class="category">: </span><span><em><var>zi</var> =</em> <strong>griddata</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>xi</var>, <var>yi</var>, <var>method</var>)</em><a href="#index-griddata-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata-2">
<span class="category">: </span><span><em>[<var>xi</var>, <var>yi</var>, <var>zi</var>] =</em> <strong>griddata</strong> <em>(…)</em><a href="#index-griddata-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata-3">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em><a href="#index-griddata-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata-4">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>, <var>method</var>)</em><a href="#index-griddata-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata-5">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>, <var>method</var>, <var>options</var>)</em><a href="#index-griddata-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular 2-D and 3-D source data at specified points. </p> <p>For 2-D interpolation, the inputs <var>x</var> and <var>y</var> define the points where the function <code><var>z</var> = f (<var>x</var>, <var>y</var>)</code> is evaluated. The inputs <var>x</var>, <var>y</var>, <var>z</var> are either vectors of the same length, or the unequal vectors <var>x</var>, <var>y</var> are expanded to a 2-D grid with <code>meshgrid</code> and <var>z</var> is a 2-D matrix matching the resulting size of the X-Y grid. </p> <p>The interpolation points are (<var>xi</var>, <var>yi</var>). If, and only if, <var>xi</var> is a row vector and <var>yi</var> is a column vector, then <code>meshgrid</code> will be used to create a mesh of interpolation points. </p> <p>For 3-D interpolation, the inputs <var>x</var>, <var>y</var>, and <var>z</var> define the points where the function <code><var>v</var> = f (<var>x</var>, <var>y</var>, <var>z</var>)</code> is evaluated. The inputs <var>x</var>, <var>y</var>, <var>z</var> are either vectors of the same length, or if they are of unequal length, then they are expanded to a 3-D grid with <code>meshgrid</code>. The size of the input <var>v</var> must match the size of the original data, either as a vector or a matrix. </p> <p>The optional input interpolation <var>method</var> can be <code>"nearest"</code>, <code>"linear"</code>, or for 2-D data <code>"v4"</code>. When the method is <code>"nearest"</code>, the output <var>vi</var> will be the closest point in the original data (<var>x</var>, <var>y</var>, <var>z</var>) to the query point (<var>xi</var>, <var>yi</var>, <var>zi</var>). When the method is <code>"linear"</code>, the output <var>vi</var> will be a linear interpolation between the two closest points in the original source data in each dimension. For 2-D cases only, the <code>"v4"</code> method is also available which implements a biharmonic spline interpolation. If <var>method</var> is omitted or empty, it defaults to <code>"linear"</code>. </p> <p>For 3-D interpolation, the optional argument <var>options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. For more information on the defaults and how to pass different values, see <a href="delaunay-triangulation.html#XREFdelaunayn"><code>delaunayn</code></a>. </p> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is normally based on a Delaunay triangulation. Any query values outside the convex hull of the input points will return <code>NaN</code>. However, the <code>"v4"</code> method does not use the triangulation and will return values outside the original data (extrapolation). </p> <p><strong>See also:</strong> <a href="#XREFgriddata3">griddata3</a>, <a href="#XREFgriddatan">griddatan</a>, <a href="delaunay-triangulation.html#XREFdelaunay">delaunay</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-griddata3">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>)</em><a href="#index-griddata3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata3-1">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>, <var>method</var>)</em><a href="#index-griddata3-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddata3-2">
<span class="category">: </span><span><em><var>vi</var> =</em> <strong>griddata3</strong> <em>(<var>x</var>, <var>y</var>, <var>z</var>, <var>v</var>, <var>xi</var>, <var>yi</var>, <var>zi</var>, <var>method</var>, <var>options</var>)</em><a href="#index-griddata3-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular 3-D source data at specified points. </p> <p>The inputs <var>x</var>, <var>y</var>, and <var>z</var> define the points where the function <code><var>v</var> = f (<var>x</var>, <var>y</var>, <var>z</var>)</code> is evaluated. The inputs <var>x</var>, <var>y</var>, <var>z</var> are either vectors of the same length, or if they are of unequal length, then they are expanded to a 3-D grid with <code>meshgrid</code>. The size of the input <var>v</var> must match the size of the original data, either as a vector or a matrix. </p> <p>The interpolation points are specified by <var>xi</var>, <var>yi</var>, <var>zi</var>. </p> <p>The optional input interpolation <var>method</var> can be <code>"nearest"</code> or <code>"linear"</code>. When the method is <code>"nearest"</code>, the output <var>vi</var> will be the closest point in the original data (<var>x</var>, <var>y</var>, <var>z</var>) to the query point (<var>xi</var>, <var>yi</var>, <var>zi</var>). When the method is <code>"linear"</code>, the output <var>vi</var> will be a linear interpolation between the two closest points in the original source data in each dimension. If <var>method</var> is omitted or empty, it defaults to <code>"linear"</code>. </p> <p>The optional argument <var>options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. See <code>delaunayn</code> for information on the defaults and how to pass different values. </p> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is based on a Delaunay triangulation and any query values outside the convex hull of the input points will return <code>NaN</code>. </p> <p><strong>See also:</strong> <a href="#XREFgriddata">griddata</a>, <a href="#XREFgriddatan">griddatan</a>, <a href="delaunay-triangulation.html#XREFdelaunayn">delaunayn</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-griddatan">
<span class="category">: </span><span><em><var>yi</var> =</em> <strong>griddatan</strong> <em>(<var>x</var>, <var>y</var>, <var>xi</var>)</em><a href="#index-griddatan" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddatan-1">
<span class="category">: </span><span><em><var>yi</var> =</em> <strong>griddatan</strong> <em>(<var>x</var>, <var>y</var>, <var>xi</var>, <var>method</var>)</em><a href="#index-griddatan-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-griddatan-2">
<span class="category">: </span><span><em><var>yi</var> =</em> <strong>griddatan</strong> <em>(<var>x</var>, <var>y</var>, <var>xi</var>, <var>method</var>, <var>options</var>)</em><a href="#index-griddatan-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Interpolate irregular source data <var>x</var>, <var>y</var> at points specified by <var>xi</var>. </p> <p>The input <var>x</var> is an MxN matrix representing M points in an N-dimensional space. The input <var>y</var> is a single-valued column vector (Mx1) representing a function evaluated at the points <var>x</var>, i.e., <code><var>y</var> = fcn (<var>x</var>)</code>. The input <var>xi</var> is a list of points for which the function output <var>yi</var> should be approximated through interpolation. <var>xi</var> must have the same number of columns (<var>N</var>) as <var>x</var> so that the dimensionality matches. </p> <p>The optional input interpolation <var>method</var> can be <code>"nearest"</code> or <code>"linear"</code>. When the method is <code>"nearest"</code>, the output <var>yi</var> will be the closest point in the original data <var>x</var> to the query point <var>xi</var>. When the method is <code>"linear"</code>, the output <var>yi</var> will be a linear interpolation between the two closest points in the original source data. If <var>method</var> is omitted or empty, it defaults to <code>"linear"</code>. </p> <p>The optional argument <var>options</var> is passed directly to Qhull when computing the Delaunay triangulation used for interpolation. See <code>delaunayn</code> for information on the defaults and how to pass different values. </p> <p>Example </p> <pre class="example" data-language="matlab">## Evaluate sombrero() function at irregular data points
x = 16*gallery ("uniformdata", [200,1], 1) - 8;
y = 16*gallery ("uniformdata", [200,1], 11) - 8;
z = sin (sqrt (x.^2 + y.^2)) ./ sqrt (x.^2 + y.^2);
## Create a regular grid and interpolate data
[xi, yi] = ndgrid (linspace (-8, 8, 50));
zi = griddatan ([x, y], z, [xi(:), yi(:)]);
zi = reshape (zi, size (xi));
## Plot results
clf ();
plot3 (x, y, z, "or");
hold on
surf (xi, yi, zi);
legend ("Original Data", "Interpolated Data");</pre> <p>Programming Notes: If the input is complex the real and imaginary parts are interpolated separately. Interpolation is based on a Delaunay triangulation and any query values outside the convex hull of the input points will return <code>NaN</code>. For 2-D and 3-D data additional interpolation methods are available by using the <code>griddata</code> function. </p> <p><strong>See also:</strong> <a href="#XREFgriddata">griddata</a>, <a href="#XREFgriddata3">griddata3</a>, <a href="delaunay-triangulation.html#XREFdelaunayn">delaunayn</a>. </p>
</dd>
</dl> <p>An example of the use of the <code>griddata</code> function is </p> <pre class="example" data-language="matlab">rand ("state", 1);
x = 2*rand (1000,1) - 1;
y = 2*rand (size (x)) - 1;
z = sin (2*(x.^2+y.^2));
[xx,yy] = meshgrid (linspace (-1,1,32));
zz = griddata (x, y, z, xx, yy);
mesh (xx, yy, zz);</pre> <p>that interpolates from a random scattering of points, to a uniform grid. The output of the above can be seen in <a href="#fig_003agriddata">Figure 30.6</a>. </p> <div class="float">
 <div align="center">
<img src="https://docs.octave.org/v8.1.0/griddata.png" alt="griddata"> </div> <div class="float-caption"><p><strong>Figure 30.6: </strong>Interpolation from a scattered data to a regular grid</p></div>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Interpolation-on-Scattered-Data.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Interpolation-on-Scattered-Data.html</a>
  </p>
</div>
