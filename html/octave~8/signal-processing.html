<div class="chapter" id="Signal-Processing">   <h1 class="chapter">31 Signal Processing</h1> <p>This chapter describes the signal processing and fast Fourier transform functions available in Octave. Fast Fourier transforms are computed with the <small>FFTW</small> or <small>FFTPACK</small> libraries depending on how Octave is built. </p> <dl class="def"> <dt id="index-fft">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fft</strong> <em>(<var>x</var>)</em><a href="#index-fft" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fft-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fft</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-fft-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fft-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fft</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href="#index-fft-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the discrete Fourier transform of <var>x</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The FFT is calculated along the first non-singleton dimension of the array. Thus if <var>x</var> is a matrix, <code>fft (<var>x</var>)</code> computes the FFT for each column of <var>x</var>. </p> <p>If called with two arguments, <var>n</var> is expected to be an integer specifying the number of elements of <var>x</var> to use, or an empty matrix to specify that its value should be ignored. If <var>n</var> is larger than the dimension along which the FFT is calculated, then <var>x</var> is resized and padded with zeros. Otherwise, if <var>n</var> is smaller than the dimension along which the FFT is calculated, then <var>x</var> is truncated. </p> <p>If called with three arguments, <var>dim</var> is an integer specifying the dimension of the matrix along which the FFT is performed. </p> <p><strong>See also:</strong> <a href="#XREFifft">ifft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ifft">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>ifft</strong> <em>(<var>y</var>)</em><a href="#index-ifft" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifft-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>ifft</strong> <em>(<var>y</var>, <var>n</var>)</em><a href="#index-ifft-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifft-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>ifft</strong> <em>(<var>y</var>, <var>n</var>, <var>dim</var>)</em><a href="#index-ifft-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse discrete Fourier transform of <var>y</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The inverse FFT is calculated along the first non-singleton dimension of the array. Thus if <var>y</var> is a matrix, <code>ifft (<var>y</var>)</code> computes the inverse FFT for each column of <var>y</var>. </p> <p>If called with two arguments, <var>n</var> is expected to be an integer specifying the number of elements of <var>y</var> to use, or an empty matrix to specify that its value should be ignored. If <var>n</var> is larger than the dimension along which the inverse FFT is calculated, then <var>y</var> is resized and padded with zeros. Otherwise, if <var>n</var> is smaller than the dimension along which the inverse FFT is calculated, then <var>y</var> is truncated. </p> <p>If called with three arguments, <var>dim</var> is an integer specifying the dimension of the matrix along which the inverse FFT is performed. </p> <p><strong>See also:</strong> <a href="#XREFfft">fft</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFifftn">ifftn</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fft2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>fft2</strong> <em>(<var>A</var>)</em><a href="#index-fft2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fft2-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>fft2</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>)</em><a href="#index-fft2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the two-dimensional discrete Fourier transform of <var>A</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional arguments <var>m</var> and <var>n</var> may be used specify the number of rows and columns of <var>A</var> to use. If either of these is larger than the size of <var>A</var>, <var>A</var> is resized and padded with zeros. </p> <p>If <var>A</var> is a multi-dimensional matrix, each two-dimensional sub-matrix of <var>A</var> is treated separately. </p> <p><strong>See also:</strong> <a href="#XREFifft2">ifft2</a>, <a href="#XREFfft">fft</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ifft2">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>ifft2</strong> <em>(<var>B</var>)</em><a href="#index-ifft2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifft2-1">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>ifft2</strong> <em>(<var>B</var>, <var>m</var>, <var>n</var>)</em><a href="#index-ifft2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse two-dimensional discrete Fourier transform of <var>B</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional arguments <var>m</var> and <var>n</var> may be used specify the number of rows and columns of <var>B</var> to use. If either of these is larger than the size of <var>B</var>, <var>B</var> is resized and padded with zeros. </p> <p>If <var>B</var> is a multi-dimensional matrix, each two-dimensional sub-matrix of <var>B</var> is treated separately. </p> <p><strong>See also:</strong> <a href="#XREFfft2">fft2</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFifftn">ifftn</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fftn">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>fftn</strong> <em>(<var>A</var>)</em><a href="#index-fftn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftn-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>fftn</strong> <em>(<var>A</var>, <var>size</var>)</em><a href="#index-fftn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the N-dimensional discrete Fourier transform of <var>A</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional vector argument <var>size</var> may be used specify the dimensions of the array to be used. If an element of <var>size</var> is smaller than the corresponding dimension of <var>A</var>, then the dimension of <var>A</var> is truncated prior to performing the FFT. Otherwise, if an element of <var>size</var> is larger than the corresponding dimension then <var>A</var> is resized and padded with zeros. </p> <p><strong>See also:</strong> <a href="#XREFifftn">ifftn</a>, <a href="#XREFfft">fft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ifftn">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>ifftn</strong> <em>(<var>B</var>)</em><a href="#index-ifftn" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifftn-1">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>ifftn</strong> <em>(<var>B</var>, <var>size</var>)</em><a href="#index-ifftn-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse N-dimensional discrete Fourier transform of <var>B</var> using a Fast Fourier Transform (FFT) algorithm. </p> <p>The optional vector argument <var>size</var> may be used specify the dimensions of the array to be used. If an element of <var>size</var> is smaller than the corresponding dimension of <var>B</var>, then the dimension of <var>B</var> is truncated prior to performing the inverse FFT. Otherwise, if an element of <var>size</var> is larger than the corresponding dimension then <var>B</var> is resized and padded with zeros. </p> <p><strong>See also:</strong> <a href="#XREFfftn">fftn</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFfftw">fftw</a>. </p>
</dd>
</dl> <p>Octave uses the <small>FFTW</small> libraries to perform FFT computations. When Octave starts up and initializes the <small>FFTW</small> libraries, they read a system wide file (on a Unix system, it is typically <samp>/etc/fftw/wisdom</samp>) that contains information useful to speed up FFT computations. This information is called the <em>wisdom</em>. The system-wide file allows wisdom to be shared between all applications using the <small>FFTW</small> libraries. </p> <p>Use the <code>fftw</code> function to generate and save wisdom. Using the utilities provided together with the <small>FFTW</small> libraries (<code>fftw-wisdom</code> on Unix systems), you can even add wisdom generated by Octave to the system-wide wisdom file. </p> <dl class="def"> <dt id="index-fftw">
<span class="category">: </span><span><em><var>method</var> =</em> <strong>fftw</strong> <em>("planner")</em><a href="#index-fftw" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftw-1">
<span class="category">: </span><span> <strong>fftw</strong> <em>("planner", <var>method</var>)</em><a href="#index-fftw-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftw-2">
<span class="category">: </span><span><em><var>wisdom</var> =</em> <strong>fftw</strong> <em>("dwisdom")</em><a href="#index-fftw-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftw-3">
<span class="category">: </span><span> <strong>fftw</strong> <em>("dwisdom", <var>wisdom</var>)</em><a href="#index-fftw-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftw-4">
<span class="category">: </span><span><em><var>nthreads</var> =</em> <strong>fftw</strong> <em>("threads")</em><a href="#index-fftw-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftw-5">
<span class="category">: </span><span> <strong>fftw</strong> <em>("threads", <var>nthreads</var>)</em><a href="#index-fftw-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Manage <small>FFTW</small> wisdom data. </p> <p>Wisdom data can be used to significantly accelerate the calculation of the FFTs, but implies an initial cost in its calculation. When the <small>FFTW</small> libraries are initialized, they read a system wide wisdom file (typically in <samp>/etc/fftw/wisdom</samp>), allowing wisdom to be shared between applications other than Octave. Alternatively, the <code>fftw</code> function can be used to import wisdom. For example, </p> <pre class="example" data-language="matlab">wisdom = fftw ("dwisdom")</pre> <p>will save the existing wisdom used by Octave to the string <var>wisdom</var>. This string can then be saved to a file and restored using the <code>save</code> and <code>load</code> commands respectively. This existing wisdom can be re-imported as follows </p> <pre class="example" data-language="matlab">fftw ("dwisdom", wisdom)</pre> <p>If <var>wisdom</var> is an empty string, then the wisdom used is cleared. </p> <p>During the calculation of Fourier transforms further wisdom is generated. The fashion in which this wisdom is generated is also controlled by the <code>fftw</code> function. There are five different manners in which the wisdom can be treated: </p> <dl compact> <dt><span><code>"estimate"</code></span></dt> <dd>
<p>Specifies that no run-time measurement of the optimal means of calculating a particular is performed, and a simple heuristic is used to pick a (probably sub-optimal) plan. The advantage of this method is that there is little or no overhead in the generation of the plan, which is appropriate for a Fourier transform that will be calculated once. </p> </dd> <dt><span><code>"measure"</code></span></dt> <dd>
<p>In this case a range of algorithms to perform the transform is considered and the best is selected based on their execution time. </p> </dd> <dt><span><code>"patient"</code></span></dt> <dd>
<p>Similar to <code>"measure"</code>, but a wider range of algorithms is considered. </p> </dd> <dt><span><code>"exhaustive"</code></span></dt> <dd>
<p>Like <code>"measure"</code>, but all possible algorithms that may be used to treat the transform are considered. </p> </dd> <dt><span><code>"hybrid"</code></span></dt> <dd><p>As run-time measurement of the algorithm can be expensive, this is a compromise where <code>"measure"</code> is used for transforms up to the size of 8192 and beyond that the <code>"estimate"</code> method is used. </p></dd> </dl> <p>The default method is <code>"estimate"</code>. The current method can be queried with </p> <pre class="example" data-language="matlab">method = fftw ("planner")</pre> <p>or set by using </p> <pre class="example" data-language="matlab">fftw ("planner", method)</pre> <p>Note that calculated wisdom will be lost when restarting Octave. However, the wisdom data can be reloaded if it is saved to a file as described above. Saved wisdom files should not be used on different platforms since they will not be efficient and the point of calculating the wisdom is lost. </p> <p>The number of threads used for computing the plans and executing the transforms can be set with </p> <pre class="example" data-language="matlab">fftw ("threads", NTHREADS)</pre> <p>Note that Octave must be compiled with multi-threaded <small>FFTW</small> support for this feature. By default, the number of (logical) processors available to the current process or <var>3</var> is used (whichever is smaller). </p> <p><strong>See also:</strong> <a href="#XREFfft">fft</a>, <a href="#XREFifft">ifft</a>, <a href="#XREFfft2">fft2</a>, <a href="#XREFifft2">ifft2</a>, <a href="#XREFfftn">fftn</a>, <a href="#XREFifftn">ifftn</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fftconv">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>fftconv</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-fftconv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftconv-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>fftconv</strong> <em>(<var>x</var>, <var>y</var>, <var>n</var>)</em><a href="#index-fftconv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Convolve two vectors using the FFT for computation. </p> <p><code>c = fftconv (<var>x</var>, <var>y</var>)</code> returns a vector of length equal to <code>length (<var>x</var>) + length (<var>y</var>) - 1</code>. If <var>x</var> and <var>y</var> are the coefficient vectors of two polynomials, the returned value is the coefficient vector of the product polynomial. </p> <p>The computation uses the FFT by calling the function <code>fftfilt</code>. If the optional argument <var>n</var> is specified, an N-point FFT is used. </p> <p><strong>See also:</strong> <a href="products-of-polynomials.html#XREFdeconv">deconv</a>, <a href="products-of-polynomials.html#XREFconv">conv</a>, <a href="products-of-polynomials.html#XREFconv2">conv2</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fftfilt">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fftfilt</strong> <em>(<var>b</var>, <var>x</var>)</em><a href="#index-fftfilt" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftfilt-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fftfilt</strong> <em>(<var>b</var>, <var>x</var>, <var>n</var>)</em><a href="#index-fftfilt-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Filter <var>x</var> with the FIR filter <var>b</var> using the FFT. </p> <p>If <var>x</var> is a matrix, filter each column of the matrix. </p> <p>Given the optional third argument, <var>n</var>, <code>fftfilt</code> uses the overlap-add method to filter <var>x</var> with <var>b</var> using an N-point FFT. The FFT size must be an even power of 2 and must be greater than or equal to the length of <var>b</var>. If the specified <var>n</var> does not meet these criteria, it is automatically adjusted to the nearest value that does. </p> <p><strong>See also:</strong> <a href="#XREFfilter">filter</a>, <a href="#XREFfilter2">filter2</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-filter">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>)</em><a href="#index-filter" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-filter-1">
<span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, <var>si</var>)</em><a href="#index-filter-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-filter-2">
<span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, [], <var>dim</var>)</em><a href="#index-filter-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-filter-3">
<span class="category">: </span><span><em>[<var>y</var>, <var>sf</var>] =</em> <strong>filter</strong> <em>(<var>b</var>, <var>a</var>, <var>x</var>, <var>si</var>, <var>dim</var>)</em><a href="#index-filter-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Apply a 1-D digital filter to the data <var>x</var>. </p> <p><code>filter</code> returns the solution to the following linear, time-invariant difference equation: </p> <pre class="example" data-language="matlab">N                   M
SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)    for 1&lt;=n&lt;=length(x)
k=0                 k=0</pre> <p>where N=length(a)-1 and M=length(b)-1. The result is calculated over the first non-singleton dimension of <var>x</var> or over <var>dim</var> if supplied. </p> <p>An equivalent form of the equation is: </p> <pre class="example" data-language="matlab">N                   M
y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1&lt;=n&lt;=length(x)
         k=1                 k=0</pre> <p>where c = a/a(1) and d = b/a(1). </p> <p>If the fourth argument <var>si</var> is provided, it is taken as the initial state of the system and the final state is returned as <var>sf</var>. The state vector is a column vector whose length is equal to the length of the longest coefficient vector minus one. If <var>si</var> is not supplied, the initial state vector is set to all zeros. </p> <p>In terms of the Z Transform, <var>y</var> is the result of passing the discrete-time signal <var>x</var> through a system characterized by the following rational system function: </p> <pre class="example" data-language="matlab">M
         SUM d(k+1) z^(-k)
         k=0
H(z) = ---------------------
            N
       1 + SUM c(k+1) z^(-k)
           k=1</pre> <p><strong>See also:</strong> <a href="#XREFfilter2">filter2</a>, <a href="#XREFfftfilt">fftfilt</a>, <a href="#XREFfreqz">freqz</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-filter2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>filter2</strong> <em>(<var>b</var>, <var>x</var>)</em><a href="#index-filter2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-filter2-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>filter2</strong> <em>(<var>b</var>, <var>x</var>, <var>shape</var>)</em><a href="#index-filter2-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Apply the 2-D FIR filter <var>b</var> to <var>x</var>. </p> <p>If the argument <var>shape</var> is specified, return an array of the desired shape. Possible values are: </p> <dl compact> <dt><span><code>"full"</code></span></dt> <dd>
<p>pad <var>x</var> with zeros on all sides before filtering. </p> </dd> <dt><span><code>"same"</code></span></dt> <dd>
<p>unpadded <var>x</var> (default) </p> </dd> <dt><span><code>"valid"</code></span></dt> <dd><p>trim <var>x</var> after filtering so edge effects are no included. </p></dd> </dl> <p>Note this is just a variation on convolution, with the parameters reversed and <var>b</var> rotated 180 degrees. </p> <p><strong>See also:</strong> <a href="products-of-polynomials.html#XREFconv2">conv2</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-freqz">
<span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>n</var>, "whole")</em><a href="#index-freqz" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-1">
<span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>)</em><a href="#index-freqz-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-2">
<span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>)</em><a href="#index-freqz-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-3">
<span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>n</var>)</em><a href="#index-freqz-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-4">
<span class="category">: </span><span><em><var>h</var> =</em> <strong>freqz</strong> <em>(<var>b</var>, <var>a</var>, <var>w</var>)</em><a href="#index-freqz-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-5">
<span class="category">: </span><span><em>[<var>h</var>, <var>w</var>] =</em> <strong>freqz</strong> <em>(…, <var>Fs</var>)</em><a href="#index-freqz-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz-6">
<span class="category">: </span><span> <strong>freqz</strong> <em>(…)</em><a href="#index-freqz-6" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return the complex frequency response <var>h</var> of the rational IIR filter whose numerator and denominator coefficients are <var>b</var> and <var>a</var>, respectively. </p> <p>The response is evaluated at <var>n</var> angular frequencies between 0 and 2*pi. </p> <p>The output value <var>w</var> is a vector of the frequencies. </p> <p>If <var>a</var> is omitted, the denominator is assumed to be 1 (this corresponds to a simple FIR filter). </p> <p>If <var>n</var> is omitted, a value of 512 is assumed. For fastest computation, <var>n</var> should factor into a small number of small primes. </p> <p>If the fourth argument, <code>"whole"</code>, is omitted the response is evaluated at frequencies between 0 and pi. </p> <p><code>freqz (<var>b</var>, <var>a</var>, <var>w</var>)</code> </p> <p>Evaluate the response at the specific frequencies in the vector <var>w</var>. The values for <var>w</var> are measured in radians. </p> <p><code>[…] = freqz (…, <var>Fs</var>)</code> </p> <p>Return frequencies in Hz instead of radians assuming a sampling rate <var>Fs</var>. If you are evaluating the response at specific frequencies <var>w</var>, those frequencies should be requested in Hz rather than radians. </p> <p><code>freqz (…)</code> </p> <p>Plot the magnitude and phase response of <var>h</var> rather than returning them. </p> <p><strong>See also:</strong> <a href="#XREFfreqz_005fplot">freqz_plot</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-freqz_005fplot">
<span class="category">: </span><span> <strong>freqz_plot</strong> <em>(<var>w</var>, <var>h</var>)</em><a href="#index-freqz_005fplot" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-freqz_005fplot-1">
<span class="category">: </span><span> <strong>freqz_plot</strong> <em>(<var>w</var>, <var>h</var>, <var>freq_norm</var>)</em><a href="#index-freqz_005fplot-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Plot the magnitude and phase response of <var>h</var>. </p> <p>If the optional <var>freq_norm</var> argument is true, the frequency vector <var>w</var> is in units of normalized radians. If <var>freq_norm</var> is false, or not given, then <var>w</var> is measured in Hertz. </p> <p><strong>See also:</strong> <a href="#XREFfreqz">freqz</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sinc">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>sinc</strong> <em>(<var>x</var>)</em><a href="#index-sinc" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the sinc function. </p> <p>Return sin (pi*x) / (pi*x). </p>
</dd>
</dl> <dl class="def"> <dt id="index-unwrap">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>)</em><a href="#index-unwrap" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-unwrap-1">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>, <var>tol</var>)</em><a href="#index-unwrap-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-unwrap-2">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>unwrap</strong> <em>(<var>x</var>, <var>tol</var>, <var>dim</var>)</em><a href="#index-unwrap-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Unwrap radian phases by adding or subtracting multiples of 2*pi as appropriate to remove jumps greater than <var>tol</var>. </p> <p><var>tol</var> defaults to pi. </p> <p>Unwrap will work along the dimension <var>dim</var>. If <var>dim</var> is unspecified it defaults to the first non-singleton dimension. </p>
</dd>
</dl> <dl class="def"> <dt id="index-arch_005ffit">
<span class="category">: </span><span><em>[<var>a</var>, <var>b</var>] =</em> <strong>arch_fit</strong> <em>(<var>y</var>, <var>x</var>, <var>p</var>, <var>iter</var>, <var>gamma</var>, <var>a0</var>, <var>b0</var>)</em><a href="#index-arch_005ffit" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Fit an ARCH regression model to the time series <var>y</var> using the scoring algorithm in Engle’s original ARCH paper. </p> <p>The model is </p> <pre class="example" data-language="matlab">y(t) = b(1) * x(t,1) + … + b(k) * x(t,k) + e(t),
h(t) = a(1) + a(2) * e(t-1)^2 + … + a(p+1) * e(t-p)^2</pre> <p>in which <em class="math">e(t)</em> is <em class="math">N(0, h(t))</em>, given a time-series vector <var>y</var> up to time <em class="math">t-1</em> and a matrix of (ordinary) regressors <var>x</var> up to <em class="math">t</em>. The order of the regression of the residual variance is specified by <var>p</var>. </p> <p>If invoked as <code>arch_fit (<var>y</var>, <var>k</var>, <var>p</var>)</code> with a positive integer <var>k</var>, fit an ARCH(<var>k</var>, <var>p</var>) process, i.e., do the above with the <em class="math">t</em>-th row of <var>x</var> given by </p> <pre class="example" data-language="matlab">[1, y(t-1), …, y(t-k)]</pre> <p>Optionally, one can specify the number of iterations <var>iter</var>, the updating factor <var>gamma</var>, and initial values <em class="math">a0</em> and <em class="math">b0</em> for the scoring algorithm. </p>
</dd>
</dl> <dl class="def"> <dt id="index-arch_005frnd">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>arch_rnd</strong> <em>(<var>a</var>, <var>b</var>, <var>t</var>)</em><a href="#index-arch_005frnd" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Simulate an ARCH sequence of length <var>t</var> with AR coefficients <var>b</var> and CH coefficients <var>a</var>. </p> <p>The result <em class="math">y(t)</em> follows the model </p> <pre class="example" data-language="matlab">y(t) = b(1) + b(2) * y(t-1) + … + b(lb) * y(t-lb+1) + e(t),</pre> <p>where <em class="math">e(t)</em>, given <var>y</var> up to time <em class="math">t-1</em>, is <em class="math">N(0, h(t))</em>, with </p> <pre class="example" data-language="matlab">h(t) = a(1) + a(2) * e(t-1)^2 + … + a(la) * e(t-la+1)^2</pre> </dd>
</dl> <dl class="def"> <dt id="index-arch_005ftest">
<span class="category">: </span><span><em>[<var>pval</var>, <var>lm</var>] =</em> <strong>arch_test</strong> <em>(<var>y</var>, <var>x</var>, <var>p</var>)</em><a href="#index-arch_005ftest" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>For a linear regression model </p> <pre class="example" data-language="matlab">y = x * b + e</pre> <p>perform a Lagrange Multiplier (LM) test of the null hypothesis of no conditional heteroscedascity against the alternative of CH(<var>p</var>). </p> <p>I.e., the model is </p> <pre class="example" data-language="matlab">y(t) = b(1) * x(t,1) + … + b(k) * x(t,k) + e(t),</pre> <p>given <var>y</var> up to <em class="math">t-1</em> and <var>x</var> up to <em class="math">t</em>, <em class="math">e</em>(t) is <em class="math">N(0, h(t))</em> with </p> <pre class="example" data-language="matlab">h(t) = v + a(1) * e(t-1)^2 + … + a(p) * e(t-p)^2,</pre> <p>and the null is <em class="math">a(1)</em> == … == <em class="math">a(p)</em> == 0. </p> <p>If the second argument is a scalar integer, <em class="math">k</em>, perform the same test in a linear autoregression model of order <em class="math">k</em>, i.e., with </p> <pre class="example" data-language="matlab">[1, y(t-1), …, y(t-k)]</pre> <p>as the <em class="math">t</em>-th row of <var>x</var>. </p> <p>Under the null, LM approximately has a chisquare distribution with <var>p</var> degrees of freedom and <var>pval</var> is the <em class="math">p</em>-value (1 minus the CDF of this distribution at LM) of the test. </p> <p>If no output argument is given, the <em class="math">p</em>-value is displayed. </p>
</dd>
</dl> <dl class="def"> <dt id="index-arma_005frnd">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>arma_rnd</strong> <em>(<var>a</var>, <var>b</var>, <var>v</var>, <var>t</var>, <var>n</var>)</em><a href="#index-arma_005frnd" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a simulation of the ARMA model. </p> <p>The ARMA model is defined by </p> <pre class="example" data-language="matlab">x(n) = a(1) * x(n-1) + … + a(k) * x(n-k)
     + e(n) + b(1) * e(n-1) + … + b(l) * e(n-l)</pre> <p>in which <var>k</var> is the length of vector <var>a</var>, <var>l</var> is the length of vector <var>b</var> and <var>e</var> is Gaussian white noise with variance <var>v</var>. The function returns a vector of length <var>t</var>. </p> <p>The optional parameter <var>n</var> gives the number of dummy <var>x</var>(<var>i</var>) used for initialization, i.e., a sequence of length <var>t</var>+<var>n</var> is generated and <var>x</var>(<var>n</var>+1:<var>t</var>+<var>n</var>) is returned. If <var>n</var> is omitted, <var>n</var> = 100 is used. </p>
</dd>
</dl> <dl class="def"> <dt id="index-autoreg_005fmatrix">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>autoreg_matrix</strong> <em>(<var>y</var>, <var>k</var>)</em><a href="#index-autoreg_005fmatrix" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Given a time series (vector) <var>y</var>, return a matrix with ones in the first column and the first <var>k</var> lagged values of <var>y</var> in the other columns. </p> <p>In other words, for <var>t</var> &gt; <var>k</var>, <code>[1, <var>y</var>(<var>t</var>-1), …, <var>y</var>(<var>t</var>-<var>k</var>)]</code> is the t-th row of the result. </p> <p>The resulting matrix may be used as a regressor matrix in autoregressions. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bartlett">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>bartlett</strong> <em>(<var>m</var>)</em><a href="#index-bartlett" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Bartlett (triangular) window of length <var>m</var>. </p> <p>For a definition of the Bartlett window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-blackman">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>blackman</strong> <em>(<var>m</var>)</em><a href="#index-blackman" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-blackman-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>blackman</strong> <em>(<var>m</var>, "periodic")</em><a href="#index-blackman-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-blackman-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>blackman</strong> <em>(<var>m</var>, "symmetric")</em><a href="#index-blackman-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Blackman window of length <var>m</var>. </p> <p>If the optional argument <code>"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var>m</var>+1 with the last coefficient removed. The optional argument <code>"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Blackman window, see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-detrend">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>detrend</strong> <em>(<var>x</var>, <var>p</var>)</em><a href="#index-detrend" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>If <var>x</var> is a vector, <code>detrend (<var>x</var>, <var>p</var>)</code> removes the best fit of a polynomial of order <var>p</var> from the data <var>x</var>. </p> <p>If <var>x</var> is a matrix, <code>detrend (<var>x</var>, <var>p</var>)</code> does the same for each column in <var>x</var>. </p> <p>The second argument <var>p</var> is optional. If it is not specified, a value of 1 is assumed. This corresponds to removing a linear trend. </p> <p>The order of the polynomial can also be given as a string, in which case <var>p</var> must be either <code>"constant"</code> (corresponds to <code><var>p</var>=0</code>) or <code>"linear"</code> (corresponds to <code><var>p</var>=1</code>). </p> <p><strong>See also:</strong> <a href="polynomial-interpolation.html#XREFpolyfit">polyfit</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-diffpara">
<span class="category">: </span><span><em>[<var>d</var>, <var>dd</var>] =</em> <strong>diffpara</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>)</em><a href="#index-diffpara" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the estimator <var>d</var> for the differencing parameter of an integrated time series. </p> <p>The frequencies from <em class="math">[2*pi*a/t, 2*pi*b/T]</em> are used for the estimation. If <var>b</var> is omitted, the interval <em class="math">[2*pi/T, 2*pi*a/T]</em> is used. If both <var>b</var> and <var>a</var> are omitted then <em class="math">a = 0.5 * sqrt (T)</em> and <em class="math">b = 1.5 * sqrt (T)</em> is used, where <em class="math">T</em> is the sample size. If <var>x</var> is a matrix, the differencing parameter of each column is estimated. </p> <p>The estimators for all frequencies in the intervals described above is returned in <var>dd</var>. </p> <p>The value of <var>d</var> is simply the mean of <var>dd</var>. </p> <p>Reference: P.J. Brockwell &amp; R.A. Davis. <cite>Time Series: Theory and Methods</cite>. Springer 1987. </p>
</dd>
</dl> <dl class="def"> <dt id="index-durbinlevinson">
<span class="category">: </span><span><em>[<var>newphi</var>, <var>newv</var>] =</em> <strong>durbinlevinson</strong> <em>(<var>c</var>, <var>oldphi</var>, <var>oldv</var>)</em><a href="#index-durbinlevinson" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Perform one step of the Durbin-Levinson algorithm. </p> <p>The vector <var>c</var> specifies the autocovariances <code>[gamma_0, …, gamma_t]</code> from lag 0 to <var>t</var>, <var>oldphi</var> specifies the coefficients based on <var>c</var>(<var>t</var>-1) and <var>oldv</var> specifies the corresponding error. </p> <p>If <var>oldphi</var> and <var>oldv</var> are omitted, all steps from 1 to <var>t</var> of the algorithm are performed. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fftshift">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fftshift</strong> <em>(<var>x</var>)</em><a href="#index-fftshift" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-fftshift-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>fftshift</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-fftshift-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Perform a shift of the vector <var>x</var>, for use with the <code>fft</code> and <code>ifft</code> functions, in order to move the frequency 0 to the center of the vector or matrix. </p> <p>If <var>x</var> is a vector of <em class="math">N</em> elements corresponding to <em class="math">N</em> time samples spaced by <em class="math">dt</em>, then <code>fftshift (fft (<var>x</var>))</code> corresponds to frequencies </p> <pre class="example" data-language="matlab">f = [ -(ceil((N-1)/2):-1:1), 0, (1:floor((N-1)/2)) ] * df</pre> <p>where <em class="math">df = 1 / (N * dt)</em>. </p> <p>If <var>x</var> is a matrix, the same holds for rows and columns. If <var>x</var> is an array, then the same holds along each dimension. </p> <p>The optional <var>dim</var> argument can be used to limit the dimension along which the permutation occurs. </p> <p><strong>See also:</strong> <a href="#XREFifftshift">ifftshift</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ifftshift">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ifftshift</strong> <em>(<var>x</var>)</em><a href="#index-ifftshift" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ifftshift-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>ifftshift</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-ifftshift-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Undo the action of the <code>fftshift</code> function. </p> <p>For even length <var>x</var>, <code>fftshift</code> is its own inverse, but odd lengths differ slightly. </p> <p><strong>See also:</strong> <a href="#XREFfftshift">fftshift</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-fractdiff">
<span class="category">: </span><span><em><var>fd</var> =</em> <strong>fractdiff</strong> <em>(<var>x</var>, <var>d</var>)</em><a href="#index-fractdiff" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Compute the fractional differences <em class="math">(1-L)^d x</em> where <em class="math">L</em> denotes the lag-operator and <em class="math">d</em> is greater than -1. </p></dd>
</dl> <dl class="def"> <dt id="index-hamming">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hamming</strong> <em>(<var>m</var>)</em><a href="#index-hamming" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-hamming-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hamming</strong> <em>(<var>m</var>, "periodic")</em><a href="#index-hamming-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-hamming-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hamming</strong> <em>(<var>m</var>, "symmetric")</em><a href="#index-hamming-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Hamming window of length <var>m</var>. </p> <p>If the optional argument <code>"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var>m</var>+1 with the last coefficient removed. The optional argument <code>"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Hamming window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-hanning">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hanning</strong> <em>(<var>m</var>)</em><a href="#index-hanning" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-hanning-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hanning</strong> <em>(<var>m</var>, "periodic")</em><a href="#index-hanning-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-hanning-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>hanning</strong> <em>(<var>m</var>, "symmetric")</em><a href="#index-hanning-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the filter coefficients of a Hanning window of length <var>m</var>. </p> <p>If the optional argument <code>"periodic"</code> is given, the periodic form of the window is returned. This is equivalent to the window of length <var>m</var>+1 with the last coefficient removed. The optional argument <code>"symmetric"</code> is equivalent to not specifying a second argument. </p> <p>For a definition of the Hanning window see, e.g., A.V. Oppenheim &amp; R. W. Schafer, <cite>Discrete-Time Signal Processing</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-hurst">
<span class="category">: </span><span><em><var>H</var> =</em> <strong>hurst</strong> <em>(<var>x</var>)</em><a href="#index-hurst" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Estimate the Hurst parameter of sample <var>x</var> via the rescaled range statistic. </p> <p>If <var>x</var> is a matrix, the parameter is estimated for every column. </p>
</dd>
</dl> <dl class="def"> <dt id="index-pchip">
<span class="category">: </span><span><em><var>pp</var> =</em> <strong>pchip</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-pchip" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pchip-1">
<span class="category">: </span><span><em><var>yi</var> =</em> <strong>pchip</strong> <em>(<var>x</var>, <var>y</var>, <var>xi</var>)</em><a href="#index-pchip-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the Piecewise Cubic Hermite Interpolating Polynomial (pchip) of points <var>x</var> and <var>y</var>. </p> <p>If called with two arguments, return the piecewise polynomial <var>pp</var> that may be used with <code>ppval</code> to evaluate the polynomial at specific points. </p> <p>When called with a third input argument, <code>pchip</code> evaluates the pchip polynomial at the points <var>xi</var>. The third calling form is equivalent to <code>ppval (pchip (<var>x</var>, <var>y</var>), <var>xi</var>)</code>. </p> <p>The variable <var>x</var> must be a strictly monotonic vector (either increasing or decreasing) of length <var>n</var>. </p> <p><var>y</var> can be either a vector or array. If <var>y</var> is a vector then it must be the same length <var>n</var> as <var>x</var>. If <var>y</var> is an array then the size of <var>y</var> must have the form <code>[<var>s1</var>, <var>s2</var>, …, <var>sk</var>, <var>n</var>]</code> The array is reshaped internally to a matrix where the leading dimension is given by <code><var>s1</var> * <var>s2</var> * … * <var>sk</var></code> and each row of this matrix is then treated separately. Note that this is exactly opposite to <code>interp1</code> but is done for <small>MATLAB</small> compatibility. </p> <p><strong>See also:</strong> <a href="one_002ddimensional-interpolation.html#XREFspline">spline</a>, <a href="polynomial-interpolation.html#XREFppval">ppval</a>, <a href="polynomial-interpolation.html#XREFmkpp">mkpp</a>, <a href="polynomial-interpolation.html#XREFunmkpp">unmkpp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-periodogram">
<span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>)</em><a href="#index-periodogram" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-periodogram-1">
<span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>)</em><a href="#index-periodogram-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-periodogram-2">
<span class="category">: </span><span><em>[<var>Pxx</var>, <var>w</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>, <var>nfft</var>)</em><a href="#index-periodogram-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-periodogram-3">
<span class="category">: </span><span><em>[<var>Pxx</var>, <var>f</var>] =</em> <strong>periodogram</strong> <em>(<var>x</var>, <var>win</var>, <var>nfft</var>, <var>Fs</var>)</em><a href="#index-periodogram-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-periodogram-4">
<span class="category">: </span><span><em>[<var>Pxx</var>, <var>f</var>] =</em> <strong>periodogram</strong> <em>(…, "<var>range</var>")</em><a href="#index-periodogram-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-periodogram-5">
<span class="category">: </span><span> <strong>periodogram</strong> <em>(…)</em><a href="#index-periodogram-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the periodogram (Power Spectral Density) of <var>x</var>. </p> <p>The possible inputs are: </p> <dl compact> <dt><span><var>x</var></span></dt> <dd> <p>data vector. If <var>x</var> is real-valued a one-sided spectrum is estimated. If <var>x</var> is complex-valued, or <code>"<var>range</var>"</code> specifies <code>"twosided"</code>, the full spectrum is estimated. </p> </dd> <dt><span><var>win</var></span></dt> <dd>
<p>window weight data. If window is empty or unspecified a default rectangular window is used. Otherwise, the window is applied to the signal (<code><var>x</var> .* <var>win</var></code>) before computing the periodogram. The window data must be a vector of the same length as <var>x</var>. </p> </dd> <dt><span><var>nfft</var></span></dt> <dd>
<p>number of frequency bins. The default is 256 or the next higher power of 2 greater than the length of <var>x</var> (<code>max (256, 2.^nextpow2 (length (x)))</code>). If <var>nfft</var> is greater than the length of the input then <var>x</var> will be zero-padded to the length of <var>nfft</var>. </p> </dd> <dt><span><var>Fs</var></span></dt> <dd>
<p>sampling rate. The default is 1. </p> </dd> <dt><span><var>range</var></span></dt> <dd><p>range of spectrum. <code>"onesided"</code> computes spectrum from [0:nfft/2+1]. <code>"twosided"</code> computes spectrum from [0:nfft-1]. </p></dd> </dl> <p>The optional second output <var>w</var> are the normalized angular frequencies. For a one-sided calculation <var>w</var> is in the range [0, pi] if <var>nfft</var> is even and [0, pi) if <var>nfft</var> is odd. Similarly, for a two-sided calculation <var>w</var> is in the range [0, 2*pi] or [0, 2*pi) depending on <var>nfft</var>. </p> <p>If a sampling frequency is specified, <var>Fs</var>, then the output frequencies <var>f</var> will be in the range [0, <var>Fs</var>/2] or [0, <var>Fs</var>/2) for one-sided calculations. For two-sided calculations the range will be [0, <var>Fs</var>). </p> <p>When called with no outputs the periodogram is immediately plotted in the current figure window. </p> <p><strong>See also:</strong> <a href="#XREFfft">fft</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sinetone">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>sinetone</strong> <em>(<var>freq</var>, <var>rate</var>, <var>sec</var>, <var>ampl</var>)</em><a href="#index-sinetone" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a sinetone of frequency <var>freq</var> with a length of <var>sec</var> seconds at sampling rate <var>rate</var> and with amplitude <var>ampl</var>. </p> <p>The arguments <var>freq</var> and <var>ampl</var> may be vectors of common size. </p> <p>The defaults are <var>rate</var> = 8000, <var>sec</var> = 1, and <var>ampl</var> = 64. </p> <p><strong>See also:</strong> <a href="#XREFsinewave">sinewave</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sinewave">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>sinewave</strong> <em>(<var>m</var>, <var>n</var>, <var>d</var>)</em><a href="#index-sinewave" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return an <var>m</var>-element vector with <var>i</var>-th element given by <code>sin (2 * pi * (<var>i</var>+<var>d</var>-1) / <var>n</var>)</code>. </p> <p>The default value for <var>d</var> is 0 and the default value for <var>n</var> is <var>m</var>. </p> <p><strong>See also:</strong> <a href="#XREFsinetone">sinetone</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spectral_005fadf">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_adf</strong> <em>(<var>c</var>)</em><a href="#index-spectral_005fadf" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spectral_005fadf-1">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_adf</strong> <em>(<var>c</var>, <var>win</var>)</em><a href="#index-spectral_005fadf-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spectral_005fadf-2">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_adf</strong> <em>(<var>c</var>, <var>win</var>, <var>b</var>)</em><a href="#index-spectral_005fadf-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the spectral density estimator given a vector of autocovariances <var>c</var>, window name <var>win</var>, and bandwidth, <var>b</var>. </p> <p>The window name, e.g., <code>"triangle"</code> or <code>"rectangle"</code> is used to search for a function called <code><var>win</var>_lw</code>. </p> <p>If <var>win</var> is omitted, the triangle window is used. </p> <p>If <var>b</var> is omitted, <code>1 / sqrt (length (<var>x</var>))</code> is used. </p> <p><strong>See also:</strong> <a href="#XREFspectral_005fxdf">spectral_xdf</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spectral_005fxdf">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_xdf</strong> <em>(<var>x</var>)</em><a href="#index-spectral_005fxdf" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spectral_005fxdf-1">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_xdf</strong> <em>(<var>x</var>, <var>win</var>)</em><a href="#index-spectral_005fxdf-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-spectral_005fxdf-2">
<span class="category">: </span><span><em><var>sde</var> =</em> <strong>spectral_xdf</strong> <em>(<var>x</var>, <var>win</var>, <var>b</var>)</em><a href="#index-spectral_005fxdf-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the spectral density estimator given a data vector <var>x</var>, window name <var>win</var>, and bandwidth, <var>b</var>. </p> <p>The window name, e.g., <code>"triangle"</code> or <code>"rectangle"</code> is used to search for a function called <code><var>win</var>_sw</code>. </p> <p>If <var>win</var> is omitted, the triangle window is used. </p> <p>If <var>b</var> is omitted, <code>1 / sqrt (length (<var>x</var>))</code> is used. </p> <p><strong>See also:</strong> <a href="#XREFspectral_005fadf">spectral_adf</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-spencer">
<span class="category">: </span><span><em><var>savg</var> =</em> <strong>spencer</strong> <em>(<var>x</var>)</em><a href="#index-spencer" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return Spencer’s 15-point moving average of each column of <var>x</var>. </p></dd>
</dl> <dl class="def"> <dt id="index-stft">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>)</em><a href="#index-stft" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-stft-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>)</em><a href="#index-stft-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-stft-2">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>)</em><a href="#index-stft-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-stft-3">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>, <var>num_coef</var>)</em><a href="#index-stft-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-stft-4">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>stft</strong> <em>(<var>x</var>, <var>win_size</var>, <var>inc</var>, <var>num_coef</var>, <var>win_type</var>)</em><a href="#index-stft-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-stft-5">
<span class="category">: </span><span><em>[<var>y</var>, <var>c</var>] =</em> <strong>stft</strong> <em>(…)</em><a href="#index-stft-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the short-time Fourier transform of the vector <var>x</var> with <var>num_coef</var> coefficients by applying a window of <var>win_size</var> data points and an increment of <var>inc</var> points. </p> <p>Before computing the Fourier transform, one of the following windows is applied: </p> <dl compact> <dt><span><code>"hanning"</code></span></dt> <dd>
<p>win_type = 1 </p> </dd> <dt><span><code>"hamming"</code></span></dt> <dd>
<p>win_type = 2 </p> </dd> <dt><span><code>"rectangle"</code></span></dt> <dd><p>win_type = 3 </p></dd> </dl> <p>The window names can be passed as strings or by the <var>win_type</var> number. </p> <p>The following defaults are used for unspecified arguments: <var>win_size</var> = 80, <var>inc</var> = 24, <var>num_coef</var> = 64, and <var>win_type</var> = 1. </p> <p><code><var>y</var> = stft (<var>x</var>, …)</code> returns the absolute values of the Fourier coefficients according to the <var>num_coef</var> positive frequencies. </p> <p><code>[<var>y</var>, <var>c</var>] = stft (<var>x</var>, …)</code> returns the entire STFT-matrix <var>y</var> and a 3-element vector <var>c</var> containing the window size, increment, and window type, which is needed by the <code>synthesis</code> function. </p> <p><strong>See also:</strong> <a href="#XREFsynthesis">synthesis</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-synthesis">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>synthesis</strong> <em>(<var>y</var>, <var>c</var>)</em><a href="#index-synthesis" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute a signal from its short-time Fourier transform <var>y</var> and a 3-element vector <var>c</var> specifying window size, increment, and window type. </p> <p>The values <var>y</var> and <var>c</var> can be derived by </p> <pre class="example" data-language="matlab">[y, c] = stft (x , …)</pre> <p><strong>See also:</strong> <a href="#XREFstft">stft</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-yulewalker">
<span class="category">: </span><span><em>[<var>a</var>, <var>v</var>] =</em> <strong>yulewalker</strong> <em>(<var>c</var>)</em><a href="#index-yulewalker" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Fit an AR (p)-model with Yule-Walker estimates given a vector <var>c</var> of autocovariances <code>[gamma_0, …, gamma_p]</code>. </p> <p>Returns the AR coefficients, <var>a</var>, and the variance of white noise, <var>v</var>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Signal-Processing.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Signal-Processing.html</a>
  </p>
</div>
