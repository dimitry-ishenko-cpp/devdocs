<div class="section" id="Set-Operations">   <h1 class="section">27.1 Set Operations</h1> <p>Octave supports several basic set operations. Octave can compute the union, intersection, and difference of two sets. Octave also supports the <em>Exclusive Or</em> set operation. </p> <p>The functions for set operations all work in the same way by accepting two input sets and returning a third set. As an example, assume that <code>a</code> and <code>b</code> contains two sets, then </p> <pre class="example" data-language="matlab">union (a, b)</pre> <p>computes the union of the two sets. </p> <p>Finally, determining whether elements belong to a set can be done with the <code>ismember</code> function. Because sets are ordered this operation is very efficient and is of order O(log2(n)) which is preferable to the <code>find</code> function which is of order O(n). </p> <dl class="def"> <dt id="index-intersect">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>intersect</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-intersect" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-intersect-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>intersect</strong> <em>(<var>a</var>, <var>b</var>, "rows")</em><a href="#index-intersect-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-intersect-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>intersect</strong> <em>(…, "sorted")</em><a href="#index-intersect-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-intersect-3">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>intersect</strong> <em>(…, "stable")</em><a href="#index-intersect-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-intersect-4">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>intersect</strong> <em>(…, "legacy")</em><a href="#index-intersect-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-intersect-5">
<span class="category">: </span><span><em>[<var>c</var>, <var>ia</var>, <var>ib</var>] =</em> <strong>intersect</strong> <em>(…)</em><a href="#index-intersect-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return the unique elements common to both <var>a</var> and <var>b</var>. </p> <p>If <var>a</var> and <var>b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code>"rows"</code> is given then return the common rows of <var>a</var> and <var>b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code>"sorted"</code>/<code>"stable"</code> controls the order in which unique values appear in the output. The default is <code>"sorted"</code> and values in the output are placed in ascending order. The alternative <code>"stable"</code> preserves the order found in the input. </p> <p>If requested, return column index vectors <var>ia</var> and <var>ib</var> such that <code><var>c</var> = <var>a</var>(<var>ia</var>)</code> and <code><var>c</var> = <var>b</var>(<var>ib</var>)</code>. </p> <p>Programming Note: The input flag <code>"legacy"</code> changes the algorithm to be compatible with <small>MATLAB</small> releases prior to R2012b. </p> <p><strong>See also:</strong> <a href="sets.html#XREFunique">unique</a>, <a href="#XREFunion">union</a>, <a href="#XREFsetdiff">setdiff</a>, <a href="#XREFsetxor">setxor</a>, <a href="#XREFismember">ismember</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-union">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>union</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-union" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-union-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>union</strong> <em>(<var>a</var>, <var>b</var>, "rows")</em><a href="#index-union-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-union-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>union</strong> <em>(…, "sorted")</em><a href="#index-union-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-union-3">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>union</strong> <em>(…, "stable")</em><a href="#index-union-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-union-4">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>union</strong> <em>(…, "legacy")</em><a href="#index-union-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-union-5">
<span class="category">: </span><span><em>[<var>c</var>, <var>ia</var>, <var>ib</var>] =</em> <strong>union</strong> <em>(…)</em><a href="#index-union-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return the unique elements that are in either <var>a</var> or <var>b</var>. </p> <p>If <var>a</var> and <var>b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code>"rows"</code> is given then return rows that are in either <var>a</var> or <var>b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code>"sorted"</code>/<code>"stable"</code> controls the order in which unique values appear in the output. The default is <code>"sorted"</code> and values in the output are placed in ascending order. The alternative <code>"stable"</code> preserves the order found in the input. </p> <p>The optional outputs <var>ia</var> and <var>ib</var> are column index vectors such that <code><var>a</var>(<var>ia</var>)</code> and <code><var>b</var>(<var>ib</var>)</code> are disjoint sets whose union is <var>c</var>. </p> <p>Programming Note: The input flag <code>"legacy"</code> changes the algorithm to be compatible with <small>MATLAB</small> releases prior to R2012b. </p> <p><strong>See also:</strong> <a href="sets.html#XREFunique">unique</a>, <a href="#XREFintersect">intersect</a>, <a href="#XREFsetdiff">setdiff</a>, <a href="#XREFsetxor">setxor</a>, <a href="#XREFismember">ismember</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-setdiff">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setdiff</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-setdiff" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setdiff-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setdiff</strong> <em>(<var>a</var>, <var>b</var>, "rows")</em><a href="#index-setdiff-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setdiff-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setdiff</strong> <em>(…, "sorted")</em><a href="#index-setdiff-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setdiff-3">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setdiff</strong> <em>(…, "stable")</em><a href="#index-setdiff-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setdiff-4">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setdiff</strong> <em>(…, "legacy")</em><a href="#index-setdiff-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setdiff-5">
<span class="category">: </span><span><em>[<var>c</var>, <var>ia</var>] =</em> <strong>setdiff</strong> <em>(…)</em><a href="#index-setdiff-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the unique elements in <var>a</var> that are not in <var>b</var>. </p> <p>If <var>a</var> is a row vector return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code>"rows"</code> is given then return the rows in <var>a</var> that are not in <var>b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code>"sorted"</code>/<code>"stable"</code> controls the order in which unique values appear in the output. The default is <code>"sorted"</code> and values in the output are placed in ascending order. The alternative <code>"stable"</code> preserves the order found in the input. </p> <p>If requested, return the index vector <var>ia</var> such that <code><var>c</var> = <var>a</var>(<var>ia</var>)</code>. </p> <p>Programming Note: The input flag <code>"legacy"</code> changes the algorithm to be compatible with <small>MATLAB</small> releases prior to R2012b. </p> <p><strong>See also:</strong> <a href="sets.html#XREFunique">unique</a>, <a href="#XREFunion">union</a>, <a href="#XREFintersect">intersect</a>, <a href="#XREFsetxor">setxor</a>, <a href="#XREFismember">ismember</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-setxor">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setxor</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-setxor" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setxor-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setxor</strong> <em>(<var>a</var>, <var>b</var>, "rows")</em><a href="#index-setxor-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setxor-2">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setxor</strong> <em>(…, "sorted")</em><a href="#index-setxor-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setxor-3">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setxor</strong> <em>(…, "stable")</em><a href="#index-setxor-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setxor-4">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>setxor</strong> <em>(…, "legacy")</em><a href="#index-setxor-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-setxor-5">
<span class="category">: </span><span><em>[<var>c</var>, <var>ia</var>, <var>ib</var>] =</em> <strong>setxor</strong> <em>(…)</em><a href="#index-setxor-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return the unique elements exclusive to sets <var>a</var> or <var>b</var>. </p> <p>If <var>a</var> and <var>b</var> are both row vectors then return a row vector; Otherwise, return a column vector. The inputs may also be cell arrays of strings. </p> <p>If the optional input <code>"rows"</code> is given then return the rows exclusive to sets <var>a</var> and <var>b</var>. The inputs must be 2-D numeric matrices to use this option. </p> <p>The optional argument <code>"sorted"</code>/<code>"stable"</code> controls the order in which unique values appear in the output. The default is <code>"sorted"</code> and values in the output are placed in ascending order. The alternative <code>"stable"</code> preserves the order found in the input. </p> <p>The optional outputs <var>ia</var> and <var>ib</var> are column index vectors such that <code><var>a</var>(<var>ia</var>)</code> and <code><var>b</var>(<var>ib</var>)</code> are disjoint sets whose union is <var>c</var>. </p> <p>Programming Note: The input flag <code>"legacy"</code> changes the algorithm to be compatible with <small>MATLAB</small> releases prior to R2012b. </p> <p><strong>See also:</strong> <a href="sets.html#XREFunique">unique</a>, <a href="#XREFunion">union</a>, <a href="#XREFintersect">intersect</a>, <a href="#XREFsetdiff">setdiff</a>, <a href="#XREFismember">ismember</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ismember">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ismember</strong> <em>(<var>a</var>, <var>s</var>)</em><a href="#index-ismember" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ismember-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>ismember</strong> <em>(<var>a</var>, <var>s</var>, "rows")</em><a href="#index-ismember-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ismember-2">
<span class="category">: </span><span><em>[<var>tf</var>, <var>s_idx</var>] =</em> <strong>ismember</strong> <em>(…)</em><a href="#index-ismember-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Return a logical matrix <var>tf</var> with the same shape as <var>a</var> which is true (1) if the element in <var>a</var> is found in <var>s</var> and false (0) if it is not. </p> <p>If a second output argument is requested then the index into <var>s</var> of each matching element is also returned. </p> <pre class="example" data-language="matlab">a = [3, 10, 1];
s = [0:9];
[tf, s_idx] = ismember (a, s)
     ⇒ tf = [1, 0, 1]
     ⇒ s_idx = [4, 0, 2]</pre> <p>The inputs <var>a</var> and <var>s</var> may also be cell arrays. </p> <pre class="example" data-language="matlab">a = {"abc"};
s = {"abc", "def"};
[tf, s_idx] = ismember (a, s)
     ⇒ tf = 1
     ⇒ s_idx = 1</pre> <p>If the optional third argument <code>"rows"</code> is given then compare rows in <var>a</var> with rows in <var>s</var>. The inputs must be 2-D matrices with the same number of columns to use this option. </p> <pre class="example" data-language="matlab">a = [1:3; 5:7; 4:6];
s = [0:2; 1:3; 2:4; 3:5; 4:6];
[tf, s_idx] = ismember (a, s, "rows")
     ⇒ tf = logical ([1; 0; 1])
     ⇒ s_idx = [2; 0; 5];</pre> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions.html#XREFlookup">lookup</a>, <a href="sets.html#XREFunique">unique</a>, <a href="#XREFunion">union</a>, <a href="#XREFintersect">intersect</a>, <a href="#XREFsetdiff">setdiff</a>, <a href="#XREFsetxor">setxor</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-powerset">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>powerset</strong> <em>(<var>a</var>)</em><a href="#index-powerset" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-powerset-1">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>powerset</strong> <em>(<var>a</var>, "rows")</em><a href="#index-powerset-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the powerset (all subsets) of the set <var>a</var>. </p> <p>The set <var>a</var> must be a numerical matrix or a cell array of strings. The output will always be a cell array of either vectors or strings. </p> <p>With the optional argument <code>"rows"</code>, each row of the set <var>a</var> is considered one element of the set. The input must be a 2-D numeric matrix to use this argument. </p> <p><strong>See also:</strong> <a href="sets.html#XREFunique">unique</a>, <a href="#XREFunion">union</a>, <a href="#XREFintersect">intersect</a>, <a href="#XREFsetdiff">setdiff</a>, <a href="#XREFsetxor">setxor</a>, <a href="#XREFismember">ismember</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Set-Operations.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Set-Operations.html</a>
  </p>
</div>
