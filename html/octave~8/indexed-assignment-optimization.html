<div class="subsection" id="Indexed-Assignment-Optimization">   <h1 class="subsection">34.3.2 Indexed Assignment Optimization</h1> <p>Octave’s ubiquitous lazily-copied pass-by-value semantics implies a problem for performance of user-defined <code>subsasgn</code> methods. Imagine the following call to <code>subsasgn</code> </p> <pre class="example" data-language="matlab">ss = substruct ("()", {1});
x = subsasgn (x, ss, 1);</pre> <p>where the corresponding method looking like this: </p> <pre class="example" data-language="matlab">function x = subsasgn (x, ss, val)
  …
  x.myfield (ss.subs{1}) = val;
endfunction</pre> <p>The problem is that on entry to the <code>subsasgn</code> method, <code>x</code> is still referenced from the caller’s scope, which means that the method will first need to unshare (copy) <code>x</code> and <code>x.myfield</code> before performing the assignment. Upon completing the call, unless an error occurs, the result is immediately assigned to <code>x</code> in the caller’s scope, so that the previous value of <code>x.myfield</code> is forgotten. Hence, the Octave language implies a copy of N elements (N being the size of <code>x.myfield</code>), where modifying just a single element would actually suffice. In other words, a constant-time operation is degraded to linear-time one. This may be a real problem for user classes that intrinsically store large arrays. </p> <p>To partially solve the problem Octave uses a special optimization for user-defined <code>subsasgn</code> methods coded as m-files. When the method gets called as a result of the built-in assignment syntax (not a direct <code>subsasgn</code> call as shown above), i.e., <code>x(1) = 1</code>, <b>AND</b> if the <code>subsasgn</code> method is declared with identical input and output arguments, as in the example above, then Octave will ignore the copy of <code>x</code> inside the caller’s scope; therefore, any changes made to <code>x</code> during the method execution will directly affect the caller’s copy as well. This allows, for instance, defining a polynomial class where modifying a single element takes constant time. </p> <p>It is important to understand the implications that this optimization brings. Since no extra copy of <code>x</code> will exist in the caller’s scope, it is <em>solely</em> the callee’s responsibility to not leave <code>x</code> in an invalid state if an error occurs during the execution. Also, if the method partially changes <code>x</code> and then errors out, the changes <em>will</em> affect <code>x</code> in the caller’s scope. Deleting or completely replacing <code>x</code> inside subsasgn will not do anything, however, only indexed assignments matter. </p> <p>Since this optimization may change the way code works (especially if badly written), a function <code>optimize_subsasgn_calls</code> is provided to control it. This feature is enabled by default. Another way to avoid the optimization is to declare subsasgn methods with different output and input arguments like this: </p> <pre class="example" data-language="matlab">function y = subsasgn (x, ss, val)
  …
endfunction</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Indexed-Assignment-Optimization.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Indexed-Assignment-Optimization.html</a>
  </p>
</div>
