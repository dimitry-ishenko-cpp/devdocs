<div class="section" id="Quadratic-Programming">   <h1 class="section">25.2 Quadratic Programming</h1> <p>Octave can also solve Quadratic Programming problems, this is </p> <pre class="example" data-language="matlab">min 0.5 x'*H*x + x'*q</pre> <p>subject to </p> <pre class="example" data-language="matlab">A*x = b
     lb &lt;= x &lt;= ub
     A_lb &lt;= A_in*x &lt;= A_ub</pre> <dl class="def"> <dt id="index-qp">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(<var>x0</var>, <var>H</var>)</em><a href="#index-qp" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qp-1">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(<var>x0</var>, <var>H</var>, <var>q</var>)</em><a href="#index-qp-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qp-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(<var>x0</var>, <var>H</var>, <var>q</var>, <var>A</var>, <var>b</var>)</em><a href="#index-qp-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qp-3">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(<var>x0</var>, <var>H</var>, <var>q</var>, <var>A</var>, <var>b</var>, <var>lb</var>, <var>ub</var>)</em><a href="#index-qp-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qp-4">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(<var>x0</var>, <var>H</var>, <var>q</var>, <var>A</var>, <var>b</var>, <var>lb</var>, <var>ub</var>, <var>A_lb</var>, <var>A_in</var>, <var>A_ub</var>)</em><a href="#index-qp-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-qp-5">
<span class="category">: </span><span><em>[<var>x</var>, <var>obj</var>, <var>info</var>, <var>lambda</var>] =</em> <strong>qp</strong> <em>(…, <var>options</var>)</em><a href="#index-qp-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve a quadratic program (QP). </p> <p>Solve the quadratic program defined by </p> <pre class="example" data-language="matlab">min 0.5 x'*H*x + x'*q
 x</pre> <p>subject to </p> <pre class="example" data-language="matlab">A*x = b
lb &lt;= x &lt;= ub
A_lb &lt;= A_in*x &lt;= A_ub</pre> <p>using a null-space active-set method. </p> <p>Any bound (<var>A</var>, <var>b</var>, <var>lb</var>, <var>ub</var>, <var>A_in</var>, <var>A_lb</var>, <var>A_ub</var>) may be set to the empty matrix (<code>[]</code>) if not present. The constraints <var>A</var> and <var>A_in</var> are matrices with each row representing a single constraint. The other bounds are scalars or vectors depending on the number of constraints. The algorithm is faster if the initial guess is feasible. </p> <p><var>options</var> is a structure specifying additional parameters which control the algorithm. Currently, <code>qp</code> recognizes these options: <code>"MaxIter"</code>, <code>"TolX"</code>. </p> <p><code>"MaxIter"</code> proscribes the maximum number of algorithm iterations before optimization is halted. The default value is 200. The value must be a positive integer. </p> <p><code>"TolX"</code> specifies the termination tolerance for the unknown variables <var>x</var>. The default is <code>sqrt (eps)</code> or approximately 1e-8. </p> <p>On return, <var>x</var> is the location of the minimum and <var>fval</var> contains the value of the objective function at <var>x</var>. </p> <dl compact> <dt><span><var>info</var></span></dt> <dd>
<p>Structure containing run-time information about the algorithm. The following fields are defined: </p> <dl compact> <dt><span><code>solveiter</code></span></dt> <dd>
<p>The number of iterations required to find the solution. </p> </dd> <dt><span><code>info</code></span></dt> <dd>
<p>An integer indicating the status of the solution. </p> <dl compact> <dt><span>0</span></dt> <dd>
<p>The problem is feasible and convex. Global solution found. </p> </dd> <dt><span>1</span></dt> <dd>
<p>The problem is not convex. Local solution found. </p> </dd> <dt><span>2</span></dt> <dd>
<p>The problem is not convex and unbounded. </p> </dd> <dt><span>3</span></dt> <dd>
<p>Maximum number of iterations reached. </p> </dd> <dt><span>6</span></dt> <dd><p>The problem is infeasible. </p></dd> </dl> </dd> </dl> </dd> </dl> <p><strong>See also:</strong> <a href="nonlinear-programming.html#XREFsqp">sqp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-pqpnonneg">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>pqpnonneg</strong> <em>(<var>c</var>, <var>d</var>)</em><a href="#index-pqpnonneg" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>pqpnonneg</strong> <em>(<var>c</var>, <var>d</var>, <var>x0</var>)</em><a href="#index-pqpnonneg-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>pqpnonneg</strong> <em>(<var>c</var>, <var>d</var>, <var>x0</var>, <var>options</var>)</em><a href="#index-pqpnonneg-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-3">
<span class="category">: </span><span><em>[<var>x</var>, <var>minval</var>] =</em> <strong>pqpnonneg</strong> <em>(…)</em><a href="#index-pqpnonneg-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-4">
<span class="category">: </span><span><em>[<var>x</var>, <var>minval</var>, <var>exitflag</var>] =</em> <strong>pqpnonneg</strong> <em>(…)</em><a href="#index-pqpnonneg-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-5">
<span class="category">: </span><span><em>[<var>x</var>, <var>minval</var>, <var>exitflag</var>, <var>output</var>] =</em> <strong>pqpnonneg</strong> <em>(…)</em><a href="#index-pqpnonneg-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pqpnonneg-6">
<span class="category">: </span><span><em>[<var>x</var>, <var>minval</var>, <var>exitflag</var>, <var>output</var>, <var>lambda</var>] =</em> <strong>pqpnonneg</strong> <em>(…)</em><a href="#index-pqpnonneg-6" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Minimize <code> (1/2 * <var>x</var>' * <var>c</var> * <var>x</var> + <var>d</var>' * <var>x</var>) </code> subject to <code><var>x</var> &gt;= 0</code>. </p> <p><var>c</var> and <var>d</var> must be real matrices, and <var>c</var> must be symmetric and positive definite. </p> <p><var>x0</var> is an optional initial guess for the solution <var>x</var>. </p> <p><var>options</var> is an options structure to change the behavior of the algorithm (see <a href="linear-least-squares.html#XREFoptimset"><code>optimset</code></a>). <code>pqpnonneg</code> recognizes one option: <code>"MaxIter"</code>. </p> <p>Outputs: </p> <dl compact> <dt><span><var>x</var></span></dt> <dd>
<p>The solution matrix </p> </dd> <dt><span><var>minval</var></span></dt> <dd>
<p>The minimum attained model value, <code>1/2*<var>xmin</var>'*<var>c</var>*<var>xmin</var> + <var>d</var>'*<var>xmin</var></code> </p> </dd> <dt><span><var>exitflag</var></span></dt> <dd>
<p>An indicator of convergence. 0 indicates that the iteration count was exceeded, and therefore convergence was not reached; &gt;0 indicates that the algorithm converged. (The algorithm is stable and will converge given enough iterations.) </p> </dd> <dt><span><var>output</var></span></dt> <dd>
<p>A structure with two fields: </p> <ul> <li> <code>"algorithm"</code>: The algorithm used (<code>"nnls"</code>) </li>
<li> <code>"iterations"</code>: The number of iterations taken. </li>
</ul> </dd> <dt><span><var>lambda</var></span></dt> <dd>
<p>Lagrange multipliers. If these are nonzero, the corresponding <var>x</var> values should be zero, indicating the solution is pressed up against a coordinate plane. The magnitude indicates how much the residual would improve if the <code><var>x</var> &gt;= 0</code> constraints were relaxed in that direction. </p> </dd> </dl> <p><strong>See also:</strong> <a href="linear-least-squares.html#XREFlsqnonneg">lsqnonneg</a>, <a href="#XREFqp">qp</a>, <a href="linear-least-squares.html#XREFoptimset">optimset</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Quadratic-Programming.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Quadratic-Programming.html</a>
  </p>
</div>
