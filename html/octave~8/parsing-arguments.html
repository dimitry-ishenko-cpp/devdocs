<div class="subsection" id="Parsing-Arguments">   <h1 class="subsection">11.9.3 Parsing Arguments</h1> <p>If none of the preceding validation functions is sufficient there is also the class <code>inputParser</code> which can perform extremely complex input checking for functions. </p> <dl class="def"> <dt id="index-inputParser">
<span class="category">: </span><span><em><var>p</var> =</em> <strong>inputParser</strong> <em>()</em><a href="#index-inputParser" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Create object <var>p</var> of the inputParser class. </p> <p>This class is designed to allow easy parsing of function arguments. The class supports four types of arguments: </p> <ol> <li> mandatory (see <code>addRequired</code>); </li>
<li> optional (see <code>addOptional</code>); </li>
<li> named (see <code>addParameter</code>); </li>
<li> switch (see <code>addSwitch</code>). </li>
</ol> <p>After defining the function API with these methods, the supplied arguments can be parsed with the <code>parse</code> method and the parsing results accessed with the <code>Results</code> accessor. </p>
</dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eParameters">
<span class="category">: </span><span> <strong>inputParser.Parameters</strong><a href="#index-inputParser_002eParameters" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return list of parameter names already defined. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eResults">
<span class="category">: </span><span> <strong>inputParser.Results</strong><a href="#index-inputParser_002eResults" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return structure with argument names as fieldnames and corresponding values. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eUnmatched">
<span class="category">: </span><span> <strong>inputParser.Unmatched</strong><a href="#index-inputParser_002eUnmatched" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return structure similar to <code>Results</code>, but for unmatched parameters. See the <code>KeepUnmatched</code> property. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eUsingDefaults">
<span class="category">: </span><span> <strong>inputParser.UsingDefaults</strong><a href="#index-inputParser_002eUsingDefaults" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Return cell array with the names of arguments that are using default values. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eCaseSensitive">
<span class="category">: </span><span> <strong>inputParser.CaseSensitive</strong> <em>= <var>boolean</var></em><a href="#index-inputParser_002eCaseSensitive" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Set whether matching of argument names should be case sensitive. Defaults to false. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eFunctionName">
<span class="category">: </span><span> <strong>inputParser.FunctionName</strong> <em>= <var>name</var></em><a href="#index-inputParser_002eFunctionName" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Set function name to be used in error messages; Defaults to empty string. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eKeepUnmatched">
<span class="category">: </span><span> <strong>inputParser.KeepUnmatched</strong> <em>= <var>boolean</var></em><a href="#index-inputParser_002eKeepUnmatched" class="copiable-anchor"> ¶</a></span>
</dt> <dd><p>Set whether an error should be given for non-defined arguments. Defaults to false. If set to true, the extra arguments can be accessed through <code>Unmatched</code> after the <code>parse</code> method. Note that since <code>Switch</code> and <code>Parameter</code> arguments can be mixed, it is not possible to know the unmatched type. If argument is found unmatched it is assumed to be of the <code>Parameter</code> type and it is expected to be followed by a value. </p></dd>
</dl> <dl class="def"> <dt id="index-inputParser_002eStructExpand">
<span class="category">: </span><span> <strong>inputParser.StructExpand</strong> <em>= <var>boolean</var></em><a href="#index-inputParser_002eStructExpand" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Set whether a structure can be passed to the function instead of parameter/value pairs. Defaults to true. </p> <p>The following example shows how to use this class: </p> <pre class="example" data-language="matlab">function check (varargin)
  p = inputParser ();                      # create object
  p.FunctionName = "check";                # set function name
  p.addRequired ("pack", @ischar);         # mandatory argument
  p.addOptional ("path", pwd(), @ischar);  # optional argument

  ## create a function handle to anonymous functions for validators
  val_mat = @(x) isvector (x) &amp;&amp; all (x &lt;= 1) &amp;&amp; all (x &gt;= 0);
  p.addOptional ("mat", [0 0], val_mat);

  ## create two arguments of type "Parameter"
  val_type = @(x) any (strcmp (x, {"linear", "quadratic"}));
  p.addParameter ("type", "linear", val_type);
  val_verb = @(x) any (strcmp (x, {"low", "medium", "high"}));
  p.addParameter ("tolerance", "low", val_verb);

  ## create a switch type of argument
  p.addSwitch ("verbose");

  p.parse (varargin{:});  # Run created parser on inputs

  ## the rest of the function can access inputs by using p.Results.
  ## for example, get the tolerance input with p.Results.tolerance
endfunction</pre> <pre class="example" data-language="matlab">check ("mech");           # valid, use defaults for other arguments
check ();                 # error, one argument is mandatory
check (1);                # error, since ! ischar
check ("mech", "~/dev");  # valid, use defaults for other arguments

check ("mech", "~/dev", [0 1 0 0], "type", "linear");  # valid

## following is also valid.  Note how the Switch argument type can
## be mixed into or before the Parameter argument type (but it
## must still appear after any Optional argument).
check ("mech", "~/dev", [0 1 0 0], "verbose", "tolerance", "high");

## following returns an error since not all optional arguments,
## 'path' and 'mat', were given before the named argument 'type'.
check ("mech", "~/dev", "type", "linear");</pre> <p><em>Note 1</em>: A function can have any mixture of the four API types but they must appear in a specific order. <code>Required</code> arguments must be first and can be followed by any <code>Optional</code> arguments. Only the <code>Parameter</code> and <code>Switch</code> arguments may be mixed together and they must appear at the end. </p> <p><em>Note 2</em>: If both <code>Optional</code> and <code>Parameter</code> arguments are mixed in a function API then once a string Optional argument fails to validate it will be considered the end of the <code>Optional</code> arguments. The remaining arguments will be compared against any <code>Parameter</code> or <code>Switch</code> arguments. </p> <p><strong>See also:</strong> <a href="defining-functions.html#XREFnargin">nargin</a>, <a href="validating-the-type-of-arguments.html#XREFvalidateattributes">validateattributes</a>, <a href="validating-the-type-of-arguments.html#XREFvalidatestring">validatestring</a>, <a href="variable_002dlength-argument-lists.html#XREFvarargin">varargin</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Parsing-Arguments.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Parsing-Arguments.html</a>
  </p>
</div>
