<div class="section" id="Rearranging-Matrices">   <h1 class="section">16.2 Rearranging Matrices</h1> <dl class="def"> <dt id="index-fliplr">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>fliplr</strong> <em>(<var>A</var>)</em><a href="#index-fliplr" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Flip array left to right. </p> <p>Return a copy of <var>A</var> with the order of the columns reversed. In other words, <var>A</var> is flipped left-to-right about a vertical axis. For example: </p> <pre class="example" data-language="matlab">fliplr ([1, 2; 3, 4])
     ⇒  2  1
         4  3</pre> <p><strong>See also:</strong> <a href="#XREFflipud">flipud</a>, <a href="#XREFflip">flip</a>, <a href="#XREFrot90">rot90</a>, <a href="#XREFrotdim">rotdim</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-flipud">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>flipud</strong> <em>(<var>A</var>)</em><a href="#index-flipud" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Flip array upside down. </p> <p>Return a copy of <var>A</var> with the order of the rows reversed. In other words, <var>A</var> is flipped upside-down about a horizontal axis. For example: </p> <pre class="example" data-language="matlab">flipud ([1, 2; 3, 4])
     ⇒  3  4
         1  2</pre> <p><strong>See also:</strong> <a href="#XREFfliplr">fliplr</a>, <a href="#XREFflip">flip</a>, <a href="#XREFrot90">rot90</a>, <a href="#XREFrotdim">rotdim</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-flip">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>flip</strong> <em>(<var>A</var>)</em><a href="#index-flip" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-flip-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>flip</strong> <em>(<var>A</var>, <var>dim</var>)</em><a href="#index-flip-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a copy of array <var>A</var> flipped across dimension <var>dim</var>. </p> <p>If <var>dim</var> is unspecified it defaults to the first non-singleton dimension. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## row vector
flip ([1  2  3  4])
      ⇒  4  3  2  1

## column vector
flip ([1; 2; 3; 4])
      ⇒  4
          3
          2
          1

## 2-D matrix along dimension 1
flip ([1 2; 3 4])
      ⇒  3  4
          1  2

## 2-D matrix along dimension 2
flip ([1 2; 3 4], 2)
      ⇒  2  1
          4  3</pre> <p><strong>See also:</strong> <a href="#XREFfliplr">fliplr</a>, <a href="#XREFflipud">flipud</a>, <a href="#XREFrot90">rot90</a>, <a href="#XREFrotdim">rotdim</a>, <a href="#XREFpermute">permute</a>, <a href="arithmetic-ops.html#XREFtranspose">transpose</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rot90">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rot90</strong> <em>(<var>A</var>)</em><a href="#index-rot90" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rot90-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rot90</strong> <em>(<var>A</var>, <var>k</var>)</em><a href="#index-rot90-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Rotate array by 90 degree increments. </p> <p>Return a copy of <var>A</var> with the elements rotated counterclockwise in 90-degree increments. </p> <p>The second argument is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1). Negative values of <var>k</var> rotate the matrix in a clockwise direction. For example, </p> <pre class="example" data-language="matlab">rot90 ([1, 2; 3, 4], -1)
    ⇒  3  1
        4  2</pre> <p>rotates the given matrix clockwise by 90 degrees. The following are all equivalent statements: </p> <pre class="example" data-language="matlab">rot90 ([1, 2; 3, 4], -1)
rot90 ([1, 2; 3, 4], 3)
rot90 ([1, 2; 3, 4], 7)</pre> <p>The rotation is always performed on the plane of the first two dimensions, i.e., rows and columns. To perform a rotation on any other plane, use <code>rotdim</code>. </p> <p><strong>See also:</strong> <a href="#XREFrotdim">rotdim</a>, <a href="#XREFfliplr">fliplr</a>, <a href="#XREFflipud">flipud</a>, <a href="#XREFflip">flip</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rotdim">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rotdim</strong> <em>(<var>A</var>)</em><a href="#index-rotdim" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rotdim-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rotdim</strong> <em>(<var>A</var>, <var>n</var>)</em><a href="#index-rotdim-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rotdim-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>rotdim</strong> <em>(<var>A</var>, <var>n</var>, <var>plane</var>)</em><a href="#index-rotdim-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a copy of <var>A</var> with the elements rotated counterclockwise in 90-degree increments. </p> <p>The second argument <var>n</var> is optional, and specifies how many 90-degree rotations are to be applied (the default value is 1). Negative values of <var>n</var> rotate the matrix in a clockwise direction. </p> <p>The third argument is also optional and defines the plane of the rotation. If present, <var>plane</var> is a two element vector containing two different valid dimensions of the matrix. When <var>plane</var> is not given the first two non-singleton dimensions are used. </p> <p>For example, </p> <pre class="example" data-language="matlab">rotdim ([1, 2; 3, 4], -1, [1, 2])
     ⇒  3  1
         4  2</pre> <p>rotates the given matrix clockwise by 90 degrees. The following are all equivalent statements: </p> <pre class="example" data-language="matlab">rotdim ([1, 2; 3, 4], -1, [1, 2])
rotdim ([1, 2; 3, 4], 3, [1, 2])
rotdim ([1, 2; 3, 4], 7, [1, 2])</pre> <p><strong>See also:</strong> <a href="#XREFrot90">rot90</a>, <a href="#XREFfliplr">fliplr</a>, <a href="#XREFflipud">flipud</a>, <a href="#XREFflip">flip</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cat">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>cat</strong> <em>(<var>dim</var>, <var>array1</var>, <var>array2</var>, …, <var>arrayN</var>)</em><a href="#index-cat" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the concatenation of N-D array objects, <var>array1</var>, <var>array2</var>, …, <var>arrayN</var> along dimension <var>dim</var>. </p> <pre class="example" data-language="matlab">A = ones (2, 2);
B = zeros (2, 2);
cat (2, A, B)
  ⇒ 1 1 0 0
     1 1 0 0</pre> <p>Alternatively, we can concatenate <var>A</var> and <var>B</var> along the second dimension in the following way: </p> <pre class="example" data-language="matlab">[A, B]</pre> <p><var>dim</var> can be larger than the dimensions of the N-D array objects and the result will thus have <var>dim</var> dimensions as the following example shows: </p> <pre class="example" data-language="matlab">cat (4, ones (2, 2), zeros (2, 2))
  ⇒ ans(:,:,1,1) =

       1 1
       1 1

     ans(:,:,1,2) =

       0 0
       0 0</pre> <p><strong>See also:</strong> <a href="#XREFhorzcat">horzcat</a>, <a href="#XREFvertcat">vertcat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-horzcat">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>horzcat</strong> <em>(<var>array1</var>, <var>array2</var>, …, <var>arrayN</var>)</em><a href="#index-horzcat" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the horizontal concatenation of N-D array objects, <var>array1</var>, <var>array2</var>, …, <var>arrayN</var> along dimension 2. </p> <p>Arrays may also be concatenated horizontally using the syntax for creating new matrices. For example: </p> <pre class="example" data-language="matlab">A = [ array1, array2, … ]</pre> <p>This syntax is slightly more efficient because the Octave parser can concatenate the arrays without the overhead of a function call. </p> <p><strong>See also:</strong> <a href="#XREFcat">cat</a>, <a href="#XREFvertcat">vertcat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-vertcat">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>vertcat</strong> <em>(<var>array1</var>, <var>array2</var>, …, <var>arrayN</var>)</em><a href="#index-vertcat" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the vertical concatenation of N-D array objects, <var>array1</var>, <var>array2</var>, …, <var>arrayN</var> along dimension 1. </p> <p>Arrays may also be concatenated vertically using the syntax for creating new matrices. For example: </p> <pre class="example" data-language="matlab">A = [ array1; array2; … ]</pre> <p>This syntax is slightly more efficient because the Octave parser can concatenate the arrays without the overhead of a function call. </p> <p><strong>See also:</strong> <a href="#XREFcat">cat</a>, <a href="#XREFhorzcat">horzcat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-permute">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>permute</strong> <em>(<var>A</var>, <var>perm</var>)</em><a href="#index-permute" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the generalized transpose for an N-D array object <var>A</var>. </p> <p>The permutation vector <var>perm</var> must contain the elements <code>1:ndims (A)</code> (in any order, but each element must appear only once). The <var>N</var>th dimension of <var>A</var> gets remapped to dimension <code><var>PERM</var>(<var>N</var>)</code>. For example: </p> <pre class="example" data-language="matlab">x = zeros ([2, 3, 5, 7]);
size (x)
   ⇒  2   3   5   7

size (permute (x, [2, 1, 3, 4]))
   ⇒  3   2   5   7

size (permute (x, [1, 3, 4, 2]))
   ⇒  2   5   7   3

## The identity permutation
size (permute (x, [1, 2, 3, 4]))
   ⇒  2   3   5   7</pre> <p><strong>See also:</strong> <a href="#XREFipermute">ipermute</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ipermute">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>ipermute</strong> <em>(<var>B</var>, <var>iperm</var>)</em><a href="#index-ipermute" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>The inverse of the <code>permute</code> function. </p> <p>The expression </p> <pre class="example" data-language="matlab">ipermute (permute (A, perm), perm)</pre> <p>returns the original array <var>A</var>. </p> <p><strong>See also:</strong> <a href="#XREFpermute">permute</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-reshape">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>reshape</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>, …)</em><a href="#index-reshape" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-reshape-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>reshape</strong> <em>(<var>A</var>, [<var>m</var> <var>n</var> …])</em><a href="#index-reshape-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-reshape-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>reshape</strong> <em>(<var>A</var>, …, [], …)</em><a href="#index-reshape-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-reshape-3">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>reshape</strong> <em>(<var>A</var>, <var>size</var>)</em><a href="#index-reshape-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a matrix with the specified dimensions (<var>m</var>, <var>n</var>, …) whose elements are taken from the matrix <var>A</var>. </p> <p>The elements of the matrix are accessed in column-major order (like Fortran arrays are stored). </p> <p>The following code demonstrates reshaping a 1x4 row vector into a 2x2 square matrix. </p> <pre class="example" data-language="matlab">reshape ([1, 2, 3, 4], 2, 2)
      ⇒  1  3
          2  4</pre> <p>Note that the total number of elements in the original matrix (<code>prod (size (<var>A</var>))</code>) must match the total number of elements in the new matrix (<code>prod ([<var>m</var> <var>n</var> …])</code>). </p> <p>A single dimension of the return matrix may be left unspecified and Octave will determine its size automatically. An empty matrix ([]) is used to flag the unspecified dimension. </p> <p><strong>See also:</strong> <a href="#XREFresize">resize</a>, <a href="#XREFvec">vec</a>, <a href="#XREFpostpad">postpad</a>, <a href="#XREFcat">cat</a>, <a href="object-sizes.html#XREFsqueeze">squeeze</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-resize">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>resize</strong> <em>(<var>A</var>, <var>m</var>)</em><a href="#index-resize" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-resize-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>resize</strong> <em>(<var>A</var>, <var>m</var>, <var>n</var>, …)</em><a href="#index-resize-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-resize-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>resize</strong> <em>(<var>A</var>, [<var>m</var> <var>n</var> …])</em><a href="#index-resize-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Resize <var>A</var> cutting off elements as necessary. </p> <p>In the result, element with certain indices is equal to the corresponding element of <var>A</var> if the indices are within the bounds of <var>A</var>; otherwise, the element is set to zero. </p> <p>In other words, the statement </p> <pre class="example" data-language="matlab">B = resize (A, dv)</pre> <p>is equivalent to the following code: </p> <pre class="example" data-language="matlab">B = zeros (dv, class (A));
sz = min (dv, size (A));
for i = 1:length (sz)
  idx{i} = 1:sz(i);
endfor
B(idx{:}) = A(idx{:});</pre> <p>but is performed more efficiently. </p> <p>If only <var>m</var> is supplied, and it is a scalar, the dimension of the result is <var>m</var>-by-<var>m</var>. If <var>m</var>, <var>n</var>, … are all scalars, then the dimensions of the result are <var>m</var>-by-<var>n</var>-by-…. If given a vector as input, then the dimensions of the result are given by the elements of that vector. </p> <p>An object can be resized to more dimensions than it has; in such case the missing dimensions are assumed to be 1. Resizing an object to fewer dimensions is not possible. </p> <p><strong>See also:</strong> <a href="#XREFreshape">reshape</a>, <a href="#XREFpostpad">postpad</a>, <a href="#XREFprepad">prepad</a>, <a href="#XREFcat">cat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-circshift">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>circshift</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-circshift" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-circshift-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>circshift</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href="#index-circshift-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Circularly shift the values of the array <var>x</var>. </p> <p><var>n</var> must be a vector of integers no longer than the number of dimensions in <var>x</var>. The values of <var>n</var> can be either positive or negative, which determines the direction in which the values of <var>x</var> are shifted. If an element of <var>n</var> is zero, then the corresponding dimension of <var>x</var> will not be shifted. If <var>n</var> is a scalar and no <var>dim</var> is specified then the shift is applied to the first non-singular dimension. </p> <p>If a scalar <var>dim</var> is given then operate along the specified dimension. In this case <var>n</var> must be a scalar as well. </p> <p>Examples: </p> <pre class="example" data-language="matlab">x = [1, 2, 3;
     4, 5, 6;
     7, 8, 9];
## positive shift on rows (1st non-singular dim)
circshift (x, 1)
  ⇒
       7   8   9
       1   2   3
       4   5   6
## negative shift on rows (1st non-singular dim)
circshift (x, -2)
  ⇒
       7   8   9
       1   2   3
       4   5   6
## no shift of rows, shift columns by 1 (2nd dimension)
circshift (x, [0,1])
  ⇒
       3   1   2
       6   4   5
       9   7   8
## shift columns (2nd dimension)
circshift (x, 1, 2)
  ⇒
       3   1   2
       6   4   5
       9   7   8</pre> <p><strong>See also:</strong> <a href="#XREFpermute">permute</a>, <a href="#XREFipermute">ipermute</a>, <a href="#XREFshiftdim">shiftdim</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-shiftdim">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>shiftdim</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-shiftdim" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-shiftdim-1">
<span class="category">: </span><span><em>[<var>y</var>, <var>ns</var>] =</em> <strong>shiftdim</strong> <em>(<var>x</var>)</em><a href="#index-shiftdim-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Shift the dimensions of <var>x</var> by <var>n</var>, where <var>n</var> must be an integer scalar. </p> <p>When <var>n</var> is positive, the dimensions of <var>x</var> are shifted to the left, with the leading dimensions circulated to the end. If <var>n</var> is negative, then the dimensions of <var>x</var> are shifted to the right, with <var>n</var> leading singleton dimensions added. </p> <p>Called with a single argument, <code>shiftdim</code>, removes the leading singleton dimensions, returning the number of dimensions removed in the second output argument <var>ns</var>. </p> <p>For example: </p> <pre class="example" data-language="matlab">x = ones (1, 2, 3);
size (shiftdim (x, -1))
  ⇒   1   1   2   3
size (shiftdim (x, 1))
  ⇒   2   3
[b, ns] = shiftdim (x)
  ⇒ b =
        1   1   1
        1   1   1
  ⇒ ns = 1</pre> <p><strong>See also:</strong> <a href="#XREFreshape">reshape</a>, <a href="#XREFpermute">permute</a>, <a href="#XREFipermute">ipermute</a>, <a href="#XREFcircshift">circshift</a>, <a href="object-sizes.html#XREFsqueeze">squeeze</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sort">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sort</strong> <em>(<var>x</var>)</em><a href="#index-sort" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sort-1">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sort</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-sort-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sort-2">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sort</strong> <em>(<var>x</var>, <var>mode</var>)</em><a href="#index-sort-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sort-3">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sort</strong> <em>(<var>x</var>, <var>dim</var>, <var>mode</var>)</em><a href="#index-sort-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a copy of <var>x</var> with the elements arranged in increasing order. </p> <p>For matrices, <code>sort</code> orders the elements within columns </p> <p>For example: </p> <pre class="example" data-language="matlab">sort ([1, 2; 2, 3; 3, 1])
   ⇒  1  1
       2  2
       3  3</pre> <p>If the optional argument <var>dim</var> is given, then the matrix is sorted along the dimension defined by <var>dim</var>. The optional argument <var>mode</var> defines the order in which the values will be sorted. Valid values of <var>mode</var> are <code>"ascend"</code> or <code>"descend"</code>. </p> <p>The <code>sort</code> function may also be used to produce a matrix containing the original row indices of the elements in the sorted matrix. For example: </p> <pre class="example" data-language="matlab">[s, i] = sort ([1, 2; 2, 3; 3, 1])
  ⇒ s = 1  1
         2  2
         3  3
  ⇒ i = 1  3
         2  1
         3  2</pre> <p>For equal elements, the indices are such that equal elements are listed in the order in which they appeared in the original list. </p> <p>Sorting of complex entries is done first by magnitude (<code>abs (<var>z</var>)</code>) and for any ties by phase angle (<code>angle (z)</code>). For example: </p> <pre class="example" data-language="matlab">sort ([1+i; 1; 1-i])
    ⇒ 1 + 0i
       1 - 1i
       1 + 1i</pre> <p>NaN values are treated as being greater than any other value and are sorted to the end of the list. </p> <p>The <code>sort</code> function may also be used to sort strings and cell arrays of strings, in which case ASCII dictionary order (uppercase ’A’ precedes lowercase ’a’) of the strings is used. </p> <p>The algorithm used in <code>sort</code> is optimized for the sorting of partially ordered lists. </p> <p><strong>See also:</strong> <a href="#XREFsortrows">sortrows</a>, <a href="#XREFissorted">issorted</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sortrows">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sortrows</strong> <em>(<var>A</var>)</em><a href="#index-sortrows" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-sortrows-1">
<span class="category">: </span><span><em>[<var>s</var>, <var>i</var>] =</em> <strong>sortrows</strong> <em>(<var>A</var>, <var>c</var>)</em><a href="#index-sortrows-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Sort the rows of the matrix <var>A</var> according to the order of the columns specified in <var>c</var>. </p> <p>By default (<var>c</var> omitted, or a particular column unspecified in <var>c</var>) an ascending sort order is used. However, if elements of <var>c</var> are negative then the corresponding column is sorted in descending order. If the elements of <var>A</var> are strings then a lexicographical sort is used. </p> <p>Example: sort by column 2 in descending order, then 3 in ascending order </p> <pre class="example" data-language="matlab">x = [ 7, 1, 4;
      8, 3, 5;
      9, 3, 6 ];
sortrows (x, [-2, 3])
   ⇒ 8  3  5
      9  3  6
      7  1  4</pre> <p><strong>See also:</strong> <a href="#XREFsort">sort</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-issorted">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issorted</strong> <em>(<var>A</var>)</em><a href="#index-issorted" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-issorted-1">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issorted</strong> <em>(<var>A</var>, <var>mode</var>)</em><a href="#index-issorted-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-issorted-2">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>issorted</strong> <em>(<var>A</var>, "rows", <var>mode</var>)</em><a href="#index-issorted-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return true if the vector <var>A</var> is sorted according to <var>mode</var>, which may be either <code>"ascend"</code>, <code>"descend"</code>, or <code>"either"</code>. </p> <p>By default, <var>mode</var> is <code>"ascend"</code>. NaNs are treated in the same manner as <code>sort</code>. </p> <p>If the optional argument <code>"rows"</code> is supplied, check whether the matrix is sorted by rows as output by the function <code>sortrows</code> (with no options). </p> <p>This function does not support sparse matrices. </p> <p><strong>See also:</strong> <a href="#XREFsort">sort</a>, <a href="#XREFsortrows">sortrows</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-nth_005felement">
<span class="category">: </span><span><em><var>nel</var> =</em> <strong>nth_element</strong> <em>(<var>x</var>, <var>n</var>)</em><a href="#index-nth_005felement" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-nth_005felement-1">
<span class="category">: </span><span><em><var>nel</var> =</em> <strong>nth_element</strong> <em>(<var>x</var>, <var>n</var>, <var>dim</var>)</em><a href="#index-nth_005felement-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Select the n-th smallest element of a vector, using the ordering defined by <code>sort</code>. </p> <p>The result is equivalent to <code>sort(<var>x</var>)(<var>n</var>)</code>. </p> <p><var>n</var> can also be a contiguous range, either ascending <code>l:u</code> or descending <code>u:-1:l</code>, in which case a range of elements is returned. </p> <p>If <var>x</var> is an array, <code>nth_element</code> operates along the dimension defined by <var>dim</var>, or the first non-singleton dimension if <var>dim</var> is not given. </p> <p>Programming Note: nth_element encapsulates the C++ standard library algorithms nth_element and partial_sort. On average, the complexity of the operation is O(M*log(K)), where <code>M = size (<var>x</var>, <var>dim</var>)</code> and <code>K = length (<var>n</var>)</code>. This function is intended for cases where the ratio K/M is small; otherwise, it may be better to use <code>sort</code>. </p> <p><strong>See also:</strong> <a href="#XREFsort">sort</a>, <a href="utility-functions.html#XREFmin">min</a>, <a href="utility-functions.html#XREFmax">max</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-tril">
<span class="category">: </span><span><em><var>A_LO</var> =</em> <strong>tril</strong> <em>(<var>A</var>)</em><a href="#index-tril" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-tril-1">
<span class="category">: </span><span><em><var>A_LO</var> =</em> <strong>tril</strong> <em>(<var>A</var>, <var>k</var>)</em><a href="#index-tril-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-tril-2">
<span class="category">: </span><span><em><var>A_LO</var> =</em> <strong>tril</strong> <em>(<var>A</var>, <var>k</var>, <var>pack</var>)</em><a href="#index-tril-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a new matrix formed by extracting the lower triangular part of the matrix <var>A</var>, and setting all other elements to zero. </p> <p>The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero. The default value of <var>k</var> is zero which includes the main diagonal as part of the result. If the value of <var>k</var> is a nonzero integer then the selection of elements starts at an offset of <var>k</var> diagonals above the main diagonal for positive <var>k</var> or below the main diagonal for negative <var>k</var>. The absolute value of <var>k</var> may not be greater than the number of subdiagonals or superdiagonals. </p> <p>Example 1 : exclude main diagonal </p> <pre class="example" data-language="matlab">tril (ones (3), -1)
     ⇒  0  0  0
         1  0  0
         1  1  0</pre> <p>Example 2 : include first superdiagonal </p> <pre class="example" data-language="matlab">tril (ones (3), 1)
     ⇒  1  1  0
         1  1  1
         1  1  1</pre> <p>If the optional third argument <code>"pack"</code> is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector. </p> <p><strong>See also:</strong> <a href="#XREFtriu">triu</a>, <a href="predicates-for-numeric-objects.html#XREFistril">istril</a>, <a href="#XREFdiag">diag</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-triu">
<span class="category">: </span><span><em><var>A_UP</var> =</em> <strong>triu</strong> <em>(<var>A</var>)</em><a href="#index-triu" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-triu-1">
<span class="category">: </span><span><em><var>A_UP</var> =</em> <strong>triu</strong> <em>(<var>A</var>, <var>k</var>)</em><a href="#index-triu-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-triu-2">
<span class="category">: </span><span><em><var>A_UP</var> =</em> <strong>triu</strong> <em>(<var>A</var>, <var>k</var>, <var>pack</var>)</em><a href="#index-triu-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a new matrix formed by extracting the upper triangular part of the matrix <var>A</var>, and setting all other elements to zero. </p> <p>The optional second argument specifies how many diagonals above or below the main diagonal should also be set to zero. The default value of <var>k</var> is zero which includes the main diagonal as part of the result. If the value of <var>k</var> is a nonzero integer then the selection of elements starts at an offset of <var>k</var> diagonals above the main diagonal for positive <var>k</var> or below the main diagonal for negative <var>k</var>. The absolute value of <var>k</var> may not be greater than the number of subdiagonals or superdiagonals. </p> <p>Example 1 : exclude main diagonal </p> <pre class="example" data-language="matlab">triu (ones (3), 1)
     ⇒  0  1  1
         0  0  1
         0  0  0</pre> <p>Example 2 : include first subdiagonal </p> <pre class="example" data-language="matlab">triu (ones (3), -1)
     ⇒  1  1  1
         1  1  1
         0  1  1</pre> <p>If the optional third argument <code>"pack"</code> is given then the extracted elements are not inserted into a matrix, but instead stacked column-wise one above another, and returned as a column vector. </p> <p><strong>See also:</strong> <a href="#XREFtril">tril</a>, <a href="predicates-for-numeric-objects.html#XREFistriu">istriu</a>, <a href="#XREFdiag">diag</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-vec">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>vec</strong> <em>(<var>x</var>)</em><a href="#index-vec" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-vec-1">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>vec</strong> <em>(<var>x</var>, <var>dim</var>)</em><a href="#index-vec-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the vector obtained by stacking the columns of the matrix <var>x</var> one above the other. </p> <p>Without <var>dim</var> this is equivalent to <code><var>x</var>(:)</code>. </p> <p>If <var>dim</var> is supplied, the dimensions of <var>v</var> are set to <var>dim</var> with all elements along the last dimension. This is equivalent to <code>shiftdim (<var>x</var>(:), 1-<var>dim</var>)</code>. </p> <p><strong>See also:</strong> <a href="#XREFvech">vech</a>, <a href="#XREFresize">resize</a>, <a href="#XREFcat">cat</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-vech">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>vech</strong> <em>(<var>x</var>)</em><a href="#index-vech" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the vector obtained by eliminating all superdiagonal elements of the square matrix <var>x</var> and stacking the result one column above the other. </p> <p>This has uses in matrix calculus where the underlying matrix is symmetric and it would be pointless to keep values above the main diagonal. </p> <p><strong>See also:</strong> <a href="#XREFvec">vec</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-prepad">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>prepad</strong> <em>(<var>A</var>, <var>l</var>)</em><a href="#index-prepad" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-prepad-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>prepad</strong> <em>(<var>A</var>, <var>l</var>, <var>c</var>)</em><a href="#index-prepad-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-prepad-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>prepad</strong> <em>(<var>A</var>, <var>l</var>, <var>c</var>, <var>dim</var>)</em><a href="#index-prepad-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Prepend the scalar value <var>c</var> to the vector <var>A</var> until it is of length <var>l</var>. If <var>c</var> is not given, a value of 0 is used. </p> <p>If <code>length (<var>A</var>) &gt; <var>l</var></code>, elements from the beginning of <var>A</var> are removed until a vector of length <var>l</var> is obtained. </p> <p>If <var>A</var> is a matrix, elements are prepended or removed from each row. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>If <var>dim</var> is larger than the dimensions of <var>A</var>, the result will have <var>dim</var> dimensions. </p> <p><strong>See also:</strong> <a href="#XREFpostpad">postpad</a>, <a href="#XREFcat">cat</a>, <a href="#XREFresize">resize</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-postpad">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>postpad</strong> <em>(<var>A</var>, <var>l</var>)</em><a href="#index-postpad" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-postpad-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>postpad</strong> <em>(<var>A</var>, <var>l</var>, <var>c</var>)</em><a href="#index-postpad-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-postpad-2">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>postpad</strong> <em>(<var>A</var>, <var>l</var>, <var>c</var>, <var>dim</var>)</em><a href="#index-postpad-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Append the scalar value <var>c</var> to the vector <var>A</var> until it is of length <var>l</var>. If <var>c</var> is not given, a value of 0 is used. </p> <p>If <code>length (<var>A</var>) &gt; <var>l</var></code>, elements from the end of <var>A</var> are removed until a vector of length <var>l</var> is obtained. </p> <p>If <var>A</var> is a matrix, elements are appended or removed from each row. </p> <p>If the optional argument <var>dim</var> is given, operate along this dimension. </p> <p>If <var>dim</var> is larger than the dimensions of <var>A</var>, the result will have <var>dim</var> dimensions. </p> <p><strong>See also:</strong> <a href="#XREFprepad">prepad</a>, <a href="#XREFcat">cat</a>, <a href="#XREFresize">resize</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-diag">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>diag</strong> <em>(<var>v</var>)</em><a href="#index-diag" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diag-1">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>diag</strong> <em>(<var>v</var>, <var>k</var>)</em><a href="#index-diag-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diag-2">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>diag</strong> <em>(<var>v</var>, <var>m</var>, <var>n</var>)</em><a href="#index-diag-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diag-3">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>diag</strong> <em>(<var>M</var>)</em><a href="#index-diag-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-diag-4">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>diag</strong> <em>(<var>M</var>, <var>k</var>)</em><a href="#index-diag-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return a diagonal matrix with vector <var>v</var> on diagonal <var>k</var>. </p> <p>The second argument is optional. If it is positive, the vector is placed on the <var>k</var>-th superdiagonal. If it is negative, it is placed on the <var>-k</var>-th subdiagonal. The default value of <var>k</var> is 0, and the vector is placed on the main diagonal. For example: </p> <pre class="example" data-language="matlab">diag ([1, 2, 3], 1)
   ⇒  0  1  0  0
       0  0  2  0
       0  0  0  3
       0  0  0  0</pre> <p>The 3-input form returns a diagonal matrix with vector <var>v</var> on the main diagonal and the resulting matrix being of size <var>m</var> rows x <var>n</var> columns. </p> <p>Given a matrix argument, instead of a vector, <code>diag</code> extracts the <var>k</var>-th diagonal of the matrix. </p>
</dd>
</dl> <dl class="def"> <dt id="index-blkdiag">
<span class="category">: </span><span><em><var>M</var> =</em> <strong>blkdiag</strong> <em>(<var>A</var>, <var>B</var>, <var>C</var>, …)</em><a href="#index-blkdiag" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Build a block diagonal matrix from <var>A</var>, <var>B</var>, <var>C</var>, … </p> <p>All arguments must be numeric and either two-dimensional matrices or scalars. If any argument is of type sparse, the output will also be sparse. </p> <p><strong>See also:</strong> <a href="#XREFdiag">diag</a>, <a href="#XREFhorzcat">horzcat</a>, <a href="#XREFvertcat">vertcat</a>, <a href="creating-sparse-matrices.html#XREFsparse">sparse</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Rearranging-Matrices.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Rearranging-Matrices.html</a>
  </p>
</div>
