<div class="section" id="Special-Functions">   <h1 class="section">17.6 Special Functions</h1> <dl class="def"> <dt id="index-airy">
<span class="category">: </span><span><em><var>a</var> =</em> <strong>airy</strong> <em>(<var>z</var>)</em><a href="#index-airy" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-airy-1">
<span class="category">: </span><span><em><var>a</var> =</em> <strong>airy</strong> <em>(<var>k</var>, <var>z</var>)</em><a href="#index-airy-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-airy-2">
<span class="category">: </span><span><em><var>a</var> =</em> <strong>airy</strong> <em>(<var>k</var>, <var>z</var>, <var>scale</var>)</em><a href="#index-airy-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-airy-3">
<span class="category">: </span><span><em>[<var>a</var>, <var>ierr</var>] =</em> <strong>airy</strong> <em>(…)</em><a href="#index-airy-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Compute Airy functions of the first and second kind, and their derivatives. </p> <pre class="example" data-language="matlab">K   Function   Scale factor (if scale is true)
---  --------   ---------------------------------------
 0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))
 1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))
 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))
 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))</pre> <p>The function call <code>airy (<var>z</var>)</code> is equivalent to <code>airy (0, <var>z</var>)</code>. </p> <p>The optional third input <var>scale</var> determines whether to apply scaling as described above. It is false by default. </p> <p>The result <var>a</var> is the same size as <var>z</var>. </p> <p>The optional output <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Loss of significance by argument reduction, output may be inaccurate. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> </dd>
</dl> <dl class="def"> <dt id="index-besselj">
<span class="category">: </span><span><em><var>J</var> =</em> <strong>besselj</strong> <em>(<var>alpha</var>, <var>x</var>)</em><a href="#index-besselj" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselj-1">
<span class="category">: </span><span><em><var>J</var> =</em> <strong>besselj</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em><a href="#index-besselj-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselj-2">
<span class="category">: </span><span><em>[<var>J</var>, <var>ierr</var>] =</em> <strong>besselj</strong> <em>(…)</em><a href="#index-besselj-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the first kind. </p> <p>The order of the Bessel function <var>alpha</var> must be real. The points for evaluation <var>x</var> may be complex. </p> <p>If the optional argument <var>opt</var> is 1 or true, the result <var>J</var> is multiplied by <code>exp <span class="nolinebreak">(-abs</span> (imag (<var>x</var>)))</code>. </p> <p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>. If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>. If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the result is a matrix with <code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns. Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same size. </p> <p>If requested, <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Loss of significance by argument reduction, output may be inaccurate. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbessely">bessely</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bessely">
<span class="category">: </span><span><em><var>Y</var> =</em> <strong>bessely</strong> <em>(<var>alpha</var>, <var>x</var>)</em><a href="#index-bessely" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bessely-1">
<span class="category">: </span><span><em><var>Y</var> =</em> <strong>bessely</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em><a href="#index-bessely-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bessely-2">
<span class="category">: </span><span><em>[<var>Y</var>, <var>ierr</var>] =</em> <strong>bessely</strong> <em>(…)</em><a href="#index-bessely-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the second kind. </p> <p>The order of the Bessel function <var>alpha</var> must be real. The points for evaluation <var>x</var> may be complex. </p> <p>If the optional argument <var>opt</var> is 1 or true, the result <var>Y</var> is multiplied by <code>exp <span class="nolinebreak">(-abs</span> (imag (<var>x</var>)))</code>. </p> <p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>. If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>. If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the result is a matrix with <code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns. Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same size. </p> <p>If requested, <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code>NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbesselj">besselj</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-besseli">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>besseli</strong> <em>(<var>alpha</var>, <var>x</var>)</em><a href="#index-besseli" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besseli-1">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>besseli</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em><a href="#index-besseli-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besseli-2">
<span class="category">: </span><span><em>[<var>I</var>, <var>ierr</var>] =</em> <strong>besseli</strong> <em>(…)</em><a href="#index-besseli-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute modified Bessel functions of the first kind. </p> <p>The order of the Bessel function <var>alpha</var> must be real. The points for evaluation <var>x</var> may be complex. </p> <p>If the optional argument <var>opt</var> is 1 or true, the result <var>I</var> is multiplied by <code>exp <span class="nolinebreak">(-abs</span> (real (<var>x</var>)))</code>. </p> <p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>. If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>. If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the result is a matrix with <code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns. Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same size. </p> <p>If requested, <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code>NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbesselk">besselk</a>, <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-besselk">
<span class="category">: </span><span><em><var>K</var> =</em> <strong>besselk</strong> <em>(<var>alpha</var>, <var>x</var>)</em><a href="#index-besselk" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselk-1">
<span class="category">: </span><span><em><var>K</var> =</em> <strong>besselk</strong> <em>(<var>alpha</var>, <var>x</var>, <var>opt</var>)</em><a href="#index-besselk-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselk-2">
<span class="category">: </span><span><em>[<var>K</var>, <var>ierr</var>] =</em> <strong>besselk</strong> <em>(…)</em><a href="#index-besselk-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Compute modified Bessel functions of the second kind. </p> <p>The order of the Bessel function <var>alpha</var> must be real. The points for evaluation <var>x</var> may be complex. </p> <p>If the optional argument <var>opt</var> is 1 or true, the result <var>K</var> is multiplied by <code>exp (<var>x</var>)</code>. </p> <p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>. If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>. If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the result is a matrix with <code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns. Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same size. </p> <p>If requested, <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code>NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesselh">besselh</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-besselh">
<span class="category">: </span><span><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>x</var>)</em><a href="#index-besselh" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselh-1">
<span class="category">: </span><span><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>k</var>, <var>x</var>)</em><a href="#index-besselh-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselh-2">
<span class="category">: </span><span><em><var>H</var> =</em> <strong>besselh</strong> <em>(<var>alpha</var>, <var>k</var>, <var>x</var>, <var>opt</var>)</em><a href="#index-besselh-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-besselh-3">
<span class="category">: </span><span><em>[<var>H</var>, <var>ierr</var>] =</em> <strong>besselh</strong> <em>(…)</em><a href="#index-besselh-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute Bessel functions of the third kind (Hankel functions). </p> <p>The order of the Bessel function <var>alpha</var> must be real. The kind of Hankel function is specified by <var>k</var> and may be either first (<var>k</var> = 1) or second (<var>k</var> = 2). The default is Hankel functions of the first kind. The points for evaluation <var>x</var> may be complex. </p> <p>If the optional argument <var>opt</var> is 1 or true, the result is multiplied by <code>exp (-I*<var>x</var>)</code> for <var>k</var> = 1 or <code>exp (I*<var>x</var>)</code> for <var>k</var> = 2. </p> <p>If <var>alpha</var> is a scalar, the result is the same size as <var>x</var>. If <var>x</var> is a scalar, the result is the same size as <var>alpha</var>. If <var>alpha</var> is a row vector and <var>x</var> is a column vector, the result is a matrix with <code>length (<var>x</var>)</code> rows and <code>length (<var>alpha</var>)</code> columns. Otherwise, <var>alpha</var> and <var>x</var> must conform and the result will be the same size. </p> <p>If requested, <var>ierr</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Input error, return <code>NaN</code>. </li>
<li> Overflow, return <code>Inf</code>. </li>
<li> Loss of significance by argument reduction results in less than half of machine accuracy. </li>
<li> Complete loss of significance by argument reduction, return <code>NaN</code>. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p><strong>See also:</strong> <a href="#XREFbesselj">besselj</a>, <a href="#XREFbessely">bessely</a>, <a href="#XREFbesseli">besseli</a>, <a href="#XREFbesselk">besselk</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-beta">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>beta</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-beta" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Beta function for real inputs <var>a</var> and <var>b</var>. </p> <p>The Beta function definition is </p> <pre class="example" data-language="matlab">beta (a, b) = gamma (a) * gamma (b) / gamma (a + b).</pre> <p>The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly. See <a href="#XREFbetaln"><code>betaln</code></a>, for computing the logarithm of the Beta function in an efficient manner. </p> <p><strong>See also:</strong> <a href="#XREFbetaln">betaln</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-betainc">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>betainc</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>)</em><a href="#index-betainc" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-betainc-1">
<span class="category">: </span><span><em><var>I</var> =</em> <strong>betainc</strong> <em>(<var>x</var>, <var>a</var>, <var>b</var>, <var>tail</var>)</em><a href="#index-betainc-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the incomplete beta function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0</pre> <p>with real <var>x</var> in the range [0,1]. The inputs <var>a</var> and <var>b</var> must be real and strictly positive (&gt; 0). If one of the inputs is not a scalar then the other inputs must be scalar or of compatible dimensions. </p> <p>By default, <var>tail</var> is <code>"lower"</code> and the incomplete beta function integrated from 0 to <var>x</var> is computed. If <var>tail</var> is <code>"upper"</code> then the complementary function integrated from <var>x</var> to 1 is calculated. The two choices are related by </p> <p>betainc (<var>x</var>, <var>a</var>, <var>b</var>, <code>"upper"</code>) = 1 - betainc (<var>x</var>, <var>a</var>, <var>b</var>, <code>"lower"</code>). </p> <p><code>betainc</code> uses a more sophisticated algorithm than subtraction to get numerically accurate results when the <code>"lower"</code> value is small. </p> <p>Reference: A. Cuyt, V. Brevik Petersen, B. Verdonk, H. Waadeland, W.B. Jones, <cite>Handbook of Continued Fractions for Special Functions</cite>, ch. 18. </p> <p><strong>See also:</strong> <a href="#XREFbeta">beta</a>, <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFbetaln">betaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-betaincinv">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>)</em><a href="#index-betaincinv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-betaincinv-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>, "lower")</em><a href="#index-betaincinv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-betaincinv-2">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>betaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>b</var>, "upper")</em><a href="#index-betaincinv-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the normalized incomplete beta function. </p> <p>The normalized incomplete beta function is defined as </p> <pre class="example" data-language="matlab">x
                         /
                 1       |
I_x (a, b) = ----------  | t^(a-1) (1-t)^(b-1) dt
             beta (a,b)  |
                         /
                        0</pre> <p>If two inputs are scalar, then <code>betaincinv (<var>y</var>, <var>a</var>, <var>b</var>)</code> is returned for each of the other inputs. </p> <p>If two or more inputs are not scalar, the sizes of them must agree, and <code>betaincinv</code> is applied element-by-element. </p> <p>The variable <var>y</var> must be in the interval [0,1], while <var>a</var> and <var>b</var> must be real and strictly positive. </p> <p>By default, <var>tail</var> is <code>"lower"</code> and the inverse of the incomplete beta function integrated from 0 to <var>x</var> is computed. If <var>tail</var> is <code>"upper"</code> then the complementary function integrated from <var>x</var> to 1 is inverted. </p> <p>The function is computed by standard Newton’s method, by solving </p> <pre class="example" data-language="matlab">y - betainc (x, a, b) = 0</pre> <p><strong>See also:</strong> <a href="#XREFbetainc">betainc</a>, <a href="#XREFbeta">beta</a>, <a href="#XREFbetaln">betaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-betaln">
<span class="category">: </span><span><em><var>lnb</var> =</em> <strong>betaln</strong> <em>(<var>a</var>, <var>b</var>)</em><a href="#index-betaln" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the natural logarithm of the Beta function for real inputs <var>a</var> and <var>b</var>. </p> <p><code>betaln</code> is defined as </p> <pre class="example" data-language="matlab">betaln (a, b) = log (beta (a, b))</pre> <p>and is calculated in a way to reduce the occurrence of underflow. </p> <p>The Beta function can grow quite large and it is often more useful to work with the logarithm of the output rather than the function directly. </p> <p><strong>See also:</strong> <a href="#XREFbeta">beta</a>, <a href="#XREFbetainc">betainc</a>, <a href="#XREFbetaincinv">betaincinv</a>, <a href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-bincoeff">
<span class="category">: </span><span><em><var>b</var> =</em> <strong>bincoeff</strong> <em>(<var>n</var>, <var>k</var>)</em><a href="#index-bincoeff" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the binomial coefficient of <var>n</var> and <var>k</var>. </p> <p>The binomial coefficient is defined as </p> <pre class="example" data-language="matlab">/   \
 | n |    n (n-1) (n-2) … (n-k+1)
 |   |  = -------------------------
 | k |               k!
 \   /</pre> <p>For example: </p> <pre class="example" data-language="matlab">bincoeff (5, 2)
   ⇒ 10</pre> <p>In most cases, the <code>nchoosek</code> function is faster for small scalar integer arguments. It also warns about loss of precision for big arguments. </p> <p><strong>See also:</strong> <a href="basic-statistical-functions.html#XREFnchoosek">nchoosek</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-commutation_005fmatrix">
<span class="category">: </span><span><em><var>k</var> =</em> <strong>commutation_matrix</strong> <em>(<var>m</var>, <var>n</var>)</em><a href="#index-commutation_005fmatrix" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the commutation matrix K(m,n) which is the unique <var>m</var>*<var>n</var> by <var>m</var>*<var>n</var> matrix such that <em class="math">K(m,n) * vec(A) = vec(A')</em> for all <em class="math">m</em> by <em class="math">n</em> matrices <em class="math">A</em>. </p> <p>If only one argument <var>m</var> is given, <em class="math">K(m,m)</em> is returned. </p> <p>See Magnus and Neudecker (1988), <cite>Matrix Differential Calculus with Applications in Statistics and Econometrics</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cosint">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>cosint</strong> <em>(<var>x</var>)</em><a href="#index-cosint" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the cosine integral function: </p> <pre class="example" data-language="matlab">+oo
           /
Ci (x) = - | (cos (t)) / t dt
           /
          x</pre> <p>An equivalent definition is </p> <pre class="example" data-language="matlab">x
                            /
                            |  cos (t) - 1
Ci (x) = gamma + log (x) +  | -------------  dt
                            |        t
                            /
                           0</pre> <p>Reference: </p> <p>M. Abramowitz and I.A. Stegun, <cite>Handbook of Mathematical Functions</cite>, 1964. </p> <p><strong>See also:</strong> <a href="#XREFsinint">sinint</a>, <a href="#XREFexpint">expint</a>, <a href="trigonometry.html#XREFcos">cos</a>. </p> </dd>
</dl> <dl class="def"> <dt id="index-duplication_005fmatrix">
<span class="category">: </span><span><em><var>d</var> =</em> <strong>duplication_matrix</strong> <em>(<var>n</var>)</em><a href="#index-duplication_005fmatrix" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the duplication matrix <em class="math">Dn</em> which is the unique <em class="math">N^2</em>-by-<em class="math">N*(N+1)/2</em> matrix such that <code>Dn * vech (A) = vec (A)</code> for all symmetric <em class="math">N</em>-by-<em class="math">N</em> matrices <em class="math">A</em>. </p> <p>See Magnus and Neudecker (1988), <cite>Matrix Differential Calculus with Applications in Statistics and Econometrics</cite>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-dawson">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>dawson</strong> <em>(<var>z</var>)</em><a href="#index-dawson" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Dawson (scaled imaginary error) function. </p> <p>The Dawson function is defined as </p> <pre class="example" data-language="matlab">(sqrt (pi) / 2) * exp (-z^2) * erfi (z)</pre> <p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ellipj">
<span class="category">: </span><span><em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>)</em><a href="#index-ellipj" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ellipj-1">
<span class="category">: </span><span><em>[<var>sn</var>, <var>cn</var>, <var>dn</var>, <var>err</var>] =</em> <strong>ellipj</strong> <em>(<var>u</var>, <var>m</var>, <var>tol</var>)</em><a href="#index-ellipj-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Jacobi elliptic functions <var>sn</var>, <var>cn</var>, and <var>dn</var> of complex argument <var>u</var> and real parameter <var>m</var>. </p> <p>If <var>m</var> is a scalar, the results are the same size as <var>u</var>. If <var>u</var> is a scalar, the results are the same size as <var>m</var>. If <var>u</var> is a column vector and <var>m</var> is a row vector, the results are matrices with <code>length (<var>u</var>)</code> rows and <code>length (<var>m</var>)</code> columns. Otherwise, <var>u</var> and <var>m</var> must conform in size and the results will be the same size as the inputs. </p> <p>The value of <var>u</var> may be complex. The value of <var>m</var> must be 0 ≤ <var>m</var> ≤ 1. </p> <p>The optional input <var>tol</var> is currently ignored (<small>MATLAB</small> uses this to allow faster, less accurate approximation). </p> <p>If requested, <var>err</var> contains the following status information and is the same size as the result. </p> <ol start="0"> <li> Normal return. </li>
<li> Error—no computation, algorithm termination condition not met, return <code>NaN</code>. </li>
</ol> <p>Reference: Milton Abramowitz and Irene A Stegun, <cite>Handbook of Mathematical Functions</cite>, Chapter 16 (Sections 16.4, 16.13, and 16.15), Dover, 1965. </p> <p><strong>See also:</strong> <a href="#XREFellipke">ellipke</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ellipke">
<span class="category">: </span><span><em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>)</em><a href="#index-ellipke" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ellipke-1">
<span class="category">: </span><span><em><var>k</var> =</em> <strong>ellipke</strong> <em>(<var>m</var>, <var>tol</var>)</em><a href="#index-ellipke-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ellipke-2">
<span class="category">: </span><span><em>[<var>k</var>, <var>e</var>] =</em> <strong>ellipke</strong> <em>(…)</em><a href="#index-ellipke-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute complete elliptic integrals of the first K(<var>m</var>) and second E(<var>m</var>) kind. </p> <p><var>m</var> must be a scalar or real array with -Inf ≤ <var>m</var> ≤ 1. </p> <p>The optional input <var>tol</var> controls the stopping tolerance of the algorithm and defaults to <code>eps (class (<var>m</var>))</code>. The tolerance can be increased to compute a faster, less accurate approximation. </p> <p>When called with one output only elliptic integrals of the first kind are returned. </p> <p>Mathematical Note: </p> <p>Elliptic integrals of the first kind are defined as </p> <pre class="example" data-language="matlab">1
        /               dt
K (m) = | ------------------------------
        / sqrt ((1 - t^2)*(1 - m*t^2))
       0</pre> <p>Elliptic integrals of the second kind are defined as </p> <pre class="example" data-language="matlab">1
        /  sqrt (1 - m*t^2)
E (m) = |  ------------------ dt
        /  sqrt (1 - t^2)
       0</pre> <p>Reference: Milton Abramowitz and Irene A. Stegun, <cite>Handbook of Mathematical Functions</cite>, Chapter 17, Dover, 1965. </p> <p><strong>See also:</strong> <a href="#XREFellipj">ellipj</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erf">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>erf</strong> <em>(<var>z</var>)</em><a href="#index-erf" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the error function. </p> <p>The error function is defined as </p> <pre class="example" data-language="matlab">z
              2        /
erf (z) = --------- *  | e^(-t^2) dt
          sqrt (pi)    /
                    t=0</pre> <p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erfc">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>erfc</strong> <em>(<var>z</var>)</em><a href="#index-erfc" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the complementary error function. </p> <p>The complementary error function is defined as <code>1 <span class="nolinebreak">-</span> erf (<var>z</var>)</code>. </p> <p><strong>See also:</strong> <a href="#XREFerfcinv">erfcinv</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfinv">erfinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erfcx">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>erfcx</strong> <em>(<var>z</var>)</em><a href="#index-erfcx" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the scaled complementary error function. </p> <p>The scaled complementary error function is defined as </p> <pre class="example" data-language="matlab">exp (z^2) * erfc (z)</pre> <p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erfi">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>erfi</strong> <em>(<var>z</var>)</em><a href="#index-erfi" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the imaginary error function. </p> <p>The imaginary error function is defined as </p> <pre class="example" data-language="matlab">-i * erf (i*z)</pre> <p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>, <a href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erfinv">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>erfinv</strong> <em>(<var>x</var>)</em><a href="#index-erfinv" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse error function. </p> <p>The inverse error function is defined such that </p> <pre class="example" data-language="matlab">erf (y) == x</pre> <p><strong>See also:</strong> <a href="#XREFerf">erf</a>, <a href="#XREFerfc">erfc</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfcinv">erfcinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-erfcinv">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>erfcinv</strong> <em>(<var>x</var>)</em><a href="#index-erfcinv" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse complementary error function. </p> <p>The inverse complementary error function is defined such that </p> <pre class="example" data-language="matlab">erfc (y) == x</pre> <p><strong>See also:</strong> <a href="#XREFerfc">erfc</a>, <a href="#XREFerf">erf</a>, <a href="#XREFerfcx">erfcx</a>, <a href="#XREFerfi">erfi</a>, <a href="#XREFdawson">dawson</a>, <a href="#XREFerfinv">erfinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-expint">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>expint</strong> <em>(<var>x</var>)</em><a href="#index-expint" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the exponential integral. </p> <p>The exponential integral is defined as: </p> <pre class="example" data-language="matlab">+oo
          /
          | exp (-t)
E_1 (x) = | -------- dt
          |    t
          /
         x</pre> <p>Note: For compatibility, this function uses the <small>MATLAB</small> definition of the exponential integral. Most other sources refer to this particular value as <em class="math">E_1 (x)</em>, and the exponential integral as </p> <pre class="example" data-language="matlab">+oo
           /
           | exp (-t)
Ei (x) = - | -------- dt
           |    t
           /
         -x</pre> <p>The two definitions are related, for positive real values of <var>x</var>, by <code><span class="nolinebreak">E_1</span> <span class="nolinebreak">(-x)</span> = <span class="nolinebreak">-Ei</span> (x) <span class="nolinebreak">-</span> i*pi</code>. </p> <p>References: </p> <p>M. Abramowitz and I.A. Stegun, <cite>Handbook of Mathematical Functions</cite>, 1964. </p> <p>N. Bleistein and R.A. Handelsman, <cite>Asymptotic expansions of integrals</cite>, 1986. </p> <p><strong>See also:</strong> <a href="#XREFcosint">cosint</a>, <a href="#XREFsinint">sinint</a>, <a href="exponents-and-logarithms.html#XREFexp">exp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gamma">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>gamma</strong> <em>(<var>z</var>)</em><a href="#index-gamma" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Gamma function. </p> <p>The Gamma function is defined as </p> <pre class="example" data-language="matlab">infinity
            /
gamma (z) = | t^(z-1) exp (-t) dt.
            /
         t=0</pre> <p>Programming Note: The gamma function can grow quite large even for small input values. In many cases it may be preferable to use the natural logarithm of the gamma function (<code>gammaln</code>) in calculations to minimize loss of precision. The final result is then <code>exp (<var>result_using_gammaln</var>).</code> </p> <p><strong>See also:</strong> <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgammaln">gammaln</a>, <a href="utility-functions.html#XREFfactorial">factorial</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gammainc">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>)</em><a href="#index-gammainc" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gammainc-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>gammainc</strong> <em>(<var>x</var>, <var>a</var>, <var>tail</var>)</em><a href="#index-gammainc-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the normalized incomplete gamma function. </p> <p>This is defined as </p> <pre class="example" data-language="matlab">x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0</pre> <p>with the limiting value of 1 as <var>x</var> approaches infinity. The standard notation is <em class="math">P(a,x)</em>, e.g., Abramowitz and Stegun (6.5.1). </p> <p>If <var>a</var> is scalar, then <code>gammainc (<var>x</var>, <var>a</var>)</code> is returned for each element of <var>x</var> and vice versa. </p> <p>If neither <var>x</var> nor <var>a</var> is scalar then the sizes of <var>x</var> and <var>a</var> must agree, and <code>gammainc</code> is applied element-by-element. The elements of <var>a</var> must be non-negative. </p> <p>By default, <var>tail</var> is <code>"lower"</code> and the incomplete gamma function integrated from 0 to <var>x</var> is computed. If <var>tail</var> is <code>"upper"</code> then the complementary function integrated from <var>x</var> to infinity is calculated. </p> <p>If <var>tail</var> is <code>"scaledlower"</code>, then the lower incomplete gamma function is multiplied by <em class="math">gamma(a+1)*exp(x)/(x^a)</em>. If <var>tail</var> is <code>"scaledupper"</code>, then the upper incomplete gamma function is multiplied by the same quantity. </p> <p>References: </p> <p>M. Abramowitz and I.A. Stegun, <cite>Handbook of mathematical functions</cite>, Dover publications, Inc., 1972. </p> <p>W. Gautschi, <cite>A computational procedure for incomplete gamma functions</cite>, ACM Trans. Math Software, pp. 466–481, Vol 5, No. 4, 2012. </p> <p>W. H. Press, S. A. Teukolsky, W. T. Vetterling, and B. P. Flannery, <cite>Numerical Recipes in Fortran 77</cite>, ch. 6.2, Vol 1, 1992. </p> <p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammaincinv">gammaincinv</a>, <a href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gammaincinv">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>gammaincinv</strong> <em>(<var>y</var>, <var>a</var>)</em><a href="#index-gammaincinv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gammaincinv-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>gammaincinv</strong> <em>(<var>y</var>, <var>a</var>, <var>tail</var>)</em><a href="#index-gammaincinv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the normalized incomplete gamma function. </p> <p>The normalized incomplete gamma function is defined as </p> <pre class="example" data-language="matlab">x
                       1       /
gammainc (x, a) = ---------    | exp (-t) t^(a-1) dt
                  gamma (a)    /
                            t=0</pre> <p>and <code>gammaincinv (gammainc (<var>x</var>, <var>a</var>), <var>a</var>) = <var>x</var></code> for each non-negative value of <var>x</var>. If <var>a</var> is scalar then <code>gammaincinv (<var>y</var>, <var>a</var>)</code> is returned for each element of <var>y</var> and vice versa. </p> <p>If neither <var>y</var> nor <var>a</var> is scalar then the sizes of <var>y</var> and <var>a</var> must agree, and <code>gammaincinv</code> is applied element-by-element. The variable <var>y</var> must be in the interval <em class="math">[0,1]</em> while <var>a</var> must be real and positive. </p> <p>By default, <var>tail</var> is <code>"lower"</code> and the inverse of the incomplete gamma function integrated from 0 to <var>x</var> is computed. If <var>tail</var> is <code>"upper"</code>, then the complementary function integrated from <var>x</var> to infinity is inverted. </p> <p>The function is computed with Newton’s method by solving </p> <pre class="example" data-language="matlab">y - gammainc (x, a) = 0</pre> <p>Reference: A. Gil, J. Segura, and N. M. Temme, <cite>Efficient and accurate algorithms for the computation and inversion of the incomplete gamma function ratios</cite>, SIAM J. Sci. Computing, pp. A2965–A2981, Vol 34, 2012. </p> <p><strong>See also:</strong> <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgamma">gamma</a>, <a href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-legendre">
<span class="category">: </span><span><em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>)</em><a href="#index-legendre" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-legendre-1">
<span class="category">: </span><span><em><var>l</var> =</em> <strong>legendre</strong> <em>(<var>n</var>, <var>x</var>, <var>normalization</var>)</em><a href="#index-legendre-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the associated Legendre function of degree <var>n</var> and order <var>m</var> = 0 … <var>n</var>. </p> <p>The value <var>n</var> must be a real non-negative integer. </p> <p><var>x</var> is a vector with real-valued elements in the range [-1, 1]. </p> <p>The optional argument <var>normalization</var> may be one of <code>"unnorm"</code>, <code>"sch"</code>, or <code>"norm"</code>. The default if no normalization is given is <code>"unnorm"</code>. </p> <p>When the optional argument <var>normalization</var> is <code>"unnorm"</code>, compute the associated Legendre function of degree <var>n</var> and order <var>m</var> and return all values for <var>m</var> = 0 … <var>n</var>. The return value has one dimension more than <var>x</var>. </p> <p>The associated Legendre function of degree <var>n</var> and order <var>m</var>: </p> <pre class="example" data-language="matlab">m         m      2  m/2   d^m
P(x) = (-1) * (1-x  )    * ----  P(x)
 n                         dx^m   n</pre> <p>with Legendre polynomial of degree <var>n</var>: </p> <pre class="example" data-language="matlab">1    d^n   2    n
P(x) = ------ [----(x - 1) ]
 n     2^n n!  dx^n</pre> <p><code>legendre (3, [-1.0, -0.9, -0.8])</code> returns the matrix: </p> <pre class="example" data-language="matlab">x  |   -1.0   |   -0.9   |   -0.8
------------------------------------
m=0 | -1.00000 | -0.47250 | -0.08000
m=1 |  0.00000 | -1.99420 | -1.98000
m=2 |  0.00000 | -2.56500 | -4.32000
m=3 |  0.00000 | -1.24229 | -3.24000</pre> <p>When the optional argument <var>normalization</var> is <code>"sch"</code>, compute the Schmidt semi-normalized associated Legendre function. The Schmidt semi-normalized associated Legendre function is related to the unnormalized Legendre functions by the following: </p> <p>For Legendre functions of degree <var>n</var> and order 0: </p> <pre class="example" data-language="matlab">0      0
SP(x) = P(x)
  n      n</pre> <p>For Legendre functions of degree n and order m: </p> <pre class="example" data-language="matlab">m      m         m    2(n-m)! 0.5
SP(x) = P(x) * (-1)  * [-------]
  n      n              (n+m)!</pre> <p>When the optional argument <var>normalization</var> is <code>"norm"</code>, compute the fully normalized associated Legendre function. The fully normalized associated Legendre function is related to the unnormalized associated Legendre functions by the following: </p> <p>For Legendre functions of degree <var>n</var> and order <var>m</var> </p> <pre class="example" data-language="matlab">m      m         m    (n+0.5)(n-m)! 0.5
NP(x) = P(x) * (-1)  * [-------------]
  n      n                  (n+m)!</pre> </dd>
</dl> <dl class="def"> <dt id="index-gammaln">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>gammaln</strong> <em>(<var>x</var>)</em><a href="#index-gammaln" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-lgamma">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>lgamma</strong> <em>(<var>x</var>)</em><a href="#index-lgamma" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the natural logarithm of the gamma function of <var>x</var>. </p> <p>Programming Note: <code>lgamma</code> is an alias for <code>gammaln</code> and either name can be used in Octave. </p> <p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammainc">gammainc</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-psi">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>psi</strong> <em>(<var>z</var>)</em><a href="#index-psi" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-psi-1">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>psi</strong> <em>(<var>k</var>, <var>z</var>)</em><a href="#index-psi-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the psi (polygamma) function. </p> <p>The polygamma functions are the <var>k</var>th derivative of the logarithm of the gamma function. If unspecified, <var>k</var> defaults to zero. A value of zero computes the digamma function, a value of 1, the trigamma function, and so on. </p> <p>The digamma function is defined: </p> <pre class="example" data-language="matlab">psi (z) = d (log (gamma (z))) / dx</pre> <p>When computing the digamma function (when <var>k</var> equals zero), <var>z</var> can have any value real or complex value. However, for polygamma functions (<var>k</var> higher than 0), <var>z</var> must be real and non-negative. </p> <p><strong>See also:</strong> <a href="#XREFgamma">gamma</a>, <a href="#XREFgammainc">gammainc</a>, <a href="#XREFgammaln">gammaln</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-sinint">
<span class="category">: </span><span><em><var>y</var> =</em> <strong>sinint</strong> <em>(<var>x</var>)</em><a href="#index-sinint" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the sine integral function: </p> <pre class="example" data-language="matlab">x
          /
Si (x) =  | sin (t) / t dt
          /
         0</pre> <p>Reference: M. Abramowitz and I.A. Stegun, <cite>Handbook of Mathematical Functions</cite>, 1964. </p> <p><strong>See also:</strong> <a href="#XREFcosint">cosint</a>, <a href="#XREFexpint">expint</a>, <a href="trigonometry.html#XREFsin">sin</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Special-Functions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Special-Functions.html</a>
  </p>
</div>
