<div class="section" id="Matlab_002dcompatible-solvers">   <h1 class="section">24.3 Matlab-compatible solvers</h1> <p>Octave also provides a set of solvers for initial value problems for ordinary differential equations (ODEs) that have a <small>MATLAB</small>-compatible interface. The options for this class of methods are set using the functions. </p> <ul> <li> <a href="#XREFodeset">odeset</a> </li>
<li> <a href="#XREFodeget">odeget</a> </li>
</ul> <p>Currently implemented solvers are: </p> <ul> <li> Runge-Kutta methods <ul> <li> <a href="#XREFode45">ode45</a> integrates a system of non-stiff ODEs or index-1 differential-algebraic equations (DAEs) using the high-order, variable-step Dormand-Prince method. It requires six function evaluations per integration step, but may take larger steps on smooth problems than <code>ode23</code>: potentially offering improved efficiency at smaller tolerances. </li>
<li> <a href="#XREFode23">ode23</a> integrates a system of non-stiff ODEs or (or index-1 DAEs). It uses the third-order Bogacki-Shampine method and adapts the local step size in order to satisfy a user-specified tolerance. The solver requires three function evaluations per integration step. </li>
<li> <a href="#XREFode23s">ode23s</a> integrates a system of stiff ODEs (or index-1 DAEs) using a modified second-order Rosenbrock method. </li>
</ul> </li>
<li> Linear multistep methods <ul> <li> <a href="#XREFode15s">ode15s</a> integrates a system of stiff ODEs (or index-1 DAEs) using a variable step, variable order method based on Backward Difference Formulas (BDF). </li>
<li> <a href="#XREFode15i">ode15i</a> integrates a system of fully-implicit ODEs (or index-1 DAEs) using the same variable step, variable order method as <code>ode15s</code>. <a href="#XREFdecic">decic</a> can be used to compute consistent initial conditions for <code>ode15i</code>. </li>
</ul> </li>
</ul> <p>Detailed information on the solvers are given in L. F. Shampine and M. W. Reichelt, <cite>The MATLAB ODE Suite</cite>, SIAM Journal on Scientific Computing, Vol. 18, 1997, pp. 1–22, DOI: <a href="https://doi.org/10.1137/S1064827594276424">https://doi.org/10.1137/S1064827594276424</a>. </p> <dl class="def"> <dt id="index-ode45">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode45</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>)</em><a href="#index-ode45" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode45-1">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode45</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>, <var>ode_opt</var>)</em><a href="#index-ode45-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode45-2">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>, <var>te</var>, <var>ye</var>, <var>ie</var>] =</em> <strong>ode45</strong> <em>(…)</em><a href="#index-ode45-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode45-3">
<span class="category">: </span><span><em><var>solution</var> =</em> <strong>ode45</strong> <em>(…)</em><a href="#index-ode45-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode45-4">
<span class="category">: </span><span> <strong>ode45</strong> <em>(…)</em><a href="#index-ode45-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Dormand-Prince method of order 4. </p> <p><var>fcn</var> is a function handle, inline function, or string containing the name of the function that defines the ODE: <code>y' = f(t,y)</code>. The function must accept two inputs where the first is time <var>t</var> and the second is a column vector of unknowns <var>y</var>. </p> <p><var>trange</var> specifies the time interval over which the ODE will be evaluated. Typically, it is a two-element vector specifying the initial and final times (<code>[tinit, tfinal]</code>). If there are more than two elements then the solution will also be evaluated at these intermediate time instances. </p> <p>By default, <code>ode45</code> uses an adaptive timestep with the <code>integrate_adaptive</code> algorithm. The tolerance for the timestep computation may be changed by using the options <code>"RelTol"</code> and <code>"AbsTol"</code>. </p> <p><var>init</var> contains the initial value for the unknowns. If it is a row vector then the solution <var>y</var> will be a matrix in which each column is the solution for the corresponding initial value in <var>init</var>. </p> <p>The optional fourth argument <var>ode_opt</var> specifies non-default options to the ODE solver. It is a structure generated by <code>odeset</code>. </p> <p>The function typically returns two outputs. Variable <var>t</var> is a column vector and contains the times where the solution was found. The output <var>y</var> is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in <var>t</var>. </p> <p>The output can also be returned as a structure <var>solution</var> which has a field <var>x</var> containing a row vector of times where the solution was evaluated and a field <var>y</var> containing the solution matrix such that each column corresponds to a time in <var>x</var>. Use <code>fieldnames (<var>solution</var>)</code> to see the other fields and additional information returned. </p> <p>If no output arguments are requested, and no <code>"OutputFcn"</code> is specified in <var>ode_opt</var>, then the <code>"OutputFcn"</code> is set to <code>odeplot</code> and the results of the solver are plotted immediately. </p> <p>If using the <code>"Events"</code> option then three additional outputs may be returned. <var>te</var> holds the time when an Event function returned a zero. <var>ye</var> holds the value of the solution at time <var>te</var>. <var>ie</var> contains an index indicating which Event function was triggered in the case of multiple Event functions. </p> <p>Example: Solve the Van der Pol equation </p> <pre class="example" data-language="matlab">fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
[t,y] = ode45 (fvdp, [0, 20], [2, 0]);</pre> <p><strong>See also:</strong> <a href="#XREFodeset">odeset</a>, <a href="#XREFodeget">odeget</a>, <a href="#XREFode23">ode23</a>, <a href="#XREFode15s">ode15s</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ode23">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode23</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>)</em><a href="#index-ode23" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23-1">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode23</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>, <var>ode_opt</var>)</em><a href="#index-ode23-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23-2">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>, <var>te</var>, <var>ye</var>, <var>ie</var>] =</em> <strong>ode23</strong> <em>(…)</em><a href="#index-ode23-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23-3">
<span class="category">: </span><span><em><var>solution</var> =</em> <strong>ode23</strong> <em>(…)</em><a href="#index-ode23-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23-4">
<span class="category">: </span><span> <strong>ode23</strong> <em>(…)</em><a href="#index-ode23-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Solve a set of non-stiff Ordinary Differential Equations (non-stiff ODEs) with the well known explicit Bogacki-Shampine method of order 3. </p> <p><var>fcn</var> is a function handle, inline function, or string containing the name of the function that defines the ODE: <code>y' = f(t,y)</code>. The function must accept two inputs where the first is time <var>t</var> and the second is a column vector of unknowns <var>y</var>. </p> <p><var>trange</var> specifies the time interval over which the ODE will be evaluated. Typically, it is a two-element vector specifying the initial and final times (<code>[tinit, tfinal]</code>). If there are more than two elements then the solution will also be evaluated at these intermediate time instances. </p> <p>By default, <code>ode23</code> uses an adaptive timestep with the <code>integrate_adaptive</code> algorithm. The tolerance for the timestep computation may be changed by using the options <code>"RelTol"</code> and <code>"AbsTol"</code>. </p> <p><var>init</var> contains the initial value for the unknowns. If it is a row vector then the solution <var>y</var> will be a matrix in which each column is the solution for the corresponding initial value in <var>init</var>. </p> <p>The optional fourth argument <var>ode_opt</var> specifies non-default options to the ODE solver. It is a structure generated by <code>odeset</code>. </p> <p>The function typically returns two outputs. Variable <var>t</var> is a column vector and contains the times where the solution was found. The output <var>y</var> is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in <var>t</var>. </p> <p>The output can also be returned as a structure <var>solution</var> which has a field <var>x</var> containing a row vector of times where the solution was evaluated and a field <var>y</var> containing the solution matrix such that each column corresponds to a time in <var>x</var>. Use <code>fieldnames (<var>solution</var>)</code> to see the other fields and additional information returned. </p> <p>If no output arguments are requested, and no <code>"OutputFcn"</code> is specified in <var>ode_opt</var>, then the <code>"OutputFcn"</code> is set to <code>odeplot</code> and the results of the solver are plotted immediately. </p> <p>If using the <code>"Events"</code> option then three additional outputs may be returned. <var>te</var> holds the time when an Event function returned a zero. <var>ye</var> holds the value of the solution at time <var>te</var>. <var>ie</var> contains an index indicating which Event function was triggered in the case of multiple Event functions. </p> <p>Example: Solve the Van der Pol equation </p> <pre class="example" data-language="matlab">fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];
[t,y] = ode23 (fvdp, [0, 20], [2, 0]);</pre> <p>Reference: For the definition of this method see <a href="https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods">https://en.wikipedia.org/wiki/List_of_Runge%E2%80%93Kutta_methods</a>. </p> <p><strong>See also:</strong> <a href="#XREFodeset">odeset</a>, <a href="#XREFodeget">odeget</a>, <a href="#XREFode45">ode45</a>, <a href="#XREFode15s">ode15s</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ode23s">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode23s</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>)</em><a href="#index-ode23s" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23s-1">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode23s</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>init</var>, <var>ode_opt</var>)</em><a href="#index-ode23s-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23s-2">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode23s</strong> <em>(…, <var>par1</var>, <var>par2</var>, …)</em><a href="#index-ode23s-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23s-3">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>, <var>te</var>, <var>ye</var>, <var>ie</var>] =</em> <strong>ode23s</strong> <em>(…)</em><a href="#index-ode23s-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode23s-4">
<span class="category">: </span><span><em><var>solution</var> =</em> <strong>ode23s</strong> <em>(…)</em><a href="#index-ode23s-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Solve a set of stiff Ordinary Differential Equations (stiff ODEs) with a Rosenbrock method of order (2,3). </p> <p><var>fcn</var> is a function handle, inline function, or string containing the name of the function that defines the ODE: <code>M y' = f(t,y)</code>. The function must accept two inputs where the first is time <var>t</var> and the second is a column vector of unknowns <var>y</var>. <var>M</var> is a constant mass matrix, non-singular and possibly sparse. Set the field <code>"Mass"</code> in <var>odeopts</var> using <var>odeset</var> to specify a mass matrix. </p> <p><var>trange</var> specifies the time interval over which the ODE will be evaluated. Typically, it is a two-element vector specifying the initial and final times (<code>[tinit, tfinal]</code>). If there are more than two elements then the solution will also be evaluated at these intermediate time instances using an interpolation procedure of the same order as the one of the solver. </p> <p>By default, <code>ode23s</code> uses an adaptive timestep with the <code>integrate_adaptive</code> algorithm. The tolerance for the timestep computation may be changed by using the options <code>"RelTol"</code> and <code>"AbsTol"</code>. </p> <p><var>init</var> contains the initial value for the unknowns. If it is a row vector then the solution <var>y</var> will be a matrix in which each column is the solution for the corresponding initial value in <var>init</var>. </p> <p>The optional fourth argument <var>ode_opt</var> specifies non-default options to the ODE solver. It is a structure generated by <code>odeset</code>. <code>ode23s</code> will ignore the following options: <code>"BDF"</code>, <code>"InitialSlope"</code>, <code>"MassSingular"</code>, <code>"MStateDependence"</code>, <code>"MvPattern"</code>, <code>"MaxOrder"</code>, <code>"Non-negative"</code>. </p> <p>The function typically returns two outputs. Variable <var>t</var> is a column vector and contains the times where the solution was found. The output <var>y</var> is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in <var>t</var>. If <var>trange</var> specifies intermediate time steps, only those will be returned. </p> <p>The output can also be returned as a structure <var>solution</var> which has a field <var>x</var> containing a row vector of times where the solution was evaluated and a field <var>y</var> containing the solution matrix such that each column corresponds to a time in <var>x</var>. Use <code>fieldnames (<var>solution</var>)</code> to see the other fields and additional information returned. </p> <p>If using the <code>"Events"</code> option then three additional outputs may be returned. <var>te</var> holds the time when an Event function returned a zero. <var>ye</var> holds the value of the solution at time <var>te</var>. <var>ie</var> contains an index indicating which Event function was triggered in the case of multiple Event functions. </p> <p>Example: Solve the stiff Van der Pol equation </p> <pre class="example" data-language="matlab">f = @(t,y) [y(2); 1000*(1 - y(1)^2) * y(2) - y(1)];
opt = odeset ('Mass', [1 0; 0 1], 'MaxStep', 1e-1);
[vt, vy] = ode23s (f, [0 2000], [2 0], opt);</pre> <p><strong>See also:</strong> <a href="#XREFodeset">odeset</a>, <a href="differential_002dalgebraic-equations.html#XREFdaspk">daspk</a>, <a href="differential_002dalgebraic-equations.html#XREFdassl">dassl</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ode15s">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode15s</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>y0</var>)</em><a href="#index-ode15s" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15s-1">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode15s</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>y0</var>, <var>ode_opt</var>)</em><a href="#index-ode15s-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15s-2">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>, <var>te</var>, <var>ye</var>, <var>ie</var>] =</em> <strong>ode15s</strong> <em>(…)</em><a href="#index-ode15s-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15s-3">
<span class="category">: </span><span><em><var>solution</var> =</em> <strong>ode15s</strong> <em>(…)</em><a href="#index-ode15s-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15s-4">
<span class="category">: </span><span> <strong>ode15s</strong> <em>(…)</em><a href="#index-ode15s-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve a set of stiff Ordinary Differential Equations (ODEs) or stiff semi-explicit index 1 Differential Algebraic Equations (DAEs). </p> <p><code>ode15s</code> uses a variable step, variable order BDF (Backward Differentiation Formula) method that ranges from order 1 to 5. </p> <p><var>fcn</var> is a function handle, inline function, or string containing the name of the function that defines the ODE: <code>y' = f(t,y)</code>. The function must accept two inputs where the first is time <var>t</var> and the second is a column vector of unknowns <var>y</var>. </p> <p><var>trange</var> specifies the time interval over which the ODE will be evaluated. Typically, it is a two-element vector specifying the initial and final times (<code>[tinit, tfinal]</code>). If there are more than two elements then the solution will also be evaluated at these intermediate time instances. </p> <p><var>init</var> contains the initial value for the unknowns. If it is a row vector then the solution <var>y</var> will be a matrix in which each column is the solution for the corresponding initial value in <var>init</var>. </p> <p>The optional fourth argument <var>ode_opt</var> specifies non-default options to the ODE solver. It is a structure generated by <code>odeset</code>. </p> <p>The function typically returns two outputs. Variable <var>t</var> is a column vector and contains the times where the solution was found. The output <var>y</var> is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in <var>t</var>. </p> <p>The output can also be returned as a structure <var>solution</var> which has a field <var>x</var> containing a row vector of times where the solution was evaluated and a field <var>y</var> containing the solution matrix such that each column corresponds to a time in <var>x</var>. Use <code>fieldnames (<var>solution</var>)</code> to see the other fields and additional information returned. </p> <p>If no output arguments are requested, and no <code>"OutputFcn"</code> is specified in <var>ode_opt</var>, then the <code>"OutputFcn"</code> is set to <code>odeplot</code> and the results of the solver are plotted immediately. </p> <p>If using the <code>"Events"</code> option then three additional outputs may be returned. <var>te</var> holds the time when an Event function returned a zero. <var>ye</var> holds the value of the solution at time <var>te</var>. <var>ie</var> contains an index indicating which Event function was triggered in the case of multiple Event functions. </p> <p>Example: Solve Robertson’s equations: </p> <pre class="example" data-language="matlab">function r = robertson_dae (t, y)
  r = [ -0.04*y(1) + 1e4*y(2)*y(3)
         0.04*y(1) - 1e4*y(2)*y(3) - 3e7*y(2)^2
y(1) + y(2) + y(3) - 1 ];
endfunction
opt = odeset ("Mass", [1 0 0; 0 1 0; 0 0 0], "MStateDependence", "none");
[t,y] = ode15s (@robertson_dae, [0, 1e3], [1; 0; 0], opt);</pre> <p><strong>See also:</strong> <a href="#XREFdecic">decic</a>, <a href="#XREFodeset">odeset</a>, <a href="#XREFodeget">odeget</a>, <a href="#XREFode23">ode23</a>, <a href="#XREFode45">ode45</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ode15i">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode15i</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>y0</var>, <var>yp0</var>)</em><a href="#index-ode15i" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15i-1">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>] =</em> <strong>ode15i</strong> <em>(<var>fcn</var>, <var>trange</var>, <var>y0</var>, <var>yp0</var>, <var>ode_opt</var>)</em><a href="#index-ode15i-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15i-2">
<span class="category">: </span><span><em>[<var>t</var>, <var>y</var>, <var>te</var>, <var>ye</var>, <var>ie</var>] =</em> <strong>ode15i</strong> <em>(…)</em><a href="#index-ode15i-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15i-3">
<span class="category">: </span><span><em><var>solution</var> =</em> <strong>ode15i</strong> <em>(…)</em><a href="#index-ode15i-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ode15i-4">
<span class="category">: </span><span> <strong>ode15i</strong> <em>(…)</em><a href="#index-ode15i-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve a set of fully-implicit Ordinary Differential Equations (ODEs) or index 1 Differential Algebraic Equations (DAEs). </p> <p><code>ode15i</code> uses a variable step, variable order BDF (Backward Differentiation Formula) method that ranges from order 1 to 5. </p> <p><var>fcn</var> is a function handle, inline function, or string containing the name of the function that defines the ODE: <code>0 = f(t,y,yp)</code>. The function must accept three inputs where the first is time <var>t</var>, the second is the function value <var>y</var> (a column vector), and the third is the derivative value <var>yp</var> (a column vector). </p> <p><var>trange</var> specifies the time interval over which the ODE will be evaluated. Typically, it is a two-element vector specifying the initial and final times (<code>[tinit, tfinal]</code>). If there are more than two elements then the solution will also be evaluated at these intermediate time instances. </p> <p><var>y0</var> and <var>yp0</var> contain the initial values for the unknowns <var>y</var> and <var>yp</var>. If they are row vectors then the solution <var>y</var> will be a matrix in which each column is the solution for the corresponding initial value in <var>y0</var> and <var>yp0</var>. </p> <p><var>y0</var> and <var>yp0</var> must be consistent initial conditions, meaning that <code>f(t,y0,yp0) = 0</code> is satisfied. The function <code>decic</code> may be used to compute consistent initial conditions given initial guesses. </p> <p>The optional fifth argument <var>ode_opt</var> specifies non-default options to the ODE solver. It is a structure generated by <code>odeset</code>. </p> <p>The function typically returns two outputs. Variable <var>t</var> is a column vector and contains the times where the solution was found. The output <var>y</var> is a matrix in which each column refers to a different unknown of the problem and each row corresponds to a time in <var>t</var>. </p> <p>The output can also be returned as a structure <var>solution</var> which has a field <var>x</var> containing a row vector of times where the solution was evaluated and a field <var>y</var> containing the solution matrix such that each column corresponds to a time in <var>x</var>. Use <code>fieldnames (<var>solution</var>)</code> to see the other fields and additional information returned. </p> <p>If no output arguments are requested, and no <code>"OutputFcn"</code> is specified in <var>ode_opt</var>, then the <code>"OutputFcn"</code> is set to <code>odeplot</code> and the results of the solver are plotted immediately. </p> <p>If using the <code>"Events"</code> option then three additional outputs may be returned. <var>te</var> holds the time when an Event function returned a zero. <var>ye</var> holds the value of the solution at time <var>te</var>. <var>ie</var> contains an index indicating which Event function was triggered in the case of multiple Event functions. </p> <p>Example: Solve Robertson’s equations: </p> <pre class="example" data-language="matlab">function r = robertson_dae (t, y, yp)
  r = [ -(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3))
        -(yp(2) - 0.04*y(1) + 1e4*y(2)*y(3) + 3e7*y(2)^2)
y(1) + y(2) + y(3) - 1 ];
endfunction
[t,y] = ode15i (@robertson_dae, [0, 1e3], [1; 0; 0], [-1e-4; 1e-4; 0]);</pre> <p><strong>See also:</strong> <a href="#XREFdecic">decic</a>, <a href="#XREFodeset">odeset</a>, <a href="#XREFodeget">odeget</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-decic">
<span class="category">: </span><span><em>[<var>y0_new</var>, <var>yp0_new</var>] =</em> <strong>decic</strong> <em>(<var>fcn</var>, <var>t0</var>, <var>y0</var>, <var>fixed_y0</var>, <var>yp0</var>, <var>fixed_yp0</var>)</em><a href="#index-decic" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-decic-1">
<span class="category">: </span><span><em>[<var>y0_new</var>, <var>yp0_new</var>] =</em> <strong>decic</strong> <em>(<var>fcn</var>, <var>t0</var>, <var>y0</var>, <var>fixed_y0</var>, <var>yp0</var>, <var>fixed_yp0</var>, <var>options</var>)</em><a href="#index-decic-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-decic-2">
<span class="category">: </span><span><em>[<var>y0_new</var>, <var>yp0_new</var>, <var>resnorm</var>] =</em> <strong>decic</strong> <em>(…)</em><a href="#index-decic-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Compute consistent implicit ODE initial conditions <var>y0_new</var> and <var>yp0_new</var> given initial guesses <var>y0</var> and <var>yp0</var>. </p> <p>A maximum of <code>length (<var>y0</var>)</code> components between <var>fixed_y0</var> and <var>fixed_yp0</var> may be chosen as fixed values. </p> <p><var>fcn</var> is a function handle. The function must accept three inputs where the first is time <var>t</var>, the second is a column vector of unknowns <var>y</var>, and the third is a column vector of unknowns <var>yp</var>. </p> <p><var>t0</var> is the initial time such that <code><var>fcn</var>(<var>t0</var>, <var>y0_new</var>, <var>yp0_new</var>) = 0</code>, specified as a scalar. </p> <p><var>y0</var> is a vector used as the initial guess for <var>y</var>. </p> <p><var>fixed_y0</var> is a vector which specifies the components of <var>y0</var> to hold fixed. Choose a maximum of <code>length (<var>y0</var>)</code> components between <var>fixed_y0</var> and <var>fixed_yp0</var> as fixed values. Set <var>fixed_y0</var>(i) component to 1 if you want to fix the value of <var>y0</var>(i). Set <var>fixed_y0</var>(i) component to 0 if you want to allow the value of <var>y0</var>(i) to change. </p> <p><var>yp0</var> is a vector used as the initial guess for <var>yp</var>. </p> <p><var>fixed_yp0</var> is a vector which specifies the components of <var>yp0</var> to hold fixed. Choose a maximum of <code>length (<var>yp0</var>)</code> components between <var>fixed_y0</var> and <var>fixed_yp0</var> as fixed values. Set <var>fixed_yp0</var>(i) component to 1 if you want to fix the value of <var>yp0</var>(i). Set <var>fixed_yp0</var>(i) component to 0 if you want to allow the value of <var>yp0</var>(i) to change. </p> <p>The optional seventh argument <var>options</var> is a structure array. Use <code>odeset</code> to generate this structure. The relevant options are <code>RelTol</code> and <code>AbsTol</code> which specify the error thresholds used to compute the initial conditions. </p> <p>The function typically returns two outputs. Variable <var>y0_new</var> is a column vector and contains the consistent initial value of <var>y</var>. The output <var>yp0_new</var> is a column vector and contains the consistent initial value of <var>yp</var>. </p> <p>The optional third output <var>resnorm</var> is the norm of the vector of residuals. If <var>resnorm</var> is small, <code>decic</code> has successfully computed the initial conditions. If the value of <var>resnorm</var> is large, use <code>RelTol</code> and <code>AbsTol</code> to adjust it. </p> <p>Example: Compute initial conditions for Robertson’s equations: </p> <pre class="example" data-language="matlab">function r = robertson_dae (t, y, yp)
  r = [ -(yp(1) + 0.04*y(1) - 1e4*y(2)*y(3))
        -(yp(2) - 0.04*y(1) + 1e4*y(2)*y(3) + 3e7*y(2)^2)
y(1) + y(2) + y(3) - 1 ];
endfunction
[y0_new,yp0_new] = decic (@robertson_dae, 0, [1; 0; 0], [1; 1; 0],
[-1e-4; 1; 0], [0; 0; 0]);</pre> <p><strong>See also:</strong> <a href="#XREFode15i">ode15i</a>, <a href="#XREFodeset">odeset</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-odeset">
<span class="category">: </span><span><em><var>odestruct</var> =</em> <strong>odeset</strong> <em>()</em><a href="#index-odeset" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-odeset-1">
<span class="category">: </span><span><em><var>odestruct</var> =</em> <strong>odeset</strong> <em>(<var>"field1"</var>, <var>value1</var>, <var>"field2"</var>, <var>value2</var>, …)</em><a href="#index-odeset-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-odeset-2">
<span class="category">: </span><span><em><var>odestruct</var> =</em> <strong>odeset</strong> <em>(<var>oldstruct</var>, <var>"field1"</var>, <var>value1</var>, <var>"field2"</var>, <var>value2</var>, …)</em><a href="#index-odeset-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-odeset-3">
<span class="category">: </span><span><em><var>odestruct</var> =</em> <strong>odeset</strong> <em>(<var>oldstruct</var>, <var>newstruct</var>)</em><a href="#index-odeset-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-odeset-4">
<span class="category">: </span><span> <strong>odeset</strong> <em>()</em><a href="#index-odeset-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Create or modify an ODE options structure. </p> <p>When called with no input argument and one output argument, return a new ODE options structure that contains all possible fields initialized to their default values. If no output argument is requested, display a list of the common ODE solver options along with their default value. </p> <p>If called with name-value input argument pairs <var>"field1"</var>, <var>"value1"</var>, <var>"field2"</var>, <var>"value2"</var>, … return a new ODE options structure with all the most common option fields initialized, <strong>and</strong> set the values of the fields <var>"field1"</var>, <var>"field2"</var>, … to the values <var>value1</var>, <var>value2</var>, …. </p> <p>If called with an input structure <var>oldstruct</var> then overwrite the values of the options <var>"field1"</var>, <var>"field2"</var>, … with new values <var>value1</var>, <var>value2</var>, … and return the modified structure. </p> <p>When called with two input ODE options structures <var>oldstruct</var> and <var>newstruct</var> overwrite all values from the structure <var>oldstruct</var> with new values from the structure <var>newstruct</var>. Empty values in <var>newstruct</var> will not overwrite values in <var>oldstruct</var>. </p> <p>The most commonly used ODE options, which are always assigned a value by <code>odeset</code>, are the following: </p> <dl compact> <dt><span><code>AbsTol</code>: positive scalar | vector, def. <code>1e-6</code></span></dt> <dd>
<p>Absolute error tolerance. </p> </dd> <dt><span><code>BDF</code>: {<code>"off"</code>} | <code>"on"</code></span></dt> <dd>
<p>Use BDF formulas in implicit multistep methods. <em>Note</em>: This option is not yet implemented. </p> </dd> <dt><span><code>Events</code>: function_handle</span></dt> <dd>
<p>Event function. An event function must have the form <code>[value, isterminal, direction] = my_events_f (t, y)</code> </p> </dd> <dt><span><code>InitialSlope</code>: vector</span></dt> <dd>
<p>Consistent initial slope vector for DAE solvers. </p> </dd> <dt><span><code>InitialStep</code>: positive scalar</span></dt> <dd>
<p>Initial time step size. </p> </dd> <dt><span><code>Jacobian</code>: matrix | function_handle</span></dt> <dd>
<p>Jacobian matrix, specified as a constant matrix or a function of time and state. </p> </dd> <dt><span><code>JConstant</code>: {<code>"off"</code>} | <code>"on"</code></span></dt> <dd>
<p>Specify whether the Jacobian is a constant matrix or depends on the state. </p> </dd> <dt><span><code>JPattern</code>: sparse matrix</span></dt> <dd>
<p>If the Jacobian matrix is sparse and non-constant but maintains a constant sparsity pattern, specify the sparsity pattern. </p> </dd> <dt><span><code>Mass</code>: matrix | function_handle</span></dt> <dd>
<p>Mass matrix, specified as a constant matrix or a function of time and state. </p> </dd> <dt><span><code>MassSingular</code>: {<code>"maybe"</code>} | <code>"yes"</code> | <code>"on"</code></span></dt> <dd>
<p>Specify whether the mass matrix is singular. </p> </dd> <dt><span><code>MaxOrder</code>: {<code>5</code>} | <code>4</code> | <code>3</code> | <code>2</code> | <code>1</code></span></dt> <dd>
<p>Maximum order of formula. </p> </dd> <dt><span><code>MaxStep</code>: positive scalar</span></dt> <dd>
<p>Maximum time step value. </p> </dd> <dt><span><code>MStateDependence</code>: {<code>"weak"</code>} | <code>"none"</code> | <code>"strong"</code></span></dt> <dd>
<p>Specify whether the mass matrix depends on the state or only on time. </p> </dd> <dt><span><code>MvPattern</code>: sparse matrix</span></dt> <dd>
<p>If the mass matrix is sparse and non-constant but maintains a constant sparsity pattern, specify the sparsity pattern. <em>Note</em>: This option is not yet implemented. </p> </dd> <dt><span><code>NonNegative</code>: scalar | vector</span></dt> <dd>
<p>Specify elements of the state vector that are expected to remain non-negative during the simulation. </p> </dd> <dt><span><code>NormControl</code>: {<code>"off"</code>} | <code>"on"</code></span></dt> <dd>
<p>Control error relative to the 2-norm of the solution, rather than its absolute value. </p> </dd> <dt><span><code>OutputFcn</code>: function_handle</span></dt> <dd>
<p>Function to monitor the state during the simulation. For the form of the function to use see <a href="#XREFodeplot"><code>odeplot</code></a>. </p> </dd> <dt><span><code>OutputSel</code>: scalar | vector</span></dt> <dd>
<p>Indices of elements of the state vector to be passed to the output monitoring function. </p> </dd> <dt><span><code>Refine</code>: positive scalar</span></dt> <dd>
<p>Specify whether output should be returned only at the end of each time step or also at intermediate time instances. The value should be a scalar indicating the number of equally spaced time points to use within each timestep at which to return output. </p> </dd> <dt><span><code>RelTol</code>: positive scalar</span></dt> <dd>
<p>Relative error tolerance. </p> </dd> <dt><span><code>Stats</code>: {<code>"off"</code>} | <code>"on"</code></span></dt> <dd>
<p>Print solver statistics after simulation. </p> </dd> <dt><span><code>Vectorized</code>: {<code>"off"</code>} | <code>"on"</code></span></dt> <dd>
<p>Specify whether <code>odefcn</code> can be passed multiple values of the state at once. </p> </dd> </dl> <p>Field names that are not in the above list are also accepted and added to the result structure. </p> <p><strong>See also:</strong> <a href="#XREFodeget">odeget</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-odeget">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>odeget</strong> <em>(<var>ode_opt</var>, <var>field</var>)</em><a href="#index-odeget" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-odeget-1">
<span class="category">: </span><span><em><var>val</var> =</em> <strong>odeget</strong> <em>(<var>ode_opt</var>, <var>field</var>, <var>default</var>)</em><a href="#index-odeget-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Query the value of the property <var>field</var> in the ODE options structure <var>ode_opt</var>. </p> <p>If called with two input arguments and the first input argument <var>ode_opt</var> is an ODE option structure and the second input argument <var>field</var> is a string specifying an option name, then return the option value <var>val</var> corresponding to <var>field</var> from <var>ode_opt</var>. </p> <p>If called with an optional third input argument, and <var>field</var> is not set in the structure <var>ode_opt</var>, then return the default value <var>default</var> instead. </p> <p><strong>See also:</strong> <a href="#XREFodeset">odeset</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-odeplot">
<span class="category">: </span><span><em><var>stop_solve</var> =</em> <strong>odeplot</strong> <em>(<var>t</var>, <var>y</var>, <var>flag</var>)</em><a href="#index-odeplot" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Open a new figure window and plot the solution of an ode problem at each time step during the integration. </p> <p>The types and values of the input parameters <var>t</var> and <var>y</var> depend on the input <var>flag</var> that is of type string. Valid values of <var>flag</var> are: </p> <dl compact> <dt><span><samp><code>"init"</code></samp></span></dt> <dd>
<p>The input <var>t</var> must be a column vector of length 2 with the first and last time step (<code>[<var>tfirst</var> <var>tlast</var>]</code>. The input <var>y</var> contains the initial conditions for the ode problem (<var>y0</var>). </p> </dd> <dt><span><samp><code>""</code></samp></span></dt> <dd>
<p>The input <var>t</var> must be a scalar double or vector specifying the time(s) for which the solution in input <var>y</var> was calculated. </p> </dd> <dt><span><samp><code>"done"</code></samp></span></dt> <dd><p>The inputs should be empty, but are ignored if they are present. </p></dd> </dl> <p><code>odeplot</code> always returns false, i.e., don’t stop the ode solver. </p> <p>Example: solve an anonymous implementation of the <code>"Van der Pol"</code> equation and display the results while solving. </p> <pre class="example" data-language="matlab">fvdp = @(t,y) [y(2); (1 - y(1)^2) * y(2) - y(1)];

opt = odeset ("OutputFcn", @odeplot, "RelTol", 1e-6);
sol = ode45 (fvdp, [0 20], [2 0], opt);</pre> <p>Background Information: This function is called by an ode solver function if it was specified in the <code>"OutputFcn"</code> property of an options structure created with <code>odeset</code>. The ode solver will initially call the function with the syntax <code>odeplot ([<var>tfirst</var>, <var>tlast</var>], <var>y0</var>, "init")</code>. The function initializes internal variables, creates a new figure window, and sets the x limits of the plot. Subsequently, at each time step during the integration the ode solver calls <code>odeplot (<var>t</var>, <var>y</var>, [])</code>. At the end of the solution the ode solver calls <code>odeplot ([], [], "done")</code> so that odeplot can perform any clean-up actions required. </p> <p><strong>See also:</strong> <a href="#XREFodeset">odeset</a>, <a href="#XREFodeget">odeget</a>, <a href="#XREFode23">ode23</a>, <a href="#XREFode45">ode45</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Matlab_002dcompatible-solvers.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Matlab_002dcompatible-solvers.html</a>
  </p>
</div>
