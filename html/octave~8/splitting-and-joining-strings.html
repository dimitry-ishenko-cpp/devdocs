<div class="subsection" id="Splitting-and-Joining-Strings">   <h1 class="subsection">5.3.3 Splitting and Joining Strings</h1> <dl class="def"> <dt id="index-substr">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>substr</strong> <em>(<var>s</var>, <var>offset</var>)</em><a href="#index-substr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-substr-1">
<span class="category">: </span><span> <strong>substr</strong> <em>(<var>s</var>, <var>offset</var>, <var>len</var>)</em><a href="#index-substr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the substring of <var>s</var> which starts at character number <var>offset</var> and is <var>len</var> characters long. </p> <p>Position numbering for offsets begins with 1. If <var>offset</var> is negative, extraction starts that far from the end of the string. </p> <p>If <var>len</var> is omitted, the substring extends to the end of <var>s</var>. A negative value for <var>len</var> extracts to within <var>len</var> characters of the end of the string </p> <p>Examples: </p> <pre class="example" data-language="matlab">substr ("This is a test string", 6, 9)
     ⇒ "is a test"
substr ("This is a test string", -11)
     ⇒ "test string"
substr ("This is a test string", -11, -7)
     ⇒ "test"</pre> <p>This function is patterned after the equivalent function in Perl. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strtok">
<span class="category">: </span><span><em>[<var>tok</var>, <var>rem</var>] =</em> <strong>strtok</strong> <em>(<var>str</var>)</em><a href="#index-strtok" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strtok-1">
<span class="category">: </span><span><em>[<var>tok</var>, <var>rem</var>] =</em> <strong>strtok</strong> <em>(<var>str</var>, <var>delim</var>)</em><a href="#index-strtok-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Find all characters in the string <var>str</var> up to, but not including, the first character which is in the string <var>delim</var>. </p> <p><var>str</var> may also be a cell array of strings in which case the function executes on every individual string and returns a cell array of tokens and remainders. </p> <p>Leading delimiters are ignored. If <var>delim</var> is not specified, whitespace is assumed. </p> <p>If <var>rem</var> is requested, it contains the remainder of the string, starting at the first delimiter. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strtok ("this is the life")
     ⇒ "this"

[tok, rem] = strtok ("14*27+31", "+-*/")
     ⇒
        tok = 14
        rem = *27+31</pre> <p><strong>See also:</strong> <a href="searching-in-strings.html#XREFindex">index</a>, <a href="#XREFstrsplit">strsplit</a>, <a href="searching-in-strings.html#XREFstrchr">strchr</a>, <a href="character-class-functions.html#XREFisspace">isspace</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strsplit">
<span class="category">: </span><span><em>[<var>cstr</var>] =</em> <strong>strsplit</strong> <em>(<var>str</var>)</em><a href="#index-strsplit" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strsplit-1">
<span class="category">: </span><span><em>[<var>cstr</var>] =</em> <strong>strsplit</strong> <em>(<var>str</var>, <var>del</var>)</em><a href="#index-strsplit-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strsplit-2">
<span class="category">: </span><span><em>[<var>cstr</var>] =</em> <strong>strsplit</strong> <em>(…, <var>name</var>, <var>value</var>)</em><a href="#index-strsplit-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strsplit-3">
<span class="category">: </span><span><em>[<var>cstr</var>, <var>matches</var>] =</em> <strong>strsplit</strong> <em>(…)</em><a href="#index-strsplit-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Split the string <var>str</var> using the delimiters specified by <var>del</var> and return a cell string array of substrings. </p> <p>If a delimiter is not specified the string is split at whitespace <code>{" ", "\f", "\n", "\r", "\t", "\v"}</code>. Otherwise, the delimiter, <var>del</var> must be a string or cell array of strings. By default, consecutive delimiters in the input string <var>s</var> are collapsed into one resulting in a single split. </p> <p>Supported <var>name</var>/<var>value</var> pair arguments are: </p> <ul> <li> <var>collapsedelimiters</var> which may take the value of <code>true</code> (default) or <code>false</code>. </li>
<li> <var>delimitertype</var> which may take the value of <code>"simple"</code> (default) or <code>"regularexpression"</code>. A simple delimiter matches the text exactly as written. Otherwise, the syntax for regular expressions outlined in <code>regexp</code> is used. </li>
</ul> <p>The optional second output, <var>matches</var>, returns the delimiters which were matched in the original string. </p> <p>Examples with simple delimiters: </p> <pre class="example" data-language="matlab">strsplit ("a b c")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a foo b,bar c", {" ", ",", "foo", "bar"})
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

strsplit ("a,,b, c", {",", " "}, "collapsedelimiters", false)
      ⇒
          {
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
          }</pre> <p>Examples with regularexpression delimiters: </p> <pre class="example" data-language="matlab">strsplit ("a foo b,bar c", ',|\s|foo|bar', ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,,b, c", '[, ]', "collapsedelimiters", false, ...
          "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] = b
            [1,4] =
            [1,5] = c
}

strsplit ("a,\t,b, c", {',', '\s'}, "delimitertype", "regularexpression")
⇒
{
            [1,1] = a
            [1,2] = b
            [1,3] = c
}

strsplit ("a,\t,b, c", {',', ' ', '\t'}, "collapsedelimiters", false)
⇒
{
            [1,1] = a
            [1,2] =
            [1,3] =
            [1,4] = b
            [1,5] =
            [1,6] = c
}</pre> <p><strong>See also:</strong> <a href="#XREFostrsplit">ostrsplit</a>, <a href="#XREFstrjoin">strjoin</a>, <a href="#XREFstrtok">strtok</a>, <a href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-ostrsplit">
<span class="category">: </span><span><em>[<var>cstr</var>] =</em> <strong>ostrsplit</strong> <em>(<var>s</var>, <var>sep</var>)</em><a href="#index-ostrsplit" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-ostrsplit-1">
<span class="category">: </span><span><em>[<var>cstr</var>] =</em> <strong>ostrsplit</strong> <em>(<var>s</var>, <var>sep</var>, <var>strip_empty</var>)</em><a href="#index-ostrsplit-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Split the string <var>s</var> using one or more separators <var>sep</var> and return a cell array of strings. </p> <p>Consecutive separators and separators at boundaries result in empty strings, unless <var>strip_empty</var> is true. The default value of <var>strip_empty</var> is false. </p> <p>2-D character arrays are split at separators and at the original column boundaries. </p> <p>Example: </p> <pre class="example" data-language="matlab">ostrsplit ("a,b,c", ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = c
          }

ostrsplit (["a,b" ; "cde"], ",")
      ⇒
          {
            [1,1] = a
            [1,2] = b
            [1,3] = cde
          }</pre> <p><strong>See also:</strong> <a href="#XREFstrsplit">strsplit</a>, <a href="#XREFstrtok">strtok</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strjoin">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>strjoin</strong> <em>(<var>cstr</var>)</em><a href="#index-strjoin" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strjoin-1">
<span class="category">: </span><span><em><var>str</var> =</em> <strong>strjoin</strong> <em>(<var>cstr</var>, <var>delimiter</var>)</em><a href="#index-strjoin-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Join the elements of the cell string array, <var>cstr</var>, into a single string. </p> <p>If no <var>delimiter</var> is specified, the elements of <var>cstr</var> are separated by a space. </p> <p>If <var>delimiter</var> is specified as a string, the cell string array is joined using the string. Escape sequences are supported. </p> <p>If <var>delimiter</var> is a cell string array whose length is one less than <var>cstr</var>, then the elements of <var>cstr</var> are joined by interleaving the cell string elements of <var>delimiter</var>. Escape sequences are not supported. </p> <pre class="example" data-language="matlab">strjoin ({'Octave','Scilab','Lush','Yorick'}, '*')
      ⇒ 'Octave*Scilab*Lush*Yorick'</pre> <p><strong>See also:</strong> <a href="#XREFstrsplit">strsplit</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Splitting-and-Joining-Strings.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Splitting-and-Joining-Strings.html</a>
  </p>
</div>
