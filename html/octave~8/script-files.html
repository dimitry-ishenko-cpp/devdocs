<div class="section" id="Script-Files">   <h1 class="section">11.11 Script Files</h1> <p>A script file is a file containing (almost) any sequence of Octave commands. It is read and evaluated just as if you had typed each command at the Octave prompt, and provides a convenient way to perform a sequence of commands that do not logically belong inside a function. </p> <p>Unlike a function file, a script file must <em>not</em> begin with the keyword <code>function</code>. If it does, Octave will assume that it is a function file, and that it defines a single function that should be evaluated as soon as it is defined. </p> <p>A script file also differs from a function file in that the variables named in a script file are not local variables, but are in the same scope as the other variables that are visible on the command line. </p> <p>Even though a script file may not begin with the <code>function</code> keyword, it is possible to define more than one function in a single script file and load (but not execute) all of them at once. To do this, the first token in the file (ignoring comments and other white space) must be something other than <code>function</code>. If you have no other statements to evaluate, you can use a statement that has no effect, like this: </p> <pre class="example" data-language="matlab"># Prevent Octave from thinking that this
# is a function file:

1;

# Define function one:

function one ()
  …</pre> <p>To have Octave read and compile these functions into an internal form, you need to make sure that the file is in Octave’s load path (accessible through the <code>path</code> function), then simply type the base name of the file that contains the commands. (Octave uses the same rules to search for script files as it does to search for function files.) </p> <p>If the first token in a file (ignoring comments) is <code>function</code>, Octave will compile the function and try to execute it, printing a message warning about any non-whitespace characters that appear after the function definition. </p> <p>Note that Octave does not try to look up the definition of any identifier until it needs to evaluate it. This means that Octave will compile the following statements if they appear in a script file, or are typed at the command line, </p> <pre class="example" data-language="matlab"># not a function file:
1;
function foo ()
  do_something ();
endfunction
function do_something ()
  do_something_else ();
endfunction</pre> <p>even though the function <code>do_something</code> is not defined before it is referenced in the function <code>foo</code>. This is not an error because Octave does not need to resolve all symbols that are referenced by a function until the function is actually evaluated. </p> <p>Since Octave doesn’t look for definitions until they are needed, the following code will always print ‘<samp>bar = 3</samp>’ whether it is typed directly on the command line, read from a script file, or is part of a function body, even if there is a function or script file called <samp>bar.m</samp> in Octave’s path. </p> <pre class="example" data-language="matlab">eval ("bar = 3");
bar</pre> <p>Code like this appearing within a function body could fool Octave if definitions were resolved as the function was being compiled. It would be virtually impossible to make Octave clever enough to evaluate this code in a consistent fashion. The parser would have to be able to perform the call to <code>eval</code> at compile time, and that would be impossible unless all the references in the string to be evaluated could also be resolved, and requiring that would be too restrictive (the string might come from user input, or depend on things that are not known until the function is evaluated). </p> <p>Although Octave normally executes commands from script files that have the name <samp><var>file</var>.m</samp>, you can use the function <code>source</code> to execute commands from any file. </p> <dl class="def"> <dt id="index-source">
<span class="category">: </span><span> <strong>source</strong> <em>(<var>file</var>)</em><a href="#index-source" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-source-1">
<span class="category">: </span><span> <strong>source</strong> <em>(<var>file</var>, <var>context</var>)</em><a href="#index-source-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Parse and execute the contents of <var>file</var>. </p> <p>Without specifying <var>context</var>, this is equivalent to executing commands from a script file, but without requiring the file to be named <samp><var>file</var>.m</samp> or to be on the execution path. </p> <p>Instead of the current context, the script may be executed in either the context of the function that called the present function (<code>"caller"</code>), or the top-level context (<code>"base"</code>). </p> <p><strong>See also:</strong> <a href="calling-a-function-by-its-name.html#XREFrun">run</a>. </p>
</dd>
</dl> <ul class="section-toc"> <li><a href="publish-octave-script-files.html" accesskey="1">Publish Octave Script Files</a></li> <li><a href="publishing-markup.html" accesskey="2">Publishing Markup</a></li> <li><a href="jupyter-notebooks.html" accesskey="3">Jupyter Notebooks</a></li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Script-Files.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Script-Files.html</a>
  </p>
</div>
