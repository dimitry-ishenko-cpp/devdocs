<div class="subsection" id="Searching-in-Strings">   <h1 class="subsection">5.3.4 Searching in Strings</h1> <p>Since a string is a character array, comparisons between strings work element by element as the following example shows: </p> <pre class="example" data-language="matlab">GNU = "GNU's Not UNIX";
spaces = (GNU == " ")
     ⇒ spaces =
       0   0   0   0   0   1   0   0   0   1   0   0   0   0</pre> <p>To determine if two strings are identical it is necessary to use the <code>strcmp</code> function. It compares complete strings and is case sensitive. <code>strncmp</code> compares only the first <code>N</code> characters (with <code>N</code> given as a parameter). <code>strcmpi</code> and <code>strncmpi</code> are the corresponding functions for case-insensitive comparison. </p> <dl class="def"> <dt id="index-strcmp">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>strcmp</strong> <em>(<var>str1</var>, <var>str2</var>)</em><a href="#index-strcmp" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the character strings <var>str1</var> and <var>str2</var> are the same, and 0 otherwise. </p> <p>If either <var>str1</var> or <var>str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong>Caution:</strong> For compatibility with <small>MATLAB</small>, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong>See also:</strong> <a href="#XREFstrcmpi">strcmpi</a>, <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strncmp">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>strncmp</strong> <em>(<var>str1</var>, <var>str2</var>, <var>n</var>)</em><a href="#index-strncmp" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the first <var>n</var> characters of strings <var>str1</var> and <var>str2</var> are the same, and 0 otherwise. </p> <pre class="example" data-language="matlab">strncmp ("abce", "abcd", 3)
      ⇒ 1</pre> <p>If either <var>str1</var> or <var>str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <pre class="example" data-language="matlab">strncmp ("abce", {"abcd", "bca", "abc"}, 3)
     ⇒ [1, 0, 1]</pre> <p><strong>Caution:</strong> For compatibility with <small>MATLAB</small>, Octave’s strncmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong>See also:</strong> <a href="#XREFstrncmpi">strncmpi</a>, <a href="#XREFstrcmp">strcmp</a>, <a href="#XREFstrcmpi">strcmpi</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strcmpi">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>strcmpi</strong> <em>(<var>str1</var>, <var>str2</var>)</em><a href="#index-strcmpi" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the character strings <var>str1</var> and <var>str2</var> are the same, disregarding case of alphabetic characters, and 0 otherwise. </p> <p>If either <var>str1</var> or <var>str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong>Caution:</strong> For compatibility with <small>MATLAB</small>, Octave’s strcmp function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong>Caution:</strong> National alphabets are not supported. </p> <p><strong>See also:</strong> <a href="#XREFstrcmp">strcmp</a>, <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strncmpi">
<span class="category">: </span><span><em><var>tf</var> =</em> <strong>strncmpi</strong> <em>(<var>str1</var>, <var>str2</var>, <var>n</var>)</em><a href="#index-strncmpi" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return 1 if the first <var>n</var> character of <var>s1</var> and <var>s2</var> are the same, disregarding case of alphabetic characters, and 0 otherwise. </p> <p>If either <var>str1</var> or <var>str2</var> is a cell array of strings, then an array of the same size is returned, containing the values described above for every member of the cell array. The other argument may also be a cell array of strings (of the same size or with only one element), char matrix or character string. </p> <p><strong>Caution:</strong> For compatibility with <small>MATLAB</small>, Octave’s strncmpi function returns 1 if the character strings are equal, and 0 otherwise. This is just the opposite of the corresponding C library function. </p> <p><strong>Caution:</strong> National alphabets are not supported. </p> <p><strong>See also:</strong> <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrcmp">strcmp</a>, <a href="#XREFstrcmpi">strcmpi</a>. </p>
</dd>
</dl> <p>Despite those comparison functions, there are more specialized function to find the index position of a search pattern within a string. </p> <dl class="def"> <dt id="index-startsWith">
<span class="category">: </span><span><em><var>retval</var> =</em> <strong>startsWith</strong> <em>(<var>str</var>, <var>pattern</var>)</em><a href="#index-startsWith" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-startsWith-1">
<span class="category">: </span><span><em><var>retval</var> =</em> <strong>startsWith</strong> <em>(<var>str</var>, <var>pattern</var>, "IgnoreCase", <var>ignore_case</var>)</em><a href="#index-startsWith-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Check whether string(s) start with pattern(s). </p> <p>Return an array of logical values that indicates which string(s) in the input <var>str</var> (a single string or cell array of strings) begin with the input <var>pattern</var> (a single string or cell array of strings). </p> <p>If the value of the parameter <code>"IgnoreCase"</code> is true, then the function will ignore the letter case of <var>str</var> and <var>pattern</var>. By default, the comparison is case sensitive. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## one string and one pattern while considering case
startsWith ("hello", "he")
      ⇒  1


## one string and one pattern while ignoring case
startsWith ("hello", "HE", "IgnoreCase", true)
      ⇒  1


## multiple strings and multiple patterns while considering case
startsWith ({"lab work.pptx", "data.txt", "foundations.ppt"},
            {"lab", "data"})
      ⇒  1  1  0


## multiple strings and one pattern while considering case
startsWith ({"DATASHEET.ods", "data.txt", "foundations.ppt"},
            "data", "IgnoreCase", false)
      ⇒  0  1  0


## multiple strings and one pattern while ignoring case
startsWith ({"DATASHEET.ods", "data.txt", "foundations.ppt"},
            "data", "IgnoreCase", true)
      ⇒  1  1  0</pre> <p><strong>See also:</strong> <a href="#XREFendsWith">endsWith</a>, <a href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-endsWith">
<span class="category">: </span><span><em><var>retval</var> =</em> <strong>endsWith</strong> <em>(<var>str</var>, <var>pattern</var>)</em><a href="#index-endsWith" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-endsWith-1">
<span class="category">: </span><span><em><var>retval</var> =</em> <strong>endsWith</strong> <em>(<var>str</var>, <var>pattern</var>, "IgnoreCase", <var>ignore_case</var>)</em><a href="#index-endsWith-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Check whether string(s) end with pattern(s). </p> <p>Return an array of logical values that indicates which string(s) in the input <var>str</var> (a single string or cell array of strings) end with the input <var>pattern</var> (a single string or cell array of strings). </p> <p>If the value of the parameter <code>"IgnoreCase"</code> is true, then the function will ignore the letter case of <var>str</var> and <var>pattern</var>. By default, the comparison is case sensitive. </p> <p>Examples: </p> <pre class="example" data-language="matlab">## one string and one pattern while considering case
endsWith ("hello", "lo")
      ⇒  1


## one string and one pattern while ignoring case
endsWith ("hello", "LO", "IgnoreCase", true)
      ⇒  1


## multiple strings and multiple patterns while considering case
endsWith ({"tests.txt", "mydoc.odt", "myFunc.m", "results.pptx"},
          {".docx", ".odt", ".txt"})
      ⇒  1  1  0  0


## multiple strings and one pattern while considering case
endsWith ({"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"},
          ".txt", "IgnoreCase", false)
      ⇒  0  0  1  0


## multiple strings and one pattern while ignoring case
endsWith ({"TESTS.TXT", "mydoc.odt", "result.txt", "myFunc.m"},
          ".txt", "IgnoreCase", true)
      ⇒  1  0  1  0</pre> <p><strong>See also:</strong> <a href="#XREFstartsWith">startsWith</a>, <a href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrncmpi">strncmpi</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-findstr">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>findstr</strong> <em>(<var>s</var>, <var>t</var>)</em><a href="#index-findstr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-findstr-1">
<span class="category">: </span><span><em><var>v</var> =</em> <strong>findstr</strong> <em>(<var>s</var>, <var>t</var>, <var>overlap</var>)</em><a href="#index-findstr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>This function is obsolete. Use <code>strfind</code> instead. </p> <p>Return the vector of all positions in the longer of the two strings <var>s</var> and <var>t</var> where an occurrence of the shorter of the two starts. </p> <p>If the optional argument <var>overlap</var> is true (default), the returned vector can include overlapping positions. For example: </p> <pre class="example" data-language="matlab">findstr ("ababab", "a")
     ⇒ [1, 3, 5];
findstr ("abababa", "aba", 0)
     ⇒ [1, 5]</pre> <p><strong>Caution:</strong> <code>findstr</code> is obsolete. Use <code>strfind</code> in all new code. </p> <p><strong>See also:</strong> <a href="#XREFstrfind">strfind</a>, <a href="#XREFstrmatch">strmatch</a>, <a href="#XREFstrcmp">strcmp</a>, <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrcmpi">strcmpi</a>, <a href="#XREFstrncmpi">strncmpi</a>, <a href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strchr">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strchr</strong> <em>(<var>str</var>, <var>chars</var>)</em><a href="#index-strchr" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strchr-1">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strchr</strong> <em>(<var>str</var>, <var>chars</var>, <var>n</var>)</em><a href="#index-strchr-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strchr-2">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strchr</strong> <em>(<var>str</var>, <var>chars</var>, <var>n</var>, <var>direction</var>)</em><a href="#index-strchr-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strchr-3">
<span class="category">: </span><span><em>[<var>i</var>, <var>j</var>] =</em> <strong>strchr</strong> <em>(…)</em><a href="#index-strchr-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Search through the string <var>str</var> for occurrences of characters from the set <var>chars</var>. </p> <p>The return value(s), as well as the <var>n</var> and <var>direction</var> arguments behave identically as in <code>find</code>. </p> <p>This will be faster than using <code>regexp</code> in most cases. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-index">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>index</strong> <em>(<var>s</var>, <var>t</var>)</em><a href="#index-index" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-index-1">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>index</strong> <em>(<var>s</var>, <var>t</var>, <var>direction</var>)</em><a href="#index-index-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the position of the first occurrence of the string <var>t</var> in the string <var>s</var>, or 0 if no occurrence is found. </p> <p><var>s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">index ("Teststring", "t")
    ⇒ 4</pre> <p>If <var>direction</var> is <code>"first"</code>, return the first element found. If <var>direction</var> is <code>"last"</code>, return the last element found. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions.html#XREFfind">find</a>, <a href="#XREFrindex">rindex</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rindex">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>rindex</strong> <em>(<var>s</var>, <var>t</var>)</em><a href="#index-rindex" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the position of the last occurrence of the character string <var>t</var> in the character string <var>s</var>, or 0 if no occurrence is found. </p> <p><var>s</var> may also be a string array or cell array of strings. </p> <p>For example: </p> <pre class="example" data-language="matlab">rindex ("Teststring", "t")
     ⇒ 6</pre> <p>The <code>rindex</code> function is equivalent to <code>index</code> with <var>direction</var> set to <code>"last"</code>. </p> <p><strong>See also:</strong> <a href="finding-elements-and-checking-conditions.html#XREFfind">find</a>, <a href="#XREFindex">index</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-unicode_005fidx">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>unicode_idx</strong> <em>(<var>str</var>)</em><a href="#index-unicode_005fidx" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return an array with the indices for each UTF-8 encoded character in <var>str</var>. </p> <pre class="example" data-language="matlab">unicode_idx ("aäbc")
     ⇒ [1, 2, 2, 3, 4]</pre> </dd>
</dl> <dl class="def"> <dt id="index-strfind">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strfind</strong> <em>(<var>str</var>, <var>pattern</var>)</em><a href="#index-strfind" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strfind-1">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strfind</strong> <em>(<var>cellstr</var>, <var>pattern</var>)</em><a href="#index-strfind-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strfind-2">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strfind</strong> <em>(…, "overlaps", <var>val</var>)</em><a href="#index-strfind-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strfind-3">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strfind</strong> <em>(…, "forcecelloutput", <var>val</var>)</em><a href="#index-strfind-3" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Search for <var>pattern</var> in the string <var>str</var> and return the starting index of every such occurrence in the vector <var>idx</var>. </p> <p>If there is no such occurrence, or if <var>pattern</var> is longer than <var>str</var>, or if <var>pattern</var> itself is empty, then <var>idx</var> is the empty array <code>[]</code>. </p> <p>The optional argument <code>"overlaps"</code> determines whether the pattern can match at every position in <var>str</var> (true), or only for unique occurrences of the complete pattern (false). The default is true. </p> <p>If a cell array of strings <var>cellstr</var> is specified then <var>idx</var> is a cell array of vectors, as specified above. </p> <p>The optional argument <code>"forcecelloutput"</code> forces <var>idx</var> to be returned as a cell array of vectors. The default is false. </p> <p>Examples: </p> <pre class="example" data-language="matlab">strfind ("abababa", "aba")
     ⇒ [1, 3, 5]


strfind ("abababa", "aba", "overlaps", false)
     ⇒ [1, 5]


strfind ({"abababa", "bebebe", "ab"}, "aba")
     ⇒
        {
          [1,1] =

             1   3   5

          [1,2] = [](1x0)
          [1,3] = [](1x0)
        }


strfind ("abababa", "aba", "forcecelloutput", true)
     ⇒
        {
          [1,1] =

             1   3   5
        }</pre> <p><strong>See also:</strong> <a href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a href="searching-and-replacing-in-strings.html#XREFregexpi">regexpi</a>, <a href="finding-elements-and-checking-conditions.html#XREFfind">find</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-strmatch">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strmatch</strong> <em>(<var>s</var>, <var>A</var>)</em><a href="#index-strmatch" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-strmatch-1">
<span class="category">: </span><span><em><var>idx</var> =</em> <strong>strmatch</strong> <em>(<var>s</var>, <var>A</var>, "exact")</em><a href="#index-strmatch-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>This function is obsolete. <strong>Use an alternative</strong> such as <code>strncmp</code> or <code>strcmp</code> instead. </p> <p>Return indices of entries of <var>A</var> which begin with the string <var>s</var>. </p> <p>The second argument <var>A</var> must be a string, character matrix, or a cell array of strings. </p> <p>If the third argument <code>"exact"</code> is not given, then <var>s</var> only needs to match <var>A</var> up to the length of <var>s</var>. Trailing spaces and nulls in <var>s</var> and <var>A</var> are ignored when matching. </p> <p>For example: </p> <pre class="example" data-language="matlab">strmatch ("apple", "apple juice")
     ⇒ 1

strmatch ("apple", ["apple  "; "apple juice"; "an apple"])
     ⇒ [1; 2]

strmatch ("apple", ["apple  "; "apple juice"; "an apple"], "exact")
     ⇒ [1]</pre> <p><strong>Caution:</strong> <code>strmatch</code> is obsolete (and can produce incorrect results in <small>MATLAB</small> when used with cell arrays of strings. Use <code>strncmp</code> (normal case) or <code>strcmp</code> (<code>"exact"</code> case) in all new code. Other replacement possibilities, depending on application, include <code>regexp</code> or <code>validatestring</code>. </p> <p><strong>See also:</strong> <a href="#XREFstrncmp">strncmp</a>, <a href="#XREFstrcmp">strcmp</a>, <a href="searching-and-replacing-in-strings.html#XREFregexp">regexp</a>, <a href="#XREFstrfind">strfind</a>, <a href="validating-the-type-of-arguments.html#XREFvalidatestring">validatestring</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Searching-in-Strings.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Searching-in-Strings.html</a>
  </p>
</div>
