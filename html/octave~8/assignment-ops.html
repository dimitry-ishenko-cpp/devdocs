<div class="section" id="Assignment-Ops">   <h1 class="section">8.6 Assignment Expressions</h1>      <p>An <em>assignment</em> is an expression that stores a new value into a variable. For example, the following expression assigns the value 1 to the variable <code>z</code>: </p> <pre class="example" data-language="matlab">z = 1</pre> <p>After this expression is executed, the variable <code>z</code> has the value 1. Whatever old value <code>z</code> had before the assignment is forgotten. The ‘<samp>=</samp>’ sign is called an <em>assignment operator</em>. </p> <p>Assignments can store string values also. For example, the following expression would store the value <code>"this food is good"</code> in the variable <code>message</code>: </p> <pre class="example" data-language="matlab">thing = "food"
predicate = "good"
message = [ "this " , thing , " is " , predicate ]</pre> <p>(This also illustrates concatenation of strings.) </p>  <p>Most operators (addition, concatenation, and so on) have no effect except to compute a value. If you ignore the value, you might as well not use the operator. An assignment operator is different. It does produce a value, but even if you ignore the value, the assignment still makes itself felt through the alteration of the variable. We call this a <em>side effect</em>. </p>  <p>The left-hand operand of an assignment need not be a variable (see <a href="variables.html">Variables</a>). It can also be an element of a matrix (see <a href="index-expressions.html">Index Expressions</a>) or a list of return values (see <a href="calling-functions.html">Calling Functions</a>). These are all called <em>lvalues</em>, which means they can appear on the left-hand side of an assignment operator. The right-hand operand may be any expression. It produces the new value which the assignment stores in the specified variable, matrix element, or list of return values. </p> <p>It is important to note that variables do <em>not</em> have permanent types. The type of a variable is simply the type of whatever value it happens to hold at the moment. In the following program fragment, the variable <code>foo</code> has a numeric value at first, and a string value later on: </p> <pre class="example" data-language="matlab">octave:13&gt; foo = 1
foo = 1
octave:13&gt; foo = "bar"
foo = bar</pre> <p>When the second assignment gives <code>foo</code> a string value, the fact that it previously had a numeric value is forgotten. </p> <p>Assignment of a scalar to an indexed matrix sets all of the elements that are referenced by the indices to the scalar value. For example, if <code>a</code> is a matrix with at least two columns, </p> <pre class="example" data-language="matlab">a(:, 2) = 5</pre> <p>sets all the elements in the second column of <code>a</code> to 5. </p> <p>Assigning an empty matrix ‘<samp>[]</samp>’ works in most cases to allow you to delete rows or columns of matrices and vectors. See <a href="empty-matrices.html">Empty Matrices</a>. For example, given a 4 by 5 matrix <var>A</var>, the assignment </p> <pre class="example" data-language="matlab">A (3, :) = []</pre> <p>deletes the third row of <var>A</var>, and the assignment </p> <pre class="example" data-language="matlab">A (:, 1:2:5) = []</pre> <p>deletes the first, third, and fifth columns. </p> <p>An assignment is an expression, so it has a value. Thus, <code>z = 1</code> as an expression has the value 1. One consequence of this is that you can write multiple assignments together: </p> <pre class="example" data-language="matlab">x = y = z = 0</pre> <p>stores the value 0 in all three variables. It does this because the value of <code>z = 0</code>, which is 0, is stored into <code>y</code>, and then the value of <code>y = z = 0</code>, which is 0, is stored into <code>x</code>. </p> <p>This is also true of assignments to lists of values, so the following is a valid expression </p> <pre class="example" data-language="matlab">[a, b, c] = [u, s, v] = svd (a)</pre> <p>that is exactly equivalent to </p> <pre class="example" data-language="matlab">[u, s, v] = svd (a)
a = u
b = s
c = v</pre> <p>In expressions like this, the number of values in each part of the expression need not match. For example, the expression </p> <pre class="example" data-language="matlab">[a, b] = [u, s, v] = svd (a)</pre> <p>is equivalent to </p> <pre class="example" data-language="matlab">[u, s, v] = svd (a)
a = u
b = s</pre> <p>The number of values on the left side of the expression can, however, not exceed the number of values on the right side. For example, the following will produce an error. </p> <pre class="example" data-language="matlab">[a, b, c, d] = [u, s, v] = svd (a);
-| error: element number 4 undefined in return list</pre> <p>The symbol <code>~</code> may be used as a placeholder in the list of lvalues, indicating that the corresponding return value should be ignored and not stored anywhere: </p> <pre class="example" data-language="matlab">[~, s, v] = svd (a);</pre> <p>This is cleaner and more memory efficient than using a dummy variable. The <code>nargout</code> value for the right-hand side expression is not affected. If the assignment is used as an expression, the return value is a comma-separated list with the ignored values dropped. </p>  <p>A very common programming pattern is to increment an existing variable with a given value, like this </p> <pre class="example" data-language="matlab">a = a + 2;</pre> <p>This can be written in a clearer and more condensed form using the <code>+=</code> operator </p> <pre class="example" data-language="matlab">a += 2;</pre> <p>   Similar operators also exist for subtraction (<code>-=</code>), multiplication (<code>*=</code>), and division (<code>/=</code>). An expression of the form </p> <pre class="example" data-language="matlab">expr1 op= expr2</pre> <p>is evaluated as </p> <pre class="example" data-language="matlab">expr1 = (expr1) op (expr2)</pre> <p>where <var>op</var> can be either <code>+</code>, <code>-</code>, <code>*</code>, or <code>/</code>, as long as <var>expr2</var> is a simple expression with no side effects. If <var>expr2</var> also contains an assignment operator, then this expression is evaluated as </p> <pre class="example" data-language="matlab">temp = expr2
expr1 = (expr1) op temp</pre> <p>where <var>temp</var> is a placeholder temporary value storing the computed result of evaluating <var>expr2</var>. So, the expression </p> <pre class="example" data-language="matlab">a *= b+1</pre> <p>is evaluated as </p> <pre class="example" data-language="matlab">a = a * (b+1)</pre> <p>and <em>not</em> </p> <pre class="example" data-language="matlab">a = a * b + 1</pre> <p>You can use an assignment anywhere an expression is called for. For example, it is valid to write <code>x != (y = 1)</code> to set <code>y</code> to 1 and then test whether <code>x</code> equals 1. But this style tends to make programs hard to read. Except in a one-shot program, you should rewrite it to get rid of such nesting of assignments. This is never very hard. </p>     </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Assignment-Ops.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Assignment-Ops.html</a>
  </p>
</div>
