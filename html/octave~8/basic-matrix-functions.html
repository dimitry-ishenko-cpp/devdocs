<div class="section" id="Basic-Matrix-Functions">   <h1 class="section">18.2 Basic Matrix Functions</h1>  <dl class="def"> <dt id="index-balance">
<span class="category">: </span><span><em><var>AA</var> =</em> <strong>balance</strong> <em>(<var>A</var>)</em><a href="#index-balance" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-balance-1">
<span class="category">: </span><span><em><var>AA</var> =</em> <strong>balance</strong> <em>(<var>A</var>, <var>opt</var>)</em><a href="#index-balance-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-balance-2">
<span class="category">: </span><span><em>[<var>DD</var>, <var>AA</var>] =</em> <strong>balance</strong> <em>(<var>A</var>, <var>opt</var>)</em><a href="#index-balance-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-balance-3">
<span class="category">: </span><span><em>[<var>D</var>, <var>P</var>, <var>AA</var>] =</em> <strong>balance</strong> <em>(<var>A</var>, <var>opt</var>)</em><a href="#index-balance-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-balance-4">
<span class="category">: </span><span><em>[<var>CC</var>, <var>DD</var>, <var>AA</var>, <var>BB</var>] =</em> <strong>balance</strong> <em>(<var>A</var>, <var>B</var>, <var>opt</var>)</em><a href="#index-balance-4" class="copiable-anchor"> ¶</a></span>
</dt> <dd> <p>Balance the matrix <var>A</var> to reduce numerical errors in future calculations. </p> <p>Compute <code><var>AA</var> = <var>DD</var> \ <var>A</var> * <var>DD</var></code> in which <var>AA</var> is a matrix whose row and column norms are roughly equal in magnitude, and <code><var>DD</var> = <var>P</var> * <var>D</var></code>, in which <var>P</var> is a permutation matrix and <var>D</var> is a diagonal matrix of powers of two. This allows the equilibration to be computed without round-off. Results of eigenvalue calculation are typically improved by balancing first. </p> <p>If two output values are requested, <code>balance</code> returns the diagonal <var>D</var> and the permutation <var>P</var> separately as vectors. In this case, <code><var>DD</var> = eye(n)(:,<var>P</var>) * diag (<var>D</var>)</code>, where <em class="math">n</em> is the matrix size. </p> <p>If four output values are requested, compute <code><var>AA</var> =
<var>CC</var>*<var>A</var>*<var>DD</var></code> and <code><var>BB</var> = <var>CC</var>*<var>B</var>*<var>DD</var></code>, in which <var>AA</var> and <var>BB</var> have nonzero elements of approximately the same magnitude and <var>CC</var> and <var>DD</var> are permuted diagonal matrices as in <var>DD</var> for the algebraic eigenvalue problem. </p> <p>The eigenvalue balancing option <var>opt</var> may be one of: </p> <dl compact> <dt><span><code>"noperm"</code>, <code>"S"</code></span></dt> <dd>
<p>Scale only; do not permute. </p> </dd> <dt><span><code>"noscal"</code>, <code>"P"</code></span></dt> <dd><p>Permute only; do not scale. </p></dd> </dl> <p>Algebraic eigenvalue balancing uses standard <small>LAPACK</small> routines. </p> <p>Generalized eigenvalue problem balancing uses Ward’s algorithm (SIAM Journal on Scientific and Statistical Computing, 1981). </p>
</dd>
</dl> <dl class="def"> <dt id="index-bandwidth">
<span class="category">: </span><span><em><var>bw</var> =</em> <strong>bandwidth</strong> <em>(<var>A</var>, <var>type</var>)</em><a href="#index-bandwidth" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-bandwidth-1">
<span class="category">: </span><span><em>[<var>lower</var>, <var>upper</var>] =</em> <strong>bandwidth</strong> <em>(<var>A</var>)</em><a href="#index-bandwidth-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the bandwidth of <var>A</var>. </p> <p>The <var>type</var> argument is the string <code>"lower"</code> for the lower bandwidth and <code>"upper"</code> for the upper bandwidth. If no <var>type</var> is specified return both the lower and upper bandwidth of <var>A</var>. </p> <p>The lower/upper bandwidth of a matrix is the number of subdiagonals/superdiagonals with nonzero entries. </p> <p><strong>See also:</strong> <a href="predicates-for-numeric-objects.html#XREFisbanded">isbanded</a>, <a href="predicates-for-numeric-objects.html#XREFisdiag">isdiag</a>, <a href="predicates-for-numeric-objects.html#XREFistril">istril</a>, <a href="predicates-for-numeric-objects.html#XREFistriu">istriu</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-cond">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>cond</strong> <em>(<var>A</var>)</em><a href="#index-cond" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-cond-1">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>cond</strong> <em>(<var>A</var>, <var>p</var>)</em><a href="#index-cond-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the <var>p</var>-norm condition number of a matrix with respect to inversion. </p> <p><code>cond (<var>A</var>)</code> is defined as <code>norm (<var>A</var>, <var>p</var>) * norm (inv (<var>A</var>), <var>p</var>)</code>. </p> <p>By default, <code><var>p</var> = 2</code> is used which implies a (relatively slow) singular value decomposition. Other possible selections are <code><var>p</var> = 1, Inf, "fro"</code> which are generally faster. For a full discussion of possible <var>p</var> values, see <a href="#XREFnorm"><code>norm</code></a>. </p> <p>The condition number of a matrix quantifies the sensitivity of the matrix inversion operation when small changes are made to matrix elements. Ideally the condition number will be close to 1. When the number is large this indicates small changes (such as underflow or round-off error) will produce large changes in the resulting output. In such cases the solution results from numerical computing are not likely to be accurate. </p> <p><strong>See also:</strong> <a href="sparse-linear-algebra.html#XREFcondest">condest</a>, <a href="#XREFrcond">rcond</a>, <a href="#XREFcondeig">condeig</a>, <a href="#XREFnorm">norm</a>, <a href="matrix-factorizations.html#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-condeig">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>condeig</strong> <em>(<var>a</var>)</em><a href="#index-condeig" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-condeig-1">
<span class="category">: </span><span><em>[<var>v</var>, <var>lambda</var>, <var>c</var>] =</em> <strong>condeig</strong> <em>(<var>a</var>)</em><a href="#index-condeig-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute condition numbers of a matrix with respect to eigenvalues. </p> <p>The condition numbers are the reciprocals of the cosines of the angles between the left and right eigenvectors; Large values indicate that the matrix has multiple distinct eigenvalues. </p> <p>The input <var>a</var> must be a square numeric matrix. </p> <p>The outputs are: </p> <ul> <li> <var>c</var> is a vector of condition numbers for the eigenvalues of <var>a</var>. </li>
<li> <var>v</var> is the matrix of right eigenvectors of <var>a</var>. The result is equivalent to calling <code>[<var>v</var>, <var>lambda</var>] = eig (<var>a</var>)</code>. </li>
<li> <var>lambda</var> is the diagonal matrix of eigenvalues of <var>a</var>. The result is equivalent to calling <code>[<var>v</var>, <var>lambda</var>] = eig (<var>a</var>)</code>. </li>
</ul> <p>Example </p> <pre class="example" data-language="matlab">a = [1, 2; 3, 4];
c = condeig (a)
  ⇒ c =
       1.0150
       1.0150</pre> <p><strong>See also:</strong> <a href="#XREFeig">eig</a>, <a href="#XREFcond">cond</a>, <a href="#XREFbalance">balance</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-det">
<span class="category">: </span><span><em><var>d</var> =</em> <strong>det</strong> <em>(<var>A</var>)</em><a href="#index-det" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-det-1">
<span class="category">: </span><span><em>[<var>d</var>, <var>rcond</var>] =</em> <strong>det</strong> <em>(<var>A</var>)</em><a href="#index-det-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the determinant of <var>A</var>. </p> <p>Return an estimate of the reciprocal condition number if requested. </p> <p>Programming Notes: Routines from <small>LAPACK</small> are used for full matrices and code from <small>UMFPACK</small> is used for sparse matrices. </p> <p>The determinant should not be used to check a matrix for singularity. For that, use any of the condition number functions: <code>cond</code>, <code>condest</code>, <code>rcond</code>. </p> <p><strong>See also:</strong> <a href="#XREFcond">cond</a>, <a href="sparse-linear-algebra.html#XREFcondest">condest</a>, <a href="#XREFrcond">rcond</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-eig">
<span class="category">: </span><span><em><var>lambda</var> =</em> <strong>eig</strong> <em>(<var>A</var>)</em><a href="#index-eig" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-1">
<span class="category">: </span><span><em><var>lambda</var> =</em> <strong>eig</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-eig-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-2">
<span class="category">: </span><span><em>[<var>V</var>, <var>lambda</var>] =</em> <strong>eig</strong> <em>(<var>A</var>)</em><a href="#index-eig-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-3">
<span class="category">: </span><span><em>[<var>V</var>, <var>lambda</var>] =</em> <strong>eig</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-eig-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-4">
<span class="category">: </span><span><em>[<var>V</var>, <var>lambda</var>, <var>W</var>] =</em> <strong>eig</strong> <em>(<var>A</var>)</em><a href="#index-eig-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-5">
<span class="category">: </span><span><em>[<var>V</var>, <var>lambda</var>, <var>W</var>] =</em> <strong>eig</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-eig-5" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-6">
<span class="category">: </span><span><em>[…] =</em> <strong>eig</strong> <em>(<var>A</var>, <var>balanceOption</var>)</em><a href="#index-eig-6" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-7">
<span class="category">: </span><span><em>[…] =</em> <strong>eig</strong> <em>(<var>A</var>, <var>B</var>, <var>algorithm</var>)</em><a href="#index-eig-7" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-eig-8">
<span class="category">: </span><span><em>[…] =</em> <strong>eig</strong> <em>(…, <var>eigvalOption</var>)</em><a href="#index-eig-8" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the eigenvalues (<var>lambda</var>) and optionally the right eigenvectors (<var>V</var>) and the left eigenvectors (<var>W</var>) of a matrix or pair of matrices. </p> <p>The flag <var>balanceOption</var> can be one of: </p> <dl compact> <dt><span><code>"balance"</code> (default)</span></dt> <dd>
<p>Preliminary balancing is on. </p> </dd> <dt><span><code>"nobalance"</code></span></dt> <dd><p>Disables preliminary balancing. </p></dd> </dl> <p>The flag <var>eigvalOption</var> can be one of: </p> <dl compact> <dt><span><code>"matrix"</code></span></dt> <dd>
<p>Return the eigenvalues in a diagonal matrix. (default if 2 or 3 outputs are requested) </p> </dd> <dt><span><code>"vector"</code></span></dt> <dd><p>Return the eigenvalues in a column vector. (default if only 1 output is requested, e.g., <var>lambda</var> = eig (<var>A</var>)) </p></dd> </dl> <p>The flag <var>algorithm</var> can be one of: </p> <dl compact> <dt><span><code>"chol"</code></span></dt> <dd>
<p>Use the Cholesky factorization of B. (default if <var>A</var> is symmetric (Hermitian) and <var>B</var> is symmetric (Hermitian) positive definite) </p> </dd> <dt><span><code>"qz"</code></span></dt> <dd><p>Use the QZ algorithm. (used whenever <var>A</var> or <var>B</var> are not symmetric) </p></dd> </dl> <table> <thead><tr>
<th width="31%"></th>
<th width="23%">no flag</th>
<th width="23%">chol</th>
<th width="23%">qz</th>
</tr></thead> <tr>
<td width="31%">both are symmetric</td>
<td width="23%"><code>"chol"</code></td>
<td width="23%"><code>"chol"</code></td>
<td width="23%"><code>"qz"</code></td>
</tr> <tr>
<td width="31%">at least one is not symmetric</td>
<td width="23%"><code>"qz"</code></td>
<td width="23%"><code>"qz"</code></td>
<td width="23%"><code>"qz"</code></td>
</tr> </table> <p>The eigenvalues returned by <code>eig</code> are not ordered. </p> <p><strong>See also:</strong> <a href="sparse-linear-algebra.html#XREFeigs">eigs</a>, <a href="matrix-factorizations.html#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-givens">
<span class="category">: </span><span><em><var>G</var> =</em> <strong>givens</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-givens" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-givens-1">
<span class="category">: </span><span><em>[<var>c</var>, <var>s</var>] =</em> <strong>givens</strong> <em>(<var>x</var>, <var>y</var>)</em><a href="#index-givens-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Givens rotation matrix <var>G</var>. </p> <p>The Givens matrix is a 2-by-2 orthogonal matrix </p> <pre class="example" data-language="matlab">G = [ c , s
     -s', c]</pre> <p>such that </p> <pre class="example" data-language="matlab">G * [x; y] = [*; 0]</pre> <p>with <var>x</var> and <var>y</var> scalars. </p> <p>If two output arguments are requested, return the factors <var>c</var> and <var>s</var> rather than the Givens rotation matrix. </p> <p>For example: </p> <pre class="example" data-language="matlab">givens (1, 1)
   ⇒   0.70711   0.70711
       -0.70711   0.70711</pre> <p>Note: The Givens matrix represents a counterclockwise rotation of a 2-D plane and can be used to introduce zeros into a matrix prior to complete factorization. </p> <p><strong>See also:</strong> <a href="#XREFplanerot">planerot</a>, <a href="matrix-factorizations.html#XREFqr">qr</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-gsvd">
<span class="category">: </span><span><em><var>S</var> =</em> <strong>gsvd</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-gsvd" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gsvd-1">
<span class="category">: </span><span><em>[<var>U</var>, <var>V</var>, <var>X</var>, <var>C</var>, <var>S</var>] =</em> <strong>gsvd</strong> <em>(<var>A</var>, <var>B</var>)</em><a href="#index-gsvd-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-gsvd-2">
<span class="category">: </span><span><em>[<var>U</var>, <var>V</var>, <var>X</var>, <var>C</var>, <var>S</var>] =</em> <strong>gsvd</strong> <em>(<var>A</var>, <var>B</var>, 0)</em><a href="#index-gsvd-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the generalized singular value decomposition of (<var>A</var>, <var>B</var>). </p> <p>The generalized singular value decomposition is defined by the following relations: </p> <pre class="example" data-language="matlab">A = U*C*X'
B = V*S*X'
C'*C + S'*S = eye (columns (A))</pre> <p>The function <code>gsvd</code> normally returns just the vector of generalized singular values <code>sqrt (diag (C'*C) ./ diag (S'*S))</code>. If asked for five return values, it also computes U, V, X, and C. </p> <p>If the optional third input is present, <code>gsvd</code> constructs the "economy-sized" decomposition where the number of columns of <var>U</var>, <var>V</var> and the number of rows of <var>C</var>, <var>S</var> is less than or equal to the number of columns of <var>A</var>. This option is not yet implemented. </p> <p>Programming Note: the code is a wrapper to the corresponding <small>LAPACK</small> dggsvd and zggsvd routines. If matrices <var>A</var> and <var>B</var> are <em>both</em> rank deficient then <small>LAPACK</small> will return an incorrect factorization. Programmers should avoid this combination. </p> <p><strong>See also:</strong> <a href="matrix-factorizations.html#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-planerot">
<span class="category">: </span><span><em>[<var>G</var>, <var>y</var>] =</em> <strong>planerot</strong> <em>(<var>x</var>)</em><a href="#index-planerot" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the Givens rotation matrix for the two-element column vector <var>x</var>. </p> <p>The Givens matrix is a 2-by-2 orthogonal matrix </p> <pre class="example" data-language="matlab">G = [ c , s
     -s', c]</pre> <p>such that </p> <pre class="example" data-language="matlab">y = G * [x(1); x(2)] ≡ [*; 0]</pre> <p>Note: The Givens matrix represents a counterclockwise rotation of a 2-D plane and can be used to introduce zeros into a matrix prior to complete factorization. </p> <p><strong>See also:</strong> <a href="#XREFgivens">givens</a>, <a href="matrix-factorizations.html#XREFqr">qr</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-inv">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>inv</strong> <em>(<var>A</var>)</em><a href="#index-inv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-inv-1">
<span class="category">: </span><span><em>[<var>x</var>, <var>rcond</var>] =</em> <strong>inv</strong> <em>(<var>A</var>)</em><a href="#index-inv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-inverse">
<span class="category">: </span><span><em>[…] =</em> <strong>inverse</strong> <em>(…)</em><a href="#index-inverse" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the inverse of the square matrix <var>A</var>. </p> <p>Return an estimate of the reciprocal condition number if requested, otherwise warn of an ill-conditioned matrix if the reciprocal condition number is small. </p> <p>In general it is best to avoid calculating the inverse of a matrix directly. For example, it is both faster and more accurate to solve systems of equations (<var>A</var>*<em class="math">x</em> = <em class="math">b</em>) with <code><var>y</var> = <var>A</var> \ <em class="math">b</em></code>, rather than <code><var>y</var> = inv (<var>A</var>) * <em class="math">b</em></code>. </p> <p>If called with a sparse matrix, then in general <var>x</var> will be a full matrix requiring significantly more storage. Avoid forming the inverse of a sparse matrix if possible. </p> <p><code>inverse</code> is an alias and may be used identically in place of <code>inv</code>. </p> <p><strong>See also:</strong> <a href="arithmetic-ops.html#XREFldivide">ldivide</a>, <a href="arithmetic-ops.html#XREFrdivide">rdivide</a>, <a href="#XREFpinv">pinv</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-linsolve">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>linsolve</strong> <em>(<var>A</var>, <var>b</var>)</em><a href="#index-linsolve" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-linsolve-1">
<span class="category">: </span><span><em><var>x</var> =</em> <strong>linsolve</strong> <em>(<var>A</var>, <var>b</var>, <var>opts</var>)</em><a href="#index-linsolve-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-linsolve-2">
<span class="category">: </span><span><em>[<var>x</var>, <var>R</var>] =</em> <strong>linsolve</strong> <em>(…)</em><a href="#index-linsolve-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Solve the linear system <code>A*x = b</code>. </p> <p>With no options, this function is equivalent to the left division operator (<code>x = A \ b</code>) or the matrix-left-divide function (<code>x = mldivide (A, b)</code>). </p> <p>Octave ordinarily examines the properties of the matrix <var>A</var> and chooses a solver that best matches the matrix. By passing a structure <var>opts</var> to <code>linsolve</code> you can inform Octave directly about the matrix <var>A</var>. In this case Octave will skip the matrix examination and proceed directly to solving the linear system. </p> <p><strong>Warning:</strong> If the matrix <var>A</var> does not have the properties listed in the <var>opts</var> structure then the result will not be accurate AND no warning will be given. When in doubt, let Octave examine the matrix and choose the appropriate solver as this step takes little time and the result is cached so that it is only done once per linear system. </p> <p>Possible <var>opts</var> fields (set value to true/false): </p> <dl compact> <dt><span>LT</span></dt> <dd>
<p><var>A</var> is lower triangular </p> </dd> <dt><span>UT</span></dt> <dd>
<p><var>A</var> is upper triangular </p> </dd> <dt><span>UHESS</span></dt> <dd>
<p><var>A</var> is upper Hessenberg (currently makes no difference) </p> </dd> <dt><span>SYM</span></dt> <dd>
<p><var>A</var> is symmetric or complex Hermitian (currently makes no difference) </p> </dd> <dt><span>POSDEF</span></dt> <dd>
<p><var>A</var> is positive definite </p> </dd> <dt><span>RECT</span></dt> <dd>
<p><var>A</var> is general rectangular (currently makes no difference) </p> </dd> <dt><span>TRANSA</span></dt> <dd><p>Solve <code>A'*x = b</code> if true rather than <code>A*x = b</code> </p></dd> </dl> <p>The optional second output <var>R</var> is the inverse condition number of <var>A</var> (zero if matrix is singular). </p> <p><strong>See also:</strong> <a href="arithmetic-ops.html#XREFmldivide">mldivide</a>, <a href="#XREFmatrix_005ftype">matrix_type</a>, <a href="#XREFrcond">rcond</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-matrix_005ftype">
<span class="category">: </span><span><em><var>type</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>)</em><a href="#index-matrix_005ftype" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-matrix_005ftype-1">
<span class="category">: </span><span><em><var>type</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>, "nocompute")</em><a href="#index-matrix_005ftype-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-matrix_005ftype-2">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>, <var>type</var>)</em><a href="#index-matrix_005ftype-2" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-matrix_005ftype-3">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>, "upper", <var>perm</var>)</em><a href="#index-matrix_005ftype-3" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-matrix_005ftype-4">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>, "lower", <var>perm</var>)</em><a href="#index-matrix_005ftype-4" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-matrix_005ftype-5">
<span class="category">: </span><span><em><var>A</var> =</em> <strong>matrix_type</strong> <em>(<var>A</var>, "banded", <var>nl</var>, <var>nu</var>)</em><a href="#index-matrix_005ftype-5" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Identify the matrix type or mark a matrix as a particular type. </p> <p>This allows more rapid solutions of linear equations involving <var>A</var> to be performed. </p> <p>Called with a single argument, <code>matrix_type</code> returns the type of the matrix and caches it for future use. </p> <p>Called with more than one argument, <code>matrix_type</code> allows the type of the matrix to be defined. </p> <p>If the option <code>"nocompute"</code> is given, the function will not attempt to guess the type if it is still unknown. This is useful for debugging purposes. </p> <p>The possible matrix types depend on whether the matrix is full or sparse, and can be one of the following </p> <dl compact> <dt><span><code>"unknown"</code></span></dt> <dd>
<p>Remove any previously cached matrix type, and mark type as unknown. </p> </dd> <dt><span><code>"full"</code></span></dt> <dd>
<p>Mark the matrix as full. </p> </dd> <dt><span><code>"positive definite"</code></span></dt> <dd>
<p>Probable full positive definite matrix. </p> </dd> <dt><span><code>"diagonal"</code></span></dt> <dd>
<p>Diagonal matrix. (Sparse matrices only) </p> </dd> <dt><span><code>"permuted diagonal"</code></span></dt> <dd>
<p>Permuted Diagonal matrix. The permutation does not need to be specifically indicated, as the structure of the matrix explicitly gives this. (Sparse matrices only) </p> </dd> <dt><span><code>"upper"</code></span></dt> <dd>
<p>Upper triangular. If the optional third argument <var>perm</var> is given, the matrix is assumed to be a permuted upper triangular with the permutations defined by the vector <var>perm</var>. </p> </dd> <dt><span><code>"lower"</code></span></dt> <dd>
<p>Lower triangular. If the optional third argument <var>perm</var> is given, the matrix is assumed to be a permuted lower triangular with the permutations defined by the vector <var>perm</var>. </p> </dd> <dt><span><code>"banded"</code></span></dt> <dt><span><code>"banded positive definite"</code></span></dt> <dd>
<p>Banded matrix with the band size of <var>nl</var> below the diagonal and <var>nu</var> above it. If <var>nl</var> and <var>nu</var> are 1, then the matrix is tridiagonal and treated with specialized code. In addition the matrix can be marked as probably a positive definite. (Sparse matrices only) </p> </dd> <dt><span><code>"singular"</code></span></dt> <dd>
<p>The matrix is assumed to be singular and will be treated with a minimum norm solution. </p> </dd> </dl> <p>Note that the matrix type will be discovered automatically on the first attempt to solve a linear equation involving <var>A</var>. Therefore <code>matrix_type</code> is only useful to give Octave hints of the matrix type. Incorrectly defining the matrix type will result in incorrect results from solutions of linear equations; it is entirely <strong>the responsibility of the user</strong> to correctly identify the matrix type. </p> <p>Also, the test for positive definiteness is a low-cost test for a Hermitian matrix with a real positive diagonal. This does not guarantee that the matrix is positive definite, but only that it is a probable candidate. When such a matrix is factorized, a Cholesky factorization is first attempted, and if that fails the matrix is then treated with an LU factorization. Once the matrix has been factorized, <code>matrix_type</code> will return the correct classification of the matrix. </p>
</dd>
</dl> <dl class="def"> <dt id="index-norm">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>norm</strong> <em>(<var>A</var>)</em><a href="#index-norm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-norm-1">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>norm</strong> <em>(<var>A</var>, <var>p</var>)</em><a href="#index-norm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-norm-2">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>norm</strong> <em>(<var>A</var>, <var>p</var>, <var>opt</var>)</em><a href="#index-norm-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the p-norm of the matrix <var>A</var>. </p> <p>If the second argument is not given, <code>p = 2</code> is used. </p> <p>If <var>A</var> is a matrix (or sparse matrix): </p> <dl compact> <dt><span><var>p</var> = <code>1</code></span></dt> <dd>
<p>1-norm, the largest column sum of the absolute values of <var>A</var>. </p> </dd> <dt><span><var>p</var> = <code>2</code></span></dt> <dd>
<p>Largest singular value of <var>A</var>. </p> </dd> <dt id="index-infinity-norm"><span><var>p</var> = <code>Inf</code> or <code>"inf"</code><a href="#index-infinity-norm" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Infinity norm, the largest row sum of the absolute values of <var>A</var>. </p> </dd> <dt id="index-Frobenius-norm"><span><var>p</var> = <code>"fro"</code><a href="#index-Frobenius-norm" class="copiable-anchor"> ¶</a></span></dt> <dd>
<p>Frobenius norm of <var>A</var>, <code>sqrt (sum (diag (<var>A</var>' * <var>A</var>)))</code>. </p> </dd> <dt id="index-general-p_002dnorm"><span>other <var>p</var>, <code><var>p</var> &gt; 1</code><a href="#index-general-p_002dnorm" class="copiable-anchor"> ¶</a></span></dt> <dd><p>maximum <code>norm (A*x, p)</code> such that <code>norm (x, p) == 1</code> </p></dd> </dl> <p>If <var>A</var> is a vector or a scalar: </p> <dl compact> <dt><span><var>p</var> = <code>Inf</code> or <code>"inf"</code></span></dt> <dd>
<p><code>max (abs (<var>A</var>))</code>. </p> </dd> <dt><span><var>p</var> = <code>-Inf</code></span></dt> <dd>
<p><code>min (abs (<var>A</var>))</code>. </p> </dd> <dt><span><var>p</var> = <code>"fro"</code></span></dt> <dd>
<p>Frobenius norm of <var>A</var>, <code>sqrt (sumsq (abs (A)))</code>. </p> </dd> <dt><span><var>p</var> = 0</span></dt> <dd>
<p>Hamming norm—the number of nonzero elements. </p> </dd> <dt><span>other <var>p</var>, <code><var>p</var> &gt; 1</code></span></dt> <dd>
<p>p-norm of <var>A</var>, <code>(sum (abs (<var>A</var>) .^ <var>p</var>)) ^ (1/<var>p</var>)</code>. </p> </dd> <dt><span>other <var>p</var> <code><var>p</var> &lt; 1</code></span></dt> <dd><p>the p-pseudonorm defined as above. </p></dd> </dl> <p>If <var>opt</var> is the value <code>"rows"</code>, treat each row as a vector and compute its norm. The result is returned as a column vector. Similarly, if <var>opt</var> is <code>"columns"</code> or <code>"cols"</code> then compute the norms of each column and return a row vector. </p> <p><strong>See also:</strong> <a href="sparse-linear-algebra.html#XREFnormest">normest</a>, <a href="sparse-linear-algebra.html#XREFnormest1">normest1</a>, <a href="#XREFvecnorm">vecnorm</a>, <a href="#XREFcond">cond</a>, <a href="matrix-factorizations.html#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-null">
<span class="category">: </span><span><em><var>Z</var> =</em> <strong>null</strong> <em>(<var>A</var>)</em><a href="#index-null" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-null-1">
<span class="category">: </span><span><em><var>Z</var> =</em> <strong>null</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-null-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return an orthonormal basis <var>Z</var> of the null space of <var>A</var>. </p> <p>The dimension of the null space <var>Z</var> is taken as the number of singular values of <var>A</var> not greater than <var>tol</var>. If the argument <var>tol</var> is missing, it is computed as </p> <pre class="example" data-language="matlab">max (size (A)) * max (svd (A, 0)) * eps</pre> <p><strong>See also:</strong> <a href="#XREForth">orth</a>, <a href="matrix-factorizations.html#XREFsvd">svd</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-orth">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>orth</strong> <em>(<var>A</var>)</em><a href="#index-orth" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-orth-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>orth</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-orth-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return an orthonormal basis of the range space of <var>A</var>. </p> <p>The dimension of the range space is taken as the number of singular values of <var>A</var> greater than <var>tol</var>. If the argument <var>tol</var> is missing, it is computed as </p> <pre class="example" data-language="matlab">max (size (A)) * max (svd (A)) * eps</pre> <p><strong>See also:</strong> <a href="#XREFnull">null</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-mgorth">
<span class="category">: </span><span><em>[<var>y</var>, <var>h</var>] =</em> <strong>mgorth</strong> <em>(<var>x</var>, <var>v</var>)</em><a href="#index-mgorth" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Orthogonalize a given column vector <var>x</var> with respect to a set of orthonormal vectors comprising the columns of <var>v</var> using the modified Gram-Schmidt method. </p> <p>On exit, <var>y</var> is a unit vector such that: </p> <pre class="example" data-language="matlab">norm (y) = 1
  v' * y = 0
  x = [v, y]*h'</pre> </dd>
</dl> <dl class="def"> <dt id="index-pinv">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>pinv</strong> <em>(<var>A</var>)</em><a href="#index-pinv" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-pinv-1">
<span class="category">: </span><span><em><var>B</var> =</em> <strong>pinv</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-pinv-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the Moore-Penrose pseudoinverse of <var>A</var>. </p> <p>Singular values less than <var>tol</var> are ignored. </p> <p>If the second argument is omitted, it is taken to be </p> <pre class="example" data-language="matlab">tol = max ([rows(x), columns(x)]) * norm (x) * eps</pre> <p><strong>See also:</strong> <a href="#XREFinv">inv</a>, <a href="arithmetic-ops.html#XREFldivide">ldivide</a>. </p>
</dd>
</dl>  <dl class="def"> <dt id="index-rank">
<span class="category">: </span><span><em><var>k</var> =</em> <strong>rank</strong> <em>(<var>A</var>)</em><a href="#index-rank" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rank-1">
<span class="category">: </span><span><em><var>k</var> =</em> <strong>rank</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-rank-1" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the rank of matrix <var>A</var>, using the singular value decomposition. </p> <p>The rank is taken to be the number of singular values of <var>A</var> that are greater than the specified tolerance <var>tol</var>. If the second argument is omitted, it is taken to be </p> <pre class="example" data-language="matlab">tol = max (size (A)) * sigma(1) * eps;</pre> <p>where <code>eps</code> is machine precision and <code>sigma(1)</code> is the largest singular value of <var>A</var>. </p> <p>The rank of a matrix is the number of linearly independent rows or columns and equals the dimension of the row and column space. The function <code>orth</code> may be used to compute an orthonormal basis of the column space. </p> <p>For testing if a system <code><var>A</var>*<var>x</var> = <var>b</var></code> of linear equations is solvable, one can use </p> <pre class="example" data-language="matlab">rank (A) == rank ([A b])</pre> <p>In this case, <code><var>x</var> = <var>A</var> \ <var>b</var></code> finds a particular solution <var>x</var>. The general solution is <var>x</var> plus the null space of matrix <var>A</var>. The function <code>null</code> may be used to compute a basis of the null space. </p> <p>Example: </p> <pre class="example" data-language="matlab">A = [1 2 3
     4 5 6
     7 8 9];
rank (A)
  ⇒ 2</pre> <p>In this example, the number of linearly independent rows is only 2 because the final row is a linear combination of the first two rows: </p> <pre class="example" data-language="matlab">A(3,:) == -A(1,:) + 2 * A(2,:)</pre> <p><strong>See also:</strong> <a href="#XREFnull">null</a>, <a href="#XREForth">orth</a>, <a href="sparse-linear-algebra.html#XREFsprank">sprank</a>, <a href="matrix-factorizations.html#XREFsvd">svd</a>, <a href="mathematical-constants.html#XREFeps">eps</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rcond">
<span class="category">: </span><span><em><var>c</var> =</em> <strong>rcond</strong> <em>(<var>A</var>)</em><a href="#index-rcond" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the 1-norm estimate of the reciprocal condition number as returned by <small>LAPACK</small>. </p> <p>If the matrix is well-conditioned then <var>c</var> will be near 1 and if the matrix is poorly conditioned it will be close to 0. </p> <p>The matrix <var>A</var> must not be sparse. If the matrix is sparse then <code>condest (<var>A</var>)</code> or <code>rcond (full (<var>A</var>))</code> should be used instead. </p> <p><strong>See also:</strong> <a href="#XREFcond">cond</a>, <a href="sparse-linear-algebra.html#XREFcondest">condest</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-trace">
<span class="category">: </span><span><em><var>t</var> =</em> <strong>trace</strong> <em>(<var>A</var>)</em><a href="#index-trace" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Compute the trace of <var>A</var>, the sum of the elements along the main diagonal. </p> <p>The implementation is straightforward: <code>sum (diag (<var>A</var>))</code>. </p> <p><strong>See also:</strong> <a href="#XREFeig">eig</a>. </p>
</dd>
</dl> <dl class="def"> <dt id="index-rref">
<span class="category">: </span><span><em><var>r</var> =</em> <strong>rref</strong> <em>(<var>A</var>)</em><a href="#index-rref" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rref-1">
<span class="category">: </span><span><em><var>r</var> =</em> <strong>rref</strong> <em>(<var>A</var>, <var>tol</var>)</em><a href="#index-rref-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-rref-2">
<span class="category">: </span><span><em>[<var>r</var>, <var>k</var>] =</em> <strong>rref</strong> <em>(…)</em><a href="#index-rref-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the reduced row echelon form of <var>A</var>. </p> <p><var>tol</var> defaults to <code>eps * max (size (<var>A</var>)) * norm (<var>A</var>, inf)</code>. </p> <p>The optional return argument <var>k</var> contains the vector of "bound variables", which are those columns on which elimination has been performed. </p> </dd>
</dl> <dl class="def"> <dt id="index-vecnorm">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>vecnorm</strong> <em>(<var>A</var>)</em><a href="#index-vecnorm" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-vecnorm-1">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>vecnorm</strong> <em>(<var>A</var>, <var>p</var>)</em><a href="#index-vecnorm-1" class="copiable-anchor"> ¶</a></span>
</dt> <dt id="index-vecnorm-2">
<span class="category">: </span><span><em><var>n</var> =</em> <strong>vecnorm</strong> <em>(<var>A</var>, <var>p</var>, <var>dim</var>)</em><a href="#index-vecnorm-2" class="copiable-anchor"> ¶</a></span>
</dt> <dd>
<p>Return the vector p-norm of the elements of array <var>A</var> along dimension <var>dim</var>. </p> <p>The p-norm of a vector is defined as </p> <pre class="example" data-language="matlab">p-norm (A, p) = sum (abs (A) .^ p)) ^ (1/p)</pre> <p>The input <var>p</var> must be a positive scalar. If omitted it defaults to 2 (Euclidean norm or distance). Other special values of <var>p</var> are 1 (Manhattan norm, sum of absolute values) and <code>Inf</code> (absolute value of largest element). </p> <p>The input <var>dim</var> specifies the dimension of the array on which the function operates and must be a positive integer. If omitted the first non-singleton dimension is used. </p> <p><strong>See also:</strong> <a href="#XREFnorm">norm</a>. </p>
</dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1996–2023 The Octave Project Developers<br>Permission is granted to make and distribute verbatim copies of this manual provided the copyright notice and this permission notice are preserved on all copies.<br/>Permission is granted to copy and distribute modified versions of this manual under the conditions for verbatim copying, provided that the entire resulting derived work is distributed under the terms of a permission notice identical to this one.</br>Permission is granted to copy and distribute translations of this manual into another language, under the above conditions for modified versions.<br>
    <a href="https://docs.octave.org/v8.1.0/Basic-Matrix-Functions.html" class="_attribution-link">https://docs.octave.org/v8.1.0/Basic-Matrix-Functions.html</a>
  </p>
</div>
