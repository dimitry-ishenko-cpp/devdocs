<h1>assert.pushResult()</h1>
<p class="version-details">version added: <a href="https://github.com/qunitjs/qunit/releases/tag/1.22.0">1.22.0</a> </p>
<h2 id="description" class="screen-reader-text h-api-desc">Description</h2> <p><code class="language-plaintext highlighter-rouge">pushResult( data )</code></p> <p>Report the result of a custom assertion.</p> <table> <thead> <tr> <th>name</th> <th>description</th> </tr> </thead> <tbody> <tr> <td>
<code class="language-plaintext highlighter-rouge">data.result</code> (boolean)</td> <td>Result of the assertion</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">data.actual</code></td> <td>Expression being tested</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">data.expected</code></td> <td>Known comparison value</td> </tr> <tr> <td>
<code class="language-plaintext highlighter-rouge">data.message</code> (string or undefined)</td> <td>Short description of the assertion</td> </tr> </tbody> </table> <h2 id="examples">Examples</h2> <p>If you need to express an expectation that is not abstracted by a built-in QUnit assertion, you can perform your own logic ad-hoc in an expression, and then pass two directly comparable values to <a href="strictequal.html"><code class="language-plaintext highlighter-rouge">assert.strictEqual()</code></a>, or pass your own representative boolean result to <a href="true.html"><code class="language-plaintext highlighter-rouge">assert.true()</code></a>.</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">QUnit.test('bad example of remainder', assert =&gt; {
  const result = 4;
  const actual = (result % 3) === 2;
  assert.true(actual, 'remainder');
  // In case of failure:
  // &gt; Actual: false
  // &gt; Expected: true
  //
  // No mention of the actual remainder.
  // No mention of the expected value.
});

QUnit.test('good example of remainder', assert =&gt; {
  const result = 4;
  assert.strictEqual(result % 3, 2, 'remainder');
  // In case of failure:
  // &gt; Actual: 1
  // &gt; Expected: 2
});

QUnit.test('bad example of between', assert =&gt; {
  const actual = 3;
  const isBetween = (actual &gt;= 1 &amp;&amp; actual &lt;= 10);
  assert.true(isBetween, 'result between 1 and 10');
  // In case of failure:
  // &gt; Actual: false
  // &gt; Expected: true
  //
  // No mention of the actual remainder.
  // No mention of the expected value.
  // Cannot be expressed in a useful way with strictEqual()
});
</pre></div></div> <h3 id="custom-assertion">Custom assertion</h3> <p>With a custom assertion method, you can control how an assertion should be evaluated, separately from how its actual and expected values are described in case of a failure.</p> <p>For example:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">QUnit.assert.between = function (actual, from, to, message) {
  const isBetween = (actual &gt;= from &amp;&amp; actual &lt;= to);

  this.pushResult({
    result: isBetween,
    actual: actual,
    expected: `between ${from} and ${to} inclusive`,
    message: message
  });
};

QUnit.test('custom assertion example', assert =&gt; {
  const result = 3;
  assert.between(result, 1, 10, 'result');
  // Example of failure if result is out of range
  // &gt; actual: 42
  // &gt; expected: between 1 and 10
});
</pre></div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; OpenJS Foundation and contributors.<br>Licensed under the MIT license.<br>
    <a href="https://api.qunitjs.com/assert/pushResult" class="_attribution-link">https://api.qunitjs.com/assert/pushResult</a>
  </p>
</div>
