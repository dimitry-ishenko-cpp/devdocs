<header> <h1>assert.closeTo()</h1> <p class="post-meta">Categories: <a class="category" href="https://qunitjs.com/api/assert/">Assertions</a>.</p> </header> <p class="version-details"> version added: <a href="https://github.com/qunitjs/qunit/releases/tag/2.21.0">2.21.0</a><span class="sep">.</span></p> <h2 id="description" class="screen-reader-text h-api-desc">Description</h2> <p><code class="language-plaintext highlighter-rouge">closeTo( actual, expected, delta, message = "" )</code></p> <p>Compare that a number is equal to a known target number within a given tolerance.</p> <table> <thead> <tr> <th>name</th> <th>description</th> </tr> </thead> <tbody> <tr> <td>
<code class="language-plaintext highlighter-rouge">actual</code> (number)</td> <td>Expression being tested</td> </tr> <tr> <td>
<code class="language-plaintext highlighter-rouge">expected</code> (number)</td> <td>Known target number</td> </tr> <tr> <td>
<code class="language-plaintext highlighter-rouge">delta</code> (number)</td> <td>The maximum difference between the expected and actual number</td> </tr> <tr> <td>
<code class="language-plaintext highlighter-rouge">message</code> (string)</td> <td>Optional description of the actual expression</td> </tr> </tbody> </table> <p>The <code class="language-plaintext highlighter-rouge">assert.closeTo()</code> assertion checks that the actual expression approximates the expected number, allowing it to be off by at most the specified amount (“delta”). This can be used to assert that two numbers are roughly or almost equal to each other.</p> <p>The actual number may be either above or below the expected number, as long as it is within the <code class="language-plaintext highlighter-rouge">delta</code> difference (inclusive).</p> <p>While non-strict assertions like this are <a href="https://timotijhof.net/posts/2015/qunit-anti-patterns/">often discouraged</a>, it may be necessary to account for limitations in how fractional numbers are represented in JavaScript. For example, <code class="language-plaintext highlighter-rouge">0.1 + 0.2</code> is actually <code class="language-plaintext highlighter-rouge">0.30000000000000004</code>. This because math operations in JavaScript adhere to the “IEEE floating-point” standard.</p> <p>To learn how floating-point numbers work internally, refer to <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">Double-precision floating-point format</a> on Wikipedia. To learn when and why floating-point numbers experience these side effects, refer to “<a href="http://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html">What Every Computer Scientist Should Know About Floating-Point Arithmetic</a>” by David Goldberg.</p> <h2 id="examples">Examples</h2> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="javascript">QUnit.test('good example', assert =&gt; {
  const x = 0.1 + 0.2; // 0.30000000000000004

  // passing: must be between 0.299 and 0.301
  assert.closeTo(x, 0.3, 0.001);

  const y = 20.13;
  // passing: must be between 20.05 and 20.15 inclusive
  assert.closeTo(y, 20.10, 0.05);
});

QUnit.test('bad example', assert =&gt; {
  const x = 20.7;
  // failing: must be between 20.0 and 20.2 inclusive
  assert.closeTo(x, 20.1, 0.1);
  // message: value should be within 0.1 inclusive
  // actual  : 20.7
  // expected: 20.1

  const y = 2018;
  // failing: must be between 2010 and 2014 inclusive
  assert.closeTo(y, 2012, 2);
  // message: value should be within 2 inclusive
  // actual  : 2018
  // expected: 2012
});
</pre></div></div> <h2 id="see-also">See also</h2> <ul> <li>Use <a href="propcontains.html"><code class="language-plaintext highlighter-rouge">assert.propContains()</code></a> to partially compare an object.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; OpenJS Foundation and contributors.<br>Licensed under the MIT license.<br>
    <a href="https://qunitjs.com/api/assert/closeTo" class="_attribution-link">https://qunitjs.com/api/assert/closeTo</a>
  </p>
</div>
