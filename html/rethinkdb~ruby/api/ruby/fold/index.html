<h1 class="title">ReQL command: fold</h1>  <div class="alg-content">
<h2 id="command-syntax">Command syntax</h2> <pre class="command-syntax" data-language="ruby">sequence.fold(base, function) → value
sequence.fold(base, function, :emit =&gt; function[, :final_emit =&gt; function]) → sequence
</pre> <h2 id="description">Description</h2> <p>Apply a function to a sequence in order, maintaining state via an accumulator. The <code class="language-plaintext highlighter-rouge">fold</code> command returns either a single value or a new sequence.</p> <p>In its first form, <code class="language-plaintext highlighter-rouge">fold</code> operates like <a href="../reduce/index.html">reduce</a>, returning a value by applying a combining function to each element in a sequence. The combining function takes two parameters: the previous reduction result (the accumulator) and the current element. However, <code class="language-plaintext highlighter-rouge">fold</code> has the following differences from <code class="language-plaintext highlighter-rouge">reduce</code>:</p> <ul> <li>it is guaranteed to proceed through the sequence from first element to last.</li> <li>it passes an initial base value to the function with the first element in place of the previous reduction result.</li> </ul> <pre class="command-syntax" data-language="ruby">combining_function(accumulator | base, element) → new_accumulator
</pre> <p>In its second form, <code class="language-plaintext highlighter-rouge">fold</code> operates like <a href="../concat_map/index.html">concat_map</a>, returning a new sequence rather than a single value. When an <code class="language-plaintext highlighter-rouge">emit</code> function is provided, <code class="language-plaintext highlighter-rouge">fold</code> will:</p> <ul> <li>proceed through the sequence in order and take an initial base value, as above.</li> <li>for each element in the sequence, call both the combining function and a separate emitting function. The emitting function takes three parameters: the previous reduction result (the accumulator), the current element, and the output from the combining function (the new value of the accumulator).</li> </ul> <p>If provided, the emitting function must return a list.</p> <pre class="command-syntax" data-language="ruby">emit(previous_accumulator, element, accumulator) → array
</pre> <p>A <code class="language-plaintext highlighter-rouge">finalEmit</code> function may also be provided, which will be called at the end of the sequence. It takes a single parameter: the result of the last reduction through the iteration (the accumulator), or the original base value if the input sequence was empty. This function must return a list, which will be appended to <code class="language-plaintext highlighter-rouge">fold</code>’s output stream.</p> <pre class="command-syntax" data-language="ruby">final_emit(accumulator | base) → array
</pre> <p><strong>Example:</strong> Concatenate words from a list.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('words').order_by('id').fold('',
    lambda { |acc, word| acc + r.branch(acc.eq(''), '', ', ') + word }
).run(conn)
</pre></div></div> <p>(This example could be implemented with <code class="language-plaintext highlighter-rouge">reduce</code>, but <code class="language-plaintext highlighter-rouge">fold</code> will preserve the order when <code class="language-plaintext highlighter-rouge">words</code> is a RethinkDB table or other stream, which is not guaranteed with <code class="language-plaintext highlighter-rouge">reduce</code>.)</p> <p><strong>Example:</strong> Return every other row in a table.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('players').fold(0,
    lambda { |acc, row| acc + 1 },
    :emit =&gt; lambda { |acc, row, new_acc| r.branch((new_acc % 2).eq(0), [row], []) }
).run(conn)
</pre></div></div> <p>The first function increments the accumulator each time it’s called, starting at <code class="language-plaintext highlighter-rouge">0</code>; the second function, the emitting function, alternates between returning a single-item list containing the current row or an empty list. The <code class="language-plaintext highlighter-rouge">fold</code> command will return a concatenated list of each emitted value.</p> <p><strong>Example:</strong> Compute a five-day running average for a weight tracker.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('tracker').filter({:name =&gt; 'bob'}).order_by('date')['weight'].fold(
    [],
    lambda { |acc, row| ([row] + acc).limit(5) },
    :emit =&gt; lambda {
        |acc, row, new_acc| r.branch(new_acc.size().eq(5), [new_acc.avg()], [])
    }
).run(conn)
</pre></div></div> </div> <section class="related-commands"> <h2>Related commands</h2> <ul> <li><a href="../reduce/index.html">reduce</a></li> <li><a href="../concat_map/index.html">concatMap</a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/api/ruby/fold/" class="_attribution-link">https://rethinkdb.com/api/ruby/fold/</a>
  </p>
</div>
