<h1 class="title">ReQL command: order_by</h1>  <div class="alg-content">
<h2 id="command-syntax">Command syntax</h2> <pre class="command-syntax" data-language="ruby">table.order_by([key | function], :index =&gt; index_name) → table_slice
selection.order_by(key | function[, ...]) → selection&lt;array&gt;
sequence.order_by(key | function[, ...]) → array
</pre> <h2 id="description">Description</h2> <p>Sort the sequence by document values of the given key(s). To specify the ordering, wrap the attribute with either <code class="language-plaintext highlighter-rouge">r.asc</code> or <code class="language-plaintext highlighter-rouge">r.desc</code> (defaults to ascending).</p> <p><strong>Note:</strong> RethinkDB uses byte-wise ordering for <code class="language-plaintext highlighter-rouge">orderBy</code> and does not support Unicode collations; non-ASCII characters will be sorted by UTF-8 codepoint. For more information on RethinkDB’s sorting order, read the section in <a href="../../../docs/data-types/index.html#sorting-order">ReQL data types</a>.</p> <p>Sorting without an index requires the server to hold the sequence in memory, and is limited to 100,000 documents (or the setting of the <code class="language-plaintext highlighter-rouge">array_limit</code> option for <a href="../run/index.html">run</a>). Sorting with an index can be done on arbitrarily large tables, or after a <a href="../between/index.html">between</a> command using the same index. This applies to both secondary indexes and the primary key (e.g., <code class="language-plaintext highlighter-rouge">:index =&gt; 'id'</code>).</p> <p>Sorting functions passed to <code class="language-plaintext highlighter-rouge">order_by</code> must be deterministic. You cannot, for instance, order rows using the <a href="../random/index.html">random</a> command. Using a non-deterministic function with <code class="language-plaintext highlighter-rouge">order_by</code> will raise a <code class="language-plaintext highlighter-rouge">ReqlQueryLogicError</code>.</p> <p><strong>Example:</strong> Order all the posts using the index <code class="language-plaintext highlighter-rouge">date</code>.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').order_by(:index =&gt; 'date').run(conn)
</pre></div></div>  <p>The index must either be the primary key or have been previously created with <a href="../index_create/index.html">index_create</a>.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').index_create('date').run(conn)
</pre></div></div> <p>You can also select a descending ordering:</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').order_by(:index =&gt; r.desc('date')).run(conn, callback)
</pre></div></div> <p><strong>Example:</strong> Order a sequence without an index.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').get(1)['comments'].order_by('date')
</pre></div></div> <p>You can also select a descending ordering:</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').get(1)['comments'].order_by(r.desc('date'))
</pre></div></div> <p>If you’re doing ad-hoc analysis and know your table won’t have more then 100,000 elements (or you’ve changed the setting of the <code class="language-plaintext highlighter-rouge">array_limit</code> option for <a href="../run/index.html">run</a>) you can run <code class="language-plaintext highlighter-rouge">order_by</code> without an index:</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('small_table').order_by('date')
</pre></div></div> <p><strong>Example:</strong> You can efficiently order using multiple fields by using a <a href="http://www.rethinkdb.com/docs/secondary-indexes/ruby/">compound index</a>.</p> <p>Order by date and title.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').order_by(:index =&gt; 'date_and_title').run(conn)
</pre></div></div> <p>The index must either be the primary key or have been previously created with <a href="../index_create/index.html">index_create</a>.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').index_create('date_and_title') {|post| [post["date"], post["title"]]}.run(conn)
</pre></div></div> <p><em>Note</em>: You cannot specify multiple orders in a compound index. See <a href="https://github.com/rethinkdb/rethinkdb/issues/2306">issue #2306</a> to track progress.</p> <p><strong>Example:</strong> If you have a sequence with fewer documents than the <code class="language-plaintext highlighter-rouge">array_limit</code>, you can order it by multiple fields without an index.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('small_table').order_by('date', r.desc('title'))
</pre></div></div> <p><strong>Example:</strong> Notice that an index ordering always has highest precedence. The following query orders posts by date, and if multiple posts were published on the same date, they will be ordered by title.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('post').order_by(:title, :index =&gt; 'date').run(conn)
</pre></div></div> <p><strong>Example:</strong> You can use <a href="../../../docs/cookbook/ruby/index.html#filtering-based-on-nested-fields">nested field</a> syntax to sort on fields from subdocuments. (You can also create indexes on nested fields using this syntax with <code class="language-plaintext highlighter-rouge">index_create</code>.)</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('user').order_by{ |user| user['group']['id'] }.run(conn)
</pre></div></div> <p><strong>Example:</strong> You can efficiently order data on arbitrary expressions using indexes.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').order_by(:index =&gt; 'votes').run(conn)
</pre></div></div> <p>The index must have been previously created with <a href="../index_create/index.html">index_create</a>.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('posts').index_create('votes') {|post|
    post["upvotes"]-post["downvotes"]
}.run(conn)
</pre></div></div> <p><strong>Example:</strong> If you have a sequence with fewer documents than the <code class="language-plaintext highlighter-rouge">array_limit</code>, you can order it with an arbitrary function directly.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('small_table').order_by(lambda { |doc|
    doc['upvotes']-doc['downvotes']
});
</pre></div></div> <p>You can also select a descending ordering:</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table('small_table').order_by(r.desc(lambda { |doc|
    doc['upvotes']-doc['downvotes']
}));
</pre></div></div> <p><strong>Example:</strong> Ordering after a <code class="language-plaintext highlighter-rouge">between</code> command can be done as long as the same index is being used.</p> <div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="ruby">r.table("posts").between(r.time(2013, 1, 1, '+00:00'), r.time(2013, 1, 1, '+00:00'), :index =&gt; 'date')
    .order_by(:index =&gt; 'date').run(conn);
</pre></div></div> </div> <section class="related-commands"> <h2>Related commands</h2> <ul> <li><a href="../skip/index.html">skip</a></li> <li><a href="../limit/index.html">limit</a></li> <li><a href="../slice/index.html">[]</a></li> </ul> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/api/ruby/order_by/" class="_attribution-link">https://rethinkdb.com/api/ruby/order_by/</a>
  </p>
</div>
