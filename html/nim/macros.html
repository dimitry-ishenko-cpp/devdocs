<h1 class="title">std/macros</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1" target="_blank">Edit</a>  
<p>This module contains the interface to the compiler's abstract syntax tree (<span id="ast_1">AST</span>). Macros operate on this tree.</p> <p>See also:</p> <ul class="simple">
<li><a href="https://nim-lang.org/docs/tut3.html">macros tutorial</a></li> <li><a href="manual.html#macros">macros section in Nim manual</a></li> </ul> <h2 id="the-ast-in-nim">The AST in Nim</h2>
<p>This section describes how the AST is modelled with Nim's type system. The AST consists of nodes (<code>NimNode</code>) with a variable number of children. Each node has a field named <code>kind</code> which describes what the node contains:</p> 
<pre class="listing" data-language="nim">type
  NimNodeKind = enum     ## kind of a node; only explanatory
    nnkNone,             ## invalid node kind
    nnkEmpty,            ## empty node
    nnkIdent,            ## node contains an identifier
    nnkIntLit,           ## node contains an int literal (example: 10)
    nnkStrLit,           ## node contains a string literal (example: "abc")
    nnkNilLit,           ## node contains a nil literal (example: nil)
    nnkCaseStmt,         ## node represents a case statement
    ...                  ## many more
  
  NimNode = ref NimNodeObj
  NimNodeObj = object
    case kind: NimNodeKind           ## the node's kind
    of nnkNone, nnkEmpty, nnkNilLit:
      discard                        ## node contains no additional fields
    of nnkCharLit..nnkUInt64Lit:
      intVal: BiggestInt             ## the int literal
    of nnkFloatLit..nnkFloat64Lit:
      floatVal: BiggestFloat         ## the float literal
    of nnkStrLit..nnkTripleStrLit, nnkCommentStmt, nnkIdent, nnkSym:
      strVal: string                 ## the string literal
    else:
      sons: seq[NimNode]             ## the node's sons (or children)</pre> <p>For the <code>NimNode</code> type, the <code>[]</code> operator has been overloaded: <code>n[i]</code> is <code>n</code>'s <code>i</code>-th child.</p> <p>To specify the AST for the different Nim constructs, the notation <code>nodekind(son1, son2, ...)</code> or <code>nodekind(value)</code> or <code>nodekind(field=value)</code> is used.</p> <p>Some child may be missing. A missing child is a node of kind <code>nnkEmpty</code>; a child can never be nil.</p> <h2 id="leaf-nodesslashatoms">Leaf nodes/Atoms</h2>
<p>A leaf of the AST often corresponds to a terminal symbol in the concrete syntax. Note that the default <code>float</code> in Nim maps to <code>float64</code> such that the default AST for a float is <code>nnkFloat64Lit</code> as below.</p> <table>
<tr>
<th>Nim expression</th>
<th>Corresponding AST</th>
</tr> <tr>
<td><code>42</code></td>
<td><code>nnkIntLit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'i8</code></td>
<td><code>nnkInt8Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'i16</code></td>
<td><code>nnkInt16Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'i32</code></td>
<td><code>nnkInt32Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'i64</code></td>
<td><code>nnkInt64Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'u8</code></td>
<td><code>nnkUInt8Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'u16</code></td>
<td><code>nnkUInt16Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'u32</code></td>
<td><code>nnkUInt32Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42'u64</code></td>
<td><code>nnkUInt64Lit(intVal = 42)</code></td>
</tr> <tr>
<td><code>42.0</code></td>
<td><code>nnkFloat64Lit(floatVal = 42.0)</code></td>
</tr> <tr>
<td><code>42.0'f32</code></td>
<td><code>nnkFloat32Lit(floatVal = 42.0)</code></td>
</tr> <tr>
<td><code>42.0'f64</code></td>
<td><code>nnkFloat64Lit(floatVal = 42.0)</code></td>
</tr> <tr>
<td><code>"abc"</code></td>
<td><code>nnkStrLit(strVal = "abc")</code></td>
</tr> <tr>
<td><code>r"abc"</code></td>
<td><code>nnkRStrLit(strVal = "abc")</code></td>
</tr> <tr>
<td><code>"""abc"""</code></td>
<td><code>nnkTripleStrLit(strVal = "abc")</code></td>
</tr> <tr>
<td><code>' '</code></td>
<td><code>nnkCharLit(intVal = 32)</code></td>
</tr> <tr>
<td><code>nil</code></td>
<td><code>nnkNilLit()</code></td>
</tr> <tr>
<td><code>myIdentifier</code></td>
<td><code>nnkIdent(strVal = "myIdentifier")</code></td>
</tr> <tr>
<td><code>myIdentifier</code></td>
<td>after lookup pass: <code>nnkSym(strVal = "myIdentifier", ...)</code>
</td>
</tr> </table>
<p>Identifiers are <code>nnkIdent</code> nodes. After the name lookup pass these nodes get transferred into <code>nnkSym</code> nodes.</p> <h2 id="callsslashexpressions">Calls/expressions</h2> <h3 id="callsslashexpressions-command-call">Command call</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">echo "abc", "xyz"</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCommand(
  nnkIdent("echo"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)</pre> <h3 id="callsslashexpressions-call-with">Call with <code>()</code>
</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">echo("abc", "xyz")</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCall(
  nnkIdent("echo"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)</pre> <h3 id="callsslashexpressions-infix-operator-call">Infix operator call</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">"abc" &amp; "xyz"</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkInfix(
  nnkIdent("&amp;"),
  nnkStrLit("abc"),
  nnkStrLit("xyz")
)</pre> <p>Note that with multiple infix operators, the command is parsed by operator precedence.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">5 + 3 * 4</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkInfix(
  nnkIdent("+"),
  nnkIntLit(5),
  nnkInfix(
    nnkIdent("*"),
    nnkIntLit(3),
    nnkIntLit(4)
  )
)</pre> <p>As a side note, if you choose to use infix operators in a prefix form, the AST behaves as a <a href="#callsslashexpressions-call-with">parenthetical function call</a> with <code>nnkAccQuoted</code>, as follows:</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">`+`(3, 4)</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCall(
  nnkAccQuoted(
    nnkIdent("+")
  ),
  nnkIntLit(3),
  nnkIntLit(4)
)</pre> <h3 id="callsslashexpressions-prefix-operator-call">Prefix operator call</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">? "xyz"</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkPrefix(
  nnkIdent("?"),
  nnkStrLit("abc")
)</pre> <h3 id="callsslashexpressions-postfix-operator-call">Postfix operator call</h3>
<p><strong>Note:</strong> There are no postfix operators in Nim. However, the <code>nnkPostfix</code> node is used for the <em>asterisk export marker</em> <code>*</code>:</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">identifier*</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkPostfix(
  nnkIdent("*"),
  nnkIdent("identifier")
)</pre> <h3 id="callsslashexpressions-call-with-named-arguments">Call with named arguments</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">writeLine(file=stdout, "hallo")</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCall(
  nnkIdent("writeLine"),
  nnkExprEqExpr(
    nnkIdent("file"),
    nnkIdent("stdout")
  ),
  nnkStrLit("hallo")
)</pre> <h3 id="callsslashexpressions-call-with-raw-string-literal">Call with raw string literal</h3>
<p>This is used, for example, in the <code>bindSym</code> examples <a href="manual.html#macros-bindsym">here</a> and with <code>re"some regexp"</code> in the regular expression module.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">echo"abc"</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCallStrLit(
  nnkIdent("echo"),
  nnkRStrLit("hello")
)</pre> <h3 id="callsslashexpressions-dereference-operator">Dereference operator <code>[]</code>
</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">x[]</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkDerefExpr(nnkIdent("x"))</pre> <h3 id="callsslashexpressions-addr-operator">Addr operator</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">addr(x)</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkAddr(nnkIdent("x"))</pre> <h3 id="callsslashexpressions-cast-operator">Cast operator</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">cast[T](x)</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCast(nnkIdent("T"), nnkIdent("x"))</pre> <h3 id="callsslashexpressions-object-access-operator-dot">Object access operator <code>.</code>
</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">x.y</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkDotExpr(nnkIdent("x"), nnkIdent("y"))</pre> <p>If you use Nim's flexible calling syntax (as in <code>x.len()</code>), the result is the same as above but wrapped in an <code>nnkCall</code>.</p> <h3 id="callsslashexpressions-array-access-operator">Array access operator <code>[]</code>
</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">x[y]</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkBracketExpr(nnkIdent("x"), nnkIdent("y"))</pre> <h3 id="callsslashexpressions-parentheses">Parentheses</h3>
<p>Parentheses for affecting operator precedence use the <code>nnkPar</code> node.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">(a + b) * c</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkInfix(nnkIdent("*"),
  nnkPar(
    nnkInfix(nnkIdent("+"), nnkIdent("a"), nnkIdent("b"))),
  nnkIdent("c"))</pre> <h3 id="callsslashexpressions-tuple-constructors">Tuple Constructors</h3>
<p>Nodes for tuple construction are built with the <code>nnkTupleConstr</code> node.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">(1, 2, 3)
(a: 1, b: 2, c: 3)
()</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTupleConstr(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))
nnkTupleConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(1)),
  nnkExprColonExpr(nnkIdent("b"), nnkIntLit(2)),
  nnkExprColonExpr(nnkIdent("c"), nnkIntLit(3)))
nnkTupleConstr()</pre> <p>Since the one tuple would be syntactically identical to parentheses with an expression in them, the parser expects a trailing comma for them. For tuple constructors with field names, this is not necessary.</p> 
<pre class="listing" data-language="nim">(1,)
(a: 1)</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTupleConstr(nnkIntLit(1))
nnkTupleConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(1)))</pre> <h3 id="callsslashexpressions-curly-braces">Curly braces</h3>
<p>Curly braces are used as the set constructor.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">{1, 2, 3}</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCurly(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))</pre> <p>When used as a table constructor, the syntax is different.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">{a: 3, b: 5}</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTableConstr(
  nnkExprColonExpr(nnkIdent("a"), nnkIntLit(3)),
  nnkExprColonExpr(nnkIdent("b"), nnkIntLit(5))
)</pre> <h3 id="callsslashexpressions-brackets">Brackets</h3>
<p>Brackets are used as the array constructor.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">[1, 2, 3]</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkBracket(nnkIntLit(1), nnkIntLit(2), nnkIntLit(3))</pre> <h3 id="callsslashexpressions-ranges">Ranges</h3>
<p>Ranges occur in set constructors, case statement branches, or array slices. Internally, the node kind <code>nnkRange</code> is used, but when constructing the AST, construction with <code>..</code> as an infix operator should be used instead.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">1..3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkInfix(
  nnkIdent(".."),
  nnkIntLit(1),
  nnkIntLit(3)
)</pre> <p>Example code:</p> 
<pre class="listing" data-language="nim">macro genRepeatEcho() =
  result = newNimNode(nnkStmtList)
  
  var forStmt = newNimNode(nnkForStmt) # generate a for statement
  forStmt.add(ident("i")) # use the variable `i` for iteration
  
  var rangeDef = newNimNode(nnkInfix).add(
    ident("..")).add(
    newIntLitNode(3),newIntLitNode(5)) # iterate over the range 3..5
  
  forStmt.add(rangeDef)
  forStmt.add(newCall(ident("echo"), newIntLitNode(3))) # meat of the loop
  result.add(forStmt)

genRepeatEcho() # gives:
                # 3
                # 3
                # 3</pre> <h3 id="callsslashexpressions-if-expression">If expression</h3>
<p>The representation of the <code>if</code> expression is subtle, but easy to traverse.</p> <p>Concrete syntax:</p> 
<pre class="listing">if cond1: expr1 elif cond2: expr2 else: expr3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkIfExpr(
  nnkElifExpr(cond1, expr1),
  nnkElifExpr(cond2, expr2),
  nnkElseExpr(expr3)
)</pre> <h3 id="callsslashexpressions-documentation-comments">Documentation Comments</h3>
<p>Double-hash (<code>##</code>) comments in the code actually have their own format, using <code>strVal</code> to get and set the comment text. Single-hash (<code>#</code>) comments are ignored.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">## This is a comment
## This is part of the first comment
stmt1
## Yet another</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCommentStmt() # only appears once for the first two lines!
stmt1
nnkCommentStmt() # another nnkCommentStmt because there is another comment
                 # (separate from the first)</pre> <h3 id="callsslashexpressions-pragmas">Pragmas</h3>
<p>One of Nim's cool features is pragmas, which allow fine-tuning of various aspects of the language. They come in all types, such as adorning procs and objects, but the standalone <code>emit</code> pragma shows the basics with the AST.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">{.emit: "#include &lt;stdio.h&gt;".}</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkPragma(
  nnkExprColonExpr(
    nnkIdent("emit"),
    nnkStrLit("#include &lt;stdio.h&gt;") # the "argument"
  )
)</pre> <p>As many <code>nnkIdent</code> appear as there are pragmas between <code>{..}</code>. Note that the declaration of new pragmas is essentially the same:</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">{.pragma: cdeclRename, cdecl.}</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkPragma(
  nnkExprColonExpr(
    nnkIdent("pragma"), # this is always first when declaring a new pragma
    nnkIdent("cdeclRename") # the name of the pragma
  ),
  nnkIdent("cdecl")
)</pre> <h2 id="statements">Statements</h2> <h3 id="statements-if-statement">If statement</h3>
<p>The representation of the if statement is subtle, but easy to traverse. If there is no <code>else</code> branch, no <code>nnkElse</code> child exists.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">if cond1:
  stmt1
elif cond2:
  stmt2
elif cond3:
  stmt3
else:
  stmt4</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkIfStmt(
  nnkElifBranch(cond1, stmt1),
  nnkElifBranch(cond2, stmt2),
  nnkElifBranch(cond3, stmt3),
  nnkElse(stmt4)
)</pre> <h3 id="statements-when-statement">When statement</h3>
<p>Like the <code>if</code> statement, but the root has the kind <code>nnkWhenStmt</code>.</p> <h3 id="statements-assignment">Assignment</h3>
<p>Concrete syntax:</p> 
<pre class="listing">x = 42</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkAsgn(nnkIdent("x"), nnkIntLit(42))</pre> <p>This is not the syntax for assignment when combined with <code>var</code>, <code>let</code>, or <code>const</code>.</p> <h3 id="statements-statement-list">Statement list</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">stmt1
stmt2
stmt3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkStmtList(stmt1, stmt2, stmt3)</pre> <h3 id="statements-case-statement">Case statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">case expr1
of expr2, expr3..expr4:
  stmt1
of expr5:
  stmt2
elif cond1:
  stmt3
else:
  stmt4</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkCaseStmt(
  expr1,
  nnkOfBranch(expr2, nnkRange(expr3, expr4), stmt1),
  nnkOfBranch(expr5, stmt2),
  nnkElifBranch(cond1, stmt3),
  nnkElse(stmt4)
)</pre> <p>The <code>nnkElifBranch</code> and <code>nnkElse</code> parts may be missing.</p> <h3 id="statements-while-statement">While statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">while expr1:
  stmt1</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkWhileStmt(expr1, stmt1)</pre> <h3 id="statements-for-statement">For statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">for ident1, ident2 in expr1:
  stmt1</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkForStmt(ident1, ident2, expr1, stmt1)</pre> <h3 id="statements-try-statement">Try statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">try:
  stmt1
except e1, e2:
  stmt2
except e3:
  stmt3
except:
  stmt4
finally:
  stmt5</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTryStmt(
  stmt1,
  nnkExceptBranch(e1, e2, stmt2),
  nnkExceptBranch(e3, stmt3),
  nnkExceptBranch(stmt4),
  nnkFinally(stmt5)
)</pre> <h3 id="statements-return-statement">Return statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">return expr1</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkReturnStmt(expr1)</pre> <h3 id="statements-yield-statement">Yield statement</h3>
<p>Like <code>return</code>, but with <code>nnkYieldStmt</code> kind.</p> 
<pre class="listing" data-language="nim">nnkYieldStmt(expr1)</pre> <h3 id="statements-discard-statement">Discard statement</h3>
<p>Like <code>return</code>, but with <code>nnkDiscardStmt</code> kind.</p> 
<pre class="listing" data-language="nim">nnkDiscardStmt(expr1)</pre> <h3 id="statements-continue-statement">Continue statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">continue</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkContinueStmt()</pre> <h3 id="statements-break-statement">Break statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">break otherLocation</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkBreakStmt(nnkIdent("otherLocation"))</pre> <p>If <code>break</code> is used without a jump-to location, <code>nnkEmpty</code> replaces <code>nnkIdent</code>.</p> <h3 id="statements-block-statement">Block statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">block name:</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkBlockStmt(nnkIdent("name"), nnkStmtList(...))</pre> <p>A <code>block</code> doesn't need an name, in which case <code>nnkEmpty</code> is used.</p> <h3 id="statements-asm-statement">Asm statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">asm """
  some asm
"""</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkAsmStmt(
  nnkEmpty(), # for pragmas
  nnkTripleStrLit("some asm"),
)</pre> <h3 id="statements-import-section">Import section</h3>
<p>Nim's <code>import</code> statement actually takes different variations depending on what keywords are present. Let's start with the simplest form.</p> <p>Concrete syntax:</p> 
<pre class="listing">import math</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkImportStmt(nnkIdent("math"))</pre> <p>With <code>except</code>, we get <code>nnkImportExceptStmt</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing">import math except pow</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkImportExceptStmt(nnkIdent("math"),nnkIdent("pow"))</pre> <p>Note that <code>import math as m</code> does not use a different node; rather, we use <code>nnkImportStmt</code> with <code>as</code> as an infix operator.</p> <p>Concrete syntax:</p> 
<pre class="listing">import strutils as su</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkImportStmt(
  nnkInfix(
    nnkIdent("as"),
    nnkIdent("strutils"),
    nnkIdent("su")
  )
)</pre> <h3 id="statements-from-statement">From statement</h3>
<p>If we use <code>from ... import</code>, the result is different, too.</p> <p>Concrete syntax:</p> 
<pre class="listing">from math import pow</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkFromStmt(nnkIdent("math"), nnkIdent("pow"))</pre> <p>Using <code>from math as m import pow</code> works identically to the <code>as</code> modifier with the <code>import</code> statement, but wrapped in <code>nnkFromStmt</code>.</p> <h3 id="statements-export-statement">Export statement</h3>
<p>When you are making an imported module accessible by modules that import yours, the <code>export</code> syntax is pretty straightforward.</p> <p>Concrete syntax:</p> 
<pre class="listing">export unsigned</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkExportStmt(nnkIdent("unsigned"))</pre> <p>Similar to the <code>import</code> statement, the AST is different for <code>export ... except</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">export math except pow # we're going to implement our own exponentiation</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkExportExceptStmt(nnkIdent("math"),nnkIdent("pow"))</pre> <h3 id="statements-include-statement">Include statement</h3>
<p>Like a plain <code>import</code> statement but with <code>nnkIncludeStmt</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing">include blocks</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkIncludeStmt(nnkIdent("blocks"))</pre> <h3 id="statements-var-section">Var section</h3>
<p>Concrete syntax:</p> 
<pre class="listing">var a = 3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkVarSection(
  nnkIdentDefs(
    nnkIdent("a"),
    nnkEmpty(), # or nnkIdent(...) if the variable declares the type
    nnkIntLit(3),
  )
)</pre> <p>Note that either the second or third (or both) parameters above must exist, as the compiler needs to know the type somehow (which it can infer from the given assignment).</p> <p>This is not the same AST for all uses of <code>var</code>. See <a href="macros.html#statements-procedure-declaration">Procedure declaration</a> for details.</p> <h3 id="statements-let-section">Let section</h3>
<p>This is equivalent to <code>var</code>, but with <code>nnkLetSection</code> rather than <code>nnkVarSection</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing">let a = 3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkLetSection(
  nnkIdentDefs(
    nnkIdent("a"),
    nnkEmpty(), # or nnkIdent(...) for the type
    nnkIntLit(3),
  )
)</pre> <h3 id="statements-const-section">Const section</h3>
<p>Concrete syntax:</p> 
<pre class="listing">const a = 3</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkConstSection(
  nnkConstDef( # not nnkConstDefs!
    nnkIdent("a"),
    nnkEmpty(), # or nnkIdent(...) if the variable declares the type
    nnkIntLit(3), # required in a const declaration!
  )
)</pre> <h3 id="statements-type-section">Type section</h3>
<p>Starting with the simplest case, a <code>type</code> section appears much like <code>var</code> and <code>const</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing">type A = int</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTypeSection(
  nnkTypeDef(
    nnkIdent("A"),
    nnkEmpty(),
    nnkIdent("int")
  )
)</pre> <p>Declaring <code>distinct</code> types is similar, with the last <code>nnkIdent</code> wrapped in <code>nnkDistinctTy</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing">type MyInt = distinct int</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkTypeDef(
  nnkIdent("MyInt"),
  nnkEmpty(),
  nnkDistinctTy(
    nnkIdent("int")
  )
)</pre> <p>If a type section uses generic parameters, they are treated here:</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type A[T] = expr1</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTypeSection(
  nnkTypeDef(
    nnkIdent("A"),
    nnkGenericParams(
      nnkIdentDefs(
        nnkIdent("T"),
        nnkEmpty(), # if the type is declared with options, like
                    # ``[T: SomeInteger]``, they are given here
        nnkEmpty(),
      )
    )
    expr1,
  )
)</pre> <p>Note that not all <code>nnkTypeDef</code> utilize <code>nnkIdent</code> as their parameter. One of the most common uses of type declarations is to work with objects.</p> <p>Concrete syntax:</p> 
<pre class="listing">type IO = object of RootObj</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkTypeDef(
  nnkIdent("IO"),
  nnkEmpty(),
  nnkObjectTy(
    nnkEmpty(), # no pragmas here
    nnkOfInherit(
      nnkIdent("RootObj") # inherits from RootObj
    ),
    nnkEmpty()
  )
)</pre> <p>Nim's object syntax is rich. Let's take a look at an involved example in its entirety to see some of the complexities.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type Obj[T] {.inheritable.} = object
  name: string
  case isFat: bool
  of true:
    m: array[100_000, T]
  of false:
    m: array[10, T]</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkPragmaExpr(
  nnkIdent("Obj"),
  nnkPragma(nnkIdent("inheritable"))
),
nnkGenericParams(
nnkIdentDefs(
  nnkIdent("T"),
  nnkEmpty(),
  nnkEmpty())
),
nnkObjectTy(
  nnkEmpty(),
  nnkEmpty(),
  nnkRecList( # list of object parameters
    nnkIdentDefs(
      nnkIdent("name"),
      nnkIdent("string"),
      nnkEmpty()
    ),
    nnkRecCase( # case statement within object (not nnkCaseStmt)
      nnkIdentDefs(
        nnkIdent("isFat"),
        nnkIdent("bool"),
        nnkEmpty()
      ),
      nnkOfBranch(
        nnkIdent("true"),
        nnkRecList( # again, a list of object parameters
          nnkIdentDefs(
            nnkIdent("m"),
            nnkBracketExpr(
              nnkIdent("array"),
              nnkIntLit(100000),
              nnkIdent("T")
            ),
            nnkEmpty()
        )
      ),
      nnkOfBranch(
        nnkIdent("false"),
        nnkRecList(
          nnkIdentDefs(
            nnkIdent("m"),
            nnkBracketExpr(
              nnkIdent("array"),
              nnkIntLit(10),
              nnkIdent("T")
            ),
            nnkEmpty()
          )
        )
      )
    )
  )
)</pre> <p>Using an <code>enum</code> is similar to using an <code>object</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type X = enum
  First</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkEnumTy(
  nnkEmpty(),
  nnkIdent("First") # you need at least one nnkIdent or the compiler complains
)</pre> <p>The usage of <code>concept</code> (experimental) is similar to objects.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type Con = concept x,y,z
  (x &amp; y &amp; z) is string</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkTypeClassTy( # note this isn't nnkConceptTy!
  nnkArgList(
    # ... idents for x, y, z
  )
  # ...
)</pre> <p>Static types, like <code>static[int]</code>, use <code>nnkIdent</code> wrapped in <code>nnkStaticTy</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type A[T: static[int]] = object</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ... within nnkGenericParams
nnkIdentDefs(
  nnkIdent("T"),
  nnkStaticTy(
    nnkIdent("int")
  ),
  nnkEmpty()
)
# ...</pre> <p>In general, declaring types mirrors this syntax (i.e., <code>nnkStaticTy</code> for <code>static</code>, etc.). Examples follow (exceptions marked by <code>*</code>):</p> <table>
<tr>
<th>Nim type</th>
<th>Corresponding AST</th>
</tr> <tr>
<td><code>static</code></td>
<td><code>nnkStaticTy</code></td>
</tr> <tr>
<td><code>tuple</code></td>
<td><code>nnkTupleTy</code></td>
</tr> <tr>
<td><code>var</code></td>
<td><code>nnkVarTy</code></td>
</tr> <tr>
<td><code>ptr</code></td>
<td><code>nnkPtrTy</code></td>
</tr> <tr>
<td><code>ref</code></td>
<td><code>nnkRefTy</code></td>
</tr> <tr>
<td><code>distinct</code></td>
<td><code>nnkDistinctTy</code></td>
</tr> <tr>
<td><code>enum</code></td>
<td><code>nnkEnumTy</code></td>
</tr> <tr>
<td><code>concept</code></td>
<td>
<code>nnkTypeClassTy</code>*</td>
</tr> <tr>
<td><code>array</code></td>
<td>
<code>nnkBracketExpr(nnkIdent("array"),...</code>*</td>
</tr> <tr>
<td><code>proc</code></td>
<td><code>nnkProcTy</code></td>
</tr> <tr>
<td><code>iterator</code></td>
<td><code>nnkIteratorTy</code></td>
</tr> <tr>
<td><code>object</code></td>
<td><code>nnkObjectTy</code></td>
</tr> </table>
<p>Take special care when declaring types as <code>proc</code>. The behavior is similar to <code>Procedure declaration</code>, below, but does not treat <code>nnkGenericParams</code>. Generic parameters are treated in the type, not the <code>proc</code> itself.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">type MyProc[T] = proc(x: T) {.nimcall.}</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkTypeDef(
  nnkIdent("MyProc"),
  nnkGenericParams( # here, not with the proc
    # ...
  )
  nnkProcTy( # behaves like a procedure declaration from here on
    nnkFormalParams(
      # ...
    ),
    nnkPragma(nnkIdent("nimcall"))
  )
)</pre> <p>The same syntax applies to <code>iterator</code> (with <code>nnkIteratorTy</code>), but <em>does not</em> apply to <code>converter</code> or <code>template</code>.</p> <p>Type class versions of these nodes generally share the same node kind but without any child nodes. The <code>tuple</code> type class is represented by <code>nnkTupleClassTy</code>, while a <code>proc</code> or <code>iterator</code> type class with pragmas has an <code>nnkEmpty</code> node in place of the <code>nnkFormalParams</code> node of a concrete <code>proc</code> or <code>iterator</code> type node.</p> 
<pre class="listing" data-language="nim">type TypeClass = proc {.nimcall.} | ref | tuple</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTypeDef(
  nnkIdent("TypeClass"),
  nnkEmpty(),
  nnkInfix(
    nnkIdent("|"),
    nnkProcTy(
      nnkEmpty(),
      nnkPragma(nnkIdent("nimcall"))
    ),
    nnkInfix(
      nnkIdent("|"),
      nnkRefTy(),
      nnkTupleClassTy()
    )
  )
)</pre> <h3 id="statements-mixin-statement">Mixin statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">mixin x</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkMixinStmt(nnkIdent("x"))</pre> <h3 id="statements-bind-statement">Bind statement</h3>
<p>Concrete syntax:</p> 
<pre class="listing">bind x</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkBindStmt(nnkIdent("x"))</pre> <h3 id="statements-procedure-declaration">Procedure declaration</h3>
<p>Let's take a look at a procedure with a lot of interesting aspects to get a feel for how procedure calls are broken down.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">proc hello*[T: SomeInteger](x: int = 3, y: float32): int {.inline.} = discard</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkProcDef(
  nnkPostfix(nnkIdent("*"), nnkIdent("hello")), # the exported proc name
  nnkEmpty(), # patterns for term rewriting in templates and macros (not procs)
  nnkGenericParams( # generic type parameters, like with type declaration
    nnkIdentDefs(
      nnkIdent("T"),
      nnkIdent("SomeInteger"),
      nnkEmpty()
    )
  ),
  nnkFormalParams(
    nnkIdent("int"), # the first FormalParam is the return type. nnkEmpty() if there is none
    nnkIdentDefs(
      nnkIdent("x"),
      nnkIdent("int"), # type type (required for procs, not for templates)
      nnkIntLit(3) # a default value
    ),
    nnkIdentDefs(
      nnkIdent("y"),
      nnkIdent("float32"),
      nnkEmpty()
    )
  ),
  nnkPragma(nnkIdent("inline")),
  nnkEmpty(), # reserved slot for future use
  nnkStmtList(nnkDiscardStmt(nnkEmpty())) # the meat of the proc
)</pre> <p>There is another consideration. Nim has flexible type identification for its procs. Even though <code>proc(a: int, b: int)</code> and <code>proc(a, b: int)</code> are equivalent in the code, the AST is a little different for the latter.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">proc(a, b: int)</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...AST as above...
nnkFormalParams(
  nnkEmpty(), # no return here
  nnkIdentDefs(
    nnkIdent("a"), # the first parameter
    nnkIdent("b"), # directly to the second parameter
    nnkIdent("int"), # their shared type identifier
    nnkEmpty(), # default value would go here
  )
),
# ...</pre> <p>When a procedure uses the special <code>var</code> type return variable, the result is different from that of a var section.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">proc hello(): var int</pre> <p>AST:</p> 
<pre class="listing" data-language="nim"># ...
nnkFormalParams(
  nnkVarTy(
    nnkIdent("int")
  )
)</pre> <h3 id="statements-iterator-declaration">Iterator declaration</h3>
<p>The syntax for iterators is similar to procs, but with <code>nnkIteratorDef</code> replacing <code>nnkProcDef</code>.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">iterator nonsense[T](x: seq[T]): float {.closure.} = ...</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkIteratorDef(
  nnkIdent("nonsense"),
  nnkEmpty(),
  ...
)</pre> <h3 id="statements-converter-declaration">Converter declaration</h3>
<p>A converter is similar to a proc.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">converter toBool(x: float): bool</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkConverterDef(
  nnkIdent("toBool"),
  # ...
)</pre> <h3 id="statements-template-declaration">Template declaration</h3>
<p>Templates (as well as macros, as we'll see) have a slightly expanded AST when compared to procs and iterators. The reason for this is <a href="manual.html#term-rewriting-macros">term-rewriting macros</a>. Notice the <code>nnkEmpty()</code> as the second argument to <code>nnkProcDef</code> and <code>nnkIteratorDef</code> above? That's where the term-rewriting macros go.</p> <p>Concrete syntax:</p> 
<pre class="listing" data-language="nim">template optOpt{expr1}(a: int): int</pre> <p>AST:</p> 
<pre class="listing" data-language="nim">nnkTemplateDef(
  nnkIdent("optOpt"),
  nnkStmtList( # instead of nnkEmpty()
    expr1
  ),
  # follows like a proc or iterator
)</pre> <p>If the template does not have types for its parameters, the type identifiers inside <code>nnkFormalParams</code> just becomes <code>nnkEmpty</code>.</p> <h3 id="statements-macro-declaration">Macro declaration</h3>
<p>Macros behave like templates, but <code>nnkTemplateDef</code> is replaced with <code>nnkMacroDef</code>.</p> <h3 id="statements-hidden-standard-conversion">Hidden Standard Conversion</h3>

<pre class="listing">var f: float = 1</pre> <p>The type of "f" is <code>float</code> but the type of "1" is actually <code>int</code>. Inserting <code>int</code> into a <code>float</code> is a type error. Nim inserts the <code>nnkHiddenStdConv</code> node around the <code>nnkIntLit</code> node so that the new node has the correct type of <code>float</code>. This works for any auto converted nodes and makes the conversion explicit.</p> <h2 id="special-node-kinds">Special node kinds</h2>
<p>There are several node kinds that are used for semantic checking or code generation. These are accessible from this module, but should not be used. Other node kinds are especially designed to make AST manipulations easier. These are explained here.</p> <p>To be written. </p>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="BindSymRule"> <dt><pre data-language="nim">BindSymRule = enum
  brClosed,                 ## only the symbols in current scope are bound
  brOpen,                   ## open for overloaded symbols, but may be a single
                             ## symbol if not ambiguous (the rules match that of
                             ## binding in generics)
  brForceOpen                ## same as brOpen, but it will always be open even
                             ## if not ambiguous (this cannot be achieved with
                             ## any other means in the language currently)</pre></dt> <dd> Specifies how <code><span class="Identifier">bindSym</span></code> behaves. The difference between open and closed symbols can be found in <a href="manual.html#symbol-lookup-in-generics-open-and-closed-symbols">manual.html#symbol-lookup-in-generics-open-and-closed-symbols</a> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L478" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L478" target="_blank">Edit</a> </dd> </div> <div id="LineInfo"> <dt><pre data-language="nim">LineInfo = object
  filename*: string
  line*, column*: int</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L519" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L519" target="_blank">Edit</a> </dd> </div> <div id="NimIdent"> <dt><pre data-language="nim">NimIdent {....deprecated.} = object of RootObj</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated</b> </div> Represents a Nim identifier in the AST. <strong>Note</strong>: This is only rarely useful, for identifier construction from a string use <code><span class="RawData">ident"abc"</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L135" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L135" target="_blank">Edit</a> </dd> </div> <div id="NimNodeKind"> <dt><pre data-language="nim">NimNodeKind = enum
  nnkNone, nnkEmpty, nnkIdent, nnkSym, nnkType, nnkCharLit, nnkIntLit,
  nnkInt8Lit, nnkInt16Lit, nnkInt32Lit, nnkInt64Lit, nnkUIntLit, nnkUInt8Lit,
  nnkUInt16Lit, nnkUInt32Lit, nnkUInt64Lit, nnkFloatLit, nnkFloat32Lit,
  nnkFloat64Lit, nnkFloat128Lit, nnkStrLit, nnkRStrLit, nnkTripleStrLit,
  nnkNilLit, nnkComesFrom, nnkDotCall, nnkCommand, nnkCall, nnkCallStrLit,
  nnkInfix, nnkPrefix, nnkPostfix, nnkHiddenCallConv, nnkExprEqExpr,
  nnkExprColonExpr, nnkIdentDefs, nnkVarTuple, nnkPar, nnkObjConstr, nnkCurly,
  nnkCurlyExpr, nnkBracket, nnkBracketExpr, nnkPragmaExpr, nnkRange, nnkDotExpr,
  nnkCheckedFieldExpr, nnkDerefExpr, nnkIfExpr, nnkElifExpr, nnkElseExpr,
  nnkLambda, nnkDo, nnkAccQuoted, nnkTableConstr, nnkBind, nnkClosedSymChoice,
  nnkOpenSymChoice, nnkHiddenStdConv, nnkHiddenSubConv, nnkConv, nnkCast,
  nnkStaticExpr, nnkAddr, nnkHiddenAddr, nnkHiddenDeref, nnkObjDownConv,
  nnkObjUpConv, nnkChckRangeF, nnkChckRange64, nnkChckRange, nnkStringToCString,
  nnkCStringToString, nnkAsgn, nnkFastAsgn, nnkGenericParams, nnkFormalParams,
  nnkOfInherit, nnkImportAs, nnkProcDef, nnkMethodDef, nnkConverterDef,
  nnkMacroDef, nnkTemplateDef, nnkIteratorDef, nnkOfBranch, nnkElifBranch,
  nnkExceptBranch, nnkElse, nnkAsmStmt, nnkPragma, nnkPragmaBlock, nnkIfStmt,
  nnkWhenStmt, nnkForStmt, nnkParForStmt, nnkWhileStmt, nnkCaseStmt,
  nnkTypeSection, nnkVarSection, nnkLetSection, nnkConstSection, nnkConstDef,
  nnkTypeDef, nnkYieldStmt, nnkDefer, nnkTryStmt, nnkFinally, nnkRaiseStmt,
  nnkReturnStmt, nnkBreakStmt, nnkContinueStmt, nnkBlockStmt, nnkStaticStmt,
  nnkDiscardStmt, nnkStmtList, nnkImportStmt, nnkImportExceptStmt,
  nnkExportStmt, nnkExportExceptStmt, nnkFromStmt, nnkIncludeStmt, nnkBindStmt,
  nnkMixinStmt, nnkUsingStmt, nnkCommentStmt, nnkStmtListExpr, nnkBlockExpr,
  nnkStmtListType, nnkBlockType, nnkWith, nnkWithout, nnkTypeOfExpr,
  nnkObjectTy, nnkTupleTy, nnkTupleClassTy, nnkTypeClassTy, nnkStaticTy,
  nnkRecList, nnkRecCase, nnkRecWhen, nnkRefTy, nnkPtrTy, nnkVarTy, nnkConstTy,
  nnkOutTy, nnkDistinctTy, nnkProcTy, nnkIteratorTy, nnkSinkAsgn, nnkEnumTy,
  nnkEnumFieldDef, nnkArgList, nnkPattern, nnkHiddenTryStmt, nnkClosure,
  nnkGotoState, nnkState, nnkBreakState, nnkFuncDef, nnkTupleConstr, nnkError ## erroneous AST node</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L32" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L32" target="_blank">Edit</a> </dd> </div> <div id="NimNodeKinds"> <dt><pre data-language="nim">NimNodeKinds = set[NimNodeKind]</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L97" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L97" target="_blank">Edit</a> </dd> </div> <div id="NimSym"> <dt><pre data-language="nim">NimSym {....deprecated.} = ref NimSymObj</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated</b> </div> Represents a Nim <em>symbol</em> in the compiler; a <em>symbol</em> is a looked-up <em>ident</em>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L141" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L141" target="_blank">Edit</a> </dd> </div> <div id="NimSymKind"> <dt><pre data-language="nim">NimSymKind = enum
  nskUnknown, nskConditional, nskDynLib, nskParam, nskGenericParam, nskTemp,
  nskModule, nskType, nskVar, nskLet, nskConst, nskResult, nskProc, nskFunc,
  nskMethod, nskIterator, nskConverter, nskMacro, nskTemplate, nskField,
  nskEnumField, nskForVar, nskLabel, nskStub</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L119" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L119" target="_blank">Edit</a> </dd> </div> <div id="NimTypeKind"> <dt><pre data-language="nim">NimTypeKind = enum
  ntyNone, ntyBool, ntyChar, ntyEmpty, ntyAlias, ntyNil, ntyExpr, ntyStmt,
  ntyTypeDesc, ntyGenericInvocation, ntyGenericBody, ntyGenericInst,
  ntyGenericParam, ntyDistinct, ntyEnum, ntyOrdinal, ntyArray, ntyObject,
  ntyTuple, ntySet, ntyRange, ntyPtr, ntyRef, ntyVar, ntySequence, ntyProc,
  ntyPointer, ntyOpenArray, ntyString, ntyCString, ntyForward, ntyInt, ntyInt8,
  ntyInt16, ntyInt32, ntyInt64, ntyFloat, ntyFloat32, ntyFloat64, ntyFloat128,
  ntyUInt, ntyUInt8, ntyUInt16, ntyUInt32, ntyUInt64, ntyUnused0, ntyUnused1,
  ntyUnused2, ntyVarargs, ntyUncheckedArray, ntyError, ntyBuiltinTypeClass,
  ntyUserTypeClass, ntyUserTypeClassInst, ntyCompositeTypeClass, ntyInferred,
  ntyAnd, ntyOr, ntyNot, ntyAnything, ntyStatic, ntyFromExpr, ntyOptDeprecated,
  ntyVoid</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L98" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L98" target="_blank">Edit</a> </dd> </div> <div id="TNimSymKinds"> <dt><pre data-language="nim">TNimSymKinds {....deprecated.} = set[NimSymKind]</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated</b> </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L128" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L128" target="_blank">Edit</a> </dd> </div> <div id="TNimTypeKinds"> <dt><pre data-language="nim">TNimTypeKinds {....deprecated.} = set[NimTypeKind]</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated</b> </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L118" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L118" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="10">Consts</h2> <dl> <div id="AtomicNodes"> <dt><pre data-language="nim">AtomicNodes = {nnkNone..nnkNilLit}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1211" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1211" target="_blank">Edit</a> </dd> </div> <div id="CallNodes"> <dt><pre data-language="nim">CallNodes = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand,
             nnkCallStrLit, nnkHiddenCallConv}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1213" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1213" target="_blank">Edit</a> </dd> </div> <div id="nnkCallKinds"> <dt><pre data-language="nim">nnkCallKinds = {nnkCall, nnkInfix, nnkPrefix, nnkPostfix, nnkCommand,
                nnkCallStrLit, nnkHiddenCallConv}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L149" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L149" target="_blank">Edit</a> </dd> </div> <div id="nnkLiterals"> <dt><pre data-language="nim">nnkLiterals = {nnkCharLit..nnkNilLit}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L147" target="_blank">Edit</a> </dd> </div> <div id="nnkMutableTy"> <dt><pre data-language="nim">nnkMutableTy {....deprecated.} = nnkOutTy</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L131" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L131" target="_blank">Edit</a> </dd> </div> <div id="nnkSharedTy"> <dt><pre data-language="nim">nnkSharedTy {....deprecated.} = nnkSinkAsgn</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L132" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L132" target="_blank">Edit</a> </dd> </div> <div id="RoutineNodes"> <dt><pre data-language="nim">RoutineNodes = {nnkProcDef, nnkFuncDef, nnkMethodDef, nnkDo, nnkLambda,
                nnkIteratorDef, nnkTemplateDef, nnkConverterDef, nnkMacroDef}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1209" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1209" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="$-procs-all"> <div id="$,LineInfo"> <dt><pre data-language="nim">proc `$`(arg: LineInfo): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Return a string representation in the form <code><span class="Identifier">filepath</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="Identifier">column</span><span class="Punctuation">)</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L523" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L523" target="_blank">Edit</a> </dd> </div> <div id="$,NimIdent"> <dt><pre data-language="nim">proc `$`(i: NimIdent): string {.magic: "NStrVal", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Use \'strVal\' instead.",
                                raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Use 'strVal' instead. </div> Converts a Nim identifier to a string. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L263" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L263" target="_blank">Edit</a> </dd> </div> <div id="$,NimNode"> <dt><pre data-language="nim">proc `$`(node: NimNode): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Get the string of an identifier node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1399" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1399" target="_blank">Edit</a> </dd> </div> <div id="$,NimSym"> <dt><pre data-language="nim">proc `$`(s: NimSym): string {.magic: "NStrVal", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Use \'strVal\' instead.",
                              raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Use 'strVal' instead. </div> Converts a Nim symbol to a string. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L267" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L267" target="_blank">Edit</a> </dd> </div> </div> <div id="==-procs-all"> <div id="==,NimIdent,NimIdent"> <dt><pre data-language="nim">proc `==`(a, b: NimIdent): bool {.magic: "EqIdent", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Use \'==\' on \'NimNode\' instead.",
                                  raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Use '==' on 'NimNode' instead. </div> Compares two Nim identifiers. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L159" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L159" target="_blank">Edit</a> </dd> </div> <div id="==,NimNode,NimNode"> <dt><pre data-language="nim">proc `==`(a, b: NimNode): bool {.magic: "EqNimrodNode", noSideEffect,
                                 ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Compare two Nim nodes. Return true if nodes are structurally equivalent. This means two independently created nodes can be equal. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L163" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L163" target="_blank">Edit</a> </dd> </div> <div id="==,NimSym,NimSym"> <dt><pre data-language="nim">proc `==`(a, b: NimSym): bool {.magic: "EqNimrodNode", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Use \'==(NimNode, NimNode)\' instead.",
                                raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Use '==(NimNode, NimNode)' instead. </div> Compares two Nim symbols. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L167" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L167" target="_blank">Edit</a> </dd> </div> </div> <div id="[]-procs-all"> <div id="[],NimNode,BackwardsIndex"> <dt><pre data-language="nim">proc `[]`(n: NimNode; i: BackwardsIndex): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Get <code><span class="Identifier">n</span></code>'s <code><span class="Identifier">i</span></code>'th child. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L184" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L184" target="_blank">Edit</a> </dd> </div> <div id="[],NimNode,int"> <dt><pre data-language="nim">proc `[]`(n: NimNode; i: int): NimNode {.magic: "NChild", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Get <code><span class="Identifier">n</span></code>'s <code><span class="Identifier">i</span></code>'th child. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L181" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L181" target="_blank">Edit</a> </dd> </div> <div id="[],NimNode,HSlice[T: Ordinal,U: Ordinal]"> <dt><pre data-language="nim">proc `[]`[T, U: Ordinal](n: NimNode; x: HSlice[T, U]): seq[NimNode]</pre></dt> <dd> Slice operation for NimNode. Returns a seq of child of <code><span class="Identifier">n</span></code> who inclusive range <code><span class="Punctuation">[</span><span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">a</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">n</span><span class="Punctuation">[</span><span class="Identifier">x</span><span class="Operator">.</span><span class="Identifier">b</span><span class="Punctuation">]</span><span class="Punctuation">]</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L190" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L190" target="_blank">Edit</a> </dd> </div> </div> <div id="[]=-procs-all"> <div id="[]=,NimNode,BackwardsIndex,NimNode"> <dt><pre data-language="nim">proc `[]=`(n: NimNode; i: BackwardsIndex; child: NimNode) {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Set <code><span class="Identifier">n</span></code>'s <code><span class="Identifier">i</span></code>'th child to <code><span class="Identifier">child</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L203" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L203" target="_blank">Edit</a> </dd> </div> <div id="[]=,NimNode,int,NimNode"> <dt><pre data-language="nim">proc `[]=`(n: NimNode; i: int; child: NimNode) {.magic: "NSetChild",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Set <code><span class="Identifier">n</span></code>'s <code><span class="Identifier">i</span></code>'th child to <code><span class="Identifier">child</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L199" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L199" target="_blank">Edit</a> </dd> </div> </div> <div id="add-procs-all"> <div id="add,NimNode,NimNode"> <dt><pre data-language="nim">proc add(father, child: NimNode): NimNode {.magic: "NAdd", discardable,
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Adds the <code><span class="Identifier">child</span></code> to the <code><span class="Identifier">father</span></code> node. Returns the father node so that calls can be nested. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L221" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L221" target="_blank">Edit</a> </dd> </div> <div id="add,NimNode,varargs[NimNode]"> <dt><pre data-language="nim">proc add(father: NimNode; children: varargs[NimNode]): NimNode {.
    magic: "NAddMultiple", discardable, noSideEffect, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Adds each child of <code><span class="Identifier">children</span></code> to the <code><span class="Identifier">father</span></code> node. Returns the <code><span class="Identifier">father</span></code> node so that calls can be nested. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L226" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L226" target="_blank">Edit</a> </dd> </div> </div> <div id="addIdentIfAbsent-procs-all"> <div id="addIdentIfAbsent,NimNode,string"> <dt><pre data-language="nim">proc addIdentIfAbsent(dest: NimNode; ident: string) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Add <code><span class="Identifier">ident</span></code> to <code><span class="Identifier">dest</span></code> if it is not present. This is intended for use with pragmas. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1511" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1511" target="_blank">Edit</a> </dd> </div> </div> <div id="addPragma-procs-all"> <div id="addPragma,NimNode,NimNode"> <dt><pre data-language="nim">proc addPragma(someProc, pragma: NimNode) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Adds pragma to routine definition. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1355" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1355" target="_blank">Edit</a> </dd> </div> </div> <div id="astGenRepr-procs-all"> <div id="astGenRepr,NimNode"> <dt><pre data-language="nim">proc astGenRepr(n: NimNode): string {....gcsafe, raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Convert the AST <code><span class="Identifier">n</span></code> to the code required to generate that AST.</p> <p>See also <a href="system.html#repr,T">system: repr</a>, <a title="proc treeRepr(n: NimNode): string" href="#treeRepr,NimNode">treeRepr</a>, and <a title="proc lispRepr(n: NimNode; indented = false): string" href="#lispRepr,NimNode">lispRepr</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L993" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L993" target="_blank">Edit</a> </dd> </div> </div> <div id="basename-procs-all"> <div id="basename,NimNode"> <dt><pre data-language="nim">proc basename(a: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Pull an identifier from prefix/postfix expressions. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1389" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1389" target="_blank">Edit</a> </dd> </div> </div> <div id="basename=-procs-all"> <div id="basename=,NimNode,string"> <dt><pre data-language="nim">proc basename=(a: NimNode; val: string) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1459" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1459" target="_blank">Edit</a> </dd> </div> </div> <div id="bindSym-procs-all"> <div id="bindSym,,BindSymRule"> <dt><pre data-language="nim">proc bindSym(ident: string | NimNode; rule: BindSymRule = brClosed): NimNode {.
    magic: "NBindSym", noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a node that binds <code><span class="Identifier">ident</span></code> to a symbol node. The bound symbol may be an overloaded symbol. if <code><span class="Identifier">ident</span></code> is a NimNode, it must have <code><span class="Identifier">nnkIdent</span></code> kind. If <code><span class="Identifier">rule</span> <span class="Operator">==</span> <span class="Identifier">brClosed</span></code> either an <code><span class="Identifier">nnkClosedSymChoice</span></code> tree is returned or <code><span class="Identifier">nnkSym</span></code> if the symbol is not ambiguous. If <code><span class="Identifier">rule</span> <span class="Operator">==</span> <span class="Identifier">brOpen</span></code> either an <code><span class="Identifier">nnkOpenSymChoice</span></code> tree is returned or <code><span class="Identifier">nnkSym</span></code> if the symbol is not ambiguous. If <code><span class="Identifier">rule</span> <span class="Operator">==</span> <span class="Identifier">brForceOpen</span></code> always an <code><span class="Identifier">nnkOpenSymChoice</span></code> tree is returned even if the symbol is not ambiguous.</p> <p>See the <a href="manual.html#macros-bindsym">manual</a> for more details.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L489" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L489" target="_blank">Edit</a> </dd> </div> </div> <div id="body-procs-all"> <div id="body,NimNode"> <dt><pre data-language="nim">proc body(someProc: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1367" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1367" target="_blank">Edit</a> </dd> </div> </div> <div id="body=-procs-all"> <div id="body=,NimNode,NimNode"> <dt><pre data-language="nim">proc body=(someProc: NimNode; val: NimNode) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1378" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1378" target="_blank">Edit</a> </dd> </div> </div> <div id="boolVal-procs-all"> <div id="boolVal,NimNode"> <dt><pre data-language="nim">proc boolVal(n: NimNode): bool {.noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1523" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1523" target="_blank">Edit</a> </dd> </div> </div> <div id="callsite-procs-all"> <div id="callsite"> <dt><pre data-language="nim">proc callsite(): NimNode {.magic: "NCallSite", ...gcsafe, deprecated: "Deprecated since v0.18.1; use `varargs[untyped]` in the macro prototype instead",
                           raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since v0.18.1; use `varargs[untyped]` in the macro prototype instead </div> Returns the AST of the invocation expression that invoked this macro. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L508" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L508" target="_blank">Edit</a> </dd> </div> </div> <div id="copy-procs-all"> <div id="copy,NimNode"> <dt><pre data-language="nim">proc copy(node: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> An alias for <a href="#copyNimTree,NimNode">copyNimTree</a>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1492" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1492" target="_blank">Edit</a> </dd> </div> </div> <div id="copyChildrenTo-procs-all"> <div id="copyChildrenTo,NimNode,NimNode"> <dt><pre data-language="nim">proc copyChildrenTo(src, dest: NimNode) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Copy all children from <code><span class="Identifier">src</span></code> to <code><span class="Identifier">dest</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1298" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1298" target="_blank">Edit</a> </dd> </div> </div> <div id="copyLineInfo-procs-all"> <div id="copyLineInfo,NimNode,NimNode"> <dt><pre data-language="nim">proc copyLineInfo(arg: NimNode; info: NimNode) {.magic: "NLineInfo",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Copy lineinfo from <code><span class="Identifier">info</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L536" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L536" target="_blank">Edit</a> </dd> </div> </div> <div id="copyNimNode-procs-all"> <div id="copyNimNode,NimNode"> <dt><pre data-language="nim">proc copyNimNode(n: NimNode): NimNode {.magic: "NCopyNimNode", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Creates a new AST node by copying the node <code><span class="Identifier">n</span></code>. Note that unlike <code><span class="Identifier">copyNimTree</span></code>, child nodes of <code><span class="Identifier">n</span></code> are not copied. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">macro foo(x: typed) =
  var s = copyNimNode(x)
  doAssert s.len == 0
  doAssert s.kind == nnkStmtList

foo:
  let x = 12
  echo x</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L404" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L404" target="_blank">Edit</a> </dd> </div> </div> <div id="copyNimTree-procs-all"> <div id="copyNimTree,NimNode"> <dt><pre data-language="nim">proc copyNimTree(n: NimNode): NimNode {.magic: "NCopyNimTree", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Creates a new AST node by recursively copying the node <code><span class="Identifier">n</span></code>. Note that unlike <code><span class="Identifier">copyNimNode</span></code>, this copies <code><span class="Identifier">n</span></code>, the children of <code><span class="Identifier">n</span></code>, etc. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">macro foo(x: typed) =
  var s = copyNimTree(x)
  doAssert s.len == 2
  doAssert s.kind == nnkStmtList

foo:
  let x = 12
  echo x</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L417" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L417" target="_blank">Edit</a> </dd> </div> </div> <div id="del-procs-all"> <div id="del,NimNode,int,int"> <dt><pre data-language="nim">proc del(father: NimNode; idx = 0; n = 1) {.magic: "NDel", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Deletes <code><span class="Identifier">n</span></code> children of <code><span class="Identifier">father</span></code> starting at index <code><span class="Identifier">idx</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L231" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L231" target="_blank">Edit</a> </dd> </div> </div> <div id="eqIdent-procs-all"> <div id="eqIdent,NimNode,NimNode"> <dt><pre data-language="nim">proc eqIdent(a: NimNode; b: NimNode): bool {.magic: "EqIdent", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Style insensitive comparison. <code><span class="Identifier">a</span></code> and <code><span class="Identifier">b</span></code> can be an identifier or a symbol. Both may be wrapped in an export marker (<code><span class="Identifier">nnkPostfix</span></code>) or quoted with backticks (<code><span class="Identifier">nnkAccQuoted</span></code>), these nodes will be unwrapped. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L922" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L922" target="_blank">Edit</a> </dd> </div> <div id="eqIdent,NimNode,string"> <dt><pre data-language="nim">proc eqIdent(a: NimNode; b: string): bool {.magic: "EqIdent", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Style insensitive comparison. <code><span class="Identifier">a</span></code> can be an identifier or a symbol. <code><span class="Identifier">a</span></code> may be wrapped in an export marker (<code><span class="Identifier">nnkPostfix</span></code>) or quoted with backticks (<code><span class="Identifier">nnkAccQuoted</span></code>), these nodes will be unwrapped. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L910" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L910" target="_blank">Edit</a> </dd> </div> <div id="eqIdent,string,NimNode"> <dt><pre data-language="nim">proc eqIdent(a: string; b: NimNode): bool {.magic: "EqIdent", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Style insensitive comparison. <code><span class="Identifier">b</span></code> can be an identifier or a symbol. <code><span class="Identifier">b</span></code> may be wrapped in an export marker (<code><span class="Identifier">nnkPostfix</span></code>) or quoted with backticks (<code><span class="Identifier">nnkAccQuoted</span></code>), these nodes will be unwrapped. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L916" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L916" target="_blank">Edit</a> </dd> </div> <div id="eqIdent,string,string"> <dt><pre data-language="nim">proc eqIdent(a: string; b: string): bool {.magic: "EqIdent", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Style insensitive comparison. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L907" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L907" target="_blank">Edit</a> </dd> </div> </div> <div id="error-procs-all"> <div id="error,string,NimNode"> <dt><pre data-language="nim">proc error(msg: string; n: NimNode = nil) {.magic: "NError", ...gcsafe, raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Writes an error message at compile time. The optional <code><span class="Identifier">n</span><span class="Punctuation">:</span> <span class="Identifier">NimNode</span></code> parameter is used as the source for file and line number information in the compilation error message. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L430" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L430" target="_blank">Edit</a> </dd> </div> </div> <div id="expectIdent-procs-all"> <div id="expectIdent,NimNode,string"> <dt><pre data-language="nim">proc expectIdent(n: NimNode; name: string) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Check that <code><span class="Identifier">eqIdent</span><span class="Punctuation">(</span><span class="Identifier">n</span><span class="Punctuation">,</span><span class="Identifier">name</span><span class="Punctuation">)</span></code> holds true. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1496" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1496" target="_blank">Edit</a> </dd> </div> </div> <div id="expectKind-procs-all"> <div id="expectKind,NimNode,NimNodeKind"> <dt><pre data-language="nim">proc expectKind(n: NimNode; k: NimNodeKind) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Checks that <code><span class="Identifier">n</span></code> is of kind <code><span class="Identifier">k</span></code>. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L681" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L681" target="_blank">Edit</a> </dd> </div> <div id="expectKind,NimNode,set[NimNodeKind]"> <dt><pre data-language="nim">proc expectKind(n: NimNode; k: set[NimNodeKind]) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Checks that <code><span class="Identifier">n</span></code> is of kind <code><span class="Identifier">k</span></code>. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check the AST that is passed to them. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1215" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1215" target="_blank">Edit</a> </dd> </div> </div> <div id="expectLen-procs-all"> <div id="expectLen,NimNode,int"> <dt><pre data-language="nim">proc expectLen(n: NimNode; len: int) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Checks that <code><span class="Identifier">n</span></code> has exactly <code><span class="Identifier">len</span></code> children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L693" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L693" target="_blank">Edit</a> </dd> </div> <div id="expectLen,NimNode,int,int"> <dt><pre data-language="nim">proc expectLen(n: NimNode; min, max: int) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Checks that <code><span class="Identifier">n</span></code> has a number of children in the range <code><span class="Identifier">min</span><span class="Operator">..</span><span class="Identifier">max</span></code>. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L699" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L699" target="_blank">Edit</a> </dd> </div> </div> <div id="expectMinLen-procs-all"> <div id="expectMinLen,NimNode,int"> <dt><pre data-language="nim">proc expectMinLen(n: NimNode; min: int) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Checks that <code><span class="Identifier">n</span></code> has at least <code><span class="Identifier">min</span></code> children. If this is not the case, compilation aborts with an error message. This is useful for writing macros that check its number of arguments. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L687" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L687" target="_blank">Edit</a> </dd> </div> </div> <div id="extractDocCommentsAndRunnables-procs-all"> <div id="extractDocCommentsAndRunnables,NimNode"> <dt><pre data-language="nim">proc extractDocCommentsAndRunnables(n: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <p>returns a <code><span class="Identifier">nnkStmtList</span></code> containing the top-level doc comments and runnableExamples in <code><span class="Identifier">a</span></code>, stopping at the first child that is neither. Example:</p> 
<pre class="listing" data-language="nim">import std/macros
macro transf(a): untyped =
  result = quote do:
    proc fun2*() = discard
  let header = extractDocCommentsAndRunnables(a.body)
  # correct usage: rest is appended
  result.body = header
  result.body.add quote do: discard # just an example
  # incorrect usage: nesting inside a nnkStmtList:
  # result.body = quote do: (`header`; discard)

proc fun*() {.transf.} =
  ## first comment
  runnableExamples: discard
  runnableExamples: discard
  ## last comment
  discard # first statement after doc comments + runnableExamples
  ## not docgen'd</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1771" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1771" target="_blank">Edit</a> </dd> </div> </div> <div id="floatVal-procs-all"> <div id="floatVal,NimNode"> <dt><pre data-language="nim">proc floatVal(n: NimNode): BiggestFloat {.magic: "NFloatVal", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns a float from any floating point literal. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L240" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L240" target="_blank">Edit</a> </dd> </div> </div> <div id="floatVal=-procs-all"> <div id="floatVal=,NimNode,BiggestFloat"> <dt><pre data-language="nim">proc floatVal=(n: NimNode; val: BiggestFloat) {.magic: "NSetFloatVal",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L373" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L373" target="_blank">Edit</a> </dd> </div> </div> <div id="genSym-procs-all"> <div id="genSym,NimSymKind,string"> <dt><pre data-language="nim">proc genSym(kind: NimSymKind = nskLet; ident = ""): NimNode {.magic: "NGenSym",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Generates a fresh symbol that is guaranteed to be unique. The symbol needs to occur in a declaration context. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L503" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L503" target="_blank">Edit</a> </dd> </div> </div> <div id="getAlign-procs-all"> <div id="getAlign,NimNode"> <dt><pre data-language="nim">proc getAlign(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ...raises: [],
                                   tags: [], forbids: [].}</pre></dt> <dd> Returns the same result as <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">alignof</span></code> if the alignment is known by the Nim compiler. It works on <code><span class="Identifier">NimNode</span></code> for use in macro context. Returns a negative value if the Nim compiler does not know the alignment. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1756" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1756" target="_blank">Edit</a> </dd> </div> </div> <div id="getAst-procs-all"> <div id="getAst,untyped"> <dt><pre data-language="nim">proc getAst(macroOrTemplate: untyped): NimNode {.magic: "ExpandToAst",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Obtains the AST nodes returned from a macro or template invocation. See also <code><span class="Identifier">genasts</span><span class="Operator">.</span><span class="Identifier">genAst</span></code>. Example:</p> 
<pre class="listing" data-language="nim">macro FooMacro() =
  var ast = getAst(BarTemplate())</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L589" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L589" target="_blank">Edit</a> </dd> </div> </div> <div id="getImpl-procs-all"> <div id="getImpl,NimSym"> <dt><pre data-language="nim">proc getImpl(s: NimSym): NimNode {.magic: "GetImpl", noSideEffect, ...deprecated: "use `getImpl: NimNode -&gt; NimNode` instead",
                                   raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> use `getImpl: NimNode -&gt; NimNode` instead </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L261" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L261" target="_blank">Edit</a> </dd> </div> <div id="getImpl,NimNode"> <dt><pre data-language="nim">proc getImpl(symbol: NimNode): NimNode {.magic: "GetImpl", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns a copy of the declaration of a symbol or <code><span class="Keyword">nil</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L245" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L245" target="_blank">Edit</a> </dd> </div> </div> <div id="getImplTransformed-procs-all"> <div id="getImplTransformed,NimNode"> <dt><pre data-language="nim">proc getImplTransformed(symbol: NimNode): NimNode {.magic: "GetImplTransf",
    noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> For a typed proc returns the AST after transformation pass; this is useful for debugging how the compiler transforms code (e.g.: <code><span class="Keyword">defer</span></code>, <code><span class="Keyword">for</span></code>) but note that code transformations are implementation dependent and subject to change. See an example in <code><span class="Identifier">tests</span><span class="Operator">/</span><span class="Identifier">macros</span><span class="Operator">/</span><span class="Identifier">tmacros_various</span><span class="Operator">.</span><span class="Identifier">nim</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L274" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L274" target="_blank">Edit</a> </dd> </div> </div> <div id="getOffset-procs-all"> <div id="getOffset,NimNode"> <dt><pre data-language="nim">proc getOffset(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ...raises: [],
                                    tags: [], forbids: [].}</pre></dt> <dd> Returns the same result as <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">offsetof</span></code> if the offset is known by the Nim compiler. It expects a resolved symbol node from a field of a type. Therefore it only requires one argument instead of two. Returns a negative value if the Nim compiler does not know the offset. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1761" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1761" target="_blank">Edit</a> </dd> </div> </div> <div id="getProjectPath-procs-all"> <div id="getProjectPath"> <dt><pre data-language="nim">proc getProjectPath(): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Returns the path to the currently compiling project.</p> <p>This is not to be confused with <a href="system.html#currentSourcePath.t">system.currentSourcePath</a> which returns the path of the source file containing that template call.</p> <p>For example, assume a <code><span class="Identifier">dir1</span><span class="Operator">/</span><span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">nim</span></code> that imports a <code><span class="Identifier">dir2</span><span class="Operator">/</span><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code>, have the <code><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code> print out both <code><span class="Identifier">getProjectPath</span></code> and <code><span class="Identifier">currentSourcePath</span></code> outputs.</p> <p>Now when <code><span class="Identifier">foo</span><span class="Operator">.</span><span class="Identifier">nim</span></code> is compiled, the <code><span class="Identifier">getProjectPath</span></code> from <code><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code> will return the <code><span class="Identifier">dir1</span><span class="Operator">/</span></code> path, while the <code><span class="Identifier">currentSourcePath</span></code> will return the path to the <code><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code> source file.</p> <p>Now when <code><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code> is compiled directly, the <code><span class="Identifier">getProjectPath</span></code> will now return the <code><span class="Identifier">dir2</span><span class="Operator">/</span></code> path, and the <code><span class="Identifier">currentSourcePath</span></code> will still return the same path, the path to the <code><span class="Identifier">bar</span><span class="Operator">.</span><span class="Identifier">nim</span></code> source file.</p> <p>The path returned by this proc is set at compile time.</p> <p>See also:</p> <ul class="simple">
<li><a href="os.html#getCurrentDir">getCurrentDir proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1727" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1727" target="_blank">Edit</a> </dd> </div> </div> <div id="getSize-procs-all"> <div id="getSize,NimNode"> <dt><pre data-language="nim">proc getSize(arg: NimNode): int {.magic: "NSizeOf", noSideEffect, ...raises: [],
                                  tags: [], forbids: [].}</pre></dt> <dd> Returns the same result as <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">sizeof</span></code> if the size is known by the Nim compiler. Returns a negative value if the Nim compiler does not know the size. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1752" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1752" target="_blank">Edit</a> </dd> </div> </div> <div id="getType-procs-all"> <div id="getType,NimNode"> <dt><pre data-language="nim">proc getType(n: NimNode): NimNode {.magic: "NGetType", noSideEffect, ...raises: [],
                                    tags: [], forbids: [].}</pre></dt> <dd> With 'getType' you can access the node's <span id="type_1">type</span>. A Nim type is mapped to a Nim AST too, so it's slightly confusing but it means the same API can be used to traverse types. Recursive types are flattened for you so there is no danger of infinite recursions during traversal. To resolve recursive types, you have to call 'getType' again. To see what kind of type it is, call <code><span class="Identifier">typeKind</span></code> on getType's result. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L296" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L296" target="_blank">Edit</a> </dd> </div> <div id="getType,typedesc"> <dt><pre data-language="nim">proc getType(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
                                     ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Version of <code><span class="Identifier">getType</span></code> which takes a <code><span class="Identifier">typedesc</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L304" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L304" target="_blank">Edit</a> </dd> </div> </div> <div id="getTypeImpl-procs-all"> <div id="getTypeImpl,NimNode"> <dt><pre data-language="nim">proc getTypeImpl(n: NimNode): NimNode {.magic: "NGetType", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns the <span id="type_2">type</span> of a node in a form matching the implementation of the type. Any intermediate aliases are expanded to arrive at the final type implementation. You can instead use <code><span class="Identifier">getImpl</span></code> on a symbol if you want to find the intermediate aliases. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type
  Vec[N: static[int], T] = object
    arr: array[N, T]
  Vec4[T] = Vec[4, T]
  Vec4f = Vec4[float32]
var a: Vec4f
var b: Vec4[float32]
var c: Vec[4, float32]
macro dumpTypeImpl(x: typed): untyped =
  newLit(x.getTypeImpl.repr)
let t = """
object
  arr: array[0 .. 3, float32]
"""
doAssert(dumpTypeImpl(a) == t)
doAssert(dumpTypeImpl(b) == t)
doAssert(dumpTypeImpl(c) == t)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L332" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L332" target="_blank">Edit</a> </dd> </div> <div id="getTypeImpl,typedesc"> <dt><pre data-language="nim">proc getTypeImpl(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Version of <code><span class="Identifier">getTypeImpl</span></code> which takes a <code><span class="Identifier">typedesc</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L369" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L369" target="_blank">Edit</a> </dd> </div> </div> <div id="getTypeInst-procs-all"> <div id="getTypeInst,NimNode"> <dt><pre data-language="nim">proc getTypeInst(n: NimNode): NimNode {.magic: "NGetType", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns the <span id="type_3">type</span> of a node in a form matching the way the type instance was declared in the code. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type
  Vec[N: static[int], T] = object
    arr: array[N, T]
  Vec4[T] = Vec[4, T]
  Vec4f = Vec4[float32]
var a: Vec4f
var b: Vec4[float32]
var c: Vec[4, float32]
macro dumpTypeInst(x: typed): untyped =
  newLit(x.getTypeInst.repr)
doAssert(dumpTypeInst(a) == "Vec4f")
doAssert(dumpTypeInst(b) == "Vec4[float32]")
doAssert(dumpTypeInst(c) == "Vec[4, float32]")</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L311" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L311" target="_blank">Edit</a> </dd> </div> <div id="getTypeInst,typedesc"> <dt><pre data-language="nim">proc getTypeInst(n: typedesc): NimNode {.magic: "NGetType", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Version of <code><span class="Identifier">getTypeInst</span></code> which takes a <code><span class="Identifier">typedesc</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L329" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L329" target="_blank">Edit</a> </dd> </div> </div> <div id="hasArgOfName-procs-all"> <div id="hasArgOfName,NimNode,string"> <dt><pre data-language="nim">proc hasArgOfName(params: NimNode; name: string): bool {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Search <code><span class="Identifier">nnkFormalParams</span></code> for an argument. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1503" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1503" target="_blank">Edit</a> </dd> </div> </div> <div id="hint-procs-all"> <div id="hint,string,NimNode"> <dt><pre data-language="nim">proc hint(msg: string; n: NimNode = nil) {.magic: "NHint", ...gcsafe, raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Writes a hint message at compile time. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L438" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L438" target="_blank">Edit</a> </dd> </div> </div> <div id="ident-procs-all"> <div id="ident,NimNode"> <dt><pre data-language="nim">proc ident(n: NimNode): NimIdent {.magic: "NIdent", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; All functionality is defined on \'NimNode\'.",
                                   raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; All functionality is defined on 'NimNode'. </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L255" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L255" target="_blank">Edit</a> </dd> </div> <div id="ident,string"> <dt><pre data-language="nim">proc ident(name: string): NimNode {.magic: "StrToIdent", noSideEffect,
                                    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create a new ident node from a string. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L474" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L474" target="_blank">Edit</a> </dd> </div> </div> <div id="ident=-procs-all"> <div id="ident=,NimNode,NimIdent"> <dt><pre data-language="nim">proc ident=(n: NimNode; val: NimIdent) {.magic: "NSetIdent", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Generate a new \'NimNode\' with \'ident(string)\' instead.",
    raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Generate a new 'NimNode' with 'ident(string)' instead. </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L380" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L380" target="_blank">Edit</a> </dd> </div> </div> <div id="infix-procs-all"> <div id="infix,NimNode,string,NimNode"> <dt><pre data-language="nim">proc infix(a: NimNode; op: string; b: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1476" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1476" target="_blank">Edit</a> </dd> </div> </div> <div id="insert-procs-all"> <div id="insert,NimNode,int,NimNode"> <dt><pre data-language="nim">proc insert(a: NimNode; pos: int; b: NimNode) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Insert node <code><span class="Identifier">b</span></code> into node <code><span class="Identifier">a</span></code> at <code><span class="Identifier">pos</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1444" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1444" target="_blank">Edit</a> </dd> </div> </div> <div id="internalErrorFlag-procs-all"> <div id="internalErrorFlag"> <dt><pre data-language="nim">proc internalErrorFlag(): string {.magic: "NError", noSideEffect, ...raises: [],
                                   tags: [], forbids: [].}</pre></dt> <dd> Some builtins set an error flag. This is then turned into a proper exception. <strong>Note</strong>: Ordinary application code should not call this. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L569" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L569" target="_blank">Edit</a> </dd> </div> </div> <div id="intVal-procs-all"> <div id="intVal,NimNode"> <dt><pre data-language="nim">proc intVal(n: NimNode): BiggestInt {.magic: "NIntVal", noSideEffect,
                                      ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns an integer value from any integer literal or enum field symbol. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L237" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L237" target="_blank">Edit</a> </dd> </div> </div> <div id="intVal=-procs-all"> <div id="intVal=,NimNode,BiggestInt"> <dt><pre data-language="nim">proc intVal=(n: NimNode; val: BiggestInt) {.magic: "NSetIntVal", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L372" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L372" target="_blank">Edit</a> </dd> </div> </div> <div id="isExported-procs-all"> <div id="isExported,NimNode"> <dt><pre data-language="nim">proc isExported(n: NimNode): bool {.noSideEffect, ...raises: [], tags: [],
                                    forbids: [].}</pre></dt> <dd> Returns whether the symbol is exported or not. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1768" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1768" target="_blank">Edit</a> </dd> </div> </div> <div id="isInstantiationOf-procs-all"> <div id="isInstantiationOf,NimNode,NimNode"> <dt><pre data-language="nim">proc isInstantiationOf(instanceProcSym, genProcSym: NimNode): bool {.
    magic: "SymIsInstantiationOf", noSideEffect, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Checks if a proc symbol is an instance of the generic proc symbol. Useful to check proc symbols against generic symbols returned by <code><span class="Identifier">bindSym</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L291" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L291" target="_blank">Edit</a> </dd> </div> </div> <div id="kind-procs-all"> <div id="kind,NimNode"> <dt><pre data-language="nim">proc kind(n: NimNode): NimNodeKind {.magic: "NKind", noSideEffect, ...raises: [],
                                     tags: [], forbids: [].}</pre></dt> <dd> Returns the <code><span class="Identifier">kind</span></code> of the node <code><span class="Identifier">n</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L234" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L234" target="_blank">Edit</a> </dd> </div> </div> <div id="last-procs-all"> <div id="last,NimNode"> <dt><pre data-language="nim">proc last(node: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Return the last item in nodes children. Same as <code><span class="Identifier">node</span><span class="Punctuation">[</span><span class="Operator">^</span><span class="DecNumber">1</span><span class="Punctuation">]</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1204" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1204" target="_blank">Edit</a> </dd> </div> </div> <div id="len-procs-all"> <div id="len,NimNode"> <dt><pre data-language="nim">proc len(n: NimNode): int {.magic: "NLen", noSideEffect, ...raises: [], tags: [],
                            forbids: [].}</pre></dt> <dd> Returns the number of children of <code><span class="Identifier">n</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L178" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L178" target="_blank">Edit</a> </dd> </div> </div> <div id="lineInfo-procs-all"> <div id="lineInfo,NimNode"> <dt><pre data-language="nim">proc lineInfo(arg: NimNode): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Return line info in the form <code><span class="Identifier">filepath</span><span class="Punctuation">(</span><span class="Identifier">line</span><span class="Punctuation">,</span> <span class="Identifier">column</span><span class="Punctuation">)</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L559" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L559" target="_blank">Edit</a> </dd> </div> </div> <div id="lineInfoObj-procs-all"> <div id="lineInfoObj,NimNode"> <dt><pre data-language="nim">proc lineInfoObj(n: NimNode): LineInfo {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns <code><span class="Identifier">LineInfo</span></code> of <code><span class="Identifier">n</span></code>, using absolute path for <code><span class="Identifier">filename</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L555" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L555" target="_blank">Edit</a> </dd> </div> </div> <div id="lispRepr-procs-all"> <div id="lispRepr,NimNode"> <dt><pre data-language="nim">proc lispRepr(n: NimNode; indented = false): string {....gcsafe, raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Convert the AST <code><span class="Identifier">n</span></code> to a human-readable lisp-like string.</p> <p>See also <code><span class="Identifier">repr</span></code>, <a title="proc treeRepr(n: NimNode): string" href="#treeRepr,NimNode">treeRepr</a>, and <a title="proc astGenRepr(n: NimNode): string" href="#astGenRepr,NimNode">astGenRepr</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L986" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L986" target="_blank">Edit</a> </dd> </div> </div> <div id="name-procs-all"> <div id="name,NimNode"> <dt><pre data-language="nim">proc name(someProc: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1306" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1306" target="_blank">Edit</a> </dd> </div> </div> <div id="name=-procs-all"> <div id="name=,NimNode,NimNode"> <dt><pre data-language="nim">proc name=(someProc: NimNode; val: NimNode) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1317" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1317" target="_blank">Edit</a> </dd> </div> </div> <div id="nestList-procs-all"> <div id="nestList,NimNode,NimNode"> <dt><pre data-language="nim">proc nestList(op: NimNode; pack: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Nests the list <code><span class="Identifier">pack</span></code> into a tree of call expressions: <code><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">]</span></code> is transformed into <code><span class="Identifier">op</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">op</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code>. This is also known as fold expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L889" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L889" target="_blank">Edit</a> </dd> </div> <div id="nestList,NimNode,NimNode,NimNode"> <dt><pre data-language="nim">proc nestList(op: NimNode; pack: NimNode; init: NimNode): NimNode {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Nests the list <code><span class="Identifier">pack</span></code> into a tree of call expressions: <code><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">b</span><span class="Punctuation">,</span> <span class="Identifier">c</span><span class="Punctuation">]</span></code> is transformed into <code><span class="Identifier">op</span><span class="Punctuation">(</span><span class="Identifier">a</span><span class="Punctuation">,</span> <span class="Identifier">op</span><span class="Punctuation">(</span><span class="Identifier">c</span><span class="Punctuation">,</span> <span class="Identifier">d</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code>. This is also known as fold expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L899" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L899" target="_blank">Edit</a> </dd> </div> </div> <div id="newAssignment-procs-all"> <div id="newAssignment,NimNode,NimNode"> <dt><pre data-language="nim">proc newAssignment(lhs, rhs: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1156" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1156" target="_blank">Edit</a> </dd> </div> </div> <div id="newBlockStmt-procs-all"> <div id="newBlockStmt,NimNode"> <dt><pre data-language="nim">proc newBlockStmt(body: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create a new block: stmt. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1137" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1137" target="_blank">Edit</a> </dd> </div> <div id="newBlockStmt,NimNode,NimNode"> <dt><pre data-language="nim">proc newBlockStmt(label, body: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Create a new block statement with label. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1133" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1133" target="_blank">Edit</a> </dd> </div> </div> <div id="newCall-procs-all"> <div id="newCall,NimIdent,varargs[NimNode]"> <dt><pre data-language="nim">proc newCall(theProc: NimIdent; args: varargs[NimNode]): NimNode {....deprecated: "Deprecated since v0.18.1; use \'newCall(string, ...)\' or \'newCall(NimNode, ...)\' instead",
    raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since v0.18.1; use 'newCall(string, ...)' or 'newCall(NimNode, ...)' instead </div> Produces a new call node. <code><span class="Identifier">theProc</span></code> is the proc that is called with the arguments <code><span class="Identifier">args</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">]</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L721" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L721" target="_blank">Edit</a> </dd> </div> <div id="newCall,NimNode,varargs[NimNode]"> <dt><pre data-language="nim">proc newCall(theProc: NimNode; args: varargs[NimNode]): NimNode {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Produces a new call node. <code><span class="Identifier">theProc</span></code> is the proc that is called with the arguments <code><span class="Identifier">args</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">]</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L712" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L712" target="_blank">Edit</a> </dd> </div> <div id="newCall,string,varargs[NimNode]"> <dt><pre data-language="nim">proc newCall(theProc: string; args: varargs[NimNode]): NimNode {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Produces a new call node. <code><span class="Identifier">theProc</span></code> is the proc that is called with the arguments <code><span class="Identifier">args</span><span class="Punctuation">[</span><span class="FloatNumber">0.</span><span class="Operator">.</span><span class="Punctuation">]</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L731" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L731" target="_blank">Edit</a> </dd> </div> </div> <div id="newColonExpr-procs-all"> <div id="newColonExpr,NimNode,NimNode"> <dt><pre data-language="nim">proc newColonExpr(a, b: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create new colon expression. newColonExpr(a, b) -&gt; <code><span class="Identifier">a</span><span class="Punctuation">:</span> <span class="Identifier">b</span></code> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1164" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1164" target="_blank">Edit</a> </dd> </div> </div> <div id="newCommentStmtNode-procs-all"> <div id="newCommentStmtNode,string"> <dt><pre data-language="nim">proc newCommentStmtNode(s: string): NimNode {.noSideEffect, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> Creates a comment statement node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L446" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L446" target="_blank">Edit</a> </dd> </div> </div> <div id="newConstStmt-procs-all"> <div id="newConstStmt,NimNode,NimNode"> <dt><pre data-language="nim">proc newConstStmt(name, value: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Create a new const stmt. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1151" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1151" target="_blank">Edit</a> </dd> </div> </div> <div id="newDotExpr-procs-all"> <div id="newDotExpr,NimNode,NimNode"> <dt><pre data-language="nim">proc newDotExpr(a, b: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create new dot expression. a.dot(b) -&gt; <code><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">b</span></code> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1159" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1159" target="_blank">Edit</a> </dd> </div> </div> <div id="newEmptyNode-procs-all"> <div id="newEmptyNode"> <dt><pre data-language="nim">proc newEmptyNode(): NimNode {.noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create a new empty node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1116" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1116" target="_blank">Edit</a> </dd> </div> </div> <div id="newEnum-procs-all"> <div id="newEnum,NimNode,openArray[NimNode],bool,bool"> <dt><pre data-language="nim">proc newEnum(name: NimNode; fields: openArray[NimNode]; public, pure: bool): NimNode {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new enum. <code><span class="Identifier">name</span></code> must be an ident. Fields are allowed to be either idents or EnumFieldDef:</p> 
<pre class="listing" data-language="nim">newEnum(
  name    = ident("Colors"),
  fields  = [ident("Blue"), ident("Red")],
  public  = true, pure = false)

# type Colors* = Blue Red</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1256" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1256" target="_blank">Edit</a> </dd> </div> </div> <div id="newFloatLitNode-procs-all"> <div id="newFloatLitNode,BiggestFloat"> <dt><pre data-language="nim">proc newFloatLitNode(f: BiggestFloat): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Creates a float literal node from <code><span class="Identifier">f</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L456" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L456" target="_blank">Edit</a> </dd> </div> </div> <div id="newIdentDefs-procs-all"> <div id="newIdentDefs,NimNode,NimNode"> <dt><pre data-language="nim">proc newIdentDefs(name, kind: NimNode; default = newEmptyNode()): NimNode {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new <code><span class="Identifier">nnkIdentDefs</span></code> node of a specific kind and value.</p> <p><code><span class="Identifier">nnkIdentDefs</span></code> need to have at least three children, but they can have more: first comes a list of identifiers followed by a type and value nodes. This helper proc creates a three node subtree, the first subnode being a single identifier name. Both the <code><span class="Identifier">kind</span></code> node and <code><span class="Identifier">default</span></code> (value) nodes may be empty depending on where the <code><span class="Identifier">nnkIdentDefs</span></code> appears: tuple or object definitions will have an empty <code><span class="Identifier">default</span></code> node, <code><span class="Keyword">let</span></code> or <code><span class="Keyword">var</span></code> blocks may have an empty <code><span class="Identifier">kind</span></code> node if the identifier is being assigned a value. Example:</p> 
<pre class="listing" data-language="nim">var varSection = newNimNode(nnkVarSection).add(
  newIdentDefs(ident("a"), ident("string")),
  newIdentDefs(ident("b"), newEmptyNode(), newLit(3)))
# --&gt; var
#       a: string
#       b = 3</pre> <p>If you need to create multiple identifiers you need to use the lower level <code><span class="Identifier">newNimNode</span></code>:</p> 
<pre class="listing" data-language="nim">result = newNimNode(nnkIdentDefs).add(
  ident("a"), ident("b"), ident("c"), ident("string"),
    newStrLitNode("Hello"))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1169" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1169" target="_blank">Edit</a> </dd> </div> </div> <div id="newIdentNode-procs-all"> <div id="newIdentNode,NimIdent"> <dt><pre data-language="nim">proc newIdentNode(i: NimIdent): NimNode {....deprecated: "use ident(string)",
    raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> use ident(string) </div> Creates an identifier node from <code><span class="Identifier">i</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L463" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L463" target="_blank">Edit</a> </dd> </div> <div id="newIdentNode,string"> <dt><pre data-language="nim">proc newIdentNode(i: string): NimNode {.magic: "StrToIdent", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Creates an identifier node from <code><span class="Identifier">i</span></code>. It is simply an alias for <code><span class="Identifier">ident</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">)</span></code>. Use that, it's shorter. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L470" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L470" target="_blank">Edit</a> </dd> </div> </div> <div id="newIfStmt-procs-all"> <div id="newIfStmt,varargs[tuple[NimNode,NimNode]]"> <dt><pre data-language="nim">proc newIfStmt(branches: varargs[tuple[cond, body: NimNode]]): NimNode {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Constructor for <code><span class="Keyword">if</span></code> statements.</p> 
<pre class="listing" data-language="nim">newIfStmt(
  (Ident, StmtList),
  ...
)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1242" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1242" target="_blank">Edit</a> </dd> </div> </div> <div id="newIntLitNode-procs-all"> <div id="newIntLitNode,BiggestInt"> <dt><pre data-language="nim">proc newIntLitNode(i: BiggestInt): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Creates an int literal node from <code><span class="Identifier">i</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L451" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L451" target="_blank">Edit</a> </dd> </div> </div> <div id="newLetStmt-procs-all"> <div id="newLetStmt,NimNode,NimNode"> <dt><pre data-language="nim">proc newLetStmt(name, value: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Create a new let stmt. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1146" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1146" target="_blank">Edit</a> </dd> </div> </div> <div id="newLit-procs-all"> <div id="newLit"> <dt><pre data-language="nim">proc newLit(arg: enum): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L826" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L826" target="_blank">Edit</a> </dd> </div> <div id="newLit_2"> <dt><pre data-language="nim">proc newLit(arg: object): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L837" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L837" target="_blank">Edit</a> </dd> </div> <div id="newLit,ref."> <dt><pre data-language="nim">proc newLit(arg: ref object): NimNode</pre></dt> <dd> produces a new ref type literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L842" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L842" target="_blank">Edit</a> </dd> </div> <div id="newLit,bool"> <dt><pre data-language="nim">proc newLit(b: bool): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new boolean literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L794" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L794" target="_blank">Edit</a> </dd> </div> <div id="newLit,char"> <dt><pre data-language="nim">proc newLit(c: char): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new character literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L739" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L739" target="_blank">Edit</a> </dd> </div> <div id="newLit,float32"> <dt><pre data-language="nim">proc newLit(f: float32): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new float literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L810" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L810" target="_blank">Edit</a> </dd> </div> <div id="newLit,float64"> <dt><pre data-language="nim">proc newLit(f: float64): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new float literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L815" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L815" target="_blank">Edit</a> </dd> </div> <div id="newLit,int"> <dt><pre data-language="nim">proc newLit(i: int): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L744" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L744" target="_blank">Edit</a> </dd> </div> <div id="newLit,int8"> <dt><pre data-language="nim">proc newLit(i: int8): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L749" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L749" target="_blank">Edit</a> </dd> </div> <div id="newLit,int16"> <dt><pre data-language="nim">proc newLit(i: int16): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L754" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L754" target="_blank">Edit</a> </dd> </div> <div id="newLit,int32"> <dt><pre data-language="nim">proc newLit(i: int32): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L759" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L759" target="_blank">Edit</a> </dd> </div> <div id="newLit,int64"> <dt><pre data-language="nim">proc newLit(i: int64): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L764" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L764" target="_blank">Edit</a> </dd> </div> <div id="newLit,uint"> <dt><pre data-language="nim">proc newLit(i: uint): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new unsigned integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L769" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L769" target="_blank">Edit</a> </dd> </div> <div id="newLit,uint8"> <dt><pre data-language="nim">proc newLit(i: uint8): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new unsigned integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L774" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L774" target="_blank">Edit</a> </dd> </div> <div id="newLit,uint16"> <dt><pre data-language="nim">proc newLit(i: uint16): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new unsigned integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L779" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L779" target="_blank">Edit</a> </dd> </div> <div id="newLit,uint32"> <dt><pre data-language="nim">proc newLit(i: uint32): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new unsigned integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L784" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L784" target="_blank">Edit</a> </dd> </div> <div id="newLit,uint64"> <dt><pre data-language="nim">proc newLit(i: uint64): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new unsigned integer literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L789" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L789" target="_blank">Edit</a> </dd> </div> <div id="newLit,string"> <dt><pre data-language="nim">proc newLit(s: string): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new string literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L798" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L798" target="_blank">Edit</a> </dd> </div> <div id="newLit,array[N,T]"> <dt><pre data-language="nim">proc newLit[N, T](arg: array[N, T]): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L832" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L832" target="_blank">Edit</a> </dd> </div> <div id="newLit,T"> <dt><pre data-language="nim">proc newLit[T: tuple](arg: T): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L835" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L835" target="_blank">Edit</a> </dd> </div> <div id="newLit,seq[T]"> <dt><pre data-language="nim">proc newLit[T](arg: seq[T]): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L833" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L833" target="_blank">Edit</a> </dd> </div> <div id="newLit,set[T]"> <dt><pre data-language="nim">proc newLit[T](s: set[T]): NimNode</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L834" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L834" target="_blank">Edit</a> </dd> </div> </div> <div id="newNilLit-procs-all"> <div id="newNilLit"> <dt><pre data-language="nim">proc newNilLit(): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> New nil literal shortcut. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1200" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1200" target="_blank">Edit</a> </dd> </div> </div> <div id="newNimNode-procs-all"> <div id="newNimNode,NimNodeKind,NimNode"> <dt><pre data-language="nim">proc newNimNode(kind: NimNodeKind; lineInfoFrom: NimNode = nil): NimNode {.
    magic: "NNewNimNode", noSideEffect, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new AST node of the specified kind.</p> <p>The <code><span class="Identifier">lineInfoFrom</span></code> parameter is used for line information when the produced code crashes. You should ensure that it is set to a node that you are transforming.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L395" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L395" target="_blank">Edit</a> </dd> </div> </div> <div id="newPar-procs-all"> <div id="newPar,NimNode"> <dt><pre data-language="nim">proc newPar(exprs: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Create a new parentheses-enclosed expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1124" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1124" target="_blank">Edit</a> </dd> </div> <div id="newPar,varargs[NimNode]"> <dt><pre data-language="nim">proc newPar(exprs: varargs[NimNode]): NimNode {....deprecated: "don\'t use newPar/nnkPar to construct tuple expressions; use nnkTupleConstr instead",
    raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> don't use newPar/nnkPar to construct tuple expressions; use nnkTupleConstr instead </div> Create a new parentheses-enclosed expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1128" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1128" target="_blank">Edit</a> </dd> </div> </div> <div id="newProc-procs-all"> <div id="newProc,openArray[NimNode],NimNode,NimNode"> <dt><pre data-language="nim">proc newProc(name = newEmptyNode();
             params: openArray[NimNode] = [newEmptyNode()];
             body: NimNode = newStmtList(); procType = nnkProcDef;
             pragmas: NimNode = newEmptyNode()): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Shortcut for creating a new proc.</p> <p>The <code><span class="Identifier">params</span></code> array must start with the return type of the proc, followed by a list of IdentDefs which specify the params.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1221" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1221" target="_blank">Edit</a> </dd> </div> </div> <div id="newStmtList-procs-all"> <div id="newStmtList,varargs[NimNode]"> <dt><pre data-language="nim">proc newStmtList(stmts: varargs[NimNode]): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Create a new statement list. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1120" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1120" target="_blank">Edit</a> </dd> </div> </div> <div id="newStrLitNode-procs-all"> <div id="newStrLitNode,string"> <dt><pre data-language="nim">proc newStrLitNode(s: string): NimNode {.noSideEffect, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Creates a string literal node from <code><span class="Identifier">s</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L441" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L441" target="_blank">Edit</a> </dd> </div> </div> <div id="newTree-procs-all"> <div id="newTree,NimNodeKind,varargs[NimNode]"> <dt><pre data-language="nim">proc newTree(kind: NimNodeKind; children: varargs[NimNode]): NimNode {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Produces a new node with children. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L706" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L706" target="_blank">Edit</a> </dd> </div> </div> <div id="newVarStmt-procs-all"> <div id="newVarStmt,NimNode,NimNode"> <dt><pre data-language="nim">proc newVarStmt(name, value: NimNode): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Create a new var stmt. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1141" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1141" target="_blank">Edit</a> </dd> </div> </div> <div id="nodeID-procs-all"> <div id="nodeID,NimNode"> <dt><pre data-language="nim">proc nodeID(n: NimNode): int {.magic: "NodeId", ...raises: [], tags: [],
                               forbids: [].}</pre></dt> <dd> Returns the id of <code><span class="Identifier">n</span></code>, when the compiler has been compiled with the flag <code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">useNodeids</span></code>, otherwise returns <code><span class="Operator">-</span><span class="DecNumber">1</span></code>. This proc is for the purpose to debug the compiler only. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1527" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1527" target="_blank">Edit</a> </dd> </div> </div> <div id="owner-procs-all"> <div id="owner,NimNode"> <dt><pre data-language="nim">proc owner(sym: NimNode): NimNode {.magic: "SymOwner", noSideEffect, ...raises: [],
                                    tags: [], forbids: [].}</pre></dt> <dd> <p>Accepts a node of kind <code><span class="Identifier">nnkSym</span></code> and returns its owner's symbol. The meaning of 'owner' depends on <code><span class="Identifier">sym</span></code>'s <code><span class="Identifier">NimSymKind</span></code> and declaration context. For top level declarations this is an <code><span class="Identifier">nskModule</span></code> symbol, for proc local variables an <code><span class="Identifier">nskProc</span></code> symbol, for enum/object fields an <code><span class="Identifier">nskType</span></code> symbol, etc. For symbols without an owner, <code><span class="Keyword">nil</span></code> is returned.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#symKind,NimNode">symKind proc</a> to get the kind of a symbol</li> <li>
<a href="#getImpl,NimNode">getImpl proc</a> to get the declaration of a symbol</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L280" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L280" target="_blank">Edit</a> </dd> </div> </div> <div id="params-procs-all"> <div id="params,NimNode"> <dt><pre data-language="nim">proc params(someProc: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1323" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1323" target="_blank">Edit</a> </dd> </div> </div> <div id="params=-procs-all"> <div id="params=,NimNode,NimNode"> <dt><pre data-language="nim">proc params=(someProc: NimNode; params: NimNode) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1330" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1330" target="_blank">Edit</a> </dd> </div> </div> <div id="parseExpr-procs-all"> <div id="parseExpr,string,string"> <dt><pre data-language="nim">proc parseExpr(s: string; filename: string = ""): NimNode {.noSideEffect,
    ...raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> Compiles the passed string to its AST representation. Expects a single expression. Raises <code><span class="Identifier">ValueError</span></code> for parsing errors. A filename can be given for more informative errors. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L573" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L573" target="_blank">Edit</a> </dd> </div> </div> <div id="parseStmt-procs-all"> <div id="parseStmt,string,string"> <dt><pre data-language="nim">proc parseStmt(s: string; filename: string = ""): NimNode {.noSideEffect,
    ...raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> Compiles the passed string to its AST representation. Expects one or more statements. Raises <code><span class="Identifier">ValueError</span></code> for parsing errors. A filename can be given for more informative errors. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L581" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L581" target="_blank">Edit</a> </dd> </div> </div> <div id="postfix-procs-all"> <div id="postfix,NimNode,string"> <dt><pre data-language="nim">proc postfix(node: NimNode; op: string): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1470" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1470" target="_blank">Edit</a> </dd> </div> </div> <div id="pragma-procs-all"> <div id="pragma,NimNode"> <dt><pre data-language="nim">proc pragma(someProc: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Get the pragma of a proc type. These will be expanded. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1338" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1338" target="_blank">Edit</a> </dd> </div> </div> <div id="pragma=-procs-all"> <div id="pragma=,NimNode,NimNode"> <dt><pre data-language="nim">proc pragma=(someProc: NimNode; val: NimNode) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Set the pragma of a proc type. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1346" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1346" target="_blank">Edit</a> </dd> </div> </div> <div id="prefix-procs-all"> <div id="prefix,NimNode,string"> <dt><pre data-language="nim">proc prefix(node: NimNode; op: string): NimNode {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1473" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1473" target="_blank">Edit</a> </dd> </div> </div> <div id="quote-procs-all"> <div id="quote,typed,string"> <dt><pre data-language="nim">proc quote(bl: typed; op = "``"): NimNode {.magic: "QuoteAst", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Quasi-quoting operator. Accepts an expression or a block and returns the AST that represents it. Within the quoted AST, you are able to interpolate NimNode expressions from the surrounding scope. If no operator is given, quoting is done using backticks. Otherwise, the given operator must be used as a prefix operator for any interpolated expression. The original meaning of the interpolation operator may be obtained by escaping it (by prefixing it with itself) when used as a unary operator: e.g. <code><span class="Operator">@</span></code> is escaped as <code><span class="Operator">@@</span></code>, <code><span class="Operator">&amp;%</span></code> is escaped as <code><span class="Operator">&amp;%&amp;%</span></code> and so on; see examples.</p> <p>A custom operator interpolation needs accent quoted (``) whenever it resolves to a symbol.</p> <p>See also <a href="genasts.html">genasts</a> which avoids some issues with <code><span class="Identifier">quote</span></code>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">macro check(ex: untyped) =
  # this is a simplified version of the check macro from the
  # unittest module.

  # If there is a failed check, we want to make it easy for
  # the user to jump to the faulty line in the code, so we
  # get the line info here:
  var info = ex.lineinfo

  # We will also display the code string of the failed check:
  var expString = ex.toStrLit

  # Finally we compose the code to implement the check:
  result = quote do:
    if not `ex`:
      echo `info` &amp; ": Check failed: " &amp; `expString`
check 1 + 1 == 2</pre> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim"># example showing how to define a symbol that requires backtick without
# quoting it.
var destroyCalled = false
macro bar() =
  let s = newTree(nnkAccQuoted, ident"=destroy")
  # let s = ident"`=destroy`" # this would not work
  result = quote do:
    type Foo = object
    # proc `=destroy`(a: var Foo) = destroyCalled = true # this would not work
    proc `s`(a: var Foo) = destroyCalled = true
    block:
      let a = Foo()
bar()
doAssert destroyCalled</pre> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim"># custom `op`
var destroyCalled = false
macro bar(ident) =
  var x = 1.5
  result = quote("@") do:
    type Foo = object
    let `@ident` = 0 # custom op interpolated symbols need quoted (``)
    proc `=destroy`(a: var Foo) =
      doAssert @x == 1.5
      doAssert compiles(@x == 1.5)
      let b1 = @[1,2]
      let b2 = @@[1,2]
      doAssert $b1 == "[1, 2]"
      doAssert $b2 == "@[1, 2]"
      destroyCalled = true
    block:
      let a = Foo()
bar(someident)
doAssert destroyCalled

proc `&amp;%`(x: int): int = 1
proc `&amp;%`(x, y: int): int = 2

macro bar2() =
  var x = 3
  result = quote("&amp;%") do:
    var y = &amp;%x # quoting operator
    doAssert &amp;%&amp;%y == 1 # unary operator =&gt; need to escape
    doAssert y &amp;% y == 2 # binary operator =&gt; no need to escape
    doAssert y == 3
bar2()</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L598" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L598" target="_blank">Edit</a> </dd> </div> </div> <div id="sameType-procs-all"> <div id="sameType,NimNode,NimNode"> <dt><pre data-language="nim">proc sameType(a, b: NimNode): bool {.magic: "SameNodeType", noSideEffect,
                                     ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Compares two Nim nodes' types. Return true if the types are the same, e.g. true when comparing alias with original type. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L173" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L173" target="_blank">Edit</a> </dd> </div> </div> <div id="setLineInfo-procs-all"> <div id="setLineInfo,NimNode,string,int,int"> <dt><pre data-language="nim">proc setLineInfo(arg: NimNode; file: string; line: int; column: int) {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Sets the line info on the NimNode. The file needs to exists, but can be a relative path. If you want to attach line info to a block using <code><span class="Identifier">quote</span></code> you'll need to add the line information after the quote block. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L543" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L543" target="_blank">Edit</a> </dd> </div> <div id="setLineInfo,NimNode,LineInfo"> <dt><pre data-language="nim">proc setLineInfo(arg: NimNode; lineInfo: LineInfo) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> See <a href="#setLineInfo,NimNode,string,int,int">setLineInfo proc</a> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L551" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L551" target="_blank">Edit</a> </dd> </div> </div> <div id="signatureHash-procs-all"> <div id="signatureHash,NimNode"> <dt><pre data-language="nim">proc signatureHash(n: NimNode): string {.magic: "NSigHash", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns a stable identifier derived from the signature of a symbol. The signature combines many factors such as the type of the symbol, the owning module of the symbol and others. The same identifier is used in the back-end to produce the mangled symbol name. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L356" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L356" target="_blank">Edit</a> </dd> </div> </div> <div id="strVal-procs-all"> <div id="strVal,NimNode"> <dt><pre data-language="nim">proc strVal(n: NimNode): string {.magic: "NStrVal", noSideEffect, ...raises: [],
                                  tags: [], forbids: [].}</pre></dt> <dd> <p>Returns the string value of an identifier, symbol, comment, or string literal.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#strVal=,NimNode,string">strVal= proc</a> for setting the string value.</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L247" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L247" target="_blank">Edit</a> </dd> </div> </div> <div id="strVal=-procs-all"> <div id="strVal=,NimNode,string"> <dt><pre data-language="nim">proc strVal=(n: NimNode; val: string) {.magic: "NSetStrVal", noSideEffect,
                                        ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Sets the string value of a string literal or comment. Setting <code><span class="Identifier">strVal</span></code> is disallowed for <code><span class="Identifier">nnkIdent</span></code> and <code><span class="Identifier">nnkSym</span></code> nodes; a new node must be created using <code><span class="Identifier">ident</span></code> or <code><span class="Identifier">bindSym</span></code> instead.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#strVal,NimNode">strVal proc</a> for getting the string value.</li> <li>
<a href="#ident,string">ident proc</a> for creating an identifier.</li> <li>
<a href="#bindSym%2C%2CBindSymRule">bindSym proc</a> for binding a symbol.</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L385" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L385" target="_blank">Edit</a> </dd> </div> </div> <div id="symBodyHash-procs-all"> <div id="symBodyHash,NimNode"> <dt><pre data-language="nim">proc symBodyHash(s: NimNode): string {.noSideEffect, ...raises: [], tags: [],
                                       forbids: [].}</pre></dt> <dd> Returns a stable digest for symbols derived not only from type signature and owning module, but also implementation body. All procs/variables used in the implementation of this symbol are hashed recursively as well, including magics from system module. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L362" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L362" target="_blank">Edit</a> </dd> </div> </div> <div id="symbol-procs-all"> <div id="symbol,NimNode"> <dt><pre data-language="nim">proc symbol(n: NimNode): NimSym {.magic: "NSymbol", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; All functionality is defined on \'NimNode\'.",
                                  raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; All functionality is defined on 'NimNode'. </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L258" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L258" target="_blank">Edit</a> </dd> </div> </div> <div id="symbol=-procs-all"> <div id="symbol=,NimNode,NimSym"> <dt><pre data-language="nim">proc symbol=(n: NimNode; val: NimSym) {.magic: "NSetSymbol", noSideEffect, ...deprecated: "Deprecated since version 0.18.1; Generate a new \'NimNode\' with \'genSym\' instead.",
                                        raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.1; Generate a new 'NimNode' with 'genSym' instead. </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L377" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L377" target="_blank">Edit</a> </dd> </div> </div> <div id="symKind-procs-all"> <div id="symKind,NimNode"> <dt><pre data-language="nim">proc symKind(symbol: NimNode): NimSymKind {.magic: "NSymKind", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L244" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L244" target="_blank">Edit</a> </dd> </div> </div> <div id="toNimIdent-procs-all"> <div id="toNimIdent,string"> <dt><pre data-language="nim">proc toNimIdent(s: string): NimIdent {.magic: "StrToIdent", noSideEffect, ...deprecated: "Deprecated since version 0.18.0: Use \'ident\' or \'newIdentNode\' instead.",
                                       raises: [], tags: [], forbids: [].}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> Deprecated since version 0.18.0: Use 'ident' or 'newIdentNode' instead. </div> Constructs an identifier from the string <code><span class="Identifier">s</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L155" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L155" target="_blank">Edit</a> </dd> </div> </div> <div id="toStrLit-procs-all"> <div id="toStrLit,NimNode"> <dt><pre data-language="nim">proc toStrLit(n: NimNode): NimNode {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Converts the AST <code><span class="Identifier">n</span></code> to the concrete Nim code and wraps that in a string literal node. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L513" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L513" target="_blank">Edit</a> </dd> </div> </div> <div id="treeRepr-procs-all"> <div id="treeRepr,NimNode"> <dt><pre data-language="nim">proc treeRepr(n: NimNode): string {....gcsafe, raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Convert the AST <code><span class="Identifier">n</span></code> to a human-readable tree-like string.</p> <p>See also <code><span class="Identifier">repr</span></code>, <a title="proc lispRepr(n: NimNode; indented = false): string" href="#lispRepr,NimNode">lispRepr</a>, and <a title="proc astGenRepr(n: NimNode): string" href="#astGenRepr,NimNode">astGenRepr</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L979" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L979" target="_blank">Edit</a> </dd> </div> </div> <div id="typeKind-procs-all"> <div id="typeKind,NimNode"> <dt><pre data-language="nim">proc typeKind(n: NimNode): NimTypeKind {.magic: "NGetType", noSideEffect,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns the type kind of the node 'n' that should represent a type, that means the node should have been obtained via <code><span class="Identifier">getType</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L307" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L307" target="_blank">Edit</a> </dd> </div> </div> <div id="unpackInfix-procs-all"> <div id="unpackInfix,NimNode"> <dt><pre data-language="nim">proc unpackInfix(node: NimNode): tuple[left: NimNode, op: string, right: NimNode] {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1488" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1488" target="_blank">Edit</a> </dd> </div> </div> <div id="unpackPostfix-procs-all"> <div id="unpackPostfix,NimNode"> <dt><pre data-language="nim">proc unpackPostfix(node: NimNode): tuple[node: NimNode, op: string] {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1480" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1480" target="_blank">Edit</a> </dd> </div> </div> <div id="unpackPrefix-procs-all"> <div id="unpackPrefix,NimNode"> <dt><pre data-language="nim">proc unpackPrefix(node: NimNode): tuple[node: NimNode, op: string] {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1484" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1484" target="_blank">Edit</a> </dd> </div> </div> <div id="warning-procs-all"> <div id="warning,string,NimNode"> <dt><pre data-language="nim">proc warning(msg: string; n: NimNode = nil) {.magic: "NWarning", ...gcsafe,
    raises: [], tags: [], forbids: [].}</pre></dt> <dd> Writes a warning message at compile time. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L435" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L435" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="15">Iterators</h2> <dl> <div id="children-iterators-all"> <div id="children.i,NimNode"> <dt><pre data-language="nim">iterator children(n: NimNode): NimNode {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Iterates over the children of the NimNode <code><span class="Identifier">n</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1425" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1425" target="_blank">Edit</a> </dd> </div> </div> <div id="items-iterators-all"> <div id="items.i,NimNode"> <dt><pre data-language="nim">iterator items(n: NimNode): NimNode {.inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Iterates over the children of the NimNode <code><span class="Identifier">n</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1415" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1415" target="_blank">Edit</a> </dd> </div> </div> <div id="pairs-iterators-all"> <div id="pairs.i,NimNode"> <dt><pre data-language="nim">iterator pairs(n: NimNode): (int, NimNode) {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Iterates over the children of the NimNode <code><span class="Identifier">n</span></code> and its indices. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1420" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1420" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="17">Macros</h2> <dl> <div id="dumpAstGen-macros-all"> <div id="dumpAstGen.m,untyped"> <dt><pre data-language="nim">macro dumpAstGen(s: untyped): untyped</pre></dt> <dd> <p>Accepts a block of nim code and prints the parsed abstract syntax tree using the <code><span class="Identifier">astGenRepr</span></code> proc. Printing is done <em>at compile time</em>.</p> <p>You can use this as a tool to write macros quicker by writing example outputs and then copying the snippets into the macro for modification.</p> <p>For example:</p> 
<pre class="listing" data-language="nim">dumpAstGen:
  echo "Hello, World!"</pre> <p>Outputs:</p> 
<pre class="listing" data-language="nim">nnkStmtList.newTree(
  nnkCommand.newTree(
    newIdentNode("echo"),
    newLit("Hello, World!")
  )
)</pre> <p>Also see <code><span class="Identifier">dumpTree</span></code> and <code><span class="Identifier">dumpLisp</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1091" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1091" target="_blank">Edit</a> </dd> </div> </div> <div id="dumpLisp-macros-all"> <div id="dumpLisp.m,untyped"> <dt><pre data-language="nim">macro dumpLisp(s: untyped): untyped</pre></dt> <dd> <p>Accepts a block of nim code and prints the parsed abstract syntax tree using the <code><span class="Identifier">lispRepr</span></code> proc. Printing is done <em>at compile time</em>.</p> <p>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</p> <p>For example:</p> 
<pre class="listing" data-language="nim">dumpLisp:
  echo "Hello, World!"</pre> <p>Outputs:</p> 
<pre class="listing" data-language="nim">(StmtList
 (Command
  (Ident "echo")
  (StrLit "Hello, World!")))</pre> <p>Also see <code><span class="Identifier">dumpAstGen</span></code> and <code><span class="Identifier">dumpTree</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1067" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1067" target="_blank">Edit</a> </dd> </div> </div> <div id="dumpTree-macros-all"> <div id="dumpTree.m,untyped"> <dt><pre data-language="nim">macro dumpTree(s: untyped): untyped</pre></dt> <dd> <p>Accepts a block of nim code and prints the parsed abstract syntax tree using the <code><span class="Identifier">treeRepr</span></code> proc. Printing is done <em>at compile time</em>.</p> <p>You can use this as a tool to explore the Nim's abstract syntax tree and to discover what kind of nodes must be created to represent a certain expression/statement.</p> <p>For example:</p> 
<pre class="listing" data-language="nim">dumpTree:
  echo "Hello, World!"</pre> <p>Outputs:</p> 
<pre class="listing" data-language="nim">StmtList
  Command
    Ident "echo"
    StrLit "Hello, World!"</pre> <p>Also see <code><span class="Identifier">dumpAstGen</span></code> and <code><span class="Identifier">dumpLisp</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1043" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1043" target="_blank">Edit</a> </dd> </div> </div> <div id="expandMacros-macros-all"> <div id="expandMacros.m,typed"> <dt><pre data-language="nim">macro expandMacros(body: typed): untyped</pre></dt> <dd> <p>Expands one level of macro - useful for debugging. Can be used to inspect what happens when a macro call is expanded, without altering its result.</p> <p>For instance,</p> 
<pre class="listing" data-language="nim">import std/[sugar, macros]

let
  x = 10
  y = 20
expandMacros:
  dump(x + y)</pre> <p>will actually dump <code><span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span></code>, but at the same time will print at compile time the expansion of the <code><span class="Identifier">dump</span></code> macro, which in this case is <code><span class="Identifier">debugEcho</span> <span class="Punctuation">[</span><span class="StringLit">"x + y"</span><span class="Punctuation">,</span> <span class="StringLit">" = "</span><span class="Punctuation">,</span> <span class="Identifier">x</span> <span class="Operator">+</span> <span class="Identifier">y</span><span class="Punctuation">]</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1532" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1532" target="_blank">Edit</a> </dd> </div> </div> <div id="getCustomPragmaVal-macros-all"> <div id="getCustomPragmaVal.m,typed,"> <dt><pre data-language="nim">macro getCustomPragmaVal(n: typed; cp: typed{nkSym}): untyped</pre></dt> <dd> <p>Expands to value of custom pragma <code><span class="Identifier">cp</span></code> of expression <code><span class="Identifier">n</span></code> which is expected to be <code><span class="Identifier">nnkDotExpr</span></code>, a proc or a type.</p> <p>See also <a title="macro hasCustomPragma(n: typed; cp: typed{nkSym}): untyped" href="#hasCustomPragma.m,typed,">hasCustomPragma</a>.</p> 
<pre class="listing" data-language="nim">template serializationKey(key: string) {.pragma.}
type
  MyObj {.serializationKey: "mo".} = object
    myField {.serializationKey: "mf".}: int
var o: MyObj
assert(o.myField.getCustomPragmaVal(serializationKey) == "mf")
assert(o.getCustomPragmaVal(serializationKey) == "mo")
assert(MyObj.getCustomPragmaVal(serializationKey) == "mo")</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1674" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1674" target="_blank">Edit</a> </dd> </div> </div> <div id="hasCustomPragma-macros-all"> <div id="hasCustomPragma.m,typed,"> <dt><pre data-language="nim">macro hasCustomPragma(n: typed; cp: typed{nkSym}): untyped</pre></dt> <dd> <p>Expands to <code><span class="Identifier">true</span></code> if expression <code><span class="Identifier">n</span></code> which is expected to be <code><span class="Identifier">nnkDotExpr</span></code> (if checking a field), a proc or a type has custom pragma <code><span class="Identifier">cp</span></code>.</p> <p>See also <a title="macro getCustomPragmaVal(n: typed; cp: typed{nkSym}): untyped" href="#getCustomPragmaVal.m,typed,">getCustomPragmaVal</a>.</p> 
<pre class="listing" data-language="nim">template myAttr() {.pragma.}
type
  MyObj = object
    myField {.myAttr.}: int

proc myProc() {.myAttr.} = discard

var o: MyObj
assert(o.myField.hasCustomPragma(myAttr))
assert(myProc.hasCustomPragma(myAttr))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1649" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1649" target="_blank">Edit</a> </dd> </div> </div> <div id="unpackVarargs-macros-all"> <div id="unpackVarargs.m,untyped,varargs[untyped]"> <dt><pre data-language="nim">macro unpackVarargs(callee: untyped; args: varargs[untyped]): untyped</pre></dt> <dd> Calls <code><span class="Identifier">callee</span></code> with <code><span class="Identifier">args</span></code> unpacked as individual arguments. This is useful in 2 cases:<ul class="simple">
<li>when forwarding <code><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> for some typed <code><span class="Identifier">T</span></code>
</li> <li>when forwarding <code><span class="Identifier">varargs</span><span class="Punctuation">[</span><span class="Identifier">untyped</span><span class="Punctuation">]</span></code> when <code><span class="Identifier">args</span></code> can potentially be empty, due to a compiler limitation</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">template call1(fun: typed; args: varargs[untyped]): untyped =
  unpackVarargs(fun, args)
  # when varargsLen(args) &gt; 0: fun(args) else: fun() # this would also work
template call2(fun: typed; args: varargs[typed]): untyped =
  unpackVarargs(fun, args)
proc fn1(a = 0, b = 1) = discard (a, b)
call1(fn1, 10, 11)
call1(fn1) # `args` is empty in this case
if false: call2(echo, 10, 11) # would print 1011</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1707" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1707" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="18">Templates</h2> <dl> <div id="findChild-templates-all"> <div id="findChild.t,NimNode,untyped"> <dt><pre data-language="nim">template findChild(n: NimNode; cond: untyped): NimNode {.dirty.}</pre></dt> <dd> <p>Find the first child node matching condition (or nil).</p> 
<pre class="listing" data-language="nim">var res = findChild(n, it.kind == nnkPostfix and
                       it.basename.ident == ident"foo")</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L1430" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L1430" target="_blank">Edit</a> </dd> </div> </div> <div id="or-templates-all"> <div id="or.t,NimNode,NimNode"> <dt><pre data-language="nim">template `or`(x, y: NimNode): NimNode</pre></dt> <dd> <p>Evaluate <code><span class="Identifier">x</span></code> and when it is not an empty node, return it. Otherwise evaluate to <code><span class="Identifier">y</span></code>. Can be used to chain several expressions to get the first expression that is not empty.</p> 
<pre class="listing" data-language="nim">let node = mightBeEmpty() or mightAlsoBeEmpty() or fallbackNode</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/core/macros.nim#L207" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/core/macros.nim#L207" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/macros.html" class="_attribution-link">https://nim-lang.org/docs/macros.html</a>
  </p>
</div>
