<h1 class="title">parseutils</h1>  
<p>This module contains helpers for parsing tokens, numbers, integers, floats, identifiers, etc.</p> <p>To unpack raw bytes look at the <a href="streams.html">streams</a> module.</p> <pre class="listing" data-language="nim">let logs = @["2019-01-10: OK_", "2019-01-11: FAIL_", "2019-01: aaaa"]
var outp: seq[string]

for log in logs:
  var res: string
  if parseUntil(log, res, ':') == 10: # YYYY-MM-DD == 10
    outp.add(res &amp; " - " &amp; captureBetween(log, ' ', '_'))
doAssert outp == @["2019-01-10 - OK", "2019-01-11 - FAIL"]</pre>
<pre class="listing" data-language="nim">from strutils import Digits, parseInt

let
  input1 = "2019 school start"
  input2 = "3 years back"
  startYear = input1[0 .. skipWhile(input1, Digits)-1] # 2019
  yearsBack = input2[0 .. skipWhile(input2, Digits)-1] # 3
  examYear = parseInt(startYear) + parseInt(yearsBack)
doAssert "Examination is in " &amp; $examYear == "Examination is in 2022"</pre>
<p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="strutils.html">strutils module</a> for combined and identical parsing proc's</li> <li>
<a href="json.html">json module</a> for a JSON parser</li> <li>
<a href="parsecfg.html">parsecfg module</a> for a configuration file parser</li> <li>
<a href="parsecsv.html">parsecsv module</a> for a simple CSV (comma separated value) parser</li> <li>
<a href="parseopt.html">parseopt module</a> for a command line parser</li> <li>
<a href="parsexml.html">parsexml module</a> for a XML / HTML parser</li> <li>
<a href="lib.html#pure-libraries-parsers">other parsers</a> for other parsers</li> </ul>  <h2 id="7">Types</h2> <dl>  <dt><pre id="InterpolatedKind" data-language="nim">InterpolatedKind = enum
  ikStr,                    ## ``str`` part of the interpolated string
  ikDollar,                 ## escaped ``$`` part of the interpolated string
  ikVar,                    ## ``var`` part of the interpolated string
  ikExpr                     ## ``expr`` part of the interpolated string</pre></dt> <dd> Describes for <code>interpolatedFragments</code> which part of the interpolated string is yielded; for example in "str$$$var${expr}" <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L586" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L586" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="parseBin%2Cstring%2CT%2Cint%2Cint" data-language="nim">proc parseBin[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {...}{.
    noSideEffect.}</pre></dt> <dd> <p>Parses a binary number and stores its value in <code>number</code>.</p> <p>Returns the number of the parsed characters or 0 in case of an error. If error, the value of <code>number</code> is not changed.</p> <p>If <code>maxLen == 0</code>, the parsing continues until the first non-bin character or to the end of the string. Otherwise, no more than <code>maxLen</code> characters are parsed starting from the <code>start</code> position.</p> <p>It does not check for overflow. If the value represented by the string is too big to fit into <code>number</code>, only the value of last fitting characters will be stored in <code>number</code> without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var num: int
doAssert parseBin("0100_1110_0110_1001_1110_1101", num) == 29
doAssert num == 5138925
doAssert parseBin("3", num) == 0
var num8: int8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8) == 32
doAssert num8 == 0b1110_1101'i8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8, 3, 9) == 9
doAssert num8 == 0b0100_1110'i8
var num8u: uint8
doAssert parseBin("0b_0100_1110_0110_1001_1110_1101", num8u) == 32
doAssert num8u == 237
var num64: int64
doAssert parseBin("0100111001101001111011010100111001101001", num64) == 40
doAssert num64 == 336784608873</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L62" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L62" target="_blank">Edit</a> </dd>  <dt><pre id="parseOct%2Cstring%2CT%2Cint%2Cint" data-language="nim">proc parseOct[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {...}{.
    noSideEffect.}</pre></dt> <dd> <p>Parses an octal number and stores its value in <code>number</code>.</p> <p>Returns the number of the parsed characters or 0 in case of an error. If error, the value of <code>number</code> is not changed.</p> <p>If <code>maxLen == 0</code>, the parsing continues until the first non-oct character or to the end of the string. Otherwise, no more than <code>maxLen</code> characters are parsed starting from the <code>start</code> position.</p> <p>It does not check for overflow. If the value represented by the string is too big to fit into <code>number</code>, only the value of last fitting characters will be stored in <code>number</code> without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var num: int
doAssert parseOct("0o23464755", num) == 10
doAssert num == 5138925
doAssert parseOct("8", num) == 0
var num8: int8
doAssert parseOct("0o_1464_755", num8) == 11
doAssert num8 == -19
doAssert parseOct("0o_1464_755", num8, 3, 3) == 3
doAssert num8 == 102
var num8u: uint8
doAssert parseOct("1464755", num8u) == 7
doAssert num8u == 237
var num64: int64
doAssert parseOct("2346475523464755", num64) == 16
doAssert num64 == 86216859871725</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L109" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L109" target="_blank">Edit</a> </dd>  <dt><pre id="parseHex%2Cstring%2CT%2Cint%2Cint" data-language="nim">proc parseHex[T: SomeInteger](s: string; number: var T; start = 0; maxLen = 0): int {...}{.
    noSideEffect.}</pre></dt> <dd> <p>Parses a hexadecimal number and stores its value in <code>number</code>.</p> <p>Returns the number of the parsed characters or 0 in case of an error. If error, the value of <code>number</code> is not changed.</p> <p>If <code>maxLen == 0</code>, the parsing continues until the first non-hex character or to the end of the string. Otherwise, no more than <code>maxLen</code> characters are parsed starting from the <code>start</code> position.</p> <p>It does not check for overflow. If the value represented by the string is too big to fit into <code>number</code>, only the value of last fitting characters will be stored in <code>number</code> without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var num: int
doAssert parseHex("4E_69_ED", num) == 8
doAssert num == 5138925
doAssert parseHex("X", num) == 0
doAssert parseHex("#ABC", num) == 4
var num8: int8
doAssert parseHex("0x_4E_69_ED", num8) == 11
doAssert num8 == 0xED'i8
doAssert parseHex("0x_4E_69_ED", num8, 3, 2) == 2
doAssert num8 == 0x4E'i8
var num8u: uint8
doAssert parseHex("0x_4E_69_ED", num8u) == 11
doAssert num8u == 237
var num64: int64
doAssert parseHex("4E69ED4E69ED", num64) == 12
doAssert num64 == 86216859871725</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L156" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L156" target="_blank">Edit</a> </dd>  <dt><pre id="parseIdent%2Cstring%2Cstring%2Cint" data-language="nim">proc parseIdent(s: string; ident: var string; start = 0): int {...}{.raises: [],
    tags: [].}</pre></dt> <dd> Parses an identifier and stores it in <code>ident</code>. Returns the number of the parsed characters or 0 in case of an error. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: string
doAssert parseIdent("Hello World", res, 0) == 5
doAssert res == "Hello"
doAssert parseIdent("Hello World", res, 1) == 4
doAssert res == "ello"
doAssert parseIdent("Hello World", res, 6) == 5
doAssert res == "World"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L211" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L211" target="_blank">Edit</a> </dd>  <dt><pre id="parseIdent%2Cstring%2Cint" data-language="nim">proc parseIdent(s: string; start = 0): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Parses an identifier and returns it or an empty string in case of an error. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert parseIdent("Hello World", 0) == "Hello"
doAssert parseIdent("Hello World", 1) == "ello"
doAssert parseIdent("Hello World", 5) == ""
doAssert parseIdent("Hello World", 6) == "World"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L229" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L229" target="_blank">Edit</a> </dd>  <dt><pre id="skipWhitespace%2Cstring%2Cint" data-language="nim">proc skipWhitespace(s: string; start = 0): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Skips the whitespace starting at <code>s[start]</code>. Returns the number of skipped characters. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skipWhitespace("Hello World", 0) == 0
doAssert skipWhitespace(" Hello World", 0) == 1
doAssert skipWhitespace("Hello World", 5) == 1
doAssert skipWhitespace("Hello  World", 5) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L244" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L244" target="_blank">Edit</a> </dd>  <dt><pre id="skip%2Cstring%2Cstring%2Cint" data-language="nim">proc skip(s, token: string; start = 0): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Skips the <code>token</code> starting at <code>s[start]</code>. Returns the length of <code>token</code> or 0 if there was no <code>token</code> at <code>s[start]</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skip("2019-01-22", "2019", 0) == 4
doAssert skip("2019-01-22", "19", 0) == 0
doAssert skip("2019-01-22", "19", 2) == 2
doAssert skip("CAPlow", "CAP", 0) == 3
doAssert skip("CAPlow", "cap", 0) == 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L255" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L255" target="_blank">Edit</a> </dd>  <dt><pre id="skipIgnoreCase%2Cstring%2Cstring%2Cint" data-language="nim">proc skipIgnoreCase(s, token: string; start = 0): int {...}{.raises: [], tags: [].}</pre></dt> <dd> Same as <code>skip</code> but case is ignored for token matching. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skipIgnoreCase("CAPlow", "CAP", 0) == 3
doAssert skipIgnoreCase("CAPlow", "cap", 0) == 3</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L270" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L270" target="_blank">Edit</a> </dd>  <dt><pre id="skipUntil%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc skipUntil(s: string; until: set[char]; start = 0): int {...}{.inline,
    raises: [], tags: [].}</pre></dt> <dd> Skips all characters until one char from the set <code>until</code> is found or the end is reached. Returns number of characters skipped. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skipUntil("Hello World", {'W', 'e'}, 0) == 1
doAssert skipUntil("Hello World", {'W'}, 0) == 6
doAssert skipUntil("Hello World", {'W', 'd'}, 0) == 6</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L280" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L280" target="_blank">Edit</a> </dd>  <dt><pre id="skipUntil%2Cstring%2Cchar%2Cint" data-language="nim">proc skipUntil(s: string; until: char; start = 0): int {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> Skips all characters until the char <code>until</code> is found or the end is reached. Returns number of characters skipped. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skipUntil("Hello World", 'o', 0) == 4
doAssert skipUntil("Hello World", 'o', 4) == 0
doAssert skipUntil("Hello World", 'W', 0) == 6
doAssert skipUntil("Hello World", 'w', 0) == 11</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L291" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L291" target="_blank">Edit</a> </dd>  <dt><pre id="skipWhile%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc skipWhile(s: string; toSkip: set[char]; start = 0): int {...}{.inline,
    raises: [], tags: [].}</pre></dt> <dd> Skips all characters while one char from the set <code>token</code> is found. Returns number of characters skipped. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert skipWhile("Hello World", {'H', 'e'}) == 2
doAssert skipWhile("Hello World", {'e'}) == 0
doAssert skipWhile("Hello World", {'W', 'o', 'r'}, 6) == 3</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L303" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L303" target="_blank">Edit</a> </dd>  <dt><pre id="parseUntil%2Cstring%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc parseUntil(s: string; token: var string; until: set[char]; start = 0): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> Parses a token and stores it in <code>token</code>. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters notin <code>until</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var myToken: string
doAssert parseUntil("Hello World", myToken, {'W', 'o', 'r'}) == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, {'W', 'r'}) == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, {'W', 'r'}, 3) == 3
doAssert myToken == "lo "</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L317" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L317" target="_blank">Edit</a> </dd>  <dt><pre id="parseUntil%2Cstring%2Cstring%2Cchar%2Cint" data-language="nim">proc parseUntil(s: string; token: var string; until: char; start = 0): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> Parses a token and stores it in <code>token</code>. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that is not the <code>until</code> character. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var myToken: string
doAssert parseUntil("Hello World", myToken, 'W') == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, 'o') == 4
doAssert myToken == "Hell"
doAssert parseUntil("Hello World", myToken, 'o', 2) == 2
doAssert myToken == "ll"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L336" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L336" target="_blank">Edit</a> </dd>  <dt><pre id="parseUntil%2Cstring%2Cstring%2Cstring%2Cint" data-language="nim">proc parseUntil(s: string; token: var string; until: string; start = 0): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> Parses a token and stores it in <code>token</code>. Returns the number of the parsed characters or 0 in case of an error. A token consists of any character that comes before the <code>until</code> token. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var myToken: string
doAssert parseUntil("Hello World", myToken, "Wor") == 6
doAssert myToken == "Hello "
doAssert parseUntil("Hello World", myToken, "Wor", 2) == 4
doAssert myToken == "llo "</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L355" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L355" target="_blank">Edit</a> </dd>  <dt><pre id="parseWhile%2Cstring%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc parseWhile(s: string; token: var string; validChars: set[char]; start = 0): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> Parses a token and stores it in <code>token</code>. Returns the number of the parsed characters or 0 in case of an error. A token consists of the characters in <code>validChars</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var myToken: string
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 0) == 0
doAssert myToken.len() == 0
doAssert parseWhile("Hello World", myToken, {'W', 'o', 'r'}, 6) == 3
doAssert myToken == "Wor"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L382" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L382" target="_blank">Edit</a> </dd>  <dt><pre id="captureBetween%2Cstring%2Cchar%2Cchar%2Cint" data-language="nim">proc captureBetween(s: string; first: char; second = '\x00'; start = 0): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Finds the first occurrence of <code>first</code>, then returns everything from there up to <code>second</code> (if <code>second</code> is '0', then <code>first</code> is used). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert captureBetween("Hello World", 'e') == "llo World"
doAssert captureBetween("Hello World", 'e', 'r') == "llo Wo"
doAssert captureBetween("Hello World", 'l', start = 6) == "d"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L399" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L399" target="_blank">Edit</a> </dd>  <dt><pre id="parseBiggestInt%2Cstring%2CBiggestInt%2Cint" data-language="nim">proc parseBiggestInt(s: string; number: var BiggestInt; start = 0): int {...}{.
    gcsafe, extern: "npuParseBiggestInt", noSideEffect, raises: [ValueError],
    tags: [].}</pre></dt> <dd> Parses an integer starting at <code>start</code> and stores the value into <code>number</code>. Result is the number of processed chars or 0 if there is no integer. <code>ValueError</code> is raised if the parsed integer is out of the valid range. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: BiggestInt
doAssert parseBiggestInt("9223372036854775807", res, 0) == 19
doAssert res == 9223372036854775807</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L445" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L445" target="_blank">Edit</a> </dd>  <dt><pre id="parseInt%2Cstring%2Cint%2Cint" data-language="nim">proc parseInt(s: string; number: var int; start = 0): int {...}{.gcsafe,
    extern: "npuParseInt", noSideEffect, raises: [ValueError], tags: [].}</pre></dt> <dd> Parses an integer starting at <code>start</code> and stores the value into <code>number</code>. Result is the number of processed chars or 0 if there is no integer. <code>ValueError</code> is raised if the parsed integer is out of the valid range. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: int
doAssert parseInt("2019", res, 0) == 4
doAssert res == 2019
doAssert parseInt("2019", res, 2) == 2
doAssert res == 19</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L461" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L461" target="_blank">Edit</a> </dd>  <dt><pre id="parseSaturatedNatural%2Cstring%2Cint%2Cint" data-language="nim">proc parseSaturatedNatural(s: string; b: var int; start = 0): int {...}{.raises: [],
    tags: [].}</pre></dt> <dd> Parses a natural number into <code>b</code>. This cannot raise an overflow error. <code>high(int)</code> is returned for an overflow. The number of processed character is returned. This is usually what you really want to use instead of <span id="parseint_1">parseInt</span>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res = 0
discard parseSaturatedNatural("848", res)
doAssert res == 848</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L480" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L480" target="_blank">Edit</a> </dd>  <dt><pre id="parseBiggestUInt%2Cstring%2CBiggestUInt%2Cint" data-language="nim">proc parseBiggestUInt(s: string; number: var BiggestUInt; start = 0): int {...}{.
    gcsafe, extern: "npuParseBiggestUInt", noSideEffect, raises: [ValueError],
    tags: [].}</pre></dt> <dd> Parses an unsigned integer starting at <code>start</code> and stores the value into <code>number</code>. <code>ValueError</code> is raised if the parsed integer is out of the valid range. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: BiggestUInt
doAssert parseBiggestUInt("12", res, 0) == 2
doAssert res == 12
doAssert parseBiggestUInt("1111111111111111111", res, 0) == 19
doAssert res == 1111111111111111111'u64</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L524" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L524" target="_blank">Edit</a> </dd>  <dt><pre id="parseUInt%2Cstring%2Cuint%2Cint" data-language="nim">proc parseUInt(s: string; number: var uint; start = 0): int {...}{.gcsafe,
    extern: "npuParseUInt", noSideEffect, raises: [ValueError], tags: [].}</pre></dt> <dd> Parses an unsigned integer starting at <code>start</code> and stores the value into <code>number</code>. <code>ValueError</code> is raised if the parsed integer is out of the valid range. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: uint
doAssert parseUInt("3450", res) == 4
doAssert res == 3450
doAssert parseUInt("3450", res, 2) == 2
doAssert res == 50</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L542" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L542" target="_blank">Edit</a> </dd>  <dt><pre id="parseBiggestFloat%2Cstring%2CBiggestFloat%2Cint" data-language="nim">proc parseBiggestFloat(s: string; number: var BiggestFloat; start = 0): int {...}{.
    magic: "ParseBiggestFloat", importc: "nimParseBiggestFloat", noSideEffect.}</pre></dt> <dd> Parses a float starting at <code>start</code> and stores the value into <code>number</code>. Result is the number of processed chars or 0 if a parsing error occurred. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L561" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L561" target="_blank">Edit</a> </dd>  <dt><pre id="parseFloat%2Cstring%2Cfloat%2Cint" data-language="nim">proc parseFloat(s: string; number: var float; start = 0): int {...}{.gcsafe,
    extern: "npuParseFloat", noSideEffect, raises: [], tags: [].}</pre></dt> <dd> Parses a float starting at <code>start</code> and stores the value into <code>number</code>. Result is the number of processed chars or 0 if there occurred a parsing error. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var res: float
doAssert parseFloat("32", res, 0) == 2
doAssert res == 32.0
doAssert parseFloat("32.57", res, 0) == 5
doAssert res == 32.57
doAssert parseFloat("32.57", res, 3) == 2
doAssert res == 57.00</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L567" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L567" target="_blank">Edit</a> </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre id="interpolatedFragments.i%2Cstring" data-language="nim">iterator interpolatedFragments(s: string): tuple[kind: InterpolatedKind,
    value: string] {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> Tokenizes the string <code>s</code> into substrings for interpolation purposes. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var outp: seq[tuple[kind: InterpolatedKind, value: string]]
for k, v in interpolatedFragments("  $this is ${an  example}  $$"):
  outp.add (k, v)
doAssert outp == @[(ikStr, "  "),
                   (ikVar, "this"),
                   (ikStr, " is "),
                   (ikExpr, "an  example"),
                   (ikStr, "  "),
                   (ikDollar, "$")]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseutils.nim#L594" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseutils.nim#L594" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/parseutils.html" class="_attribution-link">https://nim-lang.org/docs/parseutils.html</a>
  </p>
</div>
