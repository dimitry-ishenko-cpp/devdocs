<h1 class="title">std/decls</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/std/decls.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/std/decls.nim#L1" target="_blank">Edit</a>  <p class="module-desc">This module implements syntax sugar for some declarations.</p>  <h2 id="6">Imports</h2> <dl> <a href="macros.html">macros</a> </dl>   <h2 id="17">Macros</h2> <dl> <div id="byaddr-macros-all"> <div id="byaddr.m"> <dt><pre data-language="nim">macro byaddr(sect)</pre></dt> <dd> Allows a syntax for l-value references, being an exact analog to <code><span class="Identifier">auto</span><span class="Operator">&amp;</span> <span class="Identifier">a</span> <span class="Operator">=</span> <span class="Identifier">ex</span><span class="Punctuation">;</span></code> in C++.<div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> This makes use of 2 experimental features, namely nullary templates instantiated as symbols and variable macro pragmas. For this reason, its behavior is not stable. The current implementation allows redefinition, but this is not an intended consequence.</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var s = @[10, 11, 12]
var a {.byaddr.} = s[0]
a += 100
assert s == @[110, 11, 12]
assert a is int
var b {.byaddr.}: int = s[0]
assert a.addr == b.addr</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/std/decls.nim#L5" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/std/decls.nim#L5" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/decls.html" class="_attribution-link">https://nim-lang.org/docs/decls.html</a>
  </p>
</div>
