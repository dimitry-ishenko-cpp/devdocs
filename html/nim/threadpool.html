<h1 class="title">threadpool</h1>  
<p>Implements Nim's <a href="manual_experimental.html#parallel-amp-spawn">spawn</a>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="threads.html">threads module</a></li> <li><a href="channels.html">channels module</a></li> <li><a href="locks.html">locks module</a></li> <li><a href="asyncdispatch.html">asyncdispatch module</a></li> </ul> <p>Unstable API.</p>  <h2 id="6">Imports</h2> <dl> <a href="cpuinfo.html">cpuinfo</a>, <a href="cpuload.html">cpuload</a>, <a href="locks.html">locks</a>, <a href="os.html">os</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="FlowVarBase">FlowVarBase = ref FlowVarBaseObj</pre></dt> <dd> Untyped base class for <code>FlowVar[T]</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L104" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L104" target="_blank">Edit</a> </dd>  <dt><pre id="FlowVar" data-language="nim">FlowVar[T] {...}{.compilerProc.} = ref FlowVarObj[T]</pre></dt> <dd> A data flow variable. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L117" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L117" target="_blank">Edit</a> </dd>  <dt><pre id="ThreadId" data-language="nim">ThreadId = range[0 .. MaxDistinguishedThread - 1]</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L318" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L318" target="_blank">Edit</a> </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre id="MaxThreadPoolSize">MaxThreadPoolSize = 256</pre></dt> <dd> Maximum size of the thread pool. 256 threads should be good enough for anybody ;-) <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L313" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L313" target="_blank">Edit</a> </dd>  <dt><pre id="MaxDistinguishedThread">MaxDistinguishedThread = 32</pre></dt> <dd> Maximum number of "distinguished" threads. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L315" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L315" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="blockUntil%2CFlowVarBaseObj" data-language="nim">proc blockUntil(fv: var FlowVarBaseObj) {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Waits until the value for the <code>fv</code> arrives.</p> <p>Usually it is not necessary to call this explicitly.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L140" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L140" target="_blank">Edit</a> </dd>  <dt><pre id="awaitAndThen%2CFlowVar%5BT%5D%2Cproc%28T%29" data-language="nim">proc awaitAndThen[T](fv: FlowVar[T]; action: proc (x: T) {...}{.closure.})</pre></dt> <dd> <p>Blocks until the <code>fv</code> is available and then passes its value to <code>action</code>.</p> <p>Note that due to Nim's parameter passing semantics this means that <code>T</code> doesn't need to be copied so <code>awaitAndThen</code> can sometimes be more efficient than <a href="#%5E,FlowVar%5BT%5D">^ proc</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L232" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L232" target="_blank">Edit</a> </dd>  <dt><pre id="unsafeRead%2CFlowVar%5Bref.T%5D" data-language="nim">proc unsafeRead[T](fv: FlowVar[ref T]): ptr T</pre></dt> <dd> Blocks until the value is available and then returns this value. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L250" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L250" target="_blank">Edit</a> </dd>  <dt><pre id="%5E%2CFlowVar%5BT%5D" data-language="nim">proc `^`[T](fv: FlowVar[T]): T</pre></dt> <dd> Blocks until the value is available and then returns this value. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L259" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L259" target="_blank">Edit</a> </dd>  <dt><pre id="blockUntilAny%2CopenArray%5BFlowVarBase%5D" data-language="nim">proc blockUntilAny(flowVars: openArray[FlowVarBase]): int {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Awaits any of the given <code>flowVars</code>. Returns the index of one <code>flowVar</code> for which a value arrived.</p> <p>A <code>flowVar</code> only supports one call to <code>blockUntilAny</code> at the same time. That means if you <code>blockUntilAny([a,b])</code> and <code>blockUntilAny([b,c])</code> the second call will only block until <code>c</code>. If there is no <code>flowVar</code> left to be able to wait on, -1 is returned.</p> <p><strong>Note</strong>: This results in non-deterministic behaviour and should be avoided.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L268" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L268" target="_blank">Edit</a> </dd>  <dt><pre id="isReady%2CFlowVarBase" data-language="nim">proc isReady(fv: FlowVarBase): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Determines whether the specified <code>FlowVarBase</code>'s value is available.</p> <p>If <code>true</code>, awaiting <code>fv</code> will not block.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L297" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L297" target="_blank">Edit</a> </dd>  <dt><pre id="setMinPoolSize%2Crange%5B%5D" data-language="nim">proc setMinPoolSize(size: range[1 .. MaxThreadPoolSize]) {...}{.raises: [], tags: [].}</pre></dt> <dd> Sets the minimum thread pool size. The default value of this is 4. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L399" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L399" target="_blank">Edit</a> </dd>  <dt><pre id="setMaxPoolSize%2Crange%5B%5D" data-language="nim">proc setMaxPoolSize(size: range[1 .. MaxThreadPoolSize]) {...}{.raises: [], tags: [].}</pre></dt> <dd> Sets the maximum thread pool size. The default value of this is <code>MaxThreadPoolSize</code> (256). <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L403" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L403" target="_blank">Edit</a> </dd>  <dt><pre id="preferSpawn" data-language="nim">proc preferSpawn(): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Use this proc to determine quickly if a <code>spawn</code> or a direct call is preferable.</p> <p>If it returns <code>true</code>, a <code>spawn</code> may make sense. In general it is not necessary to call this directly; use <a href="#spawnX.t">spawnX template</a> instead.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L444" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L444" target="_blank">Edit</a> </dd>  <dt><pre id="spawn%2Csinktyped" data-language="nim">proc spawn(call: sink typed): void {...}{.magic: "Spawn".}</pre></dt> <dd> <p>Always spawns a new task, so that the <code>call</code> is never executed on the calling thread.</p> <p><code>call</code> has to be proc call <code>p(...)</code> where <code>p</code> is gcsafe and has a return type that is either <code>void</code> or compatible with <code>FlowVar[T]</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L453" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L453" target="_blank">Edit</a> </dd>  <dt><pre id="pinnedSpawn%2CThreadId%2Csinktyped" data-language="nim">proc pinnedSpawn(id: ThreadId; call: sink typed): void {...}{.magic: "Spawn".}</pre></dt> <dd> <p>Always spawns a new task on the worker thread with <code>id</code>, so that the <code>call</code> is <strong>always</strong> executed on the thread.</p> <p><code>call</code> has to be proc call <code>p(...)</code> where <code>p</code> is gcsafe and has a return type that is either <code>void</code> or compatible with <code>FlowVar[T]</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L460" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L460" target="_blank">Edit</a> </dd>  <dt><pre id="parallel%2Cuntyped" data-language="nim">proc parallel(body: untyped) {...}{.magic: "Parallel".}</pre></dt> <dd> <p>A parallel section can be used to execute a block in parallel.</p> <p><code>body</code> has to be in a DSL that is a particular subset of the language.</p> <p>Please refer to <a href="manual_experimental.html#parallel-amp-spawn">the manual</a> for further information.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L478" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L478" target="_blank">Edit</a> </dd>  <dt><pre id="sync" data-language="nim">proc sync() {...}{.raises: [], tags: [TimeEffect].}</pre></dt> <dd> <p>A simple barrier to wait for all <code>spawn</code>'ed tasks.</p> <p>If you need more elaborate waiting, you have to use an explicit barrier.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L587" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L587" target="_blank">Edit</a> </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre id="spawnX.t" data-language="nim">template spawnX(call)</pre></dt> <dd> <p>Spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread.</p> <p>Usually it is advised to use <a href="#spawn,typed">spawn proc</a> in order to not block the producer for an unknown amount of time.</p> <p><code>call</code> has to be proc call <code>p(...)</code> where <code>p</code> is gcsafe and has a return type that is either 'void' or compatible with <code>FlowVar[T]</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/concurrency/threadpool.nim#L467" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L467" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/threadpool.html" class="_attribution-link">https://nim-lang.org/docs/threadpool.html</a>
  </p>
</div>
