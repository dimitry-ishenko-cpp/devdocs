<h1 class="title">std/threadpool</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L1" target="_blank">Edit</a>  <div class="deprecation-message"> <b>Deprecated:</b> use the nimble packages `malebolgia`, `taskpools` or `weave` instead </div> 
<p>Implements Nim's <a href="manual_experimental.html#parallel-amp-spawn">parallel &amp; spawn statements</a>.</p> <p>Unstable API.</p> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="typedthreads.html">threads module</a> for basic thread support</li> <li>
<a href="locks.html">locks module</a> for locks and condition variables</li> <li>
<a href="asyncdispatch.html">asyncdispatch module</a> for asynchronous IO</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="cpuinfo.html">cpuinfo</a>, <a href="cpuload.html">cpuload</a>, <a href="locks.html">locks</a>, <a href="os.html">os</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="FlowVar"> <dt><pre data-language="nim">FlowVar[T] {.compilerproc.} = ref FlowVarObj[T]</pre></dt> <dd> A data flow variable. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L119" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L119" target="_blank">Edit</a> </dd> </div> <div id="FlowVarBase"> <dt><pre>FlowVarBase = ref FlowVarBaseObj</pre></dt> <dd> Untyped base class for <a href="#FlowVar">FlowVar[T]</a>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L106" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L106" target="_blank">Edit</a> </dd> </div> <div id="ThreadId"> <dt><pre data-language="nim">ThreadId = range[0 .. MaxDistinguishedThread - 1]</pre></dt> <dd> A thread identifier. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L320" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L320" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="10">Consts</h2> <dl> <div id="MaxDistinguishedThread"> <dt><pre data-language="nim">MaxDistinguishedThread {.intdefine.} = 32</pre></dt> <dd> Maximum number of "distinguished" threads. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L317" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L317" target="_blank">Edit</a> </dd> </div> <div id="MaxThreadPoolSize"> <dt><pre data-language="nim">MaxThreadPoolSize {.intdefine.} = 256</pre></dt> <dd> Maximum size of the thread pool. 256 threads should be good enough for anybody ;-) <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L315" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L315" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="^-procs-all"> <div id="^,FlowVar[T]"> <dt><pre data-language="nim">proc `^`[T](fv: FlowVar[T]): T</pre></dt> <dd> Blocks until the value is available and then returns this value. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L261" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L261" target="_blank">Edit</a> </dd> </div> </div> <div id="awaitAndThen-procs-all"> <div id="awaitAndThen,FlowVar[T],proc(T)"> <dt><pre data-language="nim">proc awaitAndThen[T](fv: FlowVar[T]; action: proc (x: T) {.closure.})</pre></dt> <dd> <p>Blocks until <code><span class="Identifier">fv</span></code> is available and then passes its value to <code><span class="Identifier">action</span></code>.</p> <p>Note that due to Nim's parameter passing semantics, this means that <code><span class="Identifier">T</span></code> doesn't need to be copied, so <code><span class="Identifier">awaitAndThen</span></code> can sometimes be more efficient than the <a href="#^,FlowVar[T]">^ proc</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L234" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L234" target="_blank">Edit</a> </dd> </div> </div> <div id="blockUntil-procs-all"> <div id="blockUntil,FlowVarBaseObj"> <dt><pre data-language="nim">proc blockUntil(fv: var FlowVarBaseObj) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Waits until the value for <code><span class="Identifier">fv</span></code> arrives.</p> <p>Usually it is not necessary to call this explicitly.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L142" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L142" target="_blank">Edit</a> </dd> </div> </div> <div id="blockUntilAny-procs-all"> <div id="blockUntilAny,openArray[FlowVarBase]"> <dt><pre data-language="nim">proc blockUntilAny(flowVars: openArray[FlowVarBase]): int {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Awaits any of the given <code><span class="Identifier">flowVars</span></code>. Returns the index of one <code><span class="Identifier">flowVar</span></code> for which a value arrived.</p> <p>A <code><span class="Identifier">flowVar</span></code> only supports one call to <code><span class="Identifier">blockUntilAny</span></code> at the same time. That means if you <code><span class="Identifier">blockUntilAny</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="Identifier">a</span><span class="Punctuation">,</span><span class="Identifier">b</span><span class="Punctuation">]</span><span class="Punctuation">)</span></code> and <code><span class="Identifier">blockUntilAny</span><span class="Punctuation">(</span><span class="Punctuation">[</span><span class="Identifier">b</span><span class="Punctuation">,</span><span class="Identifier">c</span><span class="Punctuation">]</span><span class="Punctuation">)</span></code> the second call will only block until <code><span class="Identifier">c</span></code>. If there is no <code><span class="Identifier">flowVar</span></code> left to be able to wait on, -1 is returned.</p> <p><strong>Note:</strong> This results in non-deterministic behaviour and should be avoided.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L270" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L270" target="_blank">Edit</a> </dd> </div> </div> <div id="isReady-procs-all"> <div id="isReady,FlowVarBase"> <dt><pre data-language="nim">proc isReady(fv: FlowVarBase): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Determines whether the specified <code><span class="Identifier">FlowVarBase</span></code>'s value is available.</p> <p>If <code><span class="Identifier">true</span></code>, awaiting <code><span class="Identifier">fv</span></code> will not block.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L299" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L299" target="_blank">Edit</a> </dd> </div> </div> <div id="parallel-procs-all"> <div id="parallel,untyped"> <dt><pre data-language="nim">proc parallel(body: untyped) {.magic: "Parallel", ...raises: [], tags: [],
                               forbids: [].}</pre></dt> <dd> <p>A parallel section can be used to execute a block in parallel.</p> <p><code><span class="Identifier">body</span></code> has to be in a DSL that is a particular subset of the language.</p> <p>Please refer to <a href="manual_experimental.html#parallel-amp-spawn">the manual</a> for further information.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L482" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L482" target="_blank">Edit</a> </dd> </div> </div> <div id="pinnedSpawn-procs-all"> <div id="pinnedSpawn,ThreadId,sinktyped"> <dt><pre data-language="nim">proc pinnedSpawn(id: ThreadId; call: sink typed) {.magic: "Spawn", ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Always spawns a new task on the worker thread with <code><span class="Identifier">id</span></code>, so that the <code><span class="Identifier">call</span></code> is <strong>always</strong> executed on the thread.</p> <p><code><span class="Identifier">call</span></code> has to be a proc call <code><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></code> where <code><span class="Identifier">p</span></code> is gcsafe and has a return type that is either <code><span class="Identifier">void</span></code> or compatible with <code><span class="Identifier">FlowVar</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L463" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L463" target="_blank">Edit</a> </dd> </div> </div> <div id="preferSpawn-procs-all"> <div id="preferSpawn"> <dt><pre data-language="nim">proc preferSpawn(): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Use this proc to determine quickly if a <code><span class="Identifier">spawn</span></code> or a direct call is preferable.</p> <p>If it returns <code><span class="Identifier">true</span></code>, a <code><span class="Identifier">spawn</span></code> may make sense. In general it is not necessary to call this directly; use the <a href="#spawnX.t">spawnX template</a> instead.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L446" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L446" target="_blank">Edit</a> </dd> </div> </div> <div id="setMaxPoolSize-procs-all"> <div id="setMaxPoolSize,range[]"> <dt><pre data-language="nim">proc setMaxPoolSize(size: range[1 .. MaxThreadPoolSize]) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Sets the maximum thread pool size. The default value of this is <a href="#MaxThreadPoolSize">MaxThreadPoolSize</a>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L405" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L405" target="_blank">Edit</a> </dd> </div> </div> <div id="setMinPoolSize-procs-all"> <div id="setMinPoolSize,range[]"> <dt><pre data-language="nim">proc setMinPoolSize(size: range[1 .. MaxThreadPoolSize]) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Sets the minimum thread pool size. The default value of this is 4. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L401" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L401" target="_blank">Edit</a> </dd> </div> </div> <div id="spawn-procs-all"> <div id="spawn,sinktyped"> <dt><pre data-language="nim">proc spawn(call: sink typed) {.magic: "Spawn", ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Always spawns a new task, so that the <code><span class="Identifier">call</span></code> is never executed on the calling thread.</p> <p><code><span class="Identifier">call</span></code> has to be a proc call <code><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></code> where <code><span class="Identifier">p</span></code> is gcsafe and has a return type that is either <code><span class="Identifier">void</span></code> or compatible with <code><span class="Identifier">FlowVar</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L455" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L455" target="_blank">Edit</a> </dd> </div> </div> <div id="sync-procs-all"> <div id="sync"> <dt><pre data-language="nim">proc sync() {....raises: [], tags: [TimeEffect], forbids: [].}</pre></dt> <dd> <p>A simple barrier to wait for all <code><span class="Identifier">spawn</span></code>ed tasks.</p> <p>If you need more elaborate waiting, you have to use an explicit barrier.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L591" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L591" target="_blank">Edit</a> </dd> </div> </div> <div id="unsafeRead-procs-all"> <div id="unsafeRead,FlowVar[ref.T]"> <dt><pre data-language="nim">proc unsafeRead[T](fv: FlowVar[ref T]): ptr T</pre></dt> <dd> Blocks until the value is available and then returns this value. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L252" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L252" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="18">Templates</h2> <dl> <div id="spawnX-templates-all"> <div id="spawnX.t"> <dt><pre data-language="nim">template spawnX(call)</pre></dt> <dd> <p>Spawns a new task if a CPU core is ready, otherwise executes the call in the calling thread.</p> <p>Usually, it is advised to use the <a href="#spawn,sinktyped">spawn proc</a> in order to not block the producer for an unknown amount of time.</p> <p><code><span class="Identifier">call</span></code> has to be a proc call <code><span class="Identifier">p</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></code> where <code><span class="Identifier">p</span></code> is gcsafe and has a return type that is either 'void' or compatible with <code><span class="Identifier">FlowVar</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/concurrency/threadpool.nim#L471" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/concurrency/threadpool.nim#L471" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/threadpool.html" class="_attribution-link">https://nim-lang.org/docs/threadpool.html</a>
  </p>
</div>
