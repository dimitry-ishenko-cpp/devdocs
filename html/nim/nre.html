<h1 class="title">std/nre</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L1" target="_blank">Edit</a>  
<h2 id="what-is-nreqmark">What is NRE?</h2>
<p>A regular expression library for Nim using PCRE to do the hard work.</p> <p>For documentation on how to write patterns, there exists <a href="https://www.pcre.org/original/doc/html/pcrepattern.html">the official PCRE pattern documentation</a>. You can also search the internet for a wide variety of third-party documentation and tools.</p> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> If you love <code><span class="Identifier">sequtils</span><span class="Operator">.</span><span class="Identifier">toSeq</span></code> we have bad news for you. This library doesn't work with it due to documented compiler limitations. As a workaround, use this:</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/nre
# either `import std/nre except toSeq` or fully qualify `sequtils.toSeq`:
import std/sequtils
iterator iota(n: int): int =
  for i in 0..&lt;n: yield i
assert sequtils.toSeq(iota(3)) == @[0, 1, 2]</pre>
<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> There are also alternative nimble packages such as <a href="https://github.com/khchen/tinyre">tinyre</a> and <a href="https://github.com/nitely/nim-regex">regex</a>.</div> <h3 id="what-is-nreqmark-licencing">Licencing</h3>
<p>PCRE has <a href="http://pcre.sourceforge.net/license.txt">some additional terms</a> that you must agree to in order to use this module.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/nre
import std/sugar
let vowels = re"[aeoui]"
let bounds = collect:
  for match in "moiga".findIter(vowels): match.matchBounds
assert bounds == @[1 .. 1, 2 .. 2, 4 .. 4]
from std/sequtils import toSeq
let s = sequtils.toSeq("moiga".findIter(vowels))
  # fully qualified to avoid confusion with nre.toSeq
assert s.len == 3

let firstVowel = "foo".find(vowels)
let hasVowel = firstVowel.isSome()
assert hasVowel
let matchBounds = firstVowel.get().captureBounds[-1]
assert matchBounds.a == 1

# as with module `re`, unless specified otherwise, `start` parameter in each
# proc indicates where the scan starts, but outputs are relative to the start
# of the input string, not to `start`:
assert find("uxabc", re"(?&lt;=x|y)ab", start = 1).get.captures[-1] == "ab"
assert find("uxabc", re"ab", start = 3).isNone</pre>  <h2 id="6">Imports</h2> <dl> <a href="pcre.html">pcre</a>, <a href="util.html">util</a>, <a href="tables.html">tables</a>, <a href="strutils.html">strutils</a>, <a href="options.html">options</a>, <a href="unicode.html">unicode</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="CaptureBounds"> <dt><pre>CaptureBounds = distinct RegexMatch</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L197" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L197" target="_blank">Edit</a> </dd> </div> <div id="Captures"> <dt><pre>Captures = distinct RegexMatch</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L196" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L196" target="_blank">Edit</a> </dd> </div> <div id="InvalidUnicodeError"> <dt><pre data-language="nim">InvalidUnicodeError = ref object of RegexError
  pos*: int                  ## the location of the invalid unicode in bytes</pre></dt> <dd> Thrown when matching fails due to invalid unicode in strings <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L204" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L204" target="_blank">Edit</a> </dd> </div> <div id="Regex"> <dt><pre data-language="nim">Regex = ref object
  pattern*: string
  ## not nil
  ## nil</pre></dt> <dd> Represents the pattern that things are matched against, constructed with <code><span class="Identifier">re</span><span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">)</span></code>. Examples: <code><span class="RawData">re"foo"</span></code>, <code><span class="Identifier">re</span><span class="Punctuation">(</span><span class="RawData">r"(*ANYCRLF)(?x)foo # comment"</span><span class="Operator">.</span></code><dl>
<dt><code><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code></dt> <dd>the string that was used to create the pattern. For details on how to write a pattern, please see <a href="https://www.pcre.org/original/doc/html/pcrepattern.html">the official PCRE pattern documentation.</a>
</dd> <dt><code><span class="Identifier">captureCount</span><span class="Punctuation">:</span> <span class="Identifier">int</span></code></dt> <dd>the number of captures that the pattern has.</dd> <dt><code><span class="Identifier">captureNameId</span><span class="Punctuation">:</span> <span class="Identifier">Table</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></code></dt> <dd>a table from the capture names to their numeric id.</dd> </dl> <h4 id="licencing-options">Options</h4>
<p>The following options may appear anywhere in the pattern, and they affect the rest of it.</p> <ul class="simple">
<li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">i</span><span class="Punctuation">)</span></code> - case insensitive</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">m</span><span class="Punctuation">)</span></code> - multi-line: <code><span class="Operator">^</span></code> and <code><span class="Operator">$</span></code> match the beginning and end of lines, not of the subject string</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">s</span><span class="Punctuation">)</span></code> - <code><span class="Operator">.</span></code> also matches newline (<em>dotall</em>)</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">U</span><span class="Punctuation">)</span></code> - expressions are not greedy by default. <code><span class="Operator">?</span></code> can be added to a qualifier to make it greedy</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">x</span><span class="Punctuation">)</span></code> - whitespace and comments (<code><span class="Comment">#</span></code>) are ignored (<em>extended</em>)</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">?</span><span class="Identifier">X</span><span class="Punctuation">)</span></code> - character escapes without special meaning (<code><span class="Operator">\</span><span class="Identifier">w</span></code> vs. <code><span class="Operator">\</span><span class="Identifier">a</span></code>) are errors (<em>extra</em>)</li> </ul> <p>One or a combination of these options may appear only at the beginning of the pattern:</p> <ul class="simple">
<li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">UTF8</span><span class="Punctuation">)</span></code> - treat both the pattern and subject as UTF-8</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">UCP</span><span class="Punctuation">)</span></code> - Unicode character properties; <code><span class="Operator">\</span><span class="Identifier">w</span></code> matches <code><span class="Identifier">я</span></code>
</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">U</span><span class="Punctuation">)</span></code> - a combination of the two options above</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">FIRSTLINE</span><span class="Operator">*</span><span class="Punctuation">)</span></code> - fails if there is not a match on the first line</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">NO_AUTO_CAPTURE</span><span class="Punctuation">)</span></code> - turn off auto-capture for groups; <code><span class="Punctuation">(</span><span class="Operator">?&lt;</span><span class="Identifier">name</span><span class="Operator">&gt;...</span><span class="Punctuation">)</span></code> can be used to capture</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">CR</span><span class="Punctuation">)</span></code> - newlines are separated by <code><span class="Operator">\</span><span class="Identifier">r</span></code>
</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">LF</span><span class="Punctuation">)</span></code> - newlines are separated by <code><span class="Operator">\</span><span class="Identifier">n</span></code> (UNIX default)</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">CRLF</span><span class="Punctuation">)</span></code> - newlines are separated by <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">n</span></code> (Windows default)</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">ANYCRLF</span><span class="Punctuation">)</span></code> - newlines are separated by any of the above</li> <li>
<p><code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">ANY</span><span class="Punctuation">)</span></code> - newlines are separated by any of the above and Unicode newlines:</p> <p>single characters VT (vertical tab, U+000B), FF (form feed, U+000C), NEL (next line, U+0085), LS (line separator, U+2028), and PS (paragraph separator, U+2029). For the 8-bit library, the last two are recognized only in UTF-8 mode. — man pcre</p> </li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">JAVASCRIPT_COMPAT</span><span class="Punctuation">)</span></code> - JavaScript compatibility</li> <li>
<code><span class="Punctuation">(</span><span class="Operator">*</span><span class="Identifier">NO_STUDY</span><span class="Punctuation">)</span></code> - turn off studying; study is enabled by default</li> </ul> <p>For more details on the leading option groups, see the <a href="http://man7.org/linux/man-pages/man3/pcresyntax.3.html#OPTION_SETTING">Option Setting</a> and the <a href="http://man7.org/linux/man-pages/man3/pcresyntax.3.html#NEWLINE_CONVENTION">Newline Convention</a> sections of the <a href="http://man7.org/linux/man-pages/man3/pcresyntax.3.html">PCRE syntax manual</a>.</p> <p>Some of these options are not part of PCRE and are converted by nre into PCRE flags. These include <code><span class="Identifier">NEVER_UTF</span></code>, <code><span class="Identifier">ANCHORED</span></code>, <code><span class="Identifier">DOLLAR_ENDONLY</span></code>, <code><span class="Identifier">FIRSTLINE</span></code>, <code><span class="Identifier">NO_AUTO_CAPTURE</span></code>, <code><span class="Identifier">JAVASCRIPT_COMPAT</span></code>, <code><span class="Identifier">U</span></code>, <code><span class="Identifier">NO_STUDY</span></code>. In other PCRE wrappers, you will need to pass these as separate flags to PCRE.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L77" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L77" target="_blank">Edit</a> </dd> </div> <div id="RegexError"> <dt><pre>RegexError = ref object of CatchableError</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L199" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L199" target="_blank">Edit</a> </dd> </div> <div id="RegexInternalError"> <dt><pre>RegexInternalError = ref object of RegexError</pre></dt> <dd> Internal error in the module, this probably means that there is a bug <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L201" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L201" target="_blank">Edit</a> </dd> </div> <div id="RegexMatch"> <dt><pre data-language="nim">RegexMatch = object
  pattern*: Regex            ## The regex doing the matching.
                             ## Not nil.
  str*: string               ## The string that was matched against.
  ## First item is the bounds of the match
  ## Other items are the captures
  ## `a` is inclusive start, `b` is exclusive end</pre></dt> <dd> Usually seen as Option<a title="object RegexMatch" href="#RegexMatch">RegexMatch</a>, it represents the result of an execution. On failure, it is none, on success, it is some.<dl>
<dt><code><span class="Identifier">pattern</span><span class="Punctuation">:</span> <span class="Identifier">Regex</span></code></dt> <dd>the pattern that is being matched</dd> <dt><code><span class="Identifier">str</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code></dt> <dd>the string that was matched against</dd> <dt><code><span class="Identifier">captures</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code></dt> <dd>the string value of whatever was captured at that id. If the value is invalid, then behavior is undefined. If the id is <code><span class="Operator">-</span><span class="DecNumber">1</span></code>, then the whole match is returned. If the given capture was not matched, <code><span class="Keyword">nil</span></code> is returned. See examples for <code><span class="Identifier">match</span></code>.</dd> <dt><code><span class="Identifier">captureBounds</span><span class="Punctuation">[</span><span class="Punctuation">]</span><span class="Punctuation">:</span> <span class="Identifier">HSlice</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></code></dt> <dd>gets the bounds of the given capture according to the same rules as the above. If the capture is not filled, then <code><span class="Identifier">None</span></code> is returned. The bounds are both inclusive. See examples for <code><span class="Identifier">match</span></code>.</dd> <dt><code><span class="Identifier">match</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code></dt> <dd>the full text of the match.</dd> <dt><code><span class="Identifier">matchBounds</span><span class="Punctuation">:</span> <span class="Identifier">HSlice</span><span class="Punctuation">[</span><span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">int</span><span class="Punctuation">]</span></code></dt> <dd>the bounds of the match, as in <code><span class="Identifier">captureBounds</span><span class="Punctuation">[</span><span class="Punctuation">]</span></code>
</dd> <dt><code><span class="Punctuation">(</span><span class="Identifier">captureBounds</span><span class="Operator">|</span><span class="Identifier">captures</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toTable</span></code></dt> <dd>returns a table with each named capture as a key.</dd> <dt><code><span class="Punctuation">(</span><span class="Identifier">captureBounds</span><span class="Operator">|</span><span class="Identifier">captures</span><span class="Punctuation">)</span><span class="Operator">.</span><span class="Identifier">toSeq</span></code></dt> <dd>returns all the captures by their number.</dd> <dt><code><span class="Operator">$:</span> <span class="Identifier">string</span></code></dt> <dd>same as <code><span class="Identifier">match</span></code>
</dd> </dl> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L154" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L154" target="_blank">Edit</a> </dd> </div> <div id="StudyError"> <dt><pre>StudyError = ref object of RegexError</pre></dt> <dd> Thrown when studying the regular expression fails for whatever reason. The message contains the error code. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L214" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L214" target="_blank">Edit</a> </dd> </div> <div id="SyntaxError"> <dt><pre data-language="nim">SyntaxError = ref object of RegexError
  pos*: int                  ## the location of the syntax error in bytes
  pattern*: string           ## the pattern that caused the problem</pre></dt> <dd> Thrown when there is a syntax error in the regular expression string passed in <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L208" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L208" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="$-procs-all"> <div id="$,RegexMatch"> <dt><pre data-language="nim">proc `$`(pattern: RegexMatch): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L407" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L407" target="_blank">Edit</a> </dd> </div> </div> <div id="==-procs-all"> <div id="==,Regex,Regex"> <dt><pre data-language="nim">proc `==`(a, b: Regex): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L410" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L410" target="_blank">Edit</a> </dd> </div> <div id="==,RegexMatch,RegexMatch"> <dt><pre data-language="nim">proc `==`(a, b: RegexMatch): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L418" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L418" target="_blank">Edit</a> </dd> </div> </div> <div id="[]-procs-all"> <div id="[],CaptureBounds,int"> <dt><pre data-language="nim">func `[]`(pattern: CaptureBounds; i: int): HSlice[int, int] {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L319" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L319" target="_blank">Edit</a> </dd> </div> <div id="[],CaptureBounds,string"> <dt><pre data-language="nim">func `[]`(pattern: CaptureBounds; name: string): HSlice[int, int] {.
    ...raises: [KeyError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L353" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L353" target="_blank">Edit</a> </dd> </div> <div id="[],Captures,int"> <dt><pre data-language="nim">func `[]`(pattern: Captures; i: int): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L327" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L327" target="_blank">Edit</a> </dd> </div> <div id="[],Captures,string"> <dt><pre data-language="nim">func `[]`(pattern: Captures; name: string): string {....raises: [KeyError],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L359" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L359" target="_blank">Edit</a> </dd> </div> </div> <div id="captureBounds-procs-all"> <div id="captureBounds,RegexMatch"> <dt><pre data-language="nim">func captureBounds(pattern: RegexMatch): CaptureBounds {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L308" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L308" target="_blank">Edit</a> </dd> </div> </div> <div id="captureCount-procs-all"> <div id="captureCount,Regex"> <dt><pre data-language="nim">proc captureCount(pattern: Regex): int {....raises: [ValueError], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L280" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L280" target="_blank">Edit</a> </dd> </div> </div> <div id="captureNameId-procs-all"> <div id="captureNameId,Regex"> <dt><pre data-language="nim">proc captureNameId(pattern: Regex): Table[string, int] {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L283" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L283" target="_blank">Edit</a> </dd> </div> </div> <div id="captures-procs-all"> <div id="captures,RegexMatch"> <dt><pre data-language="nim">func captures(pattern: RegexMatch): Captures {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L310" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L310" target="_blank">Edit</a> </dd> </div> </div> <div id="contains-procs-all"> <div id="contains,CaptureBounds,int"> <dt><pre data-language="nim">func contains(pattern: CaptureBounds; i: int): bool {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L312" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L312" target="_blank">Edit</a> </dd> </div> <div id="contains,CaptureBounds,string"> <dt><pre data-language="nim">func contains(pattern: CaptureBounds; name: string): bool {....raises: [KeyError],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L339" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L339" target="_blank">Edit</a> </dd> </div> <div id="contains,Captures,int"> <dt><pre data-language="nim">func contains(pattern: Captures; i: int): bool {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L316" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L316" target="_blank">Edit</a> </dd> </div> <div id="contains,Captures,string"> <dt><pre data-language="nim">func contains(pattern: Captures; name: string): bool {....raises: [KeyError],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L346" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L346" target="_blank">Edit</a> </dd> </div> <div id="contains,string,Regex,int"> <dt><pre data-language="nim">proc contains(str: string; pattern: Regex; start = 0; endpos = int.high): bool {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError], tags: [],
    forbids: [].}</pre></dt> <dd> Determine if the string contains the given pattern between the end and start positions: This function is equivalent to <code><span class="Identifier">isSome</span><span class="Punctuation">(</span><span class="Identifier">str</span><span class="Operator">.</span><span class="Identifier">find</span><span class="Punctuation">(</span><span class="Identifier">pattern</span><span class="Punctuation">,</span> <span class="Identifier">start</span><span class="Punctuation">,</span> <span class="Identifier">endpos</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert "abc".contains(re"bc")
assert not "abc".contains(re"cd")
assert not "abc".contains(re"a", start = 1)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L606" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L606" target="_blank">Edit</a> </dd> </div> </div> <div id="escapeRe-procs-all"> <div id="escapeRe,string"> <dt><pre data-language="nim">proc escapeRe(str: string): string {....gcsafe, raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Escapes the string so it doesn't match any special characters. Incompatible with the Extra flag (<code><span class="Identifier">X</span></code>).</p> <p>Escaped char: <code><span class="Operator">\</span> <span class="Operator">+</span> <span class="Operator">*</span> <span class="Operator">?</span> <span class="Punctuation">[</span> <span class="Operator">^</span> <span class="Punctuation">]</span> <span class="Operator">$</span> <span class="Punctuation">(</span> <span class="Punctuation">)</span> <span class="Punctuation">{</span> <span class="Punctuation">}</span> <span class="Operator">=</span> <span class="Operator">!</span> <span class="Operator">&lt;</span> <span class="Operator">&gt;</span> <span class="Operator">|</span> <span class="Punctuation">:</span> <span class="Operator">-</span></code></p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert escapeRe("fly+wind") == "fly\\+wind"
assert escapeRe("!") == "\\!"
assert escapeRe("nim*") == "nim\\*"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L730" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L730" target="_blank">Edit</a> </dd> </div> </div> <div id="find-procs-all"> <div id="find,string,Regex,int"> <dt><pre data-language="nim">proc find(str: string; pattern: Regex; start = 0; endpos = int.high): Option[
    RegexMatch] {....raises: [ValueError, RegexInternalError, InvalidUnicodeError],
                  tags: [], forbids: [].}</pre></dt> <dd> Finds the given pattern in the string between the end and start positions.<dl>
<dt><code><span class="Identifier">start</span></code></dt> <dd>The start point at which to start matching. <code><span class="Operator">|</span><span class="Identifier">abc</span></code> is <code><span class="DecNumber">0</span></code>; <code><span class="Identifier">a</span><span class="Operator">|</span><span class="Identifier">bc</span></code> is <code><span class="DecNumber">1</span></code>
</dd> <dt><code><span class="Identifier">endpos</span></code></dt> <dd>The maximum index for a match; <code><span class="Identifier">int</span><span class="Operator">.</span><span class="Identifier">high</span></code> means the end of the string, otherwise it’s an inclusive upper bound.</dd> </dl> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L588" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L588" target="_blank">Edit</a> </dd> </div> </div> <div id="findAll-procs-all"> <div id="findAll,string,Regex,int"> <dt><pre data-language="nim">proc findAll(str: string; pattern: Regex; start = 0; endpos = int.high): seq[
    string] {....raises: [ValueError, RegexInternalError, InvalidUnicodeError],
              tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L601" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L601" target="_blank">Edit</a> </dd> </div> </div> <div id="match-procs-all"> <div id="match,RegexMatch"> <dt><pre data-language="nim">func match(pattern: RegexMatch): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L333" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L333" target="_blank">Edit</a> </dd> </div> <div id="match,string,Regex,int"> <dt><pre data-language="nim">proc match(str: string; pattern: Regex; start = 0; endpos = int.high): Option[
    RegexMatch] {....raises: [ValueError, RegexInternalError, InvalidUnicodeError],
                  tags: [], forbids: [].}</pre></dt> <dd> Like <a href="#find,string,Regex,int">find(...)</a>, but anchored to the start of the string. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert "foo".match(re"f").isSome
assert "foo".match(re"o").isNone

assert "abc".match(re"(\w)").get.captures[0] == "a"
assert "abc".match(re"(?&lt;letter&gt;\w)").get.captures["letter"] == "a"
assert "abc".match(re"(\w)\w").get.captures[-1] == "ab"

assert "abc".match(re"(\w)").get.captureBounds[0] == 0 .. 0
assert 0 in "abc".match(re"(\w)").get.captureBounds
assert "abc".match(re"").get.captureBounds[-1] == 0 .. -1
assert "abc".match(re"abc").get.captureBounds[-1] == 0 .. 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L520" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L520" target="_blank">Edit</a> </dd> </div> </div> <div id="matchBounds-procs-all"> <div id="matchBounds,RegexMatch"> <dt><pre data-language="nim">func matchBounds(pattern: RegexMatch): HSlice[int, int] {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L336" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L336" target="_blank">Edit</a> </dd> </div> </div> <div id="re-procs-all"> <div id="re,string"> <dt><pre data-language="nim">proc re(pattern: string): Regex {....raises: [KeyError, SyntaxError, StudyError,
    ValueError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L477" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L477" target="_blank">Edit</a> </dd> </div> </div> <div id="replace-procs-all"> <div id="replace,string,Regex,string"> <dt><pre data-language="nim">proc replace(str: string; pattern: Regex; sub: string): string {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError, KeyError],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L725" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L725" target="_blank">Edit</a> </dd> </div> <div id="replace,string,Regex,proc(RegexMatch)"> <dt><pre data-language="nim">proc replace(str: string; pattern: Regex;
             subproc: proc (match: RegexMatch): string): string {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError, Exception],
    tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Replaces each match of Regex in the string with <code><span class="Identifier">subproc</span></code>, which should never be or return <code><span class="Keyword">nil</span></code>.</p> <p>If <code><span class="Identifier">subproc</span></code> is a <code><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">RegexMatch</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code>, then it is executed with each match and the return value is the replacement value.</p> <p>If <code><span class="Identifier">subproc</span></code> is a <code><span class="Keyword">proc</span> <span class="Punctuation">(</span><span class="Identifier">string</span><span class="Punctuation">)</span><span class="Punctuation">:</span> <span class="Identifier">string</span></code>, then it is executed with the full text of the match and the return value is the replacement value.</p> <p>If <code><span class="Identifier">subproc</span></code> is a string, the syntax is as follows:</p> <ul class="simple">
<li>
<code><span class="Operator">$$</span></code> - literal <code><span class="Operator">$</span></code>
</li> <li>
<code><span class="Operator">$</span><span class="DecNumber">123</span></code> - capture number <code><span class="DecNumber">123</span></code>
</li> <li>
<code><span class="Operator">$</span><span class="Identifier">foo</span></code> - named capture <code><span class="Identifier">foo</span></code>
</li> <li>
<code><span class="Operator">$</span><span class="Punctuation">{</span><span class="Identifier">foo</span><span class="Punctuation">}</span></code> - same as above</li> <li>
<code><span class="Operator">$</span><span class="DecNumber">1</span><span class="Operator">$</span><span class="Comment">#</span></code> - first and second captures</li> <li>
<code><span class="Operator">$</span><span class="Comment">#</span></code> - first capture</li> <li>
<code><span class="Operator">$</span><span class="DecNumber">0</span></code> - full match</li> </ul> <p>If a given capture is missing, <code><span class="Identifier">IndexDefect</span></code> thrown for un-named captures and <code><span class="Identifier">KeyError</span></code> for named captures.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L696" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L696" target="_blank">Edit</a> </dd> </div> <div id="replace,string,Regex,proc(string)"> <dt><pre data-language="nim">proc replace(str: string; pattern: Regex; subproc: proc (match: string): string): string {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError, Exception],
    tags: [RootEffect], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L721" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L721" target="_blank">Edit</a> </dd> </div> </div> <div id="split-procs-all"> <div id="split,string,Regex,int,int"> <dt><pre data-language="nim">proc split(str: string; pattern: Regex; maxSplit = -1; start = 0): seq[string] {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Splits the string with the given regex. This works according to the rules that Perl and Javascript use.</p> <p><code><span class="Identifier">start</span></code> behaves the same as in <a href="#find,string,Regex,int">find(...)</a>. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim"># -  If the match is zero-width, then the string is still split:
assert "123".split(re"") == @["1", "2", "3"]

# -  If the pattern has a capture in it, it is added after the string
#    split:
assert "12".split(re"(\d)") == @["", "1", "", "2", ""]

# -  If `maxsplit != -1`, then the string will only be split
#    `maxsplit - 1` times. This means that there will be `maxsplit`
#    strings in the output seq.
assert "1.2.3".split(re"\.", maxsplit = 2) == @["1", "2.3"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L617" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L617" target="_blank">Edit</a> </dd> </div> </div> <div id="toSeq-procs-all"> <div id="toSeq,CaptureBounds"> <dt><pre data-language="nim">proc toSeq(pattern: CaptureBounds; default = none(HSlice[int, int])): seq[
    Option[HSlice[int, int]]] {....raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L397" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L397" target="_blank">Edit</a> </dd> </div> <div id="toSeq,Captures,Option[string]"> <dt><pre data-language="nim">proc toSeq(pattern: Captures; default: Option[string] = none(string)): seq[
    Option[string]] {....raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L402" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L402" target="_blank">Edit</a> </dd> </div> </div> <div id="toTable-procs-all"> <div id="toTable,CaptureBounds"> <dt><pre data-language="nim">func toTable(pattern: CaptureBounds): Table[string, HSlice[int, int]] {.
    ...raises: [KeyError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L374" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L374" target="_blank">Edit</a> </dd> </div> <div id="toTable,Captures"> <dt><pre data-language="nim">func toTable(pattern: Captures): Table[string, string] {....raises: [KeyError],
    tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L370" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L370" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="15">Iterators</h2> <dl> <div id="findIter-iterators-all"> <div id="findIter.i,string,Regex,int"> <dt><pre data-language="nim">iterator findIter(str: string; pattern: Regex; start = 0; endpos = int.high): RegexMatch {.
    ...raises: [ValueError, RegexInternalError, InvalidUnicodeError], tags: [],
    forbids: [].}</pre></dt> <dd> Works the same as <a href="#find,string,Regex,int">find(...)</a>, but finds every non-overlapping match: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/sugar
assert collect(for a in "2222".findIter(re"22"): a.match) == @["22", "22"]
 # not @["22", "22", "22"]</pre>
<p>Arguments are the same as <a href="#find,string,Regex,int">find(...)</a></p> <p>Variants:</p> <ul class="simple">
<li>
<code><span class="Keyword">proc</span> <span class="Identifier">findAll</span><span class="Punctuation">(</span><span class="Operator">...</span><span class="Punctuation">)</span></code> returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">string</span><span class="Punctuation">]</span></code>
</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L537" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L537" target="_blank">Edit</a> </dd> </div> </div> <div id="items-iterators-all"> <div id="items.i,CaptureBounds"> <dt><pre data-language="nim">iterator items(pattern: CaptureBounds; default = none(HSlice[int, int])): Option[
    HSlice[int, int]] {....raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L389" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L389" target="_blank">Edit</a> </dd> </div> <div id="items.i,Captures,Option[string]"> <dt><pre data-language="nim">iterator items(pattern: Captures; default: Option[string] = none(string)): Option[
    string] {....raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/impure/nre.nim#L393" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/nre.nim#L393" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/nre.html" class="_attribution-link">https://nim-lang.org/docs/nre.html</a>
  </p>
</div>
