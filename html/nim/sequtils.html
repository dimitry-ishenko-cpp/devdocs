<h1 class="title">sequtils</h1>  <p class="module-desc">Although this module has <code>seq</code> in its name, it implements operations not only for <span id="seq_1">seq</span> type, but for three built-in container types under the <code>openArray</code> umbrella:</p>
<ul class="simple">
<li>sequences</li> <li>strings</li> <li>array</li> </ul> <p>The system module defines several common functions, such as:</p> <ul class="simple">
<li>
<code>newSeq[T]</code> for creating new sequences of type <code>T</code>
</li> <li>
<code>@</code> for converting arrays and strings to sequences</li> <li>
<code>add</code> for adding new elements to strings and sequences</li> <li>
<code>&amp;</code> for string and seq concatenation</li> <li>
<code>in</code> (alias for <code>contains</code>) and <code>notin</code> for checking if an item is in a container</li> </ul> <p>This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.</p> <p>For functional style programming you have different options at your disposal:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li>pass <a href="manual.html#procedures-anonymous-procs">anonymous proc</a>
</li> <li>import <a href="sugar.html">sugar module</a> and use <a href="#">=&gt; macro</a>
</li> <li>use <a href="#18">...It templates</a> (<a href="#mapIt.t,typed,untyped">mapIt</a>, <a href="#filterIt.t,untyped,untyped">filterIt</a>, etc.)</li> </ul> <p>The chaining of functions is possible thanks to the <a href="manual.html#procedures-method-call-syntax">method call syntax</a>.</p> <pre class="listing" data-language="nim">import sequtils, sugar

# Creating a sequence from 1 to 10, multiplying each member by 2,
# keeping only the members which are not divisible by 6.
let
  foo = toSeq(1..10).map(x =&gt; x*2).filter(x =&gt; x mod 6 != 0)
  bar = toSeq(1..10).mapIt(it*2).filterIt(it mod 6 != 0)
  baz = collect(newSeq):
    for i in 1..10:
      let j = 2*i
      if j mod 6 != 0:
        j

doAssert foo == bar
doAssert foo == baz
echo foo                  # @[2, 4, 8, 10, 14, 16, 20]

echo foo.any(x =&gt; x &gt; 17) # true
echo bar.allIt(it &lt; 20)   # false
echo foo.foldl(a + b)     # 74; sum of all members</pre>
<pre class="listing" data-language="nim">import sequtils
from strutils import join

let
  vowels = @"aeiou" # creates a sequence @['a', 'e', 'i', 'o', 'u']
  foo = "sequtils is an awesome module"

echo foo.filterIt(it notin vowels).join # "sqtls s n wsm mdl"</pre>
<hr> <p><strong>See also</strong>:</p> <ul class="simple">
<li>
<a href="strutils.html">strutils module</a> for common string functions</li> <li>
<a href="sugar.html">sugar module</a> for syntactic sugar macros</li> <li>
<a href="algorithm.html">algorithm module</a> for common generic algorithms</li> <li>
<a href="json.html">json module</a> for a structure which allows heterogeneous members</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a>, <a href="macros.html">macros</a> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="concat%2Cvarargs%5Bseq%5BT%5D%5D" data-language="nim">proc concat[T](seqs: varargs[seq[T]]): seq[T]</pre></dt> <dd> <p>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#distribute,seq%5BT%5D,Positive">distribute proc</a> for a reverse operation</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  s1 = @[1, 2, 3]
  s2 = @[4, 5]
  s3 = @[6, 7]
  total = concat(s1, s2, s3)
assert total == @[1, 2, 3, 4, 5, 6, 7]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L113" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L113" target="_blank">Edit</a> </dd>  <dt><pre id="count%2CopenArray%5BT%5D%2CT" data-language="nim">proc count[T](s: openArray[T]; x: T): int</pre></dt> <dd> Returns the number of occurrences of the item <code>x</code> in the container <code>s</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 2, 3, 2, 4, 2]
  b = "abracadabra"
assert count(a, 2) == 4
assert count(a, 99) == 0
assert count(b, 'r') == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L138" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L138" target="_blank">Edit</a> </dd>  <dt><pre id="cycle%2CopenArray%5BT%5D%2CNatural" data-language="nim">proc cycle[T](s: openArray[T]; n: Natural): seq[T]</pre></dt> <dd> Returns a new sequence with the items of the container <code>s</code> repeated <code>n</code> times. <code>n</code> must be a non-negative number (zero or more). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  s = @[1, 2, 3]
  total = s.cycle(3)
assert total == @[1, 2, 3, 1, 2, 3, 1, 2, 3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L153" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L153" target="_blank">Edit</a> </dd>  <dt><pre id="repeat%2CT%2CNatural" data-language="nim">proc repeat[T](x: T; n: Natural): seq[T]</pre></dt> <dd> Returns a new sequence with the item <code>x</code> repeated <code>n</code> times. <code>n</code> must be a non-negative number (zero or more). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  total = repeat(5, 3)
assert total == @[5, 5, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L171" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L171" target="_blank">Edit</a> </dd>  <dt><pre id="deduplicate%2CopenArray%5BT%5D%2Cbool" data-language="nim">proc deduplicate[T](s: openArray[T]; isSorted: bool = false): seq[T]</pre></dt> <dd> <p>Returns a new sequence without duplicates.</p> <p>Setting the optional argument <code>isSorted</code> to <code>true</code> (default: false) uses a faster algorithm for deduplication. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]
  dup2 = @["a", "a", "c", "d", "d"]
  unique1 = deduplicate(dup1)
  unique2 = deduplicate(dup2, isSorted = true)
assert unique1 == @[1, 3, 4, 2, 8]
assert unique2 == @["a", "c", "d"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L184" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L184" target="_blank">Edit</a> </dd>  <dt><pre id="minIndex%2CopenArray%5BT%5D" data-language="nim">proc minIndex[T](s: openArray[T]): int</pre></dt> <dd> Returns the index of the minimum value of <code>s</code>. <code>T</code> needs to have a <code>&lt;</code> operator. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert minIndex(a) == 0
assert minIndex(b) == 3
assert minIndex(c) == 1
assert minIndex(d) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L212" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L212" target="_blank">Edit</a> </dd>  <dt><pre id="maxIndex%2CopenArray%5BT%5D" data-language="nim">proc maxIndex[T](s: openArray[T]): int</pre></dt> <dd> Returns the index of the maximum value of <code>s</code>. <code>T</code> needs to have a <code>&lt;</code> operator. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert maxIndex(a) == 3
assert maxIndex(b) == 0
assert maxIndex(c) == 2
assert maxIndex(d) == 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L229" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L229" target="_blank">Edit</a> </dd>  <dt><pre id="zip%2C%2C" data-language="nim">proc zip[S, T](s1: openArray[S]; s2: openArray[T]): seq[(S, T)]</pre></dt> <dd> <p>Returns a new sequence with a combination of the two input containers.</p> <p>The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.</p> <p><strong>Note</strong>: For Nim 1.0.x and older version, <code>zip</code> returned a seq of named tuple with fields <code>a</code> and <code>b</code>. For Nim versions 1.1.x and newer, <code>zip</code> returns a seq of unnamed tuples.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  short = @[1, 2, 3]
  long = @[6, 5, 4, 3, 2, 1]
  words = @["one", "two", "three"]
  letters = "abcd"
  zip1 = zip(short, long)
  zip2 = zip(short, words)
assert zip1 == @[(1, 6), (2, 5), (3, 4)]
assert zip2 == @[(1, "one"), (2, "two"), (3, "three")]
assert zip1[2][0] == 3
assert zip2[1][1] == "two"
when (NimMajor, NimMinor) &lt;= (1, 0):
  let
    zip3 = zip(long, letters)
  assert zip3 == @[(a: 6, b: 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].b == 'a'
else:
  let
    zip3: seq[tuple[num: int, letter: char]] = zip(long, letters)
  assert zip3 == @[(6, 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].letter == 'a'</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L289" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L289" target="_blank">Edit</a> </dd>  <dt><pre id="unzip%2CopenArray%5B%5D" data-language="nim">proc unzip[S, T](s: openArray[(S, T)]): (seq[S], seq[T])</pre></dt> <dd> Returns a tuple of two sequences split out from a sequence of 2-field tuples. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  zipped = @[(1, 'a'), (2, 'b'), (3, 'c')]
  unzipped1 = @[1, 2, 3]
  unzipped2 = @['a', 'b', 'c']
assert zipped.unzip() == (unzipped1, unzipped2)
assert zip(unzipped1, unzipped2).unzip() == (unzipped1, unzipped2)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L291" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L291" target="_blank">Edit</a> </dd>  <dt><pre id="distribute%2Cseq%5BT%5D%2CPositive" data-language="nim">proc distribute[T](s: seq[T]; num: Positive; spread = true): seq[seq[T]]</pre></dt> <dd> <p>Splits and distributes a sequence <code>s</code> into <code>num</code> sub-sequences.</p> <p>Returns a sequence of <code>num</code> sequences. For <em>some</em> input values this is the inverse of the <a href="#concat,varargs%5Bseq%5BT%5D%5D">concat</a> proc. The input sequence <code>s</code> can be empty, which will produce <code>num</code> empty sequences.</p> <p>If <code>spread</code> is false and the length of <code>s</code> is not a multiple of <code>num</code>, the proc will max out the first sub-sequence with <code>1 + len(s) div num</code> entries, leaving the remainder of elements to the last sequence.</p> <p>On the other hand, if <code>spread</code> is true, the proc will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 2, 3, 4, 5, 6, 7]
assert numbers.distribute(3) == @[@[1, 2, 3], @[4, 5], @[6, 7]]
assert numbers.distribute(3, false) == @[@[1, 2, 3], @[4, 5, 6], @[7]]
assert numbers.distribute(6)[0] == @[1, 2]
assert numbers.distribute(6)[1] == @[3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L306" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L306" target="_blank">Edit</a> </dd>  <dt><pre id="map%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">proc map[T, S](s: openArray[T]; op: proc (x: T): S {...}{.closure.}): seq[S] {...}{.inline.}</pre></dt> <dd> <p>Returns a new sequence with the results of <code>op</code> proc applied to every item in the container <code>s</code>.</p> <p>Since the input is not modified you can use it to transform the type of the elements in the input container.</p> <p>Instead of using <code>map</code> and <code>filter</code>, consider using the <code>collect</code> macro from the <code>sugar</code> module.</p> <p>See also:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#mapIt.t,typed,untyped">mapIt template</a></li> <li>
<a href="#apply,openArray%5BT%5D,proc(T)_2">apply proc</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = map(a, proc(x: int): string = $x)
assert b == @["1", "2", "3", "4"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L363" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L363" target="_blank">Edit</a> </dd>  <dt><pre id="apply%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">proc apply[T](s: var openArray[T]; op: proc (x: var T) {...}{.closure.}) {...}{.inline.}</pre></dt> <dd> <p>Applies <code>op</code> to every item in <code>s</code> modifying it directly.</p> <p>Note that container <code>s</code> must be declared as a <code>var</code> and it is required for your input and output types to be the same, since <code>s</code> is modified in-place. The parameter function takes a <code>var T</code> type parameter.</p> <p>See also:</p> <ul class="simple">
<li><a href="#applyIt.t,untyped,untyped">applyIt template</a></li> <li><a href="#map,openArray%5BT%5D,proc(T)">map proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @["1", "2", "3", "4"]
apply(a, proc(x: var string) = x &amp;= "42")
assert a == @["142", "242", "342", "442"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L389" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L389" target="_blank">Edit</a> </dd>  <dt><pre id="apply%2CopenArray%5BT%5D%2Cproc%28T%29_2" data-language="nim">proc apply[T](s: var openArray[T]; op: proc (x: T): T {...}{.closure.}) {...}{.inline.}</pre></dt> <dd> <p>Applies <code>op</code> to every item in <code>s</code> modifying it directly.</p> <p>Note that container <code>s</code> must be declared as a <code>var</code> and it is required for your input and output types to be the same, since <code>s</code> is modified in-place. The parameter function takes and returns a <code>T</code> type variable.</p> <p>See also:</p> <ul class="simple">
<li><a href="#applyIt.t,untyped,untyped">applyIt template</a></li> <li><a href="#map,openArray%5BT%5D,proc(T)">map proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @["1", "2", "3", "4"]
apply(a, proc(x: string): string = x &amp; "42")
assert a == @["142", "242", "342", "442"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L409" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L409" target="_blank">Edit</a> </dd>  <dt><pre id="apply%2CopenArray%5BT%5D%2Cproc%28T%29_3" data-language="nim">proc apply[T](s: openArray[T]; op: proc (x: T) {...}{.closure.}) {...}{.inline.}</pre></dt> <dd> Same as <code>apply</code> but for proc that do not return and do not mutate <code>s</code> directly. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">apply([0, 1, 2, 3, 4], proc(item: int) = echo item)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L429" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L429" target="_blank">Edit</a> </dd>  <dt><pre id="filter%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">proc filter[T](s: openArray[T]; pred: proc (x: T): bool {...}{.closure.}): seq[T] {...}{.
    inline.}</pre></dt> <dd> <p>Returns a new sequence with all the items of <code>s</code> that fulfilled the predicate <code>pred</code> (function that returns a <code>bool</code>).</p> <p>Instead of using <code>map</code> and <code>filter</code>, consider using the <code>collect</code> macro from the <code>sugar</code> module.</p> <p>See also:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> <li><a href="#filter.i,openArray%5BT%5D,proc(T)">filter iterator</a></li> <li>
<a href="#keepIf,seq%5BT%5D,proc(T)">keepIf proc</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  colors = @["red", "yellow", "black"]
  f1 = filter(colors, proc(x: string): bool = x.len &lt; 6)
  f2 = filter(colors, proc(x: string): bool = x.contains('y'))
assert f1 == @["red", "black"]
assert f2 == @["yellow"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L457" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L457" target="_blank">Edit</a> </dd>  <dt><pre id="keepIf%2Cseq%5BT%5D%2Cproc%28T%29" data-language="nim">proc keepIf[T](s: var seq[T]; pred: proc (x: T): bool {...}{.closure.}) {...}{.inline.}</pre></dt> <dd> <p>Keeps the items in the passed sequence <code>s</code> if they fulfilled the predicate <code>pred</code> (function that returns a <code>bool</code>).</p> <p>Note that <code>s</code> must be declared as a <code>var</code>.</p> <p>Similar to the <a href="#filter,openArray%5BT%5D,proc(T)">filter proc</a>, but modifies the sequence directly.</p> <p>See also:</p> <ul class="simple">
<li><a href="#keepItIf.t,seq,untyped">keepItIf template</a></li> <li><a href="#filter,openArray%5BT%5D,proc(T)">filter proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]
keepIf(floats, proc(x: float): bool = x &gt; 10)
assert floats == @[13.0, 12.5, 10.1]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L484" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L484" target="_blank">Edit</a> </dd>  <dt><pre id="delete%2Cseq%5BT%5D%2CNatural%2CNatural" data-language="nim">proc delete[T](s: var seq[T]; first, last: Natural)</pre></dt> <dd> Deletes in the items of a sequence <code>s</code> at positions <code>first..last</code> (including both ends of a range). This modifies <code>s</code> itself, it does not return a copy. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let outcome = @[1, 1, 1, 1, 1, 1, 1, 1]
var dest = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.delete(3, 8)
assert outcome == dest</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L514" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L514" target="_blank">Edit</a> </dd>  <dt><pre id="insert%2Cseq%5BT%5D%2CopenArray%5BT%5D%2Cint" data-language="nim">proc insert[T](dest: var seq[T]; src: openArray[T]; pos = 0)</pre></dt> <dd> <p>Inserts items from <code>src</code> into <code>dest</code> at position <code>pos</code>. This modifies <code>dest</code> itself, it does not return a copy.</p> <p>Notice that <code>src</code> and <code>dest</code> must be of the same type. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var dest = @[1, 1, 1, 1, 1, 1, 1, 1]
let
  src = @[2, 2, 2, 2, 2, 2]
  outcome = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.insert(src, 3)
assert dest == outcome</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L539" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L539" target="_blank">Edit</a> </dd>  <dt><pre id="all%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">proc all[T](s: openArray[T]; pred: proc (x: T): bool {...}{.closure.}): bool</pre></dt> <dd> <p>Iterates through a container and checks if every item fulfills the predicate.</p> <p>See also:</p> <ul class="simple">
<li><a href="#allIt.t,untyped,untyped">allIt template</a></li> <li><a href="#any,openArray%5BT%5D,proc(T)">any proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert all(numbers, proc (x: int): bool = return x &lt; 10) == true
assert all(numbers, proc (x: int): bool = return x &lt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L651" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L651" target="_blank">Edit</a> </dd>  <dt><pre id="any%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">proc any[T](s: openArray[T]; pred: proc (x: T): bool {...}{.closure.}): bool</pre></dt> <dd> <p>Iterates through a container and checks if some item fulfills the predicate.</p> <p>See also:</p> <ul class="simple">
<li><a href="#anyIt.t,untyped,untyped">anyIt template</a></li> <li><a href="#all,openArray%5BT%5D,proc(T)">all proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert any(numbers, proc (x: int): bool = return x &gt; 8) == true
assert any(numbers, proc (x: int): bool = return x &gt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L693" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L693" target="_blank">Edit</a> </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre id="filter.i%2CopenArray%5BT%5D%2Cproc%28T%29" data-language="nim">iterator filter[T](s: openArray[T]; pred: proc (x: T): bool {...}{.closure.}): T</pre></dt> <dd> <p>Iterates through a container <code>s</code> and yields every item that fulfills the predicate <code>pred</code> (function that returns a <code>bool</code>).</p> <p>Instead of using <code>map</code> and <code>filter</code>, consider using the <code>collect</code> macro from the <code>sugar</code> module.</p> <p>See also:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filter,openArray%5BT%5D,proc(T)">filter proc</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
var evens = newSeq[int]()
for n in filter(numbers, proc (x: int): bool = x mod 2 == 0):
  evens.add(n)
assert evens == @[4, 8, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L434" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L434" target="_blank">Edit</a> </dd>  <dt><pre id="items.i" data-language="nim">iterator items[T](xs: iterator (): T): T</pre></dt> <dd> iterates over each element yielded by a closure iterator. This may not seem particularly useful on its own, but this allows closure iterators to be used by the the mapIt, filterIt, allIt, anyIt, etc. templates. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L1101" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1101" target="_blank">Edit</a> </dd> </dl>  <h2 id="17">Macros</h2> <dl>  <dt><pre id="mapLiterals.m%2Cuntyped%2Cuntyped" data-language="nim">macro mapLiterals(constructor, op: untyped; nested = true): untyped</pre></dt> <dd> <p>Applies <code>op</code> to each of the <strong>atomic</strong> literals like <code>3</code> or <code>"abc"</code> in the specified <code>constructor</code> AST. This can be used to map every array element to some target type:</p> <p>Example:</p> <pre class="listing" data-language="nim">let x = mapLiterals([0.1, 1.2, 2.3, 3.4], int)
doAssert x is array[4, int]</pre>
<p>Short notation for:</p> <pre class="listing" data-language="nim">let x = [int(0.1), int(1.2), int(2.3), int(3.4)]</pre>
<p>If <code>nested</code> is true (which is the default), the literals are replaced everywhere in the <code>constructor</code> AST, otherwise only the first level is considered:</p> <pre class="listing" data-language="nim">let a = mapLiterals((1.2, (2.3, 3.4), 4.8), int)
let b = mapLiterals((1.2, (2.3, 3.4), 4.8), int, nested=false)
assert a == (1, (2, 3), 4)
assert b == (1, (2.3, 3.4), 4)

let c = mapLiterals((1, (2, 3), 4, (5, 6)), `$`)
let d = mapLiterals((1, (2, 3), 4, (5, 6)), `$`, nested=false)
assert c == ("1", ("2", "3"), "4", ("5", "6"))
assert d == ("1", (2, 3), "4", (5, 6))</pre>
<p>There are no constraints for the <code>constructor</code> AST, it works for nested tuples of arrays of sets etc.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L1065" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1065" target="_blank">Edit</a> </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre id="filterIt.t%2Cuntyped%2Cuntyped" data-language="nim">template filterIt(s, pred: untyped): untyped</pre></dt> <dd> <p>Returns a new sequence with all the items of <code>s</code> that fulfilled the predicate <code>pred</code>.</p> <p>Unlike the <a href="#filter,openArray%5BT%5D,proc(T)">filter proc</a> and <a href="#filter.i,openArray%5BT%5D,proc(T)">filter iterator</a>, the predicate needs to be an expression using the <code>it</code> variable for testing, like: <code>filterIt("abcxyz", it == 'x')</code>.</p> <p>Instead of using <code>mapIt</code> and <code>filterIt</code>, consider using the <code>collect</code> macro from the <code>sugar</code> module.</p> <p>See also:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filter,openArray%5BT%5D,proc(T)">fliter proc</a></li> <li><a href="#filter.i,openArray%5BT%5D,proc(T)">filter iterator</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]
  acceptable = temperatures.filterIt(it &lt; 50 and it &gt; -10)
  notAcceptable = temperatures.filterIt(it &gt; 50 or it &lt; -10)
assert acceptable == @[-2.0, 24.5, 44.31]
assert notAcceptable == @[-272.15, 99.9, -113.44]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L573" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L573" target="_blank">Edit</a> </dd>  <dt><pre id="keepItIf.t%2Cseq%2Cuntyped" data-language="nim">template keepItIf(varSeq: seq; pred: untyped)</pre></dt> <dd> <p>Keeps the items in the passed sequence (must be declared as a <code>var</code>) if they fulfilled the predicate.</p> <p>Unlike the <a href="#keepIf,seq%5BT%5D,proc(T)">keepIf proc</a>, the predicate needs to be an expression using the <code>it</code> variable for testing, like: <code>keepItIf("abcxyz", it == 'x')</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#keepIf,seq%5BT%5D,proc(T)">keepIf proc</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var candidates = @["foo", "bar", "baz", "foobar"]
candidates.keepItIf(it.len == 3 and it[0] == 'b')
assert candidates == @["bar", "baz"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L603" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L603" target="_blank">Edit</a> </dd>  <dt><pre id="countIt.t%2Cuntyped%2Cuntyped" data-language="nim">template countIt(s, pred: untyped): int</pre></dt> <dd> <p>Returns a count of all the items that fulfilled the predicate.</p> <p>The predicate needs to be an expression using the <code>it</code> variable for testing, like: <code>countIt(@[1, 2, 3], it &gt; 2)</code>. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]
iterator iota(n: int): int =
  for i in 0..&lt;n: yield i
assert numbers.countIt(it &lt; 0) == 3
assert countIt(iota(10), it &lt; 2) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L633" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L633" target="_blank">Edit</a> </dd>  <dt><pre id="allIt.t%2Cuntyped%2Cuntyped" data-language="nim">template allIt(s, pred: untyped): bool</pre></dt> <dd> <p>Iterates through a container and checks if every item fulfills the predicate.</p> <p>Unlike the <a href="#all,openArray%5BT%5D,proc(T)">all proc</a>, the predicate needs to be an expression using the <code>it</code> variable for testing, like: <code>allIt("abba", it == 'a')</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#all,openArray%5BT%5D,proc(T)">all proc</a></li> <li><a href="#anyIt.t,untyped,untyped">anyIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.allIt(it &lt; 10) == true
assert numbers.allIt(it &lt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L669" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L669" target="_blank">Edit</a> </dd>  <dt><pre id="anyIt.t%2Cuntyped%2Cuntyped" data-language="nim">template anyIt(s, pred: untyped): bool</pre></dt> <dd> <p>Iterates through a container and checks if some item fulfills the predicate.</p> <p>Unlike the <a href="#any,openArray%5BT%5D,proc(T)">any proc</a>, the predicate needs to be an expression using the <code>it</code> variable for testing, like: <code>anyIt("abba", it == 'a')</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#any,openArray%5BT%5D,proc(T)">any proc</a></li> <li><a href="#allIt.t,untyped,untyped">allIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.anyIt(it &gt; 8) == true
assert numbers.anyIt(it &gt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L711" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L711" target="_blank">Edit</a> </dd>  <dt><pre id="toSeq.t%2Cuntyped" data-language="nim">template toSeq(iter: untyped): untyped</pre></dt> <dd> Transforms any iterable (anything that can be iterated over, e.g. with a for-loop) into a sequence. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  myRange = 1..5
  mySet: set[int8] = {5'i8, 3, 1}
assert typeof(myRange) is HSlice[system.int, system.int]
assert typeof(mySet) is set[int8]

let
  mySeq1 = toSeq(myRange)
  mySeq2 = toSeq(mySet)
assert mySeq1 == @[1, 2, 3, 4, 5]
assert mySeq2 == @[1'i8, 3, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L776" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L776" target="_blank">Edit</a> </dd>  <dt><pre id="foldl.t%2Cuntyped%2Cuntyped" data-language="nim">template foldl(sequence, operation: untyped): untyped</pre></dt> <dd> <p>Template to fold a sequence from left to right, returning the accumulation.</p> <p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <code>operation</code>.</p> <p>The <code>operation</code> parameter should be an expression which uses the variables <code>a</code> and <code>b</code> for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#foldl.t,,,">foldl template</a> with a starting parameter</li> <li><a href="#foldr.t,untyped,untyped">foldr template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[5, 9, 11]
  addition = foldl(numbers, a + b)
  subtraction = foldl(numbers, a - b)
  multiplication = foldl(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldl(words, a &amp; b)
  procs = @["proc", "Is", "Also", "Fine"]


proc foo(acc, cur: string): string =
  result = acc &amp; cur

assert addition == 25, "Addition is (((5)+9)+11)"
assert subtraction == -15, "Subtraction is (((5)-9)-11)"
assert multiplication == 495, "Multiplication is (((5)*9)*11)"
assert concatenation == "nimiscool"
assert foldl(procs, foo(a, b)) == "procIsAlsoFine"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L814" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L814" target="_blank">Edit</a> </dd>  <dt><pre id="foldl.t%2C%2C%2C" data-language="nim">template foldl(sequence, operation, first): untyped</pre></dt> <dd> <p>Template to fold a sequence from left to right, returning the accumulation.</p> <p>This version of <code>foldl</code> gets a <strong>starting parameter</strong>. This makes it possible to accumulate the sequence into a different type than the sequence elements.</p> <p>The <code>operation</code> parameter should be an expression which uses the variables <code>a</code> and <code>b</code> for each step of the fold. The <code>first</code> parameter is the start value (the first <code>a</code>) and therefor defines the type of the result.</p> <p>See also:</p> <ul class="simple">
<li><a href="#foldr.t,untyped,untyped">foldr template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[0, 8, 1, 5]
  digits = foldl(numbers, a &amp; (chr(b + ord('0'))), "")
assert digits == "0815"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L863" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L863" target="_blank">Edit</a> </dd>  <dt><pre id="foldr.t%2Cuntyped%2Cuntyped" data-language="nim">template foldr(sequence, operation: untyped): untyped</pre></dt> <dd> <p>Template to fold a sequence from right to left, returning the accumulation.</p> <p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <code>operation</code>.</p> <p>The <code>operation</code> parameter should be an expression which uses the variables <code>a</code> and <code>b</code> for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</p> <p>See also:</p> <ul class="simple">
<li><a href="#foldl.t,untyped,untyped">foldl template</a></li> <li>
<a href="#foldl.t,,,">foldl template</a> with a starting parameter</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[5, 9, 11]
  addition = foldr(numbers, a + b)
  subtraction = foldr(numbers, a - b)
  multiplication = foldr(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldr(words, a &amp; b)
assert addition == 25, "Addition is (5+(9+(11)))"
assert subtraction == 7, "Subtraction is (5-(9-(11)))"
assert multiplication == 495, "Multiplication is (5*(9*(11)))"
assert concatenation == "nimiscool"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L890" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L890" target="_blank">Edit</a> </dd>  <dt><pre id="mapIt.t%2Ctyped%2Cuntyped" data-language="nim">template mapIt(s: typed; op: untyped): untyped</pre></dt> <dd> <p>Returns a new sequence with the results of <code>op</code> proc applied to every item in the container <code>s</code>.</p> <p>Since the input is not modified you can use it to transform the type of the elements in the input container.</p> <p>The template injects the <code>it</code> variable which you can use directly in an expression.</p> <p>Instead of using <code>mapIt</code> and <code>filterIt</code>, consider using the <code>collect</code> macro from the <code>sugar</code> module.</p> <p>See also:</p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#map,openArray%5BT%5D,proc(T)">map proc</a></li> <li>
<a href="#applyIt.t,untyped,untyped">applyIt template</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  nums = @[1, 2, 3, 4]
  strings = nums.mapIt($(4 * it))
assert strings == @["4", "8", "12", "16"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L932" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L932" target="_blank">Edit</a> </dd>  <dt><pre id="applyIt.t%2Cuntyped%2Cuntyped" data-language="nim">template applyIt(varSeq, op: untyped)</pre></dt> <dd> <p>Convenience template around the mutable <code>apply</code> proc to reduce typing.</p> <p>The template injects the <code>it</code> variable which you can use directly in an expression. The expression has to return the same type as the sequence you are mutating.</p> <p>See also:</p> <ul class="simple">
<li><a href="#apply,openArray%5BT%5D,proc(T)_2">apply proc</a></li> <li><a href="#mapIt.t,typed,untyped">mapIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var nums = @[1, 2, 3, 4]
nums.applyIt(it * 3)
assert nums[0] + nums[3] == 15</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L1007" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1007" target="_blank">Edit</a> </dd>  <dt><pre id="newSeqWith.t%2Cint%2Cuntyped" data-language="nim">template newSeqWith(len: int; init: untyped): untyped</pre></dt> <dd> <p>Creates a new sequence of length <code>len</code>, calling <code>init</code> to initialize each value of the sequence.</p> <p>Useful for creating "2D" sequences - sequences containing other sequences or to populate fields of the created sequence. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">## Creates a sequence containing 5 bool sequences, each of length of 3.
var seq2D = newSeqWith(5, newSeq[bool](3))
assert seq2D.len == 5
assert seq2D[0].len == 3
assert seq2D[4][2] == false

## Creates a sequence of 20 random numbers from 1 to 10
import random
var seqRand = newSeqWith(20, rand(10))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/sequtils.nim#L1028" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1028" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/sequtils.html" class="_attribution-link">https://nim-lang.org/docs/sequtils.html</a>
  </p>
</div>
