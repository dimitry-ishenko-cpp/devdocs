<h1 class="title">std/sequtils</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1" target="_blank">Edit</a>  <p class="module-desc">Although this module has <code><span class="Identifier">seq</span></code> in its name, it implements operations not only for the <span id="seq_1">seq</span> type, but for three built-in container types under the <code><span class="Identifier">openArray</span></code> umbrella:</p>
<ul class="simple">
<li>sequences</li> <li>strings</li> <li>array</li> </ul> <p>The <code><span class="Identifier">system</span></code> module defines several common functions, such as:</p> <ul class="simple">
<li>
<code><span class="Identifier">newSeq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> for creating new sequences of type <code><span class="Identifier">T</span></code>
</li> <li>
<code><span class="Operator">@</span></code> for converting arrays and strings to sequences</li> <li>
<code><span class="Identifier">add</span></code> for adding new elements to strings and sequences</li> <li>
<code><span class="Operator">&amp;</span></code> for string and seq concatenation</li> <li>
<code><span class="Keyword">in</span></code> (alias for <code><span class="Identifier">contains</span></code>) and <code><span class="Keyword">notin</span></code> for checking if an item is in a container</li> </ul> <p>This module builds upon that, providing additional functionality in form of procs, iterators and templates inspired by functional programming languages.</p> <p>For functional style programming you have different options at your disposal:</p> <ul class="simple">
<li>the <a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a>
</li> <li>pass an <a href="manual.html#procedures-anonymous-procs">anonymous proc</a>
</li> <li>import the <a href="sugar.html">sugar module</a> and use the <a href="#">=&gt; macro</a>
</li> <li>use <a href="#18">...It templates</a> (<a href="#mapIt.t,typed,untyped">mapIt</a>, <a href="#filterIt.t,untyped,untyped">filterIt</a>, etc.)</li> </ul> <p>Chaining of functions is possible thanks to the <a href="manual.html#procedures-method-call-syntax">method call syntax</a>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/sequtils
import std/sugar

# Creating a sequence from 1 to 10, multiplying each member by 2,
# keeping only the members which are not divisible by 6.
let
  foo = toSeq(1..10).map(x =&gt; x * 2).filter(x =&gt; x mod 6 != 0)
  bar = toSeq(1..10).mapIt(it * 2).filterIt(it mod 6 != 0)
  baz = collect:
    for i in 1..10:
      let j = 2 * i
      if j mod 6 != 0:
        j

doAssert foo == bar
doAssert foo == baz
doAssert foo == @[2, 4, 8, 10, 14, 16, 20]

doAssert foo.any(x =&gt; x &gt; 17)
doAssert not bar.allIt(it &lt; 20)
doAssert foo.foldl(a + b) == 74 # sum of all members</pre> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/sequtils
from std/strutils import join

let
  vowels = @"aeiou"
  foo = "sequtils is an awesome module"

doAssert (vowels is seq[char]) and (vowels == @['a', 'e', 'i', 'o', 'u'])
doAssert foo.filterIt(it notin vowels).join == "sqtls s n wsm mdl"</pre> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="strutils.html">strutils module</a> for common string functions</li> <li>
<a href="sugar.html">sugar module</a> for syntactic sugar macros</li> <li>
<a href="algorithm.html">algorithm module</a> for common generic algorithms</li> <li>
<a href="json.html">json module</a> for a structure which allows heterogeneous members</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a>, <a href="macros.html">macros</a> </dl>   <h2 id="12">Procs</h2> <dl> <div id="all-procs-all"> <div id="all,openArray[T],proc(T)"> <dt><pre data-language="nim">proc all[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): bool {.
    effectsOf: pred.}</pre></dt> <dd> <p>Iterates through a container and checks if every item fulfills the predicate.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#allIt.t,untyped,untyped">allIt template</a></li> <li><a href="#any,openArray[T],proc(T)">any proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert all(numbers, proc (x: int): bool = x &lt; 10) == true
assert all(numbers, proc (x: int): bool = x &lt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L705" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L705" target="_blank">Edit</a> </dd> </div> </div> <div id="any-procs-all"> <div id="any,openArray[T],proc(T)"> <dt><pre data-language="nim">proc any[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): bool {.
    effectsOf: pred.}</pre></dt> <dd> <p>Iterates through a container and checks if at least one item fulfills the predicate.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#anyIt.t,untyped,untyped">anyIt template</a></li> <li><a href="#all,openArray[T],proc(T)">all proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert any(numbers, proc (x: int): bool = x &gt; 8) == true
assert any(numbers, proc (x: int): bool = x &gt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L747" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L747" target="_blank">Edit</a> </dd> </div> </div> <div id="apply-procs-all"> <div id="apply,openArray[T],proc(T)_3"> <dt><pre data-language="nim">proc apply[T](s: openArray[T]; op: proc (x: T) {.closure.}) {.inline,
    effectsOf: op.}</pre></dt> <dd> Same as <code><span class="Identifier">apply</span></code> but for a proc that does not return anything and does not mutate <code><span class="Identifier">s</span></code> directly. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var message: string
apply([0, 1, 2, 3, 4], proc(item: int) = message.addInt item)
assert message == "01234"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L440" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L440" target="_blank">Edit</a> </dd> </div> <div id="apply,openArray[T],proc(T)_2"> <dt><pre data-language="nim">proc apply[T](s: var openArray[T]; op: proc (x: T): T {.closure.}) {.inline,
    effectsOf: op.}</pre></dt> <dd> <p>Applies <code><span class="Identifier">op</span></code> to every item in <code><span class="Identifier">s</span></code> modifying it directly.</p> <p>Note that the container <code><span class="Identifier">s</span></code> must be declared as a <code><span class="Keyword">var</span></code> and it is required for your input and output types to be the same, since <code><span class="Identifier">s</span></code> is modified in-place. The parameter function takes and returns a <code><span class="Identifier">T</span></code> type variable.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#applyIt.t,untyped,untyped">applyIt template</a></li> <li><a href="#map,openArray[T],proc(T)">map proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @["1", "2", "3", "4"]
apply(a, proc(x: string): string = x &amp; "42")
assert a == @["142", "242", "342", "442"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L420" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L420" target="_blank">Edit</a> </dd> </div> <div id="apply,openArray[T],proc(T)"> <dt><pre data-language="nim">proc apply[T](s: var openArray[T]; op: proc (x: var T) {.closure.}) {.inline,
    effectsOf: op.}</pre></dt> <dd> <p>Applies <code><span class="Identifier">op</span></code> to every item in <code><span class="Identifier">s</span></code>, modifying it directly.</p> <p>Note that the container <code><span class="Identifier">s</span></code> must be declared as a <code><span class="Keyword">var</span></code>, since <code><span class="Identifier">s</span></code> is modified in-place. The parameter function takes a <code><span class="Keyword">var</span> <span class="Identifier">T</span></code> type parameter.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#applyIt.t,untyped,untyped">applyIt template</a></li> <li><a href="#map,openArray[T],proc(T)">map proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @["1", "2", "3", "4"]
apply(a, proc(x: var string) = x &amp;= "42")
assert a == @["142", "242", "342", "442"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L401" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L401" target="_blank">Edit</a> </dd> </div> </div> <div id="concat-procs-all"> <div id="concat,varargs[seq[T]]"> <dt><pre data-language="nim">func concat[T](seqs: varargs[seq[T]]): seq[T]</pre></dt> <dd> <p>Takes several sequences' items and returns them inside a new sequence. All sequences must be of the same type.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#distribute,seq[T],Positive">distribute func</a> for a reverse operation</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  s1 = @[1, 2, 3]
  s2 = @[4, 5]
  s3 = @[6, 7]
  total = concat(s1, s2, s3)
assert total == @[1, 2, 3, 4, 5, 6, 7]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L118" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L118" target="_blank">Edit</a> </dd> </div> </div> <div id="count-procs-all"> <div id="count,openArray[T],T"> <dt><pre data-language="nim">func count[T](s: openArray[T]; x: T): int</pre></dt> <dd> Returns the number of occurrences of the item <code><span class="Identifier">x</span></code> in the container <code><span class="Identifier">s</span></code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 2, 3, 2, 4, 2]
  b = "abracadabra"
assert count(a, 2) == 4
assert count(a, 99) == 0
assert count(b, 'r') == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L143" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L143" target="_blank">Edit</a> </dd> </div> </div> <div id="cycle-procs-all"> <div id="cycle,openArray[T],Natural"> <dt><pre data-language="nim">func cycle[T](s: openArray[T]; n: Natural): seq[T]</pre></dt> <dd> Returns a new sequence with the items of the container <code><span class="Identifier">s</span></code> repeated <code><span class="Identifier">n</span></code> times. <code><span class="Identifier">n</span></code> must be a non-negative number (zero or more). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  s = @[1, 2, 3]
  total = s.cycle(3)
assert total == @[1, 2, 3, 1, 2, 3, 1, 2, 3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L158" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L158" target="_blank">Edit</a> </dd> </div> </div> <div id="deduplicate-procs-all"> <div id="deduplicate,openArray[T],bool"> <dt><pre data-language="nim">func deduplicate[T](s: openArray[T]; isSorted: bool = false): seq[T]</pre></dt> <dd> <p>Returns a new sequence without duplicates.</p> <p>Setting the optional argument <code><span class="Identifier">isSorted</span></code> to true (default: false) uses a faster algorithm for deduplication. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  dup1 = @[1, 1, 3, 4, 2, 2, 8, 1, 4]
  dup2 = @["a", "a", "c", "d", "d"]
  unique1 = deduplicate(dup1)
  unique2 = deduplicate(dup2, isSorted = true)
assert unique1 == @[1, 3, 4, 2, 8]
assert unique2 == @["a", "c", "d"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L189" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L189" target="_blank">Edit</a> </dd> </div> </div> <div id="delete-procs-all"> <div id="delete,seq[T],Natural,Natural"> <dt><pre data-language="nim">func delete[T](s: var seq[T]; first, last: Natural) {.
    ...deprecated: "use `delete(s, first..last)`".}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> use `delete(s, first..last)` </div> Deletes the items of a sequence <code><span class="Identifier">s</span></code> at positions <code><span class="Identifier">first</span><span class="Operator">..</span><span class="Identifier">last</span></code> (including both ends of the range). This modifies <code><span class="Identifier">s</span></code> itself, it does not return a copy. <p><strong class="examples_text">Example: cmd: --warning:deprecated:off</strong></p> <pre class="listing" data-language="nim">let outcome = @[1, 1, 1, 1, 1, 1, 1, 1]
var dest = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.delete(3, 8)
assert outcome == dest</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L569" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L569" target="_blank">Edit</a> </dd> </div> <div id="delete,seq[T],Slice[int]"> <dt><pre data-language="nim">func delete[T](s: var seq[T]; slice: Slice[int])</pre></dt> <dd> <p>Deletes the items <code><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">slice</span><span class="Punctuation">]</span></code>, raising <code><span class="Identifier">IndexDefect</span></code> if the slice contains elements out of range.</p> <p>This operation moves all elements after <code><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">slice</span><span class="Punctuation">]</span></code> in linear time.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @[10, 11, 12, 13, 14]
doAssertRaises(IndexDefect): a.delete(4..5)
assert a == @[10, 11, 12, 13, 14]
a.delete(4..4)
assert a == @[10, 11, 12, 13]
a.delete(1..2)
assert a == @[10, 13]
a.delete(1..&lt;1) # empty slice
assert a == @[10, 13]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L529" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L529" target="_blank">Edit</a> </dd> </div> </div> <div id="distribute-procs-all"> <div id="distribute,seq[T],Positive"> <dt><pre data-language="nim">func distribute[T](s: seq[T]; num: Positive; spread = true): seq[seq[T]]</pre></dt> <dd> <p>Splits and distributes a sequence <code><span class="Identifier">s</span></code> into <code><span class="Identifier">num</span></code> sub-sequences.</p> <p>Returns a sequence of <code><span class="Identifier">num</span></code> sequences. For <em>some</em> input values this is the inverse of the <a href="#concat,varargs[seq[T]]">concat</a> func. The input sequence <code><span class="Identifier">s</span></code> can be empty, which will produce <code><span class="Identifier">num</span></code> empty sequences.</p> <p>If <code><span class="Identifier">spread</span></code> is false and the length of <code><span class="Identifier">s</span></code> is not a multiple of <code><span class="Identifier">num</span></code>, the func will max out the first sub-sequence with <code><span class="DecNumber">1</span> <span class="Operator">+</span> <span class="Identifier">len</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">)</span> <span class="Keyword">div</span> <span class="Identifier">num</span></code> entries, leaving the remainder of elements to the last sequence.</p> <p>On the other hand, if <code><span class="Identifier">spread</span></code> is true, the func will distribute evenly the remainder of the division across all sequences, which makes the result more suited to multithreading where you are passing equal sized work units to a thread pool and want to maximize core usage. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 2, 3, 4, 5, 6, 7]
assert numbers.distribute(3) == @[@[1, 2, 3], @[4, 5], @[6, 7]]
assert numbers.distribute(3, false) == @[@[1, 2, 3], @[4, 5, 6], @[7]]
assert numbers.distribute(6)[0] == @[1, 2]
assert numbers.distribute(6)[1] == @[3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L319" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L319" target="_blank">Edit</a> </dd> </div> </div> <div id="filter-procs-all"> <div id="filter,openArray[T],proc(T)"> <dt><pre data-language="nim">proc filter[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): seq[T] {.
    inline, effectsOf: pred.}</pre></dt> <dd> <p>Returns a new sequence with all the items of <code><span class="Identifier">s</span></code> that fulfill the predicate <code><span class="Identifier">pred</span></code> (a function that returns a <code><span class="Identifier">bool</span></code>).</p> <p>Instead of using <code><span class="Identifier">map</span></code> and <code><span class="Identifier">filter</span></code>, consider using the <code><span class="Identifier">collect</span></code> macro from the <code><span class="Identifier">sugar</span></code> module.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> <li><a href="#filter.i,openArray[T],proc(T)">filter iterator</a></li> <li>
<a href="#keepIf,seq[T],proc(T)">keepIf proc</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  colors = @["red", "yellow", "black"]
  f1 = filter(colors, proc(x: string): bool = x.len &lt; 6)
  f2 = filter(colors, proc(x: string): bool = x.contains('y'))
assert f1 == @["red", "black"]
assert f2 == @["yellow"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L472" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L472" target="_blank">Edit</a> </dd> </div> </div> <div id="insert-procs-all"> <div id="insert,seq[T],openArray[T],int"> <dt><pre data-language="nim">func insert[T](dest: var seq[T]; src: openArray[T]; pos = 0)</pre></dt> <dd> <p>Inserts items from <code><span class="Identifier">src</span></code> into <code><span class="Identifier">dest</span></code> at position <code><span class="Identifier">pos</span></code>. This modifies <code><span class="Identifier">dest</span></code> itself, it does not return a copy.</p> <p>Note that the elements of <code><span class="Identifier">src</span></code> and <code><span class="Identifier">dest</span></code> must be of the same type. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var dest = @[1, 1, 1, 1, 1, 1, 1, 1]
let
  src = @[2, 2, 2, 2, 2, 2]
  outcome = @[1, 1, 1, 2, 2, 2, 2, 2, 2, 1, 1, 1, 1, 1]
dest.insert(src, 3)
assert dest == outcome</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L593" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L593" target="_blank">Edit</a> </dd> </div> </div> <div id="keepIf-procs-all"> <div id="keepIf,seq[T],proc(T)"> <dt><pre data-language="nim">proc keepIf[T](s: var seq[T]; pred: proc (x: T): bool {.closure.}) {.inline,
    effectsOf: pred.}</pre></dt> <dd> <p>Keeps the items in the passed sequence <code><span class="Identifier">s</span></code> if they fulfill the predicate <code><span class="Identifier">pred</span></code> (a function that returns a <code><span class="Identifier">bool</span></code>).</p> <p>Note that <code><span class="Identifier">s</span></code> must be declared as a <code><span class="Keyword">var</span></code>.</p> <p>Similar to the <a href="#filter,openArray[T],proc(T)">filter proc</a>, but modifies the sequence directly.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#keepItIf.t,seq,untyped">keepItIf template</a></li> <li><a href="#filter,openArray[T],proc(T)">filter proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var floats = @[13.0, 12.5, 5.8, 2.0, 6.1, 9.9, 10.1]
keepIf(floats, proc(x: float): bool = x &gt; 10)
assert floats == @[13.0, 12.5, 10.1]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L499" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L499" target="_blank">Edit</a> </dd> </div> </div> <div id="map-procs-all"> <div id="map,openArray[T],proc(T)"> <dt><pre data-language="nim">proc map[T, S](s: openArray[T]; op: proc (x: T): S {.closure.}): seq[S] {.
    inline, effectsOf: op.}</pre></dt> <dd> <p>Returns a new sequence with the results of the <code><span class="Identifier">op</span></code> proc applied to every item in the container <code><span class="Identifier">s</span></code>.</p> <p>Since the input is not modified, you can use it to transform the type of the elements in the input container.</p> <p>Instead of using <code><span class="Identifier">map</span></code> and <code><span class="Identifier">filter</span></code>, consider using the <code><span class="Identifier">collect</span></code> macro from the <code><span class="Identifier">sugar</span></code> module.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#mapIt.t,typed,untyped">mapIt template</a></li> <li>
<a href="#apply,openArray[T],proc(T)_2">apply proc</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = map(a, proc(x: int): string = $x)
assert b == @["1", "2", "3", "4"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L375" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L375" target="_blank">Edit</a> </dd> </div> </div> <div id="maxIndex-procs-all"> <div id="maxIndex,openArray[T]"> <dt><pre data-language="nim">func maxIndex[T](s: openArray[T]): int</pre></dt> <dd> Returns the index of the maximum value of <code><span class="Identifier">s</span></code>. <code><span class="Identifier">T</span></code> needs to have a <code><span class="Operator">&lt;</span></code> operator. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert maxIndex(a) == 3
assert maxIndex(b) == 0
assert maxIndex(c) == 2
assert maxIndex(d) == 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L234" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L234" target="_blank">Edit</a> </dd> </div> </div> <div id="minIndex-procs-all"> <div id="minIndex,openArray[T]"> <dt><pre data-language="nim">func minIndex[T](s: openArray[T]): int</pre></dt> <dd> Returns the index of the minimum value of <code><span class="Identifier">s</span></code>. <code><span class="Identifier">T</span></code> needs to have a <code><span class="Operator">&lt;</span></code> operator. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = @[1, 2, 3, 4]
  b = @[6, 5, 4, 3]
  c = [2, -7, 8, -5]
  d = "ziggy"
assert minIndex(a) == 0
assert minIndex(b) == 3
assert minIndex(c) == 1
assert minIndex(d) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L217" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L217" target="_blank">Edit</a> </dd> </div> </div> <div id="minmax-procs-all"> <div id="minmax,openArray[T]"> <dt><pre data-language="nim">func minmax[T](x: openArray[T]): (T, T)</pre></dt> <dd> The minimum and maximum values of <code><span class="Identifier">x</span></code>. <code><span class="Identifier">T</span></code> needs to have a <code><span class="Operator">&lt;</span></code> operator. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L251" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L251" target="_blank">Edit</a> </dd> </div> </div> <div id="repeat-procs-all"> <div id="repeat,T,Natural"> <dt><pre data-language="nim">proc repeat[T](x: T; n: Natural): seq[T]</pre></dt> <dd> Returns a new sequence with the item <code><span class="Identifier">x</span></code> repeated <code><span class="Identifier">n</span></code> times. <code><span class="Identifier">n</span></code> must be a non-negative number (zero or more). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  total = repeat(5, 3)
assert total == @[5, 5, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L176" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L176" target="_blank">Edit</a> </dd> </div> </div> <div id="unzip-procs-all"> <div id="unzip,openArray[]"> <dt><pre data-language="nim">proc unzip[S, T](s: openArray[(S, T)]): (seq[S], seq[T])</pre></dt> <dd> Returns a tuple of two sequences split out from a sequence of 2-field tuples. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  zipped = @[(1, 'a'), (2, 'b'), (3, 'c')]
  unzipped1 = @[1, 2, 3]
  unzipped2 = @['a', 'b', 'c']
assert zipped.unzip() == (unzipped1, unzipped2)
assert zip(unzipped1, unzipped2).unzip() == (unzipped1, unzipped2)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L305" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L305" target="_blank">Edit</a> </dd> </div> </div> <div id="zip-procs-all"> <div id="zip,,"> <dt><pre data-language="nim">proc zip[S, T](s1: openArray[S]; s2: openArray[T]): seq[(S, T)]</pre></dt> <dd> <p>Returns a new sequence with a combination of the two input containers.</p> <p>The input containers can be of different types. If one container is shorter, the remaining items in the longer container are discarded.</p> <p><strong>Note</strong>: For Nim 1.0.x and older version, <code><span class="Identifier">zip</span></code> returned a seq of named tuples with fields <code><span class="Identifier">a</span></code> and <code><span class="Identifier">b</span></code>. For Nim versions 1.1.x and newer, <code><span class="Identifier">zip</span></code> returns a seq of unnamed tuples.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  short = @[1, 2, 3]
  long = @[6, 5, 4, 3, 2, 1]
  words = @["one", "two", "three"]
  letters = "abcd"
  zip1 = zip(short, long)
  zip2 = zip(short, words)
assert zip1 == @[(1, 6), (2, 5), (3, 4)]
assert zip2 == @[(1, "one"), (2, "two"), (3, "three")]
assert zip1[2][0] == 3
assert zip2[1][1] == "two"
when (NimMajor, NimMinor) &lt;= (1, 0):
  let
    zip3 = zip(long, letters)
  assert zip3 == @[(a: 6, b: 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].b == 'a'
else:
  let
    zip3: seq[tuple[num: int, letter: char]] = zip(long, letters)
  assert zip3 == @[(6, 'a'), (5, 'b'), (4, 'c'), (3, 'd')]
  assert zip3[0].letter == 'a'</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L303" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L303" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="15">Iterators</h2> <dl> <div id="filter-iterators-all"> <div id="filter.i,openArray[T],proc(T)"> <dt><pre data-language="nim">iterator filter[T](s: openArray[T]; pred: proc (x: T): bool {.closure.}): T {.
    effectsOf: pred.}</pre></dt> <dd> <p>Iterates through a container <code><span class="Identifier">s</span></code> and yields every item that fulfills the predicate <code><span class="Identifier">pred</span></code> (a function that returns a <code><span class="Identifier">bool</span></code>).</p> <p>Instead of using <code><span class="Identifier">map</span></code> and <code><span class="Identifier">filter</span></code>, consider using the <code><span class="Identifier">collect</span></code> macro from the <code><span class="Identifier">sugar</span></code> module.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filter,openArray[T],proc(T)">filter proc</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
var evens = newSeq[int]()
for n in filter(numbers, proc (x: int): bool = x mod 2 == 0):
  evens.add(n)
assert evens == @[4, 8, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L449" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L449" target="_blank">Edit</a> </dd> </div> </div> <div id="items-iterators-all"> <div id="items.i"> <dt><pre data-language="nim">iterator items[T](xs: iterator (): T): T</pre></dt> <dd> Iterates over each element yielded by a closure iterator. This may not seem particularly useful on its own, but this allows closure iterators to be used by the mapIt, filterIt, allIt, anyIt, etc. templates. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L1135" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1135" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="17">Macros</h2> <dl> <div id="mapLiterals-macros-all"> <div id="mapLiterals.m,untyped,untyped"> <dt><pre data-language="nim">macro mapLiterals(constructor, op: untyped; nested = true): untyped</pre></dt> <dd> Applies <code><span class="Identifier">op</span></code> to each of the <strong>atomic</strong> literals like <code><span class="DecNumber">3</span></code> or <code><span class="StringLit">"abc"</span></code> in the specified <code><span class="Identifier">constructor</span></code> AST. This can be used to map every array element to some target type: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = mapLiterals([0.1, 1.2, 2.3, 3.4], int)
doAssert x is array[4, int]
doAssert x == [int(0.1), int(1.2), int(2.3), int(3.4)]</pre>If <code><span class="Identifier">nested</span></code> is true (which is the default), the literals are replaced everywhere in the <code><span class="Identifier">constructor</span></code> AST, otherwise only the first level is considered: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = mapLiterals((1.2, (2.3, 3.4), 4.8), int)
let b = mapLiterals((1.2, (2.3, 3.4), 4.8), int, nested=false)
assert a == (1, (2, 3), 4)
assert b == (1, (2.3, 3.4), 4)

let c = mapLiterals((1, (2, 3), 4, (5, 6)), `$`)
let d = mapLiterals((1, (2, 3), 4, (5, 6)), `$`, nested=false)
assert c == ("1", ("2", "3"), "4", ("5", "6"))
assert d == ("1", (2, 3), "4", (5, 6))</pre>There are no constraints for the <code><span class="Identifier">constructor</span></code> AST, it works for nested tuples of arrays of sets etc. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L1109" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1109" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="18">Templates</h2> <dl> <div id="allIt-templates-all"> <div id="allIt.t,untyped,untyped"> <dt><pre data-language="nim">template allIt(s, pred: untyped): bool</pre></dt> <dd> <p>Iterates through a container and checks if every item fulfills the predicate.</p> <p>Unlike the <a href="#all,openArray[T],proc(T)">all proc</a>, the predicate needs to be an expression using the <code><span class="Identifier">it</span></code> variable for testing, like: <code><span class="Identifier">allIt</span><span class="Punctuation">(</span><span class="StringLit">"abba"</span><span class="Punctuation">,</span> <span class="Identifier">it</span> <span class="Operator">==</span> <span class="CharLit">'a'</span><span class="Punctuation">)</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#all,openArray[T],proc(T)">all proc</a></li> <li><a href="#anyIt.t,untyped,untyped">anyIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.allIt(it &lt; 10) == true
assert numbers.allIt(it &lt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L723" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L723" target="_blank">Edit</a> </dd> </div> </div> <div id="anyIt-templates-all"> <div id="anyIt.t,untyped,untyped"> <dt><pre data-language="nim">template anyIt(s, pred: untyped): bool</pre></dt> <dd> <p>Iterates through a container and checks if at least one item fulfills the predicate.</p> <p>Unlike the <a href="#any,openArray[T],proc(T)">any proc</a>, the predicate needs to be an expression using the <code><span class="Identifier">it</span></code> variable for testing, like: <code><span class="Identifier">anyIt</span><span class="Punctuation">(</span><span class="StringLit">"abba"</span><span class="Punctuation">,</span> <span class="Identifier">it</span> <span class="Operator">==</span> <span class="CharLit">'a'</span><span class="Punctuation">)</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#any,openArray[T],proc(T)">any proc</a></li> <li><a href="#allIt.t,untyped,untyped">allIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[1, 4, 5, 8, 9, 7, 4]
assert numbers.anyIt(it &gt; 8) == true
assert numbers.anyIt(it &gt; 9) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L765" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L765" target="_blank">Edit</a> </dd> </div> </div> <div id="applyIt-templates-all"> <div id="applyIt.t,untyped,untyped"> <dt><pre data-language="nim">template applyIt(varSeq, op: untyped)</pre></dt> <dd> <p>Convenience template around the mutable <code><span class="Identifier">apply</span></code> proc to reduce typing.</p> <p>The template injects the <code><span class="Identifier">it</span></code> variable which you can use directly in an expression. The expression has to return the same type as the elements of the sequence you are mutating.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#apply,openArray[T],proc(T)_2">apply proc</a></li> <li><a href="#mapIt.t,typed,untyped">mapIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var nums = @[1, 2, 3, 4]
nums.applyIt(it * 3)
assert nums[0] + nums[3] == 15</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L1051" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1051" target="_blank">Edit</a> </dd> </div> </div> <div id="countIt-templates-all"> <div id="countIt.t,untyped,untyped"> <dt><pre data-language="nim">template countIt(s, pred: untyped): int</pre></dt> <dd> <p>Returns a count of all the items that fulfill the predicate.</p> <p>The predicate needs to be an expression using the <code><span class="Identifier">it</span></code> variable for testing, like: <code><span class="Identifier">countIt</span><span class="Punctuation">(</span><span class="Operator">@</span><span class="Punctuation">[</span><span class="DecNumber">1</span><span class="Punctuation">,</span> <span class="DecNumber">2</span><span class="Punctuation">,</span> <span class="DecNumber">3</span><span class="Punctuation">]</span><span class="Punctuation">,</span> <span class="Identifier">it</span> <span class="Operator">&gt;</span> <span class="DecNumber">2</span><span class="Punctuation">)</span></code>. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let numbers = @[-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]
iterator iota(n: int): int =
  for i in 0..&lt;n: yield i
assert numbers.countIt(it &lt; 0) == 3
assert countIt(iota(10), it &lt; 2) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L687" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L687" target="_blank">Edit</a> </dd> </div> </div> <div id="filterIt-templates-all"> <div id="filterIt.t,untyped,untyped"> <dt><pre data-language="nim">template filterIt(s, pred: untyped): untyped</pre></dt> <dd> <p>Returns a new sequence with all the items of <code><span class="Identifier">s</span></code> that fulfill the predicate <code><span class="Identifier">pred</span></code>.</p> <p>Unlike the <a href="#filter,openArray[T],proc(T)">filter proc</a> and <a href="#filter.i,openArray[T],proc(T)">filter iterator</a>, the predicate needs to be an expression using the <code><span class="Identifier">it</span></code> variable for testing, like: <code><span class="Identifier">filterIt</span><span class="Punctuation">(</span><span class="StringLit">"abcxyz"</span><span class="Punctuation">,</span> <span class="Identifier">it</span> <span class="Operator">==</span> <span class="CharLit">'x'</span><span class="Punctuation">)</span></code>.</p> <p>Instead of using <code><span class="Identifier">mapIt</span></code> and <code><span class="Identifier">filterIt</span></code>, consider using the <code><span class="Identifier">collect</span></code> macro from the <code><span class="Identifier">sugar</span></code> module.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#filter,openArray[T],proc(T)">filter proc</a></li> <li><a href="#filter.i,openArray[T],proc(T)">filter iterator</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  temperatures = @[-272.15, -2.0, 24.5, 44.31, 99.9, -113.44]
  acceptable = temperatures.filterIt(it &lt; 50 and it &gt; -10)
  notAcceptable = temperatures.filterIt(it &gt; 50 or it &lt; -10)
assert acceptable == @[-2.0, 24.5, 44.31]
assert notAcceptable == @[-272.15, 99.9, -113.44]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L627" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L627" target="_blank">Edit</a> </dd> </div> </div> <div id="foldl-templates-all"> <div id="foldl.t,,,"> <dt><pre data-language="nim">template foldl(sequence, operation, first): untyped</pre></dt> <dd> <p>Template to fold a sequence from left to right, returning the accumulation.</p> <p>This version of <code><span class="Identifier">foldl</span></code> gets a <strong>starting parameter</strong>. This makes it possible to accumulate the sequence into a different type than the sequence elements.</p> <p>The <code><span class="Identifier">operation</span></code> parameter should be an expression which uses the variables <code><span class="Identifier">a</span></code> and <code><span class="Identifier">b</span></code> for each step of the fold. The <code><span class="Identifier">first</span></code> parameter is the start value (the first <code><span class="Identifier">a</span></code>) and therefore defines the type of the result.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#foldr.t,untyped,untyped">foldr template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[0, 8, 1, 5]
  digits = foldl(numbers, a &amp; (chr(b + ord('0'))), "")
assert digits == "0815"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L917" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L917" target="_blank">Edit</a> </dd> </div> <div id="foldl.t,untyped,untyped"> <dt><pre data-language="nim">template foldl(sequence, operation: untyped): untyped</pre></dt> <dd> <p>Template to fold a sequence from left to right, returning the accumulation.</p> <p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <code><span class="Identifier">operation</span></code>.</p> <p>The <code><span class="Identifier">operation</span></code> parameter should be an expression which uses the variables <code><span class="Identifier">a</span></code> and <code><span class="Identifier">b</span></code> for each step of the fold. Since this is a left fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (((1) - 2) - 3).</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#foldl.t,,,">foldl template</a> with a starting parameter</li> <li><a href="#foldr.t,untyped,untyped">foldr template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[5, 9, 11]
  addition = foldl(numbers, a + b)
  subtraction = foldl(numbers, a - b)
  multiplication = foldl(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldl(words, a &amp; b)
  procs = @["proc", "Is", "Also", "Fine"]


func foo(acc, cur: string): string =
  result = acc &amp; cur

assert addition == 25, "Addition is (((5)+9)+11)"
assert subtraction == -15, "Subtraction is (((5)-9)-11)"
assert multiplication == 495, "Multiplication is (((5)*9)*11)"
assert concatenation == "nimiscool"
assert foldl(procs, foo(a, b)) == "procIsAlsoFine"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L868" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L868" target="_blank">Edit</a> </dd> </div> </div> <div id="foldr-templates-all"> <div id="foldr.t,untyped,untyped"> <dt><pre data-language="nim">template foldr(sequence, operation: untyped): untyped</pre></dt> <dd> <p>Template to fold a sequence from right to left, returning the accumulation.</p> <p>The sequence is required to have at least a single element. Debug versions of your program will assert in this situation but release versions will happily go ahead. If the sequence has a single element it will be returned without applying <code><span class="Identifier">operation</span></code>.</p> <p>The <code><span class="Identifier">operation</span></code> parameter should be an expression which uses the variables <code><span class="Identifier">a</span></code> and <code><span class="Identifier">b</span></code> for each step of the fold. Since this is a right fold, for non associative binary operations like subtraction think that the sequence of numbers 1, 2 and 3 will be parenthesized as (1 - (2 - (3))).</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#foldl.t,untyped,untyped">foldl template</a></li> <li>
<a href="#foldl.t,,,">foldl template</a> with a starting parameter</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  numbers = @[5, 9, 11]
  addition = foldr(numbers, a + b)
  subtraction = foldr(numbers, a - b)
  multiplication = foldr(numbers, a * b)
  words = @["nim", "is", "cool"]
  concatenation = foldr(words, a &amp; b)
assert addition == 25, "Addition is (5+(9+(11)))"
assert subtraction == 7, "Subtraction is (5-(9-(11)))"
assert multiplication == 495, "Multiplication is (5*(9*(11)))"
assert concatenation == "nimiscool"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L944" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L944" target="_blank">Edit</a> </dd> </div> </div> <div id="keepItIf-templates-all"> <div id="keepItIf.t,seq,untyped"> <dt><pre data-language="nim">template keepItIf(varSeq: seq; pred: untyped)</pre></dt> <dd> <p>Keeps the items in the passed sequence (must be declared as a <code><span class="Keyword">var</span></code>) if they fulfill the predicate.</p> <p>Unlike the <a href="#keepIf,seq[T],proc(T)">keepIf proc</a>, the predicate needs to be an expression using the <code><span class="Identifier">it</span></code> variable for testing, like: <code><span class="Identifier">keepItIf</span><span class="Punctuation">(</span><span class="StringLit">"abcxyz"</span><span class="Punctuation">,</span> <span class="Identifier">it</span> <span class="Operator">==</span> <span class="CharLit">'x'</span><span class="Punctuation">)</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#keepIf,seq[T],proc(T)">keepIf proc</a></li> <li><a href="#filterIt.t,untyped,untyped">filterIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var candidates = @["foo", "bar", "baz", "foobar"]
candidates.keepItIf(it.len == 3 and it[0] == 'b')
assert candidates == @["bar", "baz"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L657" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L657" target="_blank">Edit</a> </dd> </div> </div> <div id="mapIt-templates-all"> <div id="mapIt.t,typed,untyped"> <dt><pre data-language="nim">template mapIt(s: typed; op: untyped): untyped</pre></dt> <dd> <p>Returns a new sequence with the results of the <code><span class="Identifier">op</span></code> proc applied to every item in the container <code><span class="Identifier">s</span></code>.</p> <p>Since the input is not modified you can use it to transform the type of the elements in the input container.</p> <p>The template injects the <code><span class="Identifier">it</span></code> variable which you can use directly in an expression.</p> <p>Instead of using <code><span class="Identifier">mapIt</span></code> and <code><span class="Identifier">filterIt</span></code>, consider using the <code><span class="Identifier">collect</span></code> macro from the <code><span class="Identifier">sugar</span></code> module.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="sugar.html#collect.m%2Cuntyped%2Cuntyped">sugar.collect macro</a></li> <li><a href="#map,openArray[T],proc(T)">map proc</a></li> <li>
<a href="#applyIt.t,untyped,untyped">applyIt template</a> for the in-place version</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  nums = @[1, 2, 3, 4]
  strings = nums.mapIt($(4 * it))
assert strings == @["4", "8", "12", "16"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L986" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L986" target="_blank">Edit</a> </dd> </div> </div> <div id="newSeqWith-templates-all"> <div id="newSeqWith.t,int,untyped"> <dt><pre data-language="nim">template newSeqWith(len: int; init: untyped): untyped</pre></dt> <dd> <p>Creates a new <code><span class="Identifier">seq</span></code> of length <code><span class="Identifier">len</span></code>, calling <code><span class="Identifier">init</span></code> to initialize each value of the seq.</p> <p>Useful for creating "2D" seqs - seqs containing other seqs or to populate fields of the created seq.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">## Creates a seq containing 5 bool seqs, each of length of 3.
var seq2D = newSeqWith(5, newSeq[bool](3))
assert seq2D.len == 5
assert seq2D[0].len == 3
assert seq2D[4][2] == false

## Creates a seq with random numbers
import std/random
var seqRand = newSeqWith(20, rand(1.0))
assert seqRand[0] != seqRand[1]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L1072" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L1072" target="_blank">Edit</a> </dd> </div> </div> <div id="toSeq-templates-all"> <div id="toSeq.t,untyped"> <dt><pre data-language="nim">template toSeq(iter: untyped): untyped</pre></dt> <dd> Transforms any iterable (anything that can be iterated over, e.g. with a for-loop) into a sequence. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  myRange = 1..5
  mySet: set[int8] = {5'i8, 3, 1}
assert typeof(myRange) is HSlice[system.int, system.int]
assert typeof(mySet) is set[int8]

let
  mySeq1 = toSeq(myRange)
  mySeq2 = toSeq(mySet)
assert mySeq1 == @[1, 2, 3, 4, 5]
assert mySeq2 == @[1'i8, 3, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/collections/sequtils.nim#L830" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/sequtils.nim#L830" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/sequtils.html" class="_attribution-link">https://nim-lang.org/docs/sequtils.html</a>
  </p>
</div>
