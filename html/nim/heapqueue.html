<h1 class="title">heapqueue</h1>  <p class="module-desc">The <code>heapqueue</code> module implements a <a href="https://en.wikipedia.org/wiki/Heap_(data_structure)">heap data structure</a> that can be used as a <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a>. Heaps are arrays for which <code>a[k] &lt;= a[2*k+1]</code> and <code>a[k] &lt;= a[2*k+2]</code> for all <code>k</code>, counting elements from 0. The interesting property of a heap is that <code>a[0]</code> is always its smallest element. </p>
<h2 id="basic-usage">Basic usage</h2> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = initHeapQueue[int]()
heap.push(8)
heap.push(2)
heap.push(5)
# The first element is the lowest element
assert heap[0] == 2
# Remove and return the lowest element
assert heap.pop() == 2
# The lowest element remaining is 5
assert heap[0] == 5</pre> <h2 id="usage-with-custom-object">Usage with custom object</h2>
<p>To use a <code>HeapQueue</code> with a custom object, the <code>&lt;</code> operator must be implemented.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type Job = object
  priority: int

proc `&lt;`(a, b: Job): bool = a.priority &lt; b.priority

var jobs = initHeapQueue[Job]()
jobs.push(Job(priority: 1))
jobs.push(Job(priority: 2))

assert jobs[0].priority == 1</pre>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="HeapQueue" data-language="nim">HeapQueue[T] = object
  data: seq[T]</pre></dt> <dd> A heap queue, commonly known as a priority queue. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L53" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L53" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="initHeapQueue" data-language="nim">proc initHeapQueue[T](): HeapQueue[T]</pre></dt> <dd> <p>Creates a new empty heap.</p> <p>See also:</p> <ul class="simple">
<li><a href="#toHeapQueue,openArray%5BT%5D">toHeapQueue proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L57" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L57" target="_blank">Edit</a> </dd>  <dt><pre id="len%2CHeapQueue%5BT%5D" data-language="nim">proc len[T](heap: HeapQueue[T]): int {...}{.inline.}</pre></dt> <dd> Returns the number of elements of <code>heap</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L64" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L64" target="_blank">Edit</a> </dd>  <dt><pre id="%5B%5D%2CHeapQueue%5BT%5D%2CNatural" data-language="nim">proc `[]`[T](heap: HeapQueue[T]; i: Natural): lent T {...}{.inline.}</pre></dt> <dd> Accesses the i-th element of <code>heap</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L68" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L68" target="_blank">Edit</a> </dd>  <dt><pre id="push%2CHeapQueue%5BT%5D%2CsinkT" data-language="nim">proc push[T](heap: var HeapQueue[T]; item: sink T)</pre></dt> <dd> Pushes <code>item</code> onto heap, maintaining the heap invariant. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L114" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L114" target="_blank">Edit</a> </dd>  <dt><pre id="toHeapQueue%2CopenArray%5BT%5D" data-language="nim">proc toHeapQueue[T](x: openArray[T]): HeapQueue[T]</pre></dt> <dd> <p>Creates a new HeapQueue that contains the elements of <code>x</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#initHeapQueue">initHeapQueue proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = toHeapQueue([9, 5, 8])
assert heap.pop() == 5
assert heap[0] == 8</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L119" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L119" target="_blank">Edit</a> </dd>  <dt><pre id="pop%2CHeapQueue%5BT%5D" data-language="nim">proc pop[T](heap: var HeapQueue[T]): T</pre></dt> <dd> Pops and returns the smallest item from <code>heap</code>, maintaining the heap invariant. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = toHeapQueue([9, 5, 8])
assert heap.pop() == 5</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L133" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L133" target="_blank">Edit</a> </dd>  <dt><pre id="find%2CHeapQueue%5BT%5D%2CT" data-language="nim">proc find[T](heap: HeapQueue[T]; x: T): int</pre></dt> <dd> Linear scan to find index of item <code>x</code> or -1 if not found. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = toHeapQueue([9, 5, 8])
assert heap.find(5) == 0
assert heap.find(9) == 1
assert heap.find(777) == -1</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L147" target="_blank">Edit</a> </dd>  <dt><pre id="del%2CHeapQueue%5BT%5D%2CNatural" data-language="nim">proc del[T](heap: var HeapQueue[T]; index: Natural)</pre></dt> <dd> Removes the element at <code>index</code> from <code>heap</code>, maintaining the heap invariant. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = toHeapQueue([9, 5, 8])
heap.del(1)
assert heap[0] == 5
assert heap[1] == 8</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L158" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L158" target="_blank">Edit</a> </dd>  <dt><pre id="replace%2CHeapQueue%5BT%5D%2CsinkT" data-language="nim">proc replace[T](heap: var HeapQueue[T]; item: sink T): T</pre></dt> <dd> Pops and returns the current smallest value, and add the new item. This is more efficient than pop() followed by push(), and can be more appropriate when using a fixed-size heap. Note that the value returned may be larger than item! That constrains reasonable uses of this routine unless written as part of a conditional replacement: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = initHeapQueue[int]()
heap.push(5)
heap.push(12)
assert heap.replace(6) == 5
assert heap.len == 2
assert heap[0] == 6
assert heap.replace(4) == 6</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L171" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L171" target="_blank">Edit</a> </dd>  <dt><pre id="pushpop%2CHeapQueue%5BT%5D%2CsinkT" data-language="nim">proc pushpop[T](heap: var HeapQueue[T]; item: sink T): T</pre></dt> <dd> Fast version of a push followed by a pop. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = initHeapQueue[int]()
heap.push(5)
heap.push(12)
assert heap.pushpop(6) == 5
assert heap.len == 2
assert heap[0] == 6
assert heap.pushpop(4) == 4</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L189" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L189" target="_blank">Edit</a> </dd>  <dt><pre id="clear%2CHeapQueue%5BT%5D" data-language="nim">proc clear[T](heap: var HeapQueue[T])</pre></dt> <dd> Removes all elements from <code>heap</code>, making it empty. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = initHeapQueue[int]()
heap.push(1)
heap.clear()
assert heap.len == 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L204" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L204" target="_blank">Edit</a> </dd>  <dt><pre id="%24%2CHeapQueue%5BT%5D" data-language="nim">proc `$`[T](heap: HeapQueue[T]): string</pre></dt> <dd> Turns a heap into its string representation. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var heap = initHeapQueue[int]()
heap.push(1)
heap.push(2)
assert $heap == "[1, 2]"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/collections/heapqueue.nim#L213" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/collections/heapqueue.nim#L213" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/heapqueue.html" class="_attribution-link">https://nim-lang.org/docs/heapqueue.html</a>
  </p>
</div>
