<h1 class="title">parseopt</h1>  <p class="module-desc">This module provides the standard Nim command line parser. It supports one convenience iterator over all command line options and some lower-level features. </p>
<h2 id="supported-syntax">Supported Syntax</h2>
<p>The following syntax is supported when arguments for the <code>shortNoVal</code> and <code>longNoVal</code> parameters, which are <a href="#shortnoval-and-longnoval">described later</a>, are not provided:</p> <ol class="simple">
<li>Short options: <code>-abcd</code>, <code>-e:5</code>, <code>-e=5</code>
</li> <li>Long options: <code>--foo:bar</code>, <code>--foo=bar</code>, <code>--foo</code>
</li> <li>Arguments: everything that does not start with a <code>-</code>
</li> </ol> <p>These three kinds of tokens are enumerated in the <a href="#CmdLineKind">CmdLineKind enum</a>.</p> <p>When option values begin with ':' or '=', they need to be doubled up (as in <code>--delim::</code>) or alternated (as in <code>--delim=:</code>).</p> <p>The <code>--</code> option, commonly used to denote that every token that follows is an argument, is interpreted as a long option, and its name is the empty string.</p> <h2 id="parsing">Parsing</h2>
<p>Use an <a href="#OptParser">OptParser</a> to parse command line options. It can be created with <a href="#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D">initOptParser</a>, and <a href="#next,OptParser">next</a> advances the parser by one token.</p> <p>For each token, the parser's <code>kind</code>, <code>key</code>, and <code>val</code> fields give information about that token. If the token is a long or short option, <code>key</code> is the option's name, and <code>val</code> is either the option's value, if provided, or the empty string. For arguments, the <code>key</code> field contains the argument itself, and <code>val</code> is unused. To check if the end of the command line has been reached, check if <code>kind</code> is equal to <code>cmdEnd</code>.</p> <p>Here is an example:</p> <pre class="listing" data-language="nim">import parseopt

var p = initOptParser("-ab -e:5 --foo --bar=20 file.txt")
while true:
  p.next()
  case p.kind
  of cmdEnd: break
  of cmdShortOption, cmdLongOption:
    if p.val == "":
      echo "Option: ", p.key
    else:
      echo "Option and value: ", p.key, ", ", p.val
  of cmdArgument:
    echo "Argument: ", p.key

# Output:
# Option: a
# Option: b
# Option and value: e, 5
# Option: foo
# Option and value: bar, 20
# Argument: file.txt</pre>
<p>The <a href="#getopt.i,OptParser">getopt iterator</a>, which is provided for convenience, can be used to iterate through all command line options as well.</p> <h2 id="shortnoval-and-longnoval">
<code>shortNoVal</code> and <code>longNoVal</code>
</h2>
<p>The optional <code>shortNoVal</code> and <code>longNoVal</code> parameters present in <a href="#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D">initOptParser</a> are for specifying which short and long options do not accept values.</p> <p>When <code>shortNoVal</code> is non-empty, users are not required to separate short options and their values with a ':' or '=' since the parser knows which options accept values and which ones do not. This behavior also applies for long options if <code>longNoVal</code> is non-empty. For short options, <code>-j4</code> becomes supported syntax, and for long options, <code>--foo bar</code> becomes supported. This is in addition to the <a href="#supported-syntax">previously mentioned syntax</a>. Users can still separate options and their values with ':' or '=', but that becomes optional.</p> <p>As more options which do not accept values are added to your program, remember to amend <code>shortNoVal</code> and <code>longNoVal</code> accordingly.</p> <p>The following example illustrates the difference between having an empty <code>shortNoVal</code> and <code>longNoVal</code>, which is the default, and providing arguments for those two parameters:</p> <pre class="listing" data-language="nim">import parseopt

proc printToken(kind: CmdLineKind, key: string, val: string) =
  case kind
  of cmdEnd: doAssert(false)  # Doesn't happen with getopt()
  of cmdShortOption, cmdLongOption:
    if val == "":
      echo "Option: ", key
    else:
      echo "Option and value: ", key, ", ", val
  of cmdArgument:
    echo "Argument: ", key

let cmdLine = "-j4 --first bar"

var emptyNoVal = initOptParser(cmdLine)
for kind, key, val in emptyNoVal.getopt():
  printToken(kind, key, val)

# Output:
# Option: j
# Option: 4
# Option: first
# Argument: bar

var withNoVal = initOptParser(cmdLine, shortNoVal = {'c'},
                              longNoVal = @["second"])
for kind, key, val in withNoVal.getopt():
  printToken(kind, key, val)

# Output:
# Option and value: j, 4
# Option and value: first, bar</pre> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="os.html">os module</a> for lower-level command line parsing procs</li> <li>
<a href="parseutils.html">parseutils module</a> for helpers that parse tokens, numbers, identifiers, etc.</li> <li>
<a href="strutils.html">strutils module</a> for common string handling operations</li> <li>
<a href="json.html">json module</a> for a JSON parser</li> <li>
<a href="parsecfg.html">parsecfg module</a> for a configuration file parser</li> <li>
<a href="parsecsv.html">parsecsv module</a> for a simple CSV (comma separated value) parser</li> <li>
<a href="parsexml.html">parsexml module</a> for a XML / HTML parser</li> <li>
<a href="lib.html#pure-libraries-parsers">other parsers</a> for more parsers</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="os.html">os</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="CmdLineKind" data-language="nim">CmdLineKind = enum
  cmdEnd,                   ## End of command line reached
  cmdArgument,              ## An argument such as a filename
  cmdLongOption,            ## A long option such as --option
  cmdShortOption             ## A short option such as -c</pre></dt> <dd> The detected command line token. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L157" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L157" target="_blank">Edit</a> </dd>  <dt><pre id="OptParser" data-language="nim">OptParser = object of RootObj
  pos*: int
  inShortState: bool
  allowWhitespaceAfterColon: bool
  shortNoVal: set[char]
  longNoVal: seq[string]
  cmds: seq[string]
  idx: int
  kind*: CmdLineKind         ## The detected command line token
  key*, val*: TaintedString  ## Key and value pair; the key is the option
                             ## or the argument, and the value is not "" if
                             ## the option was given a value</pre></dt> <dd> <p> Implementation of the command line parser.</p> <p>To initialize it, use the <a href="#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D">initOptParser proc</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L162" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L162" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="initOptParser%2Cstring%2Cset%5Bchar%5D%2Cseq%5Bstring%5D" data-language="nim">proc initOptParser(cmdline = ""; shortNoVal: set[char] = {};
                   longNoVal: seq[string] = @[];
                   allowWhitespaceAfterColon = true): OptParser {...}{.raises: [],
    tags: [ReadIOEffect].}</pre></dt> <dd> <p>Initializes the command line parser.</p> <p>If <code>cmdline == ""</code>, the real command line as provided by the <code>os</code> module is retrieved instead.</p> <p><code>shortNoVal</code> and <code>longNoVal</code> are used to specify which options do not take values. See the <a href="#shortnoval-and-longnoval">documentation about these parameters</a> for more information on how this affects parsing.</p> <p>See also:</p> <ul class="simple">
<li><a href="#getopt.i,OptParser">getopt iterator</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var p = initOptParser()
p = initOptParser("--left --debug:3 -l -r:2")
p = initOptParser("--left --debug:3 -l -r:2",
                  shortNoVal = {'l'}, longNoVal = @["left"])</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L199" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L199" target="_blank">Edit</a> </dd>  <dt><pre id="initOptParser%2Cseq%5BTaintedString%5D%2Cset%5Bchar%5D%2Cseq%5Bstring%5D" data-language="nim">proc initOptParser(cmdline: seq[TaintedString]; shortNoVal: set[char] = {};
                   longNoVal: seq[string] = @[];
                   allowWhitespaceAfterColon = true): OptParser {...}{.raises: [],
    tags: [ReadIOEffect].}</pre></dt> <dd> <p>Initializes the command line parser.</p> <p>If <code>cmdline.len == 0</code>, the real command line as provided by the <code>os</code> module is retrieved instead. Behavior of the other parameters remains the same as in <a href="#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D">initOptParser(string, ...)</a>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#getopt.i,seq%5BTaintedString%5D,set%5Bchar%5D,seq%5Bstring%5D">getopt iterator</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var p = initOptParser()
p = initOptParser(@["--left", "--debug:3", "-l", "-r:2"])
p = initOptParser(@["--left", "--debug:3", "-l", "-r:2"],
                  shortNoVal = {'l'}, longNoVal = @["left"])</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L237" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L237" target="_blank">Edit</a> </dd>  <dt><pre id="next%2COptParser" data-language="nim">proc next(p: var OptParser) {...}{.gcsafe, extern: "npo$1", raises: [], tags: [].}</pre></dt> <dd> <p>Parses the next token.</p> <p><code>p.kind</code> describes what kind of token has been parsed. <code>p.key</code> and <code>p.val</code> are set accordingly.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var p = initOptParser("--left -r:2 file.txt")
p.next()
doAssert p.kind == cmdLongOption and p.key == "left"
p.next()
doAssert p.kind == cmdShortOption and p.key == "r" and p.val == "2"
p.next()
doAssert p.kind == cmdArgument and p.key == "file.txt"
p.next()
doAssert p.kind == cmdEnd</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L299" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L299" target="_blank">Edit</a> </dd>  <dt><pre id="cmdLineRest%2COptParser" data-language="nim">proc cmdLineRest(p: OptParser): TaintedString {...}{.gcsafe, extern: "npo$1",
    raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves the rest of the command line that has not been parsed yet.</p> <p>See also:</p> <ul class="simple">
<li><a href="#remainingArgs,OptParser">remainingArgs proc</a></li> </ul> <p><strong>Examples:</strong></p> <pre class="listing" data-language="nim">var p = initOptParser("--left -r:2 -- foo.txt bar.txt")
while true:
  p.next()
  if p.kind == cmdLongOption and p.key == "":  # Look for "--"
    break
  else: continue
doAssert p.cmdLineRest == "foo.txt bar.txt"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L369" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L369" target="_blank">Edit</a> </dd>  <dt><pre id="remainingArgs%2COptParser" data-language="nim">proc remainingArgs(p: OptParser): seq[TaintedString] {...}{.gcsafe, extern: "npo$1",
    raises: [], tags: [].}</pre></dt> <dd> <p>Retrieves a sequence of the arguments that have not been parsed yet.</p> <p>See also:</p> <ul class="simple">
<li><a href="#cmdLineRest,OptParser">cmdLineRest proc</a></li> </ul> <p><strong>Examples:</strong></p> <pre class="listing" data-language="nim">var p = initOptParser("--left -r:2 -- foo.txt bar.txt")
while true:
  p.next()
  if p.kind == cmdLongOption and p.key == "":  # Look for "--"
    break
  else: continue
doAssert p.remainingArgs == @["foo.txt", "bar.txt"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L387" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L387" target="_blank">Edit</a> </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre id="getopt.i%2COptParser" data-language="nim">iterator getopt(p: var OptParser): tuple[kind: CmdLineKind,
    key, val: TaintedString] {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Convenience iterator for iterating over the given <a href="#OptParser">OptParser</a>.</p> <p>There is no need to check for <code>cmdEnd</code> while iterating.</p> <p>See also:</p> <ul class="simple">
<li><a href="#initOptParser,string,set%5Bchar%5D,seq%5Bstring%5D">initOptParser proc</a></li> </ul> <p><strong>Examples:</strong></p> <pre class="listing" data-language="nim"># these are placeholders, of course
proc writeHelp() = discard
proc writeVersion() = discard

var filename: string
var p = initOptParser("--left --debug:3 -l -r:2")

for kind, key, val in p.getopt():
  case kind
  of cmdArgument:
    filename = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been given, so we show the help
  writeHelp()</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L406" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L406" target="_blank">Edit</a> </dd>  <dt><pre id="getopt.i%2Cseq%5BTaintedString%5D%2Cset%5Bchar%5D%2Cseq%5Bstring%5D" data-language="nim">iterator getopt(cmdline: seq[TaintedString] = commandLineParams();
                shortNoVal: set[char] = {}; longNoVal: seq[string] = @[]): tuple[
    kind: CmdLineKind, key, val: TaintedString] {...}{.raises: [],
    tags: [ReadIOEffect].}</pre></dt> <dd> <p>Convenience iterator for iterating over command line arguments.</p> <p>This creates a new <a href="#OptParser">OptParser</a>. If no command line arguments are provided, the real command line as provided by the <code>os</code> module is retrieved instead.</p> <p><code>shortNoVal</code> and <code>longNoVal</code> are used to specify which options do not take values. See the <a href="#shortnoval-and-longnoval">documentation about these parameters</a> for more information on how this affects parsing.</p> <p>There is no need to check for <code>cmdEnd</code> while iterating.</p> <p>See also:</p> <ul class="simple">
<li><a href="#initOptParser,seq%5BTaintedString%5D,set%5Bchar%5D,seq%5Bstring%5D">initOptParser proc</a></li> </ul> <p><strong>Examples:</strong></p> <pre class="listing" data-language="nim"># these are placeholders, of course
proc writeHelp() = discard
proc writeVersion() = discard

var filename: string
let params = @["--left", "--debug:3", "-l", "-r:2"]

for kind, key, val in getopt(params):
  case kind
  of cmdArgument:
    filename = key
  of cmdLongOption, cmdShortOption:
    case key
    of "help", "h": writeHelp()
    of "version", "v": writeVersion()
  of cmdEnd: assert(false) # cannot happen
if filename == "":
  # no filename has been written, so we show the help
  writeHelp()</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/parseopt.nim#L446" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/parseopt.nim#L446" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/parseopt.html" class="_attribution-link">https://nim-lang.org/docs/parseopt.html</a>
  </p>
</div>
