<h1 class="title">re</h1>  
<p>Regular expression support for Nim.</p> <p>This module is implemented by providing a wrapper around the <a href="http://www.pcre.org">PCRE (Perl-Compatible Regular Expressions)</a> C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though. PCRE's licence follows:</p> <h2 id="licence-of-the-pcre-library">Licence of the PCRE library</h2>
<p>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</p> <p>Written by Philip Hazel<br>Copyright (c) 1997-2005 University of Cambridge<br></p>
<hr> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul class="simple">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li> <li>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> <h2 id="regular-expression-syntax-and-semantics">Regular expression syntax and semantics</h2>
<p>As the regular expressions supported by this module are enormous, the reader is referred to <a href="http://perldoc.perl.org/perlre.html">http://perldoc.perl.org/perlre.html</a> for the full documentation of Perl's regular expressions.</p> <p>Because the backslash <code>\</code> is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the <em>raw</em> strings of Nim, so that backslashes are interpreted by the regular expression engine:</p>
<pre data-language="nim">r"\S"  # matches any character that is not whitespace</pre> <p>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</p>
<pre>The quick brown fox</pre> <p>matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters, which do not stand for themselves but instead are interpreted in some special way.</p> <p>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</p> <table>
<tr>
<th>meta character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\</code></td>
<td>general escape character with several uses</td>
</tr> <tr>
<td><code>^</code></td>
<td>assert start of string (or line, in multiline mode)</td>
</tr> <tr>
<td><code>$</code></td>
<td>assert end of string (or line, in multiline mode)</td>
</tr> <tr>
<td><code>.</code></td>
<td>match any character except newline (by default)</td>
</tr> <tr>
<td><code>[</code></td>
<td>start character class definition</td>
</tr> <tr>
<td><code>|</code></td>
<td>start of alternative branch</td>
</tr> <tr>
<td><code>(</code></td>
<td>start subpattern</td>
</tr> <tr>
<td><code>)</code></td>
<td>end subpattern</td>
</tr> <tr>
<td><code>{</code></td>
<td>start min/max quantifier</td>
</tr> <tr>
<td><code>?</code></td>
<td>extends the meaning of <code>(</code><p>also 0 or 1 quantifier (equal to <code>{0,1}</code>)<br>also quantifier minimizer<br></p>
</td>
</tr> <tr>
<td><code>*</code></td>
<td>0 or more quantifier (equal to <code>{0,}</code>)</td>
</tr> <tr>
<td><code>+</code></td>
<td>1 or more quantifier (equal to <code>{1,}</code>)<p>also "possessive quantifier"<br></p>
</td>
</tr> </table>
<p>Part of a pattern that is in square brackets is called a "character class". In a character class the only metacharacters are:</p> <table>
<tr>
<th>meta character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\</code></td>
<td>general escape character</td>
</tr> <tr>
<td><code>^</code></td>
<td>negate the class, but only if the first character</td>
</tr> <tr>
<td><code>-</code></td>
<td>indicates character range</td>
</tr> <tr>
<td><code>[</code></td>
<td>POSIX character class (only if followed by POSIX syntax)</td>
</tr> <tr>
<td><code>]</code></td>
<td>terminates the character class</td>
</tr> </table>
<p>The following sections describe the use of each of the metacharacters.</p> <h3 id="regular-expression-syntax-and-semantics-backslash">Backslash</h3>
<p>The <span id="backslash_1">backslash</span> character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</p> <p>For example, if you want to match a <code>*</code> character, you write <code>\*</code> in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write <code>\\</code>.</p> <h3 id="regular-expression-syntax-and-semantics-nonminusprinting-characters">Non-printing characters</h3>
<p>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents::</p> <table>
<tr>
<th>character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\a</code></td>
<td>alarm, that is, the BEL character (hex 07)</td>
</tr> <tr>
<td><code>\e</code></td>
<td>escape (hex 1B)</td>
</tr> <tr>
<td><code>\f</code></td>
<td>formfeed (hex 0C)</td>
</tr> <tr>
<td><code>\n</code></td>
<td>newline (hex 0A)</td>
</tr> <tr>
<td><code>\r</code></td>
<td>carriage return (hex 0D)</td>
</tr> <tr>
<td><code>\t</code></td>
<td>tab (hex 09)</td>
</tr> <tr>
<td><code>\ddd</code></td>
<td>character with octal code ddd, or backreference</td>
</tr> <tr>
<td><code>\xhh</code></td>
<td>character with hex code hh</td>
</tr> </table>
<p>After <code>\x</code>, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between <code>\x{</code> and <code>}</code>, but the value of the character code must be less than 2**31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between <code>\x{</code> and <code>}</code>, or if there is no terminating <code>}</code>, this form of escape is not recognized. Instead, the initial <code>\x</code> will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</p> <p>After <code>\0</code> up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence <code>\0\x\07</code> specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</p> <p>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</p> <p>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</p> <table>
<tr>
<th>example</th>
<th>meaning</th>
</tr> <tr>
<td><code>\040</code></td>
<td>is another way of writing a space</td>
</tr> <tr>
<td><code>\40</code></td>
<td>is the same, provided there are fewer than 40 previous capturing subpatterns</td>
</tr> <tr>
<td><code>\7</code></td>
<td>is always a back reference</td>
</tr> <tr>
<td><code>\11</code></td>
<td>might be a back reference, or another way of writing a tab</td>
</tr> <tr>
<td><code>\011</code></td>
<td>is always a tab</td>
</tr> <tr>
<td><code>\0113</code></td>
<td>is a tab followed by the character "3"</td>
</tr> <tr>
<td><code>\113</code></td>
<td>might be a back reference, otherwise the character with octal code 113</td>
</tr> <tr>
<td><code>\377</code></td>
<td>might be a back reference, otherwise the byte consisting entirely of 1 bits</td>
</tr> <tr>
<td><code>\81</code></td>
<td>is either a back reference, or a binary zero followed by the two characters "8" and "1"</td>
</tr> </table>
<p>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</p> <p>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence <code>\b</code> is interpreted as the backspace character (hex 08), and the sequence <code>\X</code> is interpreted as the character "X". Outside a character class, these sequences have different meanings (see below).</p> <h3 id="regular-expression-syntax-and-semantics-generic-character-types">Generic character types</h3>
<p>The third use of backslash is for specifying <span id="generic-character-types_1">generic character types</span>. The following are always recognized:</p> <table>
<tr>
<th>character type</th>
<th>meaning</th>
</tr> <tr>
<td><code>\d</code></td>
<td>any decimal digit</td>
</tr> <tr>
<td><code>\D</code></td>
<td>any character that is not a decimal digit</td>
</tr> <tr>
<td><code>\s</code></td>
<td>any whitespace character</td>
</tr> <tr>
<td><code>\S</code></td>
<td>any character that is not a whitespace character</td>
</tr> <tr>
<td><code>\w</code></td>
<td>any "word" character</td>
</tr> <tr>
<td><code>\W</code></td>
<td>any "non-word" character</td>
</tr> </table>
<p>Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.</p> <p>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</p> <p>For compatibility with Perl, <code>\s</code> does not match the VT character (code 11). This makes it different from the the POSIX "space" class. The <code>\s</code> characters are HT (9), LF (10), FF (12), CR (13), and space (32).</p> <p>A "word" character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see "Locale support" in the pcreapi page). For example, in the "fr_FR" (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by <code>\w</code>.</p> <p>In UTF-8 mode, characters with values greater than 128 never match <code>\d</code>, <code>\s</code>, or <code>\w</code>, and always match <code>\D</code>, <code>\S</code>, and <code>\W</code>. This is true even when Unicode character property support is available.</p> <h3 id="regular-expression-syntax-and-semantics-simple-assertions">Simple assertions</h3>
<p>The fourth use of backslash is for certain <span id="simple-assertions_1">simple assertions</span>. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are::</p> <table>
<tr>
<th>assertion</th>
<th>meaning</th>
</tr> <tr>
<td><code>\b</code></td>
<td>matches at a word boundary</td>
</tr> <tr>
<td><code>\B</code></td>
<td>matches when not at a word boundary</td>
</tr> <tr>
<td><code>\A</code></td>
<td>matches at start of subject</td>
</tr> <tr>
<td><code>\Z</code></td>
<td>matches at end of subject or before newline at end</td>
</tr> <tr>
<td><code>\z</code></td>
<td>matches at end of subject</td>
</tr> <tr>
<td><code>\G</code></td>
<td>matches at first matching position in subject</td>
</tr> </table>
<p>These assertions may not appear in character classes (but note that <code>\b</code> has a different meaning, namely the backspace character, inside a character class).</p> <p>A word boundary is a position in the subject string where the current character and the previous character do not both match <code>\w</code> or <code>\W</code> (i.e. one matches <code>\w</code> and the other matches <code>\W</code>), or the start or end of the string if the first or last character matches <code>\w</code>, respectively.</p> <p>The <code>\A</code>, <code>\Z</code>, and <code>\z</code> assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between <code>\Z</code> and <code>\z</code> is that <code>\Z</code> matches before a newline that is the last character of the string as well as at the end of the string, whereas <code>\z</code> matches only at the end.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">## Unless specified otherwise, `start` parameter in each proc indicates
## where the scan starts, but outputs are relative to the start of the input
## string, not to `start`:
doAssert find("uxabc", re"(?&lt;=x|y)ab", start = 1) == 2 # lookbehind assertion
doAssert find("uxabc", re"ab", start = 3) == -1 # we're past `start` =&gt; not found
doAssert not match("xabc", re"^abc$", start = 1)
  # can't match start of string since we're starting at 1</pre>  <h2 id="6">Imports</h2> <dl> <a href="pcre.html">pcre</a>, <a href="strutils.html">strutils</a>, <a href="rtarrays.html">rtarrays</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="RegexFlag" data-language="nim">RegexFlag = enum
  reIgnoreCase = 0,         ## do caseless matching
  reMultiLine = 1,          ## ``^`` and ``$`` match newlines within data
  reDotAll = 2,             ## ``.`` matches anything including NL
  reExtended = 3,           ## ignore whitespace and ``#`` comments
  reStudy = 4                ## study the expression (may be omitted if the
                             ## expression will be used only once)</pre></dt> <dd> options for regular expressions <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L43" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L43" target="_blank">Edit</a> </dd>  <dt><pre id="Regex">Regex = ref RegexDesc</pre></dt> <dd> a compiled regular expression <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L55" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L55" target="_blank">Edit</a> </dd>  <dt><pre id="RegexError">RegexError = object of ValueError</pre></dt> <dd> is raised if the pattern is no valid regular expression. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L57" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L57" target="_blank">Edit</a> </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre id="MaxSubpatterns">MaxSubpatterns = 20</pre></dt> <dd> defines the maximum number of subpatterns that can be captured. This limit still exists for <code>replacef</code> and <code>parallelReplace</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L38" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L38" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="re%2Cstring" data-language="nim">proc re(s: string; flags = {reStudy}): Regex {...}{.raises: [RegexError], tags: [].}</pre></dt> <dd> <p>Constructor of regular expressions.</p> <p>Note that Nim's extended raw string literals support the syntax <code>re"[abc]"</code> as a short form for <code>re(r"[abc]")</code>. Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L88" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L88" target="_blank">Edit</a> </dd>  <dt><pre id="rex%2Cstring" data-language="nim">proc rex(s: string; flags = {reStudy, reExtended}): Regex {...}{.
    raises: [RegexError], tags: [].}</pre></dt> <dd> <p>Constructor for extended regular expressions.</p> <p>The extended means that comments starting with <code>#</code> and whitespace are ignored.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L113" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L113" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Ccstring%2CRegex%2CopenArray%5Bstring%5D%2Cint%2Cint" data-language="nim">proc findBounds(buf: cstring; pattern: Regex; matches: var openArray[string];
                start = 0; bufSize: int): tuple[first, last: int] {...}{.raises: [],
    tags: [].}</pre></dt> <dd> returns the starting position and end position of <code>pattern</code> in <code>buf</code> (where <code>buf</code> has length <code>bufSize</code> and is not necessarily <code>'\0'</code> terminated), and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>(-1,0)</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L144" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L144" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Cstring%2CRegex%2CopenArray%5Bstring%5D%2Cint" data-language="nim">proc findBounds(s: string; pattern: Regex; matches: var openArray[string];
                start = 0): tuple[first, last: int] {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> returns the starting position and end position of <code>pattern</code> in <code>s</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>(-1,0)</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L164" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L164" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Ccstring%2CRegex%2CopenArray%5Btuple%5Bint%2Cint%5D%5D%2Cint%2Cint" data-language="nim">proc findBounds(buf: cstring; pattern: Regex;
                matches: var openArray[tuple[first, last: int]]; start = 0;
                bufSize = 0): tuple[first, last: int] {...}{.raises: [], tags: [].}</pre></dt> <dd> returns the starting position and end position of <code>pattern</code> in <code>buf</code> (where <code>buf</code> has length <code>bufSize</code> and is not necessarily <code>'\0'</code> terminated), and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>(-1,0)</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L172" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L172" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Cstring%2CRegex%2CopenArray%5Btuple%5Bint%2Cint%5D%5D%2Cint" data-language="nim">proc findBounds(s: string; pattern: Regex;
                matches: var openArray[tuple[first, last: int]]; start = 0): tuple[
    first, last: int] {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> returns the starting position and end position of <code>pattern</code> in <code>s</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>(-1,0)</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L193" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L193" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Ccstring%2CRegex%2Cint%2Cint" data-language="nim">proc findBounds(buf: cstring; pattern: Regex; start = 0; bufSize: int): tuple[
    first, last: int] {...}{.raises: [], tags: [].}</pre></dt> <dd> returns the <code>first</code> and <code>last</code> position of <code>pattern</code> in <code>buf</code>, where <code>buf</code> has length <code>bufSize</code> (not necessarily <code>'\0'</code> terminated). If it does not match, <code>(-1,0)</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L202" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L202" target="_blank">Edit</a> </dd>  <dt><pre id="findBounds%2Cstring%2CRegex%2Cint" data-language="nim">proc findBounds(s: string; pattern: Regex; start = 0): tuple[first, last: int] {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> <p>returns the <code>first</code> and <code>last</code> position of <code>pattern</code> in <code>s</code>. If it does not match, <code>(-1,0)</code> is returned.</p> <p>Note: there is a speed improvement if the matches do not need to be captured.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert findBounds("01234abc89", re"abc") == (5,7)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L215" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L215" target="_blank">Edit</a> </dd>  <dt><pre id="matchLen%2Cstring%2CRegex%2CopenArray%5Bstring%5D%2Cint" data-language="nim">proc matchLen(s: string; pattern: Regex; matches: var openArray[string];
              start = 0): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, <code>-1</code> is returned. Note that a match length of zero can happen. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L234" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L234" target="_blank">Edit</a> </dd>  <dt><pre id="matchLen%2Ccstring%2CRegex%2CopenArray%5Bstring%5D%2Cint%2Cint" data-language="nim">proc matchLen(buf: cstring; pattern: Regex; matches: var openArray[string];
              start = 0; bufSize: int): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, <code>-1</code> is returned. Note that a match length of zero can happen. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L241" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L241" target="_blank">Edit</a> </dd>  <dt><pre id="matchLen%2Cstring%2CRegex%2Cint" data-language="nim">proc matchLen(s: string; pattern: Regex; start = 0): int {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, <code>-1</code> is returned. Note that a match length of zero can happen. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert matchLen("abcdefg", re"cde", 2) == 3
doAssert matchLen("abcdefg", re"abcde") == 5
doAssert matchLen("abcdefg", re"cde") == -1</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L248" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L248" target="_blank">Edit</a> </dd>  <dt><pre id="matchLen%2Ccstring%2CRegex%2Cint%2Cint" data-language="nim">proc matchLen(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> the same as <code>match</code>, but it returns the length of the match, if there is no match, <code>-1</code> is returned. Note that a match length of zero can happen. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L259" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L259" target="_blank">Edit</a> </dd>  <dt><pre id="match%2Cstring%2CRegex%2Cint" data-language="nim">proc match(s: string; pattern: Regex; start = 0): bool {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> returns <code>true</code> if <code>s[start..]</code> matches the <code>pattern</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L265" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L265" target="_blank">Edit</a> </dd>  <dt><pre id="match%2Cstring%2CRegex%2CopenArray%5Bstring%5D%2Cint" data-language="nim">proc match(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> returns <code>true</code> if <code>s[start..]</code> matches the <code>pattern</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>false</code> is returned. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import sequtils
var matches: array[2, string]
if match("abcdefg", re"c(d)ef(g)", matches, 2):
  doAssert toSeq(matches) == @["d", "g"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L269" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L269" target="_blank">Edit</a> </dd>  <dt><pre id="match%2Ccstring%2CRegex%2CopenArray%5Bstring%5D%2Cint%2Cint" data-language="nim">proc match(buf: cstring; pattern: Regex; matches: var openArray[string];
           start = 0; bufSize: int): bool {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> returns <code>true</code> if <code>buf[start..&lt;bufSize]</code> matches the <code>pattern</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>false</code> is returned. <code>buf</code> has length <code>bufSize</code> (not necessarily <code>'\0'</code> terminated). <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L283" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L283" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Ccstring%2CRegex%2CopenArray%5Bstring%5D%2Cint%2Cint" data-language="nim">proc find(buf: cstring; pattern: Regex; matches: var openArray[string];
          start = 0; bufSize = 0): int {...}{.raises: [], tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>buf</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>-1</code> is returned. <code>buf</code> has length <code>bufSize</code> (not necessarily <code>'\0'</code> terminated). <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L292" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L292" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Cstring%2CRegex%2CopenArray%5Bstring%5D%2Cint" data-language="nim">proc find(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int {...}{.
    inline, raises: [], tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>s</code> and the captured substrings in the array <code>matches</code>. If it does not match, nothing is written into <code>matches</code> and <code>-1</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L311" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L311" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Ccstring%2CRegex%2Cint%2Cint" data-language="nim">proc find(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {...}{.
    raises: [], tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>buf</code>, where <code>buf</code> has length <code>bufSize</code> (not necessarily <code>'\0'</code> terminated). If it does not match, <code>-1</code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L318" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L318" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Cstring%2CRegex%2Cint" data-language="nim">proc find(s: string; pattern: Regex; start = 0): int {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> returns the starting position of <code>pattern</code> in <code>s</code>. If it does not match, <code>-1</code> is returned. We start the scan at <code>start</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert find("abcdefg", re"cde") == 2
doAssert find("abcdefg", re"abc") == 0
doAssert find("abcdefg", re"zz") == -1 # not found
doAssert find("abcdefg", re"cde", start = 2) == 2 # still 2
doAssert find("abcdefg", re"cde", start = 3) == -1 # we're past the start position
doAssert find("xabc", re"(?&lt;=x|y)abc", start = 1) == 1
  # lookbehind assertion `(?&lt;=x|y)` can look behind `start`</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L330" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L330" target="_blank">Edit</a> </dd>  <dt><pre id="findAll%2Cstring%2CRegex%2Cint" data-language="nim">proc findAll(s: string; pattern: Regex; start = 0): seq[string] {...}{.inline,
    raises: [], tags: [].}</pre></dt> <dd> returns all matching <code>substrings</code> of <code>s</code> that match <code>pattern</code>. If it does not match, @[] is returned. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L383" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L383" target="_blank">Edit</a> </dd>  <dt><pre id="contains%2Cstring%2CRegex%2Cint" data-language="nim">proc contains(s: string; pattern: Regex; start = 0): bool {...}{.inline, raises: [],
    tags: [].}</pre></dt> <dd> same as <code>find(s, pattern, start) &gt;= 0</code> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L413" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L413" target="_blank">Edit</a> </dd>  <dt><pre id="contains%2Cstring%2CRegex%2CopenArray%5Bstring%5D%2Cint" data-language="nim">proc contains(s: string; pattern: Regex; matches: var openArray[string];
              start = 0): bool {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> same as <code>find(s, pattern, matches, start) &gt;= 0</code> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L417" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L417" target="_blank">Edit</a> </dd>  <dt><pre id="startsWith%2Cstring%2CRegex" data-language="nim">proc startsWith(s: string; prefix: Regex): bool {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> returns true if <code>s</code> starts with the pattern <code>prefix</code> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L422" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L422" target="_blank">Edit</a> </dd>  <dt><pre id="endsWith%2Cstring%2CRegex" data-language="nim">proc endsWith(s: string; suffix: Regex): bool {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> returns true if <code>s</code> ends with the pattern <code>suffix</code> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L426" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L426" target="_blank">Edit</a> </dd>  <dt><pre id="replace%2Cstring%2CRegex%2Cstring" data-language="nim">proc replace(s: string; sub: Regex; by = ""): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Replaces <code>sub</code> in <code>s</code> by the string <code>by</code>. Captures cannot be accessed in <code>by</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)") == "; "
doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)", "?") == "?; ?"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L431" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L431" target="_blank">Edit</a> </dd>  <dt><pre id="replacef%2Cstring%2CRegex%2Cstring" data-language="nim">proc replacef(s: string; sub: Regex; by: string): string {...}{.raises: [ValueError],
    tags: [].}</pre></dt> <dd> Replaces <code>sub</code> in <code>s</code> by the string <code>by</code>. Captures can be accessed in <code>by</code> with the notation <code>$i</code> and <code>$#</code> (see strutils.`%`). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "var1=key; var2=key2".replacef(re"(\w+)=(\w+)", "$1&lt;-$2$2") ==
  "var1&lt;-keykey; var2&lt;-key2key2"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L448" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L448" target="_blank">Edit</a> </dd>  <dt><pre id="multiReplace%2Cstring%2CopenArray%5Btuple%5BRegex%2Cstring%5D%5D" data-language="nim">proc multiReplace(s: string;
                  subs: openArray[tuple[pattern: Regex, repl: string]]): string {...}{.
    raises: [ValueError], tags: [].}</pre></dt> <dd> Returns a modified copy of <code>s</code> with the substitutions in <code>subs</code> applied in parallel. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L466" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L466" target="_blank">Edit</a> </dd>  <dt><pre id="transformFile%2Cstring%2Cstring%2CopenArray%5Btuple%5BRegex%2Cstring%5D%5D" data-language="nim">proc transformFile(infile, outfile: string;
                   subs: openArray[tuple[pattern: Regex, repl: string]]) {...}{.
    raises: [IOError, ValueError], tags: [ReadIOEffect, WriteIOEffect].}</pre></dt> <dd> reads in the file <code>infile</code>, performs a parallel replacement (calls <code>parallelReplace</code>) and writes back to <code>outfile</code>. Raises <code>IOError</code> if an error occurs. This is supposed to be used for quick scripting. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L486" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L486" target="_blank">Edit</a> </dd>  <dt><pre id="split%2Cstring%2CRegex" data-language="nim">proc split(s: string; sep: Regex; maxsplit = -1): seq[string] {...}{.inline,
    raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into a seq of substrings.</p> <p>The portion matched by <code>sep</code> is not returned.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L524" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L524" target="_blank">Edit</a> </dd>  <dt><pre id="escapeRe%2Cstring" data-language="nim">proc escapeRe(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> escapes <code>s</code> so that it is matched verbatim when used as a regular expression. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L531" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L531" target="_blank">Edit</a> </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre id="findAll.i%2Cstring%2CRegex%2Cint" data-language="nim">iterator findAll(s: string; pattern: Regex; start = 0): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Yields all matching <em>substrings</em> of <code>s</code> that match <code>pattern</code>.</p> <p>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L343" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L343" target="_blank">Edit</a> </dd>  <dt><pre id="findAll.i%2Ccstring%2CRegex%2Cint%2Cint" data-language="nim">iterator findAll(buf: cstring; pattern: Regex; start = 0; bufSize: int): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> <p>Yields all matching <code>substrings</code> of <code>s</code> that match <code>pattern</code>.</p> <p>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L362" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L362" target="_blank">Edit</a> </dd>  <dt><pre id="split.i%2Cstring%2CRegex" data-language="nim">iterator split(s: string; sep: Regex; maxsplit = -1): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into substrings.</p> <p>Substrings are separated by the regular expression <code>sep</code> (and the portion matched by <code>sep</code> is not returned).</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import sequtils
doAssert toSeq(split("00232this02939is39an22example111", re"\d+")) ==
  @["", "this", "is", "an", "example", ""]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L494" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L494" target="_blank">Edit</a> </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre id="%3D~.t%2Cstring%2CRegex" data-language="nim">template `=~`(s: string; pattern: Regex): untyped</pre></dt> <dd> This calls <code>match</code> with an implicit declared <code>matches</code> array that can be used in the scope of the <code>=~</code> call: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">proc parse(line: string): string =
  if line =~ re"\s*(\w+)\s*\=\s*(\w+)": # matches a key=value pair:
    result = $(matches[0], matches[1])
  elif line =~ re"\s*(\#.*)": # matches a comment
    # note that the implicit ``matches`` array is different from 1st branch
    result = $(matches[0],)
  else: doAssert false
  doAssert not declared(matches)
doAssert parse("NAME = LENA") == """("NAME", "LENA")"""
doAssert parse("   # comment ... ") == """("# comment ... ",)"""</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/impure/re.nim#L392" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L392" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/re.html" class="_attribution-link">https://nim-lang.org/docs/re.html</a>
  </p>
</div>
