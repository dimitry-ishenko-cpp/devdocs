<h1 class="title">std/re</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L1" target="_blank">Edit</a>  
<p>Regular expression support for Nim.</p> <p>This module is implemented by providing a wrapper around the <a href="http://www.pcre.org">PCRE (Perl-Compatible Regular Expressions)</a> C library. This means that your application will depend on the PCRE library's licence when using this module, which should not be a problem though.</p> <div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> There are also alternative nimble packages such as <a href="https://github.com/khchen/tinyre">tinyre</a> and <a href="https://github.com/nitely/nim-regex">regex</a>.</div> <p>PCRE's licence follows:</p> <h2 id="licence-of-the-pcre-library">Licence of the PCRE library</h2>
<p>PCRE is a library of functions to support regular expressions whose syntax and semantics are as close as possible to those of the Perl 5 language.</p> <p>Written by Philip Hazel<br>Copyright (c) 1997-2005 University of Cambridge<br></p>
<hr> <p>Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</p> <ul class="simple">
<li>Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</li> <li>Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</li> <li>Neither the name of the University of Cambridge nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.</li> </ul> <p>THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p> <h2 id="regular-expression-syntax-and-semantics">Regular expression syntax and semantics</h2>
<p>As the regular expressions supported by this module are enormous, the reader is referred to <a href="http://perldoc.perl.org/perlre.html">http://perldoc.perl.org/perlre.html</a> for the full documentation of Perl's regular expressions.</p> <p>Because the backslash <code>\</code> is a meta character both in the Nim programming language and in regular expressions, it is strongly recommended that one uses the <em>raw</em> strings of Nim, so that backslashes are interpreted by the regular expression engine:</p> 
<pre class="listing" data-language="nim">r"\S"  # matches any character that is not whitespace</pre> <p>A regular expression is a pattern that is matched against a subject string from left to right. Most characters stand for themselves in a pattern, and match the corresponding characters in the subject. As a trivial example, the pattern:</p> <pre>The quick brown fox</pre> <p>matches a portion of a subject string that is identical to itself. The power of regular expressions comes from the ability to include alternatives and repetitions in the pattern. These are encoded in the pattern by the use of metacharacters, which do not stand for themselves but instead are interpreted in some special way.</p> <p>There are two different sets of metacharacters: those that are recognized anywhere in the pattern except within square brackets, and those that are recognized in square brackets. Outside square brackets, the metacharacters are as follows:</p> <table>
<tr>
<th>meta character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\</code></td>
<td>general escape character with several uses</td>
</tr> <tr>
<td><code>^</code></td>
<td>assert start of string (or line, in multiline mode)</td>
</tr> <tr>
<td><code>$</code></td>
<td>assert end of string (or line, in multiline mode)</td>
</tr> <tr>
<td><code>.</code></td>
<td>match any character except newline (by default)</td>
</tr> <tr>
<td><code>[</code></td>
<td>start character class definition</td>
</tr> <tr>
<td><code>|</code></td>
<td>start of alternative branch</td>
</tr> <tr>
<td><code>(</code></td>
<td>start subpattern</td>
</tr> <tr>
<td><code>)</code></td>
<td>end subpattern</td>
</tr> <tr>
<td><code>{</code></td>
<td>start min/max quantifier</td>
</tr> <tr>
<td><code>?</code></td>
<td>extends the meaning of <code>(</code><p>also 0 or 1 quantifier (equal to <code>{0,1}</code>)<br>also quantifier minimizer<br></p>
</td>
</tr> <tr>
<td><code>*</code></td>
<td>0 or more quantifier (equal to <code>{0,}</code>)</td>
</tr> <tr>
<td><code>+</code></td>
<td>1 or more quantifier (equal to <code>{1,}</code>)<p>also "possessive quantifier"<br></p>
</td>
</tr> </table>
<p>Part of a pattern that is in square brackets is called a "character class". In a character class the only metacharacters are:</p> <table>
<tr>
<th>meta character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\</code></td>
<td>general escape character</td>
</tr> <tr>
<td><code>^</code></td>
<td>negate the class, but only if the first character</td>
</tr> <tr>
<td><code>-</code></td>
<td>indicates character range</td>
</tr> <tr>
<td><code>[</code></td>
<td>POSIX character class (only if followed by POSIX syntax)</td>
</tr> <tr>
<td><code>]</code></td>
<td>terminates the character class</td>
</tr> </table>
<p>The following sections describe the use of each of the metacharacters.</p> <h3 id="regular-expression-syntax-and-semantics-backslash">Backslash</h3>
<p>The <span id="backslash_1">backslash</span> character has several uses. Firstly, if it is followed by a non-alphanumeric character, it takes away any special meaning that character may have. This use of backslash as an escape character applies both inside and outside character classes.</p> <p>For example, if you want to match a <code>*</code> character, you write <code>\*</code> in the pattern. This escaping action applies whether or not the following character would otherwise be interpreted as a metacharacter, so it is always safe to precede a non-alphanumeric with backslash to specify that it stands for itself. In particular, if you want to match a backslash, you write <code>\\</code>.</p> <h3 id="regular-expression-syntax-and-semantics-nonminusprinting-characters">Non-printing characters</h3>
<p>A second use of backslash provides a way of encoding non-printing characters in patterns in a visible manner. There is no restriction on the appearance of non-printing characters, apart from the binary zero that terminates a pattern, but when a pattern is being prepared by text editing, it is usually easier to use one of the following escape sequences than the binary character it represents:</p> <table>
<tr>
<th>character</th>
<th>meaning</th>
</tr> <tr>
<td><code>\a</code></td>
<td>alarm, that is, the BEL character (hex 07)</td>
</tr> <tr>
<td><code>\e</code></td>
<td>escape (hex 1B)</td>
</tr> <tr>
<td><code>\f</code></td>
<td>formfeed (hex 0C)</td>
</tr> <tr>
<td><code>\n</code></td>
<td>newline (hex 0A)</td>
</tr> <tr>
<td><code>\r</code></td>
<td>carriage return (hex 0D)</td>
</tr> <tr>
<td><code>\t</code></td>
<td>tab (hex 09)</td>
</tr> <tr>
<td><code>\ddd</code></td>
<td>character with octal code ddd, or backreference</td>
</tr> <tr>
<td><code>\xhh</code></td>
<td>character with hex code hh</td>
</tr> </table>
<p>After <code>\x</code>, from zero to two hexadecimal digits are read (letters can be in upper or lower case). In UTF-8 mode, any number of hexadecimal digits may appear between <code>\x{</code> and <code>}</code>, but the value of the character code must be less than 2^31 (that is, the maximum hexadecimal value is 7FFFFFFF). If characters other than hexadecimal digits appear between <code>\x{</code> and <code>}</code>, or if there is no terminating <code>}</code>, this form of escape is not recognized. Instead, the initial <code>\x</code> will be interpreted as a basic hexadecimal escape, with no following digits, giving a character whose value is zero.</p> <p>After <code>\0</code> up to two further octal digits are read. In both cases, if there are fewer than two digits, just those that are present are used. Thus the sequence <code>\0\x\07</code> specifies two binary zeros followed by a BEL character (code value 7). Make sure you supply two digits after the initial zero if the pattern character that follows is itself an octal digit.</p> <p>The handling of a backslash followed by a digit other than 0 is complicated. Outside a character class, PCRE reads it and any following digits as a decimal number. If the number is less than 10, or if there have been at least that many previous capturing left parentheses in the expression, the entire sequence is taken as a back reference. A description of how this works is given later, following the discussion of parenthesized subpatterns.</p> <p>Inside a character class, or if the decimal number is greater than 9 and there have not been that many capturing subpatterns, PCRE re-reads up to three octal digits following the backslash, and generates a single byte from the least significant 8 bits of the value. Any subsequent digits stand for themselves. For example:</p> <table>
<tr>
<th>example</th>
<th>meaning</th>
</tr> <tr>
<td><code>\040</code></td>
<td>is another way of writing a space</td>
</tr> <tr>
<td><code>\40</code></td>
<td>is the same, provided there are fewer than 40 previous capturing subpatterns</td>
</tr> <tr>
<td><code>\7</code></td>
<td>is always a back reference</td>
</tr> <tr>
<td><code>\11</code></td>
<td>might be a back reference, or another way of writing a tab</td>
</tr> <tr>
<td><code>\011</code></td>
<td>is always a tab</td>
</tr> <tr>
<td><code>\0113</code></td>
<td>is a tab followed by the character "3"</td>
</tr> <tr>
<td><code>\113</code></td>
<td>might be a back reference, otherwise the character with octal code 113</td>
</tr> <tr>
<td><code>\377</code></td>
<td>might be a back reference, otherwise the byte consisting entirely of 1 bits</td>
</tr> <tr>
<td><code>\81</code></td>
<td>is either a back reference, or a binary zero followed by the two characters "8" and "1"</td>
</tr> </table>
<p>Note that octal values of 100 or greater must not be introduced by a leading zero, because no more than three octal digits are ever read.</p> <p>All the sequences that define a single byte value or a single UTF-8 character (in UTF-8 mode) can be used both inside and outside character classes. In addition, inside a character class, the sequence <code>\b</code> is interpreted as the backspace character (hex 08), and the sequence <code>\X</code> is interpreted as the character "X". Outside a character class, these sequences have different meanings (see below).</p> <h3 id="regular-expression-syntax-and-semantics-generic-character-types">Generic character types</h3>
<p>The third use of backslash is for specifying <span id="generic-character-types_1">generic character types</span>. The following are always recognized:</p> <table>
<tr>
<th>character type</th>
<th>meaning</th>
</tr> <tr>
<td><code>\d</code></td>
<td>any decimal digit</td>
</tr> <tr>
<td><code>\D</code></td>
<td>any character that is not a decimal digit</td>
</tr> <tr>
<td><code>\s</code></td>
<td>any whitespace character</td>
</tr> <tr>
<td><code>\S</code></td>
<td>any character that is not a whitespace character</td>
</tr> <tr>
<td><code>\w</code></td>
<td>any "word" character</td>
</tr> <tr>
<td><code>\W</code></td>
<td>any "non-word" character</td>
</tr> </table>
<p>Each pair of escape sequences partitions the complete set of characters into two disjoint sets. Any given character matches one, and only one, of each pair.</p> <p>These character type sequences can appear both inside and outside character classes. They each match one character of the appropriate type. If the current matching point is at the end of the subject string, all of them fail, since there is no character to match.</p> <p>For compatibility with Perl, <code>\s</code> does not match the VT character (code 11). This makes it different from the POSIX "space" class. The <code>\s</code> characters are HT (9), LF (10), FF (12), CR (13), and space (32).</p> <p>A "word" character is an underscore or any character less than 256 that is a letter or digit. The definition of letters and digits is controlled by PCRE's low-valued character tables, and may vary if locale-specific matching is taking place (see "Locale support" in the pcreapi page). For example, in the "fr_FR" (French) locale, some character codes greater than 128 are used for accented letters, and these are matched by <code>\w</code>.</p> <p>In UTF-8 mode, characters with values greater than 128 never match <code>\d</code>, <code>\s</code>, or <code>\w</code>, and always match <code>\D</code>, <code>\S</code>, and <code>\W</code>. This is true even when Unicode character property support is available.</p> <h3 id="regular-expression-syntax-and-semantics-simple-assertions">Simple assertions</h3>
<p>The fourth use of backslash is for certain <span id="simple-assertions_1">simple assertions</span>. An assertion specifies a condition that has to be met at a particular point in a match, without consuming any characters from the subject string. The use of subpatterns for more complicated assertions is described below. The backslashed assertions are:</p> <table>
<tr>
<th>assertion</th>
<th>meaning</th>
</tr> <tr>
<td><code>\b</code></td>
<td>matches at a word boundary</td>
</tr> <tr>
<td><code>\B</code></td>
<td>matches when not at a word boundary</td>
</tr> <tr>
<td><code>\A</code></td>
<td>matches at start of subject</td>
</tr> <tr>
<td><code>\Z</code></td>
<td>matches at end of subject or before newline at end</td>
</tr> <tr>
<td><code>\z</code></td>
<td>matches at end of subject</td>
</tr> <tr>
<td><code>\G</code></td>
<td>matches at first matching position in subject</td>
</tr> </table>
<p>These assertions may not appear in character classes (but note that <code>\b</code> has a different meaning, namely the backspace character, inside a character class).</p> <p>A word boundary is a position in the subject string where the current character and the previous character do not both match <code>\w</code> or <code>\W</code> (i.e. one matches <code>\w</code> and the other matches <code>\W</code>), or the start or end of the string if the first or last character matches <code>\w</code>, respectively.</p> <p>The <code>\A</code>, <code>\Z</code>, and <code>\z</code> assertions differ from the traditional circumflex and dollar in that they only ever match at the very start and end of the subject string, whatever options are set. The difference between <code>\Z</code> and <code>\z</code> is that <code>\Z</code> matches before a newline that is the last character of the string as well as at the end of the string, whereas <code>\z</code> matches only at the end. </p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/re
## Unless specified otherwise, `start` parameter in each proc indicates
## where the scan starts, but outputs are relative to the start of the input
## string, not to `start`:
doAssert find("uxabc", re"(?&lt;=x|y)ab", start = 1) == 2 # lookbehind assertion
doAssert find("uxabc", re"ab", start = 3) == -1 # we're past `start` =&gt; not found
doAssert not match("xabc", re"^abc$", start = 1)
  # can't match start of string since we're starting at 1</pre>  <h2 id="6">Imports</h2> <dl> <a href="pcre.html">pcre</a>, <a href="strutils.html">strutils</a>, <a href="rtarrays.html">rtarrays</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="Regex"> <dt><pre>Regex = ref RegexDesc</pre></dt> <dd> a compiled regular expression <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L62" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L62" target="_blank">Edit</a> </dd> </div> <div id="RegexError"> <dt><pre>RegexError = object of ValueError</pre></dt> <dd> is raised if the pattern is no valid regular expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L64" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L64" target="_blank">Edit</a> </dd> </div> <div id="RegexFlag"> <dt><pre data-language="nim">RegexFlag = enum
  reIgnoreCase = 0,         ## do caseless matching
  reMultiLine = 1,          ## `^` and `$` match newlines within data
  reDotAll = 2,             ## `.` matches anything including NL
  reExtended = 3,           ## ignore whitespace and `#` comments
  reStudy = 4                ## study the expression (may be omitted if the
                             ## expression will be used only once)</pre></dt> <dd> options for regular expressions <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L50" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L50" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="10">Consts</h2> <dl> <div id="MaxReBufSize"> <dt><pre data-language="nim">MaxReBufSize = 2147483647'i32</pre></dt> <dd> Maximum PCRE (API 1) buffer start/size equal to <code><span class="Identifier">high</span><span class="Punctuation">(</span><span class="Identifier">cint</span><span class="Punctuation">)</span></code>, which even for 64-bit systems can be either 2<sup>31</sup>-1 or 2<sup>63</sup>-1. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L157" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L157" target="_blank">Edit</a> </dd> </div> <div id="MaxSubpatterns"> <dt><pre>MaxSubpatterns = 20</pre></dt> <dd> defines the maximum number of subpatterns that can be captured. This limit still exists for <code><span class="Identifier">replacef</span></code> and <code><span class="Identifier">parallelReplace</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L45" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L45" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="contains-procs-all"> <div id="contains,string,Regex,openArray[string],int"> <dt><pre data-language="nim">proc contains(s: string; pattern: Regex; matches: var openArray[string];
              start = 0): bool {.inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> same as <code><span class="Identifier">find</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Identifier">pattern</span><span class="Punctuation">,</span> <span class="Identifier">matches</span><span class="Punctuation">,</span> <span class="Identifier">start</span><span class="Punctuation">)</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span></code><div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L478" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L478" target="_blank">Edit</a> </dd> </div> <div id="contains,string,Regex,int"> <dt><pre data-language="nim">proc contains(s: string; pattern: Regex; start = 0): bool {.inline, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> same as <code><span class="Identifier">find</span><span class="Punctuation">(</span><span class="Identifier">s</span><span class="Punctuation">,</span> <span class="Identifier">pattern</span><span class="Punctuation">,</span> <span class="Identifier">start</span><span class="Punctuation">)</span> <span class="Operator">&gt;=</span> <span class="DecNumber">0</span></code> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L474" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L474" target="_blank">Edit</a> </dd> </div> </div> <div id="endsWith-procs-all"> <div id="endsWith,string,Regex"> <dt><pre data-language="nim">proc endsWith(s: string; suffix: Regex): bool {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> returns true if <code><span class="Identifier">s</span></code> ends with the pattern <code><span class="Identifier">suffix</span></code> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L489" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L489" target="_blank">Edit</a> </dd> </div> </div> <div id="escapeRe-procs-all"> <div id="escapeRe,string"> <dt><pre data-language="nim">proc escapeRe(s: string): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> escapes <code><span class="Identifier">s</span></code> so that it is matched verbatim when used as a regular expression. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L601" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L601" target="_blank">Edit</a> </dd> </div> </div> <div id="find-procs-all"> <div id="find,cstring,Regex,openArray[string],int,int"> <dt><pre data-language="nim">proc find(buf: cstring; pattern: Regex; matches: var openArray[string];
          start = 0; bufSize: int): int {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns the starting position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">buf</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> (not necessarily <code><span class="CharLit">'\0'</span></code> terminated).<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L352" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L352" target="_blank">Edit</a> </dd> </div> <div id="find,cstring,Regex,int,int"> <dt><pre data-language="nim">proc find(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns the starting position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">buf</span></code>, where <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> (not necessarily <code><span class="CharLit">'\0'</span></code> terminated). If it does not match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L382" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L382" target="_blank">Edit</a> </dd> </div> <div id="find,string,Regex,openArray[string],int"> <dt><pre data-language="nim">proc find(s: string; pattern: Regex; matches: var openArray[string]; start = 0): int {.
    inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns the starting position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">s</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L373" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L373" target="_blank">Edit</a> </dd> </div> <div id="find,string,Regex,int"> <dt><pre data-language="nim">proc find(s: string; pattern: Regex; start = 0): int {.inline, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> returns the starting position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">s</span></code>. If it does not match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. We start the scan at <code><span class="Identifier">start</span></code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert find("abcdefg", re"cde") == 2
doAssert find("abcdefg", re"abc") == 0
doAssert find("abcdefg", re"zz") == -1 # not found
doAssert find("abcdefg", re"cde", start = 2) == 2 # still 2
doAssert find("abcdefg", re"cde", start = 3) == -1 # we're past the start position
doAssert find("xabc", re"(?&lt;=x|y)abc", start = 1) == 1
  # lookbehind assertion `(?&lt;=x|y)` can look behind `start`</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L394" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L394" target="_blank">Edit</a> </dd> </div> </div> <div id="findAll-procs-all"> <div id="findAll,string,Regex,int"> <dt><pre data-language="nim">proc findAll(s: string; pattern: Regex; start = 0): seq[string] {.inline,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns all matching <code><span class="Identifier">substrings</span></code> of <code><span class="Identifier">s</span></code> that match <code><span class="Identifier">pattern</span></code>. If it does not match, <code><span class="Operator">@</span><span class="Punctuation">[</span><span class="Punctuation">]</span></code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L447" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L447" target="_blank">Edit</a> </dd> </div> </div> <div id="findBounds-procs-all"> <div id="findBounds,cstring,Regex,openArray[tuple[int,int]],int,int"> <dt><pre data-language="nim">proc findBounds(buf: cstring; pattern: Regex;
                matches: var openArray[tuple[first, last: int]]; start = 0;
                bufSize: int): tuple[first, last: int] {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> returns the starting position and end position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">buf</span></code> (where <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> and is not necessarily <code><span class="CharLit">'\0'</span></code> terminated), and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L201" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L201" target="_blank">Edit</a> </dd> </div> <div id="findBounds,cstring,Regex,openArray[string],int,int"> <dt><pre data-language="nim">proc findBounds(buf: cstring; pattern: Regex; matches: var openArray[string];
                start = 0; bufSize: int): tuple[first, last: int] {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>returns the starting position and end position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">buf</span></code> (where <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> and is not necessarily <code><span class="CharLit">'\0'</span></code> terminated), and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned.</p> <p>Note: The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L161" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L161" target="_blank">Edit</a> </dd> </div> <div id="findBounds,cstring,Regex,int,int"> <dt><pre data-language="nim">proc findBounds(buf: cstring; pattern: Regex; start = 0; bufSize: int): tuple[
    first, last: int] {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns the <code><span class="Identifier">first</span></code> and <code><span class="Identifier">last</span></code> position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">buf</span></code>, where <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> (not necessarily <code><span class="CharLit">'\0'</span></code> terminated). If it does not match, <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L254" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L254" target="_blank">Edit</a> </dd> </div> <div id="findBounds,string,Regex,openArray[tuple[int,int]],int"> <dt><pre data-language="nim">proc findBounds(s: string; pattern: Regex;
                matches: var openArray[tuple[first, last: int]]; start = 0): tuple[
    first, last: int] {.inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns the starting position and end position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">s</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var matches = newSeq[tuple[first, last: int]](1)
let (first, last) = findBounds("Hello World", re"(\w+)", matches)
doAssert first == 0
doAssert last == 4
doAssert matches[0] == (0, 4)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L224" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L224" target="_blank">Edit</a> </dd> </div> <div id="findBounds,string,Regex,openArray[string],int"> <dt><pre data-language="nim">proc findBounds(s: string; pattern: Regex; matches: var openArray[string];
                start = 0): tuple[first, last: int] {.inline, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> returns the starting position and end position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">s</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var matches = newSeq[string](1)
let (first, last) = findBounds("Hello World", re"(W\w+)", matches)
doAssert first == 6
doAssert last == 10
doAssert matches[0] == "World"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L184" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L184" target="_blank">Edit</a> </dd> </div> <div id="findBounds,string,Regex,int"> <dt><pre data-language="nim">proc findBounds(s: string; pattern: Regex; start = 0): tuple[first, last: int] {.
    inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>returns the <code><span class="Identifier">first</span></code> and <code><span class="Identifier">last</span></code> position of <code><span class="Identifier">pattern</span></code> in <code><span class="Identifier">s</span></code>. If it does not match, <code><span class="Punctuation">(</span><span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">,</span><span class="DecNumber">0</span><span class="Punctuation">)</span></code> is returned.</p> <p>Note: there is a speed improvement if the matches do not need to be captured.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert findBounds("01234abc89", re"abc") == (5,7)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L267" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L267" target="_blank">Edit</a> </dd> </div> </div> <div id="match-procs-all"> <div id="match,cstring,Regex,openArray[string],int,int"> <dt><pre data-language="nim">proc match(buf: cstring; pattern: Regex; matches: var openArray[string];
           start = 0; bufSize: int): bool {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> returns <code><span class="Identifier">true</span></code> if <code><span class="Identifier">buf</span><span class="Punctuation">[</span><span class="Identifier">start</span><span class="Operator">..&lt;</span><span class="Identifier">bufSize</span><span class="Punctuation">]</span></code> matches the <code><span class="Identifier">pattern</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Identifier">false</span></code> is returned. <code><span class="Identifier">buf</span></code> has length <code><span class="Identifier">bufSize</span></code> (not necessarily <code><span class="CharLit">'\0'</span></code> terminated).<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L341" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L341" target="_blank">Edit</a> </dd> </div> <div id="match,string,Regex,openArray[string],int"> <dt><pre data-language="nim">proc match(s: string; pattern: Regex; matches: var openArray[string]; start = 0): bool {.
    inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> returns <code><span class="Identifier">true</span></code> if <code><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">start</span><span class="Operator">..</span><span class="Punctuation">]</span></code> matches the <code><span class="Identifier">pattern</span></code> and the captured substrings in the array <code><span class="Identifier">matches</span></code>. If it does not match, nothing is written into <code><span class="Identifier">matches</span></code> and <code><span class="Identifier">false</span></code> is returned.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/sequtils
var matches: array[2, string]
if match("abcdefg", re"c(d)ef(g)", matches, 2):
  doAssert toSeq(matches) == @["d", "g"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L326" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L326" target="_blank">Edit</a> </dd> </div> <div id="match,string,Regex,int"> <dt><pre data-language="nim">proc match(s: string; pattern: Regex; start = 0): bool {.inline, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> returns <code><span class="Identifier">true</span></code> if <code><span class="Identifier">s</span><span class="Punctuation">[</span><span class="Identifier">start</span><span class="Operator">..</span><span class="Punctuation">]</span></code> matches the <code><span class="Identifier">pattern</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L322" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L322" target="_blank">Edit</a> </dd> </div> </div> <div id="matchLen-procs-all"> <div id="matchLen,cstring,Regex,openArray[string],int,int"> <dt><pre data-language="nim">proc matchLen(buf: cstring; pattern: Regex; matches: var openArray[string];
              start = 0; bufSize: int): int {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> the same as <code><span class="Identifier">match</span></code>, but it returns the length of the match, if there is no match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. Note that a match length of zero can happen.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L296" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L296" target="_blank">Edit</a> </dd> </div> <div id="matchLen,cstring,Regex,int,int"> <dt><pre data-language="nim">proc matchLen(buf: cstring; pattern: Regex; start = 0; bufSize: int): int {.
    inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> the same as <code><span class="Identifier">match</span></code>, but it returns the length of the match, if there is no match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. Note that a match length of zero can happen. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L316" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L316" target="_blank">Edit</a> </dd> </div> <div id="matchLen,string,Regex,openArray[string],int"> <dt><pre data-language="nim">proc matchLen(s: string; pattern: Regex; matches: var openArray[string];
              start = 0): int {.inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> the same as <code><span class="Identifier">match</span></code>, but it returns the length of the match, if there is no match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. Note that a match length of zero can happen.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The memory for <code><span class="Identifier">matches</span></code> needs to be allocated before this function is called, otherwise it will just remain empty.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L287" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L287" target="_blank">Edit</a> </dd> </div> <div id="matchLen,string,Regex,int"> <dt><pre data-language="nim">proc matchLen(s: string; pattern: Regex; start = 0): int {.inline, ...raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> the same as <code><span class="Identifier">match</span></code>, but it returns the length of the match, if there is no match, <code><span class="Operator">-</span><span class="DecNumber">1</span></code> is returned. Note that a match length of zero can happen. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert matchLen("abcdefg", re"cde", 2) == 3
doAssert matchLen("abcdefg", re"abcde") == 5
doAssert matchLen("abcdefg", re"cde") == -1</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L305" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L305" target="_blank">Edit</a> </dd> </div> </div> <div id="multiReplace-procs-all"> <div id="multiReplace,string,openArray[tuple[Regex,string]]"> <dt><pre data-language="nim">proc multiReplace(s: string;
                  subs: openArray[tuple[pattern: Regex, repl: string]]): string {.
    ...raises: [ValueError], tags: [], forbids: [].}</pre></dt> <dd> Returns a modified copy of <code><span class="Identifier">s</span></code> with the substitutions in <code><span class="Identifier">subs</span></code> applied in parallel. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L533" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L533" target="_blank">Edit</a> </dd> </div> </div> <div id="re-procs-all"> <div id="re,string"> <dt><pre data-language="nim">proc re(s: string; flags = {reStudy}): Regex {....raises: [RegexError], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Constructor of regular expressions.</p> <p>Note that Nim's extended raw string literals support the syntax <code><span class="RawData">re"[abc]"</span></code> as a short form for <code><span class="Identifier">re</span><span class="Punctuation">(</span><span class="RawData">r"[abc]"</span><span class="Punctuation">)</span></code>. Also note that since this compiles the regular expression, which is expensive, you should avoid putting it directly in the arguments of the functions like the examples show below if you plan to use it a lot of times, as this will hurt performance immensely. (e.g. outside a loop, ...)</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L101" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L101" target="_blank">Edit</a> </dd> </div> </div> <div id="replace-procs-all"> <div id="replace,string,Regex,string"> <dt><pre data-language="nim">proc replace(s: string; sub: Regex; by = ""): string {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Replaces <code><span class="Identifier">sub</span></code> in <code><span class="Identifier">s</span></code> by the string <code><span class="Identifier">by</span></code>. Captures cannot be accessed in <code><span class="Identifier">by</span></code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)") == "; "
doAssert "var1=key; var2=key2".replace(re"(\w+)=(\w+)", "?") == "?; ?"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L494" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L494" target="_blank">Edit</a> </dd> </div> </div> <div id="replacef-procs-all"> <div id="replacef,string,Regex,string"> <dt><pre data-language="nim">proc replacef(s: string; sub: Regex; by: string): string {....raises: [ValueError],
    tags: [], forbids: [].}</pre></dt> <dd> Replaces <code><span class="Identifier">sub</span></code> in <code><span class="Identifier">s</span></code> by the string <code><span class="Identifier">by</span></code>. Captures can be accessed in <code><span class="Identifier">by</span></code> with the notation <code><span class="Operator">$</span><span class="Identifier">i</span></code> and <code><span class="Operator">$</span><span class="Comment">#</span></code> (see strutils.`%`). <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "var1=key; var2=key2".replacef(re"(\w+)=(\w+)", "$1&lt;-$2$2") ==
  "var1&lt;-keykey; var2&lt;-key2key2"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L515" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L515" target="_blank">Edit</a> </dd> </div> </div> <div id="rex-procs-all"> <div id="rex,string"> <dt><pre data-language="nim">proc rex(s: string; flags = {reStudy, reExtended}): Regex {.
    ...raises: [RegexError], tags: [], forbids: [].}</pre></dt> <dd> <p>Constructor for extended regular expressions.</p> <p>The extended means that comments starting with <code><span class="Comment">#</span></code> and whitespace are ignored.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L126" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L126" target="_blank">Edit</a> </dd> </div> </div> <div id="split-procs-all"> <div id="split,string,Regex,int"> <dt><pre data-language="nim">proc split(s: string; sep: Regex; maxsplit = -1): seq[string] {.inline,
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Splits the string <code><span class="Identifier">s</span></code> into a seq of substrings.</p> <p>The portion matched by <code><span class="Identifier">sep</span></code> is not returned.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L594" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L594" target="_blank">Edit</a> </dd> </div> </div> <div id="startsWith-procs-all"> <div id="startsWith,string,Regex"> <dt><pre data-language="nim">proc startsWith(s: string; prefix: Regex): bool {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> returns true if <code><span class="Identifier">s</span></code> starts with the pattern <code><span class="Identifier">prefix</span></code> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L485" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L485" target="_blank">Edit</a> </dd> </div> </div> <div id="transformFile-procs-all"> <div id="transformFile,string,string,openArray[tuple[Regex,string]]"> <dt><pre data-language="nim">proc transformFile(infile, outfile: string;
                   subs: openArray[tuple[pattern: Regex, repl: string]]) {.
    ...raises: [IOError, ValueError], tags: [ReadIOEffect, WriteIOEffect],
    forbids: [].}</pre></dt> <dd> reads in the file <code><span class="Identifier">infile</span></code>, performs a parallel replacement (calls <code><span class="Identifier">parallelReplace</span></code>) and writes back to <code><span class="Identifier">outfile</span></code>. Raises <code><span class="Identifier">IOError</span></code> if an error occurs. This is supposed to be used for quick scripting. <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L553" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L553" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="15">Iterators</h2> <dl> <div id="findAll-iterators-all"> <div id="findAll.i,cstring,Regex,int,int"> <dt><pre data-language="nim">iterator findAll(buf: cstring; pattern: Regex; start = 0; bufSize: int): string {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Yields all matching <code><span class="Identifier">substrings</span></code> of <code><span class="Identifier">s</span></code> that match <code><span class="Identifier">pattern</span></code>.</p> <p>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L426" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L426" target="_blank">Edit</a> </dd> </div> <div id="findAll.i,string,Regex,int"> <dt><pre data-language="nim">iterator findAll(s: string; pattern: Regex; start = 0): string {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Yields all matching <em>substrings</em> of <code><span class="Identifier">s</span></code> that match <code><span class="Identifier">pattern</span></code>.</p> <p>Note that since this is an iterator you should not modify the string you are iterating over: bad things could happen.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L407" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L407" target="_blank">Edit</a> </dd> </div> </div> <div id="split-iterators-all"> <div id="split.i,string,Regex,int"> <dt><pre data-language="nim">iterator split(s: string; sep: Regex; maxsplit = -1): string {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Splits the string <code><span class="Identifier">s</span></code> into substrings.</p> <p>Substrings are separated by the regular expression <code><span class="Identifier">sep</span></code> (and the portion matched by <code><span class="Identifier">sep</span></code> is not returned).</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/sequtils
doAssert toSeq(split("00232this02939is39an22example111", re"\d+")) ==
  @["", "this", "is", "an", "example", ""]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L561" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L561" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="18">Templates</h2> <dl> <div id="=~-templates-all"> <div id="=~.t,string,Regex"> <dt><pre data-language="nim">template `=~`(s: string; pattern: Regex): untyped</pre></dt> <dd> This calls <code><span class="Identifier">match</span></code> with an implicit declared <code><span class="Identifier">matches</span></code> array that can be used in the scope of the <code><span class="Operator">=~</span></code> call: <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">proc parse(line: string): string =
  if line =~ re"\s*(\w+)\s*\=\s*(\w+)": # matches a key=value pair:
    result = $(matches[0], matches[1])
  elif line =~ re"\s*(\#.*)": # matches a comment
    # note that the implicit `matches` array is different from 1st branch
    result = $(matches[0],)
  else: doAssert false
  doAssert not declared(matches)
doAssert parse("NAME = LENA") == """("NAME", "LENA")"""
doAssert parse("   # comment ... ") == """("# comment ... ",)"""</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/impure/re.nim#L453" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/impure/re.nim#L453" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/re.html" class="_attribution-link">https://nim-lang.org/docs/re.html</a>
  </p>
</div>
