<h1 class="title">strformat</h1>  <p class="module-desc">String <span id="interpolation_1">interpolation</span> / <span id="format_1">format</span> inspired by Python's <code>f</code>-strings. </p>
<h2 id="fmt-vsdot-amp">
<code>fmt</code> vs. <code>&amp;</code>
</h2>
<p>You can use either <code>fmt</code> or the unary <code>&amp;</code> operator for formatting. The difference between them is subtle but important.</p> <p>The <code>fmt"{expr}"</code> syntax is more aesthetically pleasing, but it hides a small gotcha. The string is a <a href="manual.html#lexical-analysis-generalized-raw-string-literals">generalized raw string literal</a>. This has some surprising effects:</p> <pre class="listing" data-language="nim">import strformat
let msg = "hello"
doAssert fmt"{msg}\n" == "hello\\n"</pre>
<p>Because the literal is a raw string literal, the <code>\n</code> is not interpreted as an escape sequence.</p> <p>There are multiple ways to get around this, including the use of the <code>&amp;</code> operator:</p> <pre class="listing" data-language="nim">import strformat
let msg = "hello"

doAssert &amp;"{msg}\n" == "hello\n"

doAssert fmt"{msg}{'\n'}" == "hello\n"
doAssert fmt("{msg}\n") == "hello\n"
doAssert "{msg}\n".fmt == "hello\n"</pre>
<p>The choice of style is up to you.</p> <h2 id="formatting-strings">Formatting strings</h2>
<pre class="listing" data-language="nim">import strformat

doAssert &amp;"""{"abc":&gt;4}""" == " abc"
doAssert &amp;"""{"abc":&lt;4}""" == "abc "</pre> <h2 id="formatting-floats">Formatting floats</h2>
<pre class="listing" data-language="nim">import strformat
doAssert fmt"{-12345:08}" == "-0012345"
doAssert fmt"{-1:3}" == " -1"
doAssert fmt"{-1:03}" == "-01"
doAssert fmt"{16:#X}" == "0x10"

doAssert fmt"{123.456}" == "123.456"
doAssert fmt"{123.456:&gt;9.3f}" == "  123.456"
doAssert fmt"{123.456:9.3f}" == "  123.456"
doAssert fmt"{123.456:9.4f}" == " 123.4560"
doAssert fmt"{123.456:&gt;9.0f}" == "     123."
doAssert fmt"{123.456:&lt;9.4f}" == "123.4560 "

doAssert fmt"{123.456:e}" == "1.234560e+02"
doAssert fmt"{123.456:&gt;13e}" == " 1.234560e+02"
doAssert fmt"{123.456:13e}" == " 1.234560e+02"</pre> <h2 id="debugging-strings">Debugging strings</h2>
<p><code>fmt"{expr=}"</code> expands to <code>fmt"expr={expr}"</code> namely the text of the expression, an equal sign and the results of evaluated expression.</p> <pre class="listing" data-language="nim">import strformat
doAssert fmt"{123.456=}" == "123.456=123.456"
doAssert fmt"{123.456=:&gt;9.3f}" == "123.456=  123.456"

let x = "hello"
doAssert fmt"{x=}" == "x=hello"
doAssert fmt"{x =}" == "x =hello"

let y = 3.1415926
doAssert fmt"{y=:.2f}" == fmt"y={y:.2f}"
doAssert fmt"{y=}" == fmt"y={y}"
doAssert fmt"{y = : &lt;8}" == fmt"y = 3.14159 "

proc hello(a: string, b: float): int = 12
let a = "hello"
let b = 3.1415926
doAssert fmt"{hello(x, y) = }" == "hello(x, y) = 12"
doAssert fmt"{x.hello(y) = }" == "x.hello(y) = 12"
doAssert fmt"{hello x, y = }" == "hello x, y = 12"</pre>
<p>Note that it is space sensitive:</p> <pre class="listing" data-language="nim">import strformat
let x = "12"
doAssert fmt"{x=}" == "x=12"
doAssert fmt"{x =:}" == "x =12"
doAssert fmt"{x =}" == "x =12"
doAssert fmt"{x= :}" == "x= 12"
doAssert fmt"{x= }" == "x= 12"
doAssert fmt"{x = :}" == "x = 12"
doAssert fmt"{x = }" == "x = 12"
doAssert fmt"{x   =  :}" == "x   =  12"
doAssert fmt"{x   =  }" == "x   =  12"</pre> <h2 id="implementation-details">Implementation details</h2>
<p>An expression like <code>&amp;"{key} is {value:arg} {{z}}"</code> is transformed into:</p> <pre class="listing" data-language="nim">var temp = newStringOfCap(educatedCapGuess)
temp.formatValue key, ""
temp.add " is "
temp.formatValue value, arg
temp.add " {z}"
temp</pre>
<p>Parts of the string that are enclosed in the curly braces are interpreted as Nim code, to escape an <code>{</code> or <code>}</code> double it.</p> <p><code>&amp;</code> delegates most of the work to an open overloaded set of <code>formatValue</code> procs. The required signature for a type <code>T</code> that supports formatting is usually <code>proc formatValue(result: var string; x: T; specifier: string)</code>.</p> <p>The subexpression after the colon (<code>arg</code> in <code>&amp;"{key} is {value:arg} {{z}}"</code>) is optional. It will be passed as the last argument to <code>formatValue</code>. When the colon with the subexpression it is left out, an empty string will be taken instead.</p> <p>For strings and numeric types the optional argument is a so-called "standard format specifier".</p> <h2 id="standard-format-specifier-for-strings-integers-and-floats">Standard format specifier for strings, integers and floats</h2>
<p>The general form of a standard format specifier is:</p>
<pre data-language="nim">[[fill]align][sign][#][0][minimumwidth][.precision][type]</pre> <p>The square brackets <code>[]</code> indicate an optional element.</p> <p>The optional align flag can be one of the following:</p> <dl>
<dt>'&lt;'</dt> <dd>Forces the field to be left-aligned within the available space. (This is the default for strings.)</dd> <dt>'&gt;'</dt> <dd>Forces the field to be right-aligned within the available space. (This is the default for numbers.)</dd> <dt>'^'</dt> <dd>Forces the field to be centered within the available space.</dd> </dl> <p>Note that unless a minimum field width is defined, the field width will always be the same size as the data to fill it, so that the alignment option has no meaning in this case.</p> <p>The optional 'fill' character defines the character to be used to pad the field to the minimum width. The fill character, if present, must be followed by an alignment flag.</p> <p>The 'sign' option is only valid for numeric types, and can be one of the following:</p> <table>
<tr>
<th>Sign</th>
<th>Meaning</th>
</tr> <tr>
<td><code>+</code></td>
<td>Indicates that a sign should be used for both positive as well as negative numbers.</td>
</tr> <tr>
<td><code>-</code></td>
<td>Indicates that a sign should be used only for negative numbers (this is the default behavior).</td>
</tr> <tr>
<td>(space)</td>
<td>Indicates that a leading space should be used on positive numbers.</td>
</tr> </table>
<p>If the '#' character is present, integers use the 'alternate form' for formatting. This means that binary, octal, and hexadecimal output will be prefixed with '0b', '0o', and '0x', respectively.</p> <p>'width' is a decimal integer defining the minimum field width. If not specified, then the field width will be determined by the content.</p> <p>If the width field is preceded by a zero ('0') character, this enables zero-padding.</p> <p>The 'precision' is a decimal number indicating how many digits should be displayed after the decimal point in a floating point conversion. For non-numeric types the field indicates the maximum field size - in other words, how many characters will be used from the field content. The precision is ignored for integer conversions.</p> <p>Finally, the 'type' determines how the data should be presented.</p> <p>The available integer presentation types are:</p> <table>
<tr>
<th>Type</th>
<th>Result</th>
</tr> <tr>
<td><code>b</code></td>
<td>Binary. Outputs the number in base 2.</td>
</tr> <tr>
<td><code>d</code></td>
<td>Decimal Integer. Outputs the number in base 10.</td>
</tr> <tr>
<td><code>o</code></td>
<td>Octal format. Outputs the number in base 8.</td>
</tr> <tr>
<td><code>x</code></td>
<td>Hex format. Outputs the number in base 16, using lower-case letters for the digits above 9.</td>
</tr> <tr>
<td><code>X</code></td>
<td>Hex format. Outputs the number in base 16, using uppercase letters for the digits above 9.</td>
</tr> <tr>
<td>(None)</td>
<td>the same as 'd'</td>
</tr> </table>
<p>The available floating point presentation types are:</p> <table>
<tr>
<th>Type</th>
<th>Result</th>
</tr> <tr>
<td><code>e</code></td>
<td>Exponent notation. Prints the number in scientific notation using the letter 'e' to indicate the exponent.</td>
</tr> <tr>
<td><code>E</code></td>
<td>Exponent notation. Same as 'e' except it converts the number to uppercase.</td>
</tr> <tr>
<td><code>f</code></td>
<td>Fixed point. Displays the number as a fixed-point number.</td>
</tr> <tr>
<td><code>F</code></td>
<td>Fixed point. Same as 'f' except it converts the number to uppercase.</td>
</tr> <tr>
<td><code>g</code></td>
<td>General format. This prints the number as a fixed-point number, unless the number is too large, in which case it switches to 'e' exponent notation.</td>
</tr> <tr>
<td><code>G</code></td>
<td>General format. Same as 'g' except switches to 'E' if the number gets to large.</td>
</tr> <tr>
<td>(None)</td>
<td>similar to 'g', except that it prints at least one digit after the decimal point.</td>
</tr> </table> <h2 id="limitations">Limitations</h2>
<p>Because of the well defined order how templates and macros are expanded, strformat cannot expand template arguments:</p> <pre class="listing" data-language="nim">template myTemplate(arg: untyped): untyped =
  echo "arg is: ", arg
  echo &amp;"--- {arg} ---"

let x = "abc"
myTemplate(x)</pre>
<p>First the template <code>myTemplate</code> is expanded, where every identifier <code>arg</code> is substituted with its argument. The <code>arg</code> inside the format string is not seen by this process, because it is part of a quoted string literal. It is not an identifier yet. Then the strformat macro creates the <code>arg</code> identifier from the string literal. An identifier that cannot be resolved anymore.</p> <p>The workaround for this is to bind the template argument to a new local variable.</p> <pre class="listing" data-language="nim">template myTemplate(arg: untyped): untyped =
  block:
    let arg1 {.inject.} = arg
    echo "arg is: ", arg1
    echo &amp;"--- {arg1} ---"</pre>
<p>The use of <code>{.inject.}</code> here is necessary again because of template expansion order and hygienic templates. But since we generally want to keep the hygienicness of <code>myTemplate</code>, and we do not want <code>arg1</code> to be injected into the context where <code>myTemplate</code> is expanded, everything is wrapped in a <code>block</code>.</p> <h2 id="future-directions">Future directions</h2>
<p>A curly expression with commas in it like <code>{x, argA, argB}</code> could be transformed to <code>formatValue(result, x, argA, argB)</code> in order to support formatters that do not need to parse a custom language within a custom language but instead prefer to use Nim's existing syntax. This also helps in readability since there is only so much you can cram into single letter DSLs.</p>  <h2 id="6">Imports</h2> <dl> <a href="macros.html">macros</a>, <a href="parseutils.html">parseutils</a>, <a href="unicode.html">unicode</a>, <a href="strutils.html">strutils</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="StandardFormatSpecifier" data-language="nim">StandardFormatSpecifier = object
  fill*, align*: char        ## Desired fill and alignment.
  sign*: char                ## Desired sign.
  alternateForm*: bool       ## Whether to prefix binary, octal and hex numbers
                             ## with ``0b``, ``0o``, ``0x``.
  padWithZero*: bool         ## Whether to pad with zeros rather than spaces.
  minimumWidth*, precision*: int ## Desired minimum width and precision.
  typ*: char                 ## Type like 'f', 'g' or 'd'.
  endPosition*: int          ## End position in the format specifier after
                             ## ``parseStandardFormatSpecifier`` returned.</pre></dt> <dd> Type that describes "standard format specifiers". <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L342" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L342" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="alignString%2Cstring%2Cint%2Cchar%2Cchar" data-language="nim">proc alignString(s: string; minimumWidth: int; align = '\x00'; fill = ' '): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Aligns <code>s</code> using <code>fill</code> char. This is only of interest if you want to write a custom <code>format</code> proc that should support the standard format specifiers. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L321" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L321" target="_blank">Edit</a> </dd>  <dt><pre id="parseStandardFormatSpecifier%2Cstring%2Cint" data-language="nim">proc parseStandardFormatSpecifier(s: string; start = 0;
                                  ignoreUnknownSuffix = false): StandardFormatSpecifier {...}{.
    raises: [ValueError], tags: [].}</pre></dt> <dd> <p>An exported helper proc that parses the "standard format specifiers", as specified by the grammar:</p>
<pre data-language="nim">[[fill]align][sign][#][0][minimumwidth][.precision][type]</pre> <p>This is only of interest if you want to write a custom <code>format</code> proc that should support the standard format specifiers. If <code>ignoreUnknownSuffix</code> is true, an unknown suffix after the <code>type</code> field is not an error.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L413" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L413" target="_blank">Edit</a> </dd>  <dt><pre id="formatValue%2Cstring%2CT%2Cstring" data-language="nim">proc formatValue[T: SomeInteger](result: var string; value: T; specifier: string)</pre></dt> <dd> Standard format implementation for <code>SomeInteger</code>. It makes little sense to call this directly, but it is required to exist by the <code>&amp;</code> macro. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L465" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L465" target="_blank">Edit</a> </dd>  <dt><pre id="formatValue%2Cstring%2CSomeFloat%2Cstring" data-language="nim">proc formatValue(result: var string; value: SomeFloat; specifier: string)</pre></dt> <dd> Standard format implementation for <code>SomeFloat</code>. It makes little sense to call this directly, but it is required to exist by the <code>&amp;</code> macro. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L486" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L486" target="_blank">Edit</a> </dd>  <dt><pre id="formatValue%2Cstring%2Cstring%2Cstring" data-language="nim">proc formatValue(result: var string; value: string; specifier: string) {...}{.
    raises: [ValueError], tags: [].}</pre></dt> <dd> Standard format implementation for <code>string</code>. It makes little sense to call this directly, but it is required to exist by the <code>&amp;</code> macro. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L543" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L543" target="_blank">Edit</a> </dd> </dl>  <h2 id="17">Macros</h2> <dl>  <dt><pre id="%26.m%2Cstring" data-language="nim">macro `&amp;`(pattern: string): untyped</pre></dt> <dd> For a specification of the <code>&amp;</code> macro, see the module level documentation. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L649" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L649" target="_blank">Edit</a> </dd>  <dt><pre id="fmt.m%2Cstring" data-language="nim">macro fmt(pattern: string): untyped</pre></dt> <dd> An alias for <code>&amp;</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L652" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L652" target="_blank">Edit</a> </dd>  <dt><pre id="fmt.m%2Cstring%2Cchar%2Cchar" data-language="nim">macro fmt(pattern: string; openChar, closeChar: char): untyped</pre></dt> <dd> Use <code>openChar</code> instead of '{' and <code>closeChar</code> instead of '}' <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let testInt = 123
doAssert "&lt;testInt&gt;".fmt('&lt;', '&gt;') == "123"
doAssert """(()"foo" &amp; "bar"())""".fmt(')', '(') == "(foobar)"
doAssert """ ""{"123+123"}"" """.fmt('"', '"') == " \"{246}\" "</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strformat.nim#L655" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strformat.nim#L655" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/strformat.html" class="_attribution-link">https://nim-lang.org/docs/strformat.html</a>
  </p>
</div>
