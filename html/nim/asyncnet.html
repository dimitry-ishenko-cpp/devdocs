<h1 class="title">asyncnet</h1>  <p class="module-desc">This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the <code>asyncdispatch</code> module. </p>
<h2 id="asynchronous-io-in-nim">Asynchronous IO in Nim</h2>
<p>Async IO in Nim consists of multiple layers (from highest to lowest):</p> <ul class="simple">
<li>
<code>asyncnet</code> module</li> <li>Async await</li> <li>
<code>asyncdispatch</code> module (event loop)</li> <li>
<code>selectors</code> module</li> </ul> <p>Each builds on top of the layers below it. The selectors module is an abstraction for the various system <code>select()</code> mechanisms such as epoll or kqueue. If you wish you can use it directly, and some people have done so <a href="http://goran.krampe.se/2014/10/25/nim-socketserver/">successfully</a>. But you must be aware that on Windows it only supports <code>select()</code>.</p> <p>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</p> <p>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</p> <p>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</p> <p>For most applications using <code>asyncnet</code> is the way to go as it builds over all the layers, providing some extra features such as buffering.</p> <p>SSL ===</p> <p>SSL can be enabled by compiling with the <code>-d:ssl</code> flag.</p> <p>You must create a new SSL context with the <code>newContext</code> function defined in the <code>net</code> module. You may then call <code>wrapSocket</code> on your socket using the newly created SSL context to get an SSL socket.</p> <h2 id="examples">Examples</h2> <h3 id="examples-chat-server">Chat server</h3>
<p>The following example demonstrates a simple chat server.</p> <pre class="listing" data-language="nim">import asyncnet, asyncdispatch

var clients {.threadvar.}: seq[AsyncSocket]

proc processClient(client: AsyncSocket) {.async.} =
  while true:
    let line = await client.recvLine()
    if line.len == 0: break
    for c in clients:
      await c.send(line &amp; "\c\L")

proc serve() {.async.} =
  clients = @[]
  var server = newAsyncSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(12345))
  server.listen()
  
  while true:
    let client = await server.accept()
    clients.add client
    
    asyncCheck processClient(client)

asyncCheck serve()
runForever()</pre>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a>, <a href="asyncdispatch.html">asyncdispatch</a>, <a href="nativesockets.html">nativesockets</a>, <a href="net.html">net</a>, <a href="os.html">os</a>, <a href="openssl.html">openssl</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="AsyncSocket">AsyncSocket = ref AsyncSocketDesc</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L130" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L130" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="newAsyncSocket%2CAsyncFD%2CDomain%2CSockType%2CProtocol" data-language="nim">proc newAsyncSocket(fd: AsyncFD; domain: Domain = AF_INET;
                    sockType: SockType = SOCK_STREAM;
                    protocol: Protocol = IPPROTO_TCP; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {...}{.
    raises: [OSError], tags: [].}</pre></dt> <dd> <p>Creates a new <code>AsyncSocket</code> based on the supplied params.</p> <p>The supplied <code>fd</code>'s non-blocking state will be enabled implicitly.</p> <p>If <code>inheritable</code> is false (the default), the supplied <code>fd</code> will not be inheritable by child processes.</p> <p><strong>Note</strong>: This procedure will <strong>NOT</strong> register <code>fd</code> with the global async dispatcher. You need to do this manually. If you have used <code>newAsyncNativeSocket</code> to create <code>fd</code> then it's already registered.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L132" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L132" target="_blank">Edit</a> </dd>  <dt><pre id="newAsyncSocket%2CDomain%2CSockType%2CProtocol" data-language="nim">proc newAsyncSocket(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                    protocol: Protocol = IPPROTO_TCP; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {...}{.
    raises: [OSError, Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Creates a new asynchronous socket.</p> <p>This procedure will also create a brand new file descriptor for this socket.</p> <p>If <code>inheritable</code> is false (the default), the new file descriptor will not be inheritable by child processes.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L160" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L160" target="_blank">Edit</a> </dd>  <dt><pre id="getLocalAddr%2CAsyncSocket" data-language="nim">proc getLocalAddr(socket: AsyncSocket): (string, Port) {...}{.
    raises: [OSError, Exception], tags: [].}</pre></dt> <dd> <p>Get the socket's local address and port number.</p> <p>This is high-level interface for <span id="getsockname_1">getsockname</span>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L175" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L175" target="_blank">Edit</a> </dd>  <dt><pre id="getPeerAddr%2CAsyncSocket" data-language="nim">proc getPeerAddr(socket: AsyncSocket): (string, Port) {...}{.
    raises: [OSError, Exception], tags: [].}</pre></dt> <dd> <p>Get the socket's peer address and port number.</p> <p>This is high-level interface for <span id="getpeername_1">getpeername</span>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L181" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L181" target="_blank">Edit</a> </dd>  <dt><pre id="newAsyncSocket%2Ccint%2Ccint%2Ccint" data-language="nim">proc newAsyncSocket(domain, sockType, protocol: cint; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {...}{.
    raises: [OSError, Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Creates a new asynchronous socket.</p> <p>This procedure will also create a brand new file descriptor for this socket.</p> <p>If <code>inheritable</code> is false (the default), the new file descriptor will not be inheritable by child processes.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L187" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L187" target="_blank">Edit</a> </dd>  <dt><pre id="dial%2Cstring%2CPort" data-language="nim">proc dial(address: string; port: Port; protocol = IPPROTO_TCP; buffered = true): owned(
    Future[AsyncSocket]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> Establishes connection to the specified <code>address</code>:<code>port</code> pair via the specified protocol. The procedure iterates through possible resolutions of the <code>address</code> until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns AsyncSocket ready to send or receive data. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L281" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L281" target="_blank">Edit</a> </dd>  <dt><pre id="connect%2CAsyncSocket%2Cstring%2CPort" data-language="nim">proc connect(socket: AsyncSocket; address: string; port: Port): owned(
    Future[void]) {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Connects <code>socket</code> to server at <code>address:port</code>.</p> <p>Returns a <code>Future</code> which will complete when the connection succeeds or an error occurs.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L292" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L292" target="_blank">Edit</a> </dd>  <dt><pre id="recvInto%2CAsyncSocket%2Cpointer%2Cint" data-language="nim">proc recvInto(socket: AsyncSocket; buf: pointer; size: int;
              flags = {SafeDisconn}): owned(Future[int]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code>size</code> bytes from <code>socket</code> into <code>buf</code>.</p> <p>For buffered sockets this function will attempt to read all the requested data. It will read this data in <code>BufferSize</code> chunks.</p> <p>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</p> <p>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</p> <p>If socket is disconnected and no data is available to be read then the future will complete with a value of <code>0</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L334" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L334" target="_blank">Edit</a> </dd>  <dt><pre id="recv%2CAsyncSocket%2Cint" data-language="nim">proc recv(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
    Future[string]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code>size</code> bytes from <code>socket</code>.</p> <p>For buffered sockets this function will attempt to read all the requested data. It will read this data in <code>BufferSize</code> chunks.</p> <p>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</p> <p>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</p> <p>If socket is disconnected and no data is available to be read then the future will complete with a value of <code>""</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L382" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L382" target="_blank">Edit</a> </dd>  <dt><pre id="send%2CAsyncSocket%2Cpointer%2Cint" data-language="nim">proc send(socket: AsyncSocket; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[void]) {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Sends <code>size</code> bytes from <code>buf</code> to <code>socket</code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L434" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L434" target="_blank">Edit</a> </dd>  <dt><pre id="send%2CAsyncSocket%2Cstring" data-language="nim">proc send(socket: AsyncSocket; data: string; flags = {SafeDisconn}): owned(
    Future[void]) {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Sends <code>data</code> to <code>socket</code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L448" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L448" target="_blank">Edit</a> </dd>  <dt><pre id="acceptAddr%2CAsyncSocket" data-language="nim">proc acceptAddr(socket: AsyncSocket; flags = {SafeDisconn};
                inheritable = defined(nimInheritHandles)): owned(
    Future[tuple[address: string, client: AsyncSocket]]) {...}{.
    raises: [Exception, ValueError, OSError], tags: [RootEffect].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client.</p> <p>If <code>inheritable</code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The future will complete when the connection is successfully accepted.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L461" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L461" target="_blank">Edit</a> </dd>  <dt><pre id="accept%2CAsyncSocket" data-language="nim">proc accept(socket: AsyncSocket; flags = {SafeDisconn}): owned(
    Future[AsyncSocket]) {...}{.raises: [Exception, ValueError, OSError],
                           tags: [RootEffect].}</pre></dt> <dd> Accepts a new connection. Returns a future containing the client socket corresponding to that connection. If <code>inheritable</code> is false (the default), the resulting client socket will not be inheritable by child processes. The future will complete when the connection is successfully accepted. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L485" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L485" target="_blank">Edit</a> </dd>  <dt><pre id="recvLineInto%2CAsyncSocket%2CFutureVar%5Bstring%5D" data-language="nim">proc recvLineInto(socket: AsyncSocket; resString: FutureVar[string];
                  flags = {SafeDisconn}; maxLength = MaxLineLength): owned(
    Future[void]) {...}{.raises: [ValueError, Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Reads a line of data from <code>socket</code> into <code>resString</code>.</p> <p>If a full line is read <code>\r\L</code> is not added to <code>line</code>, however if solely <code>\r\L</code> is read then <code>line</code> will be set to it.</p> <p>If the socket is disconnected, <code>line</code> will be set to <code>""</code>.</p> <p>If the socket is disconnected in the middle of a line (before <code>\r\L</code> is read) then line will be set to <code>""</code>. The partial line <strong>will be lost</strong>.</p> <p>The <code>maxLength</code> parameter determines the maximum amount of characters that can be read. <code>resString</code> will be truncated after that.</p> <p><strong>Warning</strong>: The <code>Peek</code> flag is not yet implemented.</p> <p><strong>Warning</strong>: <code>recvLineInto</code> on unbuffered sockets assumes that the protocol uses <code>\r\L</code> to delimit a new line.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L504" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L504" target="_blank">Edit</a> </dd>  <dt><pre id="recvLine%2CAsyncSocket" data-language="nim">proc recvLine(socket: AsyncSocket; flags = {SafeDisconn};
              maxLength = MaxLineLength): owned(Future[string]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Reads a line of data from <code>socket</code>. Returned future will complete once a full line is read or an error occurs.</p> <p>If a full line is read <code>\r\L</code> is not added to <code>line</code>, however if solely <code>\r\L</code> is read then <code>line</code> will be set to it.</p> <p>If the socket is disconnected, <code>line</code> will be set to <code>""</code>.</p> <p>If the socket is disconnected in the middle of a line (before <code>\r\L</code> is read) then line will be set to <code>""</code>. The partial line <strong>will be lost</strong>.</p> <p>The <code>maxLength</code> parameter determines the maximum amount of characters that can be read. The result is truncated after that.</p> <p><strong>Warning</strong>: The <code>Peek</code> flag is not yet implemented.</p> <p><strong>Warning</strong>: <code>recvLine</code> on unbuffered sockets assumes that the protocol uses <code>\r\L</code> to delimit a new line.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L597" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L597" target="_blank">Edit</a> </dd>  <dt><pre id="listen%2CAsyncSocket" data-language="nim">proc listen(socket: AsyncSocket; backlog = SOMAXCONN) {...}{.tags: [ReadIOEffect],
    raises: [OSError].}</pre></dt> <dd> <p>Marks <code>socket</code> as accepting connections. <code>Backlog</code> specifies the maximum length of the queue of pending connections.</p> <p>Raises an OSError error upon failure.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L626" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L626" target="_blank">Edit</a> </dd>  <dt><pre id="bindAddr%2CAsyncSocket%2Cstring" data-language="nim">proc bindAddr(socket: AsyncSocket; port = Port(0); address = "") {...}{.
    tags: [ReadIOEffect], raises: [ValueError, OSError].}</pre></dt> <dd> <p>Binds <code>address</code>:<code>port</code> to the socket.</p> <p>If <code>address</code> is "" then ADDR_ANY will be bound.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L635" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L635" target="_blank">Edit</a> </dd>  <dt><pre id="connectUnix%2CAsyncSocket%2Cstring" data-language="nim">proc connectUnix(socket: AsyncSocket; path: string): owned(Future[void]) {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Binds Unix socket to <code>path</code>. This only works on Unix-style systems: Mac OS X, BSD and Linux <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L657" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L657" target="_blank">Edit</a> </dd>  <dt><pre id="bindUnix%2CAsyncSocket%2Cstring" data-language="nim">proc bindUnix(socket: AsyncSocket; path: string) {...}{.tags: [ReadIOEffect],
    raises: [].}</pre></dt> <dd> Binds Unix socket to <code>path</code>. This only works on Unix-style systems: Mac OS X, BSD and Linux <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L688" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L688" target="_blank">Edit</a> </dd>  <dt><pre id="close%2CAsyncSocket" data-language="nim">proc close(socket: AsyncSocket) {...}{.raises: [Exception, LibraryError, SslError],
                                  tags: [RootEffect].}</pre></dt> <dd> Closes the socket. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L710" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L710" target="_blank">Edit</a> </dd>  <dt><pre id="wrapSocket%2CSslContext%2CAsyncSocket" data-language="nim">proc wrapSocket(ctx: SslContext; socket: AsyncSocket) {...}{.raises: [SslError],
    tags: [].}</pre></dt> <dd> <p>Wraps a socket in an SSL context. This function effectively turns <code>socket</code> into an SSL socket.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L736" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L736" target="_blank">Edit</a> </dd>  <dt><pre id="wrapConnectedSocket%2CSslContext%2CAsyncSocket%2CSslHandshakeType%2Cstring" data-language="nim">proc wrapConnectedSocket(ctx: SslContext; socket: AsyncSocket;
                         handshake: SslHandshakeType; hostname: string = "") {...}{.
    raises: [SslError], tags: [].}</pre></dt> <dd> <p>Wraps a connected socket in an SSL context. This function effectively turns <code>socket</code> into an SSL socket. <code>hostname</code> should be specified so that the client knows which hostname the server certificate should be validated against.</p> <p>This should be called on a connected socket, and will perform an SSL handshake immediately.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L754" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L754" target="_blank">Edit</a> </dd>  <dt><pre id="getPeerCertificates%2CAsyncSocket" data-language="nim">proc getPeerCertificates(socket: AsyncSocket): seq[Certificate] {...}{.
    raises: [Exception], tags: [].}</pre></dt> <dd> Returns the certificate chain received by the peer we are connected to through the given socket. The handshake must have been completed and the certificate chain must have been verified successfully or else an empty sequence is returned. The chain is ordered from leaf certificate to root certificate. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L779" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L779" target="_blank">Edit</a> </dd>  <dt><pre id="getSockOpt%2CAsyncSocket%2CSOBool" data-language="nim">proc getSockOpt(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {...}{.
    tags: [ReadIOEffect], raises: [OSError].}</pre></dt> <dd> Retrieves option <code>opt</code> as a boolean value. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L790" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L790" target="_blank">Edit</a> </dd>  <dt><pre id="setSockOpt%2CAsyncSocket%2CSOBool%2Cbool" data-language="nim">proc setSockOpt(socket: AsyncSocket; opt: SOBool; value: bool;
                level = SOL_SOCKET) {...}{.tags: [WriteIOEffect], raises: [OSError].}</pre></dt> <dd> Sets option <code>opt</code> to a boolean value specified by <code>value</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L796" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L796" target="_blank">Edit</a> </dd>  <dt><pre id="isSsl%2CAsyncSocket" data-language="nim">proc isSsl(socket: AsyncSocket): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Determines whether <code>socket</code> is a SSL socket. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L802" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L802" target="_blank">Edit</a> </dd>  <dt><pre id="getFd%2CAsyncSocket" data-language="nim">proc getFd(socket: AsyncSocket): SocketHandle {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the socket's file descriptor. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L806" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L806" target="_blank">Edit</a> </dd>  <dt><pre id="isClosed%2CAsyncSocket" data-language="nim">proc isClosed(socket: AsyncSocket): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Determines whether the socket has been closed. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L810" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L810" target="_blank">Edit</a> </dd>  <dt><pre id="sendTo%2CAsyncSocket%2Cstring%2CPort%2Cstring" data-language="nim">proc sendTo(socket: AsyncSocket; address: string; port: Port; data: string;
            flags = {SafeDisconn}): owned(Future[void]) {...}{.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> <p>This proc sends <code>data</code> to the specified <code>address</code>, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L816" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L816" target="_blank">Edit</a> </dd>  <dt><pre id="recvFrom%2CAsyncSocket%2CFutureVar%5Bstring%5D%2Cint%2CFutureVar%5Bstring%5D%2CFutureVar%5BPort%5D" data-language="nim">proc recvFrom(socket: AsyncSocket; data: FutureVar[string]; size: int;
              address: FutureVar[string]; port: FutureVar[Port];
              flags = {SafeDisconn}): owned(Future[int]) {...}{.
    raises: [ValueError, Exception], tags: [RootEffect].}</pre></dt> <dd> <p>Receives a datagram data from <code>socket</code> into <code>data</code>, which must be at least of size <code>size</code>. The address and port of datagram's sender will be stored into <code>address</code> and <code>port</code>, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <p><strong>Notes</strong></p> <ul class="simple">
<li>
<code>data</code> must be initialized to the length of <code>size</code>.</li> <li>
<code>address</code> must be initialized to 46 in length.</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L863" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L863" target="_blank">Edit</a> </dd>  <dt><pre id="recvFrom%2CAsyncSocket%2Cint" data-language="nim">proc recvFrom(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
    Future[tuple[data: string, address: string, port: Port]]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Receives a datagram data from <code>socket</code>, which must be at least of size <code>size</code>. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncnet.nim#L917" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L917" target="_blank">Edit</a> </dd> </dl>  <h2 id="19">Exports</h2> <dl> <a href="net.html#SOBool"><span class="Identifier">SOBool</span></a> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/asyncnet.html" class="_attribution-link">https://nim-lang.org/docs/asyncnet.html</a>
  </p>
</div>
