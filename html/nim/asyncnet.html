<h1 class="title">std/asyncnet</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L1" target="_blank">Edit</a>  <p class="module-desc">This module implements a high-level asynchronous sockets API based on the asynchronous dispatcher defined in the <code><span class="Identifier">asyncdispatch</span></code> module. </p>
<h2 id="asynchronous-io-in-nim">Asynchronous IO in Nim</h2>
<p>Async IO in Nim consists of multiple layers (from highest to lowest):</p> <ul class="simple">
<li>
<code><span class="Identifier">asyncnet</span></code> module</li> <li>Async await</li> <li>
<code><span class="Identifier">asyncdispatch</span></code> module (event loop)</li> <li>
<code><span class="Identifier">selectors</span></code> module</li> </ul> <p>Each builds on top of the layers below it. The selectors module is an abstraction for the various system <code><span class="Identifier">select</span><span class="Punctuation">(</span><span class="Punctuation">)</span></code> mechanisms such as epoll or kqueue. If you wish you can use it directly, and some people have done so <a href="http://goran.krampe.se/2014/10/25/nim-socketserver/">successfully</a>. But you must be aware that on Windows it only supports <code><span class="Identifier">select</span><span class="Punctuation">(</span><span class="Punctuation">)</span></code>.</p> <p>The async dispatcher implements the proactor pattern and also has an implementation of IOCP. It implements the proactor pattern for other OS' via the selectors module. Futures are also implemented here, and indeed all the procedures return a future.</p> <p>The final layer is the async await transformation. This allows you to write asynchronous code in a synchronous style and works similar to C#'s await. The transformation works by converting any async procedures into an iterator.</p> <p>This is all single threaded, fully non-blocking and does give you a lot of control. In theory you should be able to work with any of these layers interchangeably (as long as you only care about non-Windows platforms).</p> <p>For most applications using <code><span class="Identifier">asyncnet</span></code> is the way to go as it builds over all the layers, providing some extra features such as buffering.</p> <h2 id="ssl">SSL</h2>
<p>SSL can be enabled by compiling with the <code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">ssl</span></code> flag.</p> <p>You must create a new SSL context with the <code><span class="Identifier">newContext</span></code> function defined in the <code><span class="Identifier">net</span></code> module. You may then call <code><span class="Identifier">wrapSocket</span></code> on your socket using the newly created SSL context to get an SSL socket.</p> <h2 id="examples">Examples</h2> <h3 id="examples-chat-server">Chat server</h3>
<p>The following example demonstrates a simple chat server.</p> 
<pre class="listing" data-language="nim">import std/[asyncnet, asyncdispatch]

var clients {.threadvar.}: seq[AsyncSocket]

proc processClient(client: AsyncSocket) {.async.} =
  while true:
    let line = await client.recvLine()
    if line.len == 0: break
    for c in clients:
      await c.send(line &amp; "\c\L")

proc serve() {.async.} =
  clients = @[]
  var server = newAsyncSocket()
  server.setSockOpt(OptReuseAddr, true)
  server.bindAddr(Port(12345))
  server.listen()
  
  while true:
    let client = await server.accept()
    clients.add client
    
    asyncCheck processClient(client)

asyncCheck serve()
runForever()</pre>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a>, <a href="asyncdispatch.html">asyncdispatch</a>, <a href="nativesockets.html">nativesockets</a>, <a href="net.html">net</a>, <a href="os.html">os</a>, <a href="openssl.html">openssl</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="AsyncSocket"> <dt><pre>AsyncSocket = ref AsyncSocketDesc</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L135" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L135" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="accept-procs-all"> <div id="accept,AsyncSocket"> <dt><pre data-language="nim">proc accept(socket: AsyncSocket; flags = {SafeDisconn}): owned(
    Future[AsyncSocket]) {....raises: [ValueError, OSError, Exception],
                           tags: [RootEffect], forbids: [].}</pre></dt> <dd> Accepts a new connection. Returns a future containing the client socket corresponding to that connection. If <code><span class="Identifier">inheritable</span></code> is false (the default), the resulting client socket will not be inheritable by child processes. The future will complete when the connection is successfully accepted. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L495" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L495" target="_blank">Edit</a> </dd> </div> </div> <div id="acceptAddr-procs-all"> <div id="acceptAddr,AsyncSocket"> <dt><pre data-language="nim">proc acceptAddr(socket: AsyncSocket; flags = {SafeDisconn};
                inheritable = defined(nimInheritHandles)): owned(
    Future[tuple[address: string, client: AsyncSocket]]) {.
    ...raises: [ValueError, OSError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The future will complete when the connection is successfully accepted.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L471" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L471" target="_blank">Edit</a> </dd> </div> </div> <div id="bindAddr-procs-all"> <div id="bindAddr,AsyncSocket,string"> <dt><pre data-language="nim">proc bindAddr(socket: AsyncSocket; port = Port(0); address = "") {.
    ...tags: [ReadIOEffect], raises: [ValueError, OSError], forbids: [].}</pre></dt> <dd> <p>Binds <code><span class="Identifier">address</span></code>:<code><span class="Identifier">port</span></code> to the socket.</p> <p>If <code><span class="Identifier">address</span></code> is "" then ADDR_ANY will be bound.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L643" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L643" target="_blank">Edit</a> </dd> </div> </div> <div id="bindUnix-procs-all"> <div id="bindUnix,AsyncSocket,string"> <dt><pre data-language="nim">proc bindUnix(socket: AsyncSocket; path: string) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Binds Unix socket to <code><span class="Identifier">path</span></code>. This only works on Unix-style systems: Mac OS X, BSD and Linux <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L718" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L718" target="_blank">Edit</a> </dd> </div> </div> <div id="close-procs-all"> <div id="close,AsyncSocket"> <dt><pre data-language="nim">proc close(socket: AsyncSocket) {....raises: [LibraryError, Exception, SslError],
                                  tags: [RootEffect], forbids: [].}</pre></dt> <dd> Closes the socket. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L723" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L723" target="_blank">Edit</a> </dd> </div> </div> <div id="connect-procs-all"> <div id="connect,AsyncSocket,string,Port"> <dt><pre data-language="nim">proc connect(socket: AsyncSocket; address: string; port: Port): owned(
    Future[void]) {....stackTrace: false, raises: [Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> <p>Connects <code><span class="Identifier">socket</span></code> to server at <code><span class="Identifier">address</span><span class="Punctuation">:</span><span class="Identifier">port</span></code>.</p> <p>Returns a <code><span class="Identifier">Future</span></code> which will complete when the connection succeeds or an error occurs.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L301" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L301" target="_blank">Edit</a> </dd> </div> </div> <div id="connectUnix-procs-all"> <div id="connectUnix,AsyncSocket,string"> <dt><pre data-language="nim">proc connectUnix(socket: AsyncSocket; path: string): owned(Future[void]) {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Binds Unix socket to <code><span class="Identifier">path</span></code>. This only works on Unix-style systems: Mac OS X, BSD and Linux <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L713" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L713" target="_blank">Edit</a> </dd> </div> </div> <div id="dial-procs-all"> <div id="dial,string,Port"> <dt><pre data-language="nim">proc dial(address: string; port: Port; protocol = IPPROTO_TCP; buffered = true): owned(
    Future[AsyncSocket]) {....stackTrace: false, raises: [Exception, ValueError],
                           tags: [RootEffect], forbids: [].}</pre></dt> <dd> Establishes connection to the specified <code><span class="Identifier">address</span></code>:<code><span class="Identifier">port</span></code> pair via the specified protocol. The procedure iterates through possible resolutions of the <code><span class="Identifier">address</span></code> until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns AsyncSocket ready to send or receive data. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L290" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L290" target="_blank">Edit</a> </dd> </div> </div> <div id="getFd-procs-all"> <div id="getFd,AsyncSocket"> <dt><pre data-language="nim">proc getFd(socket: AsyncSocket): SocketHandle {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Returns the socket's file descriptor. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L824" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L824" target="_blank">Edit</a> </dd> </div> </div> <div id="getLocalAddr-procs-all"> <div id="getLocalAddr,AsyncSocket"> <dt><pre data-language="nim">proc getLocalAddr(socket: AsyncSocket): (string, Port) {.
    ...raises: [OSError, Exception], tags: [], forbids: [].}</pre></dt> <dd> <p>Get the socket's local address and port number.</p> <p>This is high-level interface for <span id="getsockname_1">getsockname</span>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L180" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L180" target="_blank">Edit</a> </dd> </div> </div> <div id="getPeerAddr-procs-all"> <div id="getPeerAddr,AsyncSocket"> <dt><pre data-language="nim">proc getPeerAddr(socket: AsyncSocket): (string, Port) {.
    ...raises: [OSError, Exception], tags: [], forbids: [].}</pre></dt> <dd> <p>Get the socket's peer address and port number.</p> <p>This is high-level interface for <span id="getpeername_1">getpeername</span>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L187" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L187" target="_blank">Edit</a> </dd> </div> </div> <div id="getPeerCertificates-procs-all"> <div id="getPeerCertificates,AsyncSocket"> <dt><pre data-language="nim">proc getPeerCertificates(socket: AsyncSocket): seq[Certificate] {.
    ...raises: [Exception], tags: [], forbids: [].}</pre></dt> <dd> Returns the certificate chain received by the peer we are connected to through the given socket. The handshake must have been completed and the certificate chain must have been verified successfully or else an empty sequence is returned. The chain is ordered from leaf certificate to root certificate. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L797" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L797" target="_blank">Edit</a> </dd> </div> </div> <div id="getSockOpt-procs-all"> <div id="getSockOpt,AsyncSocket,SOBool"> <dt><pre data-language="nim">proc getSockOpt(socket: AsyncSocket; opt: SOBool; level = SOL_SOCKET): bool {.
    ...tags: [ReadIOEffect], raises: [OSError], forbids: [].}</pre></dt> <dd> Retrieves option <code><span class="Identifier">opt</span></code> as a boolean value. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L808" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L808" target="_blank">Edit</a> </dd> </div> </div> <div id="hasDataBuffered-procs-all"> <div id="hasDataBuffered,AsyncSocket"> <dt><pre data-language="nim">proc hasDataBuffered(s: AsyncSocket): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Determines whether an AsyncSocket has data buffered. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L663" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L663" target="_blank">Edit</a> </dd> </div> </div> <div id="isClosed-procs-all"> <div id="isClosed,AsyncSocket"> <dt><pre data-language="nim">proc isClosed(socket: AsyncSocket): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Determines whether the socket has been closed. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L828" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L828" target="_blank">Edit</a> </dd> </div> </div> <div id="isSsl-procs-all"> <div id="isSsl,AsyncSocket"> <dt><pre data-language="nim">proc isSsl(socket: AsyncSocket): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Determines whether <code><span class="Identifier">socket</span></code> is a SSL socket. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L820" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L820" target="_blank">Edit</a> </dd> </div> </div> <div id="listen-procs-all"> <div id="listen,AsyncSocket"> <dt><pre data-language="nim">proc listen(socket: AsyncSocket; backlog = SOMAXCONN) {....tags: [ReadIOEffect],
    raises: [OSError], forbids: [].}</pre></dt> <dd> <p>Marks <code><span class="Identifier">socket</span></code> as accepting connections. <code><span class="Identifier">Backlog</span></code> specifies the maximum length of the queue of pending connections.</p> <p>Raises an OSError error upon failure.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L634" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L634" target="_blank">Edit</a> </dd> </div> </div> <div id="newAsyncSocket-procs-all"> <div id="newAsyncSocket,cint,cint,cint"> <dt><pre data-language="nim">proc newAsyncSocket(domain, sockType, protocol: cint; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
    ...raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new asynchronous socket.</p> <p>This procedure will also create a brand new file descriptor for this socket.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the new file descriptor will not be inheritable by child processes.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L193" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L193" target="_blank">Edit</a> </dd> </div> <div id="newAsyncSocket,Domain,SockType,Protocol"> <dt><pre data-language="nim">proc newAsyncSocket(domain: Domain = AF_INET; sockType: SockType = SOCK_STREAM;
                    protocol: Protocol = IPPROTO_TCP; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
    ...raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new asynchronous socket.</p> <p>This procedure will also create a brand new file descriptor for this socket.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the new file descriptor will not be inheritable by child processes.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L165" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L165" target="_blank">Edit</a> </dd> </div> <div id="newAsyncSocket,AsyncFD,Domain,SockType,Protocol"> <dt><pre data-language="nim">proc newAsyncSocket(fd: AsyncFD; domain: Domain = AF_INET;
                    sockType: SockType = SOCK_STREAM;
                    protocol: Protocol = IPPROTO_TCP; buffered = true;
                    inheritable = defined(nimInheritHandles)): owned(AsyncSocket) {.
    ...raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new <code><span class="Identifier">AsyncSocket</span></code> based on the supplied params.</p> <p>The supplied <code><span class="Identifier">fd</span></code>'s non-blocking state will be enabled implicitly.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the supplied <code><span class="Identifier">fd</span></code> will not be inheritable by child processes.</p> <p><strong>Note</strong>: This procedure will <strong>NOT</strong> register <code><span class="Identifier">fd</span></code> with the global async dispatcher. You need to do this manually. If you have used <code><span class="Identifier">newAsyncNativeSocket</span></code> to create <code><span class="Identifier">fd</span></code> then it's already registered.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L137" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L137" target="_blank">Edit</a> </dd> </div> </div> <div id="recv-procs-all"> <div id="recv,AsyncSocket,int"> <dt><pre data-language="nim">proc recv(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
    Future[string]) {....stackTrace: false, raises: [Exception, ValueError],
                      tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">socket</span></code>.</p> <p>For buffered sockets this function will attempt to read all the requested data. It will read this data in <code><span class="Identifier">BufferSize</span></code> chunks.</p> <p>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</p> <p>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</p> <p>If socket is disconnected and no data is available to be read then the future will complete with a value of <code><span class="StringLit">""</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L391" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L391" target="_blank">Edit</a> </dd> </div> </div> <div id="recvFrom-procs-all"> <div id="recvFrom,AsyncSocket,FutureVar[string],int,FutureVar[string],FutureVar[Port]"> <dt><pre data-language="nim">proc recvFrom(socket: AsyncSocket; data: FutureVar[string]; size: int;
              address: FutureVar[string]; port: FutureVar[Port];
              flags = {SafeDisconn}): owned(Future[int]) {....stackTrace: false,
    raises: [ValueError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Receives a datagram data from <code><span class="Identifier">socket</span></code> into <code><span class="Identifier">data</span></code>, which must be at least of size <code><span class="Identifier">size</span></code>. The address and port of datagram's sender will be stored into <code><span class="Identifier">address</span></code> and <code><span class="Identifier">port</span></code>, respectively. Returned future will complete once one datagram has been received, and will return size of packet received.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <p><strong>Notes</strong></p> <ul class="simple">
<li>
<code><span class="Identifier">data</span></code> must be initialized to the length of <code><span class="Identifier">size</span></code>.</li> <li>
<code><span class="Identifier">address</span></code> must be initialized to 46 in length.</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L881" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L881" target="_blank">Edit</a> </dd> </div> <div id="recvFrom,AsyncSocket,int"> <dt><pre data-language="nim">proc recvFrom(socket: AsyncSocket; size: int; flags = {SafeDisconn}): owned(
    Future[tuple[data: string, address: string, port: Port]]) {.
    ...stackTrace: false, raises: [Exception, ValueError], tags: [RootEffect],
    forbids: [].}</pre></dt> <dd> <p>Receives a datagram data from <code><span class="Identifier">socket</span></code>, which must be at least of size <code><span class="Identifier">size</span></code>. Returned future will complete once one datagram has been received and will return tuple with: data of packet received; and address and port of datagram's sender.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L935" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L935" target="_blank">Edit</a> </dd> </div> </div> <div id="recvInto-procs-all"> <div id="recvInto,AsyncSocket,pointer,int"> <dt><pre data-language="nim">proc recvInto(socket: AsyncSocket; buf: pointer; size: int;
              flags = {SafeDisconn}): owned(Future[int]) {....stackTrace: false,
    raises: [Exception, ValueError], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">socket</span></code> into <code><span class="Identifier">buf</span></code>.</p> <p>For buffered sockets this function will attempt to read all the requested data. It will read this data in <code><span class="Identifier">BufferSize</span></code> chunks.</p> <p>For unbuffered sockets this function makes no effort to read all the data requested. It will return as much data as the operating system gives it.</p> <p>If socket is disconnected during the recv operation then the future may complete with only a part of the requested data.</p> <p>If socket is disconnected and no data is available to be read then the future will complete with a value of <code><span class="DecNumber">0</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L343" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L343" target="_blank">Edit</a> </dd> </div> </div> <div id="recvLine-procs-all"> <div id="recvLine,AsyncSocket"> <dt><pre data-language="nim">proc recvLine(socket: AsyncSocket; flags = {SafeDisconn};
              maxLength = MaxLineLength): owned(Future[string]) {.
    ...stackTrace: false, raises: [Exception, ValueError], tags: [RootEffect],
    forbids: [].}</pre></dt> <dd> <p>Reads a line of data from <code><span class="Identifier">socket</span></code>. Returned future will complete once a full line is read or an error occurs.</p> <p>If a full line is read <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is not added to <code><span class="Identifier">line</span></code>, however if solely <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is read then <code><span class="Identifier">line</span></code> will be set to it.</p> <p>If the socket is disconnected, <code><span class="Identifier">line</span></code> will be set to <code><span class="StringLit">""</span></code>.</p> <p>If the socket is disconnected in the middle of a line (before <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is read) then line will be set to <code><span class="StringLit">""</span></code>. The partial line <strong>will be lost</strong>.</p> <p>The <code><span class="Identifier">maxLength</span></code> parameter determines the maximum amount of characters that can be read. The result is truncated after that.</p> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> The <code><span class="Identifier">Peek</span></code> flag is not yet implemented.</div> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> <code><span class="Identifier">recvLine</span></code> on unbuffered sockets assumes that the protocol uses <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> to delimit a new line.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L606" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L606" target="_blank">Edit</a> </dd> </div> </div> <div id="recvLineInto-procs-all"> <div id="recvLineInto,AsyncSocket,FutureVar[string]"> <dt><pre data-language="nim">proc recvLineInto(socket: AsyncSocket; resString: FutureVar[string];
                  flags = {SafeDisconn}; maxLength = MaxLineLength): owned(
    Future[void]) {....stackTrace: false, raises: [ValueError, Exception],
                    tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Reads a line of data from <code><span class="Identifier">socket</span></code> into <code><span class="Identifier">resString</span></code>.</p> <p>If a full line is read <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is not added to <code><span class="Identifier">line</span></code>, however if solely <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is read then <code><span class="Identifier">line</span></code> will be set to it.</p> <p>If the socket is disconnected, <code><span class="Identifier">line</span></code> will be set to <code><span class="StringLit">""</span></code>.</p> <p>If the socket is disconnected in the middle of a line (before <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> is read) then line will be set to <code><span class="StringLit">""</span></code>. The partial line <strong>will be lost</strong>.</p> <p>The <code><span class="Identifier">maxLength</span></code> parameter determines the maximum amount of characters that can be read. <code><span class="Identifier">resString</span></code> will be truncated after that.</p> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> The <code><span class="Identifier">Peek</span></code> flag is not yet implemented.</div> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> <code><span class="Identifier">recvLineInto</span></code> on unbuffered sockets assumes that the protocol uses <code><span class="Operator">\</span><span class="Identifier">r</span><span class="Operator">\</span><span class="Identifier">L</span></code> to delimit a new line.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L514" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L514" target="_blank">Edit</a> </dd> </div> </div> <div id="send-procs-all"> <div id="send,AsyncSocket,pointer,int"> <dt><pre data-language="nim">proc send(socket: AsyncSocket; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[void]) {....stackTrace: false, raises: [Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> Sends <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">buf</span></code> to <code><span class="Identifier">socket</span></code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L444" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L444" target="_blank">Edit</a> </dd> </div> <div id="send,AsyncSocket,string"> <dt><pre data-language="nim">proc send(socket: AsyncSocket; data: string; flags = {SafeDisconn}): owned(
    Future[void]) {....stackTrace: false, raises: [Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> Sends <code><span class="Identifier">data</span></code> to <code><span class="Identifier">socket</span></code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L458" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L458" target="_blank">Edit</a> </dd> </div> </div> <div id="sendTo-procs-all"> <div id="sendTo,AsyncSocket,string,Port,string"> <dt><pre data-language="nim">proc sendTo(socket: AsyncSocket; address: string; port: Port; data: string;
            flags = {SafeDisconn}): owned(Future[void]) {....stackTrace: false,
    raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>This proc sends <code><span class="Identifier">data</span></code> to the specified <code><span class="Identifier">address</span></code>, which may be an IP address or a hostname. If a hostname is specified this function will try each IP of that hostname. The returned future will complete once all data has been sent.</p> <p>If an error occurs an OSError exception will be raised.</p> <p>This proc is normally used with connectionless sockets (UDP sockets).</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L834" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L834" target="_blank">Edit</a> </dd> </div> </div> <div id="setSockOpt-procs-all"> <div id="setSockOpt,AsyncSocket,SOBool,bool"> <dt><pre data-language="nim">proc setSockOpt(socket: AsyncSocket; opt: SOBool; value: bool;
                level = SOL_SOCKET) {....tags: [WriteIOEffect], raises: [OSError],
                                      forbids: [].}</pre></dt> <dd> Sets option <code><span class="Identifier">opt</span></code> to a boolean value specified by <code><span class="Identifier">value</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L814" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L814" target="_blank">Edit</a> </dd> </div> </div> <div id="sslHandle-procs-all"> <div id="sslHandle,AsyncSocket"> <dt><pre data-language="nim">proc sslHandle(self: AsyncSocket): SslPtr {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Retrieve the ssl pointer of <code><span class="Identifier">socket</span></code>. Useful for interfacing with <code><span class="Identifier">openssl</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L749" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L749" target="_blank">Edit</a> </dd> </div> </div> <div id="wrapConnectedSocket-procs-all"> <div id="wrapConnectedSocket,SslContext,AsyncSocket,SslHandshakeType,string"> <dt><pre data-language="nim">proc wrapConnectedSocket(ctx: SslContext; socket: AsyncSocket;
                         handshake: SslHandshakeType; hostname: string = "") {.
    ...raises: [SslError], tags: [], forbids: [].}</pre></dt> <dd> <p>Wraps a connected socket in an SSL context. This function effectively turns <code><span class="Identifier">socket</span></code> into an SSL socket. <code><span class="Identifier">hostname</span></code> should be specified so that the client knows which hostname the server certificate should be validated against.</p> <p>This should be called on a connected socket, and will perform an SSL handshake immediately.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L772" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L772" target="_blank">Edit</a> </dd> </div> </div> <div id="wrapSocket-procs-all"> <div id="wrapSocket,SslContext,AsyncSocket"> <dt><pre data-language="nim">proc wrapSocket(ctx: SslContext; socket: AsyncSocket) {....raises: [SslError],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Wraps a socket in an SSL context. This function effectively turns <code><span class="Identifier">socket</span></code> into an SSL socket.</p> <p><strong>Disclaimer</strong>: This code is not well tested, may be very unsafe and prone to security vulnerabilities.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncnet.nim#L754" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncnet.nim#L754" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/asyncnet.html" class="_attribution-link">https://nim-lang.org/docs/asyncnet.html</a>
  </p>
</div>
