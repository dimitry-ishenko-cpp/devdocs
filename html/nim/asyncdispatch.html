<h1 class="title">asyncdispatch</h1>  
<p>This module implements asynchronous IO. This includes a dispatcher, a <code>Future</code> type implementation, and an <code>async</code> macro which allows asynchronous code to be written in a synchronous style with the <code>await</code> keyword.</p> <p>The dispatcher acts as a kind of event loop. You must call <code>poll</code> on it (or a function which does so for you such as <code>waitFor</code> or <code>runForever</code>) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</p> <p>The <code>poll</code> function will not, on its own, return any events. Instead an appropriate <code>Future</code> object will be completed. A <code>Future</code> is a type which holds a value which is not yet available, but which <em>may</em> be available in the future. You can check whether a future is finished by using the <code>finished</code> function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the <code>failed</code> function.</p> <p>Future objects can also store a callback procedure which will be called automatically once the future completes.</p> <p>Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the <code>recv</code> function will create a request for some data to be read from a socket. The future which the <code>recv</code> function returns will then complete once the requested amount of data is read <strong>or</strong> an exception occurs.</p> <p>Code to read some data from a socket may look something like this:</p> <pre class="listing" data-language="nim">var future = socket.recv(100)
future.addCallback(
  proc () =
    echo(future.read)
)</pre> <p>All asynchronous functions returning a <code>Future</code> will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</p> <p>In the above example, the <code>recv</code> function will return a brand new <code>Future</code> instance once the request for data to be read from the socket is made. This <code>Future</code> instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to <code>stdout</code>. The <code>read</code> function is used for this and it checks whether the future completes with an error for you (if it did it will simply raise the error), if there is no error however it returns the value of the future.</p> <h2 id="asynchronous-procedures">Asynchronous procedures</h2>
<p>Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.</p> <p>An asynchronous procedure is marked using the <code>{.async.}</code> pragma. When marking a procedure with the <code>{.async.}</code> pragma it must have a <code>Future[T]</code> return type or no return type at all. If you do not specify a return type then <code>Future[void]</code> is assumed.</p> <p>Inside asynchronous procedures <code>await</code> can be used to call any procedures which return a <code>Future</code>; this includes asynchronous procedures. When a procedure is "awaited", the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</p> <p>The <code>await</code> call may be used in many contexts. It can be used on the right hand side of a variable declaration: <code>var data = await socket.recv(100)</code>, in which case the variable will be set to the value of the future automatically. It can be used to await a <code>Future</code> object, and it can be used to await a procedure returning a <code>Future[void]</code>: <code>await socket.send("foobar")</code>.</p> <p>If an awaited future completes with an error, then <code>await</code> will re-raise this error. To avoid this, you can use the <code>yield</code> keyword instead of <code>await</code>. The following section shows different ways that you can handle exceptions in async procs.</p> <h3 id="asynchronous-procedures-handling-exceptions">Handling Exceptions</h3>
<p>The most reliable way to handle exceptions is to use <code>yield</code> on a future then check the future's <code>failed</code> property. For example:</p> <pre class="listing" data-language="nim">var future = sock.recv(100)
yield future
if future.failed:
  # Handle exception</pre> <p>The <code>async</code> procedures also offer limited support for the try statement.</p> <pre class="listing" data-language="nim">try:
  let data = await sock.recv(100)
  echo("Received ", data)
except:
  # Handle exception</pre> <p>Unfortunately the semantics of the try statement may not always be correct, and occasionally the compilation may fail altogether. As such it is better to use the former style when possible.</p> <h2 id="discarding-futures">Discarding futures</h2>
<p>Futures should <strong>never</strong> be discarded. This is because they may contain errors. If you do not care for the result of a Future then you should use the <code>asyncCheck</code> procedure instead of the <code>discard</code> keyword. Note however that this does not wait for completion, and you should use <code>waitFor</code> for that purpose.</p> <h2 id="examples">Examples</h2>
<p>For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the <a href="asyncnet.html">asyncnet module</a>.</p> <h2 id="investigating-pending-futures">Investigating pending futures</h2>
<p>It's possible to get into a situation where an async proc, or more accurately a <code>Future[T]</code> gets stuck and never completes. This can happen for various reasons and can cause serious memory leaks. When this occurs it's hard to identify the procedure that is stuck.</p> <p>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with <code>-d:futureLogging</code> and use the <code>getFuturesInProgress</code> procedure to get the list of pending futures together with the stack traces to the moment of their creation.</p> <p>You may also find it useful to use this <a href="https://github.com/dom96/prometheus">prometheus package</a> which will log the pending futures into prometheus, allowing you to analyse them via a nice graph.</p> <h2 id="limitationsslashbugs">Limitations/Bugs</h2>
<ul class="simple">
<li>The effect system (<code>raises: []</code>) does not work with async procedures.</li> </ul> <code>asyncdispatch</code> module depends on the <code>asyncmacro</code> module to work properly.  <h2 id="6">Imports</h2> <dl> <a href="os.html">os</a>, <a href="tables.html">tables</a>, <a href="strutils.html">strutils</a>, <a href="times.html">times</a>, <a href="heapqueue.html">heapqueue</a>, <a href="options.html">options</a>, <a href="asyncstreams.html">asyncstreams</a>, <a href="options.html">options</a>, <a href="math.html">math</a>, <a href="monotimes.html">monotimes</a>, <a href="asyncfutures.html">asyncfutures</a>, <a href="nativesockets.html">nativesockets</a>, <a href="net.html">net</a>, <a href="deques.html">deques</a>, <a href="winlean.html">winlean</a>, <a href="sets.html">sets</a>, <a href="hashes.html">hashes</a>, <a href="macros.html">macros</a>, <a href="strutils.html">strutils</a>, <a href="asyncfutures.html">asyncfutures</a>, <a href="posix.html">posix</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="CompletionData" data-language="nim">CompletionData = object
  fd*: AsyncFD
  cb*: owned(proc (fd: AsyncFD; bytesTransferred: DWORD; errcode: OSErrorCode) {...}{.
      closure, gcsafe.})
  cell*: ForeignCell</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L246" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L246" target="_blank">Edit</a> </dd>  <dt><pre id="PDispatcher" data-language="nim">PDispatcher = ref object of PDispatcherBase
  ioPort: Handle
  handles*: HashSet[AsyncFD]</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L254" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L254" target="_blank">Edit</a> </dd>  <dt><pre id="CustomRef">CustomRef = ref CustomObj</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L261" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L261" target="_blank">Edit</a> </dd>  <dt><pre id="AsyncFD">AsyncFD = distinct int</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L263" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L263" target="_blank">Edit</a> </dd>  <dt><pre id="AsyncEvent">AsyncEvent = ptr AsyncEventImpl</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L276" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L276" target="_blank">Edit</a> </dd>  <dt><pre id="Callback" data-language="nim">Callback = proc (fd: AsyncFD): bool {...}{.closure, gcsafe.}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L278" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L278" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="%3D%3D%2CAsyncFD%2CAsyncFD" data-language="nim">proc `==`(x: AsyncFD; y: AsyncFD): bool {...}{.borrow.}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L281" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L281" target="_blank">Edit</a> </dd>  <dt><pre id="newDispatcher" data-language="nim">proc newDispatcher(): owned PDispatcher {...}{.raises: [], tags: [].}</pre></dt> <dd> Creates a new Dispatcher instance. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L283" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L283" target="_blank">Edit</a> </dd>  <dt><pre id="setGlobalDispatcher%2CsinkPDispatcher" data-language="nim">proc setGlobalDispatcher(disp: sink PDispatcher) {...}{.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L293" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L293" target="_blank">Edit</a> </dd>  <dt><pre id="getGlobalDispatcher" data-language="nim">proc getGlobalDispatcher(): PDispatcher {...}{.raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L299" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L299" target="_blank">Edit</a> </dd>  <dt><pre id="getIoHandler%2CPDispatcher" data-language="nim">proc getIoHandler(disp: PDispatcher): Handle {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the underlying IO Completion Port handle (Windows) or selector (Unix) for the specified dispatcher. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L304" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L304" target="_blank">Edit</a> </dd>  <dt><pre id="register%2CAsyncFD" data-language="nim">proc register(fd: AsyncFD) {...}{.raises: [Exception, OSError], tags: [RootEffect].}</pre></dt> <dd> Registers <code>fd</code> with the dispatcher. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L309" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L309" target="_blank">Edit</a> </dd>  <dt><pre id="hasPendingOperations" data-language="nim">proc hasPendingOperations(): bool {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Returns <code>true</code> if the global dispatcher has pending operations. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L327" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L327" target="_blank">Edit</a> </dd>  <dt><pre id="newCustom" data-language="nim">proc newCustom(): CustomRef {...}{.raises: [], tags: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L424" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L424" target="_blank">Edit</a> </dd>  <dt><pre id="recv%2CAsyncFD%2Cint" data-language="nim">proc recv(socket: AsyncFD; size: int; flags = {SafeDisconn}): owned(
    Future[string]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code>size</code> bytes from <code>socket</code>. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of <code>""</code>.</p> <p><strong>Warning</strong>: The <code>Peek</code> socket flag is not supported on Windows.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L431" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L431" target="_blank">Edit</a> </dd>  <dt><pre id="recvInto%2CAsyncFD%2Cpointer%2Cint" data-language="nim">proc recvInto(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[int]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Reads <strong>up to</strong> <code>size</code> bytes from <code>socket</code> into <code>buf</code>, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of <code>0</code>.</p> <p><strong>Warning</strong>: The <code>Peek</code> socket flag is not supported on Windows.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L504" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L504" target="_blank">Edit</a> </dd>  <dt><pre id="send%2CAsyncFD%2Cpointer%2Cint" data-language="nim">proc send(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[void]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> <p>Sends <code>size</code> bytes from <code>buf</code> to <code>socket</code>. The returned future will complete once all data has been sent.</p> <p><strong>WARNING</strong>: Use it with caution. If <code>buf</code> refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L570" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L570" target="_blank">Edit</a> </dd>  <dt><pre id="sendTo%2CAsyncFD%2Cpointer%2Cint%2Cptr.SockAddr%2CSockLen" data-language="nim">proc sendTo(socket: AsyncFD; data: pointer; size: int; saddr: ptr SockAddr;
            saddrLen: SockLen; flags = {SafeDisconn}): owned(Future[void]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> Sends <code>data</code> to specified destination <code>saddr</code>, using socket <code>socket</code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L615" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L615" target="_blank">Edit</a> </dd>  <dt><pre id="recvFromInto%2CAsyncFD%2Cpointer%2Cint%2Cptr.SockAddr%2Cptr.SockLen" data-language="nim">proc recvFromInto(socket: AsyncFD; data: pointer; size: int;
                  saddr: ptr SockAddr; saddrLen: ptr SockLen;
                  flags = {SafeDisconn}): owned(Future[int]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> Receives a datagram data from <code>socket</code> into <code>buf</code>, which must be at least of size <code>size</code>, address of datagram's sender will be stored into <code>saddr</code> and <code>saddrLen</code>. Returned future will complete once one datagram has been received, and will return size of packet received. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L660" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L660" target="_blank">Edit</a> </dd>  <dt><pre id="acceptAddr%2CAsyncFD" data-language="nim">proc acceptAddr(socket: AsyncFD; flags = {SafeDisconn};
                inheritable = defined(nimInheritHandles)): owned(
    Future[tuple[address: string, client: AsyncFD]]) {...}{.
    raises: [Exception, ValueError, OSError, ValueError, Exception],
    tags: [RootEffect].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</p> <p>The resulting client socket is automatically registered to the dispatcher.</p> <p>If <code>inheritable</code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The <code>accept</code> call may result in an error if the connecting socket disconnects during the duration of the <code>accept</code>. If the <code>SafeDisconn</code> flag is specified then this error will not be raised and instead accept will be called again.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L708" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L708" target="_blank">Edit</a> </dd>  <dt><pre id="setInheritable%2CAsyncFD%2Cbool" data-language="nim">proc setInheritable(fd: AsyncFD; inheritable: bool): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Control whether a file handle can be inherited by child processes. Returns <code>true</code> on success.</p> <p>This procedure is not guaranteed to be available for all platforms. Test for availability with <a href="#declared">declared()</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L805" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L805" target="_blank">Edit</a> </dd>  <dt><pre id="closeSocket%2CAsyncFD" data-language="nim">proc closeSocket(socket: AsyncFD) {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Closes a socket and ensures that it is unregistered. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L807" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L807" target="_blank">Edit</a> </dd>  <dt><pre id="unregister%2CAsyncFD" data-language="nim">proc unregister(fd: AsyncFD) {...}{.raises: [Exception], tags: [RootEffect].}</pre></dt> <dd> Unregisters <code>fd</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L812" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L812" target="_blank">Edit</a> </dd>  <dt><pre id="contains%2CPDispatcher%2CAsyncFD" data-language="nim">proc contains(disp: PDispatcher; fd: AsyncFD): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L816" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L816" target="_blank">Edit</a> </dd>  <dt><pre id="addRead%2CAsyncFD%2CCallback" data-language="nim">proc addRead(fd: AsyncFD; cb: Callback) {...}{.raises: [Exception, OSError],
    tags: [RootEffect].}</pre></dt> <dd> <p>Start watching the file descriptor for read availability and then call the callback <code>cb</code>.</p> <p>This is not <code>pure</code> mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use <code>addRead</code> only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</p> <p>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</p> <p>Be sure your callback <code>cb</code> returns <code>true</code>, if you want to remove watch of <code>read</code> notifications, and <code>false</code>, if you want to continue receiving notifications.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L911" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L911" target="_blank">Edit</a> </dd>  <dt><pre id="addWrite%2CAsyncFD%2CCallback" data-language="nim">proc addWrite(fd: AsyncFD; cb: Callback) {...}{.raises: [Exception, OSError],
    tags: [RootEffect].}</pre></dt> <dd> <p>Start watching the file descriptor for write availability and then call the callback <code>cb</code>.</p> <p>This is not <code>pure</code> mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use <code>addWrite</code> only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</p> <p>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</p> <p>Be sure your callback <code>cb</code> returns <code>true</code>, if you want to remove watch of <code>write</code> notifications, and <code>false</code>, if you want to continue receiving notifications.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L929" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L929" target="_blank">Edit</a> </dd>  <dt><pre id="addTimer%2Cint%2Cbool%2CCallback" data-language="nim">proc addTimer(timeout: int; oneshot: bool; cb: Callback) {...}{.
    raises: [Exception, OSError], tags: [RootEffect].}</pre></dt> <dd> <p>Registers callback <code>cb</code> to be called when timer expired.</p> <p>Parameters:</p> <ul class="simple">
<li>
<code>timeout</code> - timeout value in milliseconds.</li> <li>
<code>oneshot</code><ul class="simple">
<li>
<code>true</code> - generate only one timeout event</li> <li>
<code>false</code> - generate timeout events periodically</li> </ul> </li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L982" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L982" target="_blank">Edit</a> </dd>  <dt><pre id="addProcess%2Cint%2CCallback" data-language="nim">proc addProcess(pid: int; cb: Callback) {...}{.raises: [Exception, OSError],
    tags: [RootEffect].}</pre></dt> <dd> Registers callback <code>cb</code> to be called when process with process ID <code>pid</code> exited. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1016" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1016" target="_blank">Edit</a> </dd>  <dt><pre id="newAsyncEvent" data-language="nim">proc newAsyncEvent(): AsyncEvent {...}{.raises: [OSError], tags: [].}</pre></dt> <dd> <p>Creates a new thread-safe <code>AsyncEvent</code> object.</p> <p>New <code>AsyncEvent</code> object is not automatically registered with dispatcher like <code>AsyncSocket</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1035" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1035" target="_blank">Edit</a> </dd>  <dt><pre id="trigger%2CAsyncEvent" data-language="nim">proc trigger(ev: AsyncEvent) {...}{.raises: [OSError], tags: [].}</pre></dt> <dd> Set event <code>ev</code> to signaled state. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1050" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1050" target="_blank">Edit</a> </dd>  <dt><pre id="unregister%2CAsyncEvent" data-language="nim">proc unregister(ev: AsyncEvent) {...}{.raises: [Exception, OSError],
                                  tags: [RootEffect].}</pre></dt> <dd> Unregisters event <code>ev</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1055" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1055" target="_blank">Edit</a> </dd>  <dt><pre id="close%2CAsyncEvent" data-language="nim">proc close(ev: AsyncEvent) {...}{.raises: [OSError], tags: [].}</pre></dt> <dd> Closes event <code>ev</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1066" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1066" target="_blank">Edit</a> </dd>  <dt><pre id="addEvent%2CAsyncEvent%2CCallback" data-language="nim">proc addEvent(ev: AsyncEvent; cb: Callback) {...}{.raises: [Exception, OSError],
    tags: [RootEffect].}</pre></dt> <dd> Registers callback <code>cb</code> to be called when <code>ev</code> will be signaled <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1073" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1073" target="_blank">Edit</a> </dd>  <dt><pre id="drain%2Cint" data-language="nim">proc drain(timeout = 500) {...}{.raises: [Exception, ValueError, OSError],
                            tags: [TimeEffect, RootEffect].}</pre></dt> <dd> Waits for completion of <strong>all</strong> events and processes them. Raises <code>ValueError</code> if there are no pending operations. In contrast to <code>poll</code> this processes as many events as are available until the timeout has elapsed. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1611" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1611" target="_blank">Edit</a> </dd>  <dt><pre id="poll%2Cint" data-language="nim">proc poll(timeout = 500) {...}{.raises: [Exception, ValueError, OSError],
                           tags: [RootEffect, TimeEffect].}</pre></dt> <dd> Waits for completion events and processes them. Raises <code>ValueError</code> if there are no pending operations. This runs the underlying OS <span id="epoll_1">epoll</span> or <span id="kqueue_1">kqueue</span> primitive only once. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1623" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1623" target="_blank">Edit</a> </dd>  <dt><pre id="createAsyncNativeSocket%2Ccint%2Ccint%2Ccint" data-language="nim">proc createAsyncNativeSocket(domain: cint; sockType: cint; protocol: cint;
                             inheritable = defined(nimInheritHandles)): AsyncFD {...}{.
    raises: [OSError, Exception], tags: [RootEffect].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1640" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1640" target="_blank">Edit</a> </dd>  <dt><pre id="createAsyncNativeSocket%2CDomain%2CSockType%2CProtocol" data-language="nim">proc createAsyncNativeSocket(domain: Domain = Domain.AF_INET;
                             sockType: SockType = SOCK_STREAM;
                             protocol: Protocol = IPPROTO_TCP;
                             inheritable = defined(nimInheritHandles)): AsyncFD {...}{.
    raises: [OSError, Exception], tags: [RootEffect].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1645" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1645" target="_blank">Edit</a> </dd>  <dt><pre id="dial%2Cstring%2CPort%2CProtocol" data-language="nim">proc dial(address: string; port: Port; protocol: Protocol = IPPROTO_TCP): owned(
    Future[AsyncFD]) {...}{.raises: [OSError, ValueError, Exception],
                       tags: [RootEffect].}</pre></dt> <dd> Establishes connection to the specified <code>address</code>:<code>port</code> pair via the specified protocol. The procedure iterates through possible resolutions of the <code>address</code> until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns the async file descriptor, registered in the dispatcher of the current thread, ready to send or receive data. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1803" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1803" target="_blank">Edit</a> </dd>  <dt><pre id="connect%2CAsyncFD%2Cstring%2CPort" data-language="nim">proc connect(socket: AsyncFD; address: string; port: Port;
             domain = Domain.AF_INET): owned(Future[void]) {...}{.
    raises: [OSError, IOError, ValueError, Exception], tags: [RootEffect].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1818" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1818" target="_blank">Edit</a> </dd>  <dt><pre id="sleepAsync" data-language="nim">proc sleepAsync(ms: int | float): owned(Future[void])</pre></dt> <dd> Suspends the execution of the current async procedure for the next <code>ms</code> milliseconds. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1833" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1833" target="_blank">Edit</a> </dd>  <dt><pre id="withTimeout%2CFuture%5BT%5D%2Cint" data-language="nim">proc withTimeout[T](fut: Future[T]; timeout: int): owned(Future[bool])</pre></dt> <dd> <p>Returns a future which will complete once <code>fut</code> completes or after <code>timeout</code> milliseconds has elapsed.</p> <p>If <code>fut</code> completes first the returned future will hold true, otherwise, if <code>timeout</code> milliseconds has elapsed first, the returned future will hold false.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1845" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1845" target="_blank">Edit</a> </dd>  <dt><pre id="accept%2CAsyncFD" data-language="nim">proc accept(socket: AsyncFD; flags = {SafeDisconn};
            inheritable = defined(nimInheritHandles)): owned(Future[AsyncFD]) {...}{.
    raises: [Exception, ValueError, OSError], tags: [RootEffect].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection.</p> <p>If <code>inheritable</code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The future will complete when the connection is successfully accepted.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1867" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1867" target="_blank">Edit</a> </dd>  <dt><pre id="send%2CAsyncFD%2Cstring" data-language="nim">proc send(socket: AsyncFD; data: string; flags = {SafeDisconn}): owned(
    Future[void]) {...}{.raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> Sends <code>data</code> to <code>socket</code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1891" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1891" target="_blank">Edit</a> </dd>  <dt><pre id="readAll%2CFutureStream%5Bstring%5D" data-language="nim">proc readAll(future: FutureStream[string]): owned(Future[string]) {...}{.
    raises: [Exception, ValueError], tags: [RootEffect].}</pre></dt> <dd> Returns a future that will complete when all the string data from the specified future stream is retrieved. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1913" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1913" target="_blank">Edit</a> </dd>  <dt><pre id="callSoon%2Cproc%29" data-language="nim">proc callSoon(cbproc: proc () {...}{.gcsafe.}) {...}{.gcsafe, raises: [Exception],
    tags: [RootEffect].}</pre></dt> <dd> Schedule <code>cbproc</code> to be called as soon as possible. The callback is called when control returns to the event loop. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1924" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1924" target="_blank">Edit</a> </dd>  <dt><pre id="runForever" data-language="nim">proc runForever() {...}{.raises: [Exception, ValueError, OSError],
                    tags: [RootEffect, TimeEffect].}</pre></dt> <dd> Begins a never ending global dispatcher poll loop. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1927" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1927" target="_blank">Edit</a> </dd>  <dt><pre id="waitFor%2CFuture%5BT%5D" data-language="nim">proc waitFor[T](fut: Future[T]): T</pre></dt> <dd> <strong>Blocks</strong> the current thread until the specified future completes. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1932" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1932" target="_blank">Edit</a> </dd>  <dt><pre id="activeDescriptors" data-language="nim">proc activeDescriptors(): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> Returns the current number of active file descriptors for the current event loop. This is a cheap operation that does not involve a system call. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1939" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1939" target="_blank">Edit</a> </dd>  <dt><pre id="maxDescriptors" data-language="nim">proc maxDescriptors(): int {...}{.raises: OSError, tags: [].}</pre></dt> <dd> Returns the maximum number of active file descriptors for the current process. This involves a system call. For now <code>maxDescriptors</code> is supported on the following OSes: Windows, Linux, OSX, BSD. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncdispatch.nim#L1951" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1951" target="_blank">Edit</a> </dd> </dl>  <h2 id="17">Macros</h2> <dl>  <dt><pre id="async.m%2Cuntyped" data-language="nim">macro async(prc: untyped): untyped</pre></dt> <dd> Macro which processes async procedures into the appropriate iterators and yield statements. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncmacro.nim#L289" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncmacro.nim#L289" target="_blank">Edit</a> </dd>  <dt><pre id="multisync.m%2Cuntyped" data-language="nim">macro multisync(prc: untyped): untyped</pre></dt> <dd> <p>Macro which processes async procedures into both asynchronous and synchronous procedures.</p> <p>The generated async procedures use the <code>async</code> macro, whereas the generated synchronous procedures simply strip off the <code>await</code> calls.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncmacro.nim#L348" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncmacro.nim#L348" target="_blank">Edit</a> </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre id="await.t%2Ctyped" data-language="nim">template await(f: typed): untyped {...}{.used.}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncmacro.nim#L138" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncmacro.nim#L138" target="_blank">Edit</a> </dd>  <dt><pre id="await.t%2CFuture%5BT%5D" data-language="nim">template await[T](f: Future[T]): auto {...}{.used.}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/asyncmacro.nim#L142" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncmacro.nim#L142" target="_blank">Edit</a> </dd> </dl>  <h2 id="19">Exports</h2> <dl> <a href="nativesockets.html#Port"><span class="Identifier">Port</span></a>, <a href="net.html#SocketFlag"><span class="Identifier">SocketFlag</span></a>, <a href="asyncfutures.html#and,Future%5BT%5D,Future%5BY%5D"><span class="Identifier">and</span></a>, <a href="asyncfutures.html#addCallback,Future%5BT%5D,proc(Future%5BT%5D)"><span class="Identifier">addCallback</span></a>, <a href="asyncfutures.html#asyncCheck,Future%5BT%5D"><span class="Identifier">asyncCheck</span></a>, <a href="asyncfutures.html#or,Future%5BT%5D,Future%5BY%5D"><span class="Identifier">or</span></a>, <a href="asyncfutures.html#read"><span class="Identifier">read</span></a>, <a href="asyncfutures.html#fail,Future%5BT%5D,ref.Exception"><span class="Identifier">fail</span></a>, <a href="asyncfutures.html#setCallSoonProc"><span class="Identifier">setCallSoonProc</span></a>, <a href="asyncfutures.html#addCallback,FutureBase,proc)"><span class="Identifier">addCallback</span></a>, <a href="asyncfutures.html#clean,FutureVar%5BT%5D"><span class="Identifier">clean</span></a>, <a href="asyncfutures.html#clearCallbacks,FutureBase"><span class="Identifier">clearCallbacks</span></a>, <a href="asyncfutures.html#newFutureVar,string"><span class="Identifier">newFutureVar</span></a>, <a href="asyncfutures.html#mget,FutureVar%5BT%5D"><span class="Identifier">mget</span></a>, <a href="asyncfutures.html#Future"><span class="Identifier">Future</span></a>, <a href="asyncfutures.html#failed,FutureBase"><span class="Identifier">failed</span></a>, <a href="asyncfutures.html#%24,seq%5BStackTraceEntry%5D"><span class="Identifier">$</span></a>, <a href="asyncfutures.html#callback=,FutureBase,proc)"><span class="Identifier">callback=</span></a>, <a href="asyncfutures.html#complete,FutureVar%5BT%5D,T"><span class="Identifier">complete</span></a>, <a href="asyncfutures.html#callback=,Future%5BT%5D,proc(Future%5BT%5D)"><span class="Identifier">callback=</span></a>, <a href="asyncfutures.html#NimAsyncContinueSuffix"><span class="Identifier">NimAsyncContinueSuffix</span></a>, <a href="asyncfutures.html#FutureBase"><span class="Identifier">FutureBase</span></a>, <a href="asyncfutures.html#all,varargs%5BFuture%5BT%5D%5D"><span class="Identifier">all</span></a>, <a href="asyncfutures.html#complete,FutureVar%5BT%5D"><span class="Identifier">complete</span></a>, <a href="asyncfutures.html#FutureError"><span class="Identifier">FutureError</span></a>, <a href="asyncfutures.html#getCallSoonProc"><span class="Identifier">getCallSoonProc</span></a>, <a href="asyncfutures.html#FutureVar"><span class="Identifier">FutureVar</span></a>, <a href="asyncfutures.html#isFutureLoggingEnabled"><span class="Identifier">isFutureLoggingEnabled</span></a>, <a href="asyncfutures.html#complete,Future%5Bvoid%5D"><span class="Identifier">complete</span></a>, <a href="asyncfutures.html#readError,Future%5BT%5D"><span class="Identifier">readError</span></a>, <a href="asyncfutures.html#complete,Future%5BT%5D,T"><span class="Identifier">complete</span></a>, <a href="asyncfutures.html#newFuture,string"><span class="Identifier">newFuture</span></a>, <a href="asyncfutures.html#finished"><span class="Identifier">finished</span></a>, <a href="asyncstreams.html#len,FutureStream%5BT%5D"><span class="Identifier">len</span></a>, <a href="asyncstreams.html#callback=,FutureStream%5BT%5D,proc(FutureStream%5BT%5D)"><span class="Identifier">callback=</span></a>, <a href="asyncstreams.html#fail,FutureStream%5BT%5D,ref.Exception"><span class="Identifier">fail</span></a>, <a href="asyncstreams.html#newFutureStream,string"><span class="Identifier">newFutureStream</span></a>, <a href="asyncstreams.html#finished,FutureStream%5BT%5D"><span class="Identifier">finished</span></a>, <a href="asyncstreams.html#write,FutureStream%5BT%5D,T"><span class="Identifier">write</span></a>, <a href="asyncstreams.html#complete,FutureStream%5BT%5D"><span class="Identifier">complete</span></a>, <a href="asyncstreams.html#FutureStream"><span class="Identifier">FutureStream</span></a>, <a href="asyncstreams.html#read,FutureStream%5BT%5D"><span class="Identifier">read</span></a>, <a href="asyncstreams.html#failed,FutureStream%5BT%5D"><span class="Identifier">failed</span></a> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/asyncdispatch.html" class="_attribution-link">https://nim-lang.org/docs/asyncdispatch.html</a>
  </p>
</div>
