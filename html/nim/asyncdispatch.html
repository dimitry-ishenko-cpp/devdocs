<h1 class="title">std/asyncdispatch</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1" target="_blank">Edit</a>  
<p>This module implements asynchronous IO. This includes a dispatcher, a <code><span class="Identifier">Future</span></code> type implementation, and an <code><span class="Identifier">async</span></code> macro which allows asynchronous code to be written in a synchronous style with the <code><span class="Identifier">await</span></code> keyword.</p> <p>The dispatcher acts as a kind of event loop. You must call <code><span class="Identifier">poll</span></code> on it (or a function which does so for you such as <code><span class="Identifier">waitFor</span></code> or <code><span class="Identifier">runForever</span></code>) in order to poll for any outstanding events. The underlying implementation is based on epoll on Linux, IO Completion Ports on Windows and select on other operating systems.</p> <p>The <code><span class="Identifier">poll</span></code> function will not, on its own, return any events. Instead an appropriate <code><span class="Identifier">Future</span></code> object will be completed. A <code><span class="Identifier">Future</span></code> is a type which holds a value which is not yet available, but which <em>may</em> be available in the future. You can check whether a future is finished by using the <code><span class="Identifier">finished</span></code> function. When a future is finished it means that either the value that it holds is now available or it holds an error instead. The latter situation occurs when the operation to complete a future fails with an exception. You can distinguish between the two situations with the <code><span class="Identifier">failed</span></code> function.</p> <p>Future objects can also store a callback procedure which will be called automatically once the future completes.</p> <p>Futures therefore can be thought of as an implementation of the proactor pattern. In this pattern you make a request for an action, and once that action is fulfilled a future is completed with the result of that action. Requests can be made by calling the appropriate functions. For example: calling the <code><span class="Identifier">recv</span></code> function will create a request for some data to be read from a socket. The future which the <code><span class="Identifier">recv</span></code> function returns will then complete once the requested amount of data is read <strong>or</strong> an exception occurs.</p> <p>Code to read some data from a socket may look something like this:</p> 
<pre class="listing" data-language="nim">var future = socket.recv(100)
future.addCallback(
  proc () =
    echo(future.read)
)</pre> <p>All asynchronous functions returning a <code><span class="Identifier">Future</span></code> will not block. They will not however return immediately. An asynchronous function will have code which will be executed before an asynchronous request is made, in most cases this code sets up the request.</p> <p>In the above example, the <code><span class="Identifier">recv</span></code> function will return a brand new <code><span class="Identifier">Future</span></code> instance once the request for data to be read from the socket is made. This <code><span class="Identifier">Future</span></code> instance will complete once the requested amount of data is read, in this case it is 100 bytes. The second line sets a callback on this future which will be called once the future completes. All the callback does is write the data stored in the future to <code><span class="Identifier">stdout</span></code>. The <code><span class="Identifier">read</span></code> function is used for this and it checks whether the future completes with an error for you (if it did, it will simply raise the error), if there is no error, however, it returns the value of the future.</p> <h2 id="asynchronous-procedures">Asynchronous procedures</h2>
<p>Asynchronous procedures remove the pain of working with callbacks. They do this by allowing you to write asynchronous code the same way as you would write synchronous code.</p> <p>An asynchronous procedure is marked using the <code><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">async</span><span class="Operator">.</span><span class="Punctuation">}</span></code> pragma. When marking a procedure with the <code><span class="Punctuation">{</span><span class="Operator">.</span><span class="Identifier">async</span><span class="Operator">.</span><span class="Punctuation">}</span></code> pragma it must have a <code><span class="Identifier">Future</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> return type or no return type at all. If you do not specify a return type then <code><span class="Identifier">Future</span><span class="Punctuation">[</span><span class="Identifier">void</span><span class="Punctuation">]</span></code> is assumed.</p> <p>Inside asynchronous procedures <code><span class="Identifier">await</span></code> can be used to call any procedures which return a <code><span class="Identifier">Future</span></code>; this includes asynchronous procedures. When a procedure is "awaited", the asynchronous procedure it is awaited in will suspend its execution until the awaited procedure's Future completes. At which point the asynchronous procedure will resume its execution. During the period when an asynchronous procedure is suspended other asynchronous procedures will be run by the dispatcher.</p> <p>The <code><span class="Identifier">await</span></code> call may be used in many contexts. It can be used on the right hand side of a variable declaration: <code><span class="Keyword">var</span> <span class="Identifier">data</span> <span class="Operator">=</span> <span class="Identifier">await</span> <span class="Identifier">socket</span><span class="Operator">.</span><span class="Identifier">recv</span><span class="Punctuation">(</span><span class="DecNumber">100</span><span class="Punctuation">)</span></code>, in which case the variable will be set to the value of the future automatically. It can be used to await a <code><span class="Identifier">Future</span></code> object, and it can be used to await a procedure returning a <code><span class="Identifier">Future</span><span class="Punctuation">[</span><span class="Identifier">void</span><span class="Punctuation">]</span></code>: <code><span class="Identifier">await</span> <span class="Identifier">socket</span><span class="Operator">.</span><span class="Identifier">send</span><span class="Punctuation">(</span><span class="StringLit">"foobar"</span><span class="Punctuation">)</span></code>.</p> <p>If an awaited future completes with an error, then <code><span class="Identifier">await</span></code> will re-raise this error. To avoid this, you can use the <code><span class="Keyword">yield</span></code> keyword instead of <code><span class="Identifier">await</span></code>. The following section shows different ways that you can handle exceptions in async procs.</p> <div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Caution:</b></span> Procedures marked {.async.} do not support mutable parameters such as <code><span class="Keyword">var</span> <span class="Identifier">int</span></code>. References such as <code><span class="Keyword">ref</span> <span class="Identifier">int</span></code> should be used instead.</div> <h3 id="asynchronous-procedures-handling-exceptions">Handling Exceptions</h3>
<p>You can handle exceptions in the same way as in ordinary Nim code; by using the try statement:</p> 
<pre class="listing" data-language="nim">try:
  let data = await sock.recv(100)
  echo("Received ", data)
except:
  # Handle exception</pre> <p>An alternative approach to handling exceptions is to use <code><span class="Keyword">yield</span></code> on a future then check the future's <code><span class="Identifier">failed</span></code> property. For example:</p> 
<pre class="listing" data-language="nim">var future = sock.recv(100)
yield future
if future.failed:
  # Handle exception</pre> <h2 id="discarding-futures">Discarding futures</h2>
<p>Futures should <strong>never</strong> be discarded directly because they may contain errors. If you do not care for the result of a Future then you should use the <code><span class="Identifier">asyncCheck</span></code> procedure instead of the <code><span class="Keyword">discard</span></code> keyword. Note that this does not wait for completion, and you should use <code><span class="Identifier">waitFor</span></code> or <code><span class="Identifier">await</span></code> for that purpose.</p> <div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> <code><span class="Identifier">await</span></code> also checks if the future fails, so you can safely discard its result.</div> <h2 id="handling-futures">Handling futures</h2>
<p>There are many different operations that apply to a future. The three primary high-level operations are <code><span class="Identifier">asyncCheck</span></code>, <code><span class="Identifier">waitFor</span></code>, and <code><span class="Identifier">await</span></code>.</p> <ul class="simple">
<li>
<code><span class="Identifier">asyncCheck</span></code>: Raises an exception if the future fails. It neither waits for the future to finish nor returns the result of the future.</li> <li>
<code><span class="Identifier">waitFor</span></code>: Polls the event loop and blocks the current thread until the future finishes. This is often used to call an async procedure from a synchronous context and should never be used in an <code><span class="Identifier">async</span></code> proc.</li> <li>
<code><span class="Identifier">await</span></code>: Pauses execution in the current async procedure until the future finishes. While the current procedure is paused, other async procedures will continue running. Should be used instead of <code><span class="Identifier">waitFor</span></code> in an async procedure.</li> </ul> <p>Here is a handy quick reference chart showing their high-level differences:</p> <table>
<tr>
<th>Procedure</th>
<th>Context</th>
<th>Blocking</th>
</tr> <tr>
<td><code><span class="Identifier">asyncCheck</span></code></td>
<td>non-async and async</td>
<td>non-blocking</td>
</tr> <tr>
<td><code><span class="Identifier">waitFor</span></code></td>
<td>non-async</td>
<td>blocks current thread</td>
</tr> <tr>
<td><code><span class="Identifier">await</span></code></td>
<td>async</td>
<td>suspends current proc</td>
</tr> </table> <h2 id="examples">Examples</h2>
<p>For examples take a look at the documentation for the modules implementing asynchronous IO. A good place to start is the <a href="asyncnet.html">asyncnet module</a>.</p> <h2 id="investigating-pending-futures">Investigating pending futures</h2>
<p>It's possible to get into a situation where an async proc, or more accurately a <code><span class="Identifier">Future</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> gets stuck and never completes. This can happen for various reasons and can cause serious memory leaks. When this occurs it's hard to identify the procedure that is stuck.</p> <p>Thankfully there is a mechanism which tracks the count of each pending future. All you need to do to enable it is compile with <code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">futureLogging</span></code> and use the <code><span class="Identifier">getFuturesInProgress</span></code> procedure to get the list of pending futures together with the stack traces to the moment of their creation.</p> <p>You may also find it useful to use this <a href="https://github.com/dom96/prometheus">prometheus package</a> which will log the pending futures into prometheus, allowing you to analyse them via a nice graph.</p> <h2 id="limitationsslashbugs">Limitations/Bugs</h2>
<ul class="simple">
<li>The effect system (<code><span class="Identifier">raises</span><span class="Punctuation">:</span> <span class="Punctuation">[</span><span class="Punctuation">]</span></code>) does not work with async procedures.</li> <li>Mutable parameters are not supported by async procedures.</li> </ul> <h2 id="multiple-async-backend-support">Multiple async backend support</h2>
<p>Thanks to its powerful macro support, Nim allows <code>async</code>/<code>await</code> to be implemented in libraries with only minimal support from the language - as such, multiple <code>async</code> libraries exist, including <code>asyncdispatch</code> and <code>chronos</code>, and more may come to be developed in the future.</p> <p>Libraries built on top of async/await may wish to support multiple async backends - the best way to do so is to create separate modules for each backend that may be imported side-by-side.</p> <p>An alternative way is to select backend using a global compile flag - this method makes it difficult to compose applications that use both backends as may happen with transitive dependencies, but may be appropriate in some cases - libraries choosing this path should call the flag <code><span class="Identifier">asyncBackend</span></code>, allowing applications to choose the backend with <code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">asyncBackend</span><span class="Operator">=&lt;</span><span class="Identifier">backend_name</span><span class="Operator">&gt;</span></code>.</p> <p>Known <code><span class="Identifier">async</span></code> backends include:</p> <ul class="simple">
<li>
<code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">asyncBackend</span><span class="Operator">=</span><span class="Identifier">none</span></code>: disable <code><span class="Identifier">async</span></code> support completely</li> <li>
<code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">asyncBackend</span><span class="Operator">=</span><span class="Identifier">asyncdispatch</span></code>: <a href="asyncdispatch.html">https://nim-lang.org/docs/asyncdispatch.html</a>
</li> <li>
<code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">asyncBackend</span><span class="Operator">=</span><span class="Identifier">chronos</span></code>: <a href="https://github.com/status-im/nim-chronos/">https://github.com/status-im/nim-chronos/</a>
</li> </ul> <p><code>none</code> can be used when a library supports both a synchronous and asynchronous API, to disable the latter.</p>  <h2 id="6">Imports</h2> <dl> <a href="os.html">os</a>, <a href="tables.html">tables</a>, <a href="strutils.html">strutils</a>, <a href="times.html">times</a>, <a href="heapqueue.html">heapqueue</a>, <a href="options.html">options</a>, <a href="asyncstreams.html">asyncstreams</a>, <a href="math.html">math</a>, <a href="monotimes.html">monotimes</a>, <a href="asyncfutures.html">asyncfutures</a>, <a href="nativesockets.html">nativesockets</a>, <a href="net.html">net</a>, <a href="deques.html">deques</a>, <a href="winlean.html">winlean</a>, <a href="sets.html">sets</a>, <a href="hashes.html">hashes</a>, <a href="asyncmacro.html">asyncmacro</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="AsyncEvent"> <dt><pre>AsyncEvent = ptr AsyncEventImpl</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L339" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L339" target="_blank">Edit</a> </dd> </div> <div id="AsyncFD"> <dt><pre>AsyncFD = distinct int</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L326" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L326" target="_blank">Edit</a> </dd> </div> <div id="Callback"> <dt><pre data-language="nim">Callback = proc (fd: AsyncFD): bool {.closure, ...gcsafe.}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L341" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L341" target="_blank">Edit</a> </dd> </div> <div id="CompletionData"> <dt><pre data-language="nim">CompletionData = object
  fd*: AsyncFD
  cb*: owned(proc (fd: AsyncFD; bytesTransferred: DWORD; errcode: OSErrorCode) {.
      closure, ...gcsafe.})
  cell*: ForeignCell</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L309" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L309" target="_blank">Edit</a> </dd> </div> <div id="CustomRef"> <dt><pre>CustomRef = ref CustomObj</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L324" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L324" target="_blank">Edit</a> </dd> </div> <div id="PDispatcher"> <dt><pre data-language="nim">PDispatcher = ref object of PDispatcherBase
  handles*: HashSet[AsyncFD]</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L317" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L317" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="==-procs-all"> <div id="==,AsyncFD,AsyncFD"> <dt><pre data-language="nim">proc `==`(x: AsyncFD; y: AsyncFD): bool {.borrow, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L344" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L344" target="_blank">Edit</a> </dd> </div> </div> <div id="accept-procs-all"> <div id="accept,AsyncFD"> <dt><pre data-language="nim">proc accept(socket: AsyncFD; flags = {SafeDisconn};
            inheritable = defined(nimInheritHandles)): owned(Future[AsyncFD]) {.
    ...raises: [ValueError, OSError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The future will complete when the connection is successfully accepted.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1953" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1953" target="_blank">Edit</a> </dd> </div> </div> <div id="acceptAddr-procs-all"> <div id="acceptAddr,AsyncFD"> <dt><pre data-language="nim">proc acceptAddr(socket: AsyncFD; flags = {SafeDisconn};
                inheritable = defined(nimInheritHandles)): owned(
    Future[tuple[address: string, client: AsyncFD]]) {....gcsafe,
    raises: [ValueError, OSError, Exception, ValueError, Exception],
    tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Accepts a new connection. Returns a future containing the client socket corresponding to that connection and the remote address of the client. The future will complete when the connection is successfully accepted.</p> <p>The resulting client socket is automatically registered to the dispatcher.</p> <p>If <code><span class="Identifier">inheritable</span></code> is false (the default), the resulting client socket will not be inheritable by child processes.</p> <p>The <code><span class="Identifier">accept</span></code> call may result in an error if the connecting socket disconnects during the duration of the <code><span class="Identifier">accept</span></code>. If the <code><span class="Identifier">SafeDisconn</span></code> flag is specified then this error will not be raised and instead accept will be called again.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L771" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L771" target="_blank">Edit</a> </dd> </div> </div> <div id="activeDescriptors-procs-all"> <div id="activeDescriptors"> <dt><pre data-language="nim">proc activeDescriptors(): int {.inline, ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns the current number of active file descriptors for the current event loop. This is a cheap operation that does not involve a system call. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L2026" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L2026" target="_blank">Edit</a> </dd> </div> </div> <div id="addEvent-procs-all"> <div id="addEvent,AsyncEvent,Callback"> <dt><pre data-language="nim">proc addEvent(ev: AsyncEvent; cb: Callback) {....raises: [OSError], tags: [],
    forbids: [].}</pre></dt> <dd> Registers callback <code><span class="Identifier">cb</span></code> to be called when <code><span class="Identifier">ev</span></code> will be signaled <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1136" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1136" target="_blank">Edit</a> </dd> </div> </div> <div id="addProcess-procs-all"> <div id="addProcess,int,Callback"> <dt><pre data-language="nim">proc addProcess(pid: int; cb: Callback) {....raises: [OSError], tags: [],
    forbids: [].}</pre></dt> <dd> Registers callback <code><span class="Identifier">cb</span></code> to be called when process with process ID <code><span class="Identifier">pid</span></code> exited. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1079" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1079" target="_blank">Edit</a> </dd> </div> </div> <div id="addRead-procs-all"> <div id="addRead,AsyncFD,Callback"> <dt><pre data-language="nim">proc addRead(fd: AsyncFD; cb: Callback) {....raises: [OSError], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Start watching the file descriptor for read availability and then call the callback <code><span class="Identifier">cb</span></code>.</p> <p>This is not <code><span class="Identifier">pure</span></code> mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use <code><span class="Identifier">addRead</span></code> only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</p> <p>If you use this function, you don't need to use asyncdispatch.recv() or asyncdispatch.accept(), because they are using IOCP, please use nativesockets.recv() and nativesockets.accept() instead.</p> <p>Be sure your callback <code><span class="Identifier">cb</span></code> returns <code><span class="Identifier">true</span></code>, if you want to remove watch of <code><span class="Identifier">read</span></code> notifications, and <code><span class="Identifier">false</span></code>, if you want to continue receiving notifications.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L974" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L974" target="_blank">Edit</a> </dd> </div> </div> <div id="addTimer-procs-all"> <div id="addTimer,int,bool,Callback"> <dt><pre data-language="nim">proc addTimer(timeout: int; oneshot: bool; cb: Callback) {....raises: [OSError],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Registers callback <code><span class="Identifier">cb</span></code> to be called when timer expired.</p> <p>Parameters:</p> <ul class="simple">
<li>
<code><span class="Identifier">timeout</span></code> - timeout value in milliseconds.</li> <li>
<code><span class="Identifier">oneshot</span></code><ul class="simple">
<li>
<code><span class="Identifier">true</span></code> - generate only one timeout event</li> <li>
<code><span class="Identifier">false</span></code> - generate timeout events periodically</li> </ul> </li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1045" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1045" target="_blank">Edit</a> </dd> </div> </div> <div id="addWrite-procs-all"> <div id="addWrite,AsyncFD,Callback"> <dt><pre data-language="nim">proc addWrite(fd: AsyncFD; cb: Callback) {....raises: [OSError], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Start watching the file descriptor for write availability and then call the callback <code><span class="Identifier">cb</span></code>.</p> <p>This is not <code><span class="Identifier">pure</span></code> mechanism for Windows Completion Ports (IOCP), so if you can avoid it, please do it. Use <code><span class="Identifier">addWrite</span></code> only if really need it (main usecase is adaptation of unix-like libraries to be asynchronous on Windows).</p> <p>If you use this function, you don't need to use asyncdispatch.send() or asyncdispatch.connect(), because they are using IOCP, please use nativesockets.send() and nativesockets.connect() instead.</p> <p>Be sure your callback <code><span class="Identifier">cb</span></code> returns <code><span class="Identifier">true</span></code>, if you want to remove watch of <code><span class="Identifier">write</span></code> notifications, and <code><span class="Identifier">false</span></code>, if you want to continue receiving notifications.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L992" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L992" target="_blank">Edit</a> </dd> </div> </div> <div id="callSoon-procs-all"> <div id="callSoon,proc)"> <dt><pre data-language="nim">proc callSoon(cbproc: proc () {....gcsafe.}) {....gcsafe, raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> Schedule <code><span class="Identifier">cbproc</span></code> to be called as soon as possible. The callback is called when control returns to the event loop. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L286" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L286" target="_blank">Edit</a> </dd> </div> </div> <div id="close-procs-all"> <div id="close,AsyncEvent"> <dt><pre data-language="nim">proc close(ev: AsyncEvent) {....raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> Closes event <code><span class="Identifier">ev</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1129" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1129" target="_blank">Edit</a> </dd> </div> </div> <div id="closeSocket-procs-all"> <div id="closeSocket,AsyncFD"> <dt><pre data-language="nim">proc closeSocket(socket: AsyncFD) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Closes a socket and ensures that it is unregistered. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L870" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L870" target="_blank">Edit</a> </dd> </div> </div> <div id="connect-procs-all"> <div id="connect,AsyncFD,string,Port"> <dt><pre data-language="nim">proc connect(socket: AsyncFD; address: string; port: Port;
             domain = Domain.AF_INET): owned(Future[void]) {.
    ...raises: [ValueError, OSError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1904" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1904" target="_blank">Edit</a> </dd> </div> </div> <div id="contains-procs-all"> <div id="contains,PDispatcher,AsyncFD"> <dt><pre data-language="nim">proc contains(disp: PDispatcher; fd: AsyncFD): bool {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L879" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L879" target="_blank">Edit</a> </dd> </div> </div> <div id="createAsyncNativeSocket-procs-all"> <div id="createAsyncNativeSocket,cint,cint,cint"> <dt><pre data-language="nim">proc createAsyncNativeSocket(domain: cint; sockType: cint; protocol: cint;
                             inheritable = defined(nimInheritHandles)): AsyncFD {.
    ...raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1724" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1724" target="_blank">Edit</a> </dd> </div> <div id="createAsyncNativeSocket,Domain,SockType,Protocol"> <dt><pre data-language="nim">proc createAsyncNativeSocket(domain: Domain = Domain.AF_INET;
                             sockType: SockType = SOCK_STREAM;
                             protocol: Protocol = IPPROTO_TCP;
                             inheritable = defined(nimInheritHandles)): AsyncFD {.
    ...raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1729" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1729" target="_blank">Edit</a> </dd> </div> </div> <div id="dial-procs-all"> <div id="dial,string,Port,Protocol"> <dt><pre data-language="nim">proc dial(address: string; port: Port; protocol: Protocol = IPPROTO_TCP): owned(
    Future[AsyncFD]) {....raises: [OSError, ValueError, Exception],
                       tags: [RootEffect], forbids: [].}</pre></dt> <dd> Establishes connection to the specified <code><span class="Identifier">address</span></code>:<code><span class="Identifier">port</span></code> pair via the specified protocol. The procedure iterates through possible resolutions of the <code><span class="Identifier">address</span></code> until it succeeds, meaning that it seamlessly works with both IPv4 and IPv6. Returns the async file descriptor, registered in the dispatcher of the current thread, ready to send or receive data. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1889" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1889" target="_blank">Edit</a> </dd> </div> </div> <div id="drain-procs-all"> <div id="drain,int"> <dt><pre data-language="nim">proc drain(timeout = 500) {....raises: [ValueError, Exception, OSError],
                            tags: [TimeEffect, RootEffect], forbids: [].}</pre></dt> <dd> Waits for completion of <strong>all</strong> events and processes them. Raises <code><span class="Identifier">ValueError</span></code> if there are no pending operations. In contrast to <code><span class="Identifier">poll</span></code> this processes as many events as are available until the timeout has elapsed. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1695" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1695" target="_blank">Edit</a> </dd> </div> </div> <div id="getGlobalDispatcher-procs-all"> <div id="getGlobalDispatcher"> <dt><pre data-language="nim">proc getGlobalDispatcher(): PDispatcher {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L362" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L362" target="_blank">Edit</a> </dd> </div> </div> <div id="getIoHandler-procs-all"> <div id="getIoHandler,PDispatcher"> <dt><pre data-language="nim">proc getIoHandler(disp: PDispatcher): Handle {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns the underlying IO Completion Port handle (Windows) or selector (Unix) for the specified dispatcher. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L367" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L367" target="_blank">Edit</a> </dd> </div> </div> <div id="hasPendingOperations-procs-all"> <div id="hasPendingOperations"> <dt><pre data-language="nim">proc hasPendingOperations(): bool {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Returns <code><span class="Identifier">true</span></code> if the global dispatcher has pending operations. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L390" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L390" target="_blank">Edit</a> </dd> </div> </div> <div id="maxDescriptors-procs-all"> <div id="maxDescriptors"> <dt><pre data-language="nim">proc maxDescriptors(): int {....raises: OSError, tags: [], forbids: [].}</pre></dt> <dd> Returns the maximum number of active file descriptors for the current process. This involves a system call. For now <code><span class="Identifier">maxDescriptors</span></code> is supported on the following OSes: Windows, Linux, OSX, BSD, Solaris. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L2039" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L2039" target="_blank">Edit</a> </dd> </div> </div> <div id="newAsyncEvent-procs-all"> <div id="newAsyncEvent"> <dt><pre data-language="nim">proc newAsyncEvent(): AsyncEvent {....raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new thread-safe <code><span class="Identifier">AsyncEvent</span></code> object.</p> <p>New <code><span class="Identifier">AsyncEvent</span></code> object is not automatically registered with dispatcher like <code><span class="Identifier">AsyncSocket</span></code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1098" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1098" target="_blank">Edit</a> </dd> </div> </div> <div id="newCustom-procs-all"> <div id="newCustom"> <dt><pre data-language="nim">proc newCustom(): CustomRef {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L487" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L487" target="_blank">Edit</a> </dd> </div> </div> <div id="newDispatcher-procs-all"> <div id="newDispatcher"> <dt><pre data-language="nim">proc newDispatcher(): owned PDispatcher {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Creates a new Dispatcher instance. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L346" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L346" target="_blank">Edit</a> </dd> </div> </div> <div id="poll-procs-all"> <div id="poll,int"> <dt><pre data-language="nim">proc poll(timeout = 500) {....raises: [ValueError, Exception, OSError],
                           tags: [TimeEffect, RootEffect], forbids: [].}</pre></dt> <dd> Waits for completion events and processes them. Raises <code><span class="Identifier">ValueError</span></code> if there are no pending operations. This runs the underlying OS <span id="epoll_1">epoll</span> or <span id="kqueue_1">kqueue</span> primitive only once. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1707" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1707" target="_blank">Edit</a> </dd> </div> </div> <div id="readAll-procs-all"> <div id="readAll,FutureStream[string]"> <dt><pre data-language="nim">proc readAll(future: FutureStream[string]): owned(Future[string]) {.
    ...stackTrace: false, raises: [Exception, ValueError], tags: [RootEffect],
    forbids: [].}</pre></dt> <dd> Returns a future that will complete when all the string data from the specified future stream is retrieved. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L2000" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L2000" target="_blank">Edit</a> </dd> </div> </div> <div id="recv-procs-all"> <div id="recv,AsyncFD,int"> <dt><pre data-language="nim">proc recv(socket: AsyncFD; size: int; flags = {SafeDisconn}): owned(
    Future[string]) {....raises: [ValueError, Exception], tags: [RootEffect],
                      forbids: [].}</pre></dt> <dd> Reads <strong>up to</strong> <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">socket</span></code>. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of <code><span class="StringLit">""</span></code>.<div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> The <code><span class="Identifier">Peek</span></code> socket flag is not supported on Windows.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L494" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L494" target="_blank">Edit</a> </dd> </div> </div> <div id="recvFromInto-procs-all"> <div id="recvFromInto,AsyncFD,pointer,int,ptr.SockAddr,ptr.SockLen"> <dt><pre data-language="nim">proc recvFromInto(socket: AsyncFD; data: pointer; size: int;
                  saddr: ptr SockAddr; saddrLen: ptr SockLen;
                  flags = {SafeDisconn}): owned(Future[int]) {.
    ...raises: [ValueError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> Receives a datagram data from <code><span class="Identifier">socket</span></code> into <code><span class="Identifier">buf</span></code>, which must be at least of size <code><span class="Identifier">size</span></code>, address of datagram's sender will be stored into <code><span class="Identifier">saddr</span></code> and <code><span class="Identifier">saddrLen</span></code>. Returned future will complete once one datagram has been received, and will return size of packet received. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L723" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L723" target="_blank">Edit</a> </dd> </div> </div> <div id="recvInto-procs-all"> <div id="recvInto,AsyncFD,pointer,int"> <dt><pre data-language="nim">proc recvInto(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[int]) {....raises: [ValueError, Exception], tags: [RootEffect],
                   forbids: [].}</pre></dt> <dd> Reads <strong>up to</strong> <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">socket</span></code> into <code><span class="Identifier">buf</span></code>, which must at least be of that size. Returned future will complete once all the data requested is read, a part of the data has been read, or the socket has disconnected in which case the future will complete with a value of <code><span class="DecNumber">0</span></code>.<div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> The <code><span class="Identifier">Peek</span></code> socket flag is not supported on Windows.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L567" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L567" target="_blank">Edit</a> </dd> </div> </div> <div id="register-procs-all"> <div id="register,AsyncFD"> <dt><pre data-language="nim">proc register(fd: AsyncFD) {....raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> Registers <code><span class="Identifier">fd</span></code> with the dispatcher. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L372" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L372" target="_blank">Edit</a> </dd> </div> </div> <div id="runForever-procs-all"> <div id="runForever"> <dt><pre data-language="nim">proc runForever() {....raises: [ValueError, Exception, OSError],
                    tags: [TimeEffect, RootEffect], forbids: [].}</pre></dt> <dd> Begins a never ending global dispatcher poll loop. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L2014" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L2014" target="_blank">Edit</a> </dd> </div> </div> <div id="send-procs-all"> <div id="send,AsyncFD,pointer,int"> <dt><pre data-language="nim">proc send(socket: AsyncFD; buf: pointer; size: int; flags = {SafeDisconn}): owned(
    Future[void]) {....raises: [ValueError, Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> Sends <code><span class="Identifier">size</span></code> bytes from <code><span class="Identifier">buf</span></code> to <code><span class="Identifier">socket</span></code>. The returned future will complete once all data has been sent.<div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> Use it with caution. If <code><span class="Identifier">buf</span></code> refers to GC'ed object, you must use GC_ref/GC_unref calls to avoid early freeing of the buffer.</div> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L633" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L633" target="_blank">Edit</a> </dd> </div> <div id="send,AsyncFD,string"> <dt><pre data-language="nim">proc send(socket: AsyncFD; data: string; flags = {SafeDisconn}): owned(
    Future[void]) {....raises: [ValueError, Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> Sends <code><span class="Identifier">data</span></code> to <code><span class="Identifier">socket</span></code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1977" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1977" target="_blank">Edit</a> </dd> </div> </div> <div id="sendTo-procs-all"> <div id="sendTo,AsyncFD,pointer,int,ptr.SockAddr,SockLen"> <dt><pre data-language="nim">proc sendTo(socket: AsyncFD; data: pointer; size: int; saddr: ptr SockAddr;
            saddrLen: SockLen; flags = {SafeDisconn}): owned(Future[void]) {.
    ...raises: [ValueError, Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> Sends <code><span class="Identifier">data</span></code> to specified destination <code><span class="Identifier">saddr</span></code>, using socket <code><span class="Identifier">socket</span></code>. The returned future will complete once all data has been sent. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L678" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L678" target="_blank">Edit</a> </dd> </div> </div> <div id="setGlobalDispatcher-procs-all"> <div id="setGlobalDispatcher,sinkPDispatcher"> <dt><pre data-language="nim">proc setGlobalDispatcher(disp: sink PDispatcher) {....raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L356" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L356" target="_blank">Edit</a> </dd> </div> </div> <div id="setInheritable-procs-all"> <div id="setInheritable,AsyncFD,bool"> <dt><pre data-language="nim">proc setInheritable(fd: AsyncFD; inheritable: bool): bool {....raises: [],
    tags: [], forbids: [].}</pre></dt> <dd> <p>Control whether a file handle can be inherited by child processes. Returns <code><span class="Identifier">true</span></code> on success.</p> <p>This procedure is not guaranteed to be available for all platforms. Test for availability with <a href="system.html#declared,untyped">declared()</a>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L868" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L868" target="_blank">Edit</a> </dd> </div> </div> <div id="sleepAsync-procs-all"> <div id="sleepAsync"> <dt><pre data-language="nim">proc sleepAsync(ms: int | float): owned(Future[void])</pre></dt> <dd> Suspends the execution of the current async procedure for the next <code><span class="Identifier">ms</span></code> milliseconds. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1919" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1919" target="_blank">Edit</a> </dd> </div> </div> <div id="trigger-procs-all"> <div id="trigger,AsyncEvent"> <dt><pre data-language="nim">proc trigger(ev: AsyncEvent) {....raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> Set event <code><span class="Identifier">ev</span></code> to signaled state. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1113" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1113" target="_blank">Edit</a> </dd> </div> </div> <div id="unregister-procs-all"> <div id="unregister,AsyncEvent"> <dt><pre data-language="nim">proc unregister(ev: AsyncEvent) {....raises: [OSError], tags: [], forbids: [].}</pre></dt> <dd> Unregisters event <code><span class="Identifier">ev</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1118" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1118" target="_blank">Edit</a> </dd> </div> <div id="unregister,AsyncFD"> <dt><pre data-language="nim">proc unregister(fd: AsyncFD) {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> Unregisters <code><span class="Identifier">fd</span></code>. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L875" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L875" target="_blank">Edit</a> </dd> </div> </div> <div id="waitFor-procs-all"> <div id="waitFor,Future[T]"> <dt><pre data-language="nim">proc waitFor[T](fut: Future[T]): T</pre></dt> <dd> <strong>Blocks</strong> the current thread until the specified future completes. <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L2019" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L2019" target="_blank">Edit</a> </dd> </div> </div> <div id="withTimeout-procs-all"> <div id="withTimeout,Future[T],int"> <dt><pre data-language="nim">proc withTimeout[T](fut: Future[T]; timeout: int): owned(Future[bool])</pre></dt> <dd> <p>Returns a future which will complete once <code><span class="Identifier">fut</span></code> completes or after <code><span class="Identifier">timeout</span></code> milliseconds has elapsed.</p> <p>If <code><span class="Identifier">fut</span></code> completes first the returned future will hold true, otherwise, if <code><span class="Identifier">timeout</span></code> milliseconds has elapsed first, the returned future will hold false.</p> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/lib/pure/asyncdispatch.nim#L1931" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/asyncdispatch.nim#L1931" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/asyncdispatch.html" class="_attribution-link">https://nim-lang.org/docs/asyncdispatch.html</a>
  </p>
</div>
