<h1 class="title">Nim Backend Integration</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-2/doc/backends.md#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/doc/backends.md#L1" target="_blank">Edit</a>  
<blockquote class="markdown-quote"><p>"Heresy grows from idleness." -- Unknown.</p></blockquote> <h2 id="introduction">Introduction</h2>
<p>The <a href="nimc.html">Nim Compiler User Guide</a> documents the typical compiler invocation, using the <code>compile</code> or <code>c</code> command to transform a <code>.nim</code> file into one or more <code>.c</code> files which are then compiled with the platform's C compiler into a static binary. However, there are other commands to compile to C++, Objective-C, or JavaScript. This document tries to concentrate in a single place all the backend and interfacing options.</p> <p>The Nim compiler supports mainly two backend families: the C, C++ and Objective-C targets and the JavaScript target. <a href="backends.html#backends-the-c-like-targets">The C like targets</a> creates source files that can be compiled into a library or a final executable. <a href="backends.html#backends-the-javascript-target">The JavaScript target</a> can generate a <code>.js</code> file which you reference from an HTML file or create a <a href="http://nodejs.org">standalone Node.js program</a>.</p> <p>On top of generating libraries or standalone applications, Nim offers bidirectional interfacing with the backend targets through generic and specific pragmas.</p> <h2 id="backends">Backends</h2> <h3 id="backends-the-c-like-targets">The C like targets</h3>
<p>The commands to compile to either C, C++ or Objective-C are:</p> <div class="option-list">
<div class="option-list-item odd">
<div class="option-list-label"><code><span class="option">compileToC, cc</span></code></div>
<div class="option-list-description">compile project with C code generator</div>
</div> <div class="option-list-item">
<div class="option-list-label"><code><span class="option">compileToCpp, cpp</span></code></div>
<div class="option-list-description">compile project to C++ code</div>
</div> <div class="option-list-item odd">
<div class="option-list-label"><code><span class="option">compileToOC, objc</span></code></div>
<div class="option-list-description">compile project to Objective C code</div>
</div> </div>
<p>The most significant difference between these commands is that if you look into the <code>nimcache</code> directory you will find <code>.c</code>, <code>.cpp</code> or <code>.m</code> files, other than that all of them will produce a native binary for your project. This allows you to take the generated code and place it directly into a project using any of these languages. Here are some typical command- line invocations:</p> 
<pre class="listing" data-language="nim">nim c hallo.nim
nim cpp hallo.nim
nim objc hallo.nim</pre> <p>The compiler commands select the target backend, but if needed you can <a href="nimc.html#crossminuscompilation">specify additional switches for cross-compilation</a> to select the target CPU, operative system or compiler/linker commands.</p> <h3 id="backends-the-javascript-target">The JavaScript target</h3>
<p>Nim can also generate <span id="javascript_1">JavaScript</span> code through the <code>js</code> command.</p> <p>Nim targets JavaScript 1.5 which is supported by any widely used browser. Since JavaScript does not have a portable means to include another module, Nim just generates a long <code>.js</code> file.</p> <p>Features or modules that the JavaScript platform does not support are not available. This includes:</p> <ul class="simple">
<li>manual memory management (<code><span class="Identifier">alloc</span></code>, etc.)</li> <li>casting and other unsafe operations (<code><span class="Keyword">cast</span></code> operator, <code><span class="Identifier">zeroMem</span></code>, etc.)</li> <li>file management</li> <li>OS-specific operations</li> <li>threading, coroutines</li> <li>some modules of the standard library</li> <li>proper 64-bit integer arithmetic</li> </ul> <p>To compensate, the standard library has modules <a href="lib.html#pure-libraries-modules-for-js-backend">catered to the JS backend</a> and more support will come in the future (for instance, Node.js bindings to get OS info).</p> <p>To compile a Nim module into a <code>.js</code> file use the <code>js</code> command; the default is a <code>.js</code> file that is supposed to be referenced in an <code>.html</code> file. However, you can also run the code with <span id="nodejs_1">nodejs</span> (<a href="http://nodejs.org">http://nodejs.org</a>):</p> 
<pre class="listing" data-language="nim">nim js -d:nodejs -r examples/hallo.nim</pre> <p>If you experience errors saying that <code><span class="Identifier">globalThis</span></code> is not defined, be sure to run a recent version of Node.js (at least 12.0).</p> <h2 id="interfacing">Interfacing</h2>
<p>Nim offers bidirectional interfacing with the target backend. This means that you can call backend code from Nim and Nim code can be called by the backend code. Usually the direction of which calls which depends on your software architecture (is Nim your main program or is Nim providing a component?).</p> <h3 id="interfacing-nim-code-calling-the-backend">Nim code calling the backend</h3>
<p>Nim code can interface with the backend through the <a href="manual.html#foreign-function-interface">Foreign function interface</a> mainly through the <a href="manual.html#foreign-function-interface-importc-pragma">importc pragma</a>. The <code><span class="Identifier">importc</span></code> pragma is the <em>generic</em> way of making backend symbols available in Nim and is available in all the target backends (JavaScript too). The C++ or Objective-C backends have their respective <a href="manual.html#implementation-specific-pragmas-importcpp-pragma">ImportCpp</a> and <a href="manual.html#implementation-specific-pragmas-importobjc-pragma">ImportObjC</a> pragmas to call methods from classes.</p> <p>Whenever you use any of these pragmas you need to integrate native code into your final binary. In the case of JavaScript this is no problem at all, the same HTML file which hosts the generated JavaScript will likely provide other JavaScript functions which you are importing with <code><span class="Identifier">importc</span></code>.</p> <p>However, for the C like targets you need to link external code either statically or dynamically. The preferred way of integrating native code is to use dynamic linking because it allows you to compile Nim programs without the need for having the related development libraries installed. This is done through the <a href="manual.html#foreign-function-interface-dynlib-pragma-for-import">dynlib pragma for import</a>, though more specific control can be gained using the <a href="dynlib.html">dynlib module</a>.</p> <p>The <a href="nimc.html#dynliboverride">dynlibOverride</a> command line switch allows to avoid dynamic linking if you need to statically link something instead. Nim wrappers designed to statically link source files can use the <a href="manual.html#implementation-specific-pragmas-compile-pragma">compile pragma</a> if there are few sources or providing them along the Nim code is easier than using a system library. Libraries installed on the host system can be linked in with the <a href="manual.html#implementation-specific-pragmas-passl-pragma">PassL pragma</a>.</p> <p>To wrap native code, take a look at the <a href="https://github.com/nim-lang/c2nim/blob/master/doc/c2nim.rst">c2nim tool</a> which helps with the process of scanning and transforming header files into a Nim interface.</p> <h4 id="nim-code-calling-the-backend-c-invocation-example">C invocation example</h4>
<p>Create a <code>logic.c</code> file with the following content:</p> 
<pre class="listing" data-language="nim">int addTwoIntegers(int a, int b)
{
  return a + b;
}</pre> <p>Create a <code>calculator.nim</code> file with the following content:</p> 
<pre class="listing" data-language="nim">{.compile: "logic.c".}
proc addTwoIntegers(a, b: cint): cint {.importc.}

when isMainModule:
  echo addTwoIntegers(3, 7)</pre> <p>With these two files in place, you can run <code><span class="program">nim</span> <span class="option">c</span> <span class="option">-r</span> <span class="Identifier">calculator.nim</span></code> and the Nim compiler will compile the <code>logic.c</code> file in addition to <code>calculator.nim</code> and link both into an executable, which outputs <code><span class="DecNumber">10</span></code> when run. Another way to link the C file statically and get the same effect would be to remove the line with the <code><span class="Identifier">compile</span></code> pragma and run the following typical Unix commands:</p> 
<pre class="listing" data-language="nim">gcc -c logic.c
ar rvs mylib.a logic.o
nim c --passL:mylib.a -r calculator.nim</pre> <p>Just like in this example we pass the path to the <code>mylib.a</code> library (and we could as well pass <code>logic.o</code>) we could be passing switches to link any other static C library.</p> <h4 id="nim-code-calling-the-backend-javascript-invocation-example">JavaScript invocation example</h4>
<p>Create a <code>host.html</code> file with the following content:</p> 
<pre class="listing" data-language="nim">&lt;html&gt;&lt;body&gt;
&lt;script type="text/javascript"&gt;
function addTwoIntegers(a, b)
{
  return a + b;
}
&lt;/script&gt;
&lt;script type="text/javascript" src="calculator.js"&gt;&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;</pre> <p>Create a <code>calculator.nim</code> file with the following content (or reuse the one from the previous section):</p> 
<pre class="listing" data-language="nim">proc addTwoIntegers(a, b: int): int {.importc.}

when isMainModule:
  echo addTwoIntegers(3, 7)</pre> <p>Compile the Nim code to JavaScript with <code><span class="program">nim</span> <span class="option">js</span> <span class="Identifier">-o:calculator.js</span> <span class="Identifier">calculator.nim</span></code> and open <code>host.html</code> in a browser. If the browser supports javascript, you should see the value <code><span class="DecNumber">10</span></code> in the browser's console. Use the <a href="dom.html">dom module</a> for specific DOM querying and modification procs or take a look at <a href="https://github.com/pragmagic/karax">karax</a> for how to develop browser-based applications.</p> <h3 id="interfacing-backend-code-calling-nim">Backend code calling Nim</h3>
<p>Backend code can interface with Nim code exposed through the <a href="manual.html#foreign-function-interface-exportc-pragma">exportc pragma</a>. The <code><span class="Identifier">exportc</span></code> pragma is the <em>generic</em> way of making Nim symbols available to the backends. By default, the Nim compiler will mangle all the Nim symbols to avoid any name collision, so the most significant thing the <code><span class="Identifier">exportc</span></code> pragma does is maintain the Nim symbol name, or if specified, use an alternative symbol for the backend in case the symbol rules don't match.</p> <p>The JavaScript target doesn't have any further interfacing considerations since it also has garbage collection, but the C targets require you to initialize Nim's internals, which is done calling a <code><span class="Identifier">NimMain</span></code> function. Also, C code requires you to specify a forward declaration for functions or the compiler will assume certain types for the return value and parameters which will likely make your program crash at runtime.</p> <p>The name <code><span class="Identifier">NimMain</span></code> can be influenced via the <code><span class="Operator">--</span><span class="Identifier">nimMainPrefix</span><span class="Punctuation">:</span><span class="Identifier">prefix</span></code> switch. Use <code><span class="Operator">--</span><span class="Identifier">nimMainPrefix</span><span class="Punctuation">:</span><span class="Identifier">MyLib</span></code> and the function to call is named <code><span class="Identifier">MyLibNimMain</span></code>.</p> <p>When compiling to static or dynamic libraries, they don't call destructors of global variables as normal Nim programs would do. A C API <code><span class="Identifier">NimDestroyGlobals</span></code> is provided to call these global destructors.</p> <h4 id="backend-code-calling-nim-nim-invocation-example-from-c">Nim invocation example from C</h4>
<p>Create a <code>fib.nim</code> file with the following content:</p> 
<pre class="listing" data-language="nim">proc fib(a: cint): cint {.exportc.} =
  if a &lt;= 2:
    result = 1
  else:
    result = fib(a - 1) + fib(a - 2)</pre> <p>Create a <code>maths.c</code> file with the following content:</p> 
<pre class="listing" data-language="nim">#include &lt;stdio.h&gt;

int fib(int a);
void NimMain();

int main(void)
{
  NimMain();
  for (int f = 0; f &lt; 10; f++)
    printf("Fib of %d is %d\n", f, fib(f));
  return 0;
}</pre> <p>Now you can run the following Unix like commands to first generate C sources from the Nim code, then link them into a static binary along your main C program:</p> 
<pre class="listing" data-language="nim">nim c --noMain --noLinking fib.nim
gcc -o m -I$HOME/.cache/nim/fib_d -Ipath/to/nim/lib $HOME/.cache/nim/fib_d/*.c maths.c</pre> <p>The first command runs the Nim compiler with three special options to avoid generating a <code><span class="Identifier">main</span><span class="Punctuation">(</span><span class="Punctuation">)</span></code> function in the generated files and to avoid linking the object files into a final binary. All the generated files are placed into the <code>nimcache</code> directory. That's why the next command compiles the <code>maths.c</code> source plus all the <code>.c</code> files from <code>nimcache</code>. In addition to this path, you also have to tell the C compiler where to find Nim's <code>nimbase.h</code> header file.</p> <p>Instead of depending on the generation of the individual <code>.c</code> files you can also ask the Nim compiler to generate a statically linked library:</p> 
<pre class="listing" data-language="nim">nim c --app:staticLib fib.nim
gcc -o m -Inimcache -Ipath/to/nim/lib maths.c libfib.nim.a</pre> <p>The Nim compiler will handle linking the source files generated in the <code>nimcache</code> directory into the <code>libfib.nim.a</code> static library, which you can then link into your C program. Note that these commands are generic and will vary for each system. For instance, on Linux systems you will likely need to use <code>-ldl</code> too to link in required dlopen functionality.</p> <h4 id="backend-code-calling-nim-nim-invocation-example-from-javascript">Nim invocation example from JavaScript</h4>
<p>Create a <code>mhost.html</code> file with the following content:</p> 
<pre class="listing" data-language="nim">&lt;html&gt;&lt;body&gt;
&lt;script type="text/javascript" src="fib.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
alert("Fib for 9 is " + fib(9));
&lt;/script&gt;
&lt;/body&gt;&lt;/html&gt;</pre> <p>Create a <code>fib.nim</code> file with the following content (or reuse the one from the previous section):</p> 
<pre class="listing" data-language="nim">proc fib(a: cint): cint {.exportc.} =
  if a &lt;= 2:
    result = 1
  else:
    result = fib(a - 1) + fib(a - 2)</pre> <p>Compile the Nim code to JavaScript with <code><span class="program">nim</span> <span class="option">js</span> <span class="Identifier">-o:fib.js</span> <span class="Identifier">fib.nim</span></code> and open <code>mhost.html</code> in a browser. If the browser supports javascript, you should see an alert box displaying the text <code>Fib for 9 is 34</code>. As mentioned earlier, JavaScript doesn't require an initialization call to <code><span class="Identifier">NimMain</span></code> or a similar function and you can call the exported Nim proc directly.</p> <h3 id="interfacing-nimcache-naming-logic">Nimcache naming logic</h3>
<p>The <span id="nimcache_1">nimcache</span> directory is generated during compilation and will hold either temporary or final files depending on your backend target. The default name for the directory depends on the used backend and on your OS but you can use the <code>--nimcache</code> <a href="nimc.html#compiler-usage-commandminusline-switches">compiler switch</a> to change it.</p> <h2 id="memory-management">Memory management</h2>
<p>In the previous sections, the <code><span class="Identifier">NimMain</span><span class="Punctuation">(</span><span class="Punctuation">)</span></code> function reared its head. Since JavaScript already provides automatic memory management, you can freely pass objects between the two languages without problems. In C and derivate languages you need to be careful about what you do and how you share memory. The previous examples only dealt with simple scalar values, but passing a Nim string to C, or reading back a C string in Nim already requires you to be aware of who controls what to avoid crashing.</p> <h3 id="memory-management-strings-and-c-strings">Strings and C strings</h3>
<p>The manual mentions that <a href="manual.html#types-cstring-type">Nim strings are implicitly convertible to cstrings</a> which makes interaction usually painless. Most C functions accepting a Nim string converted to a <code><span class="Identifier">cstring</span></code> will likely not need to keep this string around and by the time they return the string won't be needed anymore.</p> <p>A similar thing happens with C code invoking Nim code which returns a <code><span class="Identifier">cstring</span></code>. Consider the following proc:</p> 
<pre class="listing" data-language="nim">proc gimme(): cstring {.exportc.} =
  result = "Hey there C code! " &amp; $rand(100)</pre> <p>Since Nim's reference counting mechanism is not aware of the C code, once the <code><span class="Identifier">gimme</span></code> proc has finished it can reclaim the memory of the <code><span class="Identifier">cstring</span></code>.</p> <h3 id="memory-management-custom-data-types">Custom data types</h3>
<p>Just like strings, custom data types that are to be shared between Nim and the backend will need careful consideration of who controls who. If you want to hand a Nim reference to C code, you will need to use <a href="system.html#GC_ref,ref.T">GC_ref</a> to mark the reference as used, so it does not get freed. And for the C backend you will need to expose the <a href="system.html#GC_unref,ref.T">GC_unref</a> proc to clean up this memory when it is not required anymore.</p> <p>Again, if you are wrapping a library which <em>mallocs</em> and <em>frees</em> data structures, you need to expose the appropriate <em>free</em> function to Nim so you can clean it up. And of course, once cleaned you should avoid accessing it from Nim (or C for that matter). Typically C data structures have their own <code><span class="Identifier">malloc_structure</span></code> and <code><span class="Identifier">free_structure</span></code> specific functions, so wrapping these for the Nim side should be enough. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/backends.html" class="_attribution-link">https://nim-lang.org/docs/backends.html</a>
  </p>
</div>
