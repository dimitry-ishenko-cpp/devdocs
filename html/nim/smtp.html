<h1 class="title">src/smtp</h1>  
<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> In order to use this module, run <code><span class="Identifier">nimble</span> <span class="Identifier">install</span> <span class="Identifier">smtp</span></code>.</div> <p>This module implements the SMTP client protocol as specified by RFC 5321, this can be used to send mail to any SMTP Server.</p> <p>This module also implements the protocol used to format messages, as specified by RFC 2822.</p> <p>Example gmail use:</p> <pre class="listing" data-language="nim">var msg = createMessage("Hello from Nim's SMTP",
                        "Hello!.\n Is this awesome or what?",
                        @["foo@gmail.com"])
let smtpConn = newSmtp(useSsl = true, debug=true)
smtpConn.connect("smtp.gmail.com", Port 465)
smtpConn.auth("username", "password")
smtpConn.sendmail("username@gmail.com", @["foo@gmail.com"], $msg)</pre>
<p>Example for startTls use:</p> <pre class="listing" data-language="nim">var msg = createMessage("Hello from Nim's SMTP",
                        "Hello!.\n Is this awesome or what?",
                        @["foo@gmail.com"])
let smtpConn = newSmtp(debug=true)
smtpConn.connect("smtp.mailtrap.io", Port 2525)
smtpConn.startTls()
smtpConn.auth("username", "password")
smtpConn.sendmail("username@gmail.com", @["foo@gmail.com"], $msg)</pre>
<p>For SSL support this module relies on OpenSSL. If you want to enable SSL, compile with <code><span class="Operator">-</span><span class="Identifier">d</span><span class="Punctuation">:</span><span class="Identifier">ssl</span></code>.</p>  <h2 id="7">Types</h2> <dl> <div id="AsyncSmtp"> <dt><pre data-language="nim">AsyncSmtp = SmtpBase[AsyncSocket]</pre></dt>  </div> <div id="Message"> <dt><pre>Message = object</pre></dt>  </div> <div id="ReplyError"> <dt><pre>ReplyError = object of IOError</pre></dt>  </div> <div id="Smtp"> <dt><pre data-language="nim">Smtp = SmtpBase[Socket]</pre></dt>  </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="$-procs-all"> <div id="$,Message"> <dt><pre data-language="nim">proc `$`(msg: Message): string {....raises: [], tags: [], forbids: [].}</pre></dt> <dd> stringify for <code><span class="Identifier">Message</span></code>. </dd> </div> </div> <div id="auth-procs-all"> <div id="auth,AsyncSmtp,string,string"> <dt><pre data-language="nim">proc auth(smtp: AsyncSmtp; username, password: string): owned(Future[void]) {.
    ...stackTrace: false, raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> Sends an AUTH command to the server to login as the <code><span class="Identifier">username</span></code> using <code><span class="Identifier">password</span></code>. May fail with ReplyError. </dd> </div> <div id="auth,Smtp,string,string"> <dt><pre data-language="nim">proc auth(smtp: Smtp; username, password: string) {.
    ...raises: [SslError, OSError, TimeoutError, ReplyError],
    tags: [WriteIOEffect, ReadIOEffect, TimeEffect], forbids: [].}</pre></dt>  </div> </div> <div id="checkReply-procs-all"> <div id="checkReply,AsyncSmtp,string"> <dt><pre data-language="nim">proc checkReply(smtp: AsyncSmtp; reply: string): owned(Future[void]) {.
    ...stackTrace: false, raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Calls <a href="#debugRecv,AsyncSmtp">debugRecv</a> and checks that the received data starts with <code><span class="Identifier">reply</span></code>. If the received data does not start with <code><span class="Identifier">reply</span></code>, then a <code><span class="Identifier">QUIT</span></code> command will be sent to the SMTP server and a <code><span class="Identifier">ReplyError</span></code> exception will be raised.</p> <p>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any <a href="https://en.wikipedia.org/wiki/Extended_SMTP">SMTP extensions</a>.</p> </dd> </div> <div id="checkReply,Smtp,string"> <dt><pre data-language="nim">proc checkReply(smtp: Smtp; reply: string) {.
    ...raises: [TimeoutError, OSError, SslError, ReplyError],
    tags: [ReadIOEffect, TimeEffect, WriteIOEffect], forbids: [].}</pre></dt>  </div> </div> <div id="close-procs-all"> <div id="close,AsyncSmtp"> <dt><pre data-language="nim">proc close(smtp: AsyncSmtp): owned(Future[void]) {....stackTrace: false,
    raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> Disconnects from the SMTP server and closes the socket. </dd> </div> <div id="close,Smtp"> <dt><pre data-language="nim">proc close(smtp: Smtp) {....raises: [SslError, OSError, LibraryError, Exception],
                         tags: [WriteIOEffect, RootEffect], forbids: [].}</pre></dt>  </div> </div> <div id="connect-procs-all"> <div id="connect,AsyncSmtp,string,Port,bool"> <dt><pre data-language="nim">proc connect(smtp: AsyncSmtp; address: string; port: Port; helo: bool = true): owned(
    Future[void]) {....stackTrace: false, raises: [Exception], tags: [RootEffect],
                    forbids: [].}</pre></dt> <dd> Establishes a connection with a SMTP server. May fail with ReplyError or with a socket error. </dd> </div> <div id="connect,Smtp,string,Port,bool"> <dt><pre data-language="nim">proc connect(smtp: Smtp; address: string; port: Port; helo: bool = true) {.
    ...raises: [OSError, IOError, SslError, TimeoutError, ReplyError],
    tags: [ReadIOEffect, WriteIOEffect, TimeEffect], forbids: [].}</pre></dt>  </div> </div> <div id="createMessage-procs-all"> <div id="createMessage,string,string,seq[string],seq[string]"> <dt><pre data-language="nim">proc createMessage(mSubject, mBody: string; mTo, mCc: seq[string] = @[]): Message {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Alternate version of the above.</p> <p>You need to make sure that <code><span class="Identifier">mSubject</span></code>, <code><span class="Identifier">mTo</span></code> and <code><span class="Identifier">mCc</span></code> don't contain any newline characters. Failing to do so will raise <code><span class="Identifier">AssertionDefect</span></code>.</p> </dd> </div> <div id="createMessage,string,string,seq[string],seq[string],openArray[tuple[string,string]]"> <dt><pre data-language="nim">proc createMessage(mSubject, mBody: string; mTo, mCc: seq[string];
                   otherHeaders: openArray[tuple[name, value: string]]): Message {.
    ...raises: [], tags: [], forbids: [].}</pre></dt> <dd> <p>Creates a new MIME compliant message.</p> <p>You need to make sure that <code><span class="Identifier">mSubject</span></code>, <code><span class="Identifier">mTo</span></code> and <code><span class="Identifier">mCc</span></code> don't contain any newline characters. Failing to do so will raise <code><span class="Identifier">AssertionDefect</span></code>.</p> </dd> </div> </div> <div id="debugRecv-procs-all"> <div id="debugRecv,AsyncSmtp"> <dt><pre data-language="nim">proc debugRecv(smtp: AsyncSmtp): Future[string] {....stackTrace: false,
    raises: [Exception, ValueError], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Receives a line of data from the socket connected to the SMTP server.</p> <p>If the <code><span class="Identifier">smtp</span></code> object was created with <code><span class="Identifier">debug</span></code> enabled, debugRecv will invoke <code><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">"S:"</span> <span class="Operator">&amp;</span> <span class="Identifier">result</span><span class="Operator">.</span><span class="Identifier">string</span><span class="Punctuation">)</span></code> after the data is received.</p> <p>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any <a href="https://en.wikipedia.org/wiki/Extended_SMTP">SMTP extensions</a>.</p> <p>See <a href="#checkReply,AsyncSmtp,string">checkReply(reply)</a>.</p> </dd> </div> <div id="debugRecv,Smtp"> <dt><pre data-language="nim">proc debugRecv(smtp: Smtp): string {....raises: [TimeoutError, OSError, SslError],
                                     tags: [ReadIOEffect, TimeEffect],
                                     forbids: [].}</pre></dt>  </div> </div> <div id="debugSend-procs-all"> <div id="debugSend,AsyncSmtp,string"> <dt><pre data-language="nim">proc debugSend(smtp: AsyncSmtp; cmd: string): owned(Future[void]) {.
    ...stackTrace: false, raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Sends <code><span class="Identifier">cmd</span></code> on the socket connected to the SMTP server.</p> <p>If the <code><span class="Identifier">smtp</span></code> object was created with <code><span class="Identifier">debug</span></code> enabled, debugSend will invoke <code><span class="Identifier">echo</span><span class="Punctuation">(</span><span class="StringLit">"C:"</span> <span class="Operator">&amp;</span> <span class="Identifier">cmd</span><span class="Punctuation">)</span></code> before sending.</p> <p>This is a lower level proc and not something that you typically would need to call when using this module. One exception to this is if you are implementing any <a href="https://en.wikipedia.org/wiki/Extended_SMTP">SMTP extensions</a>.</p> </dd> </div> <div id="debugSend,Smtp,string"> <dt><pre data-language="nim">proc debugSend(smtp: Smtp; cmd: string) {....raises: [SslError, OSError],
    tags: [WriteIOEffect], forbids: [].}</pre></dt>  </div> </div> <div id="dial-procs-all"> <div id="dial,string,Port,SslContext,bool"> <dt><pre data-language="nim">proc dial(address: string; port: Port; useSsl = false; debug = false;
          sslContext: SslContext = nil; helo: bool = true): Smtp {....raises: [
    LibraryError, SslError, Exception, IOError, OSError, TimeoutError,
    ReplyError], tags: [RootEffect, ReadDirEffect, ReadEnvEffect, ReadIOEffect,
                        WriteIOEffect, TimeEffect], forbids: [].}</pre></dt>  </div> </div> <div id="dialAsync-procs-all"> <div id="dialAsync,string,Port,SslContext,bool"> <dt><pre data-language="nim">proc dialAsync(address: string; port: Port; useSsl = false; debug = false;
               sslContext: SslContext = nil; helo: bool = true): Future[
    AsyncSmtp] {....stackTrace: false, raises: [Exception, ValueError], tags: [
    RootEffect, ReadDirEffect, ReadEnvEffect, ReadIOEffect], forbids: [].}</pre></dt>  </div> </div> <div id="ehlo-procs-all"> <div id="ehlo,AsyncSmtp"> <dt><pre data-language="nim">proc ehlo(smtp: AsyncSmtp): Future[bool] {....stackTrace: false,
    raises: [Exception, ValueError], tags: [RootEffect], forbids: [].}</pre></dt> <dd> Sends EHLO request. </dd> </div> <div id="ehlo,Smtp"> <dt><pre data-language="nim">proc ehlo(smtp: Smtp): bool {....raises: [SslError, OSError, TimeoutError],
                              tags: [WriteIOEffect, ReadIOEffect, TimeEffect],
                              forbids: [].}</pre></dt>  </div> </div> <div id="helo-procs-all"> <div id="helo,AsyncSmtp,string"> <dt><pre data-language="nim">proc helo(smtp: AsyncSmtp; helo: string = "HELO"): owned(Future[void]) {.
    ...stackTrace: false, raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt>  </div> <div id="helo,Smtp,string"> <dt><pre data-language="nim">proc helo(smtp: Smtp; helo: string = "HELO") {.
    ...raises: [SslError, OSError, TimeoutError, ReplyError],
    tags: [WriteIOEffect, ReadIOEffect, TimeEffect], forbids: [].}</pre></dt>  </div> </div> <div id="lhlo-procs-all"> <div id="lhlo,AsyncSmtp"> <dt><pre data-language="nim">proc lhlo(smtp: AsyncSmtp): owned(Future[void]) {....stackTrace: false,
    raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt>  </div> <div id="lhlo,Smtp"> <dt><pre data-language="nim">proc lhlo(smtp: Smtp) {....raises: [SslError, OSError, TimeoutError, ReplyError],
                        tags: [WriteIOEffect, ReadIOEffect, TimeEffect],
                        forbids: [].}</pre></dt>  </div> </div> <div id="newAsyncSmtp-procs-all"> <div id="newAsyncSmtp,SslContext"> <dt><pre data-language="nim">proc newAsyncSmtp(useSsl = false; debug = false; sslContext: SslContext = nil): AsyncSmtp {.
    ...raises: [LibraryError, SslError, Exception, IOError, OSError],
    tags: [RootEffect, ReadDirEffect, ReadEnvEffect, ReadIOEffect], forbids: [].}</pre></dt> <dd> Creates a new <code><span class="Identifier">AsyncSmtp</span></code> instance. </dd> </div> </div> <div id="newSmtp-procs-all"> <div id="newSmtp,SslContext"> <dt><pre data-language="nim">proc newSmtp(useSsl = false; debug = false; sslContext: SslContext = nil): Smtp {.
    ...raises: [LibraryError, SslError, Exception, IOError, OSError],
    tags: [RootEffect, ReadDirEffect, ReadEnvEffect, ReadIOEffect], forbids: [].}</pre></dt> <dd> Creates a new <code><span class="Identifier">Smtp</span></code> instance. </dd> </div> </div> <div id="sendMail-procs-all"> <div id="sendMail,AsyncSmtp,string,seq[string],string"> <dt><pre data-language="nim">proc sendMail(smtp: AsyncSmtp; fromAddr: string; toAddrs: seq[string];
              msg: string): owned(Future[void]) {....stackTrace: false,
    raises: [Exception], tags: [RootEffect], forbids: [].}</pre></dt> <dd> <p>Sends <code><span class="Identifier">msg</span></code> from <code><span class="Identifier">fromAddr</span></code> to the addresses specified in <code><span class="Identifier">toAddrs</span></code>. Messages may be formed using <code><span class="Identifier">createMessage</span></code> by converting the Message into a string.</p> <p>You need to make sure that <code><span class="Identifier">fromAddr</span></code> and <code><span class="Identifier">toAddrs</span></code> don't contain any newline characters. Failing to do so will raise <code><span class="Identifier">AssertionDefect</span></code>.</p> </dd> </div> <div id="sendMail,Smtp,string,seq[string],string"> <dt><pre data-language="nim">proc sendMail(smtp: Smtp; fromAddr: string; toAddrs: seq[string]; msg: string) {.
    ...raises: [SslError, OSError, TimeoutError, ReplyError],
    tags: [WriteIOEffect, ReadIOEffect, TimeEffect], forbids: [].}</pre></dt>  </div> </div> <div id="startTls-procs-all"> <div id="startTls,AsyncSmtp,SslContext"> <dt><pre data-language="nim">proc startTls(smtp: AsyncSmtp; sslContext: SslContext = nil): owned(
    Future[void]) {....stackTrace: false, raises: [Exception], tags: [RootEffect,
    ReadDirEffect, ReadEnvEffect, ReadIOEffect], forbids: [].}</pre></dt> <dd> Put the SMTP connection in TLS (Transport Layer Security) mode. May fail with ReplyError </dd> </div> <div id="startTls,Smtp,SslContext"> <dt><pre data-language="nim">proc startTls(smtp: Smtp; sslContext: SslContext = nil) {....raises: [SslError,
    OSError, TimeoutError, ReplyError, Exception, LibraryError, IOError], tags: [
    WriteIOEffect, ReadIOEffect, TimeEffect, RootEffect, ReadDirEffect,
    ReadEnvEffect], forbids: [].}</pre></dt>  </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/smtp.html" class="_attribution-link">https://nim-lang.org/docs/smtp.html</a>
  </p>
</div>
