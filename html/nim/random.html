<h1 class="title">random</h1>  
<p>Nim's standard random number generator.</p> <p>Its implementation is based on the <code>xoroshiro128+</code> (xor/rotate/shift/rotate) library.</p> <ul class="simple">
<li>More information: <a href="http://xoroshiro.di.unimi.it">http://xoroshiro.di.unimi.it</a>/</li> <li>C implementation: <a href="http://xoroshiro.di.unimi.it/xoroshiro128plus.c">http://xoroshiro.di.unimi.it/xoroshiro128plus.c</a>
</li> </ul> <p><strong>Do not use this module for cryptographic purposes!</strong></p> <h2 id="basic-usage">Basic usage</h2>
<p>To get started, here are some examples:</p> <pre class="listing" data-language="nim">import random

# Call randomize() once to initialize the default random number generator
# If this is not called, the same results will occur every time these
# examples are run
randomize()

# Pick a number between 0 and 100
let num = rand(100)
echo num

# Roll a six-sided die
let roll = rand(1..6)
echo roll

# Pick a marble from a bag
let marbles = ["red", "blue", "green", "yellow", "purple"]
let pick = sample(marbles)
echo pick

# Shuffle some cards
var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
shuffle(cards)
echo cards</pre>
<p>These examples all use the default random number generator. The <a href="#Rand">Rand type</a> represents the state of a random number generator. For convenience, this module contains a default Rand state that corresponds to the default random number generator. Most procs in this module which do not take in a Rand parameter, including those called in the above examples, use the default generator. Those procs are <strong>not</strong> thread-safe.</p> <p>Note that the default generator always starts in the same state. The <a href="#randomize">randomize proc</a> can be called to initialize the default generator with a seed based on the current time, and it only needs to be called once before the first usage of procs from this module. If <code>randomize</code> is not called, then the default generator will always produce the same results.</p> <p>Generators that are independent of the default one can be created with the <a href="#initRand,int64">initRand proc</a>.</p> <p>Again, it is important to remember that this module must <strong>not</strong> be used for cryptographic applications.</p> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="math.html">math module</a> for basic math routines</li> <li>
<a href="mersenne.html">mersenne module</a> for the Mersenne Twister random number generator</li> <li>
<a href="stats.html">stats module</a> for statistical analysis</li> <li>
<a href="lib.html#pure-libraries-hashing">list of cryptographic and hashing modules</a> in the standard library</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="algorithm.html">algorithm</a>, <a href="math.html">math</a>, <a href="since.html">since</a>, <a href="times.html">times</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="Rand" data-language="nim">Rand = object
  a0, a1: Ui</pre></dt> <dd> <p>State of a random number generator.</p> <p>Create a new Rand state using the <a href="#initRand,int64">initRand proc</a>.</p> <p>The module contains a default Rand state for convenience. It corresponds to the default random number generator's state. The default Rand state always starts with the same values, but the <a href="#randomize">randomize proc</a> can be used to seed the default generator with a value based on the current time.</p> <p>Many procs have two variations: one that takes in a Rand parameter and another that uses the default generator. The procs that use the default generator are <strong>not</strong> thread-safe!</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L97" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L97" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="next%2CRand" data-language="nim">proc next(r: var Rand): uint64 {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Computes a random <code>uint64</code> number using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,Rand,Natural">rand proc</a> that returns an integer between zero and a given upper bound</li> <li>
<a href="#rand,Rand,range%5B%5D">rand proc</a> that returns a float</li> <li>
<a href="#rand,Rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> <li><a href="#skipRandomNumbers,Rand">skipRandomNumbers proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var r = initRand(2019)
doAssert r.next() == 138_744_656_611_299'u64
doAssert r.next() == 979_810_537_855_049_344'u64
doAssert r.next() == 3_628_232_584_225_300_704'u64</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L125" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L125" target="_blank">Edit</a> </dd>  <dt><pre id="skipRandomNumbers%2CRand" data-language="nim">proc skipRandomNumbers(s: var Rand) {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>The jump function for the generator.</p> <p>This proc is equivalent to 2^64 calls to <a href="#next,Rand">next</a>, and it can be used to generate 2^64 non-overlapping subsequences for parallel computations.</p> <p>When multiple threads are generating random numbers, each thread must own the <a href="#Rand">Rand</a> state it is using so that the thread can safely obtain random numbers. However, if each thread creates its own Rand state, the subsequences of random numbers that each thread generates may overlap, even if the provided seeds are unique. This is more likely to happen as the number of threads and amount of random numbers generated increases.</p> <p>If many threads will generate random numbers concurrently, it is better to create a single Rand state and pass it to each thread. After passing the Rand state to a thread, call this proc before passing it to the next one. By using the Rand state this way, the subsequences of random numbers generated in each thread will never overlap as long as no thread generates more than 2^64 random numbers.</p> <p>The following example below demonstrates this pattern:</p> <pre class="listing" data-language="nim"># Compile this example with --threads:on
import random
import threadpool

const spawns = 4
const numbers = 100000

proc randomSum(rand: Rand): int =
  var r = rand
  for i in 1..numbers:
    result += rand(1..10)

var r = initRand(2019)
var vals: array[spawns, FlowVar[int]]
for val in vals.mitems:
  val = spawn(randomSum(r))
  r.skipRandomNumbers()

for val in vals:
  echo ^val</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#next,Rand">next proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L147" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2CRand%2CNatural" data-language="nim">proc rand(r: var Rand; max: Natural): int {...}{.gcsafe, locks: 0, raises: [],
    tags: [].}</pre></dt> <dd> <p>Returns a random integer in the range <code>0..max</code> using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,int">rand proc</a> that returns an integer using the default random number generator</li> <li>
<a href="#rand,Rand,range%5B%5D">rand proc</a> that returns a float</li> <li>
<a href="#rand,Rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var r = initRand(123)
doAssert r.rand(100) == 0
doAssert r.rand(100) == 96
doAssert r.rand(100) == 66</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L210" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L210" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2Cint" data-language="nim">proc rand(max: int): int {...}{.gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> <p>Returns a random integer in the range <code>0..max</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the sequence of random numbers returned from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,Rand,Natural">rand proc</a> that returns an integer using a provided state</li> <li>
<a href="#rand,float">rand proc</a> that returns a float</li> <li>
<a href="#rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">randomize(123)
doAssert rand(100) == 0
doAssert rand(100) == 96
doAssert rand(100) == 66</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L230" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L230" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2CRand%2Crange%5B%5D" data-language="nim">proc rand(r: var Rand; max: range[0.0 .. high(float)]): float {...}{.gcsafe,
    locks: 0, raises: [], tags: [].}</pre></dt> <dd> <p>Returns a random floating point number in the range <code>0.0..max</code> using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,float">rand proc</a> that returns a float using the default random number generator</li> <li>
<a href="#rand,Rand,Natural">rand proc</a> that returns an integer</li> <li>
<a href="#rand,Rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var r = initRand(234)
let f = r.rand(1.0)
## f = 8.717181376738381e-07</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L252" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L252" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2Cfloat" data-language="nim">proc rand(max: float): float {...}{.gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> <p>Returns a random floating point number in the range <code>0.0..max</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the sequence of random numbers returned from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,Rand,range%5B%5D">rand proc</a> that returns a float using a provided state</li> <li>
<a href="#rand,int">rand proc</a> that returns an integer</li> <li>
<a href="#rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">randomize(234)
let f = rand(1.0)
## f = 8.717181376738381e-07</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L273" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L273" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2CRand%2CHSlice%5BT%3A+Ordinal+or+float+or+float32+or+float64%2CT%3A+Ordinal+or+float+or+float32+or+float64%5D" data-language="nim">proc rand[T: Ordinal or SomeFloat](r: var Rand; x: HSlice[T, T]): T</pre></dt> <dd> <p>For a slice <code>a..b</code>, returns a value in the range <code>a..b</code> using the given state.</p> <p>Allowed types for <code>T</code> are integers, floats, and enums without holes.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice and uses the default random number generator</li> <li>
<a href="#rand,Rand,Natural">rand proc</a> that returns an integer</li> <li>
<a href="#rand,Rand,range%5B%5D">rand proc</a> that returns a float</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var r = initRand(345)
doAssert r.rand(1..6) == 4
doAssert r.rand(1..6) == 4
doAssert r.rand(1..6) == 6
let f = r.rand(-1.0 .. 1.0)
## f = 0.8741183448756229</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L294" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L294" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2CHSlice%5BT%3A+Ordinal+or+float+or+float32+or+float64%2CT%3A+Ordinal+or+float+or+float32+or+float64%5D" data-language="nim">proc rand[T: Ordinal or SomeFloat](x: HSlice[T, T]): T</pre></dt> <dd> <p>For a slice <code>a..b</code>, returns a value in the range <code>a..b</code>.</p> <p>Allowed types for <code>T</code> are integers, floats, and enums without holes.</p> <p>If <a href="#randomize">randomize</a> has not been called, the sequence of random numbers returned from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,Rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice and uses a provided state</li> <li>
<a href="#rand,int">rand proc</a> that returns an integer</li> <li>
<a href="#rand,float">rand proc</a> that returns a floating point number</li> <li>
<a href="#rand,typedesc%5BT%5D">rand proc</a> that accepts an integer or range type</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">randomize(345)
doAssert rand(1..6) == 4
doAssert rand(1..6) == 4
doAssert rand(1..6) == 6</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L318" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L318" target="_blank">Edit</a> </dd>  <dt><pre id="rand%2Ctypedesc%5BT%5D" data-language="nim">proc rand[T: SomeInteger](t: typedesc[T]): T</pre></dt> <dd> <p>Returns a random integer in the range <code>low(T)..high(T)</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the sequence of random numbers returned from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#rand,int">rand proc</a> that returns an integer</li> <li>
<a href="#rand,float">rand proc</a> that returns a floating point number</li> <li>
<a href="#rand,HSlice%5BT,T%5D">rand proc</a> that accepts a slice</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">randomize(567)
doAssert rand(int8) == 55
doAssert rand(int8) == -42
doAssert rand(int8) == 43
doAssert rand(uint32) == 578980729'u32
doAssert rand(uint32) == 4052940463'u32
doAssert rand(uint32) == 2163872389'u32
doAssert rand(range[1..16]) == 11
doAssert rand(range[1..16]) == 4
doAssert rand(range[1..16]) == 16</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L342" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L342" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2CRand%2Cset%5BT%5D" data-language="nim">proc sample[T](r: var Rand; s: set[T]): T</pre></dt> <dd> <p>Returns a random element from the set <code>s</code> using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,set%5BT%5D">sample proc</a> that uses the default random number generator</li> <li>
<a href="#sample,Rand,openArray%5BT%5D">sample proc</a> for openarrays</li> <li>
<a href="#sample,Rand,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that uses a cumulative distribution function</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var r = initRand(987)
let s = {1, 3, 5, 7, 9}
doAssert r.sample(s) == 5
doAssert r.sample(s) == 7
doAssert r.sample(s) == 1</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L371" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L371" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2Cset%5BT%5D" data-language="nim">proc sample[T](s: set[T]): T</pre></dt> <dd> <p>Returns a random element from the set <code>s</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the order of outcomes from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,Rand,set%5BT%5D">sample proc</a> that uses a provided state</li> <li>
<a href="#sample,openArray%5BT%5D">sample proc</a> for openarrays</li> <li>
<a href="#sample,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that uses a cumulative distribution function</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">randomize(987)
let s = {1, 3, 5, 7, 9}
doAssert sample(s) == 5
doAssert sample(s) == 7
doAssert sample(s) == 1</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L392" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L392" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2CRand%2CopenArray%5BT%5D" data-language="nim">proc sample[T](r: var Rand; a: openArray[T]): T</pre></dt> <dd> <p>Returns a random element from <code>a</code> using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,openArray%5BT%5D">sample proc</a> that uses the default random number generator</li> <li>
<a href="#sample,Rand,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that uses a cumulative distribution function</li> <li>
<a href="#sample,Rand,set%5BT%5D">sample proc</a> for sets</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let marbles = ["red", "blue", "green", "yellow", "purple"]
var r = initRand(456)
doAssert r.sample(marbles) == "blue"
doAssert r.sample(marbles) == "yellow"
doAssert r.sample(marbles) == "red"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L414" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L414" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2CopenArray%5BT%5D" data-language="nim">proc sample[T](a: openArray[T]): T</pre></dt> <dd> <p>Returns a random element from <code>a</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the order of outcomes from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,Rand,openArray%5BT%5D">sample proc</a> that uses a provided state</li> <li>
<a href="#sample,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that uses a cumulative distribution function</li> <li>
<a href="#sample,set%5BT%5D">sample proc</a> for sets</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let marbles = ["red", "blue", "green", "yellow", "purple"]
randomize(456)
doAssert sample(marbles) == "blue"
doAssert sample(marbles) == "yellow"
doAssert sample(marbles) == "red"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L431" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L431" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2CRand%2CopenArray%5BT%5D%2CopenArray%5BU%5D" data-language="nim">proc sample[T, U](r: var Rand; a: openArray[T]; cdf: openArray[U]): T</pre></dt> <dd> <p>Returns an element from <code>a</code> using a cumulative distribution function (CDF) and the given state.</p> <p>The <code>cdf</code> argument does not have to be normalized, and it could contain any type of elements that can be converted to a <code>float</code>. It must be the same length as <code>a</code>. Each element in <code>cdf</code> should be greater than or equal to the previous element.</p> <p>The outcome of the <a href="math.html#cumsum,openArray%5BT%5D">cumsum</a> proc and the return value of the <a href="math.html#cumsummed,openArray%5BT%5D">cumsummed</a> proc, which are both in the math module, can be used as the <code>cdf</code> argument.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that also utilizes a CDF but uses the default random number generator</li> <li>
<a href="#sample,Rand,openArray%5BT%5D">sample proc</a> that does not use a CDF</li> <li>
<a href="#sample,Rand,set%5BT%5D">sample proc</a> for sets</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">from math import cumsummed

let marbles = ["red", "blue", "green", "yellow", "purple"]
let count = [1, 6, 8, 3, 4]
let cdf = count.cumsummed
var r = initRand(789)
doAssert r.sample(marbles, cdf) == "red"
doAssert r.sample(marbles, cdf) == "green"
doAssert r.sample(marbles, cdf) == "blue"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L453" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L453" target="_blank">Edit</a> </dd>  <dt><pre id="sample%2CopenArray%5BT%5D%2CopenArray%5BU%5D" data-language="nim">proc sample[T, U](a: openArray[T]; cdf: openArray[U]): T</pre></dt> <dd> <p>Returns an element from <code>a</code> using a cumulative distribution function (CDF).</p> <p>This proc works similarly to <a href="#sample,Rand,openArray%5BT%5D,openArray%5BU%5D">sample[T, U](Rand, openArray[T], openArray[U])</a>. See that proc's documentation for more details.</p> <p>If <a href="#randomize">randomize</a> has not been called, the order of outcomes from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#sample,Rand,openArray%5BT%5D,openArray%5BU%5D">sample proc</a> that also utilizes a CDF but uses a provided state</li> <li>
<a href="#sample,openArray%5BT%5D">sample proc</a> that does not use a CDF</li> <li>
<a href="#sample,set%5BT%5D">sample proc</a> for sets</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">from math import cumsummed

let marbles = ["red", "blue", "green", "yellow", "purple"]
let count = [1, 6, 8, 3, 4]
let cdf = count.cumsummed
randomize(789)
doAssert sample(marbles, cdf) == "red"
doAssert sample(marbles, cdf) == "green"
doAssert sample(marbles, cdf) == "blue"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L488" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L488" target="_blank">Edit</a> </dd>  <dt><pre id="gauss%2CRand%2Cfloat%2Cfloat" data-language="nim">proc gauss(r: var Rand; mu = 0.0; sigma = 1.0): float {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns a Gaussian random variate, with mean <code>mu</code> and standard deviation <code>sigma</code> using the given state. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L520" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L520" target="_blank">Edit</a> </dd>  <dt><pre id="gauss%2Cfloat%2Cfloat" data-language="nim">proc gauss(mu = 0.0; sigma = 1.0): float {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Returns a Gaussian random variate, with mean <code>mu</code> and standard deviation <code>sigma</code>.</p> <p>If <a href="#randomize">randomize</a> has not been called, the order of outcomes from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L536" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L536" target="_blank">Edit</a> </dd>  <dt><pre id="initRand%2Cint64" data-language="nim">proc initRand(seed: int64): Rand {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Initializes a new <a href="#Rand">Rand</a> state using the given seed.</p> <p><code>seed</code> must not be zero. Providing a specific seed will produce the same results for that seed each time.</p> <p>The resulting state is independent of the default random number generator's state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#randomize,int64">randomize proc</a> that accepts a seed for the default random number generator</li> <li>
<a href="#randomize">randomize proc</a> that initializes the default random number generator using the current time</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">from times import getTime, toUnix, nanosecond

var r1 = initRand(123)

let now = getTime()
var r2 = initRand(now.toUnix * 1_000_000_000 + now.nanosecond)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L547" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L547" target="_blank">Edit</a> </dd>  <dt><pre id="randomize%2Cint64" data-language="nim">proc randomize(seed: int64) {...}{.gcsafe, locks: 0, raises: [], tags: [].}</pre></dt> <dd> <p>Initializes the default random number generator with the given seed.</p> <p><code>seed</code> must not be zero. Providing a specific seed will produce the same results for that seed each time.</p> <p>See also:</p> <ul class="simple">
<li><a href="#initRand,int64">initRand proc</a></li> <li>
<a href="#randomize">randomize proc</a> that uses the current time instead</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">from times import getTime, toUnix, nanosecond

randomize(123)

let now = getTime()
randomize(now.toUnix * 1_000_000_000 + now.nanosecond)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L573" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L573" target="_blank">Edit</a> </dd>  <dt><pre id="shuffle%2CRand%2CopenArray%5BT%5D" data-language="nim">proc shuffle[T](r: var Rand; x: var openArray[T])</pre></dt> <dd> <p>Shuffles a sequence of elements in-place using the given state.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#shuffle,openArray%5BT%5D">shuffle proc</a> that uses the default random number generator</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
var r = initRand(678)
r.shuffle(cards)
doAssert cards == ["King", "Ace", "Queen", "Ten", "Jack"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L591" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L591" target="_blank">Edit</a> </dd>  <dt><pre id="shuffle%2CopenArray%5BT%5D" data-language="nim">proc shuffle[T](x: var openArray[T])</pre></dt> <dd> <p>Shuffles a sequence of elements in-place.</p> <p>If <a href="#randomize">randomize</a> has not been called, the order of outcomes from this proc will always be the same.</p> <p>This proc uses the default random number generator. Thus, it is <strong>not</strong> thread-safe.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#shuffle,Rand,openArray%5BT%5D">shuffle proc</a> that uses a provided state</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var cards = ["Ace", "King", "Queen", "Jack", "Ten"]
randomize(678)
shuffle(cards)
doAssert cards == ["King", "Ace", "Queen", "Ten", "Jack"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L606" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L606" target="_blank">Edit</a> </dd>  <dt><pre id="randomize" data-language="nim">proc randomize() {...}{.gcsafe, locks: 0, raises: [], tags: [TimeEffect].}</pre></dt> <dd> <p>Initializes the default random number generator with a value based on the current time.</p> <p>This proc only needs to be called once, and it should be called before the first usage of procs from this module that use the default random number generator.</p> <p><strong>Note:</strong> Does not work for NimScript.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#randomize,int64">randomize proc</a> that accepts a seed</li> <li><a href="#initRand,int64">initRand proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/random.nim#L627" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/random.nim#L627" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/random.html" class="_attribution-link">https://nim-lang.org/docs/random.html</a>
  </p>
</div>
