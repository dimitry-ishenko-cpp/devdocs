<h1 class="title">std/algorithm</h1> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L1" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L1" target="_blank">Edit</a>  <p class="module-desc">This module implements some common generic algorithms on <code><span class="Identifier">openArray</span></code>s. </p>
<h2 id="basic-usage">Basic usage</h2> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import std/algorithm
type People = tuple
  year: int
  name: string

var a: seq[People]

a.add((2000, "John"))
a.add((2005, "Marie"))
a.add((2010, "Jane"))

# Sorting with default system.cmp
a.sort()
assert a == @[(year: 2000, name: "John"), (year: 2005, name: "Marie"),
              (year: 2010, name: "Jane")]

proc myCmp(x, y: People): int =
  cmp(x.name, y.name)

# Sorting with custom proc
a.sort(myCmp)
assert a == @[(year: 2010, name: "Jane"), (year: 2000, name: "John"),
              (year: 2005, name: "Marie")]</pre> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="sequtils.html">sequtils module</a> for working with the built-in seq type</li> <li>
<a href="tables.html">tables module</a> for sorting tables</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a> </dl>   <h2 id="7">Types</h2> <dl> <div id="SortOrder"> <dt><pre data-language="nim">SortOrder = enum
  Descending, Ascending</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L52" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L52" target="_blank">Edit</a> </dd> </div> </dl>   <h2 id="12">Procs</h2> <dl> <div id="*-procs-all"> <div id="*,int,SortOrder"> <dt><pre data-language="nim">proc `*`(x: int; order: SortOrder): int {.inline, ...raises: [], tags: [],
    forbids: [].}</pre></dt> <dd> <p>Flips the sign of <code><span class="Identifier">x</span></code> if <code><span class="Identifier">order</span> <span class="Operator">==</span> <span class="Identifier">Descending</span></code>. If <code><span class="Identifier">order</span> <span class="Operator">==</span> <span class="Identifier">Ascending</span></code> then <code><span class="Identifier">x</span></code> is returned.</p> <p><code><span class="Identifier">x</span></code> is supposed to be the result of a comparator, i.e.</p>
<p><code><span class="Operator">&lt;</span> <span class="DecNumber">0</span></code> for <em>less than</em>,<br><code><span class="Operator">==</span> <span class="DecNumber">0</span></code> for <em>equal</em>,<br><code><span class="Operator">&gt;</span> <span class="DecNumber">0</span></code> for <em>greater than</em>.<br></p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert -123 * Descending == 123
assert 123 * Descending == -123
assert -123 * Ascending == -123
assert 123 * Ascending == 123</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L55" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L55" target="_blank">Edit</a> </dd> </div> </div> <div id="binarySearch-procs-all"> <div id="binarySearch,openArray[T],K,proc(T,K)"> <dt><pre data-language="nim">proc binarySearch[T, K](a: openArray[T]; key: K;
                        cmp: proc (x: T; y: K): int {.closure.}): int {.
    effectsOf: cmp.}</pre></dt> <dd> <p>Binary search for <code><span class="Identifier">key</span></code> in <code><span class="Identifier">a</span></code>. Return the index of <code><span class="Identifier">key</span></code> or -1 if not found. Assumes that <code><span class="Identifier">a</span></code> is sorted according to <code><span class="Identifier">cmp</span></code>.</p> <p><code><span class="Identifier">cmp</span></code> is the comparator function to use, the expected return values are the same as those of system.cmp.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert binarySearch(["a", "b", "c", "d"], "d", system.cmp[string]) == 3
assert binarySearch(["a", "b", "c", "d"], "c", system.cmp[string]) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L159" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L159" target="_blank">Edit</a> </dd> </div> <div id="binarySearch,openArray[T],T"> <dt><pre data-language="nim">proc binarySearch[T](a: openArray[T]; key: T): int</pre></dt> <dd> Binary search for <code><span class="Identifier">key</span></code> in <code><span class="Identifier">a</span></code>. Return the index of <code><span class="Identifier">key</span></code> or -1 if not found. Assumes that <code><span class="Identifier">a</span></code> is sorted. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert binarySearch([0, 1, 2, 3, 4], 4) == 4
assert binarySearch([0, 1, 2, 3, 4], 2) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L210" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L210" target="_blank">Edit</a> </dd> </div> </div> <div id="fill-procs-all"> <div id="fill,openArray[T],Natural,Natural,T"> <dt><pre data-language="nim">proc fill[T](a: var openArray[T]; first, last: Natural; value: T)</pre></dt> <dd> <p>Assigns <code><span class="Identifier">value</span></code> to all elements of the slice <code><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">first</span><span class="Operator">..</span><span class="Identifier">last</span><span class="Punctuation">]</span></code>.</p> <p>If an invalid range is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a: array[6, int]
a.fill(1, 3, 9)
assert a == [0, 9, 9, 9, 0, 0]
a.fill(3, 5, 7)
assert a == [0, 9, 9, 7, 7, 7]
doAssertRaises(IndexDefect, a.fill(1, 7, 9))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L77" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L77" target="_blank">Edit</a> </dd> </div> <div id="fill,openArray[T],T"> <dt><pre data-language="nim">proc fill[T](a: var openArray[T]; value: T)</pre></dt> <dd> Assigns <code><span class="Identifier">value</span></code> to all elements of the container <code><span class="Identifier">a</span></code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a: array[6, int]
a.fill(9)
assert a == [9, 9, 9, 9, 9, 9]
a.fill(4)
assert a == [4, 4, 4, 4, 4, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L90" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L90" target="_blank">Edit</a> </dd> </div> </div> <div id="isSorted-procs-all"> <div id="isSorted,openArray[T],proc(T,T)"> <dt><pre data-language="nim">func isSorted[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};
                 order = SortOrder.Ascending): bool {.effectsOf: cmp.}</pre></dt> <dd> <p>Checks to see whether <code><span class="Identifier">a</span></code> is already sorted in <code><span class="Identifier">order</span></code> using <code><span class="Identifier">cmp</span></code> for the comparison. The parameters are identical to <code><span class="Identifier">sort</span></code>. Requires O(n) time.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#isSorted,openArray[T]">isSorted proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L507" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L507" target="_blank">Edit</a> </dd> </div> <div id="isSorted,openArray[T]"> <dt><pre data-language="nim">proc isSorted[T](a: openArray[T]; order = SortOrder.Ascending): bool</pre></dt> <dd> <p>Shortcut version of <code><span class="Identifier">isSorted</span></code> that uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#isSorted,openArray[T],proc(T,T)">isSorted func</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L534" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L534" target="_blank">Edit</a> </dd> </div> </div> <div id="lowerBound-procs-all"> <div id="lowerBound,openArray[T],K,proc(T,K)"> <dt><pre data-language="nim">proc lowerBound[T, K](a: openArray[T]; key: K;
                      cmp: proc (x: T; k: K): int {.closure.}): int {.
    effectsOf: cmp.}</pre></dt> <dd> <p>Returns the index of the first element in <code><span class="Identifier">a</span></code> that is not less than (i.e. greater or equal to) <code><span class="Identifier">key</span></code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code><span class="Identifier">insert</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">,</span> <span class="Identifier">lowerBound</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code> the sequence will still be sorted. Assumes that <code><span class="Identifier">a</span></code> is sorted according to <code><span class="Identifier">cmp</span></code>.</p> <p>If an invalid range is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <p>This version uses <code><span class="Identifier">cmp</span></code> to compare the elements. The expected return values are the same as those of <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#upperBound,openArray[T],K,proc(T,K)">upperBound proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#upperBound,openArray[T],T">upperBound proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.lowerBound(3, system.cmp[int]) == 2
assert arr.lowerBound(4, system.cmp[int]) == 3
assert arr.lowerBound(5, system.cmp[int]) == 3
arr.insert(4, arr.lowerBound(4, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L221" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L221" target="_blank">Edit</a> </dd> </div> <div id="lowerBound,openArray[T],T"> <dt><pre data-language="nim">proc lowerBound[T](a: openArray[T]; key: T): int</pre></dt> <dd> <p>Returns the index of the first element in <code><span class="Identifier">a</span></code> that is not less than (i.e. greater or equal to) <code><span class="Identifier">key</span></code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code><span class="Identifier">insert</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">,</span> <span class="Identifier">lowerBound</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code> the sequence will still be sorted. Assumes that <code><span class="Identifier">a</span></code> is sorted.</p> <p>This version uses the default comparison function <code><span class="Identifier">cmp</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#upperBound,openArray[T],K,proc(T,K)">upperBound proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#upperBound,openArray[T],T">upperBound proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L257" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L257" target="_blank">Edit</a> </dd> </div> </div> <div id="merge-procs-all"> <div id="merge,seq[T],openArray[T],openArray[T]"> <dt><pre data-language="nim">proc merge[T](result: var seq[T]; x, y: openArray[T]) {.inline.}</pre></dt> <dd> <p>Shortcut version of <code><span class="Identifier">merge</span></code> that uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#merge,seq[T],openArray[T],openArray[T],proc(T,T)">merge proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = [5, 10, 15, 20, 25]
let y = [50, 40, 30, 20, 10].sorted

var merged: seq[int]
merged.merge(x, y)
assert merged.isSorted
assert merged == @[5, 10, 10, 15, 20, 20, 25, 30, 40, 50]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L631" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L631" target="_blank">Edit</a> </dd> </div> <div id="merge,seq[T],openArray[T],openArray[T],proc(T,T)"> <dt><pre data-language="nim">proc merge[T](result: var seq[T]; x, y: openArray[T];
              cmp: proc (x, y: T): int {.closure.}) {.effectsOf: cmp.}</pre></dt> <dd> Merges two sorted <code><span class="Identifier">openArray</span></code>. <code><span class="Identifier">x</span></code> and <code><span class="Identifier">y</span></code> are assumed to be sorted. If you do not wish to provide your own <code><span class="Identifier">cmp</span></code>, you may use <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code> or instead call the overloaded version of <code><span class="Identifier">merge</span></code>, which uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code>.<div class="admonition admonition-info">
<span class="admonition-info-text"><b>Note:</b></span> The original data of <code><span class="Identifier">result</span></code> is not cleared, new data is appended to <code><span class="Identifier">result</span></code>.</div> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#merge,seq[T],openArray[T],openArray[T]">merge proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = @[1, 3, 6]
let y = @[2, 3, 4]

block:
  var merged = @[7] # new data is appended to merged sequence
  merged.merge(x, y, system.cmp[int])
  assert merged == @[7, 1, 2, 3, 3, 4, 6]

block:
  var merged = @[7] # if you only want new data, clear merged sequence first
  merged.setLen(0)
  merged.merge(x, y, system.cmp[int])
  assert merged.isSorted
  assert merged == @[1, 2, 3, 3, 4, 6]

import std/sugar

var res: seq[(int, int)]
res.merge([(1, 1)], [(1, 2)], (a, b) =&gt; a[0] - b[0])
assert res == @[(1, 1), (1, 2)]

assert seq[int].default.dup(merge([1, 3], [2, 4])) == @[1, 2, 3, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L554" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L554" target="_blank">Edit</a> </dd> </div> </div> <div id="nextPermutation-procs-all"> <div id="nextPermutation,openArray[T]"> <dt><pre data-language="nim">proc nextPermutation[T](x: var openArray[T]): bool {.discardable.}</pre></dt> <dd> <p>Calculates the next lexicographic permutation, directly modifying <code><span class="Identifier">x</span></code>. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.</p> <p>If you start with an unsorted array/seq, the repeated permutations will <strong>not</strong> give you all permutations but stop with the last.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#prevPermutation,openArray[T]">prevPermutation proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var v = @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.nextPermutation() == true
assert v == @[0, 2, 1, 3]
assert v.prevPermutation() == true
assert v == @[0, 1, 3, 2]
v = @[3, 2, 1, 0]
assert v.nextPermutation() == false
assert v == @[3, 2, 1, 0]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L683" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L683" target="_blank">Edit</a> </dd> </div> </div> <div id="prevPermutation-procs-all"> <div id="prevPermutation,openArray[T]"> <dt><pre data-language="nim">proc prevPermutation[T](x: var openArray[T]): bool {.discardable.}</pre></dt> <dd> <p>Calculates the previous lexicographic permutation, directly modifying <code><span class="Identifier">x</span></code>. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#nextPermutation,openArray[T]">nextPermutation proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var v = @[0, 1, 2, 3]
assert v.prevPermutation() == false
assert v == @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.prevPermutation() == true
assert v == @[0, 1, 2, 3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L723" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L723" target="_blank">Edit</a> </dd> </div> </div> <div id="product-procs-all"> <div id="product,openArray[seq[T]]"> <dt><pre data-language="nim">proc product[T](x: openArray[seq[T]]): seq[seq[T]]</pre></dt> <dd> Produces the Cartesian product of the array. Every element of the result is a combination of one element from each seq in <code><span class="Identifier">x</span></code>, with the ith element coming from <code><span class="Identifier">x</span><span class="Punctuation">[</span><span class="Identifier">i</span><span class="Punctuation">]</span></code>.<div class="admonition admonition-warning">
<span class="admonition-warning-text"><b>Warning:</b></span> complexity may explode.</div> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert product(@[@[1], @[2]]) == @[@[1, 2]]
assert product(@[@["A", "K"], @["Q"]]) == @[@["K", "Q"], @["A", "Q"]]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L646" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L646" target="_blank">Edit</a> </dd> </div> </div> <div id="reverse-procs-all"> <div id="reverse,openArray[T]"> <dt><pre data-language="nim">proc reverse[T](a: var openArray[T])</pre></dt> <dd> <p>Reverses the contents of the container <code><span class="Identifier">a</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reversed,openArray[T],Natural,int">reversed proc</a> reverse a slice and returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> <li>
<a href="#reversed,openArray[T]">reversed proc</a> reverse and returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5, 6]
a.reverse()
assert a == [6, 5, 4, 3, 2, 1]
a.reverse()
assert a == [1, 2, 3, 4, 5, 6]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L123" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L123" target="_blank">Edit</a> </dd> </div> <div id="reverse,openArray[T],Natural,Natural"> <dt><pre data-language="nim">proc reverse[T](a: var openArray[T]; first, last: Natural)</pre></dt> <dd> <p>Reverses the slice <code><span class="Identifier">a</span><span class="Punctuation">[</span><span class="Identifier">first</span><span class="Operator">..</span><span class="Identifier">last</span><span class="Punctuation">]</span></code>.</p> <p>If an invalid range is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reversed,openArray[T],Natural,int">reversed proc</a> reverse a slice and returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> <li>
<a href="#reversed,openArray[T]">reversed proc</a> reverse and returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5, 6]
a.reverse(1, 3)
assert a == [1, 4, 3, 2, 5, 6]
a.reverse(1, 3)
assert a == [1, 2, 3, 4, 5, 6]
doAssertRaises(IndexDefect, a.reverse(1, 7))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L101" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L101" target="_blank">Edit</a> </dd> </div> </div> <div id="reversed-procs-all"> <div id="reversed,openArray[T]"> <dt><pre data-language="nim">proc reversed[T](a: openArray[T]): seq[T] {.inline.}</pre></dt> <dd> <p>Returns the elements of <code><span class="Identifier">a</span></code> in reverse order.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#reverse,openArray[T]">reverse proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert [10, 11, 12].reversed == @[12, 11, 10]
assert seq[string].default.reversed == @[]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L138" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L138" target="_blank">Edit</a> </dd> </div> <div id="reversed,openArray[T],Natural,int"> <dt><pre data-language="nim">proc reversed[T](a: openArray[T]; first: Natural; last: int): seq[T] {.inline,
    ...deprecated: "use: `reversed(toOpenArray(a, first, last))`".}</pre></dt> <dd> <div class="deprecation-message"> <b>Deprecated:</b> use: `reversed(toOpenArray(a, first, last))` </div> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L150" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L150" target="_blank">Edit</a> </dd> </div> </div> <div id="rotatedLeft-procs-all"> <div id="rotatedLeft,openArray[T],int"> <dt><pre data-language="nim">proc rotatedLeft[T](arg: openArray[T]; dist: int): seq[T]</pre></dt> <dd> <p>Same as <code><span class="Identifier">rotateLeft</span></code>, just with the difference that it does not modify the argument. It creates a new <code><span class="Identifier">seq</span></code> instead.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray[T],int">rotateLeft proc</a> for the in-place version of this proc</li> <li>
<a href="#rotatedLeft,openArray[T],HSlice[int,int],int">rotatedLeft proc</a> for a version which rotates a range</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 2)
assert a == @[3, 4, 5, 1, 2]
a = rotatedLeft(a, 4)
assert a == @[2, 3, 4, 5, 1]
a = rotatedLeft(a, -6)
assert a == @[1, 2, 3, 4, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L900" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L900" target="_blank">Edit</a> </dd> </div> <div id="rotatedLeft,openArray[T],HSlice[int,int],int"> <dt><pre data-language="nim">proc rotatedLeft[T](arg: openArray[T]; slice: HSlice[int, int]; dist: int): seq[
    T]</pre></dt> <dd> <p>Same as <code><span class="Identifier">rotateLeft</span></code>, just with the difference that it does not modify the argument. It creates a new <code><span class="Identifier">seq</span></code> instead.</p> <p>Elements outside of <code><span class="Identifier">slice</span></code> will be left unchanged. If an invalid range (<code><span class="Identifier">HSlice</span></code>) is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <dl>
<dt><code><span class="Identifier">slice</span></code></dt> <dd>The indices of the element range that should be rotated.</dd> <dt><code><span class="Identifier">dist</span></code></dt> <dd>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</dd> </dl> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray[T],HSlice[int,int],int">rotateLeft proc</a> for the in-place version of this proc</li> <li>
<a href="#rotatedLeft,openArray[T],int">rotatedLeft proc</a> for a version which rotates the whole container</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 1 .. 4, 3)
assert a == @[1, 5, 2, 3, 4]
a = rotatedLeft(a, 1 .. 3, 2)
assert a == @[1, 3, 5, 2, 4]
a = rotatedLeft(a, 1 .. 3, -2)
assert a == @[1, 5, 2, 3, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L870" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L870" target="_blank">Edit</a> </dd> </div> </div> <div id="rotateLeft-procs-all"> <div id="rotateLeft,openArray[T],int"> <dt><pre data-language="nim">proc rotateLeft[T](arg: var openArray[T]; dist: int): int {.discardable.}</pre></dt> <dd> <p>Same as <code><span class="Identifier">rotateLeft</span></code>, but with default arguments for slice, so that this procedure operates on the entire <code><span class="Identifier">arg</span></code>, and not just on a part of it.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray[T],HSlice[int,int],int">rotateLeft proc</a> for a version which rotates a range</li> <li>
<a href="#rotatedLeft,openArray[T],int">rotatedLeft proc</a> for a version which returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5]
a.rotateLeft(2)
assert a == [3, 4, 5, 1, 2]
a.rotateLeft(4)
assert a == [2, 3, 4, 5, 1]
a.rotateLeft(-6)
assert a == [1, 2, 3, 4, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L850" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L850" target="_blank">Edit</a> </dd> </div> <div id="rotateLeft,openArray[T],HSlice[int,int],int"> <dt><pre data-language="nim">proc rotateLeft[T](arg: var openArray[T]; slice: HSlice[int, int]; dist: int): int {.
    discardable.}</pre></dt> <dd> Performs a left rotation on a range of elements. If you want to rotate right, use a negative <code><span class="Identifier">dist</span></code>. Specifically, <code><span class="Identifier">rotateLeft</span></code> rotates the elements at <code><span class="Identifier">slice</span></code> by <code><span class="Identifier">dist</span></code> positions.<p>The element at index <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">dist</span></code> will be at index <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span></code>.<br>The element at index <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">b</span></code> will be at <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">dist</span> <span class="Operator">-</span> <span class="DecNumber">1</span></code>.<br>The element at index <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span></code> will be at <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">+</span> <span class="DecNumber">1</span> <span class="Operator">-</span> <span class="Identifier">dist</span></code>.<br>The element at index <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="Identifier">dist</span> <span class="Operator">-</span> <span class="DecNumber">1</span></code> will be at <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">b</span></code>.<br></p>
<p>Elements outside of <code><span class="Identifier">slice</span></code> will be left unchanged. The time complexity is linear to <code><span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">b</span> <span class="Operator">-</span> <span class="Identifier">slice</span><span class="Operator">.</span><span class="Identifier">a</span> <span class="Operator">+</span> <span class="DecNumber">1</span></code>. If an invalid range (<code><span class="Identifier">HSlice</span></code>) is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <dl>
<dt><code><span class="Identifier">slice</span></code></dt> <dd>The indices of the element range that should be rotated.</dd> <dt><code><span class="Identifier">dist</span></code></dt> <dd>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</dd> </dl> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray[T],int">rotateLeft proc</a> for a version which rotates the whole container</li> <li>
<a href="#rotatedLeft,openArray[T],HSlice[int,int],int">rotatedLeft proc</a> for a version which returns a <code><span class="Identifier">seq</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [0, 1, 2, 3, 4, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 4, 1, 2, 3, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 3, 4, 1, 2, 5]
a.rotateLeft(1 .. 4, -3)
assert a == [0, 4, 1, 2, 3, 5]
doAssertRaises(IndexDefect, a.rotateLeft(1 .. 7, 2))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L812" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L812" target="_blank">Edit</a> </dd> </div> </div> <div id="sort-procs-all"> <div id="sort,openArray[T],proc(T,T)"> <dt><pre data-language="nim">func sort[T](a: var openArray[T]; cmp: proc (x, y: T): int {.closure.};
             order = SortOrder.Ascending) {.effectsOf: cmp.}</pre></dt> <dd> <p>Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable (that is, equal elements stay in the same order) and the worst case is guaranteed to be O(n log n). Sorts by <code><span class="Identifier">cmp</span></code> in the specified <code><span class="Identifier">order</span></code>.</p> <p>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length <code><span class="Identifier">a</span><span class="Operator">.</span><span class="Identifier">len</span> <span class="Keyword">div</span> <span class="DecNumber">2</span></code>. If you do not wish to provide your own <code><span class="Identifier">cmp</span></code>, you may use <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code> or instead call the overloaded version of <code><span class="Identifier">sort</span></code>, which uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code>.</p> 
<pre class="listing" data-language="nim">sort(myIntArray, system.cmp[int])
# do not use cmp[string] here as we want to use the specialized
# overload:
sort(myStrArray, system.cmp)</pre> <p>You can inline adhoc comparison procs with the <a href="manual_experimental.html#do-notation">do notation</a>. Example:</p> 
<pre class="listing" data-language="nim">people.sort do (x, y: Person) -&gt; int:
  result = cmp(x.surname, y.surname)
  if result == 0:
    result = cmp(x.name, y.name)</pre> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray[T]">sort proc</a></li> <li>
<a href="#sorted,openArray[T],proc(T,T)">sorted proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#sorted,openArray[T]">sorted proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var d = ["boo", "fo", "barr", "qux"]
proc myCmp(x, y: string): int =
  if x.len() &gt; y.len() or x.len() == y.len(): 1
  else: -1
sort(d, myCmp)
assert d == ["fo", "qux", "boo", "barr"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L368" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L368" target="_blank">Edit</a> </dd> </div> <div id="sort,openArray[T]"> <dt><pre data-language="nim">proc sort[T](a: var openArray[T]; order = SortOrder.Ascending)</pre></dt> <dd> <p>Shortcut version of <code><span class="Identifier">sort</span></code> that uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray[T],proc(T,T)">sort func</a></li> <li>
<a href="#sorted,openArray[T],proc(T,T)">sorted proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#sorted,openArray[T]">sorted proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L421" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L421" target="_blank">Edit</a> </dd> </div> </div> <div id="sorted-procs-all"> <div id="sorted,openArray[T],proc(T,T)"> <dt><pre data-language="nim">proc sorted[T](a: openArray[T]; cmp: proc (x, y: T): int {.closure.};
               order = SortOrder.Ascending): seq[T] {.effectsOf: cmp.}</pre></dt> <dd> <p>Returns <code><span class="Identifier">a</span></code> sorted by <code><span class="Identifier">cmp</span></code> in the specified <code><span class="Identifier">order</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray[T],proc(T,T)">sort func</a></li> <li><a href="#sort,openArray[T]">sort proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = sorted(a, system.cmp[int])
  c = sorted(a, system.cmp[int], Descending)
  d = sorted(["adam", "dande", "brian", "cat"], system.cmp[string])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L431" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L431" target="_blank">Edit</a> </dd> </div> <div id="sorted,openArray[T]"> <dt><pre data-language="nim">proc sorted[T](a: openArray[T]; order = SortOrder.Ascending): seq[T]</pre></dt> <dd> <p>Shortcut version of <code><span class="Identifier">sorted</span></code> that uses <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span><span class="Punctuation">[</span><span class="Identifier">T</span><span class="Punctuation">]</span></code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray[T],proc(T,T)">sort func</a></li> <li><a href="#sort,openArray[T]">sort proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = sorted(a)
  c = sorted(a, Descending)
  d = sorted(["adam", "dande", "brian", "cat"])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L453" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L453" target="_blank">Edit</a> </dd> </div> </div> <div id="upperBound-procs-all"> <div id="upperBound,openArray[T],K,proc(T,K)"> <dt><pre data-language="nim">proc upperBound[T, K](a: openArray[T]; key: K;
                      cmp: proc (x: T; k: K): int {.closure.}): int {.
    effectsOf: cmp.}</pre></dt> <dd> <p>Returns the index of the first element in <code><span class="Identifier">a</span></code> that is greater than <code><span class="Identifier">key</span></code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code><span class="Identifier">insert</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">,</span> <span class="Identifier">upperBound</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code> the sequence will still be sorted. Assumes that <code><span class="Identifier">a</span></code> is sorted according to <code><span class="Identifier">cmp</span></code>.</p> <p>If an invalid range is passed, it raises <code><span class="Identifier">IndexDefect</span></code>.</p> <p>This version uses <code><span class="Identifier">cmp</span></code> to compare the elements. The expected return values are the same as those of <code><span class="Identifier">system</span><span class="Operator">.</span><span class="Identifier">cmp</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#lowerBound,openArray[T],K,proc(T,K)">lowerBound proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#lowerBound,openArray[T],T">lowerBound proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.upperBound(2, system.cmp[int]) == 2
assert arr.upperBound(3, system.cmp[int]) == 3
assert arr.upperBound(4, system.cmp[int]) == 3
arr.insert(4, arr.upperBound(3, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L271" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L271" target="_blank">Edit</a> </dd> </div> <div id="upperBound,openArray[T],T"> <dt><pre data-language="nim">proc upperBound[T](a: openArray[T]; key: T): int</pre></dt> <dd> <p>Returns the index of the first element in <code><span class="Identifier">a</span></code> that is greater than <code><span class="Identifier">key</span></code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code><span class="Identifier">insert</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">,</span> <span class="Identifier">upperBound</span><span class="Punctuation">(</span><span class="Identifier">thing</span><span class="Punctuation">,</span> <span class="Identifier">elm</span><span class="Punctuation">)</span><span class="Punctuation">)</span></code> the sequence will still be sorted. Assumes that <code><span class="Identifier">a</span></code> is sorted.</p> <p>This version uses the default comparison function <code><span class="Identifier">cmp</span></code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#lowerBound,openArray[T],K,proc(T,K)">lowerBound proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#lowerBound,openArray[T],T">lowerBound proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L307" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L307" target="_blank">Edit</a> </dd> </div> </div> </dl>   <h2 id="18">Templates</h2> <dl> <div id="sortedByIt-templates-all"> <div id="sortedByIt.t,untyped,untyped"> <dt><pre data-language="nim">template sortedByIt(seq1, op: untyped): untyped</pre></dt> <dd> <p>Convenience template around the <code><span class="Identifier">sorted</span></code> proc to reduce typing.</p> <p>The template injects the <code><span class="Identifier">it</span></code> variable which you can use directly in an expression.</p> <p>Because the underlying <code><span class="Identifier">cmp</span><span class="Punctuation">(</span><span class="Punctuation">)</span></code> is defined for tuples you can also do a nested sort.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray[T],proc(T,T)">sort func</a></li> <li><a href="#sort,openArray[T]">sort proc</a></li> <li>
<a href="#sorted,openArray[T],proc(T,T)">sorted proc</a> sorted by <code><span class="Identifier">cmp</span></code> in the specified order</li> <li><a href="#sorted,openArray[T]">sorted proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type Person = tuple[name: string, age: int]
var
  p1: Person = (name: "p1", age: 60)
  p2: Person = (name: "p2", age: 20)
  p3: Person = (name: "p3", age: 30)
  p4: Person = (name: "p4", age: 30)
  people = @[p1, p2, p4, p3]

assert people.sortedByIt(it.name) == @[(name: "p1", age: 60), (name: "p2",
    age: 20), (name: "p3", age: 30), (name: "p4", age: 30)]
# Nested sort
assert people.sortedByIt((it.age, it.name)) == @[(name: "p2", age: 20),
   (name: "p3", age: 30), (name: "p4", age: 30), (name: "p1", age: 60)]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-2-0/lib/pure/algorithm.nim#L471" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L471" target="_blank">Edit</a> </dd> </div> </div> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2024 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/algorithm.html" class="_attribution-link">https://nim-lang.org/docs/algorithm.html</a>
  </p>
</div>
