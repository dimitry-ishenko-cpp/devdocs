<h1 class="title">algorithm</h1>  <p class="module-desc">This module implements some common generic algorithms. </p>
<h2 id="basic-usage">Basic usage</h2>
<pre class="listing" data-language="nim">import algorithm

type People = tuple
  year: int
  name: string

var a: seq[People]

a.add((2000, "John"))
a.add((2005, "Marie"))
a.add((2010, "Jane"))

# Sorting with default system.cmp
a.sort()
assert a == @[(year: 2000, name: "John"), (year: 2005, name: "Marie"),
              (year: 2010, name: "Jane")]

proc myCmp(x, y: People): int =
  if x.name &lt; y.name: -1
  elif x.name == y.name: 0
  else: 1

# Sorting with custom proc
a.sort(myCmp)
assert a == @[(year: 2010, name: "Jane"), (year: 2000, name: "John"),
              (year: 2005, name: "Marie")]</pre> <h2 id="see-also">See also</h2>
<ul class="simple">
<li>
<a href="sequtils.html">sequtils module</a> for working with the built-in seq type</li> <li>
<a href="tables.html">tables module</a> for sorting tables</li> </ul>  <h2 id="7">Types</h2> <dl>  <dt><pre id="SortOrder" data-language="nim">SortOrder = enum
  Descending, Ascending</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L50" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L50" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="%2A%2Cint%2CSortOrder" data-language="nim">proc `*`(x: int; order: SortOrder): int {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>Flips <code>x</code> if <code>order == Descending</code>. If <code>order == Ascending</code> then <code>x</code> is returned.</p> <p><code>x</code> is supposed to be the result of a comparator, i.e.</p>
<p><code>&lt; 0</code> for <em>less than</em>,<br><code>== 0</code> for <em>equal</em>,<br><code>&gt; 0</code> for <em>greater than</em>.<br></p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert `*`(-123, Descending) == 123
assert `*`(123, Descending) == -123
assert `*`(-123, Ascending) == -123
assert `*`(123, Ascending) == 123</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L53" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L53" target="_blank">Edit</a> </dd>  <dt><pre id="fill%2CopenArray%5BT%5D%2CNatural%2CNatural%2CT" data-language="nim">proc fill[T](a: var openArray[T]; first, last: Natural; value: T)</pre></dt> <dd> <p>Fills the slice <code>a[first..last]</code> with <code>value</code>.</p> <p>If an invalid range is passed, it raises IndexDefect.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a: array[6, int]
a.fill(1, 3, 9)
assert a == [0, 9, 9, 9, 0, 0]
a.fill(3, 5, 7)
assert a == [0, 9, 9, 7, 7, 7]
doAssertRaises(IndexDefect, a.fill(1, 7, 9))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L75" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L75" target="_blank">Edit</a> </dd>  <dt><pre id="fill%2CopenArray%5BT%5D%2CT" data-language="nim">proc fill[T](a: var openArray[T]; value: T)</pre></dt> <dd> Fills the container <code>a</code> with <code>value</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a: array[6, int]
a.fill(9)
assert a == [9, 9, 9, 9, 9, 9]
a.fill(4)
assert a == [4, 4, 4, 4, 4, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L88" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L88" target="_blank">Edit</a> </dd>  <dt><pre id="reverse%2CopenArray%5BT%5D%2CNatural%2CNatural" data-language="nim">proc reverse[T](a: var openArray[T]; first, last: Natural)</pre></dt> <dd> <p>Reverses the slice <code>a[first..last]</code>.</p> <p>If an invalid range is passed, it raises IndexDefect.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reversed,openArray%5BT%5D,Natural,int">reversed proc</a> reverse a slice and returns a <code>seq[T]</code>
</li> <li>
<a href="#reversed,openArray%5BT%5D">reversed proc</a> reverse and returns a <code>seq[T]</code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5, 6]
a.reverse(1, 3)
assert a == [1, 4, 3, 2, 5, 6]
a.reverse(1, 3)
assert a == [1, 2, 3, 4, 5, 6]
doAssertRaises(IndexDefect, a.reverse(1, 7))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L99" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L99" target="_blank">Edit</a> </dd>  <dt><pre id="reverse%2CopenArray%5BT%5D" data-language="nim">proc reverse[T](a: var openArray[T])</pre></dt> <dd> <p>Reverses the contents of the container <code>a</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reversed,openArray%5BT%5D,Natural,int">reversed proc</a> reverse a slice and returns a <code>seq[T]</code>
</li> <li>
<a href="#reversed,openArray%5BT%5D">reversed proc</a> reverse and returns a <code>seq[T]</code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5, 6]
a.reverse()
assert a == [6, 5, 4, 3, 2, 1]
a.reverse()
assert a == [1, 2, 3, 4, 5, 6]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L121" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L121" target="_blank">Edit</a> </dd>  <dt><pre id="reversed%2CopenArray%5BT%5D%2CNatural%2Cint" data-language="nim">proc reversed[T](a: openArray[T]; first: Natural; last: int): seq[T]</pre></dt> <dd> <p>Returns the reverse of the slice <code>a[first..last]</code>.</p> <p>If an invalid range is passed, it raises IndexDefect.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reverse,openArray%5BT%5D,Natural,Natural">reverse proc</a> reverse a slice</li> <li><a href="#reverse,openArray%5BT%5D">reverse proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [1, 2, 3, 4, 5, 6]
  b = a.reversed(1, 3)
assert b == @[4, 3, 2]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L135" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L135" target="_blank">Edit</a> </dd>  <dt><pre id="reversed%2CopenArray%5BT%5D" data-language="nim">proc reversed[T](a: openArray[T]): seq[T]</pre></dt> <dd> <p>Returns the reverse of the container <code>a</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#reverse,openArray%5BT%5D,Natural,Natural">reverse proc</a> reverse a slice</li> <li><a href="#reverse,openArray%5BT%5D">reverse proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [1, 2, 3, 4, 5, 6]
  b = reversed(a)
assert b == @[6, 5, 4, 3, 2, 1]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L157" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L157" target="_blank">Edit</a> </dd>  <dt><pre id="binarySearch%2CopenArray%5BT%5D%2CK%2Cproc%28T%2CK%29" data-language="nim">proc binarySearch[T, K](a: openArray[T]; key: K;
                        cmp: proc (x: T; y: K): int {...}{.closure.}): int</pre></dt> <dd> <p>Binary search for <code>key</code> in <code>a</code>. Returns -1 if not found.</p> <p><code>cmp</code> is the comparator function to use, the expected return values are the same as that of system.cmp.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert binarySearch(["a", "b", "c", "d"], "d", system.cmp[string]) == 3
assert binarySearch(["a", "b", "d", "c"], "d", system.cmp[string]) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L170" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L170" target="_blank">Edit</a> </dd>  <dt><pre id="binarySearch%2CopenArray%5BT%5D%2CT" data-language="nim">proc binarySearch[T](a: openArray[T]; key: T): int</pre></dt> <dd> Binary search for <code>key</code> in <code>a</code>. Returns -1 if not found. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert binarySearch([0, 1, 2, 3, 4], 4) == 4
assert binarySearch([0, 1, 4, 2, 3], 4) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L220" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L220" target="_blank">Edit</a> </dd>  <dt><pre id="lowerBound%2CopenArray%5BT%5D%2CK%2Cproc%28T%2CK%29" data-language="nim">proc lowerBound[T, K](a: openArray[T]; key: K;
                      cmp: proc (x: T; k: K): int {...}{.closure.}): int</pre></dt> <dd> <p>Returns a position to the first element in the <code>a</code> that is greater than <code>key</code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code>insert(thing, elm, lowerBound(thing, elm))</code> the sequence will still be sorted.</p> <p>If an invalid range is passed, it raises IndexDefect.</p> <p>The version uses <code>cmp</code> to compare the elements. The expected return values are the same as that of <code>system.cmp</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#upperBound,openArray%5BT%5D,K,proc(T,K)">upperBound proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#upperBound,openArray%5BT%5D,T">upperBound proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.lowerBound(3, system.cmp[int]) == 2
assert arr.lowerBound(4, system.cmp[int]) == 3
assert arr.lowerBound(5, system.cmp[int]) == 3
arr.insert(4, arr.lowerBound(4, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L230" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L230" target="_blank">Edit</a> </dd>  <dt><pre id="lowerBound%2CopenArray%5BT%5D%2CT" data-language="nim">proc lowerBound[T](a: openArray[T]; key: T): int</pre></dt> <dd> <p>Returns a position to the first element in the <code>a</code> that is greater than <code>key</code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code>insert(thing, elm, lowerBound(thing, elm))</code> the sequence will still be sorted.</p> <p>The version uses the default comparison function <code>cmp</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#upperBound,openArray%5BT%5D,K,proc(T,K)">upperBound proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#upperBound,openArray%5BT%5D,T">upperBound proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L265" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L265" target="_blank">Edit</a> </dd>  <dt><pre id="upperBound%2CopenArray%5BT%5D%2CK%2Cproc%28T%2CK%29" data-language="nim">proc upperBound[T, K](a: openArray[T]; key: K;
                      cmp: proc (x: T; k: K): int {...}{.closure.}): int</pre></dt> <dd> <p>Returns a position to the first element in the <code>a</code> that is not less (i.e. greater or equal to) than <code>key</code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code>insert(thing, elm, upperBound(thing, elm))</code> the sequence will still be sorted.</p> <p>If an invalid range is passed, it raises IndexDefect.</p> <p>The version uses <code>cmp</code> to compare the elements. The expected return values are the same as that of <code>system.cmp</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#lowerBound,openArray%5BT%5D,K,proc(T,K)">lowerBound proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#lowerBound,openArray%5BT%5D,T">lowerBound proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var arr = @[1, 2, 3, 5, 6, 7, 8, 9]
assert arr.upperBound(2, system.cmp[int]) == 2
assert arr.upperBound(3, system.cmp[int]) == 3
assert arr.upperBound(4, system.cmp[int]) == 3
arr.insert(4, arr.upperBound(3, system.cmp[int]))
assert arr == [1, 2, 3, 4, 5, 6, 7, 8, 9]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L278" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L278" target="_blank">Edit</a> </dd>  <dt><pre id="upperBound%2CopenArray%5BT%5D%2CT" data-language="nim">proc upperBound[T](a: openArray[T]; key: T): int</pre></dt> <dd> <p>Returns a position to the first element in the <code>a</code> that is not less (i.e. greater or equal to) than <code>key</code>, or last if no such element is found. In other words if you have a sorted sequence and you call <code>insert(thing, elm, upperBound(thing, elm))</code> the sequence will still be sorted.</p> <p>The version uses the default comparison function <code>cmp</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#lowerBound,openArray%5BT%5D,K,proc(T,K)">lowerBound proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#lowerBound,openArray%5BT%5D,T">lowerBound proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L313" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L313" target="_blank">Edit</a> </dd>  <dt><pre id="sort%2CopenArray%5BT%5D" data-language="nim">proc sort[T](a: var openArray[T]; order = SortOrder.Ascending)</pre></dt> <dd> <p>Shortcut version of <code>sort</code> that uses <code>system.cmp[T]</code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray%5BT%5D,proc(T,T)">sort func</a></li> <li>
<a href="#sorted,openArray%5BT%5D,proc(T,T)">sorted proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#sorted,openArray%5BT%5D">sorted proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L426" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L426" target="_blank">Edit</a> </dd>  <dt><pre id="sorted%2CopenArray%5BT%5D%2Cproc%28T%2CT%29" data-language="nim">proc sorted[T](a: openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
               order = SortOrder.Ascending): seq[T]</pre></dt> <dd> <p>Returns <code>a</code> sorted by <code>cmp</code> in the specified <code>order</code>.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray%5BT%5D,proc(T,T)">sort func</a></li> <li><a href="#sort,openArray%5BT%5D">sort proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = sorted(a, system.cmp[int])
  c = sorted(a, system.cmp[int], Descending)
  d = sorted(["adam", "dande", "brian", "cat"], system.cmp[string])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L436" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L436" target="_blank">Edit</a> </dd>  <dt><pre id="sorted%2CopenArray%5BT%5D" data-language="nim">proc sorted[T](a: openArray[T]; order = SortOrder.Ascending): seq[T]</pre></dt> <dd> <p>Shortcut version of <code>sorted</code> that uses <code>system.cmp[T]</code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray%5BT%5D,proc(T,T)">sort func</a></li> <li><a href="#sort,openArray%5BT%5D">sort proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = sorted(a)
  c = sorted(a, Descending)
  d = sorted(["adam", "dande", "brian", "cat"])
assert b == @[1, 2, 3, 4, 5]
assert c == @[5, 4, 3, 2, 1]
assert d == @["adam", "brian", "cat", "dande"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L458" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L458" target="_blank">Edit</a> </dd>  <dt><pre id="isSorted%2CopenArray%5BT%5D" data-language="nim">proc isSorted[T](a: openArray[T]; order = SortOrder.Ascending): bool</pre></dt> <dd> <p>Shortcut version of <code>isSorted</code> that uses <code>system.cmp[T]</code> as the comparison function.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#isSorted,openArray%5BT%5D,proc(T,T)">isSorted func</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L539" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L539" target="_blank">Edit</a> </dd>  <dt><pre id="product%2CopenArray%5Bseq%5BT%5D%5D" data-language="nim">proc product[T](x: openArray[seq[T]]): seq[seq[T]]</pre></dt> <dd> Produces the Cartesian product of the array. Warning: complexity may explode. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert product(@[@[1], @[2]]) == @[@[1, 2]]
assert product(@[@["A", "K"], @["Q"]]) == @[@["K", "Q"], @["A", "Q"]]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L559" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L559" target="_blank">Edit</a> </dd>  <dt><pre id="nextPermutation%2CopenArray%5BT%5D" data-language="nim">proc nextPermutation[T](x: var openArray[T]): bool {...}{.discardable.}</pre></dt> <dd> <p>Calculates the next lexicographic permutation, directly modifying <code>x</code>. The result is whether a permutation happened, otherwise we have reached the last-ordered permutation.</p> <p>If you start with an unsorted array/seq, the repeated permutations will <strong>not</strong> give you all permutations but stop with last.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#prevPermutation,openArray%5BT%5D">prevPermutation proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var v = @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.nextPermutation() == true
assert v == @[0, 2, 1, 3]
assert v.prevPermutation() == true
assert v == @[0, 1, 3, 2]
v = @[3, 2, 1, 0]
assert v.nextPermutation() == false
assert v == @[3, 2, 1, 0]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L593" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L593" target="_blank">Edit</a> </dd>  <dt><pre id="prevPermutation%2CopenArray%5BT%5D" data-language="nim">proc prevPermutation[T](x: var openArray[T]): bool {...}{.discardable.}</pre></dt> <dd> <p>Calculates the previous lexicographic permutation, directly modifying <code>x</code>. The result is whether a permutation happened, otherwise we have reached the first-ordered permutation.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#nextPermutation,openArray%5BT%5D">nextPermutation proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var v = @[0, 1, 2, 3]
assert v.prevPermutation() == false
assert v == @[0, 1, 2, 3]
assert v.nextPermutation() == true
assert v == @[0, 1, 3, 2]
assert v.prevPermutation() == true
assert v == @[0, 1, 2, 3]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L633" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L633" target="_blank">Edit</a> </dd>  <dt><pre id="rotateLeft%2CopenArray%5BT%5D%2CHSlice%5Bint%2Cint%5D%2Cint" data-language="nim">proc rotateLeft[T](arg: var openArray[T]; slice: HSlice[int, int]; dist: int): int {...}{.
    discardable.}</pre></dt> <dd> Performs a left rotation on a range of elements. If you want to rotate right, use a negative <code>dist</code>. Specifically, <code>rotateLeft</code> rotates the elements at <code>slice</code> by <code>dist</code> positions.<p>The element at index <code>slice.a + dist</code> will be at index <code>slice.a</code>.<br>The element at index <code>slice.b</code> will be at <code>slice.a + dist -1</code>.<br>The element at index <code>slice.a</code> will be at <code>slice.b + 1 - dist</code>.<br>The element at index <code>slice.a + dist - 1</code> will be at <code>slice.b</code>.<br></p>
<p>Elements outside of <code>slice</code> will be left unchanged. The time complexity is linear to <code>slice.b - slice.a + 1</code>. If an invalid range (<code>HSlice</code>) is passed, it raises IndexDefect.</p> <dl>
<dt><code>slice</code></dt> <dd>The indices of the element range that should be rotated.</dd> <dt><code>dist</code></dt> <dd>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</dd> </dl> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray%5BT%5D,int">rotateLeft proc</a> for a version which rotates the whole container</li> <li>
<a href="#rotatedLeft,openArray%5BT%5D,HSlice%5Bint,int%5D,int">rotatedLeft proc</a> for a version which returns a <code>seq[T]</code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [0, 1, 2, 3, 4, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 4, 1, 2, 3, 5]
a.rotateLeft(1 .. 4, 3)
assert a == [0, 3, 4, 1, 2, 5]
a.rotateLeft(1 .. 4, -3)
assert a == [0, 4, 1, 2, 3, 5]
doAssertRaises(IndexDefect, a.rotateLeft(1 .. 7, 2))</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L720" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L720" target="_blank">Edit</a> </dd>  <dt><pre id="rotateLeft%2CopenArray%5BT%5D%2Cint" data-language="nim">proc rotateLeft[T](arg: var openArray[T]; dist: int): int {...}{.discardable.}</pre></dt> <dd> <p>Default arguments for slice, so that this procedure operates on the entire <code>arg</code>, and not just on a part of it.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray%5BT%5D,HSlice%5Bint,int%5D,int">rotateLeft proc</a> for a version which rotates a range</li> <li>
<a href="#rotatedLeft,openArray%5BT%5D,int">rotatedLeft proc</a> for a version which returns a <code>seq[T]</code>
</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = [1, 2, 3, 4, 5]
a.rotateLeft(2)
assert a == [3, 4, 5, 1, 2]
a.rotateLeft(4)
assert a == [2, 3, 4, 5, 1]
a.rotateLeft(-6)
assert a == [1, 2, 3, 4, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L758" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L758" target="_blank">Edit</a> </dd>  <dt><pre id="rotatedLeft%2CopenArray%5BT%5D%2CHSlice%5Bint%2Cint%5D%2Cint" data-language="nim">proc rotatedLeft[T](arg: openArray[T]; slice: HSlice[int, int]; dist: int): seq[
    T]</pre></dt> <dd> <p>Same as <code>rotateLeft</code>, just with the difference that it does not modify the argument. It creates a new <code>seq</code> instead.</p> <p>Elements outside of <code>slice</code> will be left unchanged. If an invalid range (<code>HSlice</code>) is passed, it raises IndexDefect.</p> <dl>
<dt><code>slice</code></dt> <dd>The indices of the element range that should be rotated.</dd> <dt><code>dist</code></dt> <dd>The distance in amount of elements that the data should be rotated. Can be negative, can be any number.</dd> </dl> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray%5BT%5D,HSlice%5Bint,int%5D,int">rotateLeft proc</a> for the in-place version of this proc</li> <li>
<a href="#rotatedLeft,openArray%5BT%5D,int">rotatedLeft proc</a> for a version which rotates the whole container</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 1 .. 4, 3)
assert a == @[1, 5, 2, 3, 4]
a = rotatedLeft(a, 1 .. 3, 2)
assert a == @[1, 3, 5, 2, 4]
a = rotatedLeft(a, 1 .. 3, -2)
assert a == @[1, 5, 2, 3, 4]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L777" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L777" target="_blank">Edit</a> </dd>  <dt><pre id="rotatedLeft%2CopenArray%5BT%5D%2Cint" data-language="nim">proc rotatedLeft[T](arg: openArray[T]; dist: int): seq[T]</pre></dt> <dd> <p>Same as <code>rotateLeft</code>, just with the difference that it does not modify the argument. It creates a new <code>seq</code> instead.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="#rotateLeft,openArray%5BT%5D,int">rotateLeft proc</a> for the in-place version of this proc</li> <li>
<a href="#rotatedLeft,openArray%5BT%5D,HSlice%5Bint,int%5D,int">rotatedLeft proc</a> for a version which rotates a range</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = @[1, 2, 3, 4, 5]
a = rotatedLeft(a, 2)
assert a == @[3, 4, 5, 1, 2]
a = rotatedLeft(a, 4)
assert a == @[2, 3, 4, 5, 1]
a = rotatedLeft(a, -6)
assert a == @[1, 2, 3, 4, 5]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L807" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L807" target="_blank">Edit</a> </dd> </dl>  <h2 id="13">Funcs</h2> <dl>  <dt><pre id="sort%2CopenArray%5BT%5D%2Cproc%28T%2CT%29" data-language="nim">func sort[T](a: var openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
             order = SortOrder.Ascending)</pre></dt> <dd> <p>Default Nim sort (an implementation of merge sort). The sorting is guaranteed to be stable and the worst case is guaranteed to be O(n log n).</p> <p>The current implementation uses an iterative mergesort to achieve this. It uses a temporary sequence of length <code>a.len div 2</code>. If you do not wish to provide your own <code>cmp</code>, you may use <code>system.cmp</code> or instead call the overloaded version of <code>sort</code>, which uses <code>system.cmp</code>.</p> <pre class="listing" data-language="nim">sort(myIntArray, system.cmp[int])
# do not use cmp[string] here as we want to use the specialized
# overload:
sort(myStrArray, system.cmp)</pre>
<p>You can inline adhoc comparison procs with the <a href="manual_experimental.html#do-notation">do notation</a>. Example:</p> <pre class="listing" data-language="nim">people.sort do (x, y: Person) -&gt; int:
  result = cmp(x.surname, y.surname)
  if result == 0:
    result = cmp(x.name, y.name)</pre>
<p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray%5BT%5D">sort proc</a></li> <li>
<a href="#sorted,openArray%5BT%5D,proc(T,T)">sorted proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#sorted,openArray%5BT%5D">sorted proc</a></li> <li><a href="#sortedByIt.t,untyped,untyped">sortedByIt template</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var d = ["boo", "fo", "barr", "qux"]
proc myCmp(x, y: string): int =
  if x.len() &gt; y.len() or x.len() == y.len(): 1
  else: -1
sort(d, myCmp)
assert d == ["fo", "qux", "boo", "barr"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L373" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L373" target="_blank">Edit</a> </dd>  <dt><pre id="isSorted%2CopenArray%5BT%5D%2Cproc%28T%2CT%29" data-language="nim">func isSorted[T](a: openArray[T]; cmp: proc (x, y: T): int {...}{.closure.};
                 order = SortOrder.Ascending): bool</pre></dt> <dd> <p>Checks to see whether <code>a</code> is already sorted in <code>order</code> using <code>cmp</code> for the comparison. Parameters identical to <code>sort</code>. Requires O(n) time.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#isSorted,openArray%5BT%5D">isSorted proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = [2, 3, 1, 5, 4]
  b = [1, 2, 3, 4, 5]
  c = [5, 4, 3, 2, 1]
  d = ["adam", "brian", "cat", "dande"]
  e = ["adam", "dande", "brian", "cat"]
assert isSorted(a) == false
assert isSorted(b) == true
assert isSorted(c) == false
assert isSorted(c, Descending) == true
assert isSorted(d) == true
assert isSorted(e) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L512" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L512" target="_blank">Edit</a> </dd> </dl>  <h2 id="18">Templates</h2> <dl>  <dt><pre id="sortedByIt.t%2Cuntyped%2Cuntyped" data-language="nim">template sortedByIt(seq1, op: untyped): untyped</pre></dt> <dd> <p>Convenience template around the <code>sorted</code> proc to reduce typing.</p> <p>The template injects the <code>it</code> variable which you can use directly in an expression.</p> <p>Because the underlying <code>cmp()</code> is defined for tuples you can do a nested sort.</p> <p><strong>See also:</strong></p> <ul class="simple">
<li><a href="#sort,openArray%5BT%5D,proc(T,T)">sort func</a></li> <li><a href="#sort,openArray%5BT%5D">sort proc</a></li> <li>
<a href="#sorted,openArray%5BT%5D,proc(T,T)">sorted proc</a> sorted by <code>cmp</code> in the specified order</li> <li><a href="#sorted,openArray%5BT%5D">sorted proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type Person = tuple[name: string, age: int]
var
  p1: Person = (name: "p1", age: 60)
  p2: Person = (name: "p2", age: 20)
  p3: Person = (name: "p3", age: 30)
  p4: Person = (name: "p4", age: 30)
  people = @[p1, p2, p4, p3]

assert people.sortedByIt(it.name) == @[(name: "p1", age: 60), (name: "p2",
    age: 20), (name: "p3", age: 30), (name: "p4", age: 30)]
# Nested sort
assert people.sortedByIt((it.age, it.name)) == @[(name: "p2", age: 20),
   (name: "p3", age: 30), (name: "p4", age: 30), (name: "p1", age: 60)]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/algorithm.nim#L476" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/algorithm.nim#L476" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/algorithm.html" class="_attribution-link">https://nim-lang.org/docs/algorithm.html</a>
  </p>
</div>
