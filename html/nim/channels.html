<h1 class="title">channels</h1>  
<p>Channel support for threads.</p> <p><strong>Note</strong>: This is part of the system module. Do not import it directly. To activate thread support compile with the <code>--threads:on</code> command line switch.</p> <p><strong>Note:</strong> Channels are designed for the <code>Thread</code> type. They are unstable when used with <code>spawn</code></p> <p><strong>Note:</strong> The current implementation of message passing does not work with cyclic data structures.</p> <p><strong>Note:</strong> Channels cannot be passed between threads. Use globals or pass them by <code>ptr</code>.</p> <h2 id="example">Example</h2>
<p>The following is a simple example of two different ways to use channels: blocking and non-blocking.</p> <pre class="listing" data-language="nim"># Be sure to compile with --threads:on.
# The channels and threads modules are part of system and should not be
# imported.
import os

# Channels can either be:
#  - declared at the module level, or
#  - passed to procedures by ptr (raw pointer) -- see note on safety.
#
# For simplicity, in this example a channel is declared at module scope.
# Channels are generic, and they include support for passing objects between
# threads.
# Note that objects passed through channels will be deeply copied.
var chan: Channel[string]

# This proc will be run in another thread using the threads module.
proc firstWorker() =
  chan.send("Hello World!")

# This is another proc to run in a background thread. This proc takes a while
# to send the message since it sleeps for 2 seconds (or 2000 milliseconds).
proc secondWorker() =
  sleep(2000)
  chan.send("Another message")

# Initialize the channel.
chan.open()

# Launch the worker.
var worker1: Thread[void]
createThread(worker1, firstWorker)

# Block until the message arrives, then print it out.
echo chan.recv() # "Hello World!"

# Wait for the thread to exit before moving on to the next example.
worker1.joinThread()

# Launch the other worker.
var worker2: Thread[void]
createThread(worker2, secondWorker)
# This time, use a non-blocking approach with tryRecv.
# Since the main thread is not blocked, it could be used to perform other
# useful work while it waits for data to arrive on the channel.
while true:
  let tried = chan.tryRecv()
  if tried.dataAvailable:
    echo tried.msg # "Another message"
    break
  
  echo "Pretend I'm doing useful work..."
  # For this example, sleep in order not to flood stdout with the above
  # message.
  sleep(400)

# Wait for the second thread to exit before cleaning up the channel.
worker2.joinThread()

# Clean up the channel.
chan.close()</pre> <h3 id="example-sample-output">Sample output</h3>
<p>The program should output something similar to this, but keep in mind that exact results may vary in the real world:</p>
<pre data-language="nim">Hello World!
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Pretend I'm doing useful work...
Another message</pre> <h3 id="example-passing-channels-safely">Passing Channels Safely</h3>
<p>Note that when passing objects to procedures on another thread by pointer (for example through a thread's argument), objects created using the default allocator will use thread-local, GC-managed memory. Thus it is generally safer to store channel objects in global variables (as in the above example), in which case they will use a process-wide (thread-safe) shared heap.</p> <p>However, it is possible to manually allocate shared memory for channels using e.g. <code>system.allocShared0</code> and pass these pointers through thread arguments:</p> <pre class="listing" data-language="nim">proc worker(channel: ptr Channel[string]) =
  let greeting = channel[].recv()
  echo greeting

proc localChannelExample() =
  # Use allocShared0 to allocate some shared-heap memory and zero it.
  # The usual warnings about dealing with raw pointers apply. Exercise caution.
  var channel = cast[ptr Channel[string]](
    allocShared0(sizeof(Channel[string]))
  )
  channel[].open()
  # Create a thread which will receive the channel as an argument.
  var thread: Thread[ptr Channel[string]]
  createThread(thread, worker, channel)
  channel[].send("Hello from the main thread!")
  # Clean up resources.
  thread.joinThread()
  channel[].close()
  deallocShared(channel)

localChannelExample() # "Hello from the main thread!"</pre>  <h2 id="7">Types</h2> <dl>  <dt><pre data-language="nim">Channel*[TMsg] {...}{.gcsafe.} = RawChannel</pre></dt> <dd> a channel for thread communication <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L154" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L154" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="send%2CChannel%5BTMsg%5D%2CsinkTMsg" data-language="nim">proc send*[TMsg](c: var Channel[TMsg]; msg: sink TMsg) {...}{.inline.}</pre></dt> <dd> Sends a message to a thread. <code>msg</code> is deeply copied. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L367" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L367" target="_blank">Edit</a> </dd>  <dt><pre id="trySend%2CChannel%5BTMsg%5D%2CsinkTMsg" data-language="nim">proc trySend*[TMsg](c: var Channel[TMsg]; msg: sink TMsg): bool {...}{.inline.}</pre></dt> <dd> <p>Tries to send a message to a thread.</p> <p><code>msg</code> is deeply copied. Doesn't block.</p> <p>Returns <code>false</code> if the message was not sent because number of pending items in the channel exceeded <code>maxItems</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L373" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L373" target="_blank">Edit</a> </dd>  <dt><pre id="recv%2CChannel%5BTMsg%5D" data-language="nim">proc recv*[TMsg](c: var Channel[TMsg]): TMsg</pre></dt> <dd> <p>Receives a message from the channel <code>c</code>.</p> <p>This blocks until a message has arrived! You may use <a href="#peek,Channel%5BTMsg%5D">peek proc</a> to avoid the blocking.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L398" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L398" target="_blank">Edit</a> </dd>  <dt><pre id="tryRecv%2CChannel%5BTMsg%5D" data-language="nim">proc tryRecv*[TMsg](c: var Channel[TMsg]): tuple[dataAvailable: bool, msg: TMsg]</pre></dt> <dd> <p>Tries to receive a message from the channel <code>c</code>, but this can fail for all sort of reasons, including contention.</p> <p>If it fails, it returns <code>(false, default(msg))</code> otherwise it returns <code>(true, msg)</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L408" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L408" target="_blank">Edit</a> </dd>  <dt><pre id="peek%2CChannel%5BTMsg%5D" data-language="nim">proc peek*[TMsg](c: var Channel[TMsg]): int</pre></dt> <dd> <p>Returns the current number of messages in the channel <code>c</code>.</p> <p>Returns -1 if the channel has been closed.</p> <p><strong>Note</strong>: This is dangerous to use as it encourages races. It's much better to use <a href="#tryRecv,Channel%5BTMsg%5D">tryRecv proc</a> instead.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L423" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L423" target="_blank">Edit</a> </dd>  <dt><pre id="open%2CChannel%5BTMsg%5D%2Cint" data-language="nim">proc open*[TMsg](c: var Channel[TMsg]; maxItems: int = 0)</pre></dt> <dd> <p>Opens a channel <code>c</code> for inter thread communication.</p> <p>The <code>send</code> operation will block until number of unprocessed items is less than <code>maxItems</code>.</p> <p>For unlimited queue set <code>maxItems</code> to 0.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L437" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L437" target="_blank">Edit</a> </dd>  <dt><pre id="close%2CChannel%5BTMsg%5D" data-language="nim">proc close*[TMsg](c: var Channel[TMsg])</pre></dt> <dd> Closes a channel <code>c</code> and frees its associated resources. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L446" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L446" target="_blank">Edit</a> </dd>  <dt><pre id="ready%2CChannel%5BTMsg%5D" data-language="nim">proc ready*[TMsg](c: var Channel[TMsg]): bool</pre></dt> <dd> Returns true if some thread is waiting on the channel <code>c</code> for new messages. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/system/channels.nim#L450" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/system/channels.nim#L450" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/channels.html" class="_attribution-link">https://nim-lang.org/docs/channels.html</a>
  </p>
</div>
