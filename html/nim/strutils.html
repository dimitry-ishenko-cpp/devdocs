<h1 class="title">strutils</h1>  <p class="module-desc">The system module defines several common functions for working with strings, such as:</p>
<ul class="simple">
<li>
<code>$</code> for converting other data-types to strings</li> <li>
<code>&amp;</code> for string concatenation</li> <li>
<code>add</code> for adding a new character or a string to the existing one</li> <li>
<code>in</code> (alias for <code>contains</code>) and <code>notin</code> for checking if a character is in a string</li> </ul> <p>This module builds upon that, providing additional functionality in form of procedures, iterators and templates for strings.</p> <pre class="listing" data-language="nim">import strutils

let
  numbers = @[867, 5309]
  multiLineString = "first line\nsecond line\nthird line"

let jenny = numbers.join("-")
assert jenny == "867-5309"

assert splitLines(multiLineString) ==
       @["first line", "second line", "third line"]
assert split(multiLineString) == @["first", "line", "second",
                                   "line", "third", "line"]
assert indent(multiLineString, 4) ==
       "    first line\n    second line\n    third line"
assert 'z'.repeat(5) == "zzzzz"</pre>
<p>The chaining of functions is possible thanks to the <a href="manual.html#procedures-method-call-syntax">method call syntax</a>:</p> <pre class="listing" data-language="nim">import strutils
from sequtils import map

let jenny = "867-5309"
assert jenny.split('-').map(parseInt) == @[867, 5309]

assert "Beetlejuice".indent(1).repeat(3).strip ==
       "Beetlejuice Beetlejuice Beetlejuice"</pre>
<p>This module is available for the <a href="backends.html#backends-the-javascript-target">JavaScript target</a>.</p> <hr> <p><strong>See also:</strong></p> <ul class="simple">
<li>
<a href="strformat.html">strformat module</a> for string interpolation and formatting</li> <li>
<a href="unicode.html">unicode module</a> for Unicode UTF-8 handling</li> <li>
<a href="sequtils.html">sequtils module</a> for operations on container types (including strings)</li> <li>
<a href="parsecsv.html">parsecsv module</a> for a high-performance CSV parser</li> <li>
<a href="parseutils.html">parseutils module</a> for lower-level parsing of tokens, numbers, identifiers, etc.</li> <li>
<a href="parseopt.html">parseopt module</a> for command-line parsing</li> <li>
<a href="pegs.html">pegs module</a> for PEG (Parsing Expression Grammar) support</li> <li>
<a href="strtabs.html">strtabs module</a> for efficient hash tables (dictionaries, in some programming languages) mapping from strings to strings</li> <li>
<a href="ropes.html">ropes module</a> for rope data type, which can represent very long strings efficiently</li> <li>
<a href="re.html">re module</a> for regular expression (regex) support</li> <li>
<a href="strscans.html">strscans</a> for <code>scanf</code> and <code>scanp</code> macros, which offer easier substring extraction than regular expressions</li> </ul>  <h2 id="6">Imports</h2> <dl> <a href="parseutils.html">parseutils</a>, <a href="math.html">math</a>, <a href="algorithm.html">algorithm</a>, <a href="macros.html">macros</a>, <a href="unicode.html">unicode</a>, <a href="since.html">since</a> </dl>  <h2 id="7">Types</h2> <dl>  <dt><pre id="SkipTable" data-language="nim">SkipTable = array[char, int]</pre></dt> <dd> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1897" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1897" target="_blank">Edit</a> </dd>  <dt><pre id="FloatFormatMode" data-language="nim">FloatFormatMode = enum
  ffDefault,                ## use the shorter floating point notation
  ffDecimal,                ## use decimal floating point notation
  ffScientific               ## use scientific notation (using ``e`` character)</pre></dt> <dd> the different modes of floating point formatting <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2410" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2410" target="_blank">Edit</a> </dd>  <dt><pre id="BinaryPrefixMode" data-language="nim">BinaryPrefixMode = enum
  bpIEC, bpColloquial</pre></dt> <dd> the different names for binary prefixes <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2537" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2537" target="_blank">Edit</a> </dd> </dl>  <h2 id="10">Consts</h2> <dl>  <dt><pre id="Whitespace" data-language="nim">Whitespace = {' ', '\t', '\v', '\c', '\n', '\f'}</pre></dt> <dd> All the characters that count as whitespace (space, tab, vertical tab, carriage return, new line, form feed) <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L89" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L89" target="_blank">Edit</a> </dd>  <dt><pre id="Letters" data-language="nim">Letters = {'A'..'Z', 'a'..'z'}</pre></dt> <dd> the set of letters <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L93" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L93" target="_blank">Edit</a> </dd>  <dt><pre id="Digits" data-language="nim">Digits = {'0'..'9'}</pre></dt> <dd> the set of digits <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L96" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L96" target="_blank">Edit</a> </dd>  <dt><pre id="HexDigits" data-language="nim">HexDigits = {'0'..'9', 'A'..'F', 'a'..'f'}</pre></dt> <dd> the set of hexadecimal digits <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L99" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L99" target="_blank">Edit</a> </dd>  <dt><pre id="IdentChars" data-language="nim">IdentChars = {'a'..'z', 'A'..'Z', '0'..'9', '_'}</pre></dt> <dd> the set of characters an identifier can consist of <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L102" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L102" target="_blank">Edit</a> </dd>  <dt><pre id="IdentStartChars" data-language="nim">IdentStartChars = {'a'..'z', 'A'..'Z', '_'}</pre></dt> <dd> the set of characters an identifier can start with <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L105" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L105" target="_blank">Edit</a> </dd>  <dt><pre id="Newlines" data-language="nim">Newlines = {'\c', '\n'}</pre></dt> <dd> the set of characters a newline terminator can start with (carriage return, line feed) <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L108" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L108" target="_blank">Edit</a> </dd>  <dt><pre id="AllChars" data-language="nim">AllChars = {'\x00'..'\xFF'}</pre></dt> <dd> <p>A set with all the possible characters.</p> <p>Not very useful by its own, you can use it to create <em>inverted</em> sets to make the <a href="#find,string,set%5Bchar%5D,Natural,int">find proc</a> find <strong>invalid</strong> characters in strings. Example:</p> <pre class="listing" data-language="nim">let invalid = AllChars - Digits
doAssert "01234".find(invalid) == -1
doAssert "01A34".find(invalid) == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L112" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L112" target="_blank">Edit</a> </dd> </dl>  <h2 id="12">Procs</h2> <dl>  <dt><pre id="isAlphaAscii%2Cchar" data-language="nim">proc isAlphaAscii(c: char): bool {...}{.noSideEffect, gcsafe,
                                   extern: "nsuIsAlphaAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Checks whether or not character <code>c</code> is alphabetical.</p> <p>This checks a-z, A-Z ASCII characters only. Use <a href="unicode.html">Unicode module</a> for UTF-8 support.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isAlphaAscii('e') == true
doAssert isAlphaAscii('E') == true
doAssert isAlphaAscii('8') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L124" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L124" target="_blank">Edit</a> </dd>  <dt><pre id="isAlphaNumeric%2Cchar" data-language="nim">proc isAlphaNumeric(c: char): bool {...}{.noSideEffect, gcsafe,
                                     extern: "nsuIsAlphaNumericChar",
                                     raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <code>c</code> is alphanumeric.</p> <p>This checks a-z, A-Z, 0-9 ASCII characters only.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isAlphaNumeric('n') == true
doAssert isAlphaNumeric('8') == true
doAssert isAlphaNumeric(' ') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L136" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L136" target="_blank">Edit</a> </dd>  <dt><pre id="isDigit%2Cchar" data-language="nim">proc isDigit(c: char): bool {...}{.noSideEffect, gcsafe, extern: "nsuIsDigitChar",
                              raises: [], tags: [].}</pre></dt> <dd> <p>Checks whether or not <code>c</code> is a number.</p> <p>This checks 0-9 ASCII characters only.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isDigit('n') == false
doAssert isDigit('8') == true</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L147" target="_blank">Edit</a> </dd>  <dt><pre id="isSpaceAscii%2Cchar" data-language="nim">proc isSpaceAscii(c: char): bool {...}{.noSideEffect, gcsafe,
                                   extern: "nsuIsSpaceAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> Checks whether or not <code>c</code> is a whitespace character. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isSpaceAscii('n') == false
doAssert isSpaceAscii(' ') == true
doAssert isSpaceAscii('\t') == true</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L157" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L157" target="_blank">Edit</a> </dd>  <dt><pre id="isLowerAscii%2Cchar" data-language="nim">proc isLowerAscii(c: char): bool {...}{.noSideEffect, gcsafe,
                                   extern: "nsuIsLowerAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Checks whether or not <code>c</code> is a lower case character.</p> <p>This checks ASCII characters only. Use <a href="unicode.html">Unicode module</a> for UTF-8 support.</p> <p>See also:</p> <ul class="simple">
<li><a href="#toLowerAscii,char">toLowerAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isLowerAscii('e') == true
doAssert isLowerAscii('E') == false
doAssert isLowerAscii('7') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L166" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L166" target="_blank">Edit</a> </dd>  <dt><pre id="isUpperAscii%2Cchar" data-language="nim">proc isUpperAscii(c: char): bool {...}{.noSideEffect, gcsafe,
                                   extern: "nsuIsUpperAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Checks whether or not <code>c</code> is an upper case character.</p> <p>This checks ASCII characters only. Use <a href="unicode.html">Unicode module</a> for UTF-8 support.</p> <p>See also:</p> <ul class="simple">
<li><a href="#toUpperAscii,char">toUpperAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert isUpperAscii('e') == false
doAssert isUpperAscii('E') == true
doAssert isUpperAscii('7') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L181" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L181" target="_blank">Edit</a> </dd>  <dt><pre id="toLowerAscii%2Cchar" data-language="nim">proc toLowerAscii(c: char): char {...}{.noSideEffect, gcsafe,
                                   extern: "nsuToLowerAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Returns the lower case version of character <code>c</code>.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode.html#toLower,Rune">unicode.toLower</a> for a version that works for any Unicode character.</p> <p>See also:</p> <ul class="simple">
<li><a href="#isLowerAscii,char">isLowerAscii proc</a></li> <li>
<a href="#toLowerAscii,string">toLowerAscii proc</a> for converting a string</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toLowerAscii('A') == 'a'
doAssert toLowerAscii('e') == 'e'</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L197" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L197" target="_blank">Edit</a> </dd>  <dt><pre id="toLowerAscii%2Cstring" data-language="nim">proc toLowerAscii(s: string): string {...}{.noSideEffect, gcsafe,
                                       extern: "nsuToLowerAsciiStr", raises: [],
                                       tags: [].}</pre></dt> <dd> <p>Converts string <code>s</code> into lower case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode.html#toLower,string">unicode.toLower</a> for a version that works for any Unicode character.</p> <p>See also:</p> <ul class="simple">
<li><a href="#normalize,string">normalize proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toLowerAscii("FooBar!") == "foobar!"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L221" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L221" target="_blank">Edit</a> </dd>  <dt><pre id="toUpperAscii%2Cchar" data-language="nim">proc toUpperAscii(c: char): char {...}{.noSideEffect, gcsafe,
                                   extern: "nsuToUpperAsciiChar", raises: [],
                                   tags: [].}</pre></dt> <dd> <p>Converts character <code>c</code> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode.html#toUpper,Rune">unicode.toUpper</a> for a version that works for any Unicode character.</p> <p>See also:</p> <ul class="simple">
<li><a href="#isLowerAscii,char">isLowerAscii proc</a></li> <li>
<a href="#toUpperAscii,string">toUpperAscii proc</a> for converting a string</li> <li><a href="#capitalizeAscii,string">capitalizeAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toUpperAscii('a') == 'A'
doAssert toUpperAscii('E') == 'E'</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L235" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L235" target="_blank">Edit</a> </dd>  <dt><pre id="toUpperAscii%2Cstring" data-language="nim">proc toUpperAscii(s: string): string {...}{.noSideEffect, gcsafe,
                                       extern: "nsuToUpperAsciiStr", raises: [],
                                       tags: [].}</pre></dt> <dd> <p>Converts string <code>s</code> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. See <a href="unicode.html#toUpper,string">unicode.toUpper</a> for a version that works for any Unicode character.</p> <p>See also:</p> <ul class="simple">
<li><a href="#capitalizeAscii,string">capitalizeAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toUpperAscii("FooBar!") == "FOOBAR!"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L255" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L255" target="_blank">Edit</a> </dd>  <dt><pre id="capitalizeAscii%2Cstring" data-language="nim">proc capitalizeAscii(s: string): string {...}{.noSideEffect, gcsafe,
    extern: "nsuCapitalizeAscii", raises: [], tags: [].}</pre></dt> <dd> <p>Converts the first character of string <code>s</code> into upper case.</p> <p>This works only for the letters <code>A-Z</code>. Use <a href="unicode.html">Unicode module</a> for UTF-8 support.</p> <p>See also:</p> <ul class="simple">
<li><a href="#toUpperAscii,char">toUpperAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert capitalizeAscii("foo") == "Foo"
doAssert capitalizeAscii("-bar") == "-bar"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L269" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L269" target="_blank">Edit</a> </dd>  <dt><pre id="nimIdentNormalize%2Cstring" data-language="nim">proc nimIdentNormalize(s: string): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Normalizes the string <code>s</code> as a Nim identifier.</p> <p>That means to convert to lower case and remove any '_' on all characters except first one.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert nimIdentNormalize("Foo_bar") == "Foobar"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L284" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L284" target="_blank">Edit</a> </dd>  <dt><pre id="normalize%2Cstring" data-language="nim">proc normalize(s: string): string {...}{.noSideEffect, gcsafe,
                                    extern: "nsuNormalize", raises: [], tags: [].}</pre></dt> <dd> <p>Normalizes the string <code>s</code>.</p> <p>That means to convert it to lower case and remove any '_'. This should NOT be used to normalize Nim identifier names.</p> <p>See also:</p> <ul class="simple">
<li><a href="#toLowerAscii,string">toLowerAscii proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert normalize("Foo_bar") == "foobar"
doAssert normalize("Foo Bar") == "foo bar"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L304" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L304" target="_blank">Edit</a> </dd>  <dt><pre id="cmpIgnoreCase%2Cstring%2Cstring" data-language="nim">proc cmpIgnoreCase(a, b: string): int {...}{.noSideEffect, gcsafe,
                                        extern: "nsuCmpIgnoreCase", raises: [],
                                        tags: [].}</pre></dt> <dd> Compares two strings in a case insensitive manner. Returns:<p>0 if a == b<br>&lt; 0 if a &lt; b<br>&gt; 0 if a &gt; b<br></p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert cmpIgnoreCase("FooBar", "foobar") == 0
doAssert cmpIgnoreCase("bar", "Foo") &lt; 0
doAssert cmpIgnoreCase("Foo5", "foo4") &gt; 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L327" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L327" target="_blank">Edit</a> </dd>  <dt><pre id="cmpIgnoreStyle%2Cstring%2Cstring" data-language="nim">proc cmpIgnoreStyle(a, b: string): int {...}{.noSideEffect, gcsafe,
    extern: "nsuCmpIgnoreStyle", raises: [], tags: [].}</pre></dt> <dd> <p>Semantically the same as <code>cmp(normalize(a), normalize(b))</code>. It is just optimized to not allocate temporary strings. This should NOT be used to compare Nim identifier names. Use <a href="macros.html#eqIdent,string,string">macros.eqIdent</a> for that.</p> <p>Returns:</p> <p>0 if a == b<br>&lt; 0 if a &lt; b<br>&gt; 0 if a &gt; b<br></p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert cmpIgnoreStyle("foo_bar", "FooBar") == 0
doAssert cmpIgnoreStyle("foo_bar_5", "FooBar4") &gt; 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L349" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L349" target="_blank">Edit</a> </dd>  <dt><pre id="split%2Cstring%2Cchar%2Cint" data-language="nim">proc split(s: string; sep: char; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuSplitChar", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#split.i,string,char,int">split iterator</a> (see its documentation), but is a proc that returns a sequence of substrings.</p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,char,int">split iterator</a></li> <li><a href="#rsplit,string,char,int">rsplit proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b,c".split(',') == @["a", "b", "c"]
doAssert "".split(' ') == @[""]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L730" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L730" target="_blank">Edit</a> </dd>  <dt><pre id="split%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[
    string] {...}{.noSideEffect, gcsafe, extern: "nsuSplitCharSet", raises: [],
              tags: [].}</pre></dt> <dd> <p>The same as the <a href="#split.i,string,set%5Bchar%5D,int">split iterator</a> (see its documentation), but is a proc that returns a sequence of substrings.</p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,set%5Bchar%5D,int">split iterator</a></li> <li><a href="#rsplit,string,set%5Bchar%5D,int">rsplit proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b;c".split({',', ';'}) == @["a", "b", "c"]
doAssert "".split({' '}) == @[""]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L745" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L745" target="_blank">Edit</a> </dd>  <dt><pre id="split%2Cstring%2Cstring%2Cint" data-language="nim">proc split(s: string; sep: string; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuSplitString", raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into substrings using a string separator.</p> <p>Substrings are separated by the string <code>sep</code>. This is a wrapper around the <a href="#split.i,string,string,int">split iterator</a>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,string,int">split iterator</a></li> <li><a href="#rsplit,string,string,int">rsplit proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "a,b,c".split(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".split("a ") == @["", "man ", "plan ", "canal panama"]
doAssert "".split("Elon Musk") == @[""]
doAssert "a  largely    spaced sentence".split(" ") == @["a", "", "largely",
    "", "", "", "spaced", "sentence"]
doAssert "a  largely    spaced sentence".split(" ", maxsplit = 1) == @["a", " largely    spaced sentence"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L760" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L760" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit%2Cstring%2Cchar%2Cint" data-language="nim">proc rsplit(s: string; sep: char; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuRSplitChar", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,char,int">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <code>rsplit</code> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <code>#</code> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", '#', maxsplit=1)</pre>
<p>Results in <code>tailSplit</code> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,char,int">rsplit iterator</a></li> <li><a href="#split,string,char,int">split proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L783" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L783" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">proc rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): seq[
    string] {...}{.noSideEffect, gcsafe, extern: "nsuRSplitCharSet", raises: [],
              tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,set%5Bchar%5D,int">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <code>rsplit</code> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <code>#</code> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", {'#'}, maxsplit=1)</pre>
<p>Results in <code>tailSplit</code> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,set%5Bchar%5D,int">rsplit iterator</a></li> <li><a href="#split,string,set%5Bchar%5D,int">split proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L810" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L810" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit%2Cstring%2Cstring%2Cint" data-language="nim">proc rsplit(s: string; sep: string; maxsplit: int = -1): seq[string] {...}{.
    noSideEffect, gcsafe, extern: "nsuRSplitString", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#rsplit.i,string,string,int,bool">rsplit iterator</a>, but is a proc that returns a sequence of substrings.</p> <p>A possible common use case for <code>rsplit</code> is path manipulation, particularly on systems that don't use a common delimiter.</p> <p>For example, if a system had <code>#</code> as a delimiter, you could do the following to get the tail of the path:</p> <pre class="listing" data-language="nim">var tailSplit = rsplit("Root#Object#Method#Index", "#", maxsplit=1)</pre>
<p>Results in <code>tailSplit</code> containing:</p> <pre class="listing" data-language="nim">@["Root#Object#Method", "Index"]</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,string,int,bool">rsplit iterator</a></li> <li><a href="#split,string,string,int">split proc</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "a  largely    spaced sentence".rsplit(" ", maxsplit = 1) == @[
    "a  largely    spaced", "sentence"]
doAssert "a,b,c".rsplit(",") == @["a", "b", "c"]
doAssert "a man a plan a canal panama".rsplit("a ") == @["", "man ",
    "plan ", "canal panama"]
doAssert "".rsplit("Elon Musk") == @[""]
doAssert "a  largely    spaced sentence".rsplit(" ") == @["a", "",
    "largely", "", "", "", "spaced", "sentence"]</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L838" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L838" target="_blank">Edit</a> </dd>  <dt><pre id="splitLines%2Cstring" data-language="nim">proc splitLines(s: string; keepEol = false): seq[string] {...}{.noSideEffect, gcsafe,
    extern: "nsuSplitLines", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#splitLines.i,string">splitLines iterator</a> (see its documentation), but is a proc that returns a sequence of substrings.</p> <p>See also:</p> <ul class="simple">
<li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> <li><a href="#countLines,string">countLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L874" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L874" target="_blank">Edit</a> </dd>  <dt><pre id="splitWhitespace%2Cstring%2Cint" data-language="nim">proc splitWhitespace(s: string; maxsplit: int = -1): seq[string] {...}{.noSideEffect,
    gcsafe, extern: "nsuSplitWhitespace", raises: [], tags: [].}</pre></dt> <dd> <p>The same as the <a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a> (see its documentation), but is a proc that returns a sequence of substrings.</p> <p>See also:</p> <ul class="simple">
<li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L885" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L885" target="_blank">Edit</a> </dd>  <dt><pre id="toBin%2CBiggestInt%2CPositive" data-language="nim">proc toBin(x: BiggestInt; len: Positive): string {...}{.noSideEffect, gcsafe,
    extern: "nsuToBin", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <code>x</code> into its binary representation.</p> <p>The resulting string is always <code>len</code> characters long. No leading <code>0b</code> prefix is generated.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = 29
  b = 257
doAssert a.toBin(8) == "00011101"
doAssert b.toBin(8) == "00000001"
doAssert b.toBin(9) == "100000001"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L895" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L895" target="_blank">Edit</a> </dd>  <dt><pre id="toOct%2CBiggestInt%2CPositive" data-language="nim">proc toOct(x: BiggestInt; len: Positive): string {...}{.noSideEffect, gcsafe,
    extern: "nsuToOct", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <code>x</code> into its octal representation.</p> <p>The resulting string is always <code>len</code> characters long. No leading <code>0o</code> prefix is generated.</p> <p>Do not confuse it with <a href="#toOctal,char">toOctal proc</a>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = 62
  b = 513
doAssert a.toOct(3) == "076"
doAssert b.toOct(3) == "001"
doAssert b.toOct(5) == "01001"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L918" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L918" target="_blank">Edit</a> </dd>  <dt><pre id="toHex%2CT%2CPositive" data-language="nim">proc toHex[T: SomeInteger](x: T; len: Positive): string {...}{.noSideEffect.}</pre></dt> <dd> <p>Converts <code>x</code> to its hexadecimal representation.</p> <p>The resulting string will be exactly <code>len</code> characters long. No prefix like <code>0x</code> is generated. <code>x</code> is treated as an unsigned value.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = 62'u64
  b = 4097'u64
doAssert a.toHex(3) == "03E"
doAssert b.toHex(3) == "001"
doAssert b.toHex(4) == "1001"
doAssert toHex(62, 3) == "03E"
doAssert toHex(-8, 6) == "FFFFF8"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L954" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L954" target="_blank">Edit</a> </dd>  <dt><pre id="toHex%2CT" data-language="nim">proc toHex[T: SomeInteger](x: T): string {...}{.noSideEffect.}</pre></dt> <dd> Shortcut for <code>toHex(x, T.sizeof * 2)</code> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toHex(1984'i64) == "00000000000007C0"
doAssert toHex(1984'i16) == "07C0"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L970" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L970" target="_blank">Edit</a> </dd>  <dt><pre id="toHex%2Cstring" data-language="nim">proc toHex(s: string): string {...}{.noSideEffect, gcsafe, raises: [], tags: [].}</pre></dt> <dd> <p>Converts a bytes string to its hexadecimal representation.</p> <p>The output is twice the input long. No prefix like <code>0x</code> is generated.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#parseHexStr,string">parseHexStr proc</a> for the reverse operation</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = "1"
  b = "A"
  c = "\0\255"
doAssert a.toHex() == "31"
doAssert b.toHex() == "41"
doAssert c.toHex() == "00FF"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L977" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L977" target="_blank">Edit</a> </dd>  <dt><pre id="toOctal%2Cchar" data-language="nim">proc toOctal(c: char): string {...}{.noSideEffect, gcsafe, extern: "nsuToOctal",
                                raises: [], tags: [].}</pre></dt> <dd> <p>Converts a character <code>c</code> to its octal representation.</p> <p>The resulting string may not have a leading zero. Its length is always exactly 3.</p> <p>Do not confuse it with <a href="#toOct,BiggestInt,Positive">toOct proc</a>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert toOctal('1') == "061"
doAssert toOctal('A') == "101"
doAssert toOctal('a') == "141"
doAssert toOctal('!') == "041"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1002" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1002" target="_blank">Edit</a> </dd>  <dt><pre id="fromBin%2Cstring" data-language="nim">proc fromBin[T: SomeInteger](s: string): T</pre></dt> <dd> <p>Parses a binary integer value from a string <code>s</code>.</p> <p>If <code>s</code> is not a valid binary integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0b</code>, <code>0B</code>. Underscores within <code>s</code> are ignored.</p> <p>Does not check for overflow. If the value represented by <code>s</code> is too big to fit into a return type, only the value of the rightmost binary digits of <code>s</code> is returned without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let s = "0b_0100_1000_1000_1000_1110_1110_1001_1001"
doAssert fromBin[int](s) == 1216933529
doAssert fromBin[int8](s) == 0b1001_1001'i8
doAssert fromBin[int8](s) == -103'i8
doAssert fromBin[uint8](s) == 153
doAssert s.fromBin[:int16] == 0b1110_1110_1001_1001'i16
doAssert s.fromBin[:uint64] == 1216933529'u64</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1021" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1021" target="_blank">Edit</a> </dd>  <dt><pre id="fromOct%2Cstring" data-language="nim">proc fromOct[T: SomeInteger](s: string): T</pre></dt> <dd> <p>Parses an octal integer value from a string <code>s</code>.</p> <p>If <code>s</code> is not a valid octal integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0o</code>, <code>0O</code>. Underscores within <code>s</code> are ignored.</p> <p>Does not check for overflow. If the value represented by <code>s</code> is too big to fit into a return type, only the value of the rightmost octal digits of <code>s</code> is returned without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let s = "0o_123_456_777"
doAssert fromOct[int](s) == 21913087
doAssert fromOct[int8](s) == 0o377'i8
doAssert fromOct[int8](s) == -1'i8
doAssert fromOct[uint8](s) == 255'u8
doAssert s.fromOct[:int16] == 24063'i16
doAssert s.fromOct[:uint64] == 21913087'u64</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1044" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1044" target="_blank">Edit</a> </dd>  <dt><pre id="fromHex%2Cstring" data-language="nim">proc fromHex[T: SomeInteger](s: string): T</pre></dt> <dd> <p>Parses a hex integer value from a string <code>s</code>.</p> <p>If <code>s</code> is not a valid hex integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0x</code>, <code>0X</code>, <code>#</code>. Underscores within <code>s</code> are ignored.</p> <p>Does not check for overflow. If the value represented by <code>s</code> is too big to fit into a return type, only the value of the rightmost hex digits of <code>s</code> is returned without producing an error.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let s = "0x_1235_8df6"
doAssert fromHex[int](s) == 305499638
doAssert fromHex[int8](s) == 0xf6'i8
doAssert fromHex[int8](s) == -10'i8
doAssert fromHex[uint8](s) == 246'u8
doAssert s.fromHex[:int16] == -29194'i16
doAssert s.fromHex[:uint64] == 305499638'u64</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1067" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1067" target="_blank">Edit</a> </dd>  <dt><pre id="intToStr%2Cint%2CPositive" data-language="nim">proc intToStr(x: int; minchars: Positive = 1): string {...}{.noSideEffect, gcsafe,
    extern: "nsuIntToStr", raises: [], tags: [].}</pre></dt> <dd> <p>Converts <code>x</code> to its decimal representation.</p> <p>The resulting string will be minimally <code>minchars</code> characters long. This is achieved by adding leading zeros.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert intToStr(1984) == "1984"
doAssert intToStr(1984, 6) == "001984"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1090" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1090" target="_blank">Edit</a> </dd>  <dt><pre id="parseInt%2Cstring" data-language="nim">proc parseInt(s: string): int {...}{.noSideEffect, gcsafe, extern: "nsuParseInt",
                                raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid integer, <code>ValueError</code> is raised.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert parseInt("-0042") == -42</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1105" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1105" target="_blank">Edit</a> </dd>  <dt><pre id="parseBiggestInt%2Cstring" data-language="nim">proc parseBiggestInt(s: string): BiggestInt {...}{.noSideEffect, gcsafe,
    extern: "nsuParseBiggestInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid integer, <code>ValueError</code> is raised.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1117" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1117" target="_blank">Edit</a> </dd>  <dt><pre id="parseUInt%2Cstring" data-language="nim">proc parseUInt(s: string): uint {...}{.noSideEffect, gcsafe, extern: "nsuParseUInt",
                                  raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid integer, <code>ValueError</code> is raised.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1127" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1127" target="_blank">Edit</a> </dd>  <dt><pre id="parseBiggestUInt%2Cstring" data-language="nim">proc parseBiggestUInt(s: string): BiggestUInt {...}{.noSideEffect, gcsafe,
    extern: "nsuParseBiggestUInt", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal unsigned integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid integer, <code>ValueError</code> is raised.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1137" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1137" target="_blank">Edit</a> </dd>  <dt><pre id="parseFloat%2Cstring" data-language="nim">proc parseFloat(s: string): float {...}{.noSideEffect, gcsafe,
                                    extern: "nsuParseFloat",
                                    raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a decimal floating point value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid floating point number, <code>ValueError</code> is raised. <code>NAN</code>, <code>INF</code>, <code>-INF</code> are also supported (case insensitive comparison).</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert parseFloat("3.14") == 3.14
doAssert parseFloat("inf") == 1.0/0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1147" target="_blank">Edit</a> </dd>  <dt><pre id="parseBinInt%2Cstring" data-language="nim">proc parseBinInt(s: string): int {...}{.noSideEffect, gcsafe,
                                   extern: "nsuParseBinInt",
                                   raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a binary integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid binary integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0b</code>, <code>0B</code>. Underscores within <code>s</code> are ignored.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = "0b11_0101"
  b = "111"
doAssert a.parseBinInt() == 53
doAssert b.parseBinInt() == 7</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1161" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1161" target="_blank">Edit</a> </dd>  <dt><pre id="parseOctInt%2Cstring" data-language="nim">proc parseOctInt(s: string): int {...}{.noSideEffect, gcsafe,
                                   extern: "nsuParseOctInt",
                                   raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses an octal integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid oct integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0o</code>, <code>0O</code>. Underscores within <code>s</code> are ignored.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1180" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1180" target="_blank">Edit</a> </dd>  <dt><pre id="parseHexInt%2Cstring" data-language="nim">proc parseHexInt(s: string): int {...}{.noSideEffect, gcsafe,
                                   extern: "nsuParseHexInt",
                                   raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a hexadecimal integer value contained in <code>s</code>.</p> <p>If <code>s</code> is not a valid hex integer, <code>ValueError</code> is raised. <code>s</code> can have one of the following optional prefixes: <code>0x</code>, <code>0X</code>, <code>#</code>. Underscores within <code>s</code> are ignored.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1192" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1192" target="_blank">Edit</a> </dd>  <dt><pre id="parseHexStr%2Cstring" data-language="nim">proc parseHexStr(s: string): string {...}{.noSideEffect, gcsafe,
                                      extern: "nsuParseHexStr",
                                      raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Convert hex-encoded string to byte string, e.g.:</p> <p>Raises <code>ValueError</code> for an invalid hex values. The comparison is case-insensitive.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#toHex,string">toHex proc</a> for the reverse operation</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  a = "41"
  b = "3161"
  c = "00ff"
doAssert parseHexStr(a) == "A"
doAssert parseHexStr(b) == "1a"
doAssert parseHexStr(c) == "\0\255"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1219" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1219" target="_blank">Edit</a> </dd>  <dt><pre id="parseBool%2Cstring" data-language="nim">proc parseBool(s: string): bool {...}{.raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Parses a value into a <code>bool</code>.</p> <p>If <code>s</code> is one of the following values: <code>y, yes, true, 1, on</code>, then returns <code>true</code>. If <code>s</code> is one of the following values: <code>n, no, false, 0, off</code>, then returns <code>false</code>. If <code>s</code> is something else a <code>ValueError</code> exception is raised.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "n"
doAssert parseBool(a) == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1251" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1251" target="_blank">Edit</a> </dd>  <dt><pre id="parseEnum%2Cstring" data-language="nim">proc parseEnum[T: enum](s: string): T</pre></dt> <dd> <p>Parses an enum <code>T</code>. This errors at compile time, if the given enum type contains multiple fields with the same string value.</p> <p>Raises <code>ValueError</code> for an invalid value in <code>s</code>. The comparison is done in a style insensitive way.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type
  MyEnum = enum
    first = "1st",
    second,
    third = "3rd"

doAssert parseEnum[MyEnum]("1_st") == first
doAssert parseEnum[MyEnum]("second") == second
doAssertRaises(ValueError):
  echo parseEnum[MyEnum]("third")</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1322" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1322" target="_blank">Edit</a> </dd>  <dt><pre id="parseEnum%2Cstring%2CT" data-language="nim">proc parseEnum[T: enum](s: string; default: T): T</pre></dt> <dd> <p>Parses an enum <code>T</code>. This errors at compile time, if the given enum type contains multiple fields with the same string value.</p> <p>Uses <code>default</code> for an invalid value in <code>s</code>. The comparison is done in a style insensitive way.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">type
  MyEnum = enum
    first = "1st",
    second,
    third = "3rd"

doAssert parseEnum[MyEnum]("1_st") == first
doAssert parseEnum[MyEnum]("second") == second
doAssert parseEnum[MyEnum]("last", third) == third</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1342" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1342" target="_blank">Edit</a> </dd>  <dt><pre id="repeat%2Cchar%2CNatural" data-language="nim">proc repeat(c: char; count: Natural): string {...}{.noSideEffect, gcsafe,
    extern: "nsuRepeatChar", raises: [], tags: [].}</pre></dt> <dd> Returns a string of length <code>count</code> consisting only of the character <code>c</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = 'z'
doAssert a.repeat(5) == "zzzzz"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1361" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1361" target="_blank">Edit</a> </dd>  <dt><pre id="repeat%2Cstring%2CNatural" data-language="nim">proc repeat(s: string; n: Natural): string {...}{.noSideEffect, gcsafe,
    extern: "nsuRepeatStr", raises: [], tags: [].}</pre></dt> <dd> Returns string <code>s</code> concatenated <code>n</code> times. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "+ foo +".repeat(3) == "+ foo ++ foo ++ foo +"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1371" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1371" target="_blank">Edit</a> </dd>  <dt><pre id="spaces%2CNatural" data-language="nim">proc spaces(n: Natural): string {...}{.inline, raises: [], tags: [].}</pre></dt> <dd> <p>Returns a string with <code>n</code> space characters. You can use this proc to left align strings.</p> <p>See also:</p> <ul class="simple">
<li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> <li><a href="#center,string,int,char">center proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let
  width = 15
  text1 = "Hello user!"
  text2 = "This is a very long string"
doAssert text1 &amp; spaces(max(0, width - text1.len)) &amp; "|" ==
         "Hello user!    |"
doAssert text2 &amp; spaces(max(0, width - text2.len)) &amp; "|" ==
         "This is a very long string|"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1380" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1380" target="_blank">Edit</a> </dd>  <dt><pre id="align%2Cstring%2CNatural%2Cchar" data-language="nim">proc align(s: string; count: Natural; padding = ' '): string {...}{.noSideEffect,
    gcsafe, extern: "nsuAlignString", raises: [], tags: [].}</pre></dt> <dd> <p>Aligns a string <code>s</code> with <code>padding</code>, so that it is of length <code>count</code>.</p> <p><code>padding</code> characters (by default spaces) are added before <code>s</code> resulting in right alignment. If <code>s.len &gt;= count</code>, no spaces are added and <code>s</code> is returned unchanged. If you need to left align a string use the <a href="#alignLeft,string,Natural,char">alignLeft proc</a>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> <li><a href="#center,string,int,char">center proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert align("abc", 4) == " abc"
assert align("a", 0) == "a"
assert align("1232", 6) == "  1232"
assert align("1232", 6, '#') == "##1232"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1400" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1400" target="_blank">Edit</a> </dd>  <dt><pre id="alignLeft%2Cstring%2CNatural%2Cchar" data-language="nim">proc alignLeft(s: string; count: Natural; padding = ' '): string {...}{.noSideEffect,
    raises: [], tags: [].}</pre></dt> <dd> <p>Left-Aligns a string <code>s</code> with <code>padding</code>, so that it is of length <code>count</code>.</p> <p><code>padding</code> characters (by default spaces) are added after <code>s</code> resulting in left alignment. If <code>s.len &gt;= count</code>, no spaces are added and <code>s</code> is returned unchanged. If you need to right align a string use the <a href="#align,string,Natural,char">align proc</a>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> <li><a href="#center,string,int,char">center proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">assert alignLeft("abc", 4) == "abc "
assert alignLeft("a", 0) == "a"
assert alignLeft("1232", 6) == "1232  "
assert alignLeft("1232", 6, '#') == "1232##"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1427" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1427" target="_blank">Edit</a> </dd>  <dt><pre id="center%2Cstring%2Cint%2Cchar" data-language="nim">proc center(s: string; width: int; fillChar: char = ' '): string {...}{.noSideEffect,
    gcsafe, extern: "nsuCenterString", raises: [], tags: [].}</pre></dt> <dd> <p>Return the contents of <code>s</code> centered in a string <code>width</code> long using <code>fillChar</code> (default: space) as padding.</p> <p>The original string is returned if <code>width</code> is less than or equal to <code>s.len</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "foo"
doAssert a.center(2) == "foo"
doAssert a.center(5) == " foo "
doAssert a.center(6) == " foo  "</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1455" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1455" target="_blank">Edit</a> </dd>  <dt><pre id="indent%2Cstring%2CNatural%2Cstring" data-language="nim">proc indent(s: string; count: Natural; padding: string = " "): string {...}{.
    noSideEffect, gcsafe, extern: "nsuIndent", raises: [], tags: [].}</pre></dt> <dd> <p>Indents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#unindent,string,Natural,string">unindent proc</a></li> <li><a href="#dedent,string,Natural">dedent proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert indent("First line\c\l and second line.", 2) ==
         "  First line\l   and second line."</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1490" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1490" target="_blank">Edit</a> </dd>  <dt><pre id="unindent%2Cstring%2CNatural%2Cstring" data-language="nim">proc unindent(s: string; count: Natural = int.high; padding: string = " "): string {...}{.
    noSideEffect, gcsafe, extern: "nsuUnindent", raises: [], tags: [].}</pre></dt> <dd> <p>Unindents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#dedent,string,Natural">dedent proc</a></li> <li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = """
      Hello
        There
    """.unindent()

doAssert x == "Hello\nThere\n"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1515" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1515" target="_blank">Edit</a> </dd>  <dt><pre id="indentation%2Cstring" data-language="nim">proc indentation(s: string): Natural {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns the amount of indentation all lines of <code>s</code> have in common, ignoring lines that consist only of whitespace. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1548" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1548" target="_blank">Edit</a> </dd>  <dt><pre id="dedent%2Cstring%2CNatural" data-language="nim">proc dedent(s: string; count: Natural = indentation(s)): string {...}{.noSideEffect,
    gcsafe, extern: "nsuDedent", raises: [], tags: [].}</pre></dt> <dd> <p>Unindents each line in <code>s</code> by <code>count</code> amount of <code>padding</code>. The only difference between this and the <a href="#unindent,string,Natural,string">unindent proc</a> is that this by default only cuts off the amount of indentation that all lines of <code>s</code> share as opposed to all indentation. It only supports spaces as padding.</p> <p><strong>Note:</strong> This does not preserve the new line characters used in <code>s</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#unindent,string,Natural,string">unindent proc</a></li> <li><a href="#align,string,Natural,char">align proc</a></li> <li><a href="#alignLeft,string,Natural,char">alignLeft proc</a></li> <li><a href="#spaces,Natural">spaces proc</a></li> <li><a href="#indent,string,Natural,string">indent proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = """
      Hello
        There
    """.dedent()

doAssert x == "Hello\n  There\n"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1561" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1561" target="_blank">Edit</a> </dd>  <dt><pre id="delete%2Cstring%2Cint%2Cint" data-language="nim">proc delete(s: var string; first, last: int) {...}{.noSideEffect, gcsafe,
    extern: "nsuDelete", raises: [], tags: [].}</pre></dt> <dd> <p>Deletes in <code>s</code> (must be declared as <code>var</code>) the characters at positions <code>first ..last</code> (both ends included).</p> <p>This modifies <code>s</code> itself, it does not return a copy.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var a = "abracadabra"

a.delete(4, 5)
doAssert a == "abradabra"

a.delete(1, 6)
doAssert a == "ara"

a.delete(2, 999)
doAssert a == "ar"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1586" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1586" target="_blank">Edit</a> </dd>  <dt><pre id="startsWith%2Cstring%2Cchar" data-language="nim">proc startsWith(s: string; prefix: char): bool {...}{.noSideEffect, inline,
    raises: [], tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> starts with character <code>prefix</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#endsWith,string,char">endsWith proc</a></li> <li><a href="#continuesWith,string,string,Natural">continuesWith proc</a></li> <li><a href="#removePrefix,string,char">removePrefix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "abracadabra"
doAssert a.startsWith('a') == true
doAssert a.startsWith('b') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1614" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1614" target="_blank">Edit</a> </dd>  <dt><pre id="startsWith%2Cstring%2Cstring" data-language="nim">proc startsWith(s, prefix: string): bool {...}{.noSideEffect, gcsafe,
    extern: "nsuStartsWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> starts with string <code>prefix</code>.</p> <p>If <code>prefix == ""</code> true is returned.</p> <p>See also:</p> <ul class="simple">
<li><a href="#endsWith,string,string">endsWith proc</a></li> <li><a href="#continuesWith,string,string,Natural">continuesWith proc</a></li> <li><a href="#removePrefix,string,string">removePrefix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "abracadabra"
doAssert a.startsWith("abra") == true
doAssert a.startsWith("bra") == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1627" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1627" target="_blank">Edit</a> </dd>  <dt><pre id="endsWith%2Cstring%2Cchar" data-language="nim">proc endsWith(s: string; suffix: char): bool {...}{.noSideEffect, inline, raises: [],
    tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> ends with <code>suffix</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#startsWith,string,char">startsWith proc</a></li> <li><a href="#continuesWith,string,string,Natural">continuesWith proc</a></li> <li><a href="#removeSuffix,string,char">removeSuffix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "abracadabra"
doAssert a.endsWith('a') == true
doAssert a.endsWith('b') == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1647" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1647" target="_blank">Edit</a> </dd>  <dt><pre id="endsWith%2Cstring%2Cstring" data-language="nim">proc endsWith(s, suffix: string): bool {...}{.noSideEffect, gcsafe,
    extern: "nsuEndsWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> ends with <code>suffix</code>.</p> <p>If <code>suffix == ""</code> true is returned.</p> <p>See also:</p> <ul class="simple">
<li><a href="#startsWith,string,string">startsWith proc</a></li> <li><a href="#continuesWith,string,string,Natural">continuesWith proc</a></li> <li><a href="#removeSuffix,string,string">removeSuffix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "abracadabra"
doAssert a.endsWith("abra") == true
doAssert a.endsWith("dab") == false</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1660" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1660" target="_blank">Edit</a> </dd>  <dt><pre id="continuesWith%2Cstring%2Cstring%2CNatural" data-language="nim">proc continuesWith(s, substr: string; start: Natural): bool {...}{.noSideEffect,
    gcsafe, extern: "nsuContinuesWith", raises: [], tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> continues with <code>substr</code> at position <code>start</code>.</p> <p>If <code>substr == ""</code> true is returned.</p> <p>See also:</p> <ul class="simple">
<li><a href="#startsWith,string,string">startsWith proc</a></li> <li><a href="#endsWith,string,string">endsWith proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "abracadabra"
doAssert a.continuesWith("ca", 4) == true
doAssert a.continuesWith("ca", 5) == false
doAssert a.continuesWith("dab", 6) == true</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1681" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1681" target="_blank">Edit</a> </dd>  <dt><pre id="removePrefix%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc removePrefix(s: var string; chars: set[char] = Newlines) {...}{.gcsafe,
    extern: "nsuRemovePrefixCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Removes all characters from <code>chars</code> from the start of the string <code>s</code> (in-place).</p> <p>See also:</p> <ul class="simple">
<li><a href="#removeSuffix,string,set%5Bchar%5D">removeSuffix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var userInput = "\r\n*~Hello World!"
userInput.removePrefix
doAssert userInput == "*~Hello World!"
userInput.removePrefix({'~', '*'})
doAssert userInput == "Hello World!"

var otherInput = "?!?Hello!?!"
otherInput.removePrefix({'!', '?'})
doAssert otherInput == "Hello!?!"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1702" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1702" target="_blank">Edit</a> </dd>  <dt><pre id="removePrefix%2Cstring%2Cchar" data-language="nim">proc removePrefix(s: var string; c: char) {...}{.gcsafe,
    extern: "nsuRemovePrefixChar", raises: [], tags: [].}</pre></dt> <dd> <p>Removes all occurrences of a single character (in-place) from the start of a string.</p> <p>See also:</p> <ul class="simple">
<li><a href="#removeSuffix,string,char">removeSuffix proc</a></li> <li><a href="#startsWith,string,char">startsWith proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var ident = "pControl"
ident.removePrefix('p')
doAssert ident == "Control"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1724" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1724" target="_blank">Edit</a> </dd>  <dt><pre id="removePrefix%2Cstring%2Cstring" data-language="nim">proc removePrefix(s: var string; prefix: string) {...}{.gcsafe,
    extern: "nsuRemovePrefixString", raises: [], tags: [].}</pre></dt> <dd> <p>Remove the first matching prefix (in-place) from a string.</p> <p>See also:</p> <ul class="simple">
<li><a href="#removeSuffix,string,string">removeSuffix proc</a></li> <li><a href="#startsWith,string,string">startsWith proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var answers = "yesyes"
answers.removePrefix("yes")
doAssert answers == "yes"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1738" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1738" target="_blank">Edit</a> </dd>  <dt><pre id="removeSuffix%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc removeSuffix(s: var string; chars: set[char] = Newlines) {...}{.gcsafe,
    extern: "nsuRemoveSuffixCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Removes all characters from <code>chars</code> from the end of the string <code>s</code> (in-place).</p> <p>See also:</p> <ul class="simple">
<li><a href="#removePrefix,string,set%5Bchar%5D">removePrefix proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var userInput = "Hello World!*~\r\n"
userInput.removeSuffix
doAssert userInput == "Hello World!*~"
userInput.removeSuffix({'~', '*'})
doAssert userInput == "Hello World!"

var otherInput = "Hello!?!"
otherInput.removeSuffix({'!', '?'})
doAssert otherInput == "Hello"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1752" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1752" target="_blank">Edit</a> </dd>  <dt><pre id="removeSuffix%2Cstring%2Cchar" data-language="nim">proc removeSuffix(s: var string; c: char) {...}{.gcsafe,
    extern: "nsuRemoveSuffixChar", raises: [], tags: [].}</pre></dt> <dd> <p>Removes all occurrences of a single character (in-place) from the end of a string.</p> <p>See also:</p> <ul class="simple">
<li><a href="#removePrefix,string,char">removePrefix proc</a></li> <li><a href="#endsWith,string,char">endsWith proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var table = "users"
table.removeSuffix('s')
doAssert table == "user"

var dots = "Trailing dots......."
dots.removeSuffix('.')
doAssert dots == "Trailing dots"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1775" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1775" target="_blank">Edit</a> </dd>  <dt><pre id="removeSuffix%2Cstring%2Cstring" data-language="nim">proc removeSuffix(s: var string; suffix: string) {...}{.gcsafe,
    extern: "nsuRemoveSuffixString", raises: [], tags: [].}</pre></dt> <dd> <p>Remove the first matching suffix (in-place) from a string.</p> <p>See also:</p> <ul class="simple">
<li><a href="#removePrefix,string,string">removePrefix proc</a></li> <li><a href="#endsWith,string,string">endsWith proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var answers = "yeses"
answers.removeSuffix("es")
doAssert answers == "yes"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1794" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1794" target="_blank">Edit</a> </dd>  <dt><pre id="addSep%2Cstring%2Cstring%2CNatural" data-language="nim">proc addSep(dest: var string; sep = ", "; startLen: Natural = 0) {...}{.noSideEffect,
    inline, raises: [], tags: [].}</pre></dt> <dd> <p>Adds a separator to <code>dest</code> only if its length is bigger than <code>startLen</code>.</p> <p>A shorthand for:</p> <pre class="listing" data-language="nim">if dest.len &gt; startLen: add(dest, sep)</pre>
<p>This is often useful for generating some code where the items need to be <em>separated</em> by <code>sep</code>. <code>sep</code> is only added if <code>dest</code> is longer than <code>startLen</code>. The following example creates a string describing an array of integers.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var arr = "["
for x in items([2, 3, 5, 7, 11]):
  addSep(arr, startLen = len("["))
  add(arr, $x)
add(arr, "]")
doAssert arr == "[2, 3, 5, 7, 11]"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1811" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1811" target="_blank">Edit</a> </dd>  <dt><pre id="allCharsInSet%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc allCharsInSet(s: string; theSet: set[char]): bool {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns true if every character of <code>s</code> is in the set <code>theSet</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert allCharsInSet("aeea", {'a', 'e'}) == true
doAssert allCharsInSet("", {'a', 'e'}) == true</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1834" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1834" target="_blank">Edit</a> </dd>  <dt><pre id="abbrev%2Cstring%2CopenArray%5Bstring%5D" data-language="nim">proc abbrev(s: string; possibilities: openArray[string]): int {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Returns the index of the first item in <code>possibilities</code> which starts with <code>s</code>, if not ambiguous.</p> <p>Returns -1 if no item has been found and -2 if multiple items match.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert abbrev("fac", ["college", "faculty", "industry"]) == 1
doAssert abbrev("foo", ["college", "faculty", "industry"]) == -1 # Not found
doAssert abbrev("fac", ["college", "faculty", "faculties"]) == -2 # Ambiguous
doAssert abbrev("college", ["college", "colleges", "industry"]) == 0</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1844" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1844" target="_blank">Edit</a> </dd>  <dt><pre id="join%2CopenArray%5Bstring%5D%2Cstring" data-language="nim">proc join(a: openArray[string]; sep: string = ""): string {...}{.noSideEffect,
    gcsafe, extern: "nsuJoinSep", raises: [], tags: [].}</pre></dt> <dd> Concatenates all strings in the container <code>a</code>, separating them with <code>sep</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert join(["A", "B", "Conclusion"], " -&gt; ") == "A -&gt; B -&gt; Conclusion"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1866" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1866" target="_blank">Edit</a> </dd>  <dt><pre id="join%2CopenArray%5BT%5D%2Cstring" data-language="nim">proc join[T: not string](a: openArray[T]; sep: string = ""): string {...}{.
    noSideEffect, gcsafe.}</pre></dt> <dd> Converts all elements in the container <code>a</code> to strings using <code>$</code>, and concatenates them with <code>sep</code>. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert join([1, 2, 3], " -&gt; ") == "1 -&gt; 2 -&gt; 3"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1883" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1883" target="_blank">Edit</a> </dd>  <dt><pre id="initSkipTable%2CSkipTable%2Cstring" data-language="nim">proc initSkipTable(a: var SkipTable; sub: string) {...}{.noSideEffect, gcsafe,
    extern: "nsuInitSkipTable", raises: [], tags: [].}</pre></dt> <dd> Preprocess table <code>a</code> for <code>sub</code>. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1899" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1899" target="_blank">Edit</a> </dd>  <dt><pre id="find%2CSkipTable%2Cstring%2Cstring%2CNatural%2Cint" data-language="nim">proc find(a: SkipTable; s, sub: string; start: Natural = 0; last = 0): int {...}{.
    noSideEffect, gcsafe, extern: "nsuFindStrA", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>sub</code> in <code>s</code> inside range <code>start..last</code> using preprocessed table <code>a</code>. If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>Searching is case-sensitive. If <code>sub</code> is not in <code>s</code>, -1 is returned.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1918" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1918" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Cstring%2Cchar%2CNatural%2Cint" data-language="nim">proc find(s: string; sub: char; start: Natural = 0; last = 0): int {...}{.
    noSideEffect, gcsafe, extern: "nsuFindChar", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>sub</code> in <code>s</code> inside range <code>start..last</code> (both ends included). If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>Searching is case-sensitive. If <code>sub</code> is not in <code>s</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].rfind</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#rfind,string,char,Natural">rfind proc</a></li> <li><a href="#replace,string,char,char">replace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1954" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1954" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Cstring%2Cset%5Bchar%5D%2CNatural%2Cint" data-language="nim">proc find(s: string; chars: set[char]; start: Natural = 0; last = 0): int {...}{.
    noSideEffect, gcsafe, extern: "nsuFindCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>chars</code> in <code>s</code> inside range <code>start..last</code> (both ends included). If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>If <code>s</code> contains none of the characters in <code>chars</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].find</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#rfind,string,set%5Bchar%5D,Natural">rfind proc</a></li> <li><a href="#multiReplace,string,varargs%5B%5D">multiReplace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1982" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1982" target="_blank">Edit</a> </dd>  <dt><pre id="find%2Cstring%2Cstring%2CNatural%2Cint" data-language="nim">proc find(s, sub: string; start: Natural = 0; last = 0): int {...}{.noSideEffect,
    gcsafe, extern: "nsuFindStr", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>sub</code> in <code>s</code> inside range <code>start..last</code> (both ends included). If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>Searching is case-sensitive. If <code>sub</code> is not in <code>s</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].find</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#rfind,string,string,Natural">rfind proc</a></li> <li><a href="#replace,string,string,string">replace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L1999" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L1999" target="_blank">Edit</a> </dd>  <dt><pre id="rfind%2Cstring%2Cchar%2CNatural" data-language="nim">proc rfind(s: string; sub: char; start: Natural = 0; last = -1): int {...}{.
    noSideEffect, gcsafe, extern: "nsuRFindChar", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>sub</code> in <code>s</code> inside range <code>start..last</code> (both ends included) in reverse -- starting at high indexes and moving lower to the first character or <code>start</code>. If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>Searching is case-sensitive. If <code>sub</code> is not in <code>s</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].find</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,char,Natural,int">find proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2017" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2017" target="_blank">Edit</a> </dd>  <dt><pre id="rfind%2Cstring%2Cset%5Bchar%5D%2CNatural" data-language="nim">proc rfind(s: string; chars: set[char]; start: Natural = 0; last = -1): int {...}{.
    noSideEffect, gcsafe, extern: "nsuRFindCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>chars</code> in <code>s</code> inside range <code>start..last</code> (both ends included) in reverse -- starting at high indexes and moving lower to the first character or <code>start</code>. If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>If <code>s</code> contains none of the characters in <code>chars</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].rfind</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,set%5Bchar%5D,Natural,int">find proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2035" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2035" target="_blank">Edit</a> </dd>  <dt><pre id="rfind%2Cstring%2Cstring%2CNatural" data-language="nim">proc rfind(s, sub: string; start: Natural = 0; last = -1): int {...}{.noSideEffect,
    gcsafe, extern: "nsuRFindStr", raises: [], tags: [].}</pre></dt> <dd> <p>Searches for <code>sub</code> in <code>s</code> inside range <code>start..last</code> (both ends included) included) in reverse -- starting at high indexes and moving lower to the first character or <code>start</code>. If <code>last</code> is unspecified, it defaults to <code>s.high</code> (the last element).</p> <p>Searching is case-sensitive. If <code>sub</code> is not in <code>s</code>, -1 is returned. Otherwise the index returned is relative to <code>s[0]</code>, not <code>start</code>. Use <code>s[start..last].rfind</code> for a <code>start</code>-origin index.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,string,Natural,int">find proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2053" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2053" target="_blank">Edit</a> </dd>  <dt><pre id="count%2Cstring%2Cchar" data-language="nim">proc count(s: string; sub: char): int {...}{.noSideEffect, gcsafe,
                                        extern: "nsuCountChar", raises: [],
                                        tags: [].}</pre></dt> <dd> <p>Count the occurrences of the character <code>sub</code> in the string <code>s</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#countLines,string">countLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2080" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2080" target="_blank">Edit</a> </dd>  <dt><pre id="count%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc count(s: string; subs: set[char]): int {...}{.noSideEffect, gcsafe,
    extern: "nsuCountCharSet", raises: [], tags: [].}</pre></dt> <dd> <p>Count the occurrences of the group of character <code>subs</code> in the string <code>s</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#countLines,string">countLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2090" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2090" target="_blank">Edit</a> </dd>  <dt><pre id="count%2Cstring%2Cstring%2Cbool" data-language="nim">proc count(s: string; sub: string; overlapping: bool = false): int {...}{.
    noSideEffect, gcsafe, extern: "nsuCountString", raises: [], tags: [].}</pre></dt> <dd> <p>Count the occurrences of a substring <code>sub</code> in the string <code>s</code>. Overlapping occurrences of <code>sub</code> only count when <code>overlapping</code> is set to true (default: false).</p> <p>See also:</p> <ul class="simple">
<li><a href="#countLines,string">countLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2101" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2101" target="_blank">Edit</a> </dd>  <dt><pre id="countLines%2Cstring" data-language="nim">proc countLines(s: string): int {...}{.noSideEffect, gcsafe, extern: "nsuCountLines",
                                  raises: [], tags: [].}</pre></dt> <dd> <p>Returns the number of lines in the string <code>s</code>.</p> <p>This is the same as <code>len(splitLines(s))</code>, but much more efficient because it doesn't modify the string creating temporal objects. Every <a href="manual.html#lexical-analysis-character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported.</p> <p>In this context, a line is any string separated by a newline combination. A line can be an empty string.</p> <p>See also:</p> <ul class="simple">
<li><a href="#splitLines,string">splitLines proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert countLines("First line\l and second line.") == 2</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2119" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2119" target="_blank">Edit</a> </dd>  <dt><pre id="contains%2Cstring%2Cstring" data-language="nim">proc contains(s, sub: string): bool {...}{.noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Same as <code>find(s, sub) &gt;= 0</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,string,Natural,int">find proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2147" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2147" target="_blank">Edit</a> </dd>  <dt><pre id="contains%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc contains(s: string; chars: set[char]): bool {...}{.noSideEffect, raises: [],
    tags: [].}</pre></dt> <dd> <p>Same as <code>find(s, chars) &gt;= 0</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,set%5Bchar%5D,Natural,int">find proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2154" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2154" target="_blank">Edit</a> </dd>  <dt><pre id="replace%2Cstring%2Cstring%2Cstring" data-language="nim">proc replace(s, sub: string; by = ""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuReplaceStr", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <code>sub</code> in <code>s</code> by the string <code>by</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,string,Natural,int">find proc</a></li> <li>
<a href="#replace,string,char,char">replace proc</a> for replacing single characters</li> <li><a href="#replaceWord,string,string,string">replaceWord proc</a></li> <li><a href="#multiReplace,string,varargs%5B%5D">multiReplace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2161" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2161" target="_blank">Edit</a> </dd>  <dt><pre id="replace%2Cstring%2Cchar%2Cchar" data-language="nim">proc replace(s: string; sub, by: char): string {...}{.noSideEffect, gcsafe,
    extern: "nsuReplaceChar", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <code>sub</code> in <code>s</code> by the character <code>by</code>.</p> <p>Optimized version of <a href="#replace,string,string,string">replace</a> for characters.</p> <p>See also:</p> <ul class="simple">
<li><a href="#find,string,char,Natural,int">find proc</a></li> <li><a href="#replaceWord,string,string,string">replaceWord proc</a></li> <li><a href="#multiReplace,string,varargs%5B%5D">multiReplace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2203" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2203" target="_blank">Edit</a> </dd>  <dt><pre id="replaceWord%2Cstring%2Cstring%2Cstring" data-language="nim">proc replaceWord(s, sub: string; by = ""): string {...}{.noSideEffect, gcsafe,
    extern: "nsuReplaceWord", raises: [], tags: [].}</pre></dt> <dd> <p>Replaces <code>sub</code> in <code>s</code> by the string <code>by</code>.</p> <p>Each occurrence of <code>sub</code> has to be surrounded by word boundaries (comparable to <code>\b</code> in regular expressions), otherwise it is not replaced.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2221" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2221" target="_blank">Edit</a> </dd>  <dt><pre id="multiReplace%2Cstring%2Cvarargs%5B%5D" data-language="nim">proc multiReplace(s: string; replacements: varargs[(string, string)]): string {...}{.
    noSideEffect, raises: [], tags: [].}</pre></dt> <dd> <p>Same as replace, but specialized for doing multiple replacements in a single pass through the input string.</p> <p><code>multiReplace</code> performs all replacements in a single pass, this means it can be used to swap the occurrences of "a" and "b", for instance.</p> <p>If the resulting string is not longer than the original input string, only a single memory allocation is required.</p> <p>The order of the replacements does matter. Earlier replacements are preferred over later replacements in the argument list.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2252" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2252" target="_blank">Edit</a> </dd>  <dt><pre id="insertSep%2Cstring%2Cchar%2Cint" data-language="nim">proc insertSep(s: string; sep = '_'; digits = 3): string {...}{.noSideEffect, gcsafe,
    extern: "nsuInsertSep", raises: [], tags: [].}</pre></dt> <dd> <p>Inserts the separator <code>sep</code> after <code>digits</code> characters (default: 3) from right to left.</p> <p>Even though the algorithm works with any string <code>s</code>, it is only useful if <code>s</code> contains a number.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert insertSep("1000000") == "1_000_000"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2288" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2288" target="_blank">Edit</a> </dd>  <dt><pre id="escape%2Cstring%2Cstring%2Cstring" data-language="nim">proc escape(s: string; prefix = "\""; suffix = "\""): string {...}{.noSideEffect,
    gcsafe, extern: "nsuEscape", raises: [], tags: [].}</pre></dt> <dd> <p>Escapes a string <code>s</code>. See <a href="system.html#addEscapedChar,string,char">system.addEscapedChar</a> for the escaping scheme.</p> <p>The resulting string is prefixed with <code>prefix</code> and suffixed with <code>suffix</code>. Both may be empty strings.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="#unescape,string,string,string">unescape proc</a> for the opposite</li> </ul> <p>operation</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2322" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2322" target="_blank">Edit</a> </dd>  <dt><pre id="unescape%2Cstring%2Cstring%2Cstring" data-language="nim">proc unescape(s: string; prefix = "\""; suffix = "\""): string {...}{.noSideEffect,
    gcsafe, extern: "nsuUnescape", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Unescapes a string <code>s</code>.</p> <p>This complements <a href="#escape,string,string,string">escape proc</a> as it performs the opposite operations.</p> <p>If <code>s</code> does not begin with <code>prefix</code> and end with <code>suffix</code> a ValueError exception will be raised.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2346" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2346" target="_blank">Edit</a> </dd>  <dt><pre id="validIdentifier%2Cstring" data-language="nim">proc validIdentifier(s: string): bool {...}{.noSideEffect, gcsafe,
                                        extern: "nsuValidIdentifier",
                                        raises: [], tags: [].}</pre></dt> <dd> <p>Returns true if <code>s</code> is a valid identifier.</p> <p>A valid identifier starts with a character of the set <code>IdentStartChars</code> and is followed by any number of characters of the set <code>IdentChars</code>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert "abc_def08".validIdentifier</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2389" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2389" target="_blank">Edit</a> </dd>  <dt><pre id="formatBiggestFloat%2CBiggestFloat%2CFloatFormatMode%2Crange%5B%5D%2Cchar" data-language="nim">proc formatBiggestFloat(f: BiggestFloat; format: FloatFormatMode = ffDefault;
                        precision: range[-1 .. 32] = 16; decimalSep = '.'): string {...}{.
    noSideEffect, gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <code>f</code> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <code>precision</code>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>biggestFloat</code> type.</p> <p>If <code>precision == -1</code>, it tries to format it nicely.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = 123.456
doAssert x.formatBiggestFloat() == "123.4560000000000"
doAssert x.formatBiggestFloat(ffDecimal, 4) == "123.4560"
doAssert x.formatBiggestFloat(ffScientific, 2) == "1.23e+02"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2416" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2416" target="_blank">Edit</a> </dd>  <dt><pre id="formatFloat%2Cfloat%2CFloatFormatMode%2Crange%5B%5D%2Cchar" data-language="nim">proc formatFloat(f: float; format: FloatFormatMode = ffDefault;
                 precision: range[-1 .. 32] = 16; decimalSep = '.'): string {...}{.
    noSideEffect, gcsafe, extern: "nsu$1", raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <code>f</code> to a string.</p> <p>If <code>format == ffDecimal</code> then precision is the number of digits to be printed after the decimal point. If <code>format == ffScientific</code> then precision is the maximum number of significant digits to be printed. <code>precision</code>'s default value is the maximum number of meaningful digits after the decimal point for Nim's <code>float</code> type.</p> <p>If <code>precision == -1</code>, it tries to format it nicely.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let x = 123.456
doAssert x.formatFloat() == "123.4560000000000"
doAssert x.formatFloat(ffDecimal, 4) == "123.4560"
doAssert x.formatFloat(ffScientific, 2) == "1.23e+02"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2496" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2496" target="_blank">Edit</a> </dd>  <dt><pre id="trimZeros%2Cstring%2Cchar" data-language="nim">proc trimZeros(x: var string; decimalSep = '.') {...}{.noSideEffect, raises: [],
    tags: [].}</pre></dt> <dd> <p>Trim trailing zeros from a formatted floating point value <code>x</code> (must be declared as <code>var</code>).</p> <p>This modifies <code>x</code> itself, it does not return a copy.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var x = "123.456000000"
x.trimZeros()
doAssert x == "123.456"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2517" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2517" target="_blank">Edit</a> </dd>  <dt><pre id="formatSize%2Cint64%2Cchar" data-language="nim">proc formatSize(bytes: int64; decimalSep = '.'; prefix = bpIEC;
                includeSpace = false): string {...}{.noSideEffect, raises: [],
    tags: [].}</pre></dt> <dd> <p>Rounds and formats <code>bytes</code>.</p> <p>By default, uses the IEC/ISO standard binary prefixes, so 1024 will be formatted as 1KiB. Set prefix to <code>bpColloquial</code> to use the colloquial names from the SI standard (e.g. k for 1000 being reused as 1024).</p> <p><code>includeSpace</code> can be set to true to include the (SI preferred) space between the number and the unit (e.g. 1 KiB).</p> <p>See also:</p> <ul class="simple">
<li>
<a href="strformat.html">strformat module</a> for string interpolation and formatting</li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">doAssert formatSize((1'i64 shl 31) + (300'i64 shl 20)) == "2.293GiB"
doAssert formatSize((2.234*1024*1024).int) == "2.234MiB"
doAssert formatSize(4096, includeSpace = true) == "4 KiB"
doAssert formatSize(4096, prefix = bpColloquial, includeSpace = true) == "4 kB"
doAssert formatSize(4096) == "4KiB"
doAssert formatSize(5_378_934, prefix = bpColloquial, decimalSep = ',') == "5,13MB"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2541" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2541" target="_blank">Edit</a> </dd>  <dt><pre id="formatEng%2CBiggestFloat%2Crange%5B%5D%2Cbool%2Cbool%2Cstring%2Cchar" data-language="nim">proc formatEng(f: BiggestFloat; precision: range[0 .. 32] = 10;
               trim: bool = true; siPrefix: bool = false; unit: string = "";
               decimalSep = '.'; useUnitSpace = false): string {...}{.noSideEffect,
    raises: [], tags: [].}</pre></dt> <dd> <p>Converts a floating point value <code>f</code> to a string using engineering notation.</p> <p>Numbers in of the range -1000.0&lt;f&lt;1000.0 will be formatted without an exponent. Numbers outside of this range will be formatted as a significand in the range -1000.0&lt;f&lt;1000.0 and an exponent that will always be an integer multiple of 3, corresponding with the SI prefix scale k, M, G, T etc for numbers with an absolute value greater than 1 and m, , n, p etc for numbers with an absolute value less than 1.</p> <p>The default configuration (<code>trim=true</code> and <code>precision=10</code>) shows the <strong>shortest</strong> form that precisely (up to a maximum of 10 decimal places) displays the value. For example, 4.100000 will be displayed as 4.1 (which is mathematically identical) whereas 4.1000003 will be displayed as 4.1000003.</p> <p>If <code>trim</code> is set to true, trailing zeros will be removed; if false, the number of digits specified by <code>precision</code> will always be shown.</p> <p><code>precision</code> can be used to set the number of digits to be shown after the decimal point or (if <code>trim</code> is true) the maximum number of digits to be shown.</p> <pre class="listing" data-language="nim">formatEng(0, 2, trim=false) == "0.00"
formatEng(0, 2) == "0"
formatEng(0.053, 0) == "53e-3"
formatEng(52731234, 2) == "52.73e6"
formatEng(-52731234, 2) == "-52.73e6"</pre>
<p>If <code>siPrefix</code> is set to true, the number will be displayed with the SI prefix corresponding to the exponent. For example 4100 will be displayed as "4.1 k" instead of "4.1e3". Note that <code>u</code> is used for micro- in place of the greek letter mu () as per ISO 2955. Numbers with an absolute value outside of the range 1e-18&lt;f&lt;1000e18 (1a&lt;f&lt;1000E) will be displayed with an exponent rather than an SI prefix, regardless of whether <code>siPrefix</code> is true.</p> <p>If <code>useUnitSpace</code> is true, the provided unit will be appended to the string (with a space as required by the SI standard). This behaviour is slightly different to appending the unit to the result as the location of the space is altered depending on whether there is an exponent.</p> <pre class="listing" data-language="nim">formatEng(4100, siPrefix=true, unit="V") == "4.1 kV"
formatEng(4.1, siPrefix=true, unit="V") == "4.1 V"
formatEng(4.1, siPrefix=true) == "4.1" # Note lack of space
formatEng(4100, siPrefix=true) == "4.1 k"
formatEng(4.1, siPrefix=true, unit="") == "4.1 " # Space with unit=""
formatEng(4100, siPrefix=true, unit="") == "4.1 k"
formatEng(4100) == "4.1e3"
formatEng(4100, unit="V") == "4.1e3 V"
formatEng(4100, unit="", useUnitSpace=true) == "4.1e3 " # Space with useUnitSpace=true</pre>
<p><code>decimalSep</code> is used as the decimal separator.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="strformat.html">strformat module</a> for string interpolation and formatting</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2597" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2597" target="_blank">Edit</a> </dd>  <dt><pre id="addf%2Cstring%2Cstring%2Cvarargs%5Bstring%2C%5D" data-language="nim">proc addf(s: var string; formatstr: string; a: varargs[string, `$`]) {...}{.
    noSideEffect, gcsafe, extern: "nsuAddf", raises: [ValueError], tags: [].}</pre></dt> <dd> The same as <code>add(s, formatstr % a)</code>, but more efficient. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2748" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2748" target="_blank">Edit</a> </dd>  <dt><pre id="%25%2Cstring%2CopenArray%5Bstring%5D" data-language="nim">proc `%`(formatstr: string; a: openArray[string]): string {...}{.noSideEffect,
    gcsafe, extern: "nsuFormatOpenArray", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>Interpolates a format string with the values from <code>a</code>.</p> <p>The <span id="substitution_1">substitution</span> operator performs string substitutions in <code>formatstr</code> and returns a modified <code>formatstr</code>. This is often called <span id="string-interpolation_1">string interpolation</span>.</p> <p>This is best explained by an example:</p> <pre class="listing" data-language="nim">"$1 eats $2." % ["The cat", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The substitution variables (the thing after the <code>$</code>) are enumerated from 1 to <code>a.len</code>. To produce a verbatim <code>$</code>, use <code>$$</code>. The notation <code>$#</code> can be used to refer to the next substitution variable:</p> <pre class="listing" data-language="nim">"$# eats $#." % ["The cat", "fish"]</pre>
<p>Substitution variables can also be words (that is <code>[A-Za-z_]+[A-Za-z0-9_]*</code>) in which case the arguments in <code>a</code> with even indices are keys and with odd indices are the corresponding values. An example:</p> <pre class="listing" data-language="nim">"$animal eats $food." % ["animal", "The cat", "food", "fish"]</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"The cat eats fish."</pre>
<p>The variables are compared with <code>cmpIgnoreStyle</code>. <code>ValueError</code> is raised if an ill-formed format string has been passed to the <code>%</code> operator.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="strformat.html">strformat module</a> for string interpolation and formatting</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2811" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2811" target="_blank">Edit</a> </dd>  <dt><pre id="%25%2Cstring%2Cstring" data-language="nim">proc `%`(formatstr, a: string): string {...}{.noSideEffect, gcsafe,
    extern: "nsuFormatSingleElem", raises: [ValueError], tags: [].}</pre></dt> <dd> This is the same as <code>formatstr % [a]</code> (see <a href="#%25,string,openArray%5Bstring%5D">% proc</a>). <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2859" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2859" target="_blank">Edit</a> </dd>  <dt><pre id="format%2Cstring%2Cvarargs%5Bstring%2C%5D" data-language="nim">proc format(formatstr: string; a: varargs[string, `$`]): string {...}{.noSideEffect,
    gcsafe, extern: "nsuFormatVarargs", raises: [ValueError], tags: [].}</pre></dt> <dd> <p>This is the same as <code>formatstr % a</code> (see <a href="#%25,string,openArray%5Bstring%5D">% proc</a>) except that it supports auto stringification.</p> <p>See also:</p> <ul class="simple">
<li>
<a href="strformat.html">strformat module</a> for string interpolation and formatting</li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2866" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2866" target="_blank">Edit</a> </dd>  <dt><pre id="strip%2Cstring%2Cset%5Bchar%5D" data-language="nim">proc strip(s: string; leading = true; trailing = true;
           chars: set[char] = Whitespace): string {...}{.noSideEffect, gcsafe,
    extern: "nsuStrip", raises: [], tags: [].}</pre></dt> <dd> <p>Strips leading or trailing <code>chars</code> (default: whitespace characters) from <code>s</code> and returns the resulting string.</p> <p>If <code>leading</code> is true (default), leading <code>chars</code> are stripped. If <code>trailing</code> is true (default), trailing <code>chars</code> are stripped. If both are false, the string is returned unchanged.</p> <p>See also:</p> <ul class="simple">
<li><a href="#stripLineEnd,string">stripLineEnd proc</a></li> </ul> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">let a = "  vhellov   "
let b = strip(a)
doAssert b == "vhellov"

doAssert a.strip(leading = false) == "  vhellov"
doAssert a.strip(trailing = false) == "vhellov   "

doAssert b.strip(chars = {'v'}) == "hello"
doAssert b.strip(leading = false, chars = {'v'}) == "vhello"

let c = "blaXbla"
doAssert c.strip(chars = {'b', 'a'}) == "laXbl"
doAssert c.strip(chars = {'b', 'a', 'l'}) == "X"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2878" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2878" target="_blank">Edit</a> </dd>  <dt><pre id="stripLineEnd%2Cstring" data-language="nim">proc stripLineEnd(s: var string) {...}{.raises: [], tags: [].}</pre></dt> <dd> Returns <code>s</code> stripped from one of these suffixes: <code>\r, \n, \r\n, \f, \v</code> (at most once instance). For example, can be useful in conjunction with <code>osproc.execCmdEx</code>. aka: <span id="chomp_1">chomp</span> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">var s = "foo\n\n"
s.stripLineEnd
doAssert s == "foo\n"
s = "foo\r\n"
s.stripLineEnd
doAssert s == "foo"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2914" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2914" target="_blank">Edit</a> </dd>  <dt><pre id="isEmptyOrWhitespace%2Cstring" data-language="nim">proc isEmptyOrWhitespace(s: string): bool {...}{.noSideEffect, gcsafe,
    extern: "nsuIsEmptyOrWhitespace", raises: [], tags: [].}</pre></dt> <dd> Checks if <code>s</code> is empty or consists entirely of whitespace characters. <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2974" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2974" target="_blank">Edit</a> </dd> </dl>  <h2 id="15">Iterators</h2> <dl>  <dt><pre id="split.i%2Cstring%2Cchar%2Cint" data-language="nim">iterator split(s: string; sep: char; maxsplit: int = -1): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into substrings using a single separator.</p> <p>Substrings are separated by the character <code>sep</code>. The code:</p> <pre class="listing" data-language="nim">for word in split(";;this;is;an;;example;;;", ';'):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
""
"this"
"is"
"an"
""
"example"
""
""
""</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,char,int">rsplit iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#split,string,char,int">split proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L437" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L437" target="_blank">Edit</a> </dd>  <dt><pre id="split.i%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">iterator split(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into substrings using a group of separators.</p> <p>Substrings are separated by a substring containing only <code>seps</code>.</p> <pre class="listing" data-language="nim">for word in split("this\lis an\texample"):
  writeLine(stdout, word)</pre>
<p>...generates this output:</p> <pre class="listing" data-language="nim">"this"
"is"
"an"
"example"</pre>
<p>And the following code:</p> <pre class="listing" data-language="nim">for word in split("this:is;an$example", {';', ':', '$'}):
  writeLine(stdout, word)</pre>
<p>...produces the same output as the first example. The code:</p> <pre class="listing" data-language="nim">let date = "2012-11-20T22:08:08.398990"
let separators = {' ', '-', ':', 'T'}
for number in split(date, separators):
  writeLine(stdout, number)</pre>
<p>...results in:</p> <pre class="listing" data-language="nim">"2012"
"11"
"20"
"22"
"08"
"08.398990"</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,set%5Bchar%5D,int">rsplit iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#split,string,set%5Bchar%5D,int">split proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L468" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L468" target="_blank">Edit</a> </dd>  <dt><pre id="split.i%2Cstring%2Cstring%2Cint" data-language="nim">iterator split(s: string; sep: string; maxsplit: int = -1): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into substrings using a string separator.</p> <p>Substrings are separated by the string <code>sep</code>. The code:</p> <pre class="listing" data-language="nim">for word in split("thisDATAisDATAcorrupted", "DATA"):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"this"
"is"
"corrupted"</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#rsplit.i,string,string,int,bool">rsplit iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#split,string,string,int">split proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L517" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L517" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit.i%2Cstring%2Cchar%2Cint" data-language="nim">iterator rsplit(s: string; sep: char; maxsplit: int = -1): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> Splits the string <code>s</code> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo:bar".rsplit(':'):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the char <code>sep</code>.</p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,char,int">split iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#rsplit,string,char,int">rsplit proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L566" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L566" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit.i%2Cstring%2Cset%5Bchar%5D%2Cint" data-language="nim">iterator rsplit(s: string; seps: set[char] = Whitespace; maxsplit: int = -1): string {...}{.
    raises: [], tags: [].}</pre></dt> <dd> Splits the string <code>s</code> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,char,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foo bar".rsplit(WhiteSpace):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the set of chars <code>seps</code></p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,set%5Bchar%5D,int">split iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#rsplit,string,set%5Bchar%5D,int">rsplit proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L591" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L591" target="_blank">Edit</a> </dd>  <dt><pre id="rsplit.i%2Cstring%2Cstring%2Cint%2Cbool" data-language="nim">iterator rsplit(s: string; sep: string; maxsplit: int = -1;
                keepSeparators: bool = false): string {...}{.raises: [], tags: [].}</pre></dt> <dd> Splits the string <code>s</code> into substrings from the right using a string separator. Works exactly the same as <a href="#split.i,string,string,int">split iterator</a> except in reverse order.<pre class="listing" data-language="nim">for piece in "foothebar".rsplit("the"):
  echo piece</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">"bar"
"foo"</pre>
<p>Substrings are separated from the right by the string <code>sep</code></p> <p>See also:</p> <ul class="simple">
<li><a href="#split.i,string,string,int">split iterator</a></li> <li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#rsplit,string,string,int">rsplit proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L616" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L616" target="_blank">Edit</a> </dd>  <dt><pre id="splitLines.i%2Cstring" data-language="nim">iterator splitLines(s: string; keepEol = false): string {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> into its containing lines.</p> <p>Every <a href="manual.html#lexical-analysis-character-literals">character literal</a> newline combination (CR, LF, CR-LF) is supported. The result strings contain no trailing end of line characters unless parameter <code>keepEol</code> is set to <code>true</code>.</p> <p>Example:</p> <pre class="listing" data-language="nim">for line in splitLines("\nthis\nis\nan\n\nexample\n"):
  writeLine(stdout, line)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">""
"this"
"is"
"an"
""
"example"
""</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#splitWhitespace.i,string,int">splitWhitespace iterator</a></li> <li><a href="#splitLines,string">splitLines proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L641" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L641" target="_blank">Edit</a> </dd>  <dt><pre id="splitWhitespace.i%2Cstring%2Cint" data-language="nim">iterator splitWhitespace(s: string; maxsplit: int = -1): string {...}{.raises: [],
    tags: [].}</pre></dt> <dd> <p>Splits the string <code>s</code> at whitespace stripping leading and trailing whitespace if necessary. If <code>maxsplit</code> is specified and is positive, no more than <code>maxsplit</code> splits is made.</p> <p>The following code:</p> <pre class="listing" data-language="nim">let s = "  foo \t bar  baz  "
for ms in [-1, 1, 2, 3]:
  echo "------ maxsplit = ", ms, ":"
  for item in s.splitWhitespace(maxsplit=ms):
    echo '"', item, '"'</pre>
<p>...results in:</p> <pre class="listing" data-language="nim">------ maxsplit = -1:
"foo"
"bar"
"baz"
------ maxsplit = 1:
"foo"
"bar  baz  "
------ maxsplit = 2:
"foo"
"bar"
"baz  "
------ maxsplit = 3:
"foo"
"bar"
"baz"</pre>
<p>See also:</p> <ul class="simple">
<li><a href="#splitLines.i,string">splitLines iterator</a></li> <li><a href="#splitWhitespace,string,int">splitWhitespace proc</a></li> </ul> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L690" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L690" target="_blank">Edit</a> </dd>  <dt><pre id="tokenize.i%2Cstring%2Cset%5Bchar%5D" data-language="nim">iterator tokenize(s: string; seps: set[char] = Whitespace): tuple[token: string,
    isSep: bool] {...}{.raises: [], tags: [].}</pre></dt> <dd> <p>Tokenizes the string <code>s</code> into substrings.</p> <p>Substrings are separated by a substring containing only <code>seps</code>. Example:</p> <pre class="listing" data-language="nim">for word in tokenize("  this is an  example  "):
  writeLine(stdout, word)</pre>
<p>Results in:</p> <pre class="listing" data-language="nim">("  ", true)
("this", false)
(" ", true)
("is", false)
(" ", true)
("an", false)
("  ", true)
("example", false)
("  ", true)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/strutils.nim#L2940" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/strutils.nim#L2940" target="_blank">Edit</a> </dd> </dl>  <h2 id="19">Exports</h2> <dl> <a href="unicode.html#toLower,string"><span class="Identifier">toLower</span></a>, <a href="unicode.html#toLower,Rune"><span class="Identifier">toLower</span></a>, <a href="unicode.html#toUpper,Rune"><span class="Identifier">toUpper</span></a>, <a href="unicode.html#toUpper,string"><span class="Identifier">toUpper</span></a> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/strutils.html" class="_attribution-link">https://nim-lang.org/docs/strutils.html</a>
  </p>
</div>
