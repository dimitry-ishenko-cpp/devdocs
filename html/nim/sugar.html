<h1 class="title">sugar</h1>  <p class="module-desc">This module implements nice syntactic sugar based on Nim's macro system.</p>  <h2 id="6">Imports</h2> <dl> <a href="since.html">since</a>, <a href="macros.html">macros</a>, <a href="underscored_calls.html">underscored_calls</a>, <a href="algorithm.html">algorithm</a>, <a href="random.html">random</a>, <a href="sets.html">sets</a>, <a href="tables.html">tables</a>, <a href="strutils.html">strutils</a> </dl>  <h2 id="17">Macros</h2> <dl>  <dt><pre id="%3D%3E.m%2Cuntyped%2Cuntyped" data-language="nim">macro `=&gt;`(p, b: untyped): untyped</pre></dt> <dd> Syntax sugar for anonymous procedures. It also supports pragmas. <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">proc passTwoAndTwo(f: (int, int) -&gt; int): int =
  f(2, 2)

doAssert passTwoAndTwo((x, y) =&gt; x + y) == 4

type
  Bot = object
    call: proc (): string {.nosideEffect.}

var myBot = Bot()

myBot.call = () {.nosideEffect.} =&gt; "I'm a bot."
doAssert myBot.call() == "I'm a bot."</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L58" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L58" target="_blank">Edit</a> </dd>  <dt><pre id="-%3E.m%2Cuntyped%2Cuntyped" data-language="nim">macro `-&gt;`(p, b: untyped): untyped</pre></dt> <dd> Syntax sugar for procedure types.<pre class="listing" data-language="nim">proc pass2(f: (float, float) -&gt; float): float =
  f(2, 2)

# is the same as:

proc pass2(f: proc (x, y: float): float): float =
  f(2, 2)</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L146" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L146" target="_blank">Edit</a> </dd>  <dt><pre id="dump.m%2Cuntyped" data-language="nim">macro dump(x: untyped): untyped</pre></dt> <dd> <p>Dumps the content of an expression, useful for debugging. It accepts any expression and prints a textual representation of the tree representing the expression - as it would appear in source code - together with the value of the expression.</p> <p>As an example,</p> <pre class="listing" data-language="nim">let
  x = 10
  y = 20
dump(x + y)</pre>
<p>will print <code>x + y = 30</code>.</p> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L161" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L161" target="_blank">Edit</a> </dd>  <dt><pre id="capture.m%2Cvarargs%5Btyped%5D%2Cuntyped" data-language="nim">macro capture(locals: varargs[typed]; body: untyped): untyped</pre></dt> <dd> Useful when creating a closure in a loop to capture some local loop variables by their current iteration values. Example:<pre class="listing" data-language="nim">import strformat, sequtils, sugar
var myClosure : proc()
for i in 5..7:
  for j in 7..9:
    if i * j == 42:
      capture i, j:
        myClosure = proc () = echo fmt"{i} * {j} = 42"
myClosure() # output: 6 * 7 == 42
let m = @[proc (s: string): string = "to " &amp; s, proc (s: string): string = "not to " &amp; s]
var l = m.mapIt(capture(it, proc (s: string): string = it(s)))
let r = l.mapIt(it("be"))
echo r[0] &amp; ", or " &amp; r[1] # output: to be, or not to be</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L197" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L197" target="_blank">Edit</a> </dd>  <dt><pre id="dup.m%2CT%2Cvarargs%5Buntyped%5D" data-language="nim">macro dup[T](arg: T; calls: varargs[untyped]): T</pre></dt> <dd> <p>Turns an <span id="inminusplace_1">in-place</span> algorithm into one that works on a copy and returns this copy, without modifying its input.</p> <p>This macro also allows for (otherwise in-place) function chaining.</p> <p><strong>Since</strong>: Version 1.2.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import algorithm

var a = @[1, 2, 3, 4, 5, 6, 7, 8, 9]
doAssert a.dup(sort) == sorted(a)
# Chaining:
var aCopy = a
aCopy.insert(10)

doAssert a.dup(insert(10), sort) == sorted(aCopy)

var s1 = "abc"
var s2 = "xyz"
doAssert s1 &amp; s2 == s1.dup(&amp;= s2)

proc makePalindrome(s: var string) =
  for i in countdown(s.len-2, 0):
    s.add(s[i])

var c = "xyz"

# An underscore (_) can be used to denote the place of the argument you're passing:
doAssert "".dup(addQuoted(_, "foo")) == "\"foo\""
# but `_` is optional here since the substitution is in 1st position:
doAssert "".dup(addQuoted("foo")) == "\"foo\""

# chaining:
# b = "xyz"
var d = dup c:
  makePalindrome # xyzyx
  sort(_, SortOrder.Descending) # zyyxx
  makePalindrome # zyyxxxyyz

doAssert d == "zyyxxxyyz"</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L228" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L228" target="_blank">Edit</a> </dd>  <dt><pre id="collect.m%2Cuntyped%2Cuntyped" data-language="nim">macro collect(init, body: untyped): untyped</pre></dt> <dd> <p>Comprehension for seq/set/table collections. <code>init</code> is the init call, and so custom collections are supported.</p> <p>The last statement of <code>body</code> has special syntax that specifies the collection's add operation. Use <code>{e}</code> for set's <code>incl</code>, <code>{k: v}</code> for table's <code>[]=</code> and <code>e</code> for seq's <code>add</code>.</p> <p>The <code>init</code> proc can be called with any number of arguments, i.e. <code>initTable(initialSize)</code>.</p> <p><strong class="examples_text">Example:</strong></p> <pre class="listing" data-language="nim">import sets, tables
let data = @["bird", "word"]
## seq:
let k = collect(newSeq):
  for i, d in data.pairs:
    if i mod 2 == 0: d

assert k == @["bird"]
## seq with initialSize:
let x = collect(newSeqOfCap(4)):
  for i, d in data.pairs:
    if i mod 2 == 0: d

assert x == @["bird"]
## HashSet:
let y = initHashSet.collect:
  for d in data.items: {d}

assert y == data.toHashSet
## Table:
let z = collect(initTable(2)):
  for i, d in data.pairs: {i: d}

assert z == {0: "bird", 1: "word"}.toTable</pre> <a href="https://github.com/nim-lang/Nim/tree/version-1-4/lib/pure/sugar.nim#L314" target="_blank">Source</a> <a href="https://github.com/nim-lang/Nim/edit/devel/lib/pure/sugar.nim#L314" target="_blank">Edit</a> </dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2021 Andreas Rumpf<br>Licensed under the MIT License.<br>
    <a href="https://nim-lang.org/docs/sugar.html" class="_attribution-link">https://nim-lang.org/docs/sugar.html</a>
  </p>
</div>
