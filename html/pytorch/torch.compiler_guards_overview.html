<h1 id="guards-overview">Guards Overview</h1> <p>From a UX perspective, TorchDynamo is very easy to use. The user invokes <code>torchdynamo.optimize</code> as an annotation:</p> <pre data-language="python">@torchdynamo.optimize(my_compiler)
def fn_foo(bar):
</pre> <p>Where a complete example looks like this:</p> <pre data-language="python">from typing import List
import torch
from torch import _dynamo as torchdynamo

def my_compiler(gm: torch.fx.GraphModule, example_inputs: List[torch.Tensor]):
    print("my_compiler() called with FX graph:")
    gm.graph.print_tabular()
    return gm.forward  # return a python callable

@torchdynamo.optimize(my_compiler)
def toy_example(a, b):
    x = a / (torch.abs(a) + 1)
    if b.sum() &lt; 0:
        b = b * -1
    return x * b

for _ in range(100):
    toy_example(torch.randn(10), torch.randn(10))
</pre> <p>This allows TorchDynamo to capture the interpreted Python frames, grab any and all relevant information, and speed things up wherever it can. The speedup comes from a few places, and can be rather dependent on the backend (<code>my_compiler</code> in the example above) provided, but the one speedup that is important in this section is <strong>caching</strong>. Caching itself is not a direct speedup but a critical enablement that prevents recompilation. We dig a hole with dynamo, and caching allows us to get out. It enables us to hold perf neutrality while then enabling backends - the true source of our speedups.</p> <p>With even a pass-through no-op backend provided:</p> <pre data-language="python">def my_compiler(gm: torch.fx.GraphModule, example_inputs: List[torch.Tensor]):
    return gm.forward
</pre> <p>We can see TorchDynamo speeding up Python execution even on regular Python, not just PyTorch.</p>  <h2 id="caching-and-guards-overview">Caching and Guards Overview</h2> <p>TorchDynamo operates through caching transformed (by TorchDynamo) user bytecode. When TorchDynamo receives a frame for evaluation, it checks if the <strong>objects referenced in the frame have changed</strong> in certain ways, and if not, TorchDynamo reads the previously transformed user bytecode to evaluate it. In this section, we will focus on how we can identify whether or not the <strong>objects referenced in the frame have changed</strong>. This is a critical piece of functionality in TorchDynamo, because it drives the entire invalidation lifecycle. This functionality is called <strong>guards</strong>.</p> <p>At a very high level, the flow can be summarized like this:</p> <ol class="arabic simple"> <li>TorchDynamo receives a Python frame.</li> <li>It converts the frame (1) passing it through instruction translation.</li> <li>
<p>For the objects captured in (2), TorchDynamo creates tracking objects that are:</p> <ul class="simple"> <li>tracked on an output graph, which is an internal specialization of a <code>torch.fx.Tracer</code>
</li> <li>guards</li> </ul> </li> <li>TorchDynamo processes the guard objects created in (3), turning them into a generated Python function, <code>check_fn</code>, associated with a piece of code.</li> <li>The <code>check_fn</code> is evaluated whenever we encounter this code a subsequent time - if a <code>check_fn</code> passes and evaluates to <code>True</code>, TorchDynamo identifies the code in the cache and the code encountered here as same, and can be safely used. If it fails and evaluates to <code>False</code>, TorchDynamo identifies the code in the cache as not valid, and can be thrown out in favor of a new entry, through recompilation or a graph break.</li> </ol>   <h2 id="python-frame-evaluation-and-pep-523">Python Frame Evaluation and PEP 523</h2> <p>The functionality of TorchDynamo is based on <a class="reference external" href="https://peps.python.org/pep-0523/">PEP 523</a>.</p> <p>TorchDynamo installs a frame evaluation function on Python by using <code>_PyInterpreterState_SetEvalFrameFunc</code>. TorchDynamo has a hook where Python can hand control back to us during evaluation.</p> <p>The function we have installed is <code>convert_frame</code> or <code>convert_frame_assert</code> in the <code>nopython=True</code> case, but glossing over that nuance for now, let’s take a look at <code>convert_frame_assert</code>, as <code>convert_frame</code> proxies to it.</p> <p>We can find it on <a class="reference external" href="https://github.com/pytorch/pytorch/blob/0833f475ce7e42b1dd11af577f276b804fc2b158/torch/_dynamo/convert_frame.py#L222">line 222 of convert_frame.py</a>,</p> <p>with a signature as follows:</p> <pre data-language="python">def  convert_frame_assert(compiler_fn: Callable, one_graph=True):
</pre> <p>This function wraps the entry point of where Python invokes TorchDynamo with a frame:</p> <pre data-language="python">def  _convert_frame_assert(frame: types.FrameType, cache_size: int):
</pre> <p>Here is what this function does:</p> <ol class="arabic simple"> <li>Checks if it has seen this <code>code</code>(see: f_code <a class="reference external" href="https://docs.python.org/3/library/inspect.html">here</a>) before and exits early if it did.</li> <li>Checks if the code is an unsupported case.</li> <li>Checks if the <code>cache_size</code> (second arg above) crosses the limit defined in the config, <code>cache_size_limit</code>. If it has, the function drops the frame and logs warnings. This helps to avoid constant recompilation of a frame as it generally means that the frame is hot in an unexpected way and caching it produces needless overhead, as it is likely to get evicted the next time it is encountered.</li> <li>
<p>Passes the frame, alongside a function that creates an <code>InstructionTranslator</code> through bytecode transformation, via <code>transform_code_object</code>. A few crucial things happen under the hood here:</p> <ol class="arabic simple"> <li>New code is produced through <code>transform_code_object</code>.</li> <li>An FX tracer named <code>output</code> is produced through <code>InstructionTranslator</code>. This can be a bit confusing, as <code>InstructionTranslator</code> is not an <code>fx</code> tracer, but its stored in a variable named tracer, and its output <strong>is</strong> an <code>fx</code> tracer.</li> <li>The function produces guards and stores them on <code>output</code> above.</li> <li>The function produces <code>output_instructions</code> and stores them on <code>output</code> above.</li> <li>The function maps the newly produced transformed code to the initial code it read off the frame. This mapping is worth remembering, we will refer to it much later on below where we cover guard failures.</li> </ol> </li> <li>Using the transformed code from 4.1 and the guards from 4.3, the function produces a <code>GuardedCode</code>.</li> </ol> <p>Now that we have learned about frame evaluation, let’s review <code>InstructionTranslator</code>, and see how it turns the frame we handed it over into TorchDynamo internal types.</p>   <h2 id="instructiontranslator">InstructionTranslator</h2> <p><code>InstructionTranslator</code> does a lot! We won’t cover the details of everything it does, but most importantly for this document, it produces a mapping of <code>symbolic_locals</code> which maintains a mapping from the frame’s <code>f_locals</code> to TorchDynamo internal Variable objects (more on these in a moment. <code>symbolic_locals</code> is filled via traversing the frame’s locals:</p> <pre data-language="python">self.symbolic_locals = collections.OrderedDict(
    (k, VariableBuilder(self, LocalSource(k))(f_locals[k]))
    for k in vars
    if k in f_locals
)
</pre> <p>The important component here is the invocation of a call into <code>VariableBuilder</code>. <code>VariableBuilder</code>’s call implementation proxies into a function called <code>_wrap</code>, which in turn both constructs instances of <code>VariableTracker</code> and calls <code>make_guards</code> on them. More on that later.</p> <p>This mapping, in turn, is critical as each Variable has associated guards, which are then passed to <code>self.output</code>, the instance of <code>OutputGraph</code>, an fx tracer, mentioned in 4.2 of the section above. If you recall, this <code>OutputGraph</code>, stored in a variable called <code>output</code> is where our guards are stored before being passed on to become <code>GuardedCode</code></p> <p>How does <code>InstructionTranslator</code> do this? At the heart of it, there is a loop that is pumped, which drives a function <code>step</code>.</p> <p><code>step</code> is just that - a single processing step, taking exactly one instruction and doing <em>something</em> with it.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These are real instructions processed by TorchDynamo’s <code>transform_code_object</code>, and it is pretty cool.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This section purposely skips the details of <a class="reference external" href="https://docs.python.org/3/library/dis.html">dis.get_instructions</a>.</p> </div> <p>For the example above, here is a snippet of a what a few <code>Instruction</code>'s may look like:</p> <pre data-language="python">Instruction(opcode=124, opname='LOAD_FAST', arg=0, argval='b', offset=32, starts_line=8, is_jump_target=True, target=None)
Instruction(opcode=100, opname='LOAD_CONST', arg=3, argval=-1, offset=34, starts_line=None, is_jump_target=False, target=None)
Instruction(opcode=20, opname='BINARY_MULTIPLY', arg=None, argval=None, offset=36, starts_line=None, is_jump_target=False, target=None)
</pre> <p>This is the core functionality of this function. Take a look at the <code>opname</code>, and then take a look at this little snippet from inside <code>step</code>;</p> <pre data-language="python">if not hasattr(self, inst.opname):
    unimplemented(f"missing: {inst.opname}")
getattr(self, inst.opname)(inst)
</pre> <p>As we can see, the function checks if the current class, the <code>InstructionTranslator</code> has an attribute set matching the operator name (for example, <code>LOAD_CONST</code>). If it does, the function invokes it, passing the whole instruction object in. If it does not, the function drops the frame as unimplemented.</p> <p>For the <code>LOAD_CONST</code> example, we can see that we do indeed support it, with a relatively straightforward definition:</p> <pre data-language="python">def LOAD_CONST(self, inst):
    self.push(ConstantVariable(value=inst.argval))
</pre> <p>We can see that this function creates a new instance of the class <code>ConstantVariable</code> , with a value, in our example case, -1, and then pushes it onto the stack.</p> <p>There are dozens of such methods - see <code>symbolic_convert.py</code> for all of them. Generally, we implement as many matching methods to Python bytecode instructions as possible.</p> <p>Across both the logic downstream of <code>step</code> and the logic from invoking <code>VariableBuilder</code> - we now have a lot of <code>VariableTracker</code>s and of course, we’ve spoken about creating guards quiet a bit. Let’s dig into what Variables are, and get a little closer to understanding guards.</p>   <h2 id="variables">Variables</h2> <p>A <code>ConstantVariable</code> is an instance of <code>VariableTracker</code>. <code>VariableTracker</code> represents a tracked Python local or stack value.</p> <p>When it comes to representing an object inside TorchDynamo, a <code>VariableTracker</code> does exactly what it says - it tracks a given variable. It is an extremely flexible class, but there are a few points to keep in mind:</p> <ul class="simple"> <li>
<p>It manages the <code>guard</code> relationship around the underlying object through:</p> <ul> <li><code>make_guard</code></li> <li><code>replace_guards</code></li> <li><code>add_guard(s)</code></li> <li>
<code>propagate</code> - <code>propagate(*vars: List[List["VariableTracker"]])</code> - Perhaps the most important of all, in that it combines guards from all the provided <code>VariableTracker</code> instances passed in. It visits the guards and combines the guards from these onto itself.</li> </ul> </li> <li>
<p>It acts as a proxy on behalf of the underlying object, implementing methods for the rest of TorchDynamo to get information about the tracked object:</p> <ul> <li><code>call_method</code></li> <li><code>call_function</code></li> <li><code>python_type</code></li> <li><code>as_proxy</code></li> <li><code>is/as_python_proxy</code></li> </ul> </li> <li>It stores the variable <code>source</code> of type <code>Source</code>, from <code>torchdynamo/source.py</code>. This source type is a relatively self contained class that helps us organize and bookkeep where the original source came from, and helps provide convenience methods for things like getting the name, and importantly for us, producing guards.</li> </ul> <p>And this class (<code>VariableTracker</code>) is built around subclassing, somewhere between a full Abstract Base Class and fully fleshed out class - it leaves many methods raising <code>NotImplementedError</code> - with reliance on subclasses. See <code>torchdynamo/variables/</code> for all subclasses to fulfill contracts and custom behaviors.</p> <p>Knowing what we know now, we can see an example of how an instruction from <code>dis</code>, <code>BUILD_TUPLE</code>:</p>  <p><code>BUILD_TUPLE(count)</code> Creates a tuple consuming count items from the stack, and pushes the resulting tuple onto the stack.</p>  <p>In our case, our signature will be a <em>little</em> different due to the way we create <code>Instruction</code> objects, but the gist of it will be the same. Instead of passing in <code>count</code>, we pass in an object with a little extra bookkeeping, and of course, we deal with turning regular old python objects into TorchDynamo notions:</p> <pre data-language="python">def BUILD_TUPLE(self, inst):
    items = self.popn(inst.argval)
    options = VariableTracker.propagate(items)
    self.push(TupleVariable(items, **options))
</pre> <p>Here is what this code does:</p> <ol class="arabic simple"> <li>The function reads <code>argval</code>, which in this case, is analogous to <code>counts</code> in the pydoc for the equivalent instruction.</li> <li>The function <code>popn</code> the items, in this case, the signature is <code>def  popn(self, n: int) -&gt; List[TensorVariable]:</code> this hints at an underlying contract - we are returning <code>TensorVariables</code>. If we take a closer look at <code>symbolic_convert.py</code> and <code>InstructionTranslatorBase</code>/<code>InstructionTranslator</code>we see that the only thing pushed onto and popped from our stack are <code>VariableTracker</code>s.</li> </ol> <ol class="arabic simple" start="3"> <li>The function calls <code>VariableTracker.propagate</code>. This takes the guards from every single item popped off the stack in 2, and recursively traverses it and combines all the guards into <code>options</code>: <code>py  return {      "guards": guards,  }</code>
</li> <li>The function then makes a new instance of a <code>VariableTracker</code>, <code>TupleVariable</code>out of the <code>items</code> and <code>options</code>. This then allows us to install all the appropriate guards from the <code>items</code> that make up the new <code>TupleVariable</code>
</li> </ol> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Where did the first guards come from? Propagation is a good technique, but we need something created before it can be propagated. <code>VariableBuilder</code> calls <code>make_guards</code> as it creates <code>VariableTracker</code> instances, from <code>f_locals</code>. This in turn calls into the <code>source</code>, to have it create guards.</p> </div> <p>After all this, bytecode translation is done and we are one step closer to producing <code>GuardedCode</code>. We now understand how locals become <code>VariableTracker</code>s, how instructions are handled, and where guards are called on for creation. Before we can go into seeing how code and guards are combined into a GuardedCode object, we need to dig a little bit into those <code>make_guard</code> and <code>source.make_guard</code> calls above. We can then understand, what was going on when we made guards alongside, and on, <code>VariableTracker</code> instances.</p>   <h2 id="making-guards">Making Guards</h2> <p>Guards are just Python objects, of the class <code>Guard</code>. Let’s look at them in more detail.</p> <p>Looking at the definition of the dataclass (and therefore, ctor signature), we see that it has a name, a source, and a create function.</p> <pre data-language="python">@dataclasses.dataclass
class Guard:
    name: str
    source: GuardSource
    create_fn: Callable
</pre> <p>The name should be the name of the variable.</p> <p>The source here is an enum indicating what <em>kind</em> of source the guard belongs to.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Not to be confused with <code>Source</code> and the other types in <code>source.py</code>, as stored on <code>VariableTracker</code>.</p> </div> <p><code>create_fn</code> provides the main functionality to transition from a simple dataclass to actually producing valid Python code to be invoked for knowing whether or not things have changed in between invocations, and whether we can safely read from the code cache or not.</p> <p>The most common code paths for getting an instance of a guard are through <code>make_guards</code> on <code>VariableTracker</code>. <code>make_guards</code> -&gt; <code>source.make_guard</code> -&gt; <code>return Guard(self.name(), self.guard_source(), fn)</code></p> <p>Or, in a concrete example:</p> <pre data-language="python">...
elif istype(value, range):
    guards = self.make_guards(GuardBuilder.EQUALS_MATCH)
    return RangeVariable(value=value, guards=guards)
</pre> <p>Since <code>source</code> was set at the construction time of this <code>VariableTracker</code>, all that was needed here was to provide the <code>fn</code>, <code>GuardBuilder.EQUALS_MATCH</code> to the <code>create_fn</code> field.</p> <p>This <code>create_fn</code> must be a method on <code>GuardBuilder</code>. The reason for this becomes apparent in our next step. Once we have all the guards created for a frame, we move on to <code>CheckFunctionManager</code> and <code>compile_check_fn</code>.</p> <p>Before the <code>convert_frame</code> function can produce a <code>GuardedCode</code>, it needs to run the <code>CheckFunctionManager</code>, with all the guards, to produce a <code>check_fn</code> which will then, in turn get passed in alongside the code into <code>GuardedCode</code>. This is the same <code>check_fn</code> that we store in our cache entry, and the same one we run to know whether or not to retrieve the code stored alongside. For reference, here is that code:</p> <pre data-language="cpp">static CacheEntry *create_cache_entry(CacheEntry *next,
                                      PyObject *guarded_code) {
  CacheEntry *e = (CacheEntry *)malloc(sizeof(CacheEntry));
  DEBUG_NULL_CHECK(e);
  e-&gt;check_fn = PyObject_GetAttrString(guarded_code, "check_fn");
  NULL_CHECK(e-&gt;check_fn);
  e-&gt;code = (PyCodeObject *)PyObject_GetAttrString(guarded_code, "code");
  NULL_CHECK(e-&gt;code);
  e-&gt;next = next;
  return e;
}
</pre> <p>We now know how a <code>check_fn</code> function is used, and who makes it, and what it is composed of, but what we do not yet know is how. How does a list of <code>Guard</code> objects become a function we can run later on?</p> <p>First, we iterate these guards:</p> <pre data-language="python">for guard in sorted(guards or [], key=Guard.sort_key):
    if not config.guard_nn_modules and guard.is_nn_module():
        continue
    guard.create(local_builder, global_builder)
</pre> <p>Calling <code>guard.create</code> runs that <code>create_fn</code> we set on the <code>Guard</code> class above (don’t confuse it with the <code>check_fn</code> we are working on producing, the names are similar, so it can get a little confusing). In our example above, our <code>create_fn</code> is <code>GuardBuilder.EQUALS_MATCH</code>. So we are now invoking it, passing in the <code>self</code>, the guard itself, in.</p> <p>The signature is: <code>def EQUALS_MATCH(self, guard: Guard):</code></p> <p>And internally to that function, we can use the <code>name</code> on the guard to get back our original object, querying it for data and type information, which in turn gets us to the most important bit: appending code.</p> <p>At its simplest, <code>EQUALS_MATCH</code> appends just one line of code: <code>self.code.append(f"{ref} == {val!r}")</code>. Where <code>ref</code> is the name of the variable, and <code>val</code> is the value. It might produce code like this:</p> <pre data-language="python">y == 2
</pre> <p>This is a basic example. But if we append a few other kinds of <code>GuardBuilder</code> functions and then combine them all with <code>and</code> in between each statement (as we do), we might get something like this:</p> <pre data-language="python">___guarded_code.valid and ___check_type_id(y, 94367738391392) and y == 2 and ___check_tensors(x)
</pre> <p>Here is what this code performs:</p> <ol class="arabic simple"> <li>A check for <code>.valid</code>
</li> <li>A type ID check</li> <li>A value check</li> <li>A tensor check</li> </ol> <p>This becomes the heart of the code our <code>check_fn</code>, which in turn is evaluated the <strong>next</strong> time we encounter this code. It will then check:</p> <ol class="arabic simple"> <li>Is this code still valid?</li> <li>If (1), Does <code>y</code> still have a type of <code>94367738391392</code>?</li> <li>If (2), is <code>y</code> still 2?</li> <li>If (3), let’s check on if tensor <code>x</code> changed in some specific ways.</li> </ol> <p>If all of these are still true, then we can use the code cached alongside this <code>check_fn</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For a deeper dive for how and where this happens you can read <code>static PyCodeObject *lookup(CacheEntry *e, PyObject *f_locals) {</code> of <code>_eval_frame.c</code>.</p> </div> <p>If not, then, we can move on to recompiling the code anew, and storing that in the cache alongside this code, and a whole new <code>check_fn</code>, again to be checked on yet another subsequent frame.</p> <p>There are lots of other such functions on <code>GuardBuilder</code> which get coalesced into, at times massive, strings which then get evaluated as Python code and stored into <code>check_fn</code>. The example above illustrates of a simple case. To understand this functionality better, read the other functions on <code>GuardBuilder</code>, or better yet, dump the <code>code</code> variable in <code>compile_check_fn</code> to see what is getting produced, especially on larger, real models.</p>   <h2 id="summary">Summary</h2> <p>In this section, we have reviewed:</p> <ul class="simple"> <li>The role of <code>.valid</code> and invalidation around weak references (and potentially soon to be NN Moduleinvalidations).</li> <li>How the C++ side of guard functions (<code>___check_type_id</code>, <code>___check_tensors</code>, etc) operate.</li> <li>What happens when guards fail.</li> <li>What happens if we produce invalid guard code.</li> </ul> <p>We covered how user provided code wrapped in a TorchDynamo context goes on to get traced and tracked internally, organized into <code>VariableTracker</code>s <code>Source</code>s and subsequently <code>Guard</code>s, and how those <code>Guards</code> in turn guide cache entry selection and invalidation when handing Python code.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/torch.compiler_guards_overview.html" class="_attribution-link">https://pytorch.org/docs/2.1/torch.compiler_guards_overview.html</a>
  </p>
</div>
