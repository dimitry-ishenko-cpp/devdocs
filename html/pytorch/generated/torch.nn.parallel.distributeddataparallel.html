<h1 id="distributeddataparallel">DistributedDataParallel</h1> <dl class="py class"> <dt class="sig sig-object py" id="torch.nn.parallel.DistributedDataParallel">
<code>class torch.nn.parallel.DistributedDataParallel(module, device_ids=None, output_device=None, dim=0, broadcast_buffers=True, process_group=None, bucket_cap_mb=25, find_unused_parameters=False, check_reduction=False, gradient_as_bucket_view=False, static_graph=False, delay_all_reduce_named_params=None, param_to_hook_all_reduce=None, mixed_precision=None)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/parallel/distributed.html#DistributedDataParallel"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Implements distributed data parallelism that is based on <code>torch.distributed</code> package at the module level.</p> <p>This container provides data parallelism by synchronizing gradients across each model replica. The devices to synchronize across are specified by the input <code>process_group</code>, which is the entire world by default. Note that <code>DistributedDataParallel</code> does not chunk or otherwise shard the input across participating GPUs; the user is responsible for defining how to do so, for example through the use of a <code>DistributedSampler</code>.</p> <p>See also: <a class="reference internal" href="../distributed.html#distributed-basics"><span class="std std-ref">Basics</span></a> and <a class="reference internal" href="https://pytorch.org/docs/2.1/notes/cuda.html#cuda-nn-ddp-instead"><span class="std std-ref">Use nn.parallel.DistributedDataParallel instead of multiprocessing or nn.DataParallel</span></a>. The same constraints on input as in <a class="reference internal" href="torch.nn.dataparallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> apply.</p> <p>Creation of this class requires that <code>torch.distributed</code> to be already initialized, by calling <a class="reference internal" href="../distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a>.</p> <p><code>DistributedDataParallel</code> is proven to be significantly faster than <a class="reference internal" href="torch.nn.dataparallel.html#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> for single-node multi-GPU data parallel training.</p> <p>To use <code>DistributedDataParallel</code> on a host with N GPUs, you should spawn up <code>N</code> processes, ensuring that each process exclusively works on a single GPU from 0 to N-1. This can be done by either setting <code>CUDA_VISIBLE_DEVICES</code> for every process or by calling:</p> <pre data-language="python">&gt;&gt;&gt; torch.cuda.set_device(i)
</pre> <p>where i is from 0 to N-1. In each process, you should refer the following to construct this module:</p> <pre data-language="python">&gt;&gt;&gt; torch.distributed.init_process_group(
&gt;&gt;&gt;     backend='nccl', world_size=N, init_method='...'
&gt;&gt;&gt; )
&gt;&gt;&gt; model = DistributedDataParallel(model, device_ids=[i], output_device=i)
</pre> <p>In order to spawn up multiple processes per node, you can use either <code>torch.distributed.launch</code> or <code>torch.multiprocessing.spawn</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Please refer to <a class="reference external" href="https://pytorch.org/tutorials/beginner/dist_overview.html">PyTorch Distributed Overview</a> for a brief introduction to all features related to distributed training.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>DistributedDataParallel</code> can be used in conjunction with <a class="reference internal" href="../distributed.optim.html#torch.distributed.optim.ZeroRedundancyOptimizer" title="torch.distributed.optim.ZeroRedundancyOptimizer"><code>torch.distributed.optim.ZeroRedundancyOptimizer</code></a> to reduce per-rank optimizer states memory footprint. Please refer to <a class="reference external" href="https://pytorch.org/tutorials/recipes/zero_redundancy_optimizer.html">ZeroRedundancyOptimizer recipe</a> for more details.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>nccl</code> backend is currently the fastest and highly recommended backend when using GPUs. This applies to both single-node and multi-node distributed training.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This module also supports mixed-precision distributed training. This means that your model can have different types of parameters such as mixed types of <code>fp16</code> and <code>fp32</code>, the gradient reduction on these mixed types of parameters will just work fine.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you use <code>torch.save</code> on one process to checkpoint the module, and <code>torch.load</code> on some other processes to recover it, make sure that <code>map_location</code> is configured properly for every process. Without <code>map_location</code>, <code>torch.load</code> would recover the module to devices where the module was saved from.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When a model is trained on <code>M</code> nodes with <code>batch=N</code>, the gradient will be <code>M</code> times smaller when compared to the same model trained on a single node with <code>batch=M*N</code> if the loss is summed (NOT averaged as usual) across instances in a batch (because the gradients between different nodes are averaged). You should take this into consideration when you want to obtain a mathematically equivalent training process compared to the local training counterpart. But in most cases, you can just treat a DistributedDataParallel wrapped model, a DataParallel wrapped model and an ordinary model on a single GPU as the same (E.g. using the same learning rate for equivalent batch size).</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Parameters are never broadcast between processes. The module performs an all-reduce step on gradients and assumes that they will be modified by the optimizer in all processes in the same way. Buffers (e.g. BatchNorm stats) are broadcast from the module in process of rank 0, to all other replicas in the system in every iteration.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are using DistributedDataParallel in conjunction with the <a class="reference internal" href="../rpc.html#distributed-rpc-framework"><span class="std std-ref">Distributed RPC Framework</span></a>, you should always use <a class="reference internal" href="../rpc.html#torch.distributed.autograd.backward" title="torch.distributed.autograd.backward"><code>torch.distributed.autograd.backward()</code></a> to compute gradients and <a class="reference internal" href="../distributed.optim.html#torch.distributed.optim.DistributedOptimizer" title="torch.distributed.optim.DistributedOptimizer"><code>torch.distributed.optim.DistributedOptimizer</code></a> for optimizing parameters.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import torch.distributed.autograd as dist_autograd
&gt;&gt;&gt; from torch.nn.parallel import DistributedDataParallel as DDP
&gt;&gt;&gt; import torch
&gt;&gt;&gt; from torch import optim
&gt;&gt;&gt; from torch.distributed.optim import DistributedOptimizer
&gt;&gt;&gt; import torch.distributed.rpc as rpc
&gt;&gt;&gt; from torch.distributed.rpc import RRef
&gt;&gt;&gt;
&gt;&gt;&gt; t1 = torch.rand((3, 3), requires_grad=True)
&gt;&gt;&gt; t2 = torch.rand((3, 3), requires_grad=True)
&gt;&gt;&gt; rref = rpc.remote("worker1", torch.add, args=(t1, t2))
&gt;&gt;&gt; ddp_model = DDP(my_model)
&gt;&gt;&gt;
&gt;&gt;&gt; # Setup optimizer
&gt;&gt;&gt; optimizer_params = [rref]
&gt;&gt;&gt; for param in ddp_model.parameters():
&gt;&gt;&gt;     optimizer_params.append(RRef(param))
&gt;&gt;&gt;
&gt;&gt;&gt; dist_optim = DistributedOptimizer(
&gt;&gt;&gt;     optim.SGD,
&gt;&gt;&gt;     optimizer_params,
&gt;&gt;&gt;     lr=0.05,
&gt;&gt;&gt; )
&gt;&gt;&gt;
&gt;&gt;&gt; with dist_autograd.context() as context_id:
&gt;&gt;&gt;     pred = ddp_model(rref.to_here())
&gt;&gt;&gt;     loss = loss_func(pred, target)
&gt;&gt;&gt;     dist_autograd.backward(context_id, [loss])
&gt;&gt;&gt;     dist_optim.step(context_id)
</pre> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>DistributedDataParallel currently offers limited support for gradient checkpointing with <code>torch.utils.checkpoint()</code>. DDP will work as expected when there are no unused parameters in the model and each layer is checkpointed at most once (make sure you are not passing <code>find_unused_parameters=True</code> to DDP). We currently do not support the case where a layer is checkpointed multiple times, or when there unused parameters in the checkpointed model.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To let a non-DDP model load a state dict from a DDP model, <code>consume_prefix_in_state_dict_if_present()</code> needs to be applied to strip the prefix “module.” in the DDP state dict before loading.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Constructor, forward method, and differentiation of the output (or a function of the output of this module) are distributed synchronization points. Take that into account in case different processes might be executing different code.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This module assumes all parameters are registered in the model by the time it is created. No parameters should be added nor removed later. Same applies to buffers.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This module assumes all parameters are registered in the model of each distributed processes are in the same order. The module itself will conduct gradient <code>allreduce</code> following the reverse order of the registered parameters of the model. In other words, it is users’ responsibility to ensure that each distributed process has the exact same model and thus the exact same parameter registration order.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This module allows parameters with non-rowmajor-contiguous strides. For example, your model may contain some parameters whose <a class="reference internal" href="../tensor_attributes.html#torch.memory_format" title="torch.memory_format"><code>torch.memory_format</code></a> is <code>torch.contiguous_format</code> and others whose format is <code>torch.channels_last</code>. However, corresponding parameters in different processes must have the same strides.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>This module doesn’t work with <a class="reference internal" href="torch.autograd.grad.html#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a> (i.e. it will only work if gradients are to be accumulated in <code>.grad</code> attributes of parameters).</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If you plan on using this module with a <code>nccl</code> backend or a <code>gloo</code> backend (that uses Infiniband), together with a DataLoader that uses multiple workers, please change the multiprocessing start method to <code>forkserver</code> (Python 3 only) or <code>spawn</code>. Unfortunately Gloo (that uses Infiniband) and NCCL2 are not fork safe, and you will likely experience deadlocks if you don’t change this setting.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>You should never try to change your model’s parameters after wrapping up your model with <code>DistributedDataParallel</code>. Because, when wrapping up your model with <code>DistributedDataParallel</code>, the constructor of <code>DistributedDataParallel</code> will register the additional gradient reduction functions on all the parameters of the model itself at the time of construction. If you change the model’s parameters afterwards, gradient reduction functions no longer match the correct set of parameters.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Using <code>DistributedDataParallel</code> in conjunction with the <a class="reference internal" href="../rpc.html#distributed-rpc-framework"><span class="std std-ref">Distributed RPC Framework</span></a> is experimental and subject to change.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> (<a class="reference internal" href="torch.nn.module.html#torch.nn.Module" title="torch.nn.Module">Module</a>) – module to be parallelized</li> <li>
<p><strong>device_ids</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)">list</a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em> or </em><a class="reference internal" href="../tensor_attributes.html#torch.device" title="torch.device">torch.device</a>) – </p>
<p>CUDA devices. 1) For single-device modules, <code>device_ids</code> can contain exactly one device id, which represents the only CUDA device where the input module corresponding to this process resides. Alternatively, <code>device_ids</code> can also be <code>None</code>. 2) For multi-device modules and CPU modules, <code>device_ids</code> must be <code>None</code>.</p> <p>When <code>device_ids</code> is <code>None</code> for both cases, both the input data for the forward pass and the actual module must be placed on the correct device. (default: <code>None</code>)</p> </li> <li>
<strong>output_device</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em> or </em><a class="reference internal" href="../tensor_attributes.html#torch.device" title="torch.device">torch.device</a>) – Device location of output for single-device CUDA modules. For multi-device modules and CPU modules, it must be <code>None</code>, and the module itself dictates the output location. (default: <code>device_ids[0]</code> for single-device modules)</li> <li>
<strong>broadcast_buffers</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Flag that enables syncing (broadcasting) buffers of the module at beginning of the <code>forward</code> function. (default: <code>True</code>)</li> <li>
<strong>process_group</strong> – The process group to be used for distributed data all-reduction. If <code>None</code>, the default process group, which is created by <a class="reference internal" href="../distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a>, will be used. (default: <code>None</code>)</li> <li>
<strong>bucket_cap_mb</strong> – <code>DistributedDataParallel</code> will bucket parameters into multiple buckets so that gradient reduction of each bucket can potentially overlap with backward computation. <code>bucket_cap_mb</code> controls the bucket size in MegaBytes (MB). (default: 25)</li> <li>
<strong>find_unused_parameters</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Traverse the autograd graph from all tensors contained in the return value of the wrapped module’s <code>forward</code> function. Parameters that don’t receive gradients as part of this graph are preemptively marked as being ready to be reduced. In addition, parameters that may have been used in the wrapped module’s <code>forward</code> function but were not part of loss computation and thus would also not receive gradients are preemptively marked as ready to be reduced. (default: <code>False</code>)</li> <li>
<strong>check_reduction</strong> – This argument is deprecated.</li> <li>
<strong>gradient_as_bucket_view</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – When set to <code>True</code>, gradients will be views pointing to different offsets of <code>allreduce</code> communication buckets. This can reduce peak memory usage, where the saved memory size will be equal to the total gradients size. Moreover, it avoids the overhead of copying between gradients and <code>allreduce</code> communication buckets. When gradients are views, <code>detach_()</code> cannot be called on the gradients. If hitting such errors, please fix it by referring to the <a class="reference internal" href="torch.optim.optimizer.zero_grad.html#torch.optim.Optimizer.zero_grad" title="torch.optim.Optimizer.zero_grad"><code>zero_grad()</code></a> function in <code>torch/optim/optimizer.py</code> as a solution. Note that gradients will be views after first iteration, so the peak memory saving should be checked after first iteration.</li> <li>
<p><strong>static_graph</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – </p>
<p>When set to <code>True</code>, DDP knows the trained graph is static. Static graph means 1) The set of used and unused parameters will not change during the whole training loop; in this case, it does not matter whether users set <code>find_unused_parameters = True</code> or not. 2) How the graph is trained will not change during the whole training loop (meaning there is no control flow depending on iterations). When static_graph is set to be <code>True</code>, DDP will support cases that can not be supported in the past: 1) Reentrant backwards. 2) Activation checkpointing multiple times. 3) Activation checkpointing when model has unused parameters. 4) There are model parameters that are outside of forward function. 5) Potentially improve performance when there are unused parameters, as DDP will not search graph in each iteration to detect unused parameters when static_graph is set to be <code>True</code>. To check whether you can set static_graph to be <code>True</code>, one way is to check ddp logging data at the end of your previous model training, if <code>ddp_logging_data.get("can_set_static_graph") == True</code>, mostly you can set <code>static_graph = True</code> as well.</p> <dl> <dt>Example::</dt>
<dd>
<pre data-language="python">&gt;&gt;&gt; model_DDP = torch.nn.parallel.DistributedDataParallel(model)
&gt;&gt;&gt; # Training loop
&gt;&gt;&gt; ...
&gt;&gt;&gt; ddp_logging_data = model_DDP._get_ddp_logging_data()
&gt;&gt;&gt; static_graph = ddp_logging_data.get("can_set_static_graph")
</pre> </dd> </dl> </li> <li>
<strong>delay_all_reduce_named_params</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)">list</a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.12)">tuple</a><em> of </em><em>str and torch.nn.Parameter</em>) – a list of named parameters whose all reduce will be delayed when the gradient of the parameter specified in <code>param_to_hook_all_reduce</code> is ready. Other arguments of DDP do not apply to named params specified in this argument as these named params will be ignored by DDP reducer.</li> <li>
<strong>param_to_hook_all_reduce</strong> (<em>torch.nn.Parameter</em>) – a parameter to hook delayed all reduce of parameters specified in <code>delay_all_reduce_named_params</code>.</li> </ul> </dd> <dt class="field-even">Variables</dt> <dd class="field-even">
<p><strong>module</strong> (<a class="reference internal" href="torch.nn.module.html#torch.nn.Module" title="torch.nn.Module">Module</a>) – the module to be parallelized.</p> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.parallel.DistributedDataParallel(model)
</pre> <dl class="py method"> <dt class="sig sig-object py" id="torch.nn.parallel.DistributedDataParallel.join">
<code>join(divide_by_initial_world_size=True, enable=True, throw_on_early_termination=False)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/parallel/distributed.html#DistributedDataParallel.join"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A context manager to be used in conjunction with an instance of <a class="reference internal" href="#torch.nn.parallel.DistributedDataParallel" title="torch.nn.parallel.DistributedDataParallel"><code>torch.nn.parallel.DistributedDataParallel</code></a> to be able to train with uneven inputs across participating processes.</p> <p>This context manager will keep track of already-joined DDP processes, and “shadow” the forward and backward passes by inserting collective communication operations to match with the ones created by non-joined DDP processes. This will ensure each collective call has a corresponding call by already-joined DDP processes, preventing hangs or errors that would otherwise happen when training with uneven inputs across processes. Alternatively, if the flag <code>throw_on_early_termination</code> is specified to be <code>True</code>, all trainers will throw an error once one rank runs out of inputs, allowing these errors to be caught and handled according to application logic.</p> <p>Once all DDP processes have joined, the context manager will broadcast the model corresponding to the last joined process to all processes to ensure the model is the same across all processes (which is guaranteed by DDP).</p> <p>To use this to enable training with uneven inputs across processes, simply wrap this context manager around your training loop. No further modifications to the model or data loading is required.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If the model or training loop this context manager is wrapped around has additional distributed collective operations, such as <code>SyncBatchNorm</code> in the model’s forward pass, then the flag <code>throw_on_early_termination</code> must be enabled. This is because this context manager is not aware of non-DDP collective communication. This flag will cause all ranks to throw when any one rank exhausts inputs, allowing these errors to be caught and recovered from across all ranks.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>divide_by_initial_world_size</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – If <code>True</code>, will divide gradients by the initial <code>world_size</code> DDP training was launched with. If <code>False</code>, will compute the effective world size (number of ranks that have not depleted their inputs yet) and divide gradients by that during allreduce. Set <code>divide_by_initial_world_size=True</code> to ensure every input sample including the uneven inputs have equal weight in terms of how much they contribute to the global gradient. This is achieved by always dividing the gradient by the initial <code>world_size</code> even when we encounter uneven inputs. If you set this to <code>False</code>, we divide the gradient by the remaining number of nodes. This ensures parity with training on a smaller <code>world_size</code> although it also means the uneven inputs would contribute more towards the global gradient. Typically, you would want to set this to <code>True</code> for cases where the last few inputs of your training job are uneven. In extreme cases, where there is a large discrepancy in the number of inputs, setting this to <code>False</code> might provide better results.</li> <li>
<strong>enable</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Whether to enable uneven input detection or not. Pass in <code>enable=False</code> to disable in cases where you know that inputs are even across participating processes. Default is <code>True</code>.</li> <li>
<strong>throw_on_early_termination</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a>) – Whether to throw an error or continue training when at least one rank has exhausted inputs. If <code>True</code>, will throw upon the first rank reaching end of data. If <code>False</code>, will continue training with a smaller effective world size until all ranks are joined. Note that if this flag is specified, then the flag <code>divide_by_initial_world_size</code> would be ignored. Default is <code>False</code>.</li> </ul> </dd> </dl> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; import torch
&gt;&gt;&gt; import torch.distributed as dist
&gt;&gt;&gt; import os
&gt;&gt;&gt; import torch.multiprocessing as mp
&gt;&gt;&gt; import torch.nn as nn
&gt;&gt;&gt; # On each spawned worker
&gt;&gt;&gt; def worker(rank):
&gt;&gt;&gt;     dist.init_process_group("nccl", rank=rank, world_size=2)
&gt;&gt;&gt;     torch.cuda.set_device(rank)
&gt;&gt;&gt;     model = nn.Linear(1, 1, bias=False).to(rank)
&gt;&gt;&gt;     model = torch.nn.parallel.DistributedDataParallel(
&gt;&gt;&gt;         model, device_ids=[rank], output_device=rank
&gt;&gt;&gt;     )
&gt;&gt;&gt;     # Rank 1 gets one more input than rank 0.
&gt;&gt;&gt;     inputs = [torch.tensor([1]).float() for _ in range(10 + rank)]
&gt;&gt;&gt;     with model.join():
&gt;&gt;&gt;         for _ in range(5):
&gt;&gt;&gt;             for inp in inputs:
&gt;&gt;&gt;                 loss = model(inp).sum()
&gt;&gt;&gt;                 loss.backward()
&gt;&gt;&gt;     # Without the join() API, the below synchronization will hang
&gt;&gt;&gt;     # blocking for rank 1's allreduce to complete.
&gt;&gt;&gt;     torch.cuda.synchronize(device=rank)
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.nn.parallel.DistributedDataParallel.join_hook">
<code>join_hook(**kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/parallel/distributed.html#DistributedDataParallel.join_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the DDP join hook, which enables training on uneven inputs by shadowing the collective communications in the forward and backward passes.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<p><strong>kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)">dict</a>) – a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a> containing any keyword arguments to modify the behavior of the join hook at run time; all <code>Joinable</code> instances sharing the same join context manager are forwarded the same value for <code>kwargs</code>.</p> </dd> </dl> <dl class="simple"> <dt>The hook supports the following keyword arguments:</dt>
<dd>
<dl class="simple"> <dt>divide_by_initial_world_size (bool, optional):</dt>
<dd>
<p>If <code>True</code>, then gradients are divided by the initial world size that DDP was launched with. If <code>False</code>, then gradients are divided by the effective world size (i.e. the number of non-joined processes), meaning that the uneven inputs contribute more toward the global gradient. Typically, this should be set to <code>True</code> if the degree of unevenness is small but can be set to <code>False</code> in extreme cases for possibly better results. Default is <code>True</code>.</p> </dd> </dl> </dd> </dl> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.nn.parallel.DistributedDataParallel.no_sync">
<code>no_sync()</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/parallel/distributed.html#DistributedDataParallel.no_sync"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A context manager to disable gradient synchronizations across DDP processes. Within this context, gradients will be accumulated on module variables, which will later be synchronized in the first forward-backward pass exiting the context.</p> <p>Example:</p> <pre data-language="python">&gt;&gt;&gt; ddp = torch.nn.parallel.DistributedDataParallel(model, pg)
&gt;&gt;&gt; with ddp.no_sync():
&gt;&gt;&gt;     for input in inputs:
&gt;&gt;&gt;         ddp(input).backward()  # no synchronization, accumulate grads
&gt;&gt;&gt; ddp(another_input).backward()  # synchronize grads
</pre> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The forward pass should be included inside the context manager, or else gradients will still be synchronized.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="torch.nn.parallel.DistributedDataParallel.register_comm_hook">
<code>register_comm_hook(state, hook)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/nn/parallel/distributed.html#DistributedDataParallel.register_comm_hook"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Registers a communication hook which is an enhancement that provides a flexible hook to users where they can specify how DDP aggregates gradients across multiple workers.</p> <p>This hook would be very useful for researchers to try out new ideas. For example, this hook can be used to implement several algorithms like GossipGrad and gradient compression which involve different communication strategies for parameter syncs while running Distributed DataParallel training.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<p><strong>state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.12)">object</a>) – </p>
<p>Passed to the hook to maintain any state information during the training process. Examples include error feedback in gradient compression, peers to communicate with next in GossipGrad, etc.</p> <p>It is locally stored by each worker and shared by all the gradient tensors on the worker.</p> </li> <li>
<p><strong>hook</strong> (<em>Callable</em>) – </p>
<p>Callable with the following signature: <code>hook(state: object, bucket: dist.GradBucket) -&gt; torch.futures.Future[torch.Tensor]</code>:</p> <p>This function is called once the bucket is ready. The hook can perform whatever processing is needed and return a Future indicating completion of any async work (ex: allreduce). If the hook doesn’t perform any communication, it still must return a completed Future. The Future should hold the new value of grad bucket’s tensors. Once a bucket is ready, c10d reducer would call this hook and use the tensors returned by the Future and copy grads to individual parameters. Note that the future’s return type must be a single tensor.</p> <p>We also provide an API called <code>get_future</code> to retrieve a Future associated with the completion of <code>c10d.ProcessGroup.Work</code>. <code>get_future</code> is currently supported for NCCL and also supported for most operations on GLOO and MPI, except for peer to peer operations (send/recv).</p> </li> </ul> </dd> </dl> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Grad bucket’s tensors will not be predivided by world_size. User is responsible to divide by the world_size in case of operations like allreduce.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>DDP communication hook can only be registered once and should be registered before calling backward.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The Future object that hook returns should contain a single tensor that has the same shape with the tensors inside grad bucket.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code>get_future</code> API supports NCCL, and partially GLOO and MPI backends (no support for peer-to-peer operations like send/recv) and will return a <code>torch.futures.Future</code>.</p> </div> <dl> <dt>Example::</dt>
<dd>
<p>Below is an example of a noop hook that returns the same tensor.</p> <pre data-language="python">&gt;&gt;&gt; def noop(state: object, bucket: dist.GradBucket) -&gt; torch.futures.Future[torch.Tensor]:
&gt;&gt;&gt;     fut = torch.futures.Future()
&gt;&gt;&gt;     fut.set_result(bucket.buffer())
&gt;&gt;&gt;     return fut
&gt;&gt;&gt; ddp.register_comm_hook(state=None, hook=noop)
</pre> </dd> <dt>Example::</dt>
<dd>
<p>Below is an example of a Parallel SGD algorithm where gradients are encoded before allreduce, and then decoded after allreduce.</p> <pre data-language="python">&gt;&gt;&gt; def encode_and_decode(state: object, bucket: dist.GradBucket) -&gt; torch.futures.Future[torch.Tensor]:
&gt;&gt;&gt;     encoded_tensor = encode(bucket.buffer())  # encode gradients
&gt;&gt;&gt;     fut = torch.distributed.all_reduce(encoded_tensor).get_future()
&gt;&gt;&gt;     # Define the then callback to decode.
&gt;&gt;&gt;     def decode(fut):
&gt;&gt;&gt;         decoded_tensor = decode(fut.value()[0])  # decode gradients
&gt;&gt;&gt;         return decoded_tensor
&gt;&gt;&gt;     return fut.then(decode)
&gt;&gt;&gt; ddp.register_comm_hook(state=None, hook=encode_and_decode)
</pre> </dd> </dl> </dd>
</dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.nn.parallel.DistributedDataParallel.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.nn.parallel.DistributedDataParallel.html</a>
  </p>
</div>
