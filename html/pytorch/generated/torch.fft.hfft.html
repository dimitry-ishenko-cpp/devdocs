<h1 id="torch-fft-hfft">torch.fft.hfft</h1> <dl class="py function"> <dt class="sig sig-object py" id="torch.fft.hfft">
<code>torch.fft.hfft(input, n=None, dim=-1, norm=None, *, out=None) → Tensor</code> </dt> <dd>
<p>Computes the one dimensional discrete Fourier transform of a Hermitian symmetric <code>input</code> signal.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>/<a class="reference internal" href="torch.fft.ihfft.html#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> are analogous to <a class="reference internal" href="torch.fft.rfft.html#torch.fft.rfft" title="torch.fft.rfft"><code>rfft()</code></a>/<a class="reference internal" href="torch.fft.irfft.html#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>. The real FFT expects a real signal in the time-domain and gives a Hermitian symmetry in the frequency-domain. The Hermitian FFT is the opposite; Hermitian symmetric in the time-domain and real-valued in the frequency-domain. For this reason, special care needs to be taken with the length argument <code>n</code>, in the same way as with <a class="reference internal" href="torch.fft.irfft.html#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Because the signal is Hermitian in the time-domain, the result will be real in the frequency domain. Note that some input frequencies must be real-valued to satisfy the Hermitian property. In these cases the imaginary component will be ignored. For example, any imaginary component in <code>input[0]</code> would result in one or more complex frequency terms which cannot be represented in a real output and so will always be ignored.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The correct interpretation of the Hermitian input depends on the length of the original data, as given by <code>n</code>. This is because each input shape could correspond to either an odd or even length signal. By default, the signal is assumed to be even length and odd signals will not round-trip properly. So, it is recommended to always pass the signal length <code>n</code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Supports torch.half and torch.chalf on CUDA with GPU Architecture SM53 or greater. However it only supports powers of 2 signal length in every transformed dimension. With default arguments, size of the transformed dimension should be (2^n + 1) as argument <code>n</code> defaults to even output size = 2 * (transformed_dim_size - 1)</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>input</strong> (<a class="reference internal" href="../tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>) – the input tensor representing a half-Hermitian signal</li> <li>
<strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><em>optional</em>) – Output signal length. This determines the length of the real output. If given, the input will either be zero-padded or trimmed to this length before computing the Hermitian FFT. Defaults to even output: <code>n=2*(input.size(dim) - 1)</code>.</li> <li>
<strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)">int</a><em>, </em><em>optional</em>) – The dimension along which to take the one dimensional Hermitian FFT.</li> <li>
<p><strong>norm</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>optional</em>) – </p>
<p>Normalization mode. For the forward transform (<a class="reference internal" href="#torch.fft.hfft" title="torch.fft.hfft"><code>hfft()</code></a>), these correspond to:</p> <ul> <li>
<code>"forward"</code> - normalize by <code>1/n</code>
</li> <li>
<code>"backward"</code> - no normalization</li> <li>
<code>"ortho"</code> - normalize by <code>1/sqrt(n)</code> (making the Hermitian FFT orthonormal)</li> </ul> <p>Calling the backward transform (<a class="reference internal" href="torch.fft.ihfft.html#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a>) with the same normalization mode will apply an overall normalization of <code>1/n</code> between the two transforms. This is required to make <a class="reference internal" href="torch.fft.ihfft.html#torch.fft.ihfft" title="torch.fft.ihfft"><code>ihfft()</code></a> the exact inverse.</p> <p>Default is <code>"backward"</code> (no normalization).</p> </li> </ul> </dd> <dt class="field-even">Keyword Arguments</dt> <dd class="field-even">
<p><strong>out</strong> (<a class="reference internal" href="../tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a><em>, </em><em>optional</em>) – the output tensor.</p> </dd> </dl> <h4 class="rubric">Example</h4> <p>Taking a real-valued frequency signal and bringing it into the time domain gives Hermitian symmetric output:</p> <pre data-language="python">&gt;&gt;&gt; t = torch.linspace(0, 1, 5)
&gt;&gt;&gt; t
tensor([0.0000, 0.2500, 0.5000, 0.7500, 1.0000])
&gt;&gt;&gt; T = torch.fft.ifft(t)
&gt;&gt;&gt; T
tensor([ 0.5000-0.0000j, -0.1250-0.1720j, -0.1250-0.0406j, -0.1250+0.0406j,
        -0.1250+0.1720j])
</pre> <p>Note that <code>T[1] == T[-1].conj()</code> and <code>T[2] == T[-2].conj()</code> is redundant. We can thus compute the forward transform without considering negative frequencies:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.hfft(T[:3], n=5)
tensor([0.0000, 0.2500, 0.5000, 0.7500, 1.0000])
</pre> <p>Like with <a class="reference internal" href="torch.fft.irfft.html#torch.fft.irfft" title="torch.fft.irfft"><code>irfft()</code></a>, the output length must be given in order to recover an even length output:</p> <pre data-language="python">&gt;&gt;&gt; torch.fft.hfft(T[:3])
tensor([0.1250, 0.2809, 0.6250, 0.9691])
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/generated/torch.fft.hfft.html" class="_attribution-link">https://pytorch.org/docs/2.1/generated/torch.fft.hfft.html</a>
  </p>
</div>
