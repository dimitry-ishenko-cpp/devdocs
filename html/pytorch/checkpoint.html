<h1 id="torch-utils-checkpoint">torch.utils.checkpoint</h1> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Checkpointing is implemented by rerunning a forward-pass segment for each checkpointed segment during backward. This can cause persistent states like the RNG state to be advanced than they would without checkpointing. By default, checkpointing includes logic to juggle the RNG state such that checkpointed passes making use of RNG (through dropout for example) have deterministic output as compared to non-checkpointed passes. The logic to stash and restore RNG states can incur a moderate performance hit depending on the runtime of checkpointed operations. If deterministic output compared to non-checkpointed passes is not required, supply <code>preserve_rng_state=False</code> to <code>checkpoint</code> or <code>checkpoint_sequential</code> to omit stashing and restoring the RNG state during each checkpoint.</p> <p>The stashing logic saves and restores the RNG state for CPU and another device type (infer the device type from Tensor arguments excluding CPU tensors by <code>_infer_device_type</code>) to the <code>run_fn</code>. If there are multiple device, device state will only be saved for devices of a single device type, and the remaining devices will be ignored. Consequently, if any checkpointed functions involve randomness, this may result in incorrect gradients. (Note that if CUDA devices are among the devices detected, it will be prioritized; otherwise, the first device encountered will be selected.) If there are no CPU-tensors, the default device type state (default value is <code>cuda</code>, and it could be set to other device by <code>DefaultDeviceType</code>) will be saved and restored. However, the logic has no way to anticipate if the user will move Tensors to a new device within the <code>run_fn</code> itself. Therefore, if you move Tensors to a new device (“new” meaning not belonging to the set of [current device + devices of Tensor arguments]) within <code>run_fn</code>, deterministic output compared to non-checkpointed passes is never guaranteed.</p> </div> <dl class="py function"> <dt class="sig sig-object py" id="torch.utils.checkpoint.checkpoint">
<code>torch.utils.checkpoint.checkpoint(function, *args, use_reentrant=None, context_fn=&lt;function noop_context_fn&gt;, determinism_check='default', debug=False, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/utils/checkpoint.html#checkpoint"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Checkpoint a model or part of the model</p> <p>Activation checkpointing is a technique that trades compute for memory. Instead of keeping tensors needed for backward alive until they are used in gradient computation during backward, forward computation in checkpointed regions omits saving tensors for backward and recomputes them during the backward pass. Activation checkpointing can be applied to any part of a model.</p> <p>There are currently two checkpointing implementations available, determined by the <code>use_reentrant</code> parameter. It is recommended that you use <code>use_reentrant=False</code>. Please refer the note below for a discussion of their differences.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If the <code>function</code> invocation during the backward pass differs from the forward pass, e.g., due to a global variable, the checkpointed checkpointed version may not be equivalent, potentially causing an error being raised or leading to silently incorrect gradients.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If you are using the <code>use_reentrant=True</code> variant (this is currently the default), please refer to the note below for important considerations and potential limitations.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The reentrant variant of checkpoint (<code>use_reentrant=True</code>) and the non-reentrant variant of checkpoint (<code>use_reentrant=False</code>) differ in the following ways:</p> <ul class="simple"> <li>Non-reentrant checkpoint stops recomputation as soon as all needed intermediate activations have been recomputed. This feature is enabled by default, but can be disabled with <code>set_checkpoint_early_stop()</code>. Reentrant checkpoint always recomputes <code>function</code> in its entirety during the backward pass.</li> <li>The reentrant variant does not record the autograd graph during the forward pass, as it runs with the forward pass under <a class="reference internal" href="generated/torch.no_grad.html#torch.no_grad" title="torch.no_grad"><code>torch.no_grad()</code></a>. The non-reentrant version does record the autograd graph, allowing one to perform backward on the graph within checkpointed regions.</li> <li>The reentrant checkpoint only supports the <a class="reference internal" href="generated/torch.autograd.backward.html#torch.autograd.backward" title="torch.autograd.backward"><code>torch.autograd.backward()</code></a> API for the backward pass without its <code>inputs</code> argument, while the non-reentrant version supports all ways of performing the backward pass.</li> <li>At least one input and output must have <code>requires_grad=True</code> for the reentrant variant. If this condition is unmet, the checkpointed part of the model will not have gradients. The non-reentrant version does not have this requirement.</li> <li>The reentrant version does not consider tensors in nested structures (e.g., custom objects, lists, dicts, etc) as participating in autograd, while the non-reentrant version does.</li> <li>The reentrant checkpoint does not support checkpointed regions with detached tensors from the computational graph, whereas the non-reentrant version does. For the reentrant variant, if the checkpointed segment contains tensors detached using <code>detach()</code> or with <a class="reference internal" href="generated/torch.no_grad.html#torch.no_grad" title="torch.no_grad"><code>torch.no_grad()</code></a>, the backward pass will raise an error. This is because <code>checkpoint</code> makes all the outputs require gradients and this causes issues when a tensor is defined to have no gradient in the model. To avoid this, detach the tensors outside of the <code>checkpoint</code> function.</li> </ul> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>function</strong> – describes what to run in the forward pass of the model or part of the model. It should also know how to handle the inputs passed as the tuple. For example, in LSTM, if user passes <code>(activation, hidden)</code>, <code>function</code> should correctly use the first input as <code>activation</code> and the second input as <code>hidden</code>
</li> <li>
<strong>preserve_rng_state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Omit stashing and restoring the RNG state during each checkpoint. Default: <code>True</code>
</li> <li>
<strong>use_reentrant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Use checkpointing implementation that requires re-entrant autograd. If <code>use_reentrant=False</code> is specified, <code>checkpoint</code> will use an implementation that does not require re-entrant autograd. This allows <code>checkpoint</code> to support additional functionality, such as working as expected with <code>torch.autograd.grad</code> and support for keyword arguments input into the checkpointed function. Note that future versions of PyTorch will default to <code>use_reentrant=False</code>. Default: <code>True</code>
</li> <li>
<strong>context_fn</strong> (<em>Callable</em><em>, </em><em>optional</em>) – A callable returning a tuple of two context managers. The function and its recomputation will be run under the first and second context managers respectively. This argument is only supported if <code>use_reentrant=False</code>.</li> <li>
<strong>determinism_check</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)">str</a><em>, </em><em>optional</em>) – A string specifying the determinism check to perform. By default it is set to <code>"default"</code> which compares the shapes, dtypes, and devices of the recomputed tensors against those the saved tensors. To turn off this check, specify <code>"none"</code>. Currently these are the only two supported values. Please open an issue if you would like to see more determinism checks. This argument is only supported if <code>use_reentrant=False</code>, if <code>use_reentrant=True</code>, the determinism check is always disabled.</li> <li>
<strong>debug</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – If <code>True</code>, error messages will also include a trace of the operators ran during the original forward computation as well as the recomputation. This argument is only supported if <code>use_reentrant=False</code>.</li> <li>
<strong>args</strong> – tuple containing inputs to the <code>function</code>
</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>Output of running <code>function</code> on <code>*args</code></p> </dd> </dl> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="torch.utils.checkpoint.checkpoint_sequential">
<code>torch.utils.checkpoint.checkpoint_sequential(functions, segments, input, use_reentrant=True, **kwargs)</code> <a class="reference internal" href="https://pytorch.org/docs/2.1/_modules/torch/utils/checkpoint.html#checkpoint_sequential"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A helper function for checkpointing sequential models.</p> <p>Sequential models execute a list of modules/functions in order (sequentially). Therefore, we can divide such a model in various segments and checkpoint each segment. All segments except the last will not store the intermediate activations. The inputs of each checkpointed segment will be saved for re-running the segment in the backward pass.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If you are using the <code>use_reentrant=True` variant (this is the
default), please see :func:`~torch.utils.checkpoint.checkpoint` for
the important considerations and limitations of this variant. It is
recommended that you use ``use_reentrant=False</code>.</p> </div> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>functions</strong> – A <a class="reference internal" href="generated/torch.nn.sequential.html#torch.nn.Sequential" title="torch.nn.Sequential"><code>torch.nn.Sequential</code></a> or the list of modules or functions (comprising the model) to run sequentially.</li> <li>
<strong>segments</strong> – Number of chunks to create in the model</li> <li>
<strong>input</strong> – A Tensor that is input to <code>functions</code>
</li> <li>
<strong>preserve_rng_state</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Omit stashing and restoring the RNG state during each checkpoint. Default: <code>True</code>
</li> <li>
<strong>use_reentrant</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.12)">bool</a><em>, </em><em>optional</em>) – Use checkpointing implementation that requires re-entrant autograd. If <code>use_reentrant=False</code> is specified, <code>checkpoint</code> will use an implementation that does not require re-entrant autograd. This allows <code>checkpoint</code> to support additional functionality, such as working as expected with <code>torch.autograd.grad</code> and support for keyword arguments input into the checkpointed function. Default: <code>True</code>
</li> </ul> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<p>Output of running <code>functions</code> sequentially on <code>*inputs</code></p> </dd> </dl> <h4 class="rubric">Example</h4> <pre data-language="python">&gt;&gt;&gt; model = nn.Sequential(...)
&gt;&gt;&gt; input_var = checkpoint_sequential(model, chunks, input_var)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2024, PyTorch Contributors<br>PyTorch has a BSD-style license, as found in the <a href="https://github.com/pytorch/pytorch/blob/main/LICENSE">LICENSE</a> file.<br>
    <a href="https://pytorch.org/docs/2.1/checkpoint.html" class="_attribution-link">https://pytorch.org/docs/2.1/checkpoint.html</a>
  </p>
</div>
