<div class="subsection-level-extent" id="Argument-passing-conventions"> <div class="nav-panel"> <p> Previous: <a href="naming-conventions.html" accesskey="p" rel="prev">Naming conventions</a>, Up: <a href="naming-and-argument-passing-conventions.html" accesskey="u" rel="up">Naming and argument-passing conventions</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gfortran/Option-Index.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Argument-passing-conventions-1"><span>6.4.2 Argument passing conventions<a class="copiable-link" href="#Argument-passing-conventions-1"> ¶</a></span></h1> <p>Subroutines do not return a value (matching C99’s <code class="code">void</code>) while functions either return a value as specified in the platform ABI or the result variable is passed as hidden argument to the function and no result is returned. A hidden result variable is used when the result variable is an array or of type <code class="code">CHARACTER</code>. </p> <p>Arguments are passed according to the platform ABI. In particular, complex arguments might not be compatible to a struct with two real components for the real and imaginary part. The argument passing matches the one of C99’s <code class="code">_Complex</code>. Functions with scalar complex result variables return their value and do not use a by-reference argument. Note that with the <samp class="option">-ff2c</samp> option, the argument passing is modified and no longer completely matches the platform ABI. Some other Fortran compilers use <code class="code">f2c</code> semantic by default; this might cause problems with interoperablility. </p> <p>GNU Fortran passes most arguments by reference, i.e. by passing a pointer to the data. Note that the compiler might use a temporary variable into which the actual argument has been copied, if required semantically (copy-in/copy-out). </p> <p>For arguments with <code class="code">ALLOCATABLE</code> and <code class="code">POINTER</code> attribute (including procedure pointers), a pointer to the pointer is passed such that the pointer address can be modified in the procedure. </p> <p>For dummy arguments with the <code class="code">VALUE</code> attribute: Scalar arguments of the type <code class="code">INTEGER</code>, <code class="code">LOGICAL</code>, <code class="code">REAL</code> and <code class="code">COMPLEX</code> are passed by value according to the platform ABI. (As vendor extension and not recommended, using <code class="code">%VAL()</code> in the call to a procedure has the same effect.) For <code class="code">TYPE(C_PTR)</code> and procedure pointers, the pointer itself is passed such that it can be modified without affecting the caller. </p> <p>For Boolean (<code class="code">LOGICAL</code>) arguments, please note that GCC expects only the integer value 0 and 1. If a GNU Fortran <code class="code">LOGICAL</code> variable contains another integer value, the result is undefined. As some other Fortran compilers use <em class="math">-1</em> for <code class="code">.TRUE.</code>, extra care has to be taken – such as passing the value as <code class="code">INTEGER</code>. (The same value restriction also applies to other front ends of GCC, e.g. to GCC’s C99 compiler for <code class="code">_Bool</code> or GCC’s Ada compiler for <code class="code">Boolean</code>.) </p> <p>For arguments of <code class="code">CHARACTER</code> type, the character length is passed as a hidden argument at the end of the argument list. For deferred-length strings, the value is passed by reference, otherwise by value. The character length has the C type <code class="code">size_t</code> (or <code class="code">INTEGER(kind=C_SIZE_T)</code> in Fortran). Note that this is different to older versions of the GNU Fortran compiler, where the type of the hidden character length argument was a C <code class="code">int</code>. In order to retain compatibility with older versions, one can e.g. for the following Fortran procedure </p> <div class="example smallexample"> <pre class="example-preformatted">subroutine fstrlen (s, a)
   character(len=*) :: s
   integer :: a
   print*, len(s)
end subroutine fstrlen</pre>
</div> <p>define the corresponding C prototype as follows: </p> <div class="example smallexample"> <pre class="example-preformatted">#if __GNUC__ &gt; 7
typedef size_t fortran_charlen_t;
#else
typedef int fortran_charlen_t;
#endif

void fstrlen_ (char*, int*, fortran_charlen_t);</pre>
</div> <p>In order to avoid such compiler-specific details, for new code it is instead recommended to use the ISO_C_BINDING feature. </p> <p>Note with C binding, <code class="code">CHARACTER(len=1)</code> result variables are returned according to the platform ABI and no hidden length argument is used for dummy arguments; with <code class="code">VALUE</code>, those variables are passed by value. </p> <p>For <code class="code">OPTIONAL</code> dummy arguments, an absent argument is denoted by a NULL pointer, except for scalar dummy arguments of intrinsic type which have the <code class="code">VALUE</code> attribute. For those, a hidden Boolean argument (<code class="code">logical(kind=C_bool),value</code>) is used to indicate whether the argument is present. </p> <p>Arguments which are assumed-shape, assumed-rank or deferred-rank arrays or, with <samp class="option">-fcoarray=lib</samp>, allocatable scalar coarrays use an array descriptor. All other arrays pass the address of the first element of the array. With <samp class="option">-fcoarray=lib</samp>, the token and the offset belonging to nonallocatable coarrays dummy arguments are passed as hidden argument along the character length hidden arguments. The token is an opaque pointer identifying the coarray and the offset is a passed-by-value integer of kind <code class="code">C_PTRDIFF_T</code>, denoting the byte offset between the base address of the coarray and the passed scalar or first element of the passed array. </p> <p>The arguments are passed in the following order </p>
<ul class="itemize mark-bullet"> <li>Result variable, when the function result is passed by reference </li>
<li>Character length of the function result, if it is a of type <code class="code">CHARACTER</code> and no C binding is used </li>
<li>The arguments in the order in which they appear in the Fortran declaration </li>
<li>The present status for optional arguments with value attribute, which are internally passed by value </li>
<li>The character length and/or coarray token and offset for the first argument which is a <code class="code">CHARACTER</code> or a nonallocatable coarray dummy argument, followed by the hidden arguments of the next dummy argument of such a type </li>
</ul> </div>  <div class="nav-panel"> <p> Previous: <a href="naming-conventions.html">Naming conventions</a>, Up: <a href="naming-and-argument-passing-conventions.html">Naming and argument-passing conventions</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gfortran/Option-Index.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gfortran/Argument-passing-conventions.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gfortran/Argument-passing-conventions.html</a>
  </p>
</div>
