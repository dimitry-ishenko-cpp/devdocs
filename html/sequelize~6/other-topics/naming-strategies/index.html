<h1>Naming Strategies</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-underscored-option">The <code>underscored</code> option<a class="hash-link" href="#the-underscored-option" title="Direct link to heading">​</a>
</h2>
<p>Sequelize provides the <code>underscored</code> option for a model. When <code>true</code>, this option will set the <code>field</code> option on all attributes to the <a href="https://en.wikipedia.org/wiki/Snake_case" target="_blank" rel="noopener noreferrer">snake_case</a> version of its name. This also applies to foreign keys automatically generated by associations and other automatically generated fields. Example:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">const User = sequelize.define('user', { username: Sequelize.STRING }, {
  underscored: true
});
const Task = sequelize.define('task', { title: Sequelize.STRING }, {
  underscored: true
});
User.hasMany(Task);
Task.belongsTo(User);</pre>

</div></div>
<p>Above we have the models User and Task, both using the <code>underscored</code> option. We also have a One-to-Many relationship between them. Also, recall that since <code>timestamps</code> is true by default, we should expect the <code>createdAt</code> and <code>updatedAt</code> fields to be automatically created as well.</p>
<p>Without the <code>underscored</code> option, Sequelize would automatically define:</p>
<ul>
<li>A <code>createdAt</code> attribute for each model, pointing to a column named <code>createdAt</code> in each table</li>
<li>An <code>updatedAt</code> attribute for each model, pointing to a column named <code>updatedAt</code> in each table</li>
<li>A <code>userId</code> attribute in the <code>Task</code> model, pointing to a column named <code>userId</code> in the task table</li>
</ul>
<p>With the <code>underscored</code> option enabled, Sequelize will instead define:</p>
<ul>
<li>A <code>createdAt</code> attribute for each model, pointing to a column named <code>created_at</code> in each table</li>
<li>An <code>updatedAt</code> attribute for each model, pointing to a column named <code>updated_at</code> in each table</li>
<li>A <code>userId</code> attribute in the <code>Task</code> model, pointing to a column named <code>user_id</code> in the task table</li>
</ul>
<p>Note that in both cases the fields are still <a href="https://en.wikipedia.org/wiki/Camel_case" target="_blank" rel="noopener noreferrer">camelCase</a> in the JavaScript side; this option only changes how these fields are mapped to the database itself. The <code>field</code> option of every attribute is set to their snake_case version, but the attribute itself remains camelCase.</p>
<p>This way, calling <code>sync()</code> on the above code will generate the following:</p>
<div class="language-sql codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-sql codeBlock_bY9V thin-scrollbar" data-language="sql">CREATE TABLE IF NOT EXISTS "users" (
  "id" SERIAL,
  "username" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  PRIMARY KEY ("id")
);
CREATE TABLE IF NOT EXISTS "tasks" (
  "id" SERIAL,
  "title" VARCHAR(255),
  "created_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL,
  "user_id" INTEGER REFERENCES "users" ("id") ON DELETE SET NULL ON UPDATE CASCADE,
  PRIMARY KEY ("id")
);</pre>

</div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="singular-vs-plural">Singular vs. Plural<a class="hash-link" href="#singular-vs-plural" title="Direct link to heading">​</a>
</h2>
<p>At a first glance, it can be confusing whether the singular form or plural form of a name shall be used around in Sequelize. This section aims at clarifying that a bit.</p>
<p>Recall that Sequelize uses a library called <a href="https://www.npmjs.com/package/inflection" target="_blank" rel="noopener noreferrer">inflection</a> under the hood, so that irregular plurals (such as <code>person -&gt; people</code>) are computed correctly. However, if you're working in another language, you may want to define the singular and plural forms of names directly; sequelize allows you to do this with some options.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="when-defining-models">When defining models<a class="hash-link" href="#when-defining-models" title="Direct link to heading">​</a>
</h3>
<p>Models should be defined with the singular form of a word. Example:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">sequelize.define('foo', { name: DataTypes.STRING });</pre>

</div></div>
<p>Above, the model name is <code>foo</code> (singular), and the respective table name is <code>foos</code>, since Sequelize automatically gets the plural for the table name.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="when-defining-a-reference-key-in-a-model">When defining a reference key in a model<a class="hash-link" href="#when-defining-a-reference-key-in-a-model" title="Direct link to heading">​</a>
</h3>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">sequelize.define('foo', {
  name: DataTypes.STRING,
  barId: {
    type: DataTypes.INTEGER,
    allowNull: false,
    references: {
      model: "bars",
      key: "id"
    },
    onDelete: "CASCADE"
  },
});</pre>

</div></div>
<p>In the above example we are manually defining a key that references another model. It's not usual to do this, but if you have to, you should use the table name there. This is because the reference is created upon the referenced table name. In the example above, the plural form was used (<code>bars</code>), assuming that the <code>bar</code> model was created with the default settings (making its underlying table automatically pluralized).</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="when-retrieving-data-from-eager-loading">When retrieving data from eager loading<a class="hash-link" href="#when-retrieving-data-from-eager-loading" title="Direct link to heading">​</a>
</h3>
<p>When you perform an <code>include</code> in a query, the included data will be added to an extra field in the returned objects, according to the following rules:</p>
<ul>
<li>When including something from a single association (<code>hasOne</code> or <code>belongsTo</code>) - the field name will be the singular version of the model name;</li>
<li>When including something from a multiple association (<code>hasMany</code> or <code>belongsToMany</code>) - the field name will be the plural form of the model.</li>
</ul>
<p>In short, the name of the field will take the most logical form in each situation.</p>
<p>Examples:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">// Assuming Foo.hasMany(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bars will be an array
// foo.bar will not exist since it doens't make sense

// Assuming Foo.hasOne(Bar)
const foo = Foo.findOne({ include: Bar });
// foo.bar will be an object (possibly null if there is no associated model)
// foo.bars will not exist since it doens't make sense

// And so on.</pre>

</div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="overriding-singulars-and-plurals-when-defining-aliases">Overriding singulars and plurals when defining aliases<a class="hash-link" href="#overriding-singulars-and-plurals-when-defining-aliases" title="Direct link to heading">​</a>
</h3>
<p>When defining an alias for an association, instead of using simply <code>{ as: 'myAlias' }</code>, you can pass an object to specify the singular and plural forms:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">Project.belongsToMany(User, {
  as: {
    singular: 'líder',
    plural: 'líderes'
  }
});</pre>

</div></div>
<p>If you know that a model will always use the same alias in associations, you can provide the singular and plural forms directly to the model itself:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">const User = sequelize.define('user', { /* ... */ }, {
  name: {
    singular: 'líder',
    plural: 'líderes',
  }
});
Project.belongsToMany(User);</pre>

</div></div>
<p>The mixins added to the user instances will use the correct forms. For example, instead of <code>project.addUser()</code>, Sequelize will provide <code>project.getLíder()</code>. Also, instead of <code>project.setUsers()</code>, Sequelize will provide <code>project.setLíderes()</code>.</p>
<p>Note: recall that using <code>as</code> to change the name of the association will also change the name of the foreign key. Therefore it is recommended to also specify the foreign key(s) involved directly in this case.</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">// Example of possible mistake
Invoice.belongsTo(Subscription, { as: 'TheSubscription' });
Subscription.hasMany(Invoice);</pre>

</div></div>
<p>The first call above will establish a foreign key called <code>theSubscriptionId</code> on <code>Invoice</code>. However, the second call will also establish a foreign key on <code>Invoice</code> (since as we know, <code>hasMany</code> calls places foreign keys in the target model) - however, it will be named <code>subscriptionId</code>. This way you will have both <code>subscriptionId</code> and <code>theSubscriptionId</code> columns.</p>
<p>The best approach is to choose a name for the foreign key and place it explicitly in both calls. For example, if <code>subscription_id</code> was chosen:</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="js">// Fixed example
Invoice.belongsTo(Subscription, { as: 'TheSubscription', foreignKey: 'subscription_id' });
Subscription.hasMany(Invoice, { foreignKey: 'subscription_id' });</pre>

</div></div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2014&ndash;present Sequelize contributors<br>Licensed under the MIT License.<br>
    <a href="https://sequelize.org/docs/v6/other-topics/naming-strategies/" class="_attribution-link">https://sequelize.org/docs/v6/other-topics/naming-strategies/</a>
  </p>
</div>
