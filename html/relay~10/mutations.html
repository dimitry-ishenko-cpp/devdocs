<h1 id="__docusaurus" class="postHeaderTitle">Mutations</h1>
<article><div><span><p>Table of Contents:</p> <ul> <li><a href="#commitmutation"><code>commitMutation</code></a></li> <li><a href="#simple-example">Simple Example</a></li> <li><a href="#optimistic-updates">Optimistic Updates</a></li> <li><a href="#updater-configs">Updater Configs</a></li> <li><a href="#using-updater-and-optimisticupdater">Using updater and optimisticUpdater</a></li> <li><a href="#committing-local-updates">Committing Local Updates</a></li> </ul> <h2 id="commitmutation">
<code>commitMutation</code>
</h2> <p>Use <code>commitMutation</code> to create and execute mutations. <code>commitMutation</code> has the following signature:</p> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript">commitMutation(
  environment: Environment,
  <span class="hljs-attr">config</span>: {
    <span class="hljs-attr">mutation</span>: GraphQLTaggedNode,
    <span class="hljs-attr">variables</span>: {[name: string]: mixed},
    onCompleted?: ?<span class="hljs-function">(<span class="hljs-params">response: ?<span class="hljs-built_in">Object</span>, errors: ?<span class="hljs-built_in">Array</span>&lt;PayloadError&gt;</span>) =&gt;</span> <span class="hljs-keyword">void</span>,
    onError?: ?<span class="hljs-function">(<span class="hljs-params">error: <span class="hljs-built_in">Error</span></span>) =&gt;</span> <span class="hljs-keyword">void</span>,
    optimisticResponse?: <span class="hljs-built_in">Object</span>,
    optimisticUpdater?: ?<span class="hljs-function">(<span class="hljs-params">store: RecordSourceSelectorProxy</span>) =&gt;</span> <span class="hljs-keyword">void</span>,
    updater?: ?<span class="hljs-function">(<span class="hljs-params">store: RecordSourceSelectorProxy, data: SelectorData</span>) =&gt;</span> <span class="hljs-keyword">void</span>,
    configs?: <span class="hljs-built_in">Array</span>&lt;DeclarativeMutationConfig&gt;,
    cacheConfig?: CacheConfig,
  },
);
</code></pre> <h3 id="arguments">
Arguments</h3> <ul> <li>
<code>environment</code>: The <a href="relay-environment.html">Relay Environment</a>. <strong>Note:</strong> To ensure the mutation is performed on the correct <code>environment</code>, it's recommended to use the environment available within components (from <code>this.props.relay.environment</code>), instead of referencing a global environment.</li> <li>
<code>config</code>: <ul> <li>
<code>mutation</code>: The <code>graphql</code> tagged mutation query.</li> <li>
<code>variables</code>: Object containing the variables needed for the mutation. For example, if the mutation defines an <code>$input</code> variable, this object should contain an <code>input</code> key, whose shape must match the shape of the data expected by the mutation as defined by the GraphQL schema.</li> <li>
<code>onCompleted</code>: Callback function executed when the request is completed and the in-memory Relay store is updated with the <code>updater</code> function. Takes a <code>response</code> object, which is the updated response from the store, and <code>errors</code>, an array containing any errors from the server.</li> <li>
<code>onError</code>: Callback function executed if Relay encounters an error during the request.</li> <li>
<code>optimisticResponse</code>: Object containing the data to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. This object must have the same shape as the mutation's response type, as defined by the GraphQL schema. If provided, Relay will use the <code>optimisticResponse</code> data to update the fields on the relevant records in the local data store, <em>before</em> <code>optimisticUpdater</code> is executed. If an error occurs during the mutation request, the optimistic update will be rolled back.</li> <li>
<code>optimisticUpdater</code>: Function used to optimistically update the local in-memory store, i.e. immediately, before the mutation request has completed. If an error occurs during the mutation request, the optimistic update will be rolled back. This function takes a <code>store</code>, which is a proxy of the in-memory <a href="relay-store.html">Relay Store</a>. In this function, the client defines 'how to' update the local data via the <code>store</code> instance. For details on how to use the <code>store</code>, please refer to our <a href="relay-store.html">Relay Store API Reference</a>. <strong>Please note:</strong> <ul> <li>It is usually preferable to just pass an <code>optimisticResponse</code> option instead of an <code>optimisticUpdater</code>, unless you need to perform updates on the local records that are more complicated than just updating fields (e.g. deleting records or adding items to collections).</li> <li>If you do decide to use an <code>optimisticUpdater</code>, often times it can be the same function as <code>updater</code>.</li> </ul>
</li> <li>
<code>updater</code>: Function used to update the local in-memory store based on the <strong>real</strong> server response from the mutation. If <code>updater</code> is not provided, by default, Relay will know to automatically update the fields on the records referenced in the mutation response; however, you should pass an <code>updater</code> if you need to make more complicated updates than just updating fields (e.g. deleting records or adding items to collections). When the server response comes back, Relay first reverts any changes introduced by <code>optimisticUpdater</code> or <code>optimisticResponse</code> and will then execute <code>updater</code>. This function takes a <code>store</code>, which is a proxy of the in-memory <a href="relay-store.html">Relay Store</a>. In this function, the client defines 'how to' update the local data based on the server response via the <code>store</code> instance. For details on how to use the <code>store</code>, please refer to our <a href="relay-store.html">Relay Store API Reference</a>.</li> <li>
<code>configs</code>: Array containing objects describing <code>optimisticUpdater</code>/<code>updater</code> configurations. <code>configs</code> provides a convenient way to specify the <code>updater</code> behavior without having to write an <code>updater</code> function. See our section on <a href="#updater-configs">Updater Configs</a> for more details.</li> <li>
<code>cacheConfig?</code>: Optional object containing a set of cache configuration options</li> </ul>
</li> </ul> <h2 id="simple-example">
Simple Example</h2> <p>Example of a simple mutation:</p> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> {commitMutation, graphql} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;

<span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation MarkReadNotificationMutation(
    $storyID: ID!
  ) {
    markReadNotification(id: $storyID) {
      notification {
        seenState
      }
    }
  }
`</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">markNotificationAsRead</span>(<span class="hljs-params">environment, storyID</span>) </span>{
  <span class="hljs-keyword">const</span> variables = {
    storyID,
  };

  commitMutation(
    environment,
    {
      mutation,
      variables,
      <span class="hljs-attr">onCompleted</span>: <span class="hljs-function">(<span class="hljs-params">response, errors</span>) =&gt;</span> {
        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Response received from server.'</span>)
      },
      <span class="hljs-attr">onError</span>: <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.error(err),
    },
  );
}
</code></pre> <h2 id="optimistic-updates">
Optimistic Updates</h2> <p>To improve perceived responsiveness, you may wish to perform an "optimistic update", in which the client immediately updates to reflect the anticipated new value even before the response from the server has come back. The simplest way to do this is by providing an <code>optimisticResponse</code> and adding it to the <code>config</code> that we pass into <code>commitMutation</code>:</p> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation MarkReadNotificationMutation(
    $storyID: ID!
  ) {
    markReadNotification(id: $storyID) {
      notification {
        seenState
      }
    }
  }
`</span>;

<span class="hljs-keyword">const</span> optimisticResponse = {
  <span class="hljs-attr">markReadNotification</span>: {
    <span class="hljs-attr">notification</span>: {
      <span class="hljs-attr">seenState</span>: SEEN,
    },
  },
};

commitMutation(
  environment,
  {
    mutation,
    optimisticResponse,
    variables,
  },
);
</code></pre> <p>Another way to enable optimistic updates is via the <code>optimisticUpdater</code>, which can be used for more complicated update scenarios. Using <code>optimisticUpdater</code> is covered in the section <a href="#using-updater-and-optimisticupdater">below</a>.</p> <h2 id="updater-configs">
Updater Configs</h2> <p>We can give Relay instructions in the form of a <code>configs</code> array on how to use the response from each mutation to update the client-side store. We do this by configuring the mutation with one or more of the following config types:</p> <h3 id="node_delete">
NODE_DELETE</h3> <p>Given a <code>deletedIDFieldName</code>, Relay will remove the node(s) from the store.</p> <p><strong>Note</strong>: this will not remove it from any connection it might be in. If you want to remove a node from a connection, take a look at <a href="#RANGE_DELETE">RANGE_DELETE</a>.</p> <h4>
Arguments</h4> <ul> <li>
<code>deletedIDFieldName: string</code>: The field name in the response that contains the DataID or DataIDs of the deleted node or nodes</li> </ul> <h4>
Example</h4> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation DestroyShipMutation($target: ID!) {
    destroyShip(target: $target) {
      destroyedShipId
      faction {
        ships {
          id
        }
      }
    }
  }
`</span>;

<span class="hljs-keyword">const</span> configs = [{
  <span class="hljs-attr">type</span>: <span class="hljs-string">'NODE_DELETE'</span>,
  <span class="hljs-attr">deletedIDFieldName</span>: <span class="hljs-string">'destroyedShipId'</span>,
}];
</code></pre> <h3 id="range_add">
RANGE_ADD</h3> <p>Given a parent, information about the connection, and the name of the newly created edge in the response payload Relay will add the node to the store and attach it to the connection according to the range behavior(s) specified in the connectionInfo.</p> <h4>
Arguments</h4> <ul> <li>
<code>parentID: string</code>: The DataID of the parent node that contains the connection.</li> <li>
<code>connectionInfo: Array&lt;{key: string, filters?: Variables, rangeBehavior: string}&gt;</code>: An array of objects containing a connection key, an object containing optional filters, and a range behavior depending on what behavior we expect (append, prepend, or ignore). <ul> <li>
<code>filters</code>: An object containing GraphQL calls e.g. <code>const filters = {'orderby': 'chronological'};</code>.</li> </ul>
</li> <li>
<code>edgeName: string</code>: The field name in the response that represents the newly created edge</li> </ul> <h4>
Example</h4> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation AddShipMutation($factionID: ID!, $name: String!) {
    addShip(factionID: $factionID, name: $name) {
      shipEdge {
        node {
          name
        }
      }
    }
  }
`</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commit</span>(<span class="hljs-params">environment, factionID, name</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation(environment, {
    mutation,
    <span class="hljs-attr">variables</span>: {
      factionID,
      name,
    },
    <span class="hljs-attr">configs</span>: [{
      <span class="hljs-attr">type</span>: <span class="hljs-string">'RANGE_ADD'</span>,
      <span class="hljs-attr">parentID</span>: factionID,
      <span class="hljs-attr">connectionInfo</span>: [{
        <span class="hljs-attr">key</span>: <span class="hljs-string">'AddShip_ships'</span>,
        <span class="hljs-attr">rangeBehavior</span>: <span class="hljs-string">'append'</span>,
      }],
      <span class="hljs-attr">edgeName</span>: <span class="hljs-string">'shipEdge'</span>,
    }],
  });
}
</code></pre> <h3 id="range_delete">
RANGE_DELETE</h3> <p>Given a parent, <code>connectionKeys</code>, one or more DataIDs in the response payload, and a path between the parent and the connection, Relay will remove the node(s) from the connection but leave the associated record(s) in the store.</p> <h4>
Arguments</h4> <ul> <li>
<code>parentID: string</code>: The DataID of the parent node that contains the connection.</li> <li>
<code>connectionKeys: Array&lt;{key: string, filters?: Variables}&gt;</code>: An array of objects containing a connection key and optionally filters. <ul> <li>
<code>filters</code>: An object containing GraphQL calls e.g. <code>const filters = {'orderby': 'chronological'};</code>.</li> </ul>
</li> <li>
<code>pathToConnection: Array&lt;string&gt;</code>: An array containing the field names between the parent and the connection, including the parent and the connection.</li> <li>
<code>deletedIDFieldName: string | Array&lt;string&gt;</code>: The field name in the response that contains the DataID or DataIDs of the removed node or nodes, or the path to the node or nodes removed from the connection</li> </ul> <h4>
Example</h4> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation RemoveTagMutation($todoID: ID!, $tagID: ID!) {
    removeTag(todo: $todoID, tag: $tagID) {
      removedTagID
    }
  }
`</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commit</span>(<span class="hljs-params">environment, todoID, tagID</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation(environment, {
    mutation,
    <span class="hljs-attr">variables</span>: {
      todoID,
      tagID,
    },
    <span class="hljs-attr">configs</span>: [{
      <span class="hljs-attr">type</span>: <span class="hljs-string">'RANGE_DELETE'</span>,
      <span class="hljs-attr">parentID</span>: todoID,
      <span class="hljs-attr">connectionKeys</span>: [{
        <span class="hljs-attr">key</span>: <span class="hljs-string">'RemoveTags_tags'</span>,
      }],
      <span class="hljs-attr">pathToConnection</span>: [<span class="hljs-string">'todo'</span>, <span class="hljs-string">'tags'</span>],
      <span class="hljs-attr">deletedIDFieldName</span>: <span class="hljs-string">'removedTagID'</span>,
    }],
  });
}
</code></pre> <h2 id="using-updater-and-optimisticupdater">
Using updater and optimisticUpdater</h2> <p><code>updater</code> and <code>optimisticUpdater</code> are functions that you can pass to a <code>commitMutation</code> call when you need full control over how to update the local data store, either optimistically, or based on a server response. Often times, both of these can be the same function.</p> <p>When you provide these functions, this is roughly what happens during the mutation request:</p> <ul> <li>If <code>optimisticResponse</code> is provided, Relay will use it to update the fields under the records as specified by the ids in the <code>optimisticResponse</code>.</li> <li>If <code>optimisticUpdater</code> is provided, Relay will execute it and update the store accordingly.</li> <li>After the network comes back, if any optimistic update was applied, it will be rolled back.</li> <li>Relay will then automatically update the fields under the record corresponding to the ids in the response payload.</li> <li>If an <code>updater</code> was provided, Relay will execute it and update the store accordingly. The server payload will be available to the <code>updater</code> as a root field in the store.</li> </ul> <p>Here are a quick example of adding a todo item to a Todo list using this <a href="https://github.com/relayjs/relay-examples/blob/master/todo/data/schema.graphql#L36">example schema</a>:</p> <pre data-language="javascript" class="highlight"><code class="hljs css language-javascript"><span class="hljs-comment">// AddTodoMutation.js</span>
<span class="hljs-keyword">import</span> {commitMutation, graphql} <span class="hljs-keyword">from</span> <span class="hljs-string">'react-relay'</span>;
<span class="hljs-keyword">import</span> {ConnectionHandler} <span class="hljs-keyword">from</span> <span class="hljs-string">'relay-runtime'</span>;

<span class="hljs-keyword">const</span> mutation = graphql<span class="hljs-string">`
  mutation AddTodoMutation($text: String!) {
    addTodo(text: $text) {
      todoEdge {
        cursor
        node {
          complete
          id
          text
        }
      }
      viewer {
        id
        totalCount
      }
    }
  }
`</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sharedUpdater</span>(<span class="hljs-params">store, user, newEdge</span>) </span>{
  <span class="hljs-comment">// Get the current user record from the store</span>
  <span class="hljs-keyword">const</span> userProxy = store.get(user.id);

  <span class="hljs-comment">// Get the user's Todo List using ConnectionHandler helper</span>
  <span class="hljs-keyword">const</span> conn = ConnectionHandler.getConnection(
    userProxy,
    <span class="hljs-string">'TodoList_todos'</span>, <span class="hljs-comment">// This is the connection identifier, defined here</span>
    <span class="hljs-comment">// https://github.com/relayjs/relay-examples/blob/master/todo/js/components/TodoList.js#L76</span>
  );

  <span class="hljs-comment">// Insert the new todo into the Todo List connection</span>
  ConnectionHandler.insertEdgeAfter(conn, newEdge);
}

<span class="hljs-keyword">let</span> tempID = <span class="hljs-number">0</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">commit</span>(<span class="hljs-params">environment, text, user</span>) </span>{
  <span class="hljs-keyword">return</span> commitMutation(environment, {
    mutation,
    <span class="hljs-attr">variables</span>: {
      text,
    },
    <span class="hljs-attr">updater</span>: <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> {
      <span class="hljs-comment">// Get the payload returned from the server</span>
      <span class="hljs-keyword">const</span> payload = store.getRootField(<span class="hljs-string">'addTodo'</span>);

      <span class="hljs-comment">// Get the edge of the newly created Todo record</span>
      <span class="hljs-keyword">const</span> newEdge = payload.getLinkedRecord(<span class="hljs-string">'todoEdge'</span>);

      <span class="hljs-comment">// Add it to the user's todo list</span>
      sharedUpdater(store, user, newEdge);
    },
    <span class="hljs-attr">optimisticUpdater</span>: <span class="hljs-function">(<span class="hljs-params">store</span>) =&gt;</span> {
      <span class="hljs-comment">// Create a Todo record in our store with a temporary ID</span>
      <span class="hljs-keyword">const</span> id = <span class="hljs-string">'client:newTodo:'</span> + tempID++;
      <span class="hljs-keyword">const</span> node = store.create(id, <span class="hljs-string">'Todo'</span>);
      node.setValue(text, <span class="hljs-string">'text'</span>);
      node.setValue(id, <span class="hljs-string">'id'</span>);

      <span class="hljs-comment">// Create a new edge that contains the newly created Todo record</span>
      <span class="hljs-keyword">const</span> newEdge = store.create(
        <span class="hljs-string">'client:newEdge:'</span> + tempID++,
        <span class="hljs-string">'TodoEdge'</span>,
      );
      newEdge.setLinkedRecord(node, <span class="hljs-string">'node'</span>);

      <span class="hljs-comment">// Add it to the user's todo list</span>
      sharedUpdater(store, user, newEdge);

      <span class="hljs-comment">// Given that we don't have a server response here,</span>
      <span class="hljs-comment">// we also need to update the todo item count on the user</span>
      <span class="hljs-keyword">const</span> userRecord = store.get(user.id);
      userRecord.setValue(
        userRecord.getValue(<span class="hljs-string">'totalCount'</span>) + <span class="hljs-number">1</span>,
        <span class="hljs-string">'totalCount'</span>,
      );
    },
  });
}
</code></pre> <p>For details on how to interact with the Relay Store, please refer to our Relay Store <a href="relay-store.html">docs</a>.</p> <h2 id="committing-local-updates">
Committing Local Updates</h2> <p>Use <code>commitLocalUpdate</code> when you need to update the local store without necessarily executing a mutation (such as in the case of debounced operations). The function takes in a Relay <code>environment</code> and an <code>updater</code> function.</p> </span></div></article><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2020&ndash;present Facebook Inc.<br>Licensed under the BSD License.<br>
    <a href="https://relay.dev/docs/en/mutations.html" class="_attribution-link">https://relay.dev/docs/en/mutations.html</a>
  </p>
</div>
