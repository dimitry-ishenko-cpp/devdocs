<h1>Configuring Jest</h1>
<p>The Jest philosophy is to work great by default, but sometimes you just need more configuration power.</p>
<p>It is recommended to define the configuration in a dedicated JavaScript, TypeScript or JSON file. The file will be discovered automatically, if it is named <code>jest.config.js|ts|mjs|cjs|json</code>. You can use <a href="cli.html#--configpath"><code>--config</code></a> flag to pass an explicit path to the file.</p>
<div class="theme-admonition theme-admonition-note alert alert--secondary admonition_uH4V">
<div class="admonitionHeading_P5_N">
note</div>
<div class="admonitionContent_yySL"><p>Keep in mind that the resulting configuration object must always be JSON-serializable.</p></div>
</div>
<p>The configuration file should simply export an object:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  verbose: true,
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  verbose: true,
};

export default config;</pre>

</div>
</div>
</div>
<p>Or a function returning an object:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @returns {Promise&lt;import('jest').Config&gt;} */
module.exports = async () =&gt; {
  return {
    verbose: true,
  };
};</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

export default async (): Promise&lt;Config&gt; =&gt; {
  return {
    verbose: true,
  };
};</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>To read TypeScript configuration files Jest requires <a href="https://npmjs.com/package/ts-node" target="_blank" rel="noopener noreferrer"><code>ts-node</code></a>. Make sure it is installed in your project.</p></div>
</div>
<p>The configuration also can be stored in a JSON file as a plain object:</p>
<pre tabindex="0" data-language="typescript">{
  "bail": 1,
  "verbose": true
}</pre>
<div class="language-json codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">jest.config.json</div>

</div>
<p>Alternatively Jest's configuration can be defined through the <code>"jest"</code> key in the <code>package.json</code> of your project:</p>
<pre tabindex="0" data-language="typescript">{
  "name": "my-project",
  "jest": {
    "verbose": true
  }
}</pre>
<div class="language-json codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">package.json</div>

</div>
<h2 class="anchor anchorWithStickyNavbar_JmGV" id="options">Options</h2>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL">
<p>You can retrieve Jest's defaults from <code>jest-config</code> to extend them if needed:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">const {defaults} = require('jest-config');

/** @type {import('jest').Config} */
const config = {
  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts', 'cts'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';
import {defaults} from 'jest-config';

const config: Config = {
  moduleFileExtensions: [...defaults.moduleFileExtensions, 'mts'],
};

export default config;</pre>

</div>
</div>
</div>
</div>
</div>
<div class="tableOfContentsInline_pY9K"><ul class="table-of-contents">
<li><a href="#automock-boolean"><code>automock</code> [boolean]</a></li>
<li><a href="#bail-number--boolean"><code>bail</code> [number | boolean]</a></li>
<li><a href="#cachedirectory-string"><code>cacheDirectory</code> [string]</a></li>
<li><a href="#clearmocks-boolean"><code>clearMocks</code> [boolean]</a></li>
<li><a href="#collectcoverage-boolean"><code>collectCoverage</code> [boolean]</a></li>
<li><a href="#collectcoveragefrom-array"><code>collectCoverageFrom</code> [array]</a></li>
<li><a href="#coveragedirectory-string"><code>coverageDirectory</code> [string]</a></li>
<li><a href="#coveragepathignorepatterns-arraystring"><code>coveragePathIgnorePatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#coverageprovider-string"><code>coverageProvider</code> [string]</a></li>
<li><a href="#coveragereporters-arraystring--string-options"><code>coverageReporters</code> [array&lt;string | [string, options]&gt;]</a></li>
<li><a href="#coveragethreshold-object"><code>coverageThreshold</code> [object]</a></li>
<li><a href="#dependencyextractor-string"><code>dependencyExtractor</code> [string]</a></li>
<li><a href="#displayname-string-object"><code>displayName</code> [string, object]</a></li>
<li><a href="#errorondeprecated-boolean"><code>errorOnDeprecated</code> [boolean]</a></li>
<li><a href="#extensionstotreatasesm-arraystring"><code>extensionsToTreatAsEsm</code> [array&lt;string&gt;]</a></li>
<li><a href="#faketimers-object"><code>fakeTimers</code> [object]</a></li>
<li><a href="#forcecoveragematch-arraystring"><code>forceCoverageMatch</code> [array&lt;string&gt;]</a></li>
<li><a href="#globals-object"><code>globals</code> [object]</a></li>
<li><a href="#globalsetup-string"><code>globalSetup</code> [string]</a></li>
<li><a href="#globalteardown-string"><code>globalTeardown</code> [string]</a></li>
<li><a href="#haste-object"><code>haste</code> [object]</a></li>
<li><a href="#injectglobals-boolean"><code>injectGlobals</code> [boolean]</a></li>
<li><a href="#maxconcurrency-number"><code>maxConcurrency</code> [number]</a></li>
<li><a href="#maxworkers-number--string"><code>maxWorkers</code> [number | string]</a></li>
<li><a href="#moduledirectories-arraystring"><code>moduleDirectories</code> [array&lt;string&gt;]</a></li>
<li><a href="#modulefileextensions-arraystring"><code>moduleFileExtensions</code> [array&lt;string&gt;]</a></li>
<li><a href="#modulenamemapper-objectstring-string--arraystring"><code>moduleNameMapper</code> [object&lt;string, string | array&lt;string&gt;&gt;]</a></li>
<li><a href="#modulepathignorepatterns-arraystring"><code>modulePathIgnorePatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#modulepaths-arraystring"><code>modulePaths</code> [array&lt;string&gt;]</a></li>
<li><a href="#notify-boolean"><code>notify</code> [boolean]</a></li>
<li><a href="#notifymode-string"><code>notifyMode</code> [string]</a></li>
<li><a href="#preset-string"><code>preset</code> [string]</a></li>
<li><a href="#prettierpath-string"><code>prettierPath</code> [string]</a></li>
<li><a href="#projects-arraystring--projectconfig"><code>projects</code> [array&lt;string | ProjectConfig&gt;]</a></li>
<li><a href="#reporters-arraymodulename--modulename-options"><code>reporters</code> [array&lt;moduleName | [moduleName, options]&gt;]</a></li>
<li><a href="#resetmocks-boolean"><code>resetMocks</code> [boolean]</a></li>
<li><a href="#resetmodules-boolean"><code>resetModules</code> [boolean]</a></li>
<li><a href="#resolver-string"><code>resolver</code> [string]</a></li>
<li><a href="#restoremocks-boolean"><code>restoreMocks</code> [boolean]</a></li>
<li><a href="#rootdir-string"><code>rootDir</code> [string]</a></li>
<li><a href="#roots-arraystring"><code>roots</code> [array&lt;string&gt;]</a></li>
<li><a href="#runner-string"><code>runner</code> [string]</a></li>
<li><a href="#sandboxinjectedglobals-arraystring"><code>sandboxInjectedGlobals</code> [array&lt;string&gt;]</a></li>
<li><a href="#setupfiles-array"><code>setupFiles</code> [array]</a></li>
<li><a href="#setupfilesafterenv-array"><code>setupFilesAfterEnv</code> [array]</a></li>
<li><a href="#slowtestthreshold-number"><code>slowTestThreshold</code> [number]</a></li>
<li><a href="#snapshotformat-object"><code>snapshotFormat</code> [object]</a></li>
<li><a href="#snapshotresolver-string"><code>snapshotResolver</code> [string]</a></li>
<li><a href="#snapshotserializers-arraystring"><code>snapshotSerializers</code> [array&lt;string&gt;]</a></li>
<li><a href="#testenvironment-string"><code>testEnvironment</code> [string]</a></li>
<li><a href="#testenvironmentoptions-object"><code>testEnvironmentOptions</code> [Object]</a></li>
<li><a href="#testfailureexitcode-number"><code>testFailureExitCode</code> [number]</a></li>
<li><a href="#testmatch-arraystring"><code>testMatch</code> [array&lt;string&gt;]</a></li>
<li><a href="#testpathignorepatterns-arraystring"><code>testPathIgnorePatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#testregex-string--arraystring"><code>testRegex</code> [string | array&lt;string&gt;]</a></li>
<li><a href="#testresultsprocessor-string"><code>testResultsProcessor</code> [string]</a></li>
<li><a href="#testrunner-string"><code>testRunner</code> [string]</a></li>
<li><a href="#testsequencer-string"><code>testSequencer</code> [string]</a></li>
<li><a href="#testtimeout-number"><code>testTimeout</code> [number]</a></li>
<li><a href="#transform-objectstring-pathtotransformer--pathtotransformer-object"><code>transform</code> [object&lt;string, pathToTransformer | [pathToTransformer, object]&gt;]</a></li>
<li><a href="#transformignorepatterns-arraystring"><code>transformIgnorePatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#unmockedmodulepathpatterns-arraystring"><code>unmockedModulePathPatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#verbose-boolean"><code>verbose</code> [boolean]</a></li>
<li><a href="#watchpathignorepatterns-arraystring"><code>watchPathIgnorePatterns</code> [array&lt;string&gt;]</a></li>
<li><a href="#watchplugins-arraystring--string-object"><code>watchPlugins</code> [array&lt;string | [string, Object]&gt;]</a></li>
<li><a href="#watchman-boolean"><code>watchman</code> [boolean]</a></li>
<li><a href="#workeridlememorylimit-numberstring"><code>workerIdleMemoryLimit</code> [number|string]</a></li>
<li><a href="#-string"><code>//</code> [string]</a></li>
</ul></div>
<h2 class="anchor anchorWithStickyNavbar_JmGV" id="reference">Reference</h2>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="automock-boolean">
<code>automock</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>This option tells Jest that all imported modules in your tests should be mocked automatically. All modules used in your tests will have a replacement implementation, keeping the API surface.</p>
<p>Example:</p>
<pre tabindex="0" data-language="typescript">export default {
  authorize: () =&gt; 'token',
  isAuthorized: secret =&gt; secret === 'wizard',
};</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">utils.js</div>

</div>
<pre tabindex="0" data-language="typescript">import utils from '../utils';

test('if utils mocked automatically', () =&gt; {
  // Public methods of `utils` are now mock functions
  expect(utils.authorize.mock).toBeTruthy();
  expect(utils.isAuthorized.mock).toBeTruthy();

  // You can provide them with your own implementation
  // or pass the expected return value
  utils.authorize.mockReturnValue('mocked_token');
  utils.isAuthorized.mockReturnValue(true);

  expect(utils.authorize()).toBe('mocked_token');
  expect(utils.isAuthorized('not_wizard')).toBeTruthy();
});</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">__tests__/automock.test.js</div>

</div>
<div class="theme-admonition theme-admonition-note alert alert--secondary admonition_uH4V">
<div class="admonitionHeading_P5_N">
note</div>
<div class="admonitionContent_yySL">
<p>Node modules are automatically mocked when you have a manual mock in place (e.g.: <code>__mocks__/lodash.js</code>). More info <a href="manual-mocks.html#mocking-node-modules">here</a>.</p>
<p>Node.js core modules, like <code>fs</code>, are not mocked by default. They can be mocked explicitly, like <code>jest.mock('fs')</code>.</p>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="bail-number--boolean">
<code>bail</code> [number | boolean]</h3>
<p>Default: <code>0</code></p>
<p>By default, Jest runs all tests and produces all errors into the console upon completion. The bail config option can be used here to have Jest stop running tests after <code>n</code> failures. Setting bail to <code>true</code> is the same as setting bail to <code>1</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="cachedirectory-string">
<code>cacheDirectory</code> [string]</h3>
<p>Default: <code>"/tmp/&lt;path&gt;"</code></p>
<p>The directory where Jest should store its cached dependency information.</p>
<p>Jest attempts to scan your dependency tree once (up-front) and cache it in order to ease some of the filesystem churn that needs to happen while running tests. This config option lets you customize where Jest stores that cache data on disk.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="clearmocks-boolean">
<code>clearMocks</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Automatically clear mock calls, instances, contexts and results before every test. Equivalent to calling <a href="jest-object.html#jestclearallmocks"><code>jest.clearAllMocks()</code></a> before each test. This does not remove any mock implementation that may have been provided.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="collectcoverage-boolean">
<code>collectCoverage</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Indicates whether the coverage information should be collected while executing the test. Because this retrofits all executed files with coverage collection statements, it may significantly slow down your tests.</p>
<p>Jest ships with two coverage providers: <code>babel</code> (default) and <code>v8</code>. See the <a href="#coverageprovider-string"><code>coverageProvider</code></a> option for more details.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>The <code>babel</code> and <code>v8</code> coverage providers use <code>/* istanbul ignore next */</code> and <code>/* c8 ignore next */</code> comments to exclude lines from coverage reports, respectively. For more information, you can view the <a href="https://github.com/istanbuljs/nyc#parsing-hints-ignoring-lines" target="_blank" rel="noopener noreferrer"><code>istanbuljs</code> documentation</a> and the <a href="https://github.com/bcoe/c8#ignoring-uncovered-lines-functions-and-blocks" target="_blank" rel="noopener noreferrer"><code>c8</code> documentation</a>.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="collectcoveragefrom-array">
<code>collectCoverageFrom</code> [array]</h3>
<p>Default: <code>undefined</code></p>
<p>An array of <a href="https://github.com/micromatch/micromatch" target="_blank" rel="noopener noreferrer">glob patterns</a> indicating a set of files for which coverage information should be collected. If a file matches the specified glob pattern, coverage information will be collected for it even if no tests exist for this file and it's never required in the test suite.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  collectCoverageFrom: [
    '**/*.{js,jsx}',
    '!**/node_modules/**',
    '!**/vendor/**',
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  collectCoverageFrom: [
    '**/*.{js,jsx}',
    '!**/node_modules/**',
    '!**/vendor/**',
  ],
};

export default config;</pre>

</div>
</div>
</div>
<p>This will collect coverage information for all the files inside the project's <code>rootDir</code>, except the ones that match <code>**/node_modules/**</code> or <code>**/vendor/**</code>.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Each glob pattern is applied in the order they are specified in the config. For example <code>["!**/__tests__/**", "**/*.js"]</code> will not exclude <code>__tests__</code> because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after <code>**/*.js</code>.</p></div>
</div>
<div class="theme-admonition theme-admonition-note alert alert--secondary admonition_uH4V">
<div class="admonitionHeading_P5_N">
note</div>
<div class="admonitionContent_yySL"><p>This option requires <code>collectCoverage</code> to be set to <code>true</code> or Jest to be invoked with <code>--coverage</code>.</p></div>
</div>
<details class="details_IpIu alert alert--info details_jERq" data-collapsed="true"><summary>Help:</summary><div><div class="collapsibleContent_Fd2D">If you are seeing coverage output such as...<pre tabindex="0" data-language="typescript">=============================== Coverage summary ===============================
Statements   : Unknown% ( 0/0 )
Branches     : Unknown% ( 0/0 )
Functions    : Unknown% ( 0/0 )
Lines        : Unknown% ( 0/0 )
================================================================================
Jest: Coverage data for global was not found.</pre>

<p>Most likely your glob patterns are not matching any files. Refer to the <a href="https://github.com/micromatch/micromatch" target="_blank" rel="noopener noreferrer">micromatch</a> documentation to ensure your globs are compatible.</p>
</div></div></details><h3 class="anchor anchorWithStickyNavbar_JmGV" id="coveragedirectory-string">
<code>coverageDirectory</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>The directory where Jest should output its coverage files.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="coveragepathignorepatterns-arraystring">
<code>coveragePathIgnorePatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["/node_modules/"]</code></p>
<p>An array of regexp pattern strings that are matched against all file paths before executing the test. If the file path matches any of the patterns, coverage information will be skipped.</p>
<p>These pattern strings match against the full path. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: <code>["&lt;rootDir&gt;/build/", "&lt;rootDir&gt;/node_modules/"]</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="coverageprovider-string">
<code>coverageProvider</code> [string]</h3>
<p>Indicates which provider should be used to instrument code for coverage. Allowed values are <code>babel</code> (default) or <code>v8</code>.</p>
<p>Note that using <code>v8</code> is considered experimental. This uses V8's builtin code coverage rather than one based on Babel. It is not as well tested, and it has also improved in the last few releases of Node. Using the latest versions of node (v14 at the time of this writing) will yield better results.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="coveragereporters-arraystring--string-options">
<code>coverageReporters</code> [array&lt;string | [string, options]&gt;]</h3>
<p>Default: <code>["clover", "json", "lcov", "text"]</code></p>
<p>A list of reporter names that Jest uses when writing coverage reports. Any <a href="https://github.com/istanbuljs/istanbuljs/tree/master/packages/istanbul-reports/lib" target="_blank" rel="noopener noreferrer">istanbul reporter</a> can be used.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Setting this option overwrites the default values. Add <code>"text"</code> or <code>"text-summary"</code> to see a coverage summary in the console output.</p></div>
</div>
<p>Additional options can be passed using the tuple form. For example, you may hide coverage report lines for all fully-covered files:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  coverageReporters: ['clover', 'json', 'lcov', ['text', {skipFull: true}]],
};

export default config;</pre>

</div>
</div>
</div>
<p>For more information about the options object shape refer to <code>CoverageReporterWithOptions</code> type in the <a href="https://github.com/facebook/jest/tree/main/packages/jest-types/src/Config.ts" target="_blank" rel="noopener noreferrer">type definitions</a>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="coveragethreshold-object">
<code>coverageThreshold</code> [object]</h3>
<p>Default: <code>undefined</code></p>
<p>This will be used to configure minimum threshold enforcement for coverage results. Thresholds can be specified as <code>global</code>, as a <a href="https://github.com/isaacs/node-glob#glob-primer" target="_blank" rel="noopener noreferrer">glob</a>, and as a directory or file path. If thresholds aren't met, jest will fail. Thresholds specified as a positive number are taken to be the minimum percentage required. Thresholds specified as a negative number represent the maximum number of uncovered entities allowed.</p>
<p>For example, with the following configuration jest will fail if there is less than 80% branch, line, and function coverage, or if there are more than 10 uncovered statements:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: -10,
    },
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: -10,
    },
  },
};

export default config;</pre>

</div>
</div>
</div>
<p>If globs or paths are specified alongside <code>global</code>, coverage data for matching paths will be subtracted from overall coverage and thresholds will be applied independently. Thresholds for globs are applied to all files matching the glob. If the file specified by path is not found, an error is returned.</p>
<p>For example, with the following configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  coverageThreshold: {
    global: {
      branches: 50,
      functions: 50,
      lines: 50,
      statements: 50,
    },
    './src/components/': {
      branches: 40,
      statements: 40,
    },
    './src/reducers/**/*.js': {
      statements: 90,
    },
    './src/api/very-important-module.js': {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100,
    },
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  coverageThreshold: {
    global: {
      branches: 50,
      functions: 50,
      lines: 50,
      statements: 50,
    },
    './src/components/': {
      branches: 40,
      statements: 40,
    },
    './src/reducers/**/*.js': {
      statements: 90,
    },
    './src/api/very-important-module.js': {
      branches: 100,
      functions: 100,
      lines: 100,
      statements: 100,
    },
  },
};

export default config;</pre>

</div>
</div>
</div>
<p>Jest will fail if:</p>
<ul>
<li>The <code>./src/components</code> directory has less than 40% branch or statement coverage.</li>
<li>One of the files matching the <code>./src/reducers/**/*.js</code> glob has less than 90% statement coverage.</li>
<li>The <code>./src/api/very-important-module.js</code> file has less than 100% coverage.</li>
<li>Every remaining file combined has less than 50% coverage (<code>global</code>).</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="dependencyextractor-string">
<code>dependencyExtractor</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>This option allows the use of a custom dependency extractor. It must be a node module that exports an object with an <code>extract</code> function. E.g.:</p>
<pre tabindex="0" data-language="typescript">const crypto = require('crypto');
const fs = require('fs');

module.exports = {
  extract(code, filePath, defaultExtract) {
    const deps = defaultExtract(code, filePath);
    // Scan the file and add dependencies in `deps` (which is a `Set`)
    return deps;
  },
  getCacheKey() {
    return crypto
      .createHash('md5')
      .update(fs.readFileSync(__filename))
      .digest('hex');
  },
};</pre>

<p>The <code>extract</code> function should return an iterable (<code>Array</code>, <code>Set</code>, etc.) with the dependencies found in the code.</p>
<p>That module can also contain a <code>getCacheKey</code> function to generate a cache key to determine if the logic has changed and any cached artifacts relying on it should be discarded.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="displayname-string-object">
<code>displayName</code> [string, object]</h3>
<p>default: <code>undefined</code></p>
<p>Allows for a label to be printed alongside a test while it is running. This becomes more useful in multi-project repositories where there can be many jest configuration files. This visually tells which project a test belongs to.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  displayName: 'CLIENT',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  displayName: 'CLIENT',
};

export default config;</pre>

</div>
</div>
</div>
<p>Alternatively, an object with the properties <code>name</code> and <code>color</code> can be passed. This allows for a custom configuration of the background color of the displayName. <code>displayName</code> defaults to white when its value is a string. Jest uses <a href="https://github.com/chalk/chalk" target="_blank" rel="noopener noreferrer"><code>chalk</code></a> to provide the color. As such, all of the valid options for colors supported by <code>chalk</code> are also supported by Jest.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  displayName: {
    name: 'CLIENT',
    color: 'blue',
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  displayName: {
    name: 'CLIENT',
    color: 'blue',
  },
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="errorondeprecated-boolean">
<code>errorOnDeprecated</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Make calling deprecated APIs throw helpful error messages. Useful for easing the upgrade process.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="extensionstotreatasesm-arraystring">
<code>extensionsToTreatAsEsm</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>Jest will run <code>.mjs</code> and <code>.js</code> files with nearest <code>package.json</code>'s <code>type</code> field set to <code>module</code> as ECMAScript Modules. If you have any other files that should run with native ESM, you need to specify their file extension here.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  extensionsToTreatAsEsm: ['.ts'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  extensionsToTreatAsEsm: ['.ts'],
};

export default config;</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-caution alert alert--warning admonition_uH4V">
<div class="admonitionHeading_P5_N">
caution</div>
<div class="admonitionContent_yySL"><p>Jest's ESM support is still experimental, see <a href="ecmascript-modules.html">its docs for more details</a>.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="faketimers-object">
<code>fakeTimers</code> [object]</h3>
<p>Default: <code>{}</code></p>
<p>The fake timers may be useful when a piece of code sets a long timeout that we don't want to wait for in a test. For additional details see <a href="timer-mocks.html">Fake Timers guide</a> and <a href="jest-object.html#fake-timers">API documentation</a>.</p>
<p>This option provides the default configuration of fake timers for all tests. Calling <code>jest.useFakeTimers()</code> in a test file will use these options or will override them if a configuration object is passed. For example, you can tell Jest to keep the original implementation of <code>process.nextTick()</code> and adjust the limit of recursive timers that will be run:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  fakeTimers: {
    doNotFake: ['nextTick'],
    timerLimit: 1000,
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  fakeTimers: {
    doNotFake: ['nextTick'],
    timerLimit: 1000,
  },
};

export default config;</pre>

</div>
</div>
</div>
<pre tabindex="0" data-language="typescript">// install fake timers for this file using the options from Jest configuration
jest.useFakeTimers();

test('increase the limit of recursive timers for this and following tests', () =&gt; {
  jest.useFakeTimers({timerLimit: 5000});
  // ...
});</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">fakeTime.test.js</div>

</div>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL">
<p>Instead of including <code>jest.useFakeTimers()</code> in each test file, you can enable fake timers globally for all tests in your Jest configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  fakeTimers: {
    enableGlobally: true,
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  fakeTimers: {
    enableGlobally: true,
  },
};

export default config;</pre>

</div>
</div>
</div>
</div>
</div>
<p>Configuration options:</p>
<pre tabindex="0" data-language="typescript">type FakeableAPI =
  | 'Date'
  | 'hrtime'
  | 'nextTick'
  | 'performance'
  | 'queueMicrotask'
  | 'requestAnimationFrame'
  | 'cancelAnimationFrame'
  | 'requestIdleCallback'
  | 'cancelIdleCallback'
  | 'setImmediate'
  | 'clearImmediate'
  | 'setInterval'
  | 'clearInterval'
  | 'setTimeout'
  | 'clearTimeout';

type ModernFakeTimersConfig = {
  /**
   * If set to `true` all timers will be advanced automatically by 20 milliseconds
   * every 20 milliseconds. A custom time delta may be provided by passing a number.
   * The default is `false`.
   */
  advanceTimers?: boolean | number;
  /**
   * List of names of APIs that should not be faked. The default is `[]`, meaning
   * all APIs are faked.
   */
  doNotFake?: Array&lt;FakeableAPI&gt;;
  /** Whether fake timers should be enabled for all test files. The default is `false`. */
  enableGlobally?: boolean;
  /**
   * Use the old fake timers implementation instead of one backed by `@sinonjs/fake-timers`.
   * The default is `false`.
   */
  legacyFakeTimers?: boolean;
  /** Sets current system time to be used by fake timers. The default is `Date.now()`. */
  now?: number;
  /** Maximum number of recursive timers that will be run. The default is `100_000` timers. */
  timerLimit?: number;
};</pre>

<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
Legacy Fake Timers</div>
<div class="admonitionContent_yySL">
<p>For some reason you might have to use legacy implementation of fake timers. Here is how to enable it globally (additional options are not supported):</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  fakeTimers: {
    enableGlobally: true,
    legacyFakeTimers: true,
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  fakeTimers: {
    enableGlobally: true,
    legacyFakeTimers: true,
  },
};

export default config;</pre>

</div>
</div>
</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="forcecoveragematch-arraystring">
<code>forceCoverageMatch</code> [array&lt;string&gt;]</h3>
<p>Default: <code>['']</code></p>
<p>Test files are normally ignored from collecting code coverage. With this option, you can overwrite this behavior and include otherwise ignored files in code coverage.</p>
<p>For example, if you have tests in source files named with <code>.t.js</code> extension as following:</p>
<pre tabindex="0" data-language="typescript">export function sum(a, b) {
  return a + b;
}

if (process.env.NODE_ENV === 'test') {
  test('sum', () =&gt; {
    expect(sum(1, 2)).toBe(3);
  });
}</pre>
<div class="language-javascript codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">sum.t.js</div>

</div>
<p>You can collect coverage from those files with setting <code>forceCoverageMatch</code>.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  forceCoverageMatch: ['**/*.t.js'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  forceCoverageMatch: ['**/*.t.js'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="globals-object">
<code>globals</code> [object]</h3>
<p>Default: <code>{}</code></p>
<p>A set of global variables that need to be available in all test environments.</p>
<p>For example, the following would create a global <code>__DEV__</code> variable set to <code>true</code> in all test environments:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  globals: {
    __DEV__: true,
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  globals: {
    __DEV__: true,
  },
};

export default config;</pre>

</div>
</div>
</div>
<p>Note that, if you specify a global reference value (like an object or array) here, and some code mutates that value in the midst of running a test, that mutation will <em>not</em> be persisted across test runs for other test files. In addition, the <code>globals</code> object must be json-serializable, so it can't be used to specify global functions. For that, you should use <code>setupFiles</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="globalsetup-string">
<code>globalSetup</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>This option allows the use of a custom global setup module, which must export a function (it can be sync or async). The function will be triggered once before all test suites and it will receive two arguments: Jest's <a href="https://github.com/facebook/jest/blob/main/packages/jest-types/src/Config.ts#L282" target="_blank" rel="noopener noreferrer"><code>globalConfig</code></a> and <a href="https://github.com/facebook/jest/blob/main/packages/jest-types/src/Config.ts#L347" target="_blank" rel="noopener noreferrer"><code>projectConfig</code></a>.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL">
<p>A global setup module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.</p>
<p>Any global variables that are defined through <code>globalSetup</code> can only be read in <code>globalTeardown</code>. You cannot retrieve globals defined here in your test suites.</p>
<p>While code transformation is applied to the linked setup-file, Jest will <strong>not</strong> transform any code in <code>node_modules</code>. This is due to the need to load the actual transformers (e.g. <code>babel</code> or <code>typescript</code>) to perform transformation.</p>
</div>
</div>
<pre tabindex="0" data-language="typescript">module.exports = async function (globalConfig, projectConfig) {
  console.log(globalConfig.testPathPattern);
  console.log(projectConfig.cache);

  // Set reference to mongod in order to close the server during teardown.
  globalThis.__MONGOD__ = mongod;
};</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">setup.js</div>

</div>
<pre tabindex="0" data-language="typescript">module.exports = async function (globalConfig, projectConfig) {
  console.log(globalConfig.testPathPattern);
  console.log(projectConfig.cache);

  await globalThis.__MONGOD__.stop();
};</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">teardown.js</div>

</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="globalteardown-string">
<code>globalTeardown</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>This option allows the use of a custom global teardown module which must export a function (it can be sync or async). The function will be triggered once after all test suites and it will receive two arguments: Jest's <a href="https://github.com/facebook/jest/blob/main/packages/jest-types/src/Config.ts#L282" target="_blank" rel="noopener noreferrer"><code>globalConfig</code></a> and <a href="https://github.com/facebook/jest/blob/main/packages/jest-types/src/Config.ts#L347" target="_blank" rel="noopener noreferrer"><code>projectConfig</code></a>.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL">
<p>A global teardown module configured in a project (using multi-project runner) will be triggered only when you run at least one test from this project.</p>
<p>The same caveat concerning transformation of <code>node_modules</code> as for <code>globalSetup</code> applies to <code>globalTeardown</code>.</p>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="haste-object">
<code>haste</code> [object]</h3>
<p>Default: <code>undefined</code></p>
<p>This will be used to configure the behavior of <code>jest-haste-map</code>, Jest's internal file crawler/cache system. The following options are supported:</p>
<pre tabindex="0" data-language="typescript">type HasteConfig = {
  /** Whether to hash files using SHA-1. */
  computeSha1?: boolean;
  /** The platform to use as the default, e.g. 'ios'. */
  defaultPlatform?: string | null;
  /** Force use of Node's `fs` APIs rather than shelling out to `find` */
  forceNodeFilesystemAPI?: boolean;
  /**
   * Whether to follow symlinks when crawling for files.
   *   This options cannot be used in projects which use watchman.
   *   Projects with `watchman` set to true will error if this option is set to true.
   */
  enableSymlinks?: boolean;
  /** Path to a custom implementation of Haste. */
  hasteImplModulePath?: string;
  /** All platforms to target, e.g ['ios', 'android']. */
  platforms?: Array&lt;string&gt;;
  /** Whether to throw on error on module collision. */
  throwOnModuleCollision?: boolean;
  /** Custom HasteMap module */
  hasteMapModulePath?: string;
  /** Whether to retain all files, allowing e.g. search for tests in `node_modules`. */
  retainAllFiles?: boolean;
};</pre>

<h3 class="anchor anchorWithStickyNavbar_JmGV" id="injectglobals-boolean">
<code>injectGlobals</code> [boolean]</h3>
<p>Default: <code>true</code></p>
<p>Insert Jest's globals (<code>expect</code>, <code>test</code>, <code>describe</code>, <code>beforeEach</code> etc.) into the global environment. If you set this to <code>false</code>, you should import from <code>@jest/globals</code>, e.g.</p>
<pre tabindex="0" data-language="typescript">import {expect, jest, test} from '@jest/globals';

jest.useFakeTimers();

test('some test', () =&gt; {
  expect(Date.now()).toBe(0);
});</pre>

<div class="theme-admonition theme-admonition-note alert alert--secondary admonition_uH4V">
<div class="admonitionHeading_P5_N">
note</div>
<div class="admonitionContent_yySL"><p>This option is only supported using the default <code>jest-circus</code> test runner.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="maxconcurrency-number">
<code>maxConcurrency</code> [number]</h3>
<p>Default: <code>5</code></p>
<p>A number limiting the number of tests that are allowed to run at the same time when using <code>test.concurrent</code>. Any test above this limit will be queued and executed once a slot is released.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="maxworkers-number--string">
<code>maxWorkers</code> [number | string]</h3>
<p>Specifies the maximum number of workers the worker-pool will spawn for running tests. In single run mode, this defaults to the number of the cores available on your machine minus one for the main thread. In watch mode, this defaults to half of the available cores on your machine to ensure Jest is unobtrusive and does not grind your machine to a halt. It may be useful to adjust this in resource limited environments like CIs but the defaults should be adequate for most use-cases.</p>
<p>For environments with variable CPUs available, you can use percentage based configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  maxWorkers: '50%',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  maxWorkers: '50%',
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="moduledirectories-arraystring">
<code>moduleDirectories</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["node_modules"]</code></p>
<p>An array of directory names to be searched recursively up from the requiring module's location. Setting this option will <em>override</em> the default, if you wish to still search <code>node_modules</code> for packages include it along with any other options:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  moduleDirectories: ['node_modules', 'bower_components'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  moduleDirectories: ['node_modules', 'bower_components'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="modulefileextensions-arraystring">
<code>moduleFileExtensions</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["js", "mjs", "cjs", "jsx", "ts", "tsx", "json", "node"]</code></p>
<p>An array of file extensions your modules use. If you require modules without specifying a file extension, these are the extensions Jest will look for, in left-to-right order.</p>
<p>We recommend placing the extensions most commonly used in your project on the left, so if you are using TypeScript, you may want to consider moving "ts" and/or "tsx" to the beginning of the array.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="modulenamemapper-objectstring-string--arraystring">
<code>moduleNameMapper</code> [object&lt;string, string | array&lt;string&gt;&gt;]</h3>
<p>Default: <code>null</code></p>
<p>A map from regular expressions to module names or to arrays of module names that allow to stub out resources, like images or styles with a single module.</p>
<p>Modules that are mapped to an alias are unmocked by default, regardless of whether automocking is enabled or not.</p>
<p>Use <code>&lt;rootDir&gt;</code> string token to refer to <a href="#rootdir-string"><code>rootDir</code></a> value if you want to use file paths.</p>
<p>Additionally, you can substitute captured regex groups using numbered backreferences.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  moduleNameMapper: {
    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',
    '^[./a-zA-Z0-9$_-]+\\.png$': '&lt;rootDir&gt;/RelativeImageStub.js',
    'module_name_(.*)': '&lt;rootDir&gt;/substituted_module_$1.js',
    'assets/(.*)': [
      '&lt;rootDir&gt;/images/$1',
      '&lt;rootDir&gt;/photos/$1',
      '&lt;rootDir&gt;/recipes/$1',
    ],
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  moduleNameMapper: {
    '^image![a-zA-Z0-9$_-]+$': 'GlobalImageStub',
    '^[./a-zA-Z0-9$_-]+\\.png$': '&lt;rootDir&gt;/RelativeImageStub.js',
    'module_name_(.*)': '&lt;rootDir&gt;/substituted_module_$1.js',
    'assets/(.*)': [
      '&lt;rootDir&gt;/images/$1',
      '&lt;rootDir&gt;/photos/$1',
      '&lt;rootDir&gt;/recipes/$1',
    ],
  },
};

export default config;</pre>

</div>
</div>
</div>
<p>The order in which the mappings are defined matters. Patterns are checked one by one until one fits. The most specific rule should be listed first. This is true for arrays of module names as well.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>If you provide module names without boundaries <code>^$</code> it may cause hard to spot errors. E.g. <code>relay</code> will replace all modules which contain <code>relay</code> as a substring in its name: <code>relay</code>, <code>react-relay</code> and <code>graphql-relay</code> will all be pointed to your stub.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="modulepathignorepatterns-arraystring">
<code>modulePathIgnorePatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>An array of regexp pattern strings that are matched against all module paths before those paths are to be considered 'visible' to the module loader. If a given module's path matches any of the patterns, it will not be <code>require()</code>-able in the test environment.</p>
<p>These pattern strings match against the full path. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  modulePathIgnorePatterns: ['&lt;rootDir&gt;/build/'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  modulePathIgnorePatterns: ['&lt;rootDir&gt;/build/'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="modulepaths-arraystring">
<code>modulePaths</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>An alternative API to setting the <code>NODE_PATH</code> env variable, <code>modulePaths</code> is an array of absolute paths to additional locations to search when resolving modules. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  modulePaths: ['&lt;rootDir&gt;/app/'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  modulePaths: ['&lt;rootDir&gt;/app/'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="notify-boolean">
<code>notify</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Activates native OS notifications for test results. To display the notifications Jest needs <a href="https://github.com/mikaelbr/node-notifier" target="_blank" rel="noopener noreferrer"><code>node-notifier</code></a> package, which must be installed additionally:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">npm</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">Yarn</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">npm install --save-dev node-notifier</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">yarn add --dev node-notifier</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL">
<p>On macOS, remember to allow notifications from <code>terminal-notifier</code> under System Preferences &gt; Notifications &amp; Focus.</p>
<p>On Windows, <code>node-notifier</code> creates a new start menu entry on the first use and not display the notification. Notifications will be properly displayed on subsequent runs.</p>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="notifymode-string">
<code>notifyMode</code> [string]</h3>
<p>Default: <code>failure-change</code></p>
<p>Specifies notification mode. Requires <code>notify: true</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_JmGV" id="modes">Modes</h4>
<ul>
<li>
<code>always</code>: always send a notification.</li>
<li>
<code>failure</code>: send a notification when tests fail.</li>
<li>
<code>success</code>: send a notification when tests pass.</li>
<li>
<code>change</code>: send a notification when the status changed.</li>
<li>
<code>success-change</code>: send a notification when tests pass or once when it fails.</li>
<li>
<code>failure-change</code>: send a notification when tests fail or once when it passes.</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="preset-string">
<code>preset</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>A preset that is used as a base for Jest's configuration. A preset should point to an npm module that has a <code>jest-preset.json</code>, <code>jest-preset.js</code>, <code>jest-preset.cjs</code> or <code>jest-preset.mjs</code> file at the root.</p>
<p>For example, this preset <code>foo-bar/jest-preset.js</code> will be configured as follows:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  preset: 'foo-bar',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  preset: 'foo-bar',
};

export default config;</pre>

</div>
</div>
</div>
<p>Presets may also be relative to filesystem paths:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  preset: './node_modules/foo-bar/jest-preset.js',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  preset: './node_modules/foo-bar/jest-preset.js',
};

export default config;</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>Note that if you also have specified <a href="#rootdir-string"><code>rootDir</code></a> that the resolution of this file will be relative to that root directory.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="prettierpath-string">
<code>prettierPath</code> [string]</h3>
<p>Default: <code>'prettier'</code></p>
<p>Sets the path to the <a href="https://prettier.io/" target="_blank" rel="noopener noreferrer"><code>prettier</code></a> node module used to update inline snapshots.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="projects-arraystring--projectconfig">
<code>projects</code> [array&lt;string | ProjectConfig&gt;]</h3>
<p>Default: <code>undefined</code></p>
<p>When the <code>projects</code> configuration is provided with an array of paths or glob patterns, Jest will run tests in all of the specified projects at the same time. This is great for monorepos or when working on multiple projects at the same time.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  projects: ['&lt;rootDir&gt;', '&lt;rootDir&gt;/examples/*'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  projects: ['&lt;rootDir&gt;', '&lt;rootDir&gt;/examples/*'],
};

export default config;</pre>

</div>
</div>
</div>
<p>This example configuration will run Jest in the root directory as well as in every folder in the examples directory. You can have an unlimited amount of projects running in the same Jest instance.</p>
<p>The projects feature can also be used to run multiple configurations or multiple <a href="#runner-string">runners</a>. For this purpose, you can pass an array of configuration objects. For example, to run both tests and ESLint (via <a href="https://github.com/jest-community/jest-runner-eslint" target="_blank" rel="noopener noreferrer">jest-runner-eslint</a>) in the same invocation of Jest:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  projects: [
    {
      displayName: 'test',
    },
    {
      displayName: 'lint',
      runner: 'jest-runner-eslint',
      testMatch: ['&lt;rootDir&gt;/**/*.js'],
    },
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  projects: [
    {
      displayName: 'test',
    },
    {
      displayName: 'lint',
      runner: 'jest-runner-eslint',
      testMatch: ['&lt;rootDir&gt;/**/*.js'],
    },
  ],
};

export default config;</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>When using multi-project runner, it's recommended to add a <code>displayName</code> for each project. This will show the <code>displayName</code> of a project next to its tests.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="reporters-arraymodulename--modulename-options">
<code>reporters</code> [array&lt;moduleName | [moduleName, options]&gt;]</h3>
<p>Default: <code>undefined</code></p>
<p>Use this configuration option to add reporters to Jest. It must be a list of reporter names, additional options can be passed to a reporter using the tuple form:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  reporters: [
    'default',
    ['&lt;rootDir&gt;/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  reporters: [
    'default',
    ['&lt;rootDir&gt;/custom-reporter.js', {banana: 'yes', pineapple: 'no'}],
  ],
};

export default config;</pre>

</div>
</div>
</div>
<h4 class="anchor anchorWithStickyNavbar_JmGV" id="default-reporter">Default Reporter</h4>
<p>If custom reporters are specified, the default Jest reporter will be overridden. If you wish to keep it, <code>'default'</code> must be passed as a reporters name:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  reporters: [
    'default',
    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  reporters: [
    'default',
    ['jest-junit', {outputDirectory: 'reports', outputName: 'report.xml'}],
  ],
};

export default config;</pre>

</div>
</div>
</div>
<h4 class="anchor anchorWithStickyNavbar_JmGV" id="github-actions-reporter">GitHub Actions Reporter</h4>
<p>If included in the list, the built-in GitHub Actions Reporter will annotate changed files with test failure messages:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  reporters: ['default', 'github-actions'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  reporters: ['default', 'github-actions'],
};

export default config;</pre>

</div>
</div>
</div>
<h4 class="anchor anchorWithStickyNavbar_JmGV" id="summary-reporter">Summary Reporter</h4>
<p>Summary reporter prints out summary of all tests. It is a part of default reporter, hence it will be enabled if <code>'default'</code> is included in the list. For instance, you might want to use it as stand-alone reporter instead of the default one, or together with <a href="https://github.com/rickhanlonii/jest-silent-reporter" target="_blank" rel="noopener noreferrer">Silent Reporter</a>:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  reporters: ['jest-silent-reporter', 'summary'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  reporters: ['jest-silent-reporter', 'summary'],
};

export default config;</pre>

</div>
</div>
</div>
<h4 class="anchor anchorWithStickyNavbar_JmGV" id="custom-reporters">Custom Reporters</h4>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Hungry for reporters? Take a look at long list of <a href="https://github.com/jest-community/awesome-jest/blob/main/README.md#reporters" target="_blank" rel="noopener noreferrer">awesome reporters</a> from Awesome Jest.</p></div>
</div>
<p>Custom reporter module must export a class that takes <code>globalConfig</code>, <code>reporterOptions</code> and <code>reporterContext</code> as constructor arguments and implements at least <code>onRunComplete()</code> method (for the full list of methods and argument types see <code>Reporter</code> interface in <a href="https://github.com/facebook/jest/blob/main/packages/jest-reporters/src/types.ts" target="_blank" rel="noopener noreferrer">packages/jest-reporters/src/types.ts</a>):</p>
<pre tabindex="0" data-language="typescript">class CustomReporter {
  constructor(globalConfig, reporterOptions, reporterContext) {
    this._globalConfig = globalConfig;
    this._options = reporterOptions;
    this._context = reporterContext;
  }

  onRunComplete(testContexts, results) {
    console.log('Custom reporter output:');
    console.log('global config: ', this._globalConfig);
    console.log('options for this reporter from Jest config: ', this._options);
    console.log('reporter context passed from test scheduler: ', this._context);
  }

  // Optionally, reporters can force Jest to exit with non zero code by returning
  // an `Error` from `getLastError()` method.
  getLastError() {
    if (this._shouldFail) {
      return new Error('Custom error reported!');
    }
  }
}

module.exports = CustomReporter;</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">custom-reporter.js</div>

</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="resetmocks-boolean">
<code>resetMocks</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Automatically reset mock state before every test. Equivalent to calling <a href="jest-object.html#jestresetallmocks"><code>jest.resetAllMocks()</code></a> before each test. This will lead to any mocks having their fake implementations removed but does not restore their initial implementation.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="resetmodules-boolean">
<code>resetModules</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>By default, each test file gets its own independent module registry. Enabling <code>resetModules</code> goes a step further and resets the module registry before running each individual test. This is useful to isolate modules for every test so that the local module state doesn't conflict between tests. This can be done programmatically using <a href="jest-object.html#jestresetmodules"><code>jest.resetModules()</code></a>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="resolver-string">
<code>resolver</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>This option allows the use of a custom resolver. This resolver must be a module that exports <em>either</em>:</p>
<ol>
<li>a function expecting a string as the first argument for the path to resolve and an options object as the second argument. The function should either return a path to the module that should be resolved or throw an error if the module can't be found. <em>or</em>
</li>
<li>an object containing <code>async</code> and/or <code>sync</code> properties. The <code>sync</code> property should be a function with the shape explained above, and the <code>async</code> property should also be a function that accepts the same arguments, but returns a promise which resolves with the path to the module or rejects with an error.</li>
</ol>
<p>The options object provided to resolvers has the shape:</p>
<pre tabindex="0" data-language="typescript">type ResolverOptions = {
  /** Directory to begin resolving from. */
  basedir: string;
  /** List of export conditions. */
  conditions?: Array&lt;string&gt;;
  /** Instance of default resolver. */
  defaultResolver: (path: string, options: ResolverOptions) =&gt; string;
  /** List of file extensions to search in order. */
  extensions?: Array&lt;string&gt;;
  /** List of directory names to be looked up for modules recursively. */
  moduleDirectory?: Array&lt;string&gt;;
  /** List of `require.paths` to use if nothing is found in `node_modules`. */
  paths?: Array&lt;string&gt;;
  /** Allows transforming parsed `package.json` contents. */
  packageFilter?: (pkg: PackageJSON, file: string, dir: string) =&gt; PackageJSON;
  /** Allows transforms a path within a package. */
  pathFilter?: (pkg: PackageJSON, path: string, relativePath: string) =&gt; string;
  /** Current root directory. */
  rootDir?: string;
};</pre>

<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>The <code>defaultResolver</code> passed as an option is the Jest default resolver which might be useful when you write your custom one. It takes the same arguments as your custom synchronous one, e.g. <code>(path, options)</code> and returns a string or throws.</p></div>
</div>
<p>For example, if you want to respect Browserify's <a href="https://github.com/browserify/browserify-handbook/blob/master/readme.markdown#browser-field" target="_blank" rel="noopener noreferrer"><code>"browser"</code> field</a>, you can use the following resolver:</p>
<pre tabindex="0" data-language="typescript">const browserResolve = require('browser-resolve');

module.exports = browserResolve.sync;</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">resolver.js</div>

</div>
<p>And add it to Jest configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  resolver: '&lt;rootDir&gt;/resolver.js',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  resolver: '&lt;rootDir&gt;/resolver.js',
};

export default config;</pre>

</div>
</div>
</div>
<p>By combining <code>defaultResolver</code> and <code>packageFilter</code> we can implement a <code>package.json</code> "pre-processor" that allows us to change how the default resolver will resolve modules. For example, imagine we want to use the field <code>"module"</code> if it is present, otherwise fallback to <code>"main"</code>:</p>
<pre tabindex="0" data-language="typescript">module.exports = (path, options) =&gt; {
  // Call the defaultResolver, so we leverage its cache, error handling, etc.
  return options.defaultResolver(path, {
    ...options,
    // Use packageFilter to process parsed `package.json` before the resolution (see https://www.npmjs.com/package/resolve#resolveid-opts-cb)
    packageFilter: pkg =&gt; {
      return {
        ...pkg,
        // Alter the value of `main` before resolving the package
        main: pkg.module || pkg.main,
      };
    },
  });
};</pre>

<h3 class="anchor anchorWithStickyNavbar_JmGV" id="restoremocks-boolean">
<code>restoreMocks</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Automatically restore mock state and implementation before every test. Equivalent to calling <a href="jest-object.html#jestrestoreallmocks"><code>jest.restoreAllMocks()</code></a> before each test. This will lead to any mocks having their fake implementations removed and restores their initial implementation.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="rootdir-string">
<code>rootDir</code> [string]</h3>
<p>Default: The root of the directory containing your Jest <a href="#">config file</a> <em>or</em> the <code>package.json</code> <em>or</em> the <a href="http://en.wikipedia.org/wiki/Pwd" target="_blank" rel="noopener noreferrer"><code>pwd</code></a> if no <code>package.json</code> is found</p>
<p>The root directory that Jest should scan for tests and modules within. If you put your Jest config inside your <code>package.json</code> and want the root directory to be the root of your repo, the value for this config param will default to the directory of the <code>package.json</code>.</p>
<p>Oftentimes, you'll want to set this to <code>'src'</code> or <code>'lib'</code>, corresponding to where in your repository the code is stored.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Using <code>'&lt;rootDir&gt;'</code> as a string token in any other path-based configuration settings will refer back to this value. For example, if you want a <a href="#setupfiles-array"><code>setupFiles</code></a> entry to point at the <code>some-setup.js</code> file at the root of the project, set its value to: <code>'&lt;rootDir&gt;/some-setup.js'</code>.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="roots-arraystring">
<code>roots</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["&lt;rootDir&gt;"]</code></p>
<p>A list of paths to directories that Jest should use to search for files in.</p>
<p>There are times where you only want Jest to search in a single sub-directory (such as cases where you have a <code>src/</code> directory in your repo), but prevent it from accessing the rest of the repo.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL">
<p>While <code>rootDir</code> is mostly used as a token to be re-used in other configuration options, <code>roots</code> is used by the internals of Jest to locate <strong>test files and source files</strong>. This applies also when searching for manual mocks for modules from <code>node_modules</code> (<code>__mocks__</code> will need to live in one of the <code>roots</code>).</p>
<p>By default, <code>roots</code> has a single entry <code>&lt;rootDir&gt;</code> but there are cases where you may want to have multiple roots within one project, for example <code>roots: ["&lt;rootDir&gt;/src/", "&lt;rootDir&gt;/tests/"]</code>.</p>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="runner-string">
<code>runner</code> [string]</h3>
<p>Default: <code>"jest-runner"</code></p>
<p>This option allows you to use a custom runner instead of Jest's default test runner. Examples of runners include:</p>
<ul>
<li><a href="https://github.com/jest-community/jest-runner-eslint" target="_blank" rel="noopener noreferrer"><code>jest-runner-eslint</code></a></li>
<li><a href="https://github.com/rogeliog/jest-runner-mocha" target="_blank" rel="noopener noreferrer"><code>jest-runner-mocha</code></a></li>
<li><a href="https://github.com/azz/jest-runner-tsc" target="_blank" rel="noopener noreferrer"><code>jest-runner-tsc</code></a></li>
<li><a href="https://github.com/keplersj/jest-runner-prettier" target="_blank" rel="noopener noreferrer"><code>jest-runner-prettier</code></a></li>
</ul>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>The <code>runner</code> property value can omit the <code>jest-runner-</code> prefix of the package name.</p></div>
</div>
<p>To write a test-runner, export a class with which accepts <code>globalConfig</code> in the constructor, and has a <code>runTests</code> method with the signature:</p>
<pre tabindex="0" data-language="typescript">async function runTests(
  tests: Array&lt;Test&gt;,
  watcher: TestWatcher,
  onStart: OnTestStart,
  onResult: OnTestSuccess,
  onFailure: OnTestFailure,
  options: TestRunnerOptions,
): Promise&lt;void&gt;;</pre>

<p>If you need to restrict your test-runner to only run in serial rather than being executed in parallel your class should have the property <code>isSerial</code> to be set as <code>true</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="sandboxinjectedglobals-arraystring">
<code>sandboxInjectedGlobals</code> [array&lt;string&gt;]</h3>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Renamed from <code>extraGlobals</code> in Jest 28.</p></div>
</div>
<p>Default: <code>undefined</code></p>
<p>Test files run inside a <a href="https://nodejs.org/api/vm.html" target="_blank" rel="noopener noreferrer">vm</a>, which slows calls to global context properties (e.g. <code>Math</code>). With this option you can specify extra properties to be defined inside the vm for faster lookups.</p>
<p>For example, if your tests call <code>Math</code> often, you can pass it by setting <code>sandboxInjectedGlobals</code>.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  sandboxInjectedGlobals: ['Math'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  sandboxInjectedGlobals: ['Math'],
};

export default config;</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-note alert alert--secondary admonition_uH4V">
<div class="admonitionHeading_P5_N">
note</div>
<div class="admonitionContent_yySL"><p>This option has no effect if you use <a href="ecmascript-modules.html">native ESM</a>.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="setupfiles-array">
<code>setupFiles</code> [array]</h3>
<p>Default: <code>[]</code></p>
<p>A list of paths to modules that run some code to configure or set up the testing environment. Each setupFile will be run once per test file. Since every test runs in its own environment, these scripts will be executed in the testing environment before executing <a href="#setupfilesafterenv-array"><code>setupFilesAfterEnv</code></a> and before the test code itself.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>If your setup script is a CJS module, it may export an async function. Jest will call the function and await its result. This might be useful to fetch some data asynchronously. If the file is an ESM module, simply use top-level await to achieve the same result.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="setupfilesafterenv-array">
<code>setupFilesAfterEnv</code> [array]</h3>
<p>Default: <code>[]</code></p>
<p>A list of paths to modules that run some code to configure or set up the testing framework before each test file in the suite is executed. Since <a href="#setupfiles-array"><code>setupFiles</code></a> executes before the test framework is installed in the environment, this script file presents you the opportunity of running some code immediately after the test framework has been installed in the environment but before the test code itself.</p>
<p>In other words, <code>setupFilesAfterEnv</code> modules are meant for code which is repeating in each test file. Having the test framework installed makes Jest <a href="api.html">globals</a>, <a href="jest-object.html"><code>jest</code> object</a> and <a href="expect.html"><code>expect</code></a> accessible in the modules. For example, you can add extra matchers from <a href="https://github.com/jest-community/jest-extended" target="_blank" rel="noopener noreferrer"><code>jest-extended</code></a> library or call <a href="setup-teardown.html">setup and teardown</a> hooks:</p>
<pre tabindex="0" data-language="typescript">const matchers = require('jest-extended');
expect.extend(matchers);

afterEach(() =&gt; {
  jest.useRealTimers();
});</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">setup-jest.js</div>

</div>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  setupFilesAfterEnv: ['&lt;rootDir&gt;/setup-jest.js'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  setupFilesAfterEnv: ['&lt;rootDir&gt;/setup-matchers.js'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="slowtestthreshold-number">
<code>slowTestThreshold</code> [number]</h3>
<p>Default: <code>5</code></p>
<p>The number of seconds after which a test is considered as slow and reported as such in the results.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="snapshotformat-object">
<code>snapshotFormat</code> [object]</h3>
<p>Default: <code>{escapeString: false, printBasicPrototype: false}</code></p>
<p>Allows overriding specific snapshot formatting options documented in the <a href="https://www.npmjs.com/package/pretty-format#usage-with-options" target="_blank" rel="noopener noreferrer">pretty-format readme</a>, with the exceptions of <code>compareKeys</code> and <code>plugins</code>. For example, this config would have the snapshot formatter not print a prefix for "Object" and "Array":</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  snapshotFormat: {
    printBasicPrototype: false,
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  snapshotFormat: {
    printBasicPrototype: false,
  },
};

export default config;</pre>

</div>
</div>
</div>
<pre tabindex="0" data-language="typescript">test('does not show prototypes for object and array inline', () =&gt; {
  const object = {
    array: [{hello: 'Danger'}],
  };
  expect(object).toMatchInlineSnapshot(`
{
  "array": [
    {
      "hello": "Danger",
    },
  ],
}
    `);
});</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">some.test.js</div>

</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="snapshotresolver-string">
<code>snapshotResolver</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>The path to a module that can resolve test&lt;-&gt;snapshot path. This config option lets you customize where Jest stores snapshot files on disk.</p>
<pre tabindex="0" data-language="typescript">module.exports = {
  // resolves from test to snapshot path
  resolveSnapshotPath: (testPath, snapshotExtension) =&gt;
    testPath.replace('__tests__', '__snapshots__') + snapshotExtension,

  // resolves from snapshot to test path
  resolveTestPath: (snapshotFilePath, snapshotExtension) =&gt;
    snapshotFilePath
      .replace('__snapshots__', '__tests__')
      .slice(0, -snapshotExtension.length),

  // Example test path, used for preflight consistency check of the implementation above
  testPathForConsistencyCheck: 'some/__tests__/example.test.js',
};</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">custom-resolver.js</div>

</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="snapshotserializers-arraystring">
<code>snapshotSerializers</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>A list of paths to snapshot serializer modules Jest should use for snapshot testing.</p>
<p>Jest has default serializers for built-in JavaScript types, HTML elements (Jest 20.0.0+), ImmutableJS (Jest 20.0.0+) and for React elements. See <a href="tutorial-react-native.html#snapshot-test">snapshot test tutorial</a> for more information.</p>
<pre tabindex="0" data-language="typescript">module.exports = {
  serialize(val, config, indentation, depth, refs, printer) {
    return `Pretty foo: ${printer(val.foo)}`;
  },

  test(val) {
    return val &amp;&amp; Object.prototype.hasOwnProperty.call(val, 'foo');
  },
};</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">custom-serializer.js</div>

</div>
<p><code>printer</code> is a function that serializes a value using existing plugins.</p>
<p>Add <code>custom-serializer</code> to your Jest configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  snapshotSerializers: ['path/to/custom-serializer.js'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  snapshotSerializers: ['path/to/custom-serializer.js'],
};

export default config;</pre>

</div>
</div>
</div>
<p>Finally tests would look as follows:</p>
<pre tabindex="0" data-language="typescript">test(() =&gt; {
  const bar = {
    foo: {
      x: 1,
      y: 2,
    },
  };

  expect(bar).toMatchSnapshot();
});</pre>

<p>Rendered snapshot:</p>
<pre tabindex="0" data-language="typescript">Pretty foo: Object {
  "x": 1,
  "y": 2,
}</pre>

<p>To make a dependency explicit instead of implicit, you can call <a href="expect.html#expectaddsnapshotserializerserializer"><code>expect.addSnapshotSerializer</code></a> to add a module for an individual test file instead of adding its path to <code>snapshotSerializers</code> in Jest configuration.</p>
<p>More about serializers API can be found <a href="https://github.com/facebook/jest/tree/main/packages/pretty-format/README.md#serialize" target="_blank" rel="noopener noreferrer">here</a>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testenvironment-string">
<code>testEnvironment</code> [string]</h3>
<p>Default: <code>"node"</code></p>
<p>The test environment that will be used for testing. The default environment in Jest is a Node.js environment. If you are building a web app, you can use a browser-like environment through <a href="https://github.com/jsdom/jsdom" target="_blank" rel="noopener noreferrer"><code>jsdom</code></a> instead.</p>
<p>By adding a <code>@jest-environment</code> docblock at the top of the file, you can specify another environment to be used for all tests in that file:</p>
<pre tabindex="0" data-language="typescript">/**
 * @jest-environment jsdom
 */

test('use jsdom in this test file', () =&gt; {
  const element = document.createElement('div');
  expect(element).not.toBeNull();
});</pre>

<p>You can create your own module that will be used for setting up the test environment. The module must export a class with <code>setup</code>, <code>teardown</code> and <code>getVmContext</code> methods. You can also pass variables from this module to your test suites by assigning them to <code>this.global</code> object – this will make them available in your test suites as global variables. The constructor is passed <a href="https://github.com/facebook/jest/blob/491e7cb0f2daa8263caccc72d48bdce7ba759b11/packages/jest-types/src/Config.ts#L284" target="_blank" rel="noopener noreferrer">global config</a> and <a href="https://github.com/facebook/jest/blob/491e7cb0f2daa8263caccc72d48bdce7ba759b11/packages/jest-types/src/Config.ts#L349" target="_blank" rel="noopener noreferrer">project config</a> as its first argument, and <a href="https://github.com/facebook/jest/blob/491e7cb0f2daa8263caccc72d48bdce7ba759b11/packages/jest-environment/src/index.ts#L13" target="_blank" rel="noopener noreferrer"><code>testEnvironmentContext</code></a> as its second.</p>
<p>The class may optionally expose an asynchronous <code>handleTestEvent</code> method to bind to events fired by <a href="https://github.com/facebook/jest/tree/main/packages/jest-circus" target="_blank" rel="noopener noreferrer"><code>jest-circus</code></a>. Normally, <code>jest-circus</code> test runner would pause until a promise returned from <code>handleTestEvent</code> gets fulfilled, <strong>except for the next events</strong>: <code>start_describe_definition</code>, <code>finish_describe_definition</code>, <code>add_hook</code>, <code>add_test</code> or <code>error</code> (for the up-to-date list you can look at <a href="https://github.com/facebook/jest/tree/main/packages/jest-types/src/Circus.ts" target="_blank" rel="noopener noreferrer">SyncEvent type in the types definitions</a>). That is caused by backward compatibility reasons and <code>process.on('unhandledRejection', callback)</code> signature, but that usually should not be a problem for most of the use cases.</p>
<p>Any docblock pragmas in test files will be passed to the environment constructor and can be used for per-test configuration. If the pragma does not have a value, it will be present in the object with its value set to an empty string. If the pragma is not present, it will not be present in the object.</p>
<p>To use this class as your custom environment, refer to it by its full path within the project. For example, if your class is stored in <code>my-custom-environment.js</code> in some subfolder of your project, then the annotation might look like this:</p>
<pre tabindex="0" data-language="typescript">/**
 * @jest-environment ./src/test/my-custom-environment
 */</pre>

<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>TestEnvironment is sandboxed. Each test suite will trigger setup/teardown in their own TestEnvironment.</p></div>
</div>
<p>Example:</p>
<pre tabindex="0" data-language="typescript">// my-custom-environment
const NodeEnvironment = require('jest-environment-node').default;

class CustomEnvironment extends NodeEnvironment {
  constructor(config, context) {
    super(config, context);
    console.log(config.globalConfig);
    console.log(config.projectConfig);
    this.testPath = context.testPath;
    this.docblockPragmas = context.docblockPragmas;
  }

  async setup() {
    await super.setup();
    await someSetupTasks(this.testPath);
    this.global.someGlobalObject = createGlobalObject();

    // Will trigger if docblock contains @my-custom-pragma my-pragma-value
    if (this.docblockPragmas['my-custom-pragma'] === 'my-pragma-value') {
      // ...
    }
  }

  async teardown() {
    this.global.someGlobalObject = destroyGlobalObject();
    await someTeardownTasks();
    await super.teardown();
  }

  getVmContext() {
    return super.getVmContext();
  }

  async handleTestEvent(event, state) {
    if (event.name === 'test_start') {
      // ...
    }
  }
}

module.exports = CustomEnvironment;</pre>

<pre tabindex="0" data-language="typescript">// my-test-suite
/**
 * @jest-environment ./my-custom-environment
 */
let someGlobalObject;

beforeAll(() =&gt; {
  someGlobalObject = globalThis.someGlobalObject;
});</pre>

<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testenvironmentoptions-object">
<code>testEnvironmentOptions</code> [Object]</h3>
<p>Default: <code>{}</code></p>
<p>Test environment options that will be passed to the <code>testEnvironment</code>. The relevant options depend on the environment.</p>
<p>For example, in <code>jest-environment-jsdom</code>, you can override options given to <a href="https://github.com/jsdom/jsdom" target="_blank" rel="noopener noreferrer"><code>jsdom</code></a> such as <code>{html: "&lt;html lang="zh-cmn-Hant"&gt;&lt;/html&gt;", url: 'https://jestjs.io/', userAgent: "Agent/007"}</code>.</p>
<p>Both <code>jest-environment-jsdom</code> and <code>jest-environment-node</code> allow specifying <code>customExportConditions</code>, which allow you to control which versions of a library are loaded from <code>exports</code> in <code>package.json</code>. <code>jest-environment-jsdom</code> defaults to <code>['browser']</code>. <code>jest-environment-node</code> defaults to <code>['node', 'node-addons']</code>.</p>
<p>These options can also be passed in a docblock, similar to <code>testEnvironment</code>. Note that it must be parseable by <code>JSON.parse</code>. Example:</p>
<pre tabindex="0" data-language="typescript">/**
 * @jest-environment jsdom
 * @jest-environment-options {"url": "https://jestjs.io/"}
 */

test('use jsdom and set the URL in this test file', () =&gt; {
  expect(window.location.href).toBe('https://jestjs.io/');
});</pre>

<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testfailureexitcode-number">
<code>testFailureExitCode</code> [number]</h3>
<p>Default: <code>1</code></p>
<p>The exit code Jest returns on test failure.</p>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>This does not change the exit code in the case of Jest errors (e.g. invalid configuration).</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testmatch-arraystring">
<code>testMatch</code> [array&lt;string&gt;]</h3>
<p>(default: <code>[ "**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)" ]</code>)</p>
<p>The glob patterns Jest uses to detect test files. By default it looks for <code>.js</code>, <code>.jsx</code>, <code>.ts</code> and <code>.tsx</code> files inside of <code>__tests__</code> folders, as well as any files with a suffix of <code>.test</code> or <code>.spec</code> (e.g. <code>Component.test.js</code> or <code>Component.spec.js</code>). It will also find files called <code>test.js</code> or <code>spec.js</code>.</p>
<p>See the <a href="https://github.com/micromatch/micromatch" target="_blank" rel="noopener noreferrer">micromatch</a> package for details of the patterns you can specify.</p>
<p>See also <a href="#testregex-string--arraystring"><code>testRegex</code> [string | array&lt;string&gt;]</a>, but note that you cannot specify both options.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Each glob pattern is applied in the order they are specified in the config. For example <code>["!**/__fixtures__/**", "**/__tests__/**/*.js"]</code> will not exclude <code>__fixtures__</code> because the negation is overwritten with the second pattern. In order to make the negated glob work in this example it has to come after <code>**/__tests__/**/*.js</code>.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testpathignorepatterns-arraystring">
<code>testPathIgnorePatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["/node_modules/"]</code></p>
<p>An array of regexp pattern strings that are matched against all test paths before executing the test. If the test path matches any of the patterns, it will be skipped.</p>
<p>These pattern strings match against the full path. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: <code>["&lt;rootDir&gt;/build/", "&lt;rootDir&gt;/node_modules/"]</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testregex-string--arraystring">
<code>testRegex</code> [string | array&lt;string&gt;]</h3>
<p>Default: <code>(/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$</code></p>
<p>The pattern or patterns Jest uses to detect test files. By default it looks for <code>.js</code>, <code>.jsx</code>, <code>.ts</code> and <code>.tsx</code> files inside of <code>__tests__</code> folders, as well as any files with a suffix of <code>.test</code> or <code>.spec</code> (e.g. <code>Component.test.js</code> or <code>Component.spec.js</code>). It will also find files called <code>test.js</code> or <code>spec.js</code>. See also <a href="#testmatch-arraystring"><code>testMatch</code> [array&lt;string&gt;]</a>, but note that you cannot specify both options.</p>
<p>The following is a visualization of the default regex:</p>
<pre tabindex="0" data-language="typescript">├── __tests__
│   └── component.spec.js # test
│   └── anything # test
├── package.json # not test
├── foo.test.js # test
├── bar.spec.jsx # test
└── component.js # not test</pre>

<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p><code>testRegex</code> will try to detect test files using the <strong>absolute file path</strong>, therefore, having a folder with a name that matches it will run all the files as tests.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testresultsprocessor-string">
<code>testResultsProcessor</code> [string]</h3>
<p>Default: <code>undefined</code></p>
<p>This option allows the use of a custom results processor. This processor must be a node module that exports a function expecting an object with the following structure as the first argument and return it:</p>
<pre tabindex="0" data-language="typescript">{
  "success": boolean,
  "startTime": epoch,
  "numTotalTestSuites": number,
  "numPassedTestSuites": number,
  "numFailedTestSuites": number,
  "numRuntimeErrorTestSuites": number,
  "numTotalTests": number,
  "numPassedTests": number,
  "numFailedTests": number,
  "numPendingTests": number,
  "numTodoTests": number,
  "openHandles": Array&lt;Error&gt;,
  "testResults": [{
    "numFailingTests": number,
    "numPassingTests": number,
    "numPendingTests": number,
    "testResults": [{
      "title": string (message in it block),
      "status": "failed" | "pending" | "passed",
      "ancestorTitles": [string (message in describe blocks)],
      "failureMessages": [string],
      "numPassingAsserts": number,
      "location": {
        "column": number,
        "line": number
      },
      "duration": number | null
    },
    ...
    ],
    "perfStats": {
      "start": epoch,
      "end": epoch
    },
    "testFilePath": absolute path to test file,
    "coverage": {}
  },
  "testExecError:" (exists if there was a top-level failure) {
    "message": string
    "stack": string
  }
  ...
  ]
}</pre>

<p><code>testResultsProcessor</code> and <code>reporters</code> are very similar to each other. One difference is that a test result processor only gets called after all tests finished. Whereas a reporter has the ability to receive test results after individual tests and/or test suites are finished.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testrunner-string">
<code>testRunner</code> [string]</h3>
<p>Default: <code>jest-circus/runner</code></p>
<p>This option allows the use of a custom test runner. The default is <code>jest-circus</code>. A custom test runner can be provided by specifying a path to a test runner implementation.</p>
<p>The test runner module must export a function with the following signature:</p>
<pre tabindex="0" data-language="typescript">function testRunner(
  globalConfig: GlobalConfig,
  config: ProjectConfig,
  environment: Environment,
  runtime: Runtime,
  testPath: string,
): Promise&lt;TestResult&gt;;</pre>

<p>An example of such function can be found in our default <a href="https://github.com/facebook/jest/blob/main/packages/jest-jasmine2/src/index.ts" target="_blank" rel="noopener noreferrer">jasmine2 test runner package</a>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testsequencer-string">
<code>testSequencer</code> [string]</h3>
<p>Default: <code>@jest/test-sequencer</code></p>
<p>This option allows you to use a custom sequencer instead of Jest's default.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL"><p>Both <code>sort</code> and <code>shard</code> may optionally return a <code>Promise</code>.</p></div>
</div>
<p>For example, you may sort test paths alphabetically:</p>
<pre tabindex="0" data-language="typescript">const Sequencer = require('@jest/test-sequencer').default;

class CustomSequencer extends Sequencer {
  /**
   * Select tests for shard requested via --shard=shardIndex/shardCount
   * Sharding is applied before sorting
   */
  shard(tests, {shardIndex, shardCount}) {
    const shardSize = Math.ceil(tests.length / shardCount);
    const shardStart = shardSize * (shardIndex - 1);
    const shardEnd = shardSize * shardIndex;

    return [...tests]
      .sort((a, b) =&gt; (a.path &gt; b.path ? 1 : -1))
      .slice(shardStart, shardEnd);
  }

  /**
   * Sort test to determine order of execution
   * Sorting is applied after sharding
   */
  sort(tests) {
    // Test structure information
    // https://github.com/facebook/jest/blob/6b8b1404a1d9254e7d5d90a8934087a9c9899dab/packages/jest-runner/src/types.ts#L17-L21
    const copyTests = Array.from(tests);
    return copyTests.sort((testA, testB) =&gt; (testA.path &gt; testB.path ? 1 : -1));
  }
}

module.exports = CustomSequencer;</pre>
<div class="language-js codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">custom-sequencer.js</div>

</div>
<p>Add <code>custom-sequencer</code> to your Jest configuration:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  testSequencer: 'path/to/custom-sequencer.js',
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  testSequencer: 'path/to/custom-sequencer.js',
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="testtimeout-number">
<code>testTimeout</code> [number]</h3>
<p>Default: <code>5000</code></p>
<p>Default timeout of a test in milliseconds.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="transform-objectstring-pathtotransformer--pathtotransformer-object">
<code>transform</code> [object&lt;string, pathToTransformer | [pathToTransformer, object]&gt;]</h3>
<p>Default: <code>{"\\.[jt]sx?$": "babel-jest"}</code></p>
<p>A map from regular expressions to paths to transformers. Optionally, a tuple with configuration options can be passed as second argument: <code>{filePattern: ['path-to-transformer', {options}]}</code>. For example, here is how you can configure <code>babel-jest</code> for non-default behavior: <code>{'\\.js$': ['babel-jest', {rootMode: 'upward'}]}</code>.</p>
<p>Jest runs the code of your project as JavaScript, hence a transformer is needed if you use some syntax not supported by Node out of the box (such as JSX, TypeScript, Vue templates). By default, Jest will use <a href="https://github.com/facebook/jest/tree/main/packages/babel-jest#setup" target="_blank" rel="noopener noreferrer"><code>babel-jest</code></a> transformer, which will load your project's Babel configuration and transform any file matching the <code>/\.[jt]sx?$/</code> RegExp (in other words, any <code>.js</code>, <code>.jsx</code>, <code>.ts</code> or <code>.tsx</code> file). In addition, <code>babel-jest</code> will inject the Babel plugin necessary for mock hoisting talked about in <a href="manual-mocks.html#using-with-es-module-imports">ES Module mocking</a>.</p>
<p>See the <a href="code-transformation.html">Code Transformation</a> section for more details and instructions on building your own transformer.</p>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL">
<p>Keep in mind that a transformer only runs once per file unless the file has changed.</p>
<p>Remember to include the default <code>babel-jest</code> transformer explicitly, if you wish to use it alongside with additional code preprocessors:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  transform: {
    '\\.[jt]sx?$': 'babel-jest',
    '\\.css$': 'some-css-transformer',
  },
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  transform: {
    '\\.[jt]sx?$': 'babel-jest',
    '\\.css$': 'some-css-transformer',
  },
};

export default config;</pre>

</div>
</div>
</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="transformignorepatterns-arraystring">
<code>transformIgnorePatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>["/node_modules/", "\\.pnp\\.[^\\\/]+$"]</code></p>
<p>An array of regexp pattern strings that are matched against all source file paths before transformation. If the file path matches <strong>any</strong> of the patterns, it will not be transformed.</p>
<p>Providing regexp patterns that overlap with each other may result in files not being transformed that you expected to be transformed. For example:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  transformIgnorePatterns: ['/node_modules/(?!(foo|bar)/)', '/bar/'],
};

export default config;</pre>

</div>
</div>
</div>
<p>The first pattern will match (and therefore not transform) files inside <code>/node_modules</code> except for those in <code>/node_modules/foo/</code> and <code>/node_modules/bar/</code>. The second pattern will match (and therefore not transform) files inside any path with <code>/bar/</code> in it. With the two together, files in <code>/node_modules/bar/</code> will not be transformed because it does match the second pattern, even though it was excluded by the first.</p>
<p>Sometimes it happens (especially in React Native or TypeScript projects) that 3rd party modules are published as untranspiled code. Since all files inside <code>node_modules</code> are not transformed by default, Jest will not understand the code in these modules, resulting in syntax errors. To overcome this, you may use <code>transformIgnorePatterns</code> to allow transpiling such modules. You'll find a good example of this use case in <a href="tutorial-react-native.html#transformignorepatterns-customization">React Native Guide</a>.</p>
<p>These pattern strings match against the full path. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  transformIgnorePatterns: [
    '&lt;rootDir&gt;/bower_components/',
    '&lt;rootDir&gt;/node_modules/',
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  transformIgnorePatterns: [
    '&lt;rootDir&gt;/bower_components/',
    '&lt;rootDir&gt;/node_modules/',
  ],
};

export default config;</pre>

</div>
</div>
</div>
<div class="theme-admonition theme-admonition-tip alert alert--success admonition_uH4V">
<div class="admonitionHeading_P5_N">
tip</div>
<div class="admonitionContent_yySL">
<p>If you use <code>pnpm</code> and need to convert some packages under <code>node_modules</code>, you need to note that the packages in this folder (e.g. <code>node_modules/package-a/</code>) have been symlinked to the path under <code>.pnpm</code> (e.g. <code>node_modules/.pnpm/package-a@x.x.x/node_modules/pakcage-a/</code>), so using <code>&lt;rootdir&gt;/node_modules/(?!(package-a|package-b)/)</code> directly will not be recognized, while is to use:</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  transformIgnorePatterns: [
    '&lt;rootdir&gt;/node_modules/.pnpm/(?!(package-a|package-b)@)',
  ],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  transformIgnorePatterns: [
    '&lt;rootdir&gt;/node_modules/.pnpm/(?!(package-a|package-b)@)',
  ],
};

export default config;</pre>

</div>
</div>
</div>
<p>It should be noted that the folder name of pnpm under <code>.pnpm</code> is the package name plus <code>@</code> and version number, so writing <code>/</code> will not be recognized, but using <code>@</code> can.</p>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="unmockedmodulepathpatterns-arraystring">
<code>unmockedModulePathPatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>An array of regexp pattern strings that are matched against all modules before the module loader will automatically return a mock for them. If a module's path matches any of the patterns in this list, it will not be automatically mocked by the module loader.</p>
<p>This is useful for some commonly used 'utility' modules that are almost always used as implementation details almost all the time (like underscore/lo-dash, etc). It's generally a best practice to keep this list as small as possible and always use explicit <code>jest.mock()</code>/<code>jest.unmock()</code> calls in individual tests. Explicit per-test setup is far easier for other readers of the test to reason about the environment the test will run in.</p>
<p>It is possible to override this setting in individual tests by explicitly calling <code>jest.mock()</code> at the top of the test file.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="verbose-boolean">
<code>verbose</code> [boolean]</h3>
<p>Default: <code>false</code></p>
<p>Indicates whether each individual test should be reported during the run. All errors will also still be shown on the bottom after execution. Note that if there is only one test file being run it will default to <code>true</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="watchpathignorepatterns-arraystring">
<code>watchPathIgnorePatterns</code> [array&lt;string&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>An array of RegExp patterns that are matched against all source file paths before re-running tests in watch mode. If the file path matches any of the patterns, when it is updated, it will not trigger a re-run of tests.</p>
<p>These patterns match against the full path. Use the <code>&lt;rootDir&gt;</code> string token to include the path to your project's root directory to prevent it from accidentally ignoring all of your files in different environments that may have different root directories. Example: <code>["&lt;rootDir&gt;/node_modules/"]</code>.</p>
<p>Even if nothing is specified here, the watcher will ignore changes to the version control folders (.git, .hg). Other hidden files and directories, i.e. those that begin with a dot (<code>.</code>), are watched by default. Remember to escape the dot when you add them to <code>watchPathIgnorePatterns</code> as it is a special RegExp character.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  watchPathIgnorePatterns: ['&lt;rootDir&gt;/\\.tmp/', '&lt;rootDir&gt;/bar/'],
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  watchPathIgnorePatterns: ['&lt;rootDir&gt;/\\.tmp/', '&lt;rootDir&gt;/bar/'],
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="watchplugins-arraystring--string-object">
<code>watchPlugins</code> [array&lt;string | [string, Object]&gt;]</h3>
<p>Default: <code>[]</code></p>
<p>This option allows you to use custom watch plugins. Read more about watch plugins <a href="watch-plugins.html">here</a>.</p>
<p>Examples of watch plugins include:</p>
<ul>
<li><a href="https://github.com/rickhanlonii/jest-watch-master" target="_blank" rel="noopener noreferrer"><code>jest-watch-master</code></a></li>
<li><a href="https://github.com/rogeliog/jest-watch-select-projects" target="_blank" rel="noopener noreferrer"><code>jest-watch-select-projects</code></a></li>
<li><a href="https://github.com/unional/jest-watch-suspend" target="_blank" rel="noopener noreferrer"><code>jest-watch-suspend</code></a></li>
<li><a href="https://github.com/jest-community/jest-watch-typeahead" target="_blank" rel="noopener noreferrer"><code>jest-watch-typeahead</code></a></li>
<li><a href="https://github.com/cameronhunter/jest-watch-directories/tree/master/packages/jest-watch-yarn-workspaces" target="_blank" rel="noopener noreferrer"><code>jest-watch-yarn-workspaces</code></a></li>
</ul>
<div class="theme-admonition theme-admonition-info alert alert--info admonition_uH4V">
<div class="admonitionHeading_P5_N">
info</div>
<div class="admonitionContent_yySL"><p>The values in the <code>watchPlugins</code> property value can omit the <code>jest-watch-</code> prefix of the package name.</p></div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="watchman-boolean">
<code>watchman</code> [boolean]</h3>
<p>Default: <code>true</code></p>
<p>Whether to use <a href="https://facebook.github.io/watchman/" target="_blank" rel="noopener noreferrer"><code>watchman</code></a> for file crawling.</p>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="workeridlememorylimit-numberstring">
<code>workerIdleMemoryLimit</code> [number|string]</h3>
<p>Default: <code>undefined</code></p>
<p>Specifies the memory limit for workers before they are recycled and is primarily a work-around for <a href="https://github.com/facebook/jest/issues/11956" target="_blank" rel="noopener noreferrer">this issue</a>;</p>
<p>After the worker has executed a test the memory usage of it is checked. If it exceeds the value specified the worker is killed and restarted. The limit can be specified in a number of different ways and whatever the result is <code>Math.floor</code> is used to turn it into an integer value:</p>
<ul>
<li>
<code>&lt;= 1</code> - The value is assumed to be a percentage of system memory. So 0.5 sets the memory limit of the worker to half of the total system memory</li>
<li>
<code>\&gt; 1</code> - Assumed to be a fixed byte value. Because of the previous rule if you wanted a value of 1 byte (I don't know why) you could use <code>1.1</code>.</li>
<li>With units<ul>
<li>
<code>50%</code> - As above, a percentage of total system memory</li>
<li>
<code>100KB</code>, <code>65MB</code>, etc - With units to denote a fixed memory limit.<ul>
<li>
<code>K</code> / <code>KB</code> - Kilobytes (x1000)</li>
<li>
<code>KiB</code> - Kibibytes (x1024)</li>
<li>
<code>M</code> / <code>MB</code> - Megabytes</li>
<li>
<code>MiB</code> - Mebibytes</li>
<li>
<code>G</code> / <code>GB</code> - Gigabytes</li>
<li>
<code>GiB</code> - Gibibytes</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>NOTE:</strong> <a href="https://github.com/facebook/jest/issues/11956#issuecomment-1212925677" target="_blank" rel="noopener noreferrer">% based memory does not work on Linux CircleCI workers</a> due to incorrect system memory being reported.</p>
<div class="tabs-container tabList_J5MA">
<ul role="tablist" aria-orientation="horizontal" class="tabs">
<li role="tab" tabindex="0" aria-selected="true" class="tabs__item tabItem_l0OV tabs__item--active">JavaScript</li>
<li role="tab" tabindex="-1" aria-selected="false" class="tabs__item tabItem_l0OV">TypeScript</li>
</ul>
<div class="margin-top--md">
<div role="tabpanel" class="tabItem_wHwb">
<pre tabindex="0" data-language="typescript">/** @type {import('jest').Config} */
const config = {
  workerIdleMemoryLimit: 0.2,
};

module.exports = config;</pre>

</div>
<div role="tabpanel" class="tabItem_wHwb" hidden="">
<pre tabindex="0" data-language="typescript">import type {Config} from 'jest';

const config: Config = {
  workerIdleMemoryLimit: 0.2,
};

export default config;</pre>

</div>
</div>
</div>
<h3 class="anchor anchorWithStickyNavbar_JmGV" id="-string">
<code>//</code> [string]</h3>
<p>This option allows comments in <code>package.json</code>. Include the comment text as the value of this key:</p>
<pre tabindex="0" data-language="typescript">{
  "name": "my-project",
  "jest": {
    "//": "Comment goes here",
    "verbose": true
  }
}</pre>
<div class="language-json codeBlockContainer_mQmQ theme-code-block">
<div class="codeBlockTitle_x_ju">package.json</div>

</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 Facebook, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://jestjs.io/docs/configuration" class="_attribution-link">https://jestjs.io/docs/configuration</a>
  </p>
</div>
