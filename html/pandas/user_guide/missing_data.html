<h1>Working with missing data</h1> <section id="values-considered-missing"> <h2>Values considered “missing”</h2> <p>pandas uses different sentinel values to represent a missing (also referred to as NA) depending on the data type.</p> <p><code class="docutils literal notranslate"><span class="pre">numpy.nan</span></code> for NumPy data types. The disadvantage of using NumPy data types is that the original data type will be coerced to <code class="docutils literal notranslate"><span class="pre">np.float64</span></code> or <code class="docutils literal notranslate"><span class="pre">object</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: pd.Series([1, 2], dtype=np.int64).reindex([0, 1, 2])
Out[1]: 
0    1.0
1    2.0
2    NaN
dtype: float64

In [2]: pd.Series([True, False], dtype=np.bool_).reindex([0, 1, 2])
Out[2]: 
0     True
1    False
2      NaN
dtype: object
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.nat.html#pandas.NaT" title="pandas.NaT"><code class="xref py py-class docutils literal notranslate"><span class="pre">NaT</span></code></a> for NumPy <code class="docutils literal notranslate"><span class="pre">np.datetime64</span></code>, <code class="docutils literal notranslate"><span class="pre">np.timedelta64</span></code>, and <a class="reference internal" href="../reference/api/pandas.perioddtype.html#pandas.PeriodDtype" title="pandas.PeriodDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">PeriodDtype</span></code></a>. For typing applications, use <code class="xref py py-class docutils literal notranslate"><span class="pre">api.types.NaTType</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [3]: pd.Series([1, 2], dtype=np.dtype("timedelta64[ns]")).reindex([0, 1, 2])
Out[3]: 
0   0 days 00:00:00.000000001
1   0 days 00:00:00.000000002
2                         NaT
dtype: timedelta64[ns]

In [4]: pd.Series([1, 2], dtype=np.dtype("datetime64[ns]")).reindex([0, 1, 2])
Out[4]: 
0   1970-01-01 00:00:00.000000001
1   1970-01-01 00:00:00.000000002
2                             NaT
dtype: datetime64[ns]

In [5]: pd.Series(["2020", "2020"], dtype=pd.PeriodDtype("D")).reindex([0, 1, 2])
Out[5]: 
0    2020-01-01
1    2020-01-01
2           NaT
dtype: period[D]
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> for <a class="reference internal" href="../reference/api/pandas.stringdtype.html#pandas.StringDtype" title="pandas.StringDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringDtype</span></code></a>, <a class="reference internal" href="../reference/api/pandas.int64dtype.html#pandas.Int64Dtype" title="pandas.Int64Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Dtype</span></code></a> (and other bit widths), <code class="xref py py-class docutils literal notranslate"><span class="pre">Float64Dtype`(and</span> <span class="pre">other</span> <span class="pre">bit</span> <span class="pre">widths),</span> <span class="pre">:class:`BooleanDtype</span></code> and <a class="reference internal" href="../reference/api/pandas.arrowdtype.html#pandas.ArrowDtype" title="pandas.ArrowDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrowDtype</span></code></a>. These types will maintain the original data type of the data. For typing applications, use <code class="xref py py-class docutils literal notranslate"><span class="pre">api.types.NAType</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [6]: pd.Series([1, 2], dtype="Int64").reindex([0, 1, 2])
Out[6]: 
0       1
1       2
2    &lt;NA&gt;
dtype: Int64

In [7]: pd.Series([True, False], dtype="boolean[pyarrow]").reindex([0, 1, 2])
Out[7]: 
0     True
1    False
2     &lt;NA&gt;
dtype: bool[pyarrow]
</pre></div> </div> <p>To detect these missing value, use the <a class="reference internal" href="../reference/api/pandas.isna.html#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> or <a class="reference internal" href="../reference/api/pandas.notna.html#pandas.notna" title="pandas.notna"><code class="xref py py-func docutils literal notranslate"><span class="pre">notna()</span></code></a> methods.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [8]: ser = pd.Series([pd.Timestamp("2020-01-01"), pd.NaT])

In [9]: ser
Out[9]: 
0   2020-01-01
1          NaT
dtype: datetime64[ns]

In [10]: pd.isna(ser)
Out[10]: 
0    False
1     True
dtype: bool
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="../reference/api/pandas.isna.html#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> or <a class="reference internal" href="../reference/api/pandas.notna.html#pandas.notna" title="pandas.notna"><code class="xref py py-func docutils literal notranslate"><span class="pre">notna()</span></code></a> will also consider <code class="docutils literal notranslate"><span class="pre">None</span></code> a missing value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [11]: ser = pd.Series([1, None], dtype=object)

In [12]: ser
Out[12]: 
0       1
1    None
dtype: object

In [13]: pd.isna(ser)
Out[13]: 
0    False
1     True
dtype: bool
</pre></div> </div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Equality compaisons between <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, <a class="reference internal" href="../reference/api/pandas.nat.html#pandas.NaT" title="pandas.NaT"><code class="xref py py-class docutils literal notranslate"><span class="pre">NaT</span></code></a>, and <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> do not act like <code class="docutils literal notranslate"><span class="pre">None</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: None == None  # noqa: E711
Out[14]: True

In [15]: np.nan == np.nan
Out[15]: False

In [16]: pd.NaT == pd.NaT
Out[16]: False

In [17]: pd.NA == pd.NA
Out[17]: &lt;NA&gt;
</pre></div> </div> <p>Therefore, an equality comparison between a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> with one of these missing values does not provide the same information as <a class="reference internal" href="../reference/api/pandas.isna.html#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> or <a class="reference internal" href="../reference/api/pandas.notna.html#pandas.notna" title="pandas.notna"><code class="xref py py-func docutils literal notranslate"><span class="pre">notna()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [18]: ser = pd.Series([True, None], dtype="boolean[pyarrow]")

In [19]: ser == pd.NA
Out[19]: 
0    &lt;NA&gt;
1    &lt;NA&gt;
dtype: bool[pyarrow]

In [20]: pd.isna(ser)
Out[20]: 
0    False
1     True
dtype: bool
</pre></div> </div> </div> </section> <section id="na-semantics"> <h2>
<a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> semantics</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Experimental: the behaviour of <code class="xref py py-class docutils literal notranslate"><span class="pre">NA`</span></code> can still change without warning.</p> </div> <p>Starting from pandas 1.0, an experimental <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> value (singleton) is available to represent scalar missing values. The goal of <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> is provide a “missing” indicator that can be used consistently across data types (instead of <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">pd.NaT</span></code> depending on the data type).</p> <p>For example, when having missing values in a <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> with the nullable integer dtype, it will use <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: s = pd.Series([1, 2, None], dtype="Int64")

In [22]: s
Out[22]: 
0       1
1       2
2    &lt;NA&gt;
dtype: Int64

In [23]: s[2]
Out[23]: &lt;NA&gt;

In [24]: s[2] is pd.NA
Out[24]: True
</pre></div> </div> <p>Currently, pandas does not yet use those data types using <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> by default a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, so you need to specify the dtype explicitly. An easy way to convert to those dtypes is explained in the <a class="reference internal" href="#missing-data-na-conversion"><span class="std std-ref">conversion section</span></a>.</p> <section id="propagation-in-arithmetic-and-comparison-operations"> <h3>Propagation in arithmetic and comparison operations</h3> <p>In general, missing values <em>propagate</em> in operations involving <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a>. When one of the operands is unknown, the outcome of the operation is also unknown.</p> <p>For example, <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> propagates in arithmetic operations, similarly to <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: pd.NA + 1
Out[25]: &lt;NA&gt;

In [26]: "a" * pd.NA
Out[26]: &lt;NA&gt;
</pre></div> </div> <p>There are a few special cases when the result is known, even when one of the operands is <code class="docutils literal notranslate"><span class="pre">NA</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [27]: pd.NA ** 0
Out[27]: 1

In [28]: 1 ** pd.NA
Out[28]: 1
</pre></div> </div> <p>In equality and comparison operations, <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> also propagates. This deviates from the behaviour of <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, where comparisons with <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> always return <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [29]: pd.NA == 1
Out[29]: &lt;NA&gt;

In [30]: pd.NA == pd.NA
Out[30]: &lt;NA&gt;

In [31]: pd.NA &lt; 2.5
Out[31]: &lt;NA&gt;
</pre></div> </div> <p>To check if a value is equal to <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a>, use <a class="reference internal" href="../reference/api/pandas.isna.html#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [32]: pd.isna(pd.NA)
Out[32]: True
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>An exception on this basic propagation rule are <em>reductions</em> (such as the mean or the minimum), where pandas defaults to skipping missing values. See the <a class="reference internal" href="#missing-data-calculations"><span class="std std-ref">calculation section</span></a> for more.</p> </div> </section> <section id="logical-operations"> <h3>Logical operations</h3> <p>For logical operations, <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> follows the rules of the <a class="reference external" href="https://en.wikipedia.org/wiki/Three-valued_logic">three-valued logic</a> (or <em>Kleene logic</em>, similarly to R, SQL and Julia). This logic means to only propagate missing values when it is logically required.</p> <p>For example, for the logical “or” operation (<code class="docutils literal notranslate"><span class="pre">|</span></code>), if one of the operands is <code class="docutils literal notranslate"><span class="pre">True</span></code>, we already know the result will be <code class="docutils literal notranslate"><span class="pre">True</span></code>, regardless of the other value (so regardless the missing value would be <code class="docutils literal notranslate"><span class="pre">True</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code>). In this case, <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> does not propagate:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [33]: True | False
Out[33]: True

In [34]: True | pd.NA
Out[34]: True

In [35]: pd.NA | True
Out[35]: True
</pre></div> </div> <p>On the other hand, if one of the operands is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the result depends on the value of the other operand. Therefore, in this case <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> propagates:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [36]: False | True
Out[36]: True

In [37]: False | False
Out[37]: False

In [38]: False | pd.NA
Out[38]: &lt;NA&gt;
</pre></div> </div> <p>The behaviour of the logical “and” operation (<code class="docutils literal notranslate"><span class="pre">&amp;</span></code>) can be derived using similar logic (where now <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> will not propagate if one of the operands is already <code class="docutils literal notranslate"><span class="pre">False</span></code>):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: False &amp; True
Out[39]: False

In [40]: False &amp; False
Out[40]: False

In [41]: False &amp; pd.NA
Out[41]: False
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: True &amp; True
Out[42]: True

In [43]: True &amp; False
Out[43]: False

In [44]: True &amp; pd.NA
Out[44]: &lt;NA&gt;
</pre></div> </div> </section> <section id="na-in-a-boolean-context"> <h3>
<code class="docutils literal notranslate"><span class="pre">NA</span></code> in a boolean context</h3> <p>Since the actual value of an NA is unknown, it is ambiguous to convert NA to a boolean value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [45]: bool(pd.NA)
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[45], line 1
----&gt; 1 bool(pd.NA)

File missing.pyx:392, in pandas._libs.missing.NAType.__bool__()

TypeError: boolean value of NA is ambiguous
</pre></div> </div> <p>This also means that <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> cannot be used in a context where it is evaluated to a boolean, such as <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">condition:</span> <span class="pre">...</span></code> where <code class="docutils literal notranslate"><span class="pre">condition</span></code> can potentially be <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a>. In such cases, <a class="reference internal" href="../reference/api/pandas.isna.html#pandas.isna" title="pandas.isna"><code class="xref py py-func docutils literal notranslate"><span class="pre">isna()</span></code></a> can be used to check for <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> or <code class="docutils literal notranslate"><span class="pre">condition</span></code> being <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> can be avoided, for example by filling missing values beforehand.</p> <p>A similar situation occurs when using <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects in <code class="docutils literal notranslate"><span class="pre">if</span></code> statements, see <a class="reference internal" href="gotchas.html#gotchas-truth"><span class="std std-ref">Using if/truth statements with pandas</span></a>.</p> </section> <section id="numpy-ufuncs"> <h3>NumPy ufuncs</h3> <p><a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-attr docutils literal notranslate"><span class="pre">pandas.NA</span></code></a> implements NumPy’s <code class="docutils literal notranslate"><span class="pre">__array_ufunc__</span></code> protocol. Most ufuncs work with <code class="docutils literal notranslate"><span class="pre">NA</span></code>, and generally return <code class="docutils literal notranslate"><span class="pre">NA</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [46]: np.log(pd.NA)
Out[46]: &lt;NA&gt;

In [47]: np.add(pd.NA, 1)
Out[47]: &lt;NA&gt;
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Currently, ufuncs involving an ndarray and <code class="docutils literal notranslate"><span class="pre">NA</span></code> will return an object-dtype filled with NA values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [48]: a = np.array([1, 2, 3])

In [49]: np.greater(a, pd.NA)
Out[49]: array([&lt;NA&gt;, &lt;NA&gt;, &lt;NA&gt;], dtype=object)
</pre></div> </div> <p>The return type here may change to return a different array type in the future.</p> </div> <p>See <a class="reference internal" href="dsintro.html#dsintro-numpy-interop"><span class="std std-ref">DataFrame interoperability with NumPy functions</span></a> for more on ufuncs.</p> <section id="conversion"> <h4>Conversion</h4> <p>If you have a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> using <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, <a class="reference internal" href="../reference/api/pandas.series.convert_dtypes.html#pandas.Series.convert_dtypes" title="pandas.Series.convert_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.convert_dtypes()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.convert_dtypes.html#pandas.DataFrame.convert_dtypes" title="pandas.DataFrame.convert_dtypes"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.convert_dtypes()</span></code></a> in <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> that can convert data to use the data types that use <a class="reference internal" href="../reference/api/pandas.na.html#pandas.NA" title="pandas.NA"><code class="xref py py-class docutils literal notranslate"><span class="pre">NA</span></code></a> such as <a class="reference internal" href="../reference/api/pandas.int64dtype.html#pandas.Int64Dtype" title="pandas.Int64Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Dtype</span></code></a> or <a class="reference internal" href="../reference/api/pandas.arrowdtype.html#pandas.ArrowDtype" title="pandas.ArrowDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrowDtype</span></code></a>. This is especially helpful after reading in data sets from IO methods where data types were inferred.</p> <p>In this example, while the dtypes of all columns are changed, we show the results for the first 10 columns.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [50]: import io

In [51]: data = io.StringIO("a,b\n,True\n2,")

In [52]: df = pd.read_csv(data)

In [53]: df.dtypes
Out[53]: 
a    float64
b     object
dtype: object

In [54]: df_conv = df.convert_dtypes()

In [55]: df_conv
Out[55]: 
      a     b
0  &lt;NA&gt;  True
1     2  &lt;NA&gt;

In [56]: df_conv.dtypes
Out[56]: 
a      Int64
b    boolean
dtype: object
</pre></div> </div> </section> </section> </section> <section id="inserting-missing-data"> <h2>Inserting missing data</h2> <p>You can insert missing values by simply assigning to a <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>. The missing value sentinel used will be chosen based on the dtype.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: ser = pd.Series([1., 2., 3.])

In [58]: ser.loc[0] = None

In [59]: ser
Out[59]: 
0    NaN
1    2.0
2    3.0
dtype: float64

In [60]: ser = pd.Series([pd.Timestamp("2021"), pd.Timestamp("2021")])

In [61]: ser.iloc[0] = np.nan

In [62]: ser
Out[62]: 
0          NaT
1   2021-01-01
dtype: datetime64[ns]

In [63]: ser = pd.Series([True, False], dtype="boolean[pyarrow]")

In [64]: ser.iloc[0] = None

In [65]: ser
Out[65]: 
0     &lt;NA&gt;
1    False
dtype: bool[pyarrow]
</pre></div> </div> <p>For <code class="docutils literal notranslate"><span class="pre">object</span></code> types, pandas will use the value given:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [66]: s = pd.Series(["a", "b", "c"], dtype=object)

In [67]: s.loc[0] = None

In [68]: s.loc[1] = np.nan

In [69]: s
Out[69]: 
0    None
1     NaN
2       c
dtype: object
</pre></div> </div> </section> <section id="calculations-with-missing-data"> <h2>Calculations with missing data</h2> <p>Missing values propagate through arithmetic operations between pandas objects.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: ser1 = pd.Series([np.nan, np.nan, 2, 3])

In [71]: ser2 = pd.Series([np.nan, 1, np.nan, 4])

In [72]: ser1
Out[72]: 
0    NaN
1    NaN
2    2.0
3    3.0
dtype: float64

In [73]: ser2
Out[73]: 
0    NaN
1    1.0
2    NaN
3    4.0
dtype: float64

In [74]: ser1 + ser2
Out[74]: 
0    NaN
1    NaN
2    NaN
3    7.0
dtype: float64
</pre></div> </div> <p>The descriptive statistics and computational methods discussed in the <a class="reference internal" href="basics.html#basics-stats"><span class="std std-ref">data structure overview</span></a> (and listed <a class="reference internal" href="../reference/series.html#api-series-stats"><span class="std std-ref">here</span></a> and <a class="reference internal" href="../reference/frame.html#api-dataframe-stats"><span class="std std-ref">here</span></a>) are all account for missing data.</p> <p>When summing data, NA values or empty data will be treated as zero.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [75]: pd.Series([np.nan]).sum()
Out[75]: 0.0

In [76]: pd.Series([], dtype="float64").sum()
Out[76]: 0.0
</pre></div> </div> <p>When taking the product, NA values or empty data will be treated as 1.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [77]: pd.Series([np.nan]).prod()
Out[77]: 1.0

In [78]: pd.Series([], dtype="float64").prod()
Out[78]: 1.0
</pre></div> </div> <p>Cumulative methods like <a class="reference internal" href="../reference/api/pandas.dataframe.cumsum.html#pandas.DataFrame.cumsum" title="pandas.DataFrame.cumsum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumsum()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.cumprod.html#pandas.DataFrame.cumprod" title="pandas.DataFrame.cumprod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumprod()</span></code></a> ignore NA values by default preserve them in the result. This behavior can be changed with <code class="docutils literal notranslate"><span class="pre">skipna</span></code></p> <ul class="simple"> <li><p>Cumulative methods like <a class="reference internal" href="../reference/api/pandas.dataframe.cumsum.html#pandas.DataFrame.cumsum" title="pandas.DataFrame.cumsum"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumsum()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.cumprod.html#pandas.DataFrame.cumprod" title="pandas.DataFrame.cumprod"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cumprod()</span></code></a> ignore NA values by default, but preserve them in the resulting arrays. To override this behaviour and include NA values, use <code class="docutils literal notranslate"><span class="pre">skipna=False</span></code>.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: ser = pd.Series([1, np.nan, 3, np.nan])

In [80]: ser
Out[80]: 
0    1.0
1    NaN
2    3.0
3    NaN
dtype: float64

In [81]: ser.cumsum()
Out[81]: 
0    1.0
1    NaN
2    4.0
3    NaN
dtype: float64

In [82]: ser.cumsum(skipna=False)
Out[82]: 
0    1.0
1    NaN
2    NaN
3    NaN
dtype: float64
</pre></div> </div> </section> <section id="dropping-missing-data"> <h2>Dropping missing data</h2> <p><a class="reference internal" href="../reference/api/pandas.dataframe.dropna.html#pandas.DataFrame.dropna" title="pandas.DataFrame.dropna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">dropna()</span></code></a> dropa rows or columns with missing data.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [83]: df = pd.DataFrame([[np.nan, 1, 2], [1, 2, np.nan], [1, 2, 3]])

In [84]: df
Out[84]: 
     0  1    2
0  NaN  1  2.0
1  1.0  2  NaN
2  1.0  2  3.0

In [85]: df.dropna()
Out[85]: 
     0  1    2
2  1.0  2  3.0

In [86]: df.dropna(axis=1)
Out[86]: 
   1
0  1
1  2
2  2

In [87]: ser = pd.Series([1, pd.NA], dtype="int64[pyarrow]")

In [88]: ser.dropna()
Out[88]: 
0    1
dtype: int64[pyarrow]
</pre></div> </div> </section> <section id="filling-missing-data"> <h2>Filling missing data</h2> <section id="filling-by-value"> <h3>Filling by value</h3> <p><a class="reference internal" href="../reference/api/pandas.dataframe.fillna.html#pandas.DataFrame.fillna" title="pandas.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">fillna()</span></code></a> replaces NA values with non-NA data.</p> <p>Replace NA with a scalar value</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [89]: data = {"np": [1.0, np.nan, np.nan, 2], "arrow": pd.array([1.0, pd.NA, pd.NA, 2], dtype="float64[pyarrow]")}

In [90]: df = pd.DataFrame(data)

In [91]: df
Out[91]: 
    np  arrow
0  1.0    1.0
1  NaN   &lt;NA&gt;
2  NaN   &lt;NA&gt;
3  2.0    2.0

In [92]: df.fillna(0)
Out[92]: 
    np  arrow
0  1.0    1.0
1  0.0    0.0
2  0.0    0.0
3  2.0    2.0
</pre></div> </div> <p>Fill gaps forward or backward</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [93]: df.ffill()
Out[93]: 
    np  arrow
0  1.0    1.0
1  1.0    1.0
2  1.0    1.0
3  2.0    2.0

In [94]: df.bfill()
Out[94]: 
    np  arrow
0  1.0    1.0
1  2.0    2.0
2  2.0    2.0
3  2.0    2.0
</pre></div> </div> <p id="missing-data-fillna-limit">Limit the number of NA values filled</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [95]: df.ffill(limit=1)
Out[95]: 
    np  arrow
0  1.0    1.0
1  1.0    1.0
2  NaN   &lt;NA&gt;
3  2.0    2.0
</pre></div> </div> <p>NA values can be replaced with corresponding value from a <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> where the index and column aligns between the original object and the filled object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [96]: dff = pd.DataFrame(np.arange(30, dtype=np.float64).reshape(10, 3), columns=list("ABC"))

In [97]: dff.iloc[3:5, 0] = np.nan

In [98]: dff.iloc[4:6, 1] = np.nan

In [99]: dff.iloc[5:8, 2] = np.nan

In [100]: dff
Out[100]: 
      A     B     C
0   0.0   1.0   2.0
1   3.0   4.0   5.0
2   6.0   7.0   8.0
3   NaN  10.0  11.0
4   NaN   NaN  14.0
5  15.0   NaN   NaN
6  18.0  19.0   NaN
7  21.0  22.0   NaN
8  24.0  25.0  26.0
9  27.0  28.0  29.0

In [101]: dff.fillna(dff.mean())
Out[101]: 
       A     B          C
0   0.00   1.0   2.000000
1   3.00   4.0   5.000000
2   6.00   7.0   8.000000
3  14.25  10.0  11.000000
4  14.25  14.5  14.000000
5  15.00  14.5  13.571429
6  18.00  19.0  13.571429
7  21.00  22.0  13.571429
8  24.00  25.0  26.000000
9  27.00  28.0  29.000000
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="../reference/api/pandas.dataframe.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> can also be used to fill NA values.Same result as above.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [102]: dff.where(pd.notna(dff), dff.mean(), axis="columns")
Out[102]: 
       A     B          C
0   0.00   1.0   2.000000
1   3.00   4.0   5.000000
2   6.00   7.0   8.000000
3  14.25  10.0  11.000000
4  14.25  14.5  14.000000
5  15.00  14.5  13.571429
6  18.00  19.0  13.571429
7  21.00  22.0  13.571429
8  24.00  25.0  26.000000
9  27.00  28.0  29.000000
</pre></div> </div> </div> </section> <section id="interpolation"> <h3>Interpolation</h3> <p><a class="reference internal" href="../reference/api/pandas.dataframe.interpolate.html#pandas.DataFrame.interpolate" title="pandas.DataFrame.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.interpolate()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.interpolate.html#pandas.Series.interpolate" title="pandas.Series.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.interpolate()</span></code></a> fills NA values using various interpolation methods.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [103]: df = pd.DataFrame(
   .....:     {
   .....:         "A": [1, 2.1, np.nan, 4.7, 5.6, 6.8],
   .....:         "B": [0.25, np.nan, np.nan, 4, 12.2, 14.4],
   .....:     }
   .....: )
   .....: 

In [104]: df
Out[104]: 
     A      B
0  1.0   0.25
1  2.1    NaN
2  NaN    NaN
3  4.7   4.00
4  5.6  12.20
5  6.8  14.40

In [105]: df.interpolate()
Out[105]: 
     A      B
0  1.0   0.25
1  2.1   1.50
2  3.4   2.75
3  4.7   4.00
4  5.6  12.20
5  6.8  14.40

In [106]: idx = pd.date_range("2020-01-01", periods=10, freq="D")

In [107]: data = np.random.default_rng(2).integers(0, 10, 10).astype(np.float64)

In [108]: ts = pd.Series(data, index=idx)

In [109]: ts.iloc[[1, 2, 5, 6, 9]] = np.nan

In [110]: ts
Out[110]: 
2020-01-01    8.0
2020-01-02    NaN
2020-01-03    NaN
2020-01-04    2.0
2020-01-05    4.0
2020-01-06    NaN
2020-01-07    NaN
2020-01-08    0.0
2020-01-09    3.0
2020-01-10    NaN
Freq: D, dtype: float64

In [111]: ts.plot()
Out[111]: &lt;Axes: &gt;
</pre></div> </div> <img alt="../_images/series_before_interpolate.png" src="data:image/png;base64,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"> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: ts.interpolate()
Out[112]: 
2020-01-01    8.000000
2020-01-02    6.000000
2020-01-03    4.000000
2020-01-04    2.000000
2020-01-05    4.000000
2020-01-06    2.666667
2020-01-07    1.333333
2020-01-08    0.000000
2020-01-09    3.000000
2020-01-10    3.000000
Freq: D, dtype: float64

In [113]: ts.interpolate().plot()
Out[113]: &lt;Axes: &gt;
</pre></div> </div> <img alt="../_images/series_interpolate.png" src="data:image/png;base64,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"> <p>Interpolation relative to a <a class="reference internal" href="../reference/api/pandas.timestamp.html#pandas.Timestamp" title="pandas.Timestamp"><code class="xref py py-class docutils literal notranslate"><span class="pre">Timestamp</span></code></a> in the <a class="reference internal" href="../reference/api/pandas.datetimeindex.html#pandas.DatetimeIndex" title="pandas.DatetimeIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">DatetimeIndex</span></code></a> is available by setting <code class="docutils literal notranslate"><span class="pre">method="time"</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [114]: ts2 = ts.iloc[[0, 1, 3, 7, 9]]

In [115]: ts2
Out[115]: 
2020-01-01    8.0
2020-01-02    NaN
2020-01-04    2.0
2020-01-08    0.0
2020-01-10    NaN
dtype: float64

In [116]: ts2.interpolate()
Out[116]: 
2020-01-01    8.0
2020-01-02    5.0
2020-01-04    2.0
2020-01-08    0.0
2020-01-10    0.0
dtype: float64

In [117]: ts2.interpolate(method="time")
Out[117]: 
2020-01-01    8.0
2020-01-02    6.0
2020-01-04    2.0
2020-01-08    0.0
2020-01-10    0.0
dtype: float64
</pre></div> </div> <p>For a floating-point index, use <code class="docutils literal notranslate"><span class="pre">method='values'</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [118]: idx = [0.0, 1.0, 10.0]

In [119]: ser = pd.Series([0.0, np.nan, 10.0], idx)

In [120]: ser
Out[120]: 
0.0      0.0
1.0      NaN
10.0    10.0
dtype: float64

In [121]: ser.interpolate()
Out[121]: 
0.0      0.0
1.0      5.0
10.0    10.0
dtype: float64

In [122]: ser.interpolate(method="values")
Out[122]: 
0.0      0.0
1.0      1.0
10.0    10.0
dtype: float64
</pre></div> </div> <p>If you have <a class="reference external" href="https://scipy.org/">scipy</a> installed, you can pass the name of a 1-d interpolation routine to <code class="docutils literal notranslate"><span class="pre">method</span></code>. as specified in the scipy interpolation <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation">documentation</a> and reference <a class="reference external" href="https://docs.scipy.org/doc/scipy/tutorial/interpolate.html">guide</a>. The appropriate interpolation method will depend on the data type.</p> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>If you are dealing with a time series that is growing at an increasing rate, use <code class="docutils literal notranslate"><span class="pre">method='barycentric'</span></code>.</p> <p>If you have values approximating a cumulative distribution function, use <code class="docutils literal notranslate"><span class="pre">method='pchip'</span></code>.</p> <p>To fill missing values with goal of smooth plotting use <code class="docutils literal notranslate"><span class="pre">method='akima'</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [123]: df = pd.DataFrame(
   .....:    {
   .....:       "A": [1, 2.1, np.nan, 4.7, 5.6, 6.8],
   .....:       "B": [0.25, np.nan, np.nan, 4, 12.2, 14.4],
   .....:    }
   .....: )
   .....: 

In [124]: df
Out[124]: 
     A      B
0  1.0   0.25
1  2.1    NaN
2  NaN    NaN
3  4.7   4.00
4  5.6  12.20
5  6.8  14.40

In [125]: df.interpolate(method="barycentric")
Out[125]: 
      A       B
0  1.00   0.250
1  2.10  -7.660
2  3.53  -4.515
3  4.70   4.000
4  5.60  12.200
5  6.80  14.400

In [126]: df.interpolate(method="pchip")
Out[126]: 
         A          B
0  1.00000   0.250000
1  2.10000   0.672808
2  3.43454   1.928950
3  4.70000   4.000000
4  5.60000  12.200000
5  6.80000  14.400000

In [127]: df.interpolate(method="akima")
Out[127]: 
          A          B
0  1.000000   0.250000
1  2.100000  -0.873316
2  3.406667   0.320034
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000
</pre></div> </div> </div> <p>When interpolating via a polynomial or spline approximation, you must also specify the degree or order of the approximation:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [128]: df.interpolate(method="spline", order=2)
Out[128]: 
          A          B
0  1.000000   0.250000
1  2.100000  -0.428598
2  3.404545   1.206900
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000

In [129]: df.interpolate(method="polynomial", order=2)
Out[129]: 
          A          B
0  1.000000   0.250000
1  2.100000  -2.703846
2  3.451351  -1.453846
3  4.700000   4.000000
4  5.600000  12.200000
5  6.800000  14.400000
</pre></div> </div> <p>Comparing several methods.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [130]: np.random.seed(2)

In [131]: ser = pd.Series(np.arange(1, 10.1, 0.25) ** 2 + np.random.randn(37))

In [132]: missing = np.array([4, 13, 14, 15, 16, 17, 18, 20, 29])

In [133]: ser.iloc[missing] = np.nan

In [134]: methods = ["linear", "quadratic", "cubic"]

In [135]: df = pd.DataFrame({m: ser.interpolate(method=m) for m in methods})

In [136]: df.plot()
Out[136]: &lt;Axes: &gt;
</pre></div> </div> <img alt="../_images/compare_interpolations.png" src="data:image/png;base64,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"> <p>Interpolating new observations from expanding data with <a class="reference internal" href="../reference/api/pandas.series.reindex.html#pandas.Series.reindex" title="pandas.Series.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.reindex()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [137]: ser = pd.Series(np.sort(np.random.uniform(size=100)))

# interpolate at new_index
In [138]: new_index = ser.index.union(pd.Index([49.25, 49.5, 49.75, 50.25, 50.5, 50.75]))

In [139]: interp_s = ser.reindex(new_index).interpolate(method="pchip")

In [140]: interp_s.loc[49:51]
Out[140]: 
49.00    0.471410
49.25    0.476841
49.50    0.481780
49.75    0.485998
50.00    0.489266
50.25    0.491814
50.50    0.493995
50.75    0.495763
51.00    0.497074
dtype: float64
</pre></div> </div> <section id="interpolation-limits"> <h4>Interpolation limits</h4> <p><a class="reference internal" href="../reference/api/pandas.dataframe.interpolate.html#pandas.DataFrame.interpolate" title="pandas.DataFrame.interpolate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">interpolate()</span></code></a> accepts a <code class="docutils literal notranslate"><span class="pre">limit</span></code> keyword argument to limit the number of consecutive <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values filled since the last valid observation</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [141]: ser = pd.Series([np.nan, np.nan, 5, np.nan, np.nan, np.nan, 13, np.nan, np.nan])

In [142]: ser
Out[142]: 
0     NaN
1     NaN
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7     NaN
8     NaN
dtype: float64

In [143]: ser.interpolate()
Out[143]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     9.0
5    11.0
6    13.0
7    13.0
8    13.0
dtype: float64

In [144]: ser.interpolate(limit=1)
Out[144]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     NaN
5     NaN
6    13.0
7    13.0
8     NaN
dtype: float64
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are filled in a <code class="docutils literal notranslate"><span class="pre">forward</span></code> direction. Use <code class="docutils literal notranslate"><span class="pre">limit_direction</span></code> parameter to fill <code class="docutils literal notranslate"><span class="pre">backward</span></code> or from <code class="docutils literal notranslate"><span class="pre">both</span></code> directions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [145]: ser.interpolate(limit=1, limit_direction="backward")
Out[145]: 
0     NaN
1     5.0
2     5.0
3     NaN
4     NaN
5    11.0
6    13.0
7     NaN
8     NaN
dtype: float64

In [146]: ser.interpolate(limit=1, limit_direction="both")
Out[146]: 
0     NaN
1     5.0
2     5.0
3     7.0
4     NaN
5    11.0
6    13.0
7    13.0
8     NaN
dtype: float64

In [147]: ser.interpolate(limit_direction="both")
Out[147]: 
0     5.0
1     5.0
2     5.0
3     7.0
4     9.0
5    11.0
6    13.0
7    13.0
8    13.0
dtype: float64
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">NaN</span></code> values are filled whether they are surrounded by existing valid values or outside existing valid values. The <code class="docutils literal notranslate"><span class="pre">limit_area</span></code> parameter restricts filling to either inside or outside values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># fill one consecutive inside value in both directions
In [148]: ser.interpolate(limit_direction="both", limit_area="inside", limit=1)
Out[148]: 
0     NaN
1     NaN
2     5.0
3     7.0
4     NaN
5    11.0
6    13.0
7     NaN
8     NaN
dtype: float64

# fill all consecutive outside values backward
In [149]: ser.interpolate(limit_direction="backward", limit_area="outside")
Out[149]: 
0     5.0
1     5.0
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7     NaN
8     NaN
dtype: float64

# fill all consecutive outside values in both directions
In [150]: ser.interpolate(limit_direction="both", limit_area="outside")
Out[150]: 
0     5.0
1     5.0
2     5.0
3     NaN
4     NaN
5     NaN
6    13.0
7    13.0
8    13.0
dtype: float64
</pre></div> </div> </section> </section> <section id="replacing-values"> <h3>Replacing values</h3> <p><a class="reference internal" href="../reference/api/pandas.series.replace.html#pandas.Series.replace" title="pandas.Series.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.replace()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.replace.html#pandas.DataFrame.replace" title="pandas.DataFrame.replace"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.replace()</span></code></a> can be used similar to <a class="reference internal" href="../reference/api/pandas.series.fillna.html#pandas.Series.fillna" title="pandas.Series.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.fillna()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.fillna.html#pandas.DataFrame.fillna" title="pandas.DataFrame.fillna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.fillna()</span></code></a> to replace or insert missing values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [151]: df = pd.DataFrame(np.eye(3))

In [152]: df
Out[152]: 
     0    1    2
0  1.0  0.0  0.0
1  0.0  1.0  0.0
2  0.0  0.0  1.0

In [153]: df_missing = df.replace(0, np.nan)

In [154]: df_missing
Out[154]: 
     0    1    2
0  1.0  NaN  NaN
1  NaN  1.0  NaN
2  NaN  NaN  1.0

In [155]: df_filled = df_missing.replace(np.nan, 2)

In [156]: df_filled
Out[156]: 
     0    1    2
0  1.0  2.0  2.0
1  2.0  1.0  2.0
2  2.0  2.0  1.0
</pre></div> </div> <p>Replacing more than one value is possible by passing a list.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [157]: df_filled.replace([1, 44], [2, 28])
Out[157]: 
     0    1    2
0  2.0  2.0  2.0
1  2.0  2.0  2.0
2  2.0  2.0  2.0
</pre></div> </div> <p>Replacing using a mapping dict.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [158]: df_filled.replace({1: 44, 2: 28})
Out[158]: 
      0     1     2
0  44.0  28.0  28.0
1  28.0  44.0  28.0
2  28.0  28.0  44.0
</pre></div> </div> <section id="regular-expression-replacement"> <h4>Regular expression replacement</h4> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Python strings prefixed with the <code class="docutils literal notranslate"><span class="pre">r</span></code> character such as <code class="docutils literal notranslate"><span class="pre">r'hello</span> <span class="pre">world'</span></code> are <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals">“raw” strings</a>. They have different semantics regarding backslashes than strings without this prefix. Backslashes in raw strings will be interpreted as an escaped backslash, e.g., <code class="docutils literal notranslate"><span class="pre">r'\'</span> <span class="pre">==</span> <span class="pre">'\\'</span></code>.</p> </div> <p>Replace the ‘.’ with <code class="docutils literal notranslate"><span class="pre">NaN</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [159]: d = {"a": list(range(4)), "b": list("ab.."), "c": ["a", "b", np.nan, "d"]}

In [160]: df = pd.DataFrame(d)

In [161]: df.replace(".", np.nan)
Out[161]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Replace the ‘.’ with <code class="docutils literal notranslate"><span class="pre">NaN</span></code> with regular expression that removes surrounding whitespace</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [162]: df.replace(r"\s*\.\s*", np.nan, regex=True)
Out[162]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Replace with a list of regexes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [163]: df.replace([r"\.", r"(a)"], ["dot", r"\1stuff"], regex=True)
Out[163]: 
   a       b       c
0  0  astuff  astuff
1  1       b       b
2  2     dot     NaN
3  3     dot       d
</pre></div> </div> <p>Replace with a regex in a mapping dict.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [164]: df.replace({"b": r"\s*\.\s*"}, {"b": np.nan}, regex=True)
Out[164]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d
</pre></div> </div> <p>Pass nested dictionaries of regular expressions that use the <code class="docutils literal notranslate"><span class="pre">regex</span></code> keyword.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [165]: df.replace({"b": {"b": r""}}, regex=True)
Out[165]: 
   a  b    c
0  0  a    a
1  1       b
2  2  .  NaN
3  3  .    d

In [166]: df.replace(regex={"b": {r"\s*\.\s*": np.nan}})
Out[166]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  NaN  NaN
3  3  NaN    d

In [167]: df.replace({"b": r"\s*(\.)\s*"}, {"b": r"\1ty"}, regex=True)
Out[167]: 
   a    b    c
0  0    a    a
1  1    b    b
2  2  .ty  NaN
3  3  .ty    d
</pre></div> </div> <p>Pass a list of regular expressions that will replace matches with a scalar.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [168]: df.replace([r"\s*\.\s*", r"a|b"], "placeholder", regex=True)
Out[168]: 
   a            b            c
0  0  placeholder  placeholder
1  1  placeholder  placeholder
2  2  placeholder          NaN
3  3  placeholder            d
</pre></div> </div> <p>All of the regular expression examples can also be passed with the <code class="docutils literal notranslate"><span class="pre">to_replace</span></code> argument as the <code class="docutils literal notranslate"><span class="pre">regex</span></code> argument. In this case the <code class="docutils literal notranslate"><span class="pre">value</span></code> argument must be passed explicitly by name or <code class="docutils literal notranslate"><span class="pre">regex</span></code> must be a nested dictionary.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [169]: df.replace(regex=[r"\s*\.\s*", r"a|b"], value="placeholder")
Out[169]: 
   a            b            c
0  0  placeholder  placeholder
1  1  placeholder  placeholder
2  2  placeholder          NaN
3  3  placeholder            d
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>A regular expression object from <code class="docutils literal notranslate"><span class="pre">re.compile</span></code> is a valid input as well.</p> </div> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/missing_data.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/missing_data.html</a>
  </p>
</div>
