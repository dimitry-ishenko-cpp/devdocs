<h1>Frequently Asked Questions (FAQ)</h1> <section id="dataframe-memory-usage"> <h2>DataFrame memory usage</h2> <p>The memory usage of a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> (including the index) is shown when calling the <a class="reference internal" href="../reference/api/pandas.dataframe.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>. A configuration option, <code class="docutils literal notranslate"><span class="pre">display.memory_usage</span></code> (see <a class="reference internal" href="options.html#options-available"><span class="std std-ref">the list of options</span></a>), specifies if the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> memory usage will be displayed when invoking the <a class="reference internal" href="../reference/api/pandas.dataframe.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a> method.</p> <p>For example, the memory usage of the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> below is shown when calling <a class="reference internal" href="../reference/api/pandas.dataframe.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: dtypes = [
   ...:     "int64",
   ...:     "float64",
   ...:     "datetime64[ns]",
   ...:     "timedelta64[ns]",
   ...:     "complex128",
   ...:     "object",
   ...:     "bool",
   ...: ]
   ...: 

In [2]: n = 5000

In [3]: data = {t: np.random.randint(100, size=n).astype(t) for t in dtypes}

In [4]: df = pd.DataFrame(data)

In [5]: df["categorical"] = df["object"].astype("category")

In [6]: df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 5000 entries, 0 to 4999
Data columns (total 8 columns):
 #   Column           Non-Null Count  Dtype          
---  ------           --------------  -----          
 0   int64            5000 non-null   int64          
 1   float64          5000 non-null   float64        
 2   datetime64[ns]   5000 non-null   datetime64[ns] 
 3   timedelta64[ns]  5000 non-null   timedelta64[ns]
 4   complex128       5000 non-null   complex128     
 5   object           5000 non-null   object         
 6   bool             5000 non-null   bool           
 7   categorical      5000 non-null   category       
dtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)
memory usage: 288.2+ KB
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol indicates that the true memory usage could be higher, because pandas does not count the memory used by values in columns with <code class="docutils literal notranslate"><span class="pre">dtype=object</span></code>.</p> <p>Passing <code class="docutils literal notranslate"><span class="pre">memory_usage='deep'</span></code> will enable a more accurate memory usage report, accounting for the full usage of the contained objects. This is optional as it can be expensive to do this deeper introspection.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [7]: df.info(memory_usage="deep")
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 5000 entries, 0 to 4999
Data columns (total 8 columns):
 #   Column           Non-Null Count  Dtype          
---  ------           --------------  -----          
 0   int64            5000 non-null   int64          
 1   float64          5000 non-null   float64        
 2   datetime64[ns]   5000 non-null   datetime64[ns] 
 3   timedelta64[ns]  5000 non-null   timedelta64[ns]
 4   complex128       5000 non-null   complex128     
 5   object           5000 non-null   object         
 6   bool             5000 non-null   bool           
 7   categorical      5000 non-null   category       
dtypes: bool(1), category(1), complex128(1), datetime64[ns](1), float64(1), int64(1), object(1), timedelta64[ns](1)
memory usage: 424.7 KB
</pre></div> </div> <p>By default the display option is set to <code class="docutils literal notranslate"><span class="pre">True</span></code> but can be explicitly overridden by passing the <code class="docutils literal notranslate"><span class="pre">memory_usage</span></code> argument when invoking <a class="reference internal" href="../reference/api/pandas.dataframe.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a>.</p> <p>The memory usage of each column can be found by calling the <a class="reference internal" href="../reference/api/pandas.dataframe.memory_usage.html#pandas.DataFrame.memory_usage" title="pandas.DataFrame.memory_usage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_usage()</span></code></a> method. This returns a <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> with an index represented by column names and memory usage of each column shown in bytes. For the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> above, the memory usage of each column and the total memory usage can be found with the <a class="reference internal" href="../reference/api/pandas.dataframe.memory_usage.html#pandas.DataFrame.memory_usage" title="pandas.DataFrame.memory_usage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_usage()</span></code></a> method:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [8]: df.memory_usage()
Out[8]: 
Index                128
int64              40000
float64            40000
datetime64[ns]     40000
timedelta64[ns]    40000
complex128         80000
object             40000
bool                5000
categorical         9968
dtype: int64

# total memory usage of dataframe
In [9]: df.memory_usage().sum()
Out[9]: 295096
</pre></div> </div> <p>By default the memory usage of the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> index is shown in the returned <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a>, the memory usage of the index can be suppressed by passing the <code class="docutils literal notranslate"><span class="pre">index=False</span></code> argument:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [10]: df.memory_usage(index=False)
Out[10]: 
int64              40000
float64            40000
datetime64[ns]     40000
timedelta64[ns]    40000
complex128         80000
object             40000
bool                5000
categorical         9968
dtype: int64
</pre></div> </div> <p>The memory usage displayed by the <a class="reference internal" href="../reference/api/pandas.dataframe.info.html#pandas.DataFrame.info" title="pandas.DataFrame.info"><code class="xref py py-meth docutils literal notranslate"><span class="pre">info()</span></code></a> method utilizes the <a class="reference internal" href="../reference/api/pandas.dataframe.memory_usage.html#pandas.DataFrame.memory_usage" title="pandas.DataFrame.memory_usage"><code class="xref py py-meth docutils literal notranslate"><span class="pre">memory_usage()</span></code></a> method to determine the memory usage of a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> while also formatting the output in human-readable units (base-2 representation; i.e. 1KB = 1024 bytes).</p> <p>See also <a class="reference internal" href="categorical.html#categorical-memory"><span class="std std-ref">Categorical Memory Usage</span></a>.</p> </section> <section id="using-if-truth-statements-with-pandas"> <h2>Using if/truth statements with pandas</h2> <p>pandas follows the NumPy convention of raising an error when you try to convert something to a <code class="docutils literal notranslate"><span class="pre">bool</span></code>. This happens in an <code class="docutils literal notranslate"><span class="pre">if</span></code>-statement or when using the boolean operations: <code class="docutils literal notranslate"><span class="pre">and</span></code>, <code class="docutils literal notranslate"><span class="pre">or</span></code>, and <code class="docutils literal notranslate"><span class="pre">not</span></code>. It is not clear what the result of the following code should be:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; if pd.Series([False, True, False]):
...     pass
</pre></div> </div> <p>Should it be <code class="docutils literal notranslate"><span class="pre">True</span></code> because it’s not zero-length, or <code class="docutils literal notranslate"><span class="pre">False</span></code> because there are <code class="docutils literal notranslate"><span class="pre">False</span></code> values? It is unclear, so instead, pandas raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [11]: if pd.Series([False, True, False]):
   ....:     print("I was true")
   ....: 
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
&lt;ipython-input-11-5c782b38cd2f&gt; in ?()
----&gt; 1 if pd.Series([False, True, False]):
      2     print("I was true")

~/work/pandas/pandas/pandas/core/generic.py in ?(self)
   1575     @final
   1576     def __nonzero__(self) -&gt; NoReturn:
-&gt; 1577         raise ValueError(
   1578             f"The truth value of a {type(self).__name__} is ambiguous. "
   1579             "Use a.empty, a.bool(), a.item(), a.any() or a.all()."
   1580         )

ValueError: The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().
</pre></div> </div> <p>You need to explicitly choose what you want to do with the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>, e.g. use <a class="reference internal" href="../reference/api/pandas.dataframe.any.html#pandas.DataFrame.any" title="pandas.DataFrame.any"><code class="xref py py-meth docutils literal notranslate"><span class="pre">any()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.all.html#pandas.DataFrame.all" title="pandas.DataFrame.all"><code class="xref py py-meth docutils literal notranslate"><span class="pre">all()</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.empty.html#pandas.DataFrame.empty" title="pandas.DataFrame.empty"><code class="xref py py-meth docutils literal notranslate"><span class="pre">empty()</span></code></a>. Alternatively, you might want to compare if the pandas object is <code class="docutils literal notranslate"><span class="pre">None</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [12]: if pd.Series([False, True, False]) is not None:
   ....:     print("I was not None")
   ....: 
I was not None
</pre></div> </div> <p>Below is how to check if any of the values are <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [13]: if pd.Series([False, True, False]).any():
   ....:     print("I am any")
   ....: 
I am any
</pre></div> </div> <section id="bitwise-boolean"> <h3>Bitwise boolean</h3> <p>Bitwise boolean operators like <code class="docutils literal notranslate"><span class="pre">==</span></code> and <code class="docutils literal notranslate"><span class="pre">!=</span></code> return a boolean <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> which performs an element-wise comparison when compared to a scalar.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: s = pd.Series(range(5))

In [15]: s == 4
Out[15]: 
0    False
1    False
2    False
3    False
4     True
dtype: bool
</pre></div> </div> <p>See <a class="reference internal" href="basics.html#basics-compare"><span class="std std-ref">boolean comparisons</span></a> for more examples.</p> </section> <section id="using-the-in-operator"> <h3>Using the <code class="docutils literal notranslate"><span class="pre">in</span></code> operator</h3> <p>Using the Python <code class="docutils literal notranslate"><span class="pre">in</span></code> operator on a <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> tests for membership in the <strong>index</strong>, not membership among the values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [16]: s = pd.Series(range(5), index=list("abcde"))

In [17]: 2 in s
Out[17]: False

In [18]: 'b' in s
Out[18]: True
</pre></div> </div> <p>If this behavior is surprising, keep in mind that using <code class="docutils literal notranslate"><span class="pre">in</span></code> on a Python dictionary tests keys, not values, and <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> are dict-like. To test for membership in the values, use the method <a class="reference internal" href="../reference/api/pandas.series.isin.html#pandas.Series.isin" title="pandas.Series.isin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isin()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [19]: s.isin([2])
Out[19]: 
a    False
b    False
c     True
d    False
e    False
dtype: bool

In [20]: s.isin([2]).any()
Out[20]: True
</pre></div> </div> <p>For <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>, likewise, <code class="docutils literal notranslate"><span class="pre">in</span></code> applies to the column axis, testing for membership in the list of column names.</p> </section> </section> <section id="mutating-with-user-defined-function-udf-methods"> <h2>Mutating with User Defined Function (UDF) methods</h2> <p>This section applies to pandas methods that take a UDF. In particular, the methods <a class="reference internal" href="../reference/api/pandas.dataframe.apply.html#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.apply()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.aggregate.html#pandas.DataFrame.aggregate" title="pandas.DataFrame.aggregate"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.aggregate()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.transform.html#pandas.DataFrame.transform" title="pandas.DataFrame.transform"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.transform()</span></code></a>, and <a class="reference internal" href="../reference/api/pandas.dataframe.filter.html#pandas.DataFrame.filter" title="pandas.DataFrame.filter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.filter()</span></code></a>.</p> <p>It is a general rule in programming that one should not mutate a container while it is being iterated over. Mutation will invalidate the iterator, causing unexpected behavior. Consider the example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: values = [0, 1, 2, 3, 4, 5]

In [22]: n_removed = 0

In [23]: for k, value in enumerate(values):
   ....:     idx = k - n_removed
   ....:     if value % 2 == 1:
   ....:         del values[idx]
   ....:         n_removed += 1
   ....:     else:
   ....:         values[idx] = value + 1
   ....: 

In [24]: values
Out[24]: [1, 4, 5]
</pre></div> </div> <p>One probably would have expected that the result would be <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">3,</span> <span class="pre">5]</span></code>. When using a pandas method that takes a UDF, internally pandas is often iterating over the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> or other pandas object. Therefore, if the UDF mutates (changes) the <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a>, unexpected behavior can arise.</p> <p>Here is a similar example with <a class="reference internal" href="../reference/api/pandas.dataframe.apply.html#pandas.DataFrame.apply" title="pandas.DataFrame.apply"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.apply()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: def f(s):
   ....:     s.pop("a")
   ....:     return s
   ....: 

In [26]: df = pd.DataFrame({"a": [1, 2, 3], "b": [4, 5, 6]})

In [27]: df.apply(f, axis="columns")
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)
   3804 try:
-&gt; 3805     return self._engine.get_loc(casted_key)
   3806 except KeyError as err:

File index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()

File index.pyx:196, in pandas._libs.index.IndexEngine.get_loc()

File pandas/_libs/hashtable_class_helper.pxi:7081, in pandas._libs.hashtable.PyObjectHashTable.get_item()

File pandas/_libs/hashtable_class_helper.pxi:7089, in pandas._libs.hashtable.PyObjectHashTable.get_item()

KeyError: 'a'

The above exception was the direct cause of the following exception:

KeyError                                  Traceback (most recent call last)
Cell In[27], line 1
----&gt; 1 df.apply(f, axis="columns")

File ~/work/pandas/pandas/pandas/core/frame.py:10374, in DataFrame.apply(self, func, axis, raw, result_type, args, by_row, engine, engine_kwargs, **kwargs)
  10360 from pandas.core.apply import frame_apply
  10362 op = frame_apply(
  10363     self,
  10364     func=func,
   (...)
  10372     kwargs=kwargs,
  10373 )
&gt; 10374 return op.apply().__finalize__(self, method="apply")

File ~/work/pandas/pandas/pandas/core/apply.py:916, in FrameApply.apply(self)
    913 elif self.raw:
    914     return self.apply_raw(engine=self.engine, engine_kwargs=self.engine_kwargs)
--&gt; 916 return self.apply_standard()

File ~/work/pandas/pandas/pandas/core/apply.py:1063, in FrameApply.apply_standard(self)
   1061 def apply_standard(self):
   1062     if self.engine == "python":
-&gt; 1063         results, res_index = self.apply_series_generator()
   1064     else:
   1065         results, res_index = self.apply_series_numba()

File ~/work/pandas/pandas/pandas/core/apply.py:1081, in FrameApply.apply_series_generator(self)
   1078 with option_context("mode.chained_assignment", None):
   1079     for i, v in enumerate(series_gen):
   1080         # ignore SettingWithCopy here in case the user mutates
-&gt; 1081         results[i] = self.func(v, *self.args, **self.kwargs)
   1082         if isinstance(results[i], ABCSeries):
   1083             # If we have a view on v, we need to make a copy because
   1084             #  series_generator will swap out the underlying data
   1085             results[i] = results[i].copy(deep=False)

Cell In[25], line 2, in f(s)
      1 def f(s):
----&gt; 2     s.pop("a")
      3     return s

File ~/work/pandas/pandas/pandas/core/series.py:5391, in Series.pop(self, item)
   5366 def pop(self, item: Hashable) -&gt; Any:
   5367     """
   5368     Return item and drops from series. Raise KeyError if not found.
   5369 
   (...)
   5389     dtype: int64
   5390     """
-&gt; 5391     return super().pop(item=item)

File ~/work/pandas/pandas/pandas/core/generic.py:947, in NDFrame.pop(self, item)
    946 def pop(self, item: Hashable) -&gt; Series | Any:
--&gt; 947     result = self[item]
    948     del self[item]
    950     return result

File ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)
   1118     return self._values[key]
   1120 elif key_is_scalar:
-&gt; 1121     return self._get_value(key)
   1123 # Convert generator to list before going through hashable part
   1124 # (We will iterate through the generator there to check for slices)
   1125 if is_iterator(key):

File ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)
   1234     return self._values[label]
   1236 # Similar to Index.get_value, but we do not fall back to positional
-&gt; 1237 loc = self.index.get_loc(label)
   1239 if is_integer(loc):
   1240     return self._values[loc]

File ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)
   3807     if isinstance(casted_key, slice) or (
   3808         isinstance(casted_key, abc.Iterable)
   3809         and any(isinstance(x, slice) for x in casted_key)
   3810     ):
   3811         raise InvalidIndexError(key)
-&gt; 3812     raise KeyError(key) from err
   3813 except TypeError:
   3814     # If we have a listlike key, _check_indexing_error will raise
   3815     #  InvalidIndexError. Otherwise we fall through and re-raise
   3816     #  the TypeError.
   3817     self._check_indexing_error(key)

KeyError: 'a'
</pre></div> </div> <p>To resolve this issue, one can make a copy so that the mutation does not apply to the container being iterated over.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [28]: values = [0, 1, 2, 3, 4, 5]

In [29]: n_removed = 0

In [30]: for k, value in enumerate(values.copy()):
   ....:     idx = k - n_removed
   ....:     if value % 2 == 1:
   ....:         del values[idx]
   ....:         n_removed += 1
   ....:     else:
   ....:         values[idx] = value + 1
   ....: 

In [31]: values
Out[31]: [1, 3, 5]
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [32]: def f(s):
   ....:     s = s.copy()
   ....:     s.pop("a")
   ....:     return s
   ....: 

In [33]: df = pd.DataFrame({"a": [1, 2, 3], 'b': [4, 5, 6]})

In [34]: df.apply(f, axis="columns")
Out[34]: 
   b
0  4
1  5
2  6
</pre></div> </div> </section> <section id="missing-value-representation-for-numpy-types"> <h2>Missing value representation for NumPy types</h2> <section id="np-nan-as-the-na-representation-for-numpy-types"> <h3>
<code class="docutils literal notranslate"><span class="pre">np.nan</span></code> as the <code class="docutils literal notranslate"><span class="pre">NA</span></code> representation for NumPy types</h3> <p>For lack of <code class="docutils literal notranslate"><span class="pre">NA</span></code> (missing) support from the ground up in NumPy and Python in general, <code class="docutils literal notranslate"><span class="pre">NA</span></code> could have been represented with:</p> <ul class="simple"> <li><p>A <em>masked array</em> solution: an array of data and an array of boolean values indicating whether a value is there or is missing.</p></li> <li><p>Using a special sentinel value, bit pattern, or set of sentinel values to denote <code class="docutils literal notranslate"><span class="pre">NA</span></code> across the dtypes.</p></li> </ul> <p>The special value <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> (Not-A-Number) was chosen as the <code class="docutils literal notranslate"><span class="pre">NA</span></code> value for NumPy types, and there are API functions like <a class="reference internal" href="../reference/api/pandas.dataframe.isna.html#pandas.DataFrame.isna" title="pandas.DataFrame.isna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.isna()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.notna.html#pandas.DataFrame.notna" title="pandas.DataFrame.notna"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.notna()</span></code></a> which can be used across the dtypes to detect NA values. However, this choice has a downside of coercing missing integer data as float types as shown in <a class="reference internal" href="#gotchas-intna"><span class="std std-ref">Support for integer NA</span></a>.</p> </section> <section id="na-type-promotions-for-numpy-types"> <h3>
<code class="docutils literal notranslate"><span class="pre">NA</span></code> type promotions for NumPy types</h3> <p>When introducing NAs into an existing <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> via <a class="reference internal" href="../reference/api/pandas.series.reindex.html#pandas.Series.reindex" title="pandas.Series.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> or some other means, boolean and integer types will be promoted to a different dtype in order to store the NAs. The promotions are summarized in this table:</p> <table class="table"> <colgroup> <col style="width: 40.0%"> <col style="width: 60.0%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Typeclass</p></th> <th class="head"><p>Promotion dtype for storing NAs</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">floating</span></code></p></td> <td><p>no change</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">object</span></code></p></td> <td><p>no change</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">integer</span></code></p></td> <td><p>cast to <code class="docutils literal notranslate"><span class="pre">float64</span></code></p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">boolean</span></code></p></td> <td><p>cast to <code class="docutils literal notranslate"><span class="pre">object</span></code></p></td> </tr> </tbody> </table> </section> <section id="support-for-integer-na"> <h3>Support for integer <code class="docutils literal notranslate"><span class="pre">NA</span></code>
</h3> <p>In the absence of high performance <code class="docutils literal notranslate"><span class="pre">NA</span></code> support being built into NumPy from the ground up, the primary casualty is the ability to represent NAs in integer arrays. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [35]: s = pd.Series([1, 2, 3, 4, 5], index=list("abcde"))

In [36]: s
Out[36]: 
a    1
b    2
c    3
d    4
e    5
dtype: int64

In [37]: s.dtype
Out[37]: dtype('int64')

In [38]: s2 = s.reindex(["a", "b", "c", "f", "u"])

In [39]: s2
Out[39]: 
a    1.0
b    2.0
c    3.0
f    NaN
u    NaN
dtype: float64

In [40]: s2.dtype
Out[40]: dtype('float64')
</pre></div> </div> <p>This trade-off is made largely for memory and performance reasons, and also so that the resulting <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> continues to be “numeric”.</p> <p>If you need to represent integers with possibly missing values, use one of the nullable-integer extension dtypes provided by pandas or pyarrow</p> <ul class="simple"> <li><p><a class="reference internal" href="../reference/api/pandas.int8dtype.html#pandas.Int8Dtype" title="pandas.Int8Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int8Dtype</span></code></a></p></li> <li><p><a class="reference internal" href="../reference/api/pandas.int16dtype.html#pandas.Int16Dtype" title="pandas.Int16Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int16Dtype</span></code></a></p></li> <li><p><a class="reference internal" href="../reference/api/pandas.int32dtype.html#pandas.Int32Dtype" title="pandas.Int32Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int32Dtype</span></code></a></p></li> <li><p><a class="reference internal" href="../reference/api/pandas.int64dtype.html#pandas.Int64Dtype" title="pandas.Int64Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Dtype</span></code></a></p></li> <li><p><a class="reference internal" href="../reference/api/pandas.arrowdtype.html#pandas.ArrowDtype" title="pandas.ArrowDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrowDtype</span></code></a></p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [41]: s_int = pd.Series([1, 2, 3, 4, 5], index=list("abcde"), dtype=pd.Int64Dtype())

In [42]: s_int
Out[42]: 
a    1
b    2
c    3
d    4
e    5
dtype: Int64

In [43]: s_int.dtype
Out[43]: Int64Dtype()

In [44]: s2_int = s_int.reindex(["a", "b", "c", "f", "u"])

In [45]: s2_int
Out[45]: 
a       1
b       2
c       3
f    &lt;NA&gt;
u    &lt;NA&gt;
dtype: Int64

In [46]: s2_int.dtype
Out[46]: Int64Dtype()

In [47]: s_int_pa = pd.Series([1, 2, None], dtype="int64[pyarrow]")

In [48]: s_int_pa
Out[48]: 
0       1
1       2
2    &lt;NA&gt;
dtype: int64[pyarrow]
</pre></div> </div> <p>See <a class="reference internal" href="integer_na.html#integer-na"><span class="std std-ref">Nullable integer data type</span></a> and <a class="reference internal" href="pyarrow.html#pyarrow"><span class="std std-ref">PyArrow Functionality</span></a> for more.</p> </section> <section id="why-not-make-numpy-like-r"> <h3>Why not make NumPy like R?</h3> <p>Many people have suggested that NumPy should simply emulate the <code class="docutils literal notranslate"><span class="pre">NA</span></code> support present in the more domain-specific statistical programming language <a class="reference external" href="https://www.r-project.org/">R</a>. Part of the reason is the NumPy type hierarchy:</p> <table class="table"> <colgroup> <col style="width: 30.0%"> <col style="width: 70.0%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Typeclass</p></th> <th class="head"><p>Dtypes</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.floating</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">float16,</span> <span class="pre">float32,</span> <span class="pre">float64,</span> <span class="pre">float128</span></code></p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.integer</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">int8,</span> <span class="pre">int16,</span> <span class="pre">int32,</span> <span class="pre">int64</span></code></p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.unsignedinteger</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">uint8,</span> <span class="pre">uint16,</span> <span class="pre">uint32,</span> <span class="pre">uint64</span></code></p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.object_</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">object_</span></code></p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.bool_</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">bool_</span></code></p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">numpy.character</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">bytes_,</span> <span class="pre">str_</span></code></p></td> </tr> </tbody> </table> <p>The R language, by contrast, only has a handful of built-in data types: <code class="docutils literal notranslate"><span class="pre">integer</span></code>, <code class="docutils literal notranslate"><span class="pre">numeric</span></code> (floating-point), <code class="docutils literal notranslate"><span class="pre">character</span></code>, and <code class="docutils literal notranslate"><span class="pre">boolean</span></code>. <code class="docutils literal notranslate"><span class="pre">NA</span></code> types are implemented by reserving special bit patterns for each type to be used as the missing value. While doing this with the full NumPy type hierarchy would be possible, it would be a more substantial trade-off (especially for the 8- and 16-bit data types) and implementation undertaking.</p> <p>However, R <code class="docutils literal notranslate"><span class="pre">NA</span></code> semantics are now available by using masked NumPy types such as <a class="reference internal" href="../reference/api/pandas.int64dtype.html#pandas.Int64Dtype" title="pandas.Int64Dtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">Int64Dtype</span></code></a> or PyArrow types (<a class="reference internal" href="../reference/api/pandas.arrowdtype.html#pandas.ArrowDtype" title="pandas.ArrowDtype"><code class="xref py py-class docutils literal notranslate"><span class="pre">ArrowDtype</span></code></a>).</p> </section> </section> <section id="differences-with-numpy"> <h2>Differences with NumPy</h2> <p>For <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects, <a class="reference internal" href="../reference/api/pandas.dataframe.var.html#pandas.DataFrame.var" title="pandas.DataFrame.var"><code class="xref py py-meth docutils literal notranslate"><span class="pre">var()</span></code></a> normalizes by <code class="docutils literal notranslate"><span class="pre">N-1</span></code> to produce <a class="reference external" href="https://en.wikipedia.org/wiki/Bias_of_an_estimator">unbiased estimates of the population variance</a>, while NumPy’s <code class="xref py py-meth docutils literal notranslate"><span class="pre">numpy.var()</span></code> normalizes by N, which measures the variance of the sample. Note that <a class="reference internal" href="../reference/api/pandas.dataframe.cov.html#pandas.DataFrame.cov" title="pandas.DataFrame.cov"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cov()</span></code></a> normalizes by <code class="docutils literal notranslate"><span class="pre">N-1</span></code> in both pandas and NumPy.</p> </section> <section id="thread-safety"> <h2>Thread-safety</h2> <p>pandas is not 100% thread safe. The known issues relate to the <a class="reference internal" href="../reference/api/pandas.dataframe.copy.html#pandas.DataFrame.copy" title="pandas.DataFrame.copy"><code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code></a> method. If you are doing a lot of copying of <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects shared among threads, we recommend holding locks inside the threads where the data copying occurs.</p> <p>See <a class="reference external" href="https://stackoverflow.com/questions/13592618/python-pandas-dataframe-thread-safe">this link</a> for more information.</p> </section> <section id="byte-ordering-issues"> <h2>Byte-ordering issues</h2> <p>Occasionally you may have to deal with data that were created on a machine with a different byte order than the one on which you are running Python. A common symptom of this issue is an error like:</p> <div class="highlight-default notranslate">
<div class="highlight"><pre data-language="python">Traceback
    ...
ValueError: Big-endian buffer not supported on little-endian compiler
</pre></div> </div> <p>To deal with this issue you should convert the underlying NumPy array to the native system byte order <em>before</em> passing it to <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> or <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> constructors using something similar to the following:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [49]: x = np.array(list(range(10)), "&gt;i4")  # big endian

In [50]: newx = x.byteswap().view(x.dtype.newbyteorder())  # force native byteorder

In [51]: s = pd.Series(newx)
</pre></div> </div> <p>See <a class="reference external" href="https://numpy.org/doc/stable/user/basics.byteswapping.html">the NumPy documentation on byte order</a> for more details.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/gotchas.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/gotchas.html</a>
  </p>
</div>
