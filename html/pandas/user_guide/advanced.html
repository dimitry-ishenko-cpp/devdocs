<h1>MultiIndex / advanced indexing</h1> <p>This section covers <a class="reference internal" href="#advanced-hierarchical"><span class="std std-ref">indexing with a MultiIndex</span></a> and <a class="reference internal" href="#advanced-index-types"><span class="std std-ref">other advanced indexing features</span></a>.</p> <p>See the <a class="reference internal" href="indexing.html#indexing"><span class="std std-ref">Indexing and Selecting Data</span></a> for general indexing documentation.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Whether a copy or a reference is returned for a setting operation may depend on the context. This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided. See <a class="reference internal" href="indexing.html#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p> </div> <p>See the <a class="reference internal" href="cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <section id="hierarchical-indexing-multiindex"> <h2>Hierarchical indexing (MultiIndex)</h2> <p>Hierarchical / Multi-level indexing is very exciting as it opens the door to some quite sophisticated data analysis and manipulation, especially for working with higher dimensional data. In essence, it enables you to store and manipulate data with an arbitrary number of dimensions in lower dimensional data structures like <code class="docutils literal notranslate"><span class="pre">Series</span></code> (1d) and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> (2d).</p> <p>In this section, we will show what exactly we mean by “hierarchical” indexing and how it integrates with all of the pandas indexing functionality described above and in prior sections. Later, when discussing <a class="reference internal" href="groupby.html#groupby"><span class="std std-ref">group by</span></a> and <a class="reference internal" href="reshaping.html#reshaping"><span class="std std-ref">pivoting and reshaping data</span></a>, we’ll show non-trivial applications to illustrate how it aids in structuring data for analysis.</p> <p>See the <a class="reference internal" href="cookbook.html#cookbook-multi-index"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <section id="creating-a-multiindex-hierarchical-index-object"> <h3>Creating a MultiIndex (hierarchical index) object</h3> <p>The <a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> object is the hierarchical analogue of the standard <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> object which typically stores the axis labels in pandas objects. You can think of <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> as an array of tuples where each tuple is unique. A <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be created from a list of arrays (using <a class="reference internal" href="../reference/api/pandas.multiindex.from_arrays.html#pandas.MultiIndex.from_arrays" title="pandas.MultiIndex.from_arrays"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_arrays()</span></code></a>), an array of tuples (using <a class="reference internal" href="../reference/api/pandas.multiindex.from_tuples.html#pandas.MultiIndex.from_tuples" title="pandas.MultiIndex.from_tuples"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_tuples()</span></code></a>), a crossed set of iterables (using <a class="reference internal" href="../reference/api/pandas.multiindex.from_product.html#pandas.MultiIndex.from_product" title="pandas.MultiIndex.from_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code></a>), or a <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> (using <a class="reference internal" href="../reference/api/pandas.multiindex.from_frame.html#pandas.MultiIndex.from_frame" title="pandas.MultiIndex.from_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code></a>). The <code class="docutils literal notranslate"><span class="pre">Index</span></code> constructor will attempt to return a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when it is passed a list of tuples. The following examples demonstrate different ways to initialize MultiIndexes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: arrays = [
   ...:     ["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"],
   ...:     ["one", "two", "one", "two", "one", "two", "one", "two"],
   ...: ]
   ...: 

In [2]: tuples = list(zip(*arrays))

In [3]: tuples
Out[3]: 
[('bar', 'one'),
 ('bar', 'two'),
 ('baz', 'one'),
 ('baz', 'two'),
 ('foo', 'one'),
 ('foo', 'two'),
 ('qux', 'one'),
 ('qux', 'two')]

In [4]: index = pd.MultiIndex.from_tuples(tuples, names=["first", "second"])

In [5]: index
Out[5]: 
MultiIndex([('bar', 'one'),
            ('bar', 'two'),
            ('baz', 'one'),
            ('baz', 'two'),
            ('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])

In [6]: s = pd.Series(np.random.randn(8), index=index)

In [7]: s
Out[7]: 
first  second
bar    one       0.469112
       two      -0.282863
baz    one      -1.509059
       two      -1.135632
foo    one       1.212112
       two      -0.173215
qux    one       0.119209
       two      -1.044236
dtype: float64
</pre></div> </div> <p>When you want every pairing of the elements in two iterables, it can be easier to use the <a class="reference internal" href="../reference/api/pandas.multiindex.from_product.html#pandas.MultiIndex.from_product" title="pandas.MultiIndex.from_product"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_product()</span></code></a> method:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [8]: iterables = [["bar", "baz", "foo", "qux"], ["one", "two"]]

In [9]: pd.MultiIndex.from_product(iterables, names=["first", "second"])
Out[9]: 
MultiIndex([('bar', 'one'),
            ('bar', 'two'),
            ('baz', 'one'),
            ('baz', 'two'),
            ('foo', 'one'),
            ('foo', 'two'),
            ('qux', 'one'),
            ('qux', 'two')],
           names=['first', 'second'])
</pre></div> </div> <p>You can also construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> from a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> directly, using the method <a class="reference internal" href="../reference/api/pandas.multiindex.from_frame.html#pandas.MultiIndex.from_frame" title="pandas.MultiIndex.from_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.from_frame()</span></code></a>. This is a complementary method to <a class="reference internal" href="../reference/api/pandas.multiindex.to_frame.html#pandas.MultiIndex.to_frame" title="pandas.MultiIndex.to_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiIndex.to_frame()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [10]: df = pd.DataFrame(
   ....:     [["bar", "one"], ["bar", "two"], ["foo", "one"], ["foo", "two"]],
   ....:     columns=["first", "second"],
   ....: )
   ....: 

In [11]: pd.MultiIndex.from_frame(df)
Out[11]: 
MultiIndex([('bar', 'one'),
            ('bar', 'two'),
            ('foo', 'one'),
            ('foo', 'two')],
           names=['first', 'second'])
</pre></div> </div> <p>As a convenience, you can pass a list of arrays directly into <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to construct a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> automatically:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [12]: arrays = [
   ....:     np.array(["bar", "bar", "baz", "baz", "foo", "foo", "qux", "qux"]),
   ....:     np.array(["one", "two", "one", "two", "one", "two", "one", "two"]),
   ....: ]
   ....: 

In [13]: s = pd.Series(np.random.randn(8), index=arrays)

In [14]: s
Out[14]: 
bar  one   -0.861849
     two   -2.104569
baz  one   -0.494929
     two    1.071804
foo  one    0.721555
     two   -0.706771
qux  one   -1.039575
     two    0.271860
dtype: float64

In [15]: df = pd.DataFrame(np.random.randn(8, 4), index=arrays)

In [16]: df
Out[16]: 
                0         1         2         3
bar one -0.424972  0.567020  0.276232 -1.087401
    two -0.673690  0.113648 -1.478427  0.524988
baz one  0.404705  0.577046 -1.715002 -1.039268
    two -0.370647 -1.157892 -1.344312  0.844885
foo one  1.075770 -0.109050  1.643563 -1.469388
    two  0.357021 -0.674600 -1.776904 -0.968914
qux one -1.294524  0.413738  0.276662 -0.472035
    two -0.013960 -0.362543 -0.006154 -0.923061
</pre></div> </div> <p>All of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> constructors accept a <code class="docutils literal notranslate"><span class="pre">names</span></code> argument which stores string names for the levels themselves. If no names are provided, <code class="docutils literal notranslate"><span class="pre">None</span></code> will be assigned:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [17]: df.index.names
Out[17]: FrozenList([None, None])
</pre></div> </div> <p>This index can back any axis of a pandas object, and the number of <strong>levels</strong> of the index is up to you:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [18]: df = pd.DataFrame(np.random.randn(3, 8), index=["A", "B", "C"], columns=index)

In [19]: df
Out[19]: 
first        bar                 baz  ...       foo       qux          
second       one       two       one  ...       two       one       two
A       0.895717  0.805244 -1.206412  ...  1.340309 -1.170299 -0.226169
B       0.410835  0.813850  0.132003  ... -1.187678  1.130127 -1.436737
C      -1.413681  1.607920  1.024180  ... -2.211372  0.974466 -2.006747

[3 rows x 8 columns]

In [20]: pd.DataFrame(np.random.randn(6, 6), index=index[:6], columns=index[:6])
Out[20]: 
first              bar                 baz                 foo          
second             one       two       one       two       one       two
first second                                                            
bar   one    -0.410001 -0.078638  0.545952 -1.219217 -1.226825  0.769804
      two    -1.281247 -0.727707 -0.121306 -0.097883  0.695775  0.341734
baz   one     0.959726 -1.110336 -0.619976  0.149748 -0.732339  0.687738
      two     0.176444  0.403310 -0.154951  0.301624 -2.179861 -1.369849
foo   one    -0.954208  1.462696 -1.743161 -0.826591 -0.345352  1.314232
      two     0.690579  0.995761  2.396780  0.014871  3.357427 -0.317441
</pre></div> </div> <p>We’ve “sparsified” the higher levels of the indexes to make the console output a bit easier on the eyes. Note that how the index is displayed can be controlled using the <code class="docutils literal notranslate"><span class="pre">multi_sparse</span></code> option in <code class="docutils literal notranslate"><span class="pre">pandas.set_options()</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: with pd.option_context("display.multi_sparse", False):
   ....:     df
   ....: 
</pre></div> </div> <p>It’s worth keeping in mind that there’s nothing preventing you from using tuples as atomic labels on an axis:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [22]: pd.Series(np.random.randn(8), index=tuples)
Out[22]: 
(bar, one)   -1.236269
(bar, two)    0.896171
(baz, one)   -0.487602
(baz, two)   -0.082240
(foo, one)   -2.182937
(foo, two)    0.380396
(qux, one)    0.084844
(qux, two)    0.432390
dtype: float64
</pre></div> </div> <p>The reason that the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> matters is that it can allow you to do grouping, selection, and reshaping operations as we will describe below and in subsequent areas of the documentation. As you will see in later sections, you can find yourself working with hierarchically-indexed data without creating a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> explicitly yourself. However, when loading data from a file, you may wish to generate your own <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> when preparing the data set.</p> </section> <section id="reconstructing-the-level-labels"> <h3>Reconstructing the level labels</h3> <p>The method <a class="reference internal" href="../reference/api/pandas.multiindex.get_level_values.html#pandas.MultiIndex.get_level_values" title="pandas.MultiIndex.get_level_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code></a> will return a vector of the labels for each location at a particular level:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [23]: index.get_level_values(0)
Out[23]: Index(['bar', 'bar', 'baz', 'baz', 'foo', 'foo', 'qux', 'qux'], dtype='object', name='first')

In [24]: index.get_level_values("second")
Out[24]: Index(['one', 'two', 'one', 'two', 'one', 'two', 'one', 'two'], dtype='object', name='second')
</pre></div> </div> </section> <section id="basic-indexing-on-axis-with-multiindex"> <h3>Basic indexing on axis with MultiIndex</h3> <p>One of the important features of hierarchical indexing is that you can select data by a “partial” label identifying a subgroup in the data. <strong>Partial</strong> selection “drops” levels of the hierarchical index in the result in a completely analogous way to selecting a column in a regular DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: df["bar"]
Out[25]: 
second       one       two
A       0.895717  0.805244
B       0.410835  0.813850
C      -1.413681  1.607920

In [26]: df["bar", "one"]
Out[26]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), dtype: float64

In [27]: df["bar"]["one"]
Out[27]: 
A    0.895717
B    0.410835
C   -1.413681
Name: one, dtype: float64

In [28]: s["qux"]
Out[28]: 
one   -1.039575
two    0.271860
dtype: float64
</pre></div> </div> <p>See <a class="reference internal" href="#advanced-xs"><span class="std std-ref">Cross-section with hierarchical index</span></a> for how to select on a deeper level.</p> </section> <section id="defined-levels"> <h3>Defined levels</h3> <p>The <a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> keeps all the defined levels of an index, even if they are not actually used. When slicing an index, you may notice this. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [29]: df.columns.levels  # original MultiIndex
Out[29]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']])

In [30]: df[["foo","qux"]].columns.levels  # sliced
Out[30]: FrozenList([['bar', 'baz', 'foo', 'qux'], ['one', 'two']])
</pre></div> </div> <p>This is done to avoid a recomputation of the levels in order to make slicing highly performant. If you want to see only the used levels, you can use the <a class="reference internal" href="../reference/api/pandas.multiindex.get_level_values.html#pandas.MultiIndex.get_level_values" title="pandas.MultiIndex.get_level_values"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get_level_values()</span></code></a> method.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [31]: df[["foo", "qux"]].columns.to_numpy()
Out[31]: 
array([('foo', 'one'), ('foo', 'two'), ('qux', 'one'), ('qux', 'two')],
      dtype=object)

# for a specific level
In [32]: df[["foo", "qux"]].columns.get_level_values(0)
Out[32]: Index(['foo', 'foo', 'qux', 'qux'], dtype='object', name='first')
</pre></div> </div> <p>To reconstruct the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> with only the used levels, the <a class="reference internal" href="../reference/api/pandas.multiindex.remove_unused_levels.html#pandas.MultiIndex.remove_unused_levels" title="pandas.MultiIndex.remove_unused_levels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove_unused_levels()</span></code></a> method may be used.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [33]: new_mi = df[["foo", "qux"]].columns.remove_unused_levels()

In [34]: new_mi.levels
Out[34]: FrozenList([['foo', 'qux'], ['one', 'two']])
</pre></div> </div> </section> <section id="data-alignment-and-using-reindex"> <h3>Data alignment and using <code class="docutils literal notranslate"><span class="pre">reindex</span></code>
</h3> <p>Operations between differently-indexed objects having <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> on the axes will work as you expect; data alignment will work the same as an Index of tuples:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [35]: s + s[:-2]
Out[35]: 
bar  one   -1.723698
     two   -4.209138
baz  one   -0.989859
     two    2.143608
foo  one    1.443110
     two   -1.413542
qux  one         NaN
     two         NaN
dtype: float64

In [36]: s + s[::2]
Out[36]: 
bar  one   -1.723698
     two         NaN
baz  one   -0.989859
     two         NaN
foo  one    1.443110
     two         NaN
qux  one   -2.079150
     two         NaN
dtype: float64
</pre></div> </div> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>/<code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> can be called with another <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, or even a list or array of tuples:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [37]: s.reindex(index[:3])
Out[37]: 
first  second
bar    one      -0.861849
       two      -2.104569
baz    one      -0.494929
dtype: float64

In [38]: s.reindex([("foo", "two"), ("bar", "one"), ("qux", "one"), ("baz", "one")])
Out[38]: 
foo  two   -0.706771
bar  one   -0.861849
qux  one   -1.039575
baz  one   -0.494929
dtype: float64
</pre></div> </div> </section> </section> <section id="advanced-indexing-with-hierarchical-index"> <h2>Advanced indexing with hierarchical index</h2> <p>Syntactically integrating <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in advanced indexing with <code class="docutils literal notranslate"><span class="pre">.loc</span></code> is a bit challenging, but we’ve made every effort to do so. In general, MultiIndex keys take the form of tuples. For example, the following works as you would expect:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: df = df.T

In [40]: df
Out[40]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [41]: df.loc[("bar", "two")]
Out[41]: 
A    0.805244
B    0.813850
C    1.607920
Name: (bar, two), dtype: float64
</pre></div> </div> <p>Note that <code class="docutils literal notranslate"><span class="pre">df.loc['bar',</span> <span class="pre">'two']</span></code> would also work in this example, but this shorthand notation can lead to ambiguity in general.</p> <p>If you also want to index a specific column with <code class="docutils literal notranslate"><span class="pre">.loc</span></code>, you must use a tuple like this:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: df.loc[("bar", "two"), "A"]
Out[42]: 0.8052440253863785
</pre></div> </div> <p>You don’t have to specify all levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by passing only the first elements of the tuple. For example, you can use “partial” indexing to get all elements with <code class="docutils literal notranslate"><span class="pre">bar</span></code> in the first level as follows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [43]: df.loc["bar"]
Out[43]: 
               A         B         C
second                              
one     0.895717  0.410835 -1.413681
two     0.805244  0.813850  1.607920
</pre></div> </div> <p>This is a shortcut for the slightly more verbose notation <code class="docutils literal notranslate"><span class="pre">df.loc[('bar',),]</span></code> (equivalent to <code class="docutils literal notranslate"><span class="pre">df.loc['bar',]</span></code> in this example).</p> <p>“Partial” slicing also works quite nicely.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [44]: df.loc["baz":"foo"]
Out[44]: 
                     A         B         C
first second                              
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
</pre></div> </div> <p>You can slice with a ‘range’ of values, by providing a slice of tuples.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [45]: df.loc[("baz", "two"):("qux", "one")]
Out[45]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466

In [46]: df.loc[("baz", "two"):"foo"]
Out[46]: 
                     A         B         C
first second                              
baz   two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
</pre></div> </div> <p>Passing a list of labels or tuples works similar to reindexing:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [47]: df.loc[[("bar", "two"), ("qux", "one")]]
Out[47]: 
                     A         B         C
first second                              
bar   two     0.805244  0.813850  1.607920
qux   one    -1.170299  1.130127  0.974466
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>It is important to note that tuples and lists are not treated identically in pandas when it comes to indexing. Whereas a tuple is interpreted as one multi-level key, a list is used to specify several keys. Or in other words, tuples go horizontally (traversing levels), lists go vertically (scanning levels).</p> </div> <p>Importantly, a list of tuples indexes several complete <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> keys, whereas a tuple of lists refer to several values within a level:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [48]: s = pd.Series(
   ....:     [1, 2, 3, 4, 5, 6],
   ....:     index=pd.MultiIndex.from_product([["A", "B"], ["c", "d", "e"]]),
   ....: )
   ....: 

In [49]: s.loc[[("A", "c"), ("B", "d")]]  # list of tuples
Out[49]: 
A  c    1
B  d    5
dtype: int64

In [50]: s.loc[(["A", "B"], ["c", "d"])]  # tuple of lists
Out[50]: 
A  c    1
   d    2
B  c    4
   d    5
dtype: int64
</pre></div> </div> <section id="using-slicers"> <h3>Using slicers</h3> <p>You can slice a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> by providing multiple indexers.</p> <p>You can provide any of the selectors as if you are indexing by label, see <a class="reference internal" href="indexing.html#indexing-label"><span class="std std-ref">Selection by Label</span></a>, including slices, lists of labels, labels, and boolean indexers.</p> <p>You can use <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code> to select all the contents of <em>that</em> level. You do not need to specify all the <em>deeper</em> levels, they will be implied as <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p> <p>As usual, <strong>both sides</strong> of the slicers are included as this is label indexing.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>You should specify all axes in the <code class="docutils literal notranslate"><span class="pre">.loc</span></code> specifier, meaning the indexer for the <strong>index</strong> and for the <strong>columns</strong>. There are some ambiguous cases where the passed indexer could be misinterpreted as indexing <em>both</em> axes, rather than into say the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the rows.</p> <p>You should do this:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.loc[(slice("A1", "A3"), ...), :]  # noqa: E999
</pre></div> </div> <p>You should <strong>not</strong> do this:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.loc[(slice("A1", "A3"), ...)]  # noqa: E999
</pre></div> </div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [51]: def mklbl(prefix, n):
   ....:     return ["%s%s" % (prefix, i) for i in range(n)]
   ....: 

In [52]: miindex = pd.MultiIndex.from_product(
   ....:     [mklbl("A", 4), mklbl("B", 2), mklbl("C", 4), mklbl("D", 2)]
   ....: )
   ....: 

In [53]: micolumns = pd.MultiIndex.from_tuples(
   ....:     [("a", "foo"), ("a", "bar"), ("b", "foo"), ("b", "bah")], names=["lvl0", "lvl1"]
   ....: )
   ....: 

In [54]: dfmi = (
   ....:     pd.DataFrame(
   ....:         np.arange(len(miindex) * len(micolumns)).reshape(
   ....:             (len(miindex), len(micolumns))
   ....:         ),
   ....:         index=miindex,
   ....:         columns=micolumns,
   ....:     )
   ....:     .sort_index()
   ....:     .sort_index(axis=1)
   ....: )
   ....: 

In [55]: dfmi
Out[55]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C0 D0    1    0    3    2
         D1    5    4    7    6
      C1 D0    9    8   11   10
         D1   13   12   15   14
      C2 D0   17   16   19   18
...          ...  ...  ...  ...
A3 B1 C1 D1  237  236  239  238
      C2 D0  241  240  243  242
         D1  245  244  247  246
      C3 D0  249  248  251  250
         D1  253  252  255  254

[64 rows x 4 columns]
</pre></div> </div> <p>Basic MultiIndex slicing using slices, lists, and labels.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [56]: dfmi.loc[(slice("A1", "A3"), slice(None), ["C1", "C3"]), :]
Out[56]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A1 B0 C1 D0   73   72   75   74
         D1   77   76   79   78
      C3 D0   89   88   91   90
         D1   93   92   95   94
   B1 C1 D0  105  104  107  106
...          ...  ...  ...  ...
A3 B0 C3 D1  221  220  223  222
   B1 C1 D0  233  232  235  234
         D1  237  236  239  238
      C3 D0  249  248  251  250
         D1  253  252  255  254

[24 rows x 4 columns]
</pre></div> </div> <p>You can use <a class="reference internal" href="../reference/api/pandas.indexslice.html#pandas.IndexSlice" title="pandas.IndexSlice"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.IndexSlice</span></code></a> to facilitate a more natural syntax using <code class="docutils literal notranslate"><span class="pre">:</span></code>, rather than using <code class="docutils literal notranslate"><span class="pre">slice(None)</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: idx = pd.IndexSlice

In [58]: dfmi.loc[idx[:, :, ["C1", "C3"]], idx[:, "foo"]]
Out[58]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
...          ...  ...
A3 B0 C3 D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]
</pre></div> </div> <p>It is possible to perform quite complicated selections using this method on multiple axes at the same time.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [59]: dfmi.loc["A1", (slice(None), "foo")]
Out[59]: 
lvl0        a    b
lvl1      foo  foo
B0 C0 D0   64   66
      D1   68   70
   C1 D0   72   74
      D1   76   78
   C2 D0   80   82
...       ...  ...
B1 C1 D1  108  110
   C2 D0  112  114
      D1  116  118
   C3 D0  120  122
      D1  124  126

[16 rows x 2 columns]

In [60]: dfmi.loc[idx[:, :, ["C1", "C3"]], idx[:, "foo"]]
Out[60]: 
lvl0           a    b
lvl1         foo  foo
A0 B0 C1 D0    8   10
         D1   12   14
      C3 D0   24   26
         D1   28   30
   B1 C1 D0   40   42
...          ...  ...
A3 B0 C3 D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254

[32 rows x 2 columns]
</pre></div> </div> <p>Using a boolean indexer you can provide selection related to the <em>values</em>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [61]: mask = dfmi[("a", "foo")] &gt; 200

In [62]: dfmi.loc[idx[mask, :, ["C1", "C3"]], idx[:, "foo"]]
Out[62]: 
lvl0           a    b
lvl1         foo  foo
A3 B0 C1 D1  204  206
      C3 D0  216  218
         D1  220  222
   B1 C1 D0  232  234
         D1  236  238
      C3 D0  248  250
         D1  252  254
</pre></div> </div> <p>You can also specify the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument to <code class="docutils literal notranslate"><span class="pre">.loc</span></code> to interpret the passed slicers on a single axis.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [63]: dfmi.loc(axis=0)[:, :, ["C1", "C3"]]
Out[63]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C1 D0    9    8   11   10
         D1   13   12   15   14
      C3 D0   25   24   27   26
         D1   29   28   31   30
   B1 C1 D0   41   40   43   42
...          ...  ...  ...  ...
A3 B0 C3 D1  221  220  223  222
   B1 C1 D0  233  232  235  234
         D1  237  236  239  238
      C3 D0  249  248  251  250
         D1  253  252  255  254

[32 rows x 4 columns]
</pre></div> </div> <p>Furthermore, you can <em>set</em> the values using the following methods.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [64]: df2 = dfmi.copy()

In [65]: df2.loc(axis=0)[:, :, ["C1", "C3"]] = -10

In [66]: df2
Out[66]: 
lvl0           a         b     
lvl1         bar  foo  bah  foo
A0 B0 C0 D0    1    0    3    2
         D1    5    4    7    6
      C1 D0  -10  -10  -10  -10
         D1  -10  -10  -10  -10
      C2 D0   17   16   19   18
...          ...  ...  ...  ...
A3 B1 C1 D1  -10  -10  -10  -10
      C2 D0  241  240  243  242
         D1  245  244  247  246
      C3 D0  -10  -10  -10  -10
         D1  -10  -10  -10  -10

[64 rows x 4 columns]
</pre></div> </div> <p>You can use a right-hand-side of an alignable object as well.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [67]: df2 = dfmi.copy()

In [68]: df2.loc[idx[:, :, ["C1", "C3"]], :] = df2 * 1000

In [69]: df2
Out[69]: 
lvl0              a               b        
lvl1            bar     foo     bah     foo
A0 B0 C0 D0       1       0       3       2
         D1       5       4       7       6
      C1 D0    9000    8000   11000   10000
         D1   13000   12000   15000   14000
      C2 D0      17      16      19      18
...             ...     ...     ...     ...
A3 B1 C1 D1  237000  236000  239000  238000
      C2 D0     241     240     243     242
         D1     245     244     247     246
      C3 D0  249000  248000  251000  250000
         D1  253000  252000  255000  254000

[64 rows x 4 columns]
</pre></div> </div> </section> <section id="cross-section"> <h3>Cross-section</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.xs.html#pandas.DataFrame.xs" title="pandas.DataFrame.xs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">xs()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> additionally takes a level argument to make selecting data at a particular level of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> easier.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: df
Out[70]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
      two     0.805244  0.813850  1.607920
baz   one    -1.206412  0.132003  1.024180
      two     2.565646 -0.827317  0.569605
foo   one     1.431256 -0.076467  0.875906
      two     1.340309 -1.187678 -2.211372
qux   one    -1.170299  1.130127  0.974466
      two    -0.226169 -1.436737 -2.006747

In [71]: df.xs("one", level="second")
Out[71]: 
              A         B         C
first                              
bar    0.895717  0.410835 -1.413681
baz   -1.206412  0.132003  1.024180
foo    1.431256 -0.076467  0.875906
qux   -1.170299  1.130127  0.974466
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># using the slicers
In [72]: df.loc[(slice(None), "one"), :]
Out[72]: 
                     A         B         C
first second                              
bar   one     0.895717  0.410835 -1.413681
baz   one    -1.206412  0.132003  1.024180
foo   one     1.431256 -0.076467  0.875906
qux   one    -1.170299  1.130127  0.974466
</pre></div> </div> <p>You can also select on the columns with <code class="docutils literal notranslate"><span class="pre">xs</span></code>, by providing the axis argument.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [73]: df = df.T

In [74]: df.xs("one", level="second", axis=1)
Out[74]: 
first       bar       baz       foo       qux
A      0.895717 -1.206412  1.431256 -1.170299
B      0.410835  0.132003 -0.076467  1.130127
C     -1.413681  1.024180  0.875906  0.974466
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># using the slicers
In [75]: df.loc[:, (slice(None), "one")]
Out[75]: 
first        bar       baz       foo       qux
second       one       one       one       one
A       0.895717 -1.206412  1.431256 -1.170299
B       0.410835  0.132003 -0.076467  1.130127
C      -1.413681  1.024180  0.875906  0.974466
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">xs</span></code> also allows selection with multiple keys.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [76]: df.xs(("one", "bar"), level=("second", "first"), axis=1)
Out[76]: 
first        bar
second       one
A       0.895717
B       0.410835
C      -1.413681
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># using the slicers
In [77]: df.loc[:, ("bar", "one")]
Out[77]: 
A    0.895717
B    0.410835
C   -1.413681
Name: (bar, one), dtype: float64
</pre></div> </div> <p>You can pass <code class="docutils literal notranslate"><span class="pre">drop_level=False</span></code> to <code class="docutils literal notranslate"><span class="pre">xs</span></code> to retain the level that was selected.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [78]: df.xs("one", level="second", axis=1, drop_level=False)
Out[78]: 
first        bar       baz       foo       qux
second       one       one       one       one
A       0.895717 -1.206412  1.431256 -1.170299
B       0.410835  0.132003 -0.076467  1.130127
C      -1.413681  1.024180  0.875906  0.974466
</pre></div> </div> <p>Compare the above with the result using <code class="docutils literal notranslate"><span class="pre">drop_level=True</span></code> (the default value).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: df.xs("one", level="second", axis=1, drop_level=True)
Out[79]: 
first       bar       baz       foo       qux
A      0.895717 -1.206412  1.431256 -1.170299
B      0.410835  0.132003 -0.076467  1.130127
C     -1.413681  1.024180  0.875906  0.974466
</pre></div> </div> </section> <section id="advanced-reindexing-and-alignment"> <h3>Advanced reindexing and alignment</h3> <p>Using the parameter <code class="docutils literal notranslate"><span class="pre">level</span></code> in the <a class="reference internal" href="../reference/api/pandas.dataframe.reindex.html#pandas.DataFrame.reindex" title="pandas.DataFrame.reindex"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reindex()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.align.html#pandas.DataFrame.align" title="pandas.DataFrame.align"><code class="xref py py-meth docutils literal notranslate"><span class="pre">align()</span></code></a> methods of pandas objects is useful to broadcast values across a level. For instance:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [80]: midx = pd.MultiIndex(
   ....:     levels=[["zero", "one"], ["x", "y"]], codes=[[1, 1, 0, 0], [1, 0, 1, 0]]
   ....: )
   ....: 

In [81]: df = pd.DataFrame(np.random.randn(4, 2), index=midx)

In [82]: df
Out[82]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [83]: df2 = df.groupby(level=0).mean()

In [84]: df2
Out[84]: 
             0         1
one   1.060074 -0.109716
zero  1.271532  0.713416

In [85]: df2.reindex(df.index, level=0)
Out[85]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416

# aligning
In [86]: df_aligned, df2_aligned = df.align(df2, level=0)

In [87]: df_aligned
Out[87]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [88]: df2_aligned
Out[88]: 
               0         1
one  y  1.060074 -0.109716
     x  1.060074 -0.109716
zero y  1.271532  0.713416
     x  1.271532  0.713416
</pre></div> </div> </section> <section id="swapping-levels-with-swaplevel"> <h3>Swapping levels with <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code>
</h3> <p>The <a class="reference internal" href="../reference/api/pandas.multiindex.swaplevel.html#pandas.MultiIndex.swaplevel" title="pandas.MultiIndex.swaplevel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">swaplevel()</span></code></a> method can switch the order of two levels:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [89]: df[:5]
Out[89]: 
               0         1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520

In [90]: df[:5].swaplevel(0, 1, axis=0)
Out[90]: 
               0         1
y one   1.519970 -0.493662
x one   0.600178  0.274230
y zero  0.132885 -0.023688
x zero  2.410179  1.450520
</pre></div> </div> </section> <section id="reordering-levels-with-reorder-levels"> <h3>Reordering levels with <code class="docutils literal notranslate"><span class="pre">reorder_levels</span></code>
</h3> <p>The <a class="reference internal" href="../reference/api/pandas.multiindex.reorder_levels.html#pandas.MultiIndex.reorder_levels" title="pandas.MultiIndex.reorder_levels"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reorder_levels()</span></code></a> method generalizes the <code class="docutils literal notranslate"><span class="pre">swaplevel</span></code> method, allowing you to permute the hierarchical index levels in one step:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [91]: df[:5].reorder_levels([1, 0], axis=0)
Out[91]: 
               0         1
y one   1.519970 -0.493662
x one   0.600178  0.274230
y zero  0.132885 -0.023688
x zero  2.410179  1.450520
</pre></div> </div> </section> <section id="renaming-names-of-an-index-or-multiindex"> <h3>Renaming names of an <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>
</h3> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.rename.html#pandas.DataFrame.rename" title="pandas.DataFrame.rename"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename()</span></code></a> method is used to rename the labels of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, and is typically used to rename the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>. The <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument of <code class="docutils literal notranslate"><span class="pre">rename</span></code> allows a dictionary to be specified that includes only the columns you wish to rename.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [92]: df.rename(columns={0: "col0", 1: "col1"})
Out[92]: 
            col0      col1
one  y  1.519970 -0.493662
     x  0.600178  0.274230
zero y  0.132885 -0.023688
     x  2.410179  1.450520
</pre></div> </div> <p>This method can also be used to rename specific labels of the main index of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [93]: df.rename(index={"one": "two", "y": "z"})
Out[93]: 
               0         1
two  z  1.519970 -0.493662
     x  0.600178  0.274230
zero z  0.132885 -0.023688
     x  2.410179  1.450520
</pre></div> </div> <p>The <a class="reference internal" href="../reference/api/pandas.dataframe.rename_axis.html#pandas.DataFrame.rename_axis" title="pandas.DataFrame.rename_axis"><code class="xref py py-meth docutils literal notranslate"><span class="pre">rename_axis()</span></code></a> method is used to rename the name of a <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>. In particular, the names of the levels of a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be specified, which is useful if <code class="docutils literal notranslate"><span class="pre">reset_index()</span></code> is later used to move the values from the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> to a column.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [94]: df.rename_axis(index=["abc", "def"])
Out[94]: 
                 0         1
abc  def                    
one  y    1.519970 -0.493662
     x    0.600178  0.274230
zero y    0.132885 -0.023688
     x    2.410179  1.450520
</pre></div> </div> <p>Note that the columns of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> are an index, so that using <code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> with the <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument will change the name of that index.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [95]: df.rename_axis(columns="Cols").columns
Out[95]: RangeIndex(start=0, stop=2, step=1, name='Cols')
</pre></div> </div> <p>Both <code class="docutils literal notranslate"><span class="pre">rename</span></code> and <code class="docutils literal notranslate"><span class="pre">rename_axis</span></code> support specifying a dictionary, <code class="docutils literal notranslate"><span class="pre">Series</span></code> or a mapping function to map labels/names to new values.</p> <p>When working with an <code class="docutils literal notranslate"><span class="pre">Index</span></code> object directly, rather than via a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, <a class="reference internal" href="../reference/api/pandas.index.set_names.html#pandas.Index.set_names" title="pandas.Index.set_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.set_names()</span></code></a> can be used to change the names.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [96]: mi = pd.MultiIndex.from_product([[1, 2], ["a", "b"]], names=["x", "y"])

In [97]: mi.names
Out[97]: FrozenList(['x', 'y'])

In [98]: mi2 = mi.rename("new name", level=0)

In [99]: mi2
Out[99]: 
MultiIndex([(1, 'a'),
            (1, 'b'),
            (2, 'a'),
            (2, 'b')],
           names=['new name', 'y'])
</pre></div> </div> <p>You cannot set the names of the MultiIndex via a level.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [100]: mi.levels[0].name = "name via level"
---------------------------------------------------------------------------
RuntimeError                              Traceback (most recent call last)
Cell In[100], line 1
----&gt; 1 mi.levels[0].name = "name via level"

File ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)
   1686 @name.setter
   1687 def name(self, value: Hashable) -&gt; None:
   1688     if self._no_setting_name:
   1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.
-&gt; 1690         raise RuntimeError(
   1691             "Cannot set name on a level of a MultiIndex. Use "
   1692             "'MultiIndex.set_names' instead."
   1693         )
   1694     maybe_extract_name(value, None, type(self))
   1695     self._name = value

RuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.
</pre></div> </div> <p>Use <a class="reference internal" href="../reference/api/pandas.index.set_names.html#pandas.Index.set_names" title="pandas.Index.set_names"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.set_names()</span></code></a> instead.</p> </section> </section> <section id="sorting-a-multiindex"> <h2>Sorting a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>
</h2> <p>For <a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a>-ed objects to be indexed and sliced effectively, they need to be sorted. As with any index, you can use <a class="reference internal" href="../reference/api/pandas.dataframe.sort_index.html#pandas.DataFrame.sort_index" title="pandas.DataFrame.sort_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_index()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [101]: import random

In [102]: random.shuffle(tuples)

In [103]: s = pd.Series(np.random.randn(8), index=pd.MultiIndex.from_tuples(tuples))

In [104]: s
Out[104]: 
qux  two    0.206053
bar  one   -0.251905
foo  one   -2.213588
qux  one    1.063327
foo  two    1.266143
baz  two    0.299368
bar  two   -0.863838
baz  one    0.408204
dtype: float64

In [105]: s.sort_index()
Out[105]: 
bar  one   -0.251905
     two   -0.863838
baz  one    0.408204
     two    0.299368
foo  one   -2.213588
     two    1.266143
qux  one    1.063327
     two    0.206053
dtype: float64

In [106]: s.sort_index(level=0)
Out[106]: 
bar  one   -0.251905
     two   -0.863838
baz  one    0.408204
     two    0.299368
foo  one   -2.213588
     two    1.266143
qux  one    1.063327
     two    0.206053
dtype: float64

In [107]: s.sort_index(level=1)
Out[107]: 
bar  one   -0.251905
baz  one    0.408204
foo  one   -2.213588
qux  one    1.063327
bar  two   -0.863838
baz  two    0.299368
foo  two    1.266143
qux  two    0.206053
dtype: float64
</pre></div> </div> <p id="advanced-sortlevel-byname">You may also pass a level name to <code class="docutils literal notranslate"><span class="pre">sort_index</span></code> if the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels are named.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [108]: s.index = s.index.set_names(["L1", "L2"])

In [109]: s.sort_index(level="L1")
Out[109]: 
L1   L2 
bar  one   -0.251905
     two   -0.863838
baz  one    0.408204
     two    0.299368
foo  one   -2.213588
     two    1.266143
qux  one    1.063327
     two    0.206053
dtype: float64

In [110]: s.sort_index(level="L2")
Out[110]: 
L1   L2 
bar  one   -0.251905
baz  one    0.408204
foo  one   -2.213588
qux  one    1.063327
bar  two   -0.863838
baz  two    0.299368
foo  two    1.266143
qux  two    0.206053
dtype: float64
</pre></div> </div> <p>On higher dimensional objects, you can sort any of the other axes by level if they have a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [111]: df.T.sort_index(level=1, axis=1)
Out[111]: 
        one      zero       one      zero
          x         x         y         y
0  0.600178  2.410179  1.519970  0.132885
1  0.274230  1.450520 -0.493662 -0.023688
</pre></div> </div> <p>Indexing will work even if the data are not sorted, but will be rather inefficient (and show a <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code>). It will also return a copy of the data rather than a view:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: dfm = pd.DataFrame(
   .....:     {"jim": [0, 0, 1, 1], "joe": ["x", "x", "z", "y"], "jolie": np.random.rand(4)}
   .....: )
   .....: 

In [113]: dfm = dfm.set_index(["jim", "joe"])

In [114]: dfm
Out[114]: 
            jolie
jim joe          
0   x    0.490671
    x    0.120248
1   z    0.537020
    y    0.110968

In [115]: dfm.loc[(1, 'z')]
Out[115]: 
           jolie
jim joe         
1   z    0.53702
</pre></div> </div> <p id="advanced-unsorted">Furthermore, if you try to index something that is not fully lexsorted, this can raise:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [116]: dfm.loc[(0, 'y'):(1, 'z')]
---------------------------------------------------------------------------
UnsortedIndexError                        Traceback (most recent call last)
Cell In[116], line 1
----&gt; 1 dfm.loc[(0, 'y'):(1, 'z')]

File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)
   1189 maybe_callable = com.apply_if_callable(key, self.obj)
   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)
-&gt; 1191 return self._getitem_axis(maybe_callable, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)
   1409 if isinstance(key, slice):
   1410     self._validate_key(key, axis)
-&gt; 1411     return self._get_slice_axis(key, axis=axis)
   1412 elif com.is_bool_indexer(key):
   1413     return self._getbool_axis(key, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)
   1440     return obj.copy(deep=False)
   1442 labels = obj._get_axis(axis)
-&gt; 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)
   1445 if isinstance(indexer, slice):
   1446     return self.obj._slice(indexer, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)
   6618 def slice_indexer(
   6619     self,
   6620     start: Hashable | None = None,
   6621     end: Hashable | None = None,
   6622     step: int | None = None,
   6623 ) -&gt; slice:
   6624     """
   6625     Compute the slice indexer for input labels and step.
   6626 
   (...)
   6660     slice(1, 3, None)
   6661     """
-&gt; 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)
   6664     # return a slice
   6665     if not is_scalar(start_slice):

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:2904, in MultiIndex.slice_locs(self, start, end, step)
   2852 """
   2853 For an ordered MultiIndex, compute the slice locations for input
   2854 labels.
   (...)
   2900                       sequence of such.
   2901 """
   2902 # This function adds nothing to its parent implementation (the magic
   2903 # happens in get_slice_bound method), but it adds meaningful doc.
-&gt; 2904 return super().slice_locs(start, end, step)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)
   6877 start_slice = None
   6878 if start is not None:
-&gt; 6879     start_slice = self.get_slice_bound(start, "left")
   6880 if start_slice is None:
   6881     start_slice = 0

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:2848, in MultiIndex.get_slice_bound(self, label, side)
   2846 if not isinstance(label, tuple):
   2847     label = (label,)
-&gt; 2848 return self._partial_tup_index(label, side=side)

File ~/work/pandas/pandas/pandas/core/indexes/multi.py:2908, in MultiIndex._partial_tup_index(self, tup, side)
   2906 def _partial_tup_index(self, tup: tuple, side: Literal["left", "right"] = "left"):
   2907     if len(tup) &gt; self._lexsort_depth:
-&gt; 2908         raise UnsortedIndexError(
   2909             f"Key length ({len(tup)}) was greater than MultiIndex lexsort depth "
   2910             f"({self._lexsort_depth})"
   2911         )
   2913     n = len(tup)
   2914     start, end = 0, len(self)

UnsortedIndexError: 'Key length (2) was greater than MultiIndex lexsort depth (1)'
</pre></div> </div> <p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_increasing()</span></code> method on a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> shows if the index is sorted:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [117]: dfm.index.is_monotonic_increasing
Out[117]: False
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [118]: dfm = dfm.sort_index()

In [119]: dfm
Out[119]: 
            jolie
jim joe          
0   x    0.490671
    x    0.120248
1   y    0.110968
    z    0.537020

In [120]: dfm.index.is_monotonic_increasing
Out[120]: True
</pre></div> </div> <p>And now selection works as expected.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [121]: dfm.loc[(0, "y"):(1, "z")]
Out[121]: 
            jolie
jim joe          
1   y    0.110968
    z    0.537020
</pre></div> </div> </section> <section id="take-methods"> <h2>Take methods</h2> <p id="advanced-take">Similar to NumPy ndarrays, pandas <code class="docutils literal notranslate"><span class="pre">Index</span></code>, <code class="docutils literal notranslate"><span class="pre">Series</span></code>, and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> also provides the <a class="reference internal" href="../reference/api/pandas.dataframe.take.html#pandas.DataFrame.take" title="pandas.DataFrame.take"><code class="xref py py-meth docutils literal notranslate"><span class="pre">take()</span></code></a> method that retrieves elements along a given axis at the given indices. The given indices must be either a list or an ndarray of integer index positions. <code class="docutils literal notranslate"><span class="pre">take</span></code> will also accept negative integers as relative positions to the end of the object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [122]: index = pd.Index(np.random.randint(0, 1000, 10))

In [123]: index
Out[123]: Index([214, 502, 712, 567, 786, 175, 993, 133, 758, 329], dtype='int64')

In [124]: positions = [0, 9, 3]

In [125]: index[positions]
Out[125]: Index([214, 329, 567], dtype='int64')

In [126]: index.take(positions)
Out[126]: Index([214, 329, 567], dtype='int64')

In [127]: ser = pd.Series(np.random.randn(10))

In [128]: ser.iloc[positions]
Out[128]: 
0   -0.179666
9    1.824375
3    0.392149
dtype: float64

In [129]: ser.take(positions)
Out[129]: 
0   -0.179666
9    1.824375
3    0.392149
dtype: float64
</pre></div> </div> <p>For DataFrames, the given indices should be a 1d list or ndarray that specifies row or column positions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [130]: frm = pd.DataFrame(np.random.randn(5, 3))

In [131]: frm.take([1, 4, 3])
Out[131]: 
          0         1         2
1 -1.237881  0.106854 -1.276829
4  0.629675 -1.425966  1.857704
3  0.979542 -1.633678  0.615855

In [132]: frm.take([0, 2], axis=1)
Out[132]: 
          0         2
0  0.595974  0.601544
1 -1.237881 -1.276829
2 -0.767101  1.499591
3  0.979542  0.615855
4  0.629675  1.857704
</pre></div> </div> <p>It is important to note that the <code class="docutils literal notranslate"><span class="pre">take</span></code> method on pandas objects are not intended to work on boolean indices and may return unexpected results.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [133]: arr = np.random.randn(10)

In [134]: arr.take([False, False, True, True])
Out[134]: array([-1.1935, -1.1935,  0.6775,  0.6775])

In [135]: arr[[0, 1]]
Out[135]: array([-1.1935,  0.6775])

In [136]: ser = pd.Series(np.random.randn(10))

In [137]: ser.take([False, False, True, True])
Out[137]: 
0    0.233141
0    0.233141
1   -0.223540
1   -0.223540
dtype: float64

In [138]: ser.iloc[[0, 1]]
Out[138]: 
0    0.233141
1   -0.223540
dtype: float64
</pre></div> </div> <p>Finally, as a small note on performance, because the <code class="docutils literal notranslate"><span class="pre">take</span></code> method handles a narrower range of inputs, it can offer performance that is a good deal faster than fancy indexing.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [139]: arr = np.random.randn(10000, 5)

In [140]: indexer = np.arange(10000)

In [141]: random.shuffle(indexer)

In [142]: %timeit arr[indexer]
   .....: %timeit arr.take(indexer, axis=0)
   .....: 
257 us +- 4.44 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each)
79.7 us +- 1.15 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each)
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [143]: ser = pd.Series(arr[:, 0])

In [144]: %timeit ser.iloc[indexer]
   .....: %timeit ser.take(indexer)
   .....: 
144 us +- 3.69 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each)
129 us +- 2 us per loop (mean +- std. dev. of 7 runs, 10,000 loops each)
</pre></div> </div> </section> <section id="index-types"> <h2>Index types</h2> <p>We have discussed <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> in the previous sections pretty extensively. Documentation about <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code> and <code class="docutils literal notranslate"><span class="pre">PeriodIndex</span></code> are shown <a class="reference internal" href="timeseries.html#timeseries-overview"><span class="std std-ref">here</span></a>, and documentation about <code class="docutils literal notranslate"><span class="pre">TimedeltaIndex</span></code> is found <a class="reference internal" href="timedeltas.html#timedeltas-index"><span class="std std-ref">here</span></a>.</p> <p>In the following sub-sections we will highlight some other index types.</p> <section id="categoricalindex"> <h3>CategoricalIndex</h3> <p><a class="reference internal" href="../reference/api/pandas.categoricalindex.html#pandas.CategoricalIndex" title="pandas.CategoricalIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalIndex</span></code></a> is a type of index that is useful for supporting indexing with duplicates. This is a container around a <a class="reference internal" href="../reference/api/pandas.categorical.html#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">Categorical</span></code></a> and allows efficient indexing and storage of an index with a large number of duplicated elements.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [145]: from pandas.api.types import CategoricalDtype

In [146]: df = pd.DataFrame({"A": np.arange(6), "B": list("aabbca")})

In [147]: df["B"] = df["B"].astype(CategoricalDtype(list("cab")))

In [148]: df
Out[148]: 
   A  B
0  0  a
1  1  a
2  2  b
3  3  b
4  4  c
5  5  a

In [149]: df.dtypes
Out[149]: 
A       int64
B    category
dtype: object

In [150]: df["B"].cat.categories
Out[150]: Index(['c', 'a', 'b'], dtype='object')
</pre></div> </div> <p>Setting the index will create a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [151]: df2 = df.set_index("B")

In [152]: df2.index
Out[152]: CategoricalIndex(['a', 'a', 'b', 'b', 'c', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B')
</pre></div> </div> <p>Indexing with <code class="docutils literal notranslate"><span class="pre">__getitem__/.iloc/.loc</span></code> works similarly to an <code class="docutils literal notranslate"><span class="pre">Index</span></code> with duplicates. The indexers <strong>must</strong> be in the category or the operation will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [153]: df2.loc["a"]
Out[153]: 
   A
B   
a  0
a  1
a  5
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> is <strong>preserved</strong> after indexing:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [154]: df2.loc["a"].index
Out[154]: CategoricalIndex(['a', 'a', 'a'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B')
</pre></div> </div> <p>Sorting the index will sort by the order of the categories (recall that we created the index with <code class="docutils literal notranslate"><span class="pre">CategoricalDtype(list('cab'))</span></code>, so the sorted order is <code class="docutils literal notranslate"><span class="pre">cab</span></code>).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [155]: df2.sort_index()
Out[155]: 
   A
B   
c  4
a  0
a  1
a  5
b  2
b  3
</pre></div> </div> <p>Groupby operations on the index will preserve the index nature as well.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [156]: df2.groupby(level=0, observed=True).sum()
Out[156]: 
   A
B   
c  4
a  6
b  5

In [157]: df2.groupby(level=0, observed=True).sum().index
Out[157]: CategoricalIndex(['c', 'a', 'b'], categories=['c', 'a', 'b'], ordered=False, dtype='category', name='B')
</pre></div> </div> <p>Reindexing operations will return a resulting index based on the type of the passed indexer. Passing a list will return a plain-old <code class="docutils literal notranslate"><span class="pre">Index</span></code>; indexing with a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> will return a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code>, indexed according to the categories of the <strong>passed</strong> <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> dtype. This allows one to arbitrarily index these even with values <strong>not</strong> in the categories, similarly to how you can reindex <strong>any</strong> pandas index.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [158]: df3 = pd.DataFrame(
   .....:     {"A": np.arange(3), "B": pd.Series(list("abc")).astype("category")}
   .....: )
   .....: 

In [159]: df3 = df3.set_index("B")

In [160]: df3
Out[160]: 
   A
B   
a  0
b  1
c  2
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [161]: df3.reindex(["a", "e"])
Out[161]: 
     A
B     
a  0.0
e  NaN

In [162]: df3.reindex(["a", "e"]).index
Out[162]: Index(['a', 'e'], dtype='object', name='B')

In [163]: df3.reindex(pd.Categorical(["a", "e"], categories=list("abe")))
Out[163]: 
     A
B     
a  0.0
e  NaN

In [164]: df3.reindex(pd.Categorical(["a", "e"], categories=list("abe"))).index
Out[164]: CategoricalIndex(['a', 'e'], categories=['a', 'b', 'e'], ordered=False, dtype='category', name='B')
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Reshaping and Comparison operations on a <code class="docutils literal notranslate"><span class="pre">CategoricalIndex</span></code> must have the same categories or a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> will be raised.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [165]: df4 = pd.DataFrame({"A": np.arange(2), "B": list("ba")})

In [166]: df4["B"] = df4["B"].astype(CategoricalDtype(list("ab")))

In [167]: df4 = df4.set_index("B")

In [168]: df4.index
Out[168]: CategoricalIndex(['b', 'a'], categories=['a', 'b'], ordered=False, dtype='category', name='B')

In [169]: df5 = pd.DataFrame({"A": np.arange(2), "B": list("bc")})

In [170]: df5["B"] = df5["B"].astype(CategoricalDtype(list("bc")))

In [171]: df5 = df5.set_index("B")

In [172]: df5.index
Out[172]: CategoricalIndex(['b', 'c'], categories=['b', 'c'], ordered=False, dtype='category', name='B')
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [173]: pd.concat([df4, df5])
Out[173]: 
   A
B   
b  0
a  1
b  0
c  1
</pre></div> </div> </div> </section> <section id="rangeindex"> <h3>RangeIndex</h3> <p><a class="reference internal" href="../reference/api/pandas.rangeindex.html#pandas.RangeIndex" title="pandas.RangeIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">RangeIndex</span></code></a> is a sub-class of <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> that provides the default index for all <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> objects. <code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> is an optimized version of <code class="docutils literal notranslate"><span class="pre">Index</span></code> that can represent a monotonic ordered set. These are analogous to Python <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#typesseq-range">range types</a>. A <code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> will always have an <code class="docutils literal notranslate"><span class="pre">int64</span></code> dtype.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [174]: idx = pd.RangeIndex(5)

In [175]: idx
Out[175]: RangeIndex(start=0, stop=5, step=1)
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> is the default index for all <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">Series</span></code></a> objects:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [176]: ser = pd.Series([1, 2, 3])

In [177]: ser.index
Out[177]: RangeIndex(start=0, stop=3, step=1)

In [178]: df = pd.DataFrame([[1, 2], [3, 4]])

In [179]: df.index
Out[179]: RangeIndex(start=0, stop=2, step=1)

In [180]: df.columns
Out[180]: RangeIndex(start=0, stop=2, step=1)
</pre></div> </div> <p>A <code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code> will behave similarly to a <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> with an <code class="docutils literal notranslate"><span class="pre">int64</span></code> dtype and operations on a <code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code>, whose result cannot be represented by a <code class="docutils literal notranslate"><span class="pre">RangeIndex</span></code>, but should have an integer dtype, will be converted to an <code class="docutils literal notranslate"><span class="pre">Index</span></code> with <code class="docutils literal notranslate"><span class="pre">int64</span></code>. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [181]: idx[[0, 2]]
Out[181]: Index([0, 2], dtype='int64')
</pre></div> </div> </section> <section id="intervalindex"> <h3>IntervalIndex</h3> <p><a class="reference internal" href="../reference/api/pandas.intervalindex.html#pandas.IntervalIndex" title="pandas.IntervalIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalIndex</span></code></a> together with its own dtype, <code class="xref py py-class docutils literal notranslate"><span class="pre">IntervalDtype</span></code> as well as the <a class="reference internal" href="../reference/api/pandas.interval.html#pandas.Interval" title="pandas.Interval"><code class="xref py py-class docutils literal notranslate"><span class="pre">Interval</span></code></a> scalar type, allow first-class support in pandas for interval notation.</p> <p>The <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> allows some unique indexing and is also used as a return type for the categories in <a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.qcut.html#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a>.</p> <section id="indexing-with-an-intervalindex"> <h4>Indexing with an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code>
</h4> <p>An <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> can be used in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and in <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as the index.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [182]: df = pd.DataFrame(
   .....:     {"A": [1, 2, 3, 4]}, index=pd.IntervalIndex.from_breaks([0, 1, 2, 3, 4])
   .....: )
   .....: 

In [183]: df
Out[183]: 
        A
(0, 1]  1
(1, 2]  2
(2, 3]  3
(3, 4]  4
</pre></div> </div> <p>Label based indexing via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> along the edges of an interval works as you would expect, selecting that particular interval.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [184]: df.loc[2]
Out[184]: 
A    2
Name: (1, 2], dtype: int64

In [185]: df.loc[[2, 3]]
Out[185]: 
        A
(1, 2]  2
(2, 3]  3
</pre></div> </div> <p>If you select a label <em>contained</em> within an interval, this will also select the interval.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [186]: df.loc[2.5]
Out[186]: 
A    3
Name: (2, 3], dtype: int64

In [187]: df.loc[[2.5, 3.5]]
Out[187]: 
        A
(2, 3]  3
(3, 4]  4
</pre></div> </div> <p>Selecting using an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> will only return exact matches.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [188]: df.loc[pd.Interval(1, 2)]
Out[188]: 
A    2
Name: (1, 2], dtype: int64
</pre></div> </div> <p>Trying to select an <code class="docutils literal notranslate"><span class="pre">Interval</span></code> that is not exactly contained in the <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [189]: df.loc[pd.Interval(0.5, 2.5)]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
Cell In[189], line 1
----&gt; 1 df.loc[pd.Interval(0.5, 2.5)]

File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)
   1189 maybe_callable = com.apply_if_callable(key, self.obj)
   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)
-&gt; 1191 return self._getitem_axis(maybe_callable, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1431, in _LocIndexer._getitem_axis(self, key, axis)
   1429 # fall thru to straight lookup
   1430 self._validate_key(key, axis)
-&gt; 1431 return self._get_label(key, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1381, in _LocIndexer._get_label(self, label, axis)
   1379 def _get_label(self, label, axis: AxisInt):
   1380     # GH#5567 this will fail if the label is not present in the axis.
-&gt; 1381     return self.obj.xs(label, axis=axis)

File ~/work/pandas/pandas/pandas/core/generic.py:4301, in NDFrame.xs(self, key, axis, level, drop_level)
   4299             new_index = index[loc]
   4300 else:
-&gt; 4301     loc = index.get_loc(key)
   4303     if isinstance(loc, np.ndarray):
   4304         if loc.dtype == np.bool_:

File ~/work/pandas/pandas/pandas/core/indexes/interval.py:678, in IntervalIndex.get_loc(self, key)
    676 matches = mask.sum()
    677 if matches == 0:
--&gt; 678     raise KeyError(key)
    679 if matches == 1:
    680     return mask.argmax()

KeyError: Interval(0.5, 2.5, closed='right')
</pre></div> </div> <p>Selecting all <code class="docutils literal notranslate"><span class="pre">Intervals</span></code> that overlap a given <code class="docutils literal notranslate"><span class="pre">Interval</span></code> can be performed using the <a class="reference internal" href="../reference/api/pandas.intervalindex.overlaps.html#pandas.IntervalIndex.overlaps" title="pandas.IntervalIndex.overlaps"><code class="xref py py-meth docutils literal notranslate"><span class="pre">overlaps()</span></code></a> method to create a boolean indexer.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [190]: idxr = df.index.overlaps(pd.Interval(0.5, 2.5))

In [191]: idxr
Out[191]: array([ True,  True,  True, False])

In [192]: df[idxr]
Out[192]: 
        A
(0, 1]  1
(1, 2]  2
(2, 3]  3
</pre></div> </div> </section> <section id="binning-data-with-cut-and-qcut"> <h4>Binning data with <code class="docutils literal notranslate"><span class="pre">cut</span></code> and <code class="docutils literal notranslate"><span class="pre">qcut</span></code>
</h4> <p><a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.qcut.html#pandas.qcut" title="pandas.qcut"><code class="xref py py-func docutils literal notranslate"><span class="pre">qcut()</span></code></a> both return a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> object, and the bins they create are stored as an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> in its <code class="docutils literal notranslate"><span class="pre">.categories</span></code> attribute.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [193]: c = pd.cut(range(4), bins=2)

In [194]: c
Out[194]: 
[(-0.003, 1.5], (-0.003, 1.5], (1.5, 3.0], (1.5, 3.0]]
Categories (2, interval[float64, right]): [(-0.003, 1.5] &lt; (1.5, 3.0]]

In [195]: c.categories
Out[195]: IntervalIndex([(-0.003, 1.5], (1.5, 3.0]], dtype='interval[float64, right]')
</pre></div> </div> <p><a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> also accepts an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> for its <code class="docutils literal notranslate"><span class="pre">bins</span></code> argument, which enables a useful pandas idiom. First, We call <a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a> with some data and <code class="docutils literal notranslate"><span class="pre">bins</span></code> set to a fixed number, to generate the bins. Then, we pass the values of <code class="docutils literal notranslate"><span class="pre">.categories</span></code> as the <code class="docutils literal notranslate"><span class="pre">bins</span></code> argument in subsequent calls to <a class="reference internal" href="../reference/api/pandas.cut.html#pandas.cut" title="pandas.cut"><code class="xref py py-func docutils literal notranslate"><span class="pre">cut()</span></code></a>, supplying new data which will be binned into the same bins.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [196]: pd.cut([0, 3, 5, 1], bins=c.categories)
Out[196]: 
[(-0.003, 1.5], (1.5, 3.0], NaN, (-0.003, 1.5]]
Categories (2, interval[float64, right]): [(-0.003, 1.5] &lt; (1.5, 3.0]]
</pre></div> </div> <p>Any value which falls outside all bins will be assigned a <code class="docutils literal notranslate"><span class="pre">NaN</span></code> value.</p> </section> <section id="generating-ranges-of-intervals"> <h4>Generating ranges of intervals</h4> <p>If we need intervals on a regular frequency, we can use the <a class="reference internal" href="../reference/api/pandas.interval_range.html#pandas.interval_range" title="pandas.interval_range"><code class="xref py py-func docutils literal notranslate"><span class="pre">interval_range()</span></code></a> function to create an <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code> using various combinations of <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code>. The default frequency for <code class="docutils literal notranslate"><span class="pre">interval_range</span></code> is a 1 for numeric intervals, and calendar day for datetime-like intervals:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [197]: pd.interval_range(start=0, end=5)
Out[197]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]], dtype='interval[int64, right]')

In [198]: pd.interval_range(start=pd.Timestamp("2017-01-01"), periods=4)
Out[198]: 
IntervalIndex([(2017-01-01 00:00:00, 2017-01-02 00:00:00],
               (2017-01-02 00:00:00, 2017-01-03 00:00:00],
               (2017-01-03 00:00:00, 2017-01-04 00:00:00],
               (2017-01-04 00:00:00, 2017-01-05 00:00:00]],
              dtype='interval[datetime64[ns], right]')

In [199]: pd.interval_range(end=pd.Timedelta("3 days"), periods=3)
Out[199]: 
IntervalIndex([(0 days 00:00:00, 1 days 00:00:00],
               (1 days 00:00:00, 2 days 00:00:00],
               (2 days 00:00:00, 3 days 00:00:00]],
              dtype='interval[timedelta64[ns], right]')
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">freq</span></code> parameter can used to specify non-default frequencies, and can utilize a variety of <a class="reference internal" href="timeseries.html#timeseries-offset-aliases"><span class="std std-ref">frequency aliases</span></a> with datetime-like intervals:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [200]: pd.interval_range(start=0, periods=5, freq=1.5)
Out[200]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0], (6.0, 7.5]], dtype='interval[float64, right]')

In [201]: pd.interval_range(start=pd.Timestamp("2017-01-01"), periods=4, freq="W")
Out[201]: 
IntervalIndex([(2017-01-01 00:00:00, 2017-01-08 00:00:00],
               (2017-01-08 00:00:00, 2017-01-15 00:00:00],
               (2017-01-15 00:00:00, 2017-01-22 00:00:00],
               (2017-01-22 00:00:00, 2017-01-29 00:00:00]],
              dtype='interval[datetime64[ns], right]')

In [202]: pd.interval_range(start=pd.Timedelta("0 days"), periods=3, freq="9h")
Out[202]: 
IntervalIndex([(0 days 00:00:00, 0 days 09:00:00],
               (0 days 09:00:00, 0 days 18:00:00],
               (0 days 18:00:00, 1 days 03:00:00]],
              dtype='interval[timedelta64[ns], right]')
</pre></div> </div> <p>Additionally, the <code class="docutils literal notranslate"><span class="pre">closed</span></code> parameter can be used to specify which side(s) the intervals are closed on. Intervals are closed on the right side by default.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [203]: pd.interval_range(start=0, end=4, closed="both")
Out[203]: IntervalIndex([[0, 1], [1, 2], [2, 3], [3, 4]], dtype='interval[int64, both]')

In [204]: pd.interval_range(start=0, end=4, closed="neither")
Out[204]: IntervalIndex([(0, 1), (1, 2), (2, 3), (3, 4)], dtype='interval[int64, neither]')
</pre></div> </div> <p>Specifying <code class="docutils literal notranslate"><span class="pre">start</span></code>, <code class="docutils literal notranslate"><span class="pre">end</span></code>, and <code class="docutils literal notranslate"><span class="pre">periods</span></code> will generate a range of evenly spaced intervals from <code class="docutils literal notranslate"><span class="pre">start</span></code> to <code class="docutils literal notranslate"><span class="pre">end</span></code> inclusively, with <code class="docutils literal notranslate"><span class="pre">periods</span></code> number of elements in the resulting <code class="docutils literal notranslate"><span class="pre">IntervalIndex</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [205]: pd.interval_range(start=0, end=6, periods=4)
Out[205]: IntervalIndex([(0.0, 1.5], (1.5, 3.0], (3.0, 4.5], (4.5, 6.0]], dtype='interval[float64, right]')

In [206]: pd.interval_range(pd.Timestamp("2018-01-01"), pd.Timestamp("2018-02-28"), periods=3)
Out[206]: 
IntervalIndex([(2018-01-01 00:00:00, 2018-01-20 08:00:00],
               (2018-01-20 08:00:00, 2018-02-08 16:00:00],
               (2018-02-08 16:00:00, 2018-02-28 00:00:00]],
              dtype='interval[datetime64[ns], right]')
</pre></div> </div> </section> </section> </section> <section id="miscellaneous-indexing-faq"> <h2>Miscellaneous indexing FAQ</h2> <section id="integer-indexing"> <h3>Integer indexing</h3> <p>Label-based indexing with integer axis labels is a thorny topic. It has been discussed heavily on mailing lists and among various members of the scientific Python community. In pandas, our general viewpoint is that labels matter more than integer locations. Therefore, with an integer axis index <em>only</em> label-based indexing is possible with the standard tools like <code class="docutils literal notranslate"><span class="pre">.loc</span></code>. The following code will generate exceptions:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [207]: s = pd.Series(range(5))

In [208]: s[-1]
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
File ~/work/pandas/pandas/pandas/core/indexes/range.py:413, in RangeIndex.get_loc(self, key)
    412 try:
--&gt; 413     return self._range.index(new_key)
    414 except ValueError as err:

ValueError: -1 is not in range

The above exception was the direct cause of the following exception:

KeyError                                  Traceback (most recent call last)
Cell In[208], line 1
----&gt; 1 s[-1]

File ~/work/pandas/pandas/pandas/core/series.py:1121, in Series.__getitem__(self, key)
   1118     return self._values[key]
   1120 elif key_is_scalar:
-&gt; 1121     return self._get_value(key)
   1123 # Convert generator to list before going through hashable part
   1124 # (We will iterate through the generator there to check for slices)
   1125 if is_iterator(key):

File ~/work/pandas/pandas/pandas/core/series.py:1237, in Series._get_value(self, label, takeable)
   1234     return self._values[label]
   1236 # Similar to Index.get_value, but we do not fall back to positional
-&gt; 1237 loc = self.index.get_loc(label)
   1239 if is_integer(loc):
   1240     return self._values[loc]

File ~/work/pandas/pandas/pandas/core/indexes/range.py:415, in RangeIndex.get_loc(self, key)
    413         return self._range.index(new_key)
    414     except ValueError as err:
--&gt; 415         raise KeyError(key) from err
    416 if isinstance(key, Hashable):
    417     raise KeyError(key)

KeyError: -1

In [209]: df = pd.DataFrame(np.random.randn(5, 4))

In [210]: df
Out[210]: 
          0         1         2         3
0 -0.435772 -1.188928 -0.808286 -0.284634
1 -1.815703  1.347213 -0.243487  0.514704
2  1.162969 -0.287725 -0.179734  0.993962
3 -0.212673  0.909872 -0.733333 -0.349893
4  0.456434 -0.306735  0.553396  0.166221

In [211]: df.loc[-2:]
Out[211]: 
          0         1         2         3
0 -0.435772 -1.188928 -0.808286 -0.284634
1 -1.815703  1.347213 -0.243487  0.514704
2  1.162969 -0.287725 -0.179734  0.993962
3 -0.212673  0.909872 -0.733333 -0.349893
4  0.456434 -0.306735  0.553396  0.166221
</pre></div> </div> <p>This deliberate decision was made to prevent ambiguities and subtle bugs (many users reported finding bugs when the API change was made to stop “falling back” on position-based indexing).</p> </section> <section id="non-monotonic-indexes-require-exact-matches"> <h3>Non-monotonic indexes require exact matches</h3> <p>If the index of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> is monotonically increasing or decreasing, then the bounds of a label-based slice can be outside the range of the index, much like slice indexing a normal Python <code class="docutils literal notranslate"><span class="pre">list</span></code>. Monotonicity of an index can be tested with the <a class="reference internal" href="../reference/api/pandas.index.is_monotonic_increasing.html#pandas.Index.is_monotonic_increasing" title="pandas.Index.is_monotonic_increasing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_increasing()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.index.is_monotonic_decreasing.html#pandas.Index.is_monotonic_decreasing" title="pandas.Index.is_monotonic_decreasing"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_monotonic_decreasing()</span></code></a> attributes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [212]: df = pd.DataFrame(index=[2, 3, 3, 4, 5], columns=["data"], data=list(range(5)))

In [213]: df.index.is_monotonic_increasing
Out[213]: True

# no rows 0 or 1, but still returns rows 2, 3 (both of them), and 4:
In [214]: df.loc[0:4, :]
Out[214]: 
   data
2     0
3     1
3     2
4     3

# slice is are outside the index, so empty DataFrame is returned
In [215]: df.loc[13:15, :]
Out[215]: 
Empty DataFrame
Columns: [data]
Index: []
</pre></div> </div> <p>On the other hand, if the index is not monotonic, then both slice bounds must be <em>unique</em> members of the index.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [216]: df = pd.DataFrame(index=[2, 3, 1, 4, 3, 5], columns=["data"], data=list(range(6)))

In [217]: df.index.is_monotonic_increasing
Out[217]: False

# OK because 2 and 4 are in the index
In [218]: df.loc[2:4, :]
Out[218]: 
   data
2     0
3     1
1     2
4     3
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"> # 0 is not in the index
In [219]: df.loc[0:4, :]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
File ~/work/pandas/pandas/pandas/core/indexes/base.py:3805, in Index.get_loc(self, key)
   3804 try:
-&gt; 3805     return self._engine.get_loc(casted_key)
   3806 except KeyError as err:

File index.pyx:167, in pandas._libs.index.IndexEngine.get_loc()

File index.pyx:191, in pandas._libs.index.IndexEngine.get_loc()

File index.pyx:234, in pandas._libs.index.IndexEngine._get_loc_duplicates()

File index.pyx:242, in pandas._libs.index.IndexEngine._maybe_get_bool_indexer()

File index.pyx:134, in pandas._libs.index._unpack_bool_indexer()

KeyError: 0

The above exception was the direct cause of the following exception:

KeyError                                  Traceback (most recent call last)
Cell In[219], line 1
----&gt; 1 df.loc[0:4, :]

File ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)
   1182     if self._is_scalar_access(key):
   1183         return self.obj._get_value(*key, takeable=self._takeable)
-&gt; 1184     return self._getitem_tuple(key)
   1185 else:
   1186     # we by definition only have the 0th axis
   1187     axis = self.axis or 0

File ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)
   1374 if self._multi_take_opportunity(tup):
   1375     return self._multi_take(tup)
-&gt; 1377 return self._getitem_tuple_same_dim(tup)

File ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)
   1017 if com.is_null_slice(key):
   1018     continue
-&gt; 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)
   1021 # We should never have retval.ndim &lt; self.ndim, as that should
   1022 #  be handled by the _getitem_lowerdim call above.
   1023 assert retval.ndim == self.ndim

File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)
   1409 if isinstance(key, slice):
   1410     self._validate_key(key, axis)
-&gt; 1411     return self._get_slice_axis(key, axis=axis)
   1412 elif com.is_bool_indexer(key):
   1413     return self._getbool_axis(key, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)
   1440     return obj.copy(deep=False)
   1442 labels = obj._get_axis(axis)
-&gt; 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)
   1445 if isinstance(indexer, slice):
   1446     return self.obj._slice(indexer, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)
   6618 def slice_indexer(
   6619     self,
   6620     start: Hashable | None = None,
   6621     end: Hashable | None = None,
   6622     step: int | None = None,
   6623 ) -&gt; slice:
   6624     """
   6625     Compute the slice indexer for input labels and step.
   6626 
   (...)
   6660     slice(1, 3, None)
   6661     """
-&gt; 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)
   6664     # return a slice
   6665     if not is_scalar(start_slice):

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)
   6877 start_slice = None
   6878 if start is not None:
-&gt; 6879     start_slice = self.get_slice_bound(start, "left")
   6880 if start_slice is None:
   6881     start_slice = 0

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6804, in Index.get_slice_bound(self, label, side)
   6801         return self._searchsorted_monotonic(label, side)
   6802     except ValueError:
   6803         # raise the original KeyError
-&gt; 6804         raise err
   6806 if isinstance(slc, np.ndarray):
   6807     # get_loc may return a boolean array, which
   6808     # is OK as long as they are representable by a slice.
   6809     assert is_bool_dtype(slc.dtype)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6798, in Index.get_slice_bound(self, label, side)
   6796 # we need to look up the label
   6797 try:
-&gt; 6798     slc = self.get_loc(label)
   6799 except KeyError as err:
   6800     try:

File ~/work/pandas/pandas/pandas/core/indexes/base.py:3812, in Index.get_loc(self, key)
   3807     if isinstance(casted_key, slice) or (
   3808         isinstance(casted_key, abc.Iterable)
   3809         and any(isinstance(x, slice) for x in casted_key)
   3810     ):
   3811         raise InvalidIndexError(key)
-&gt; 3812     raise KeyError(key) from err
   3813 except TypeError:
   3814     # If we have a listlike key, _check_indexing_error will raise
   3815     #  InvalidIndexError. Otherwise we fall through and re-raise
   3816     #  the TypeError.
   3817     self._check_indexing_error(key)

KeyError: 0

 # 3 is not a unique label
In [220]: df.loc[2:3, :]
---------------------------------------------------------------------------
KeyError                                  Traceback (most recent call last)
Cell In[220], line 1
----&gt; 1 df.loc[2:3, :]

File ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)
   1182     if self._is_scalar_access(key):
   1183         return self.obj._get_value(*key, takeable=self._takeable)
-&gt; 1184     return self._getitem_tuple(key)
   1185 else:
   1186     # we by definition only have the 0th axis
   1187     axis = self.axis or 0

File ~/work/pandas/pandas/pandas/core/indexing.py:1377, in _LocIndexer._getitem_tuple(self, tup)
   1374 if self._multi_take_opportunity(tup):
   1375     return self._multi_take(tup)
-&gt; 1377 return self._getitem_tuple_same_dim(tup)

File ~/work/pandas/pandas/pandas/core/indexing.py:1020, in _LocationIndexer._getitem_tuple_same_dim(self, tup)
   1017 if com.is_null_slice(key):
   1018     continue
-&gt; 1020 retval = getattr(retval, self.name)._getitem_axis(key, axis=i)
   1021 # We should never have retval.ndim &lt; self.ndim, as that should
   1022 #  be handled by the _getitem_lowerdim call above.
   1023 assert retval.ndim == self.ndim

File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)
   1409 if isinstance(key, slice):
   1410     self._validate_key(key, axis)
-&gt; 1411     return self._get_slice_axis(key, axis=axis)
   1412 elif com.is_bool_indexer(key):
   1413     return self._getbool_axis(key, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)
   1440     return obj.copy(deep=False)
   1442 labels = obj._get_axis(axis)
-&gt; 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)
   1445 if isinstance(indexer, slice):
   1446     return self.obj._slice(indexer, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)
   6618 def slice_indexer(
   6619     self,
   6620     start: Hashable | None = None,
   6621     end: Hashable | None = None,
   6622     step: int | None = None,
   6623 ) -&gt; slice:
   6624     """
   6625     Compute the slice indexer for input labels and step.
   6626 
   (...)
   6660     slice(1, 3, None)
   6661     """
-&gt; 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)
   6664     # return a slice
   6665     if not is_scalar(start_slice):

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6885, in Index.slice_locs(self, start, end, step)
   6883 end_slice = None
   6884 if end is not None:
-&gt; 6885     end_slice = self.get_slice_bound(end, "right")
   6886 if end_slice is None:
   6887     end_slice = len(self)

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6812, in Index.get_slice_bound(self, label, side)
   6810     slc = lib.maybe_booleans_to_slice(slc.view("u1"))
   6811     if isinstance(slc, np.ndarray):
-&gt; 6812         raise KeyError(
   6813             f"Cannot get {side} slice bound for non-unique "
   6814             f"label: {repr(original_label)}"
   6815         )
   6817 if isinstance(slc, slice):
   6818     if side == "left":

KeyError: 'Cannot get right slice bound for non-unique label: 3'
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_increasing</span></code> and <code class="docutils literal notranslate"><span class="pre">Index.is_monotonic_decreasing</span></code> only check that an index is weakly monotonic. To check for strict monotonicity, you can combine one of those with the <a class="reference internal" href="../reference/api/pandas.index.is_unique.html#pandas.Index.is_unique" title="pandas.Index.is_unique"><code class="xref py py-meth docutils literal notranslate"><span class="pre">is_unique()</span></code></a> attribute.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [221]: weakly_monotonic = pd.Index(["a", "b", "c", "c"])

In [222]: weakly_monotonic
Out[222]: Index(['a', 'b', 'c', 'c'], dtype='object')

In [223]: weakly_monotonic.is_monotonic_increasing
Out[223]: True

In [224]: weakly_monotonic.is_monotonic_increasing &amp; weakly_monotonic.is_unique
Out[224]: False
</pre></div> </div> </section> <section id="endpoints-are-inclusive"> <h3>Endpoints are inclusive</h3> <p>Compared with standard Python sequence slicing in which the slice endpoint is not inclusive, label-based slicing in pandas <strong>is inclusive</strong>. The primary reason for this is that it is often not possible to easily determine the “successor” or next element after a particular label in an index. For example, consider the following <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [225]: s = pd.Series(np.random.randn(6), index=list("abcdef"))

In [226]: s
Out[226]: 
a   -0.101684
b   -0.734907
c   -0.130121
d   -0.476046
e    0.759104
f    0.213379
dtype: float64
</pre></div> </div> <p>Suppose we wished to slice from <code class="docutils literal notranslate"><span class="pre">c</span></code> to <code class="docutils literal notranslate"><span class="pre">e</span></code>, using integers this would be accomplished as such:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [227]: s[2:5]
Out[227]: 
c   -0.130121
d   -0.476046
e    0.759104
dtype: float64
</pre></div> </div> <p>However, if you only had <code class="docutils literal notranslate"><span class="pre">c</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span></code>, determining the next element in the index can be somewhat complicated. For example, the following does not work:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [228]: s.loc['c':'e' + 1]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[228], line 1
----&gt; 1 s.loc['c':'e' + 1]

TypeError: can only concatenate str (not "int") to str
</pre></div> </div> <p>A very common use case is to limit a time series to start and end at two specific dates. To enable this, we made the design choice to make label-based slicing include both endpoints:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [229]: s.loc["c":"e"]
Out[229]: 
c   -0.130121
d   -0.476046
e    0.759104
dtype: float64
</pre></div> </div> <p>This is most definitely a “practicality beats purity” sort of thing, but it is something to watch out for if you expect label-based slicing to behave exactly in the way that standard Python integer slicing works.</p> </section> <section id="indexing-potentially-changes-underlying-series-dtype"> <h3>Indexing potentially changes underlying Series dtype</h3> <p>The different indexing operation can potentially change the dtype of a <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [230]: series1 = pd.Series([1, 2, 3])

In [231]: series1.dtype
Out[231]: dtype('int64')

In [232]: res = series1.reindex([0, 4])

In [233]: res.dtype
Out[233]: dtype('float64')

In [234]: res
Out[234]: 
0    1.0
4    NaN
dtype: float64
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [235]: series2 = pd.Series([True])

In [236]: series2.dtype
Out[236]: dtype('bool')

In [237]: res = series2.reindex_like(series1)

In [238]: res.dtype
Out[238]: dtype('O')

In [239]: res
Out[239]: 
0    True
1     NaN
2     NaN
dtype: object
</pre></div> </div> <p>This is because the (re)indexing operations above silently inserts <code class="docutils literal notranslate"><span class="pre">NaNs</span></code> and the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> changes accordingly. This can cause some issues when using <code class="docutils literal notranslate"><span class="pre">numpy</span></code> <code class="docutils literal notranslate"><span class="pre">ufuncs</span></code> such as <code class="docutils literal notranslate"><span class="pre">numpy.logical_and</span></code>.</p> <p>See the <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2388">GH 2388</a> for a more detailed discussion.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/advanced.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/advanced.html</a>
  </p>
</div>
