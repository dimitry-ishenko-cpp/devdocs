<h1>IO tools (text, CSV, HDF5, …)</h1> <p>The pandas I/O API is a set of top level <code class="docutils literal notranslate"><span class="pre">reader</span></code> functions accessed like <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a> that generally return a pandas object. The corresponding <code class="docutils literal notranslate"><span class="pre">writer</span></code> functions are object methods that are accessed like <a class="reference internal" href="../reference/api/pandas.dataframe.to_csv.html#pandas.DataFrame.to_csv" title="pandas.DataFrame.to_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.to_csv()</span></code></a>. Below is a table containing available <code class="docutils literal notranslate"><span class="pre">readers</span></code> and <code class="docutils literal notranslate"><span class="pre">writers</span></code>.</p> <table class="table"> <colgroup> <col style="width: 12.0%"> <col style="width: 40.0%"> <col style="width: 24.0%"> <col style="width: 24.0%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Format Type</p></th> <th class="head"><p>Data Description</p></th> <th class="head"><p>Reader</p></th> <th class="head"><p>Writer</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>text</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/Comma-separated_values">CSV</a></p></td> <td><p><a class="reference internal" href="#io-read-csv-table"><span class="std std-ref">read_csv</span></a></p></td> <td><p><a class="reference internal" href="#io-store-in-csv"><span class="std std-ref">to_csv</span></a></p></td> </tr> <tr class="row-odd">
<td><p>text</p></td> <td><p>Fixed-Width Text File</p></td> <td><p><a class="reference internal" href="#io-fwf-reader"><span class="std std-ref">read_fwf</span></a></p></td> <td></td> </tr> <tr class="row-even">
<td><p>text</p></td> <td><p><a class="reference external" href="https://www.json.org/">JSON</a></p></td> <td><p><a class="reference internal" href="#io-json-reader"><span class="std std-ref">read_json</span></a></p></td> <td><p><a class="reference internal" href="#io-json-writer"><span class="std std-ref">to_json</span></a></p></td> </tr> <tr class="row-odd">
<td><p>text</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/HTML">HTML</a></p></td> <td><p><a class="reference internal" href="#io-read-html"><span class="std std-ref">read_html</span></a></p></td> <td><p><a class="reference internal" href="#io-html"><span class="std std-ref">to_html</span></a></p></td> </tr> <tr class="row-even">
<td><p>text</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/LaTeX">LaTeX</a></p></td> <td></td> <td><p><a class="reference internal" href="#io-latex"><span class="std std-ref">Styler.to_latex</span></a></p></td> </tr> <tr class="row-odd">
<td><p>text</p></td> <td><p><a class="reference external" href="https://www.w3.org/standards/xml/core">XML</a></p></td> <td><p><a class="reference internal" href="#io-read-xml"><span class="std std-ref">read_xml</span></a></p></td> <td><p><a class="reference internal" href="#io-xml"><span class="std std-ref">to_xml</span></a></p></td> </tr> <tr class="row-even">
<td><p>text</p></td> <td><p>Local clipboard</p></td> <td><p><a class="reference internal" href="#io-clipboard"><span class="std std-ref">read_clipboard</span></a></p></td> <td><p><a class="reference internal" href="#io-clipboard"><span class="std std-ref">to_clipboard</span></a></p></td> </tr> <tr class="row-odd">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/Microsoft_Excel">MS Excel</a></p></td> <td><p><a class="reference internal" href="#io-excel-reader"><span class="std std-ref">read_excel</span></a></p></td> <td><p><a class="reference internal" href="#io-excel-writer"><span class="std std-ref">to_excel</span></a></p></td> </tr> <tr class="row-even">
<td><p>binary</p></td> <td><p><a class="reference external" href="http://opendocumentformat.org">OpenDocument</a></p></td> <td><p><a class="reference internal" href="#io-ods"><span class="std std-ref">read_excel</span></a></p></td> <td></td> </tr> <tr class="row-odd">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://support.hdfgroup.org/HDF5/whatishdf5.html">HDF5 Format</a></p></td> <td><p><a class="reference internal" href="#io-hdf5"><span class="std std-ref">read_hdf</span></a></p></td> <td><p><a class="reference internal" href="#io-hdf5"><span class="std std-ref">to_hdf</span></a></p></td> </tr> <tr class="row-even">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://github.com/wesm/feather">Feather Format</a></p></td> <td><p><a class="reference internal" href="#io-feather"><span class="std std-ref">read_feather</span></a></p></td> <td><p><a class="reference internal" href="#io-feather"><span class="std std-ref">to_feather</span></a></p></td> </tr> <tr class="row-odd">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://parquet.apache.org/">Parquet Format</a></p></td> <td><p><a class="reference internal" href="#io-parquet"><span class="std std-ref">read_parquet</span></a></p></td> <td><p><a class="reference internal" href="#io-parquet"><span class="std std-ref">to_parquet</span></a></p></td> </tr> <tr class="row-even">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://orc.apache.org/">ORC Format</a></p></td> <td><p><a class="reference internal" href="#io-orc"><span class="std std-ref">read_orc</span></a></p></td> <td><p><a class="reference internal" href="#io-orc"><span class="std std-ref">to_orc</span></a></p></td> </tr> <tr class="row-odd">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/Stata">Stata</a></p></td> <td><p><a class="reference internal" href="#io-stata-reader"><span class="std std-ref">read_stata</span></a></p></td> <td><p><a class="reference internal" href="#io-stata-writer"><span class="std std-ref">to_stata</span></a></p></td> </tr> <tr class="row-even">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/SAS_(software)">SAS</a></p></td> <td><p><a class="reference internal" href="#io-sas-reader"><span class="std std-ref">read_sas</span></a></p></td> <td></td> </tr> <tr class="row-odd">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/SPSS">SPSS</a></p></td> <td><p><a class="reference internal" href="#io-spss-reader"><span class="std std-ref">read_spss</span></a></p></td> <td></td> </tr> <tr class="row-even">
<td><p>binary</p></td> <td><p><a class="reference external" href="https://docs.python.org/3/library/pickle.html">Python Pickle Format</a></p></td> <td><p><a class="reference internal" href="#io-pickle"><span class="std std-ref">read_pickle</span></a></p></td> <td><p><a class="reference internal" href="#io-pickle"><span class="std std-ref">to_pickle</span></a></p></td> </tr> <tr class="row-odd">
<td><p>SQL</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/SQL">SQL</a></p></td> <td><p><a class="reference internal" href="#io-sql"><span class="std std-ref">read_sql</span></a></p></td> <td><p><a class="reference internal" href="#io-sql"><span class="std std-ref">to_sql</span></a></p></td> </tr> <tr class="row-even">
<td><p>SQL</p></td> <td><p><a class="reference external" href="https://en.wikipedia.org/wiki/BigQuery">Google BigQuery</a></p></td> <td><p><a class="reference internal" href="#io-bigquery"><span class="std std-ref">read_gbq</span></a></p></td> <td><p><a class="reference internal" href="#io-bigquery"><span class="std std-ref">to_gbq</span></a></p></td> </tr> </tbody> </table> <p><a class="reference internal" href="#io-perf"><span class="std std-ref">Here</span></a> is an informal performance comparison for some of these IO methods.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For examples that use the <code class="docutils literal notranslate"><span class="pre">StringIO</span></code> class, make sure you import it with <code class="docutils literal notranslate"><span class="pre">from</span> <span class="pre">io</span> <span class="pre">import</span> <span class="pre">StringIO</span></code> for Python 3.</p> </div> <section id="csv-text-files"> <h2>CSV &amp; text files</h2> <p>The workhorse function for reading text files (a.k.a. flat files) is <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a>. See the <a class="reference internal" href="cookbook.html#cookbook-csv"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <section id="parsing-options"> <h3>Parsing options</h3> <p><a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a> accepts the following common arguments:</p> <section id="basic"> <h4>Basic</h4> <dl> <dt>filepath_or_buffer<span class="classifier">:various</span>
</dt>
<dd>
<p>Either a path to a file (a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">str</span></code></a>, <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>, or <code class="xref py py-class docutils literal notranslate"><span class="pre">py:py._path.local.LocalPath</span></code>), URL (including http, ftp, and S3 locations), or any object with a <code class="docutils literal notranslate"><span class="pre">read()</span></code> method (such as an open file or <a class="reference external" href="https://docs.python.org/3/library/io.html#io.StringIO" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">StringIO</span></code></a>).</p> </dd> <dt>sep<span class="classifier">:str, defaults to ',' for read_csv(), \t for read_table()</span>
</dt>
<dd>
<p>Delimiter to use. If sep is <code class="docutils literal notranslate"><span class="pre">None</span></code>, the C engine cannot automatically detect the separator, but the Python parsing engine can, meaning the latter will be used and automatically detect the separator by Python’s builtin sniffer tool, <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Sniffer" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">csv.Sniffer</span></code></a>. In addition, separators longer than 1 character and different from <code class="docutils literal notranslate"><span class="pre">'\s+'</span></code> will be interpreted as regular expressions and will also force the use of the Python parsing engine. Note that regex delimiters are prone to ignoring quoted data. Regex example: <code class="docutils literal notranslate"><span class="pre">'\\r\\t'</span></code>.</p> </dd> <dt>delimiter<span class="classifier">:str, default None</span>
</dt>
<dd>
<p>Alternative argument name for sep.</p> </dd> <dt>delim_whitespace<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>Specifies whether or not whitespace (e.g. <code class="docutils literal notranslate"><span class="pre">'</span> <span class="pre">'</span></code> or <code class="docutils literal notranslate"><span class="pre">'\t'</span></code>) will be used as the delimiter. Equivalent to setting <code class="docutils literal notranslate"><span class="pre">sep='\s+'</span></code>. If this option is set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, nothing should be passed in for the <code class="docutils literal notranslate"><span class="pre">delimiter</span></code> parameter.</p> </dd> </dl> </section> <section id="column-and-index-locations-and-names"> <h4>Column and index locations and names</h4> <dl> <dt>header<span class="classifier">:int or list of ints, default 'infer'</span>
</dt>
<dd>
<p>Row number(s) to use as the column names, and the start of the data. Default behavior is to infer the column names: if no names are passed the behavior is identical to <code class="docutils literal notranslate"><span class="pre">header=0</span></code> and column names are inferred from the first line of the file, if column names are passed explicitly then the behavior is identical to <code class="docutils literal notranslate"><span class="pre">header=None</span></code>. Explicitly pass <code class="docutils literal notranslate"><span class="pre">header=0</span></code> to be able to replace existing names.</p> <p>The header can be a list of ints that specify row locations for a MultiIndex on the columns e.g. <code class="docutils literal notranslate"><span class="pre">[0,1,3]</span></code>. Intervening rows that are not specified will be skipped (e.g. 2 in this example is skipped). Note that this parameter ignores commented lines and empty lines if <code class="docutils literal notranslate"><span class="pre">skip_blank_lines=True</span></code>, so header=0 denotes the first line of data rather than the first line of the file.</p> </dd> <dt>names<span class="classifier">:array-like, default None</span>
</dt>
<dd>
<p>List of column names to use. If file contains no header row, then you should explicitly pass <code class="docutils literal notranslate"><span class="pre">header=None</span></code>. Duplicates in this list are not allowed.</p> </dd> <dt>index_col<span class="classifier">:int, str, sequence of int / str, or False, optional, default None</span>
</dt>
<dd>
<p>Column(s) to use as the row labels of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, either given as string name or column index. If a sequence of int / str is given, a MultiIndex is used.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">index_col=False</span></code> can be used to force pandas to <em>not</em> use the first column as the index, e.g. when you have a malformed file with delimiters at the end of each line.</p> </div> <p>The default value of <code class="docutils literal notranslate"><span class="pre">None</span></code> instructs pandas to guess. If the number of fields in the column header row is equal to the number of fields in the body of the data file, then a default index is used. If it is larger, then the first columns are used as index so that the remaining number of fields in the body are equal to the number of fields in the header.</p> <p>The first row after the header is used to determine the number of columns, which will go into the index. If the subsequent rows contain less columns than the first row, they are filled with <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <p>This can be avoided through <code class="docutils literal notranslate"><span class="pre">usecols</span></code>. This ensures that the columns are taken as is and the trailing data are ignored.</p> </dd> <dt>usecols<span class="classifier">:list-like or callable, default None</span>
</dt>
<dd>
<p>Return a subset of the columns. If list-like, all elements must either be positional (i.e. integer indices into the document columns) or strings that correspond to column names provided either by the user in <code class="docutils literal notranslate"><span class="pre">names</span></code> or inferred from the document header row(s). If <code class="docutils literal notranslate"><span class="pre">names</span></code> are given, the document header row(s) are not taken into account. For example, a valid list-like <code class="docutils literal notranslate"><span class="pre">usecols</span></code> parameter would be <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">1,</span> <span class="pre">2]</span></code> or <code class="docutils literal notranslate"><span class="pre">['foo',</span> <span class="pre">'bar',</span> <span class="pre">'baz']</span></code>.</p> <p>Element order is ignored, so <code class="docutils literal notranslate"><span class="pre">usecols=[0,</span> <span class="pre">1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0]</span></code>. To instantiate a DataFrame from <code class="docutils literal notranslate"><span class="pre">data</span></code> with element order preserved use <code class="docutils literal notranslate"><span class="pre">pd.read_csv(data,</span> <span class="pre">usecols=['foo',</span> <span class="pre">'bar'])[['foo',</span> <span class="pre">'bar']]</span></code> for columns in <code class="docutils literal notranslate"><span class="pre">['foo',</span> <span class="pre">'bar']</span></code> order or <code class="docutils literal notranslate"><span class="pre">pd.read_csv(data,</span> <span class="pre">usecols=['foo',</span> <span class="pre">'bar'])[['bar',</span> <span class="pre">'foo']]</span></code> for <code class="docutils literal notranslate"><span class="pre">['bar',</span> <span class="pre">'foo']</span></code> order.</p> <p>If callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to True:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: import pandas as pd

In [2]: from io import StringIO

In [3]: data = "col1,col2,col3\na,b,1\na,b,2\nc,d,3"

In [4]: pd.read_csv(StringIO(data))
Out[4]: 
  col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [5]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in ["COL1", "COL3"])
Out[5]: 
  col1  col3
0    a     1
1    a     2
2    c     3
</pre></div> </div> <p>Using this parameter results in much faster parsing time and lower memory usage when using the c engine. The Python engine loads the data first before deciding which columns to drop.</p> </dd> </dl> </section> <section id="general-parsing-configuration"> <h4>General parsing configuration</h4> <dl> <dt>dtype<span class="classifier">:Type name or dict of column -&gt; type, default None</span>
</dt>
<dd>
<p>Data type for data or columns. E.g. <code class="docutils literal notranslate"><span class="pre">{'a':</span> <span class="pre">np.float64,</span> <span class="pre">'b':</span> <span class="pre">np.int32,</span> <span class="pre">'c':</span> <span class="pre">'Int64'}</span></code> Use <code class="docutils literal notranslate"><span class="pre">str</span></code> or <code class="docutils literal notranslate"><span class="pre">object</span></code> together with suitable <code class="docutils literal notranslate"><span class="pre">na_values</span></code> settings to preserve and not interpret dtype. If converters are specified, they will be applied INSTEAD of dtype conversion.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.5.0: </span>Support for defaultdict was added. Specify a defaultdict as input where the default determines the dtype of the columns which are not explicitly listed.</p> </div> </dd> <dt>dtype_backend<span class="classifier">:{“numpy_nullable”, “pyarrow”}, defaults to NumPy backed DataFrames</span>
</dt>
<dd>
<p>Which dtype_backend to use, e.g. whether a DataFrame should have NumPy arrays, nullable dtypes are used for all dtypes that have a nullable implementation when “numpy_nullable” is set, pyarrow is used for all dtypes if “pyarrow” is set.</p> <p>The dtype_backends are still experimential.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> </dd> <dt>engine<span class="classifier">:{'c', 'python', 'pyarrow'}</span>
</dt>
<dd>
<p>Parser engine to use. The C and pyarrow engines are faster, while the python engine is currently more feature-complete. Multithreading is currently only supported by the pyarrow engine.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0: </span>The “pyarrow” engine was added as an <em>experimental</em> engine, and some features are unsupported, or may not work correctly, with this engine.</p> </div> </dd> <dt>converters<span class="classifier">:dict, default None</span>
</dt>
<dd>
<p>Dict of functions for converting values in certain columns. Keys can either be integers or column labels.</p> </dd> <dt>true_values<span class="classifier">:list, default None</span>
</dt>
<dd>
<p>Values to consider as <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p> </dd> <dt>false_values<span class="classifier">:list, default None</span>
</dt>
<dd>
<p>Values to consider as <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p> </dd> <dt>skipinitialspace<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>Skip spaces after delimiter.</p> </dd> <dt>skiprows<span class="classifier">:list-like or integer, default None</span>
</dt>
<dd>
<p>Line numbers to skip (0-indexed) or number of lines to skip (int) at the start of the file.</p> <p>If callable, the callable function will be evaluated against the row indices, returning True if the row should be skipped and False otherwise:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [6]: data = "col1,col2,col3\na,b,1\na,b,2\nc,d,3"

In [7]: pd.read_csv(StringIO(data))
Out[7]: 
  col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [8]: pd.read_csv(StringIO(data), skiprows=lambda x: x % 2 != 0)
Out[8]: 
  col1 col2  col3
0    a    b     2
</pre></div> </div> </dd> <dt>skipfooter<span class="classifier">:int, default 0</span>
</dt>
<dd>
<p>Number of lines at bottom of file to skip (unsupported with engine=’c’).</p> </dd> <dt>nrows<span class="classifier">:int, default None</span>
</dt>
<dd>
<p>Number of rows of file to read. Useful for reading pieces of large files.</p> </dd> <dt>low_memory<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>Internally process the file in chunks, resulting in lower memory use while parsing, but possibly mixed type inference. To ensure no mixed types either set <code class="docutils literal notranslate"><span class="pre">False</span></code>, or specify the type with the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> parameter. Note that the entire file is read into a single <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> regardless, use the <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> or <code class="docutils literal notranslate"><span class="pre">iterator</span></code> parameter to return the data in chunks. (Only valid with C parser)</p> </dd> <dt>memory_map<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>If a filepath is provided for <code class="docutils literal notranslate"><span class="pre">filepath_or_buffer</span></code>, map the file object directly onto memory and access the data directly from there. Using this option can improve performance because there is no longer any I/O overhead.</p> </dd> </dl> </section> <section id="na-and-missing-data-handling"> <h4>NA and missing data handling</h4> <dl> <dt>na_values<span class="classifier">:scalar, str, list-like, or dict, default None</span>
</dt>
<dd>
<p>Additional strings to recognize as NA/NaN. If dict passed, specific per-column NA values. See <a class="reference internal" href="#io-navaluesconst"><span class="std std-ref">na values const</span></a> below for a list of the values interpreted as NaN by default.</p> </dd> <dt>keep_default_na<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>Whether or not to include the default NaN values when parsing the data. Depending on whether <code class="docutils literal notranslate"><span class="pre">na_values</span></code> is passed in, the behavior is as follows:</p> <ul class="simple"> <li><p>If <code class="docutils literal notranslate"><span class="pre">keep_default_na</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">na_values</span></code> are specified, <code class="docutils literal notranslate"><span class="pre">na_values</span></code> is appended to the default NaN values used for parsing.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">keep_default_na</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, and <code class="docutils literal notranslate"><span class="pre">na_values</span></code> are not specified, only the default NaN values are used for parsing.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">keep_default_na</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <code class="docutils literal notranslate"><span class="pre">na_values</span></code> are specified, only the NaN values specified <code class="docutils literal notranslate"><span class="pre">na_values</span></code> are used for parsing.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">keep_default_na</span></code> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, and <code class="docutils literal notranslate"><span class="pre">na_values</span></code> are not specified, no strings will be parsed as NaN.</p></li> </ul> <p>Note that if <code class="docutils literal notranslate"><span class="pre">na_filter</span></code> is passed in as <code class="docutils literal notranslate"><span class="pre">False</span></code>, the <code class="docutils literal notranslate"><span class="pre">keep_default_na</span></code> and <code class="docutils literal notranslate"><span class="pre">na_values</span></code> parameters will be ignored.</p> </dd> <dt>na_filter<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>Detect missing value markers (empty strings and the value of na_values). In data without any NAs, passing <code class="docutils literal notranslate"><span class="pre">na_filter=False</span></code> can improve the performance of reading a large file.</p> </dd> <dt>verbose<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>Indicate number of NA values placed in non-numeric columns.</p> </dd> <dt>skip_blank_lines<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, skip over blank lines rather than interpreting as NaN values.</p> </dd> </dl> </section> <section id="datetime-handling"> <h4>Datetime handling</h4> <dl> <dt>parse_dates<span class="classifier">:boolean or list of ints or names or list of lists or dict, default False.</span>
</dt>
<dd>
<ul class="simple"> <li><p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> -&gt; try parsing the index.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">2,</span> <span class="pre">3]</span></code> -&gt; try parsing columns 1, 2, 3 each as a separate date column.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">[[1,</span> <span class="pre">3]]</span></code> -&gt; combine columns 1 and 3 and parse as a single date column.</p></li> <li><p>If <code class="docutils literal notranslate"><span class="pre">{'foo':</span> <span class="pre">[1,</span> <span class="pre">3]}</span></code> -&gt; parse columns 1, 3 as date and call result ‘foo’.</p></li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>A fast-path exists for iso8601-formatted dates.</p> </div> </dd> <dt>infer_datetime_format<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and parse_dates is enabled for a column, attempt to infer the datetime format to speed up the processing.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.0.0: </span>A strict version of this argument is now the default, passing it has no effect.</p> </div> </dd> <dt>keep_date_col<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code> and parse_dates specifies combining multiple columns then keep the original columns.</p> </dd> <dt>date_parser<span class="classifier">:function, default None</span>
</dt>
<dd>
<p>Function to use for converting a sequence of string columns to an array of datetime instances. The default uses <code class="docutils literal notranslate"><span class="pre">dateutil.parser.parser</span></code> to do the conversion. pandas will try to call date_parser in three different ways, advancing to the next if an exception occurs: 1) Pass one or more arrays (as defined by parse_dates) as arguments; 2) concatenate (row-wise) the string values from the columns defined by parse_dates into a single array and pass that; and 3) call date_parser once for each row using one or more strings (corresponding to the columns defined by parse_dates) as arguments.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.0.0: </span>Use <code class="docutils literal notranslate"><span class="pre">date_format</span></code> instead, or read in as <code class="docutils literal notranslate"><span class="pre">object</span></code> and then apply <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code></a> as-needed.</p> </div> </dd> <dt>date_format<span class="classifier">:str or dict of column -&gt; format, default None</span>
</dt>
<dd>
<p>If used in conjunction with <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code>, will parse dates according to this format. For anything more complex, please read in as <code class="docutils literal notranslate"><span class="pre">object</span></code> and then apply <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code></a> as-needed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.0.</span></p> </div> </dd> <dt>dayfirst<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>DD/MM format dates, international and European format.</p> </dd> <dt>cache_dates<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>If True, use a cache of unique, converted dates to apply the datetime conversion. May produce significant speed-up when parsing duplicate date strings, especially ones with timezone offsets.</p> </dd> </dl> </section> <section id="iteration"> <h4>Iteration</h4> <dl> <dt>iterator<span class="classifier">:boolean, default False</span>
</dt>
<dd>
<p>Return <code class="docutils literal notranslate"><span class="pre">TextFileReader</span></code> object for iteration or getting chunks with <code class="docutils literal notranslate"><span class="pre">get_chunk()</span></code>.</p> </dd> <dt>chunksize<span class="classifier">:int, default None</span>
</dt>
<dd>
<p>Return <code class="docutils literal notranslate"><span class="pre">TextFileReader</span></code> object for iteration. See <a class="reference internal" href="#io-chunking"><span class="std std-ref">iterating and chunking</span></a> below.</p> </dd> </dl> </section> <section id="quoting-compression-and-file-format"> <h4>Quoting, compression, and file format</h4> <dl> <dt>compression<span class="classifier">:{'infer', 'gzip', 'bz2', 'zip', 'xz', 'zstd', None, dict}, default 'infer'</span>
</dt>
<dd>
<p>For on-the-fly decompression of on-disk data. If ‘infer’, then use gzip, bz2, zip, xz, or zstandard if <code class="docutils literal notranslate"><span class="pre">filepath_or_buffer</span></code> is path-like ending in ‘.gz’, ‘.bz2’, ‘.zip’, ‘.xz’, ‘.zst’, respectively, and no decompression otherwise. If using ‘zip’, the ZIP file must contain only one data file to be read in. Set to <code class="docutils literal notranslate"><span class="pre">None</span></code> for no decompression. Can also be a dict with key <code class="docutils literal notranslate"><span class="pre">'method'</span></code> set to one of {<code class="docutils literal notranslate"><span class="pre">'zip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'zstd'</span></code>} and other key-value pairs are forwarded to <code class="docutils literal notranslate"><span class="pre">zipfile.ZipFile</span></code>, <code class="docutils literal notranslate"><span class="pre">gzip.GzipFile</span></code>, <code class="docutils literal notranslate"><span class="pre">bz2.BZ2File</span></code>, or <code class="docutils literal notranslate"><span class="pre">zstandard.ZstdDecompressor</span></code>. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code class="docutils literal notranslate"><span class="pre">compression={'method':</span> <span class="pre">'gzip',</span> <span class="pre">'compresslevel':</span> <span class="pre">1,</span> <span class="pre">'mtime':</span> <span class="pre">1}</span></code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.2.0: </span>Previous versions forwarded dict entries for ‘gzip’ to <code class="docutils literal notranslate"><span class="pre">gzip.open</span></code>.</p> </div> </dd> <dt>thousands<span class="classifier">:str, default None</span>
</dt>
<dd>
<p>Thousands separator.</p> </dd> <dt>decimal<span class="classifier">:str, default '.'</span>
</dt>
<dd>
<p>Character to recognize as decimal point. E.g. use <code class="docutils literal notranslate"><span class="pre">','</span></code> for European data.</p> </dd> <dt>float_precision<span class="classifier">:string, default None</span>
</dt>
<dd>
<p>Specifies which converter the C engine should use for floating-point values. The options are <code class="docutils literal notranslate"><span class="pre">None</span></code> for the ordinary converter, <code class="docutils literal notranslate"><span class="pre">high</span></code> for the high-precision converter, and <code class="docutils literal notranslate"><span class="pre">round_trip</span></code> for the round-trip converter.</p> </dd> <dt>lineterminator<span class="classifier">:str (length 1), default None</span>
</dt>
<dd>
<p>Character to break file into lines. Only valid with C parser.</p> </dd> <dt>quotechar<span class="classifier">:str (length 1)</span>
</dt>
<dd>
<p>The character used to denote the start and end of a quoted item. Quoted items can include the delimiter and it will be ignored.</p> </dd> <dt>quoting<span class="classifier">:int or csv.QUOTE_* instance, default 0</span>
</dt>
<dd>
<p>Control field quoting behavior per <code class="docutils literal notranslate"><span class="pre">csv.QUOTE_*</span></code> constants. Use one of <code class="docutils literal notranslate"><span class="pre">QUOTE_MINIMAL</span></code> (0), <code class="docutils literal notranslate"><span class="pre">QUOTE_ALL</span></code> (1), <code class="docutils literal notranslate"><span class="pre">QUOTE_NONNUMERIC</span></code> (2) or <code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code> (3).</p> </dd> <dt>doublequote<span class="classifier">:boolean, default True</span>
</dt>
<dd>
<p>When <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> is specified and <code class="docutils literal notranslate"><span class="pre">quoting</span></code> is not <code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code>, indicate whether or not to interpret two consecutive <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> elements <strong>inside</strong> a field as a single <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> element.</p> </dd> <dt>escapechar<span class="classifier">:str (length 1), default None</span>
</dt>
<dd>
<p>One-character string used to escape delimiter when quoting is <code class="docutils literal notranslate"><span class="pre">QUOTE_NONE</span></code>.</p> </dd> <dt>comment<span class="classifier">:str, default None</span>
</dt>
<dd>
<p>Indicates remainder of line should not be parsed. If found at the beginning of a line, the line will be ignored altogether. This parameter must be a single character. Like empty lines (as long as <code class="docutils literal notranslate"><span class="pre">skip_blank_lines=True</span></code>), fully commented lines are ignored by the parameter <code class="docutils literal notranslate"><span class="pre">header</span></code> but not by <code class="docutils literal notranslate"><span class="pre">skiprows</span></code>. For example, if <code class="docutils literal notranslate"><span class="pre">comment='#'</span></code>, parsing ‘#empty\na,b,c\n1,2,3’ with <code class="docutils literal notranslate"><span class="pre">header=0</span></code> will result in ‘a,b,c’ being treated as the header.</p> </dd> <dt>encoding<span class="classifier">:str, default None</span>
</dt>
<dd>
<p>Encoding to use for UTF when reading/writing (e.g. <code class="docutils literal notranslate"><span class="pre">'utf-8'</span></code>). <a class="reference external" href="https://docs.python.org/3/library/codecs.html#standard-encodings">List of Python standard encodings</a>.</p> </dd> <dt>dialect<span class="classifier">:str or csv.Dialect instance, default None</span>
</dt>
<dd>
<p>If provided, this parameter will override values (default or not) for the following parameters: <code class="docutils literal notranslate"><span class="pre">delimiter</span></code>, <code class="docutils literal notranslate"><span class="pre">doublequote</span></code>, <code class="docutils literal notranslate"><span class="pre">escapechar</span></code>, <code class="docutils literal notranslate"><span class="pre">skipinitialspace</span></code>, <code class="docutils literal notranslate"><span class="pre">quotechar</span></code>, and <code class="docutils literal notranslate"><span class="pre">quoting</span></code>. If it is necessary to override values, a ParserWarning will be issued. See <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">csv.Dialect</span></code></a> documentation for more details.</p> </dd> </dl> </section> <section id="error-handling"> <h4>Error handling</h4> <dl> <dt>on_bad_lines<span class="classifier">:(‘error’, ‘warn’, ‘skip’), default ‘error’</span>
</dt>
<dd>
<p>Specifies what to do upon encountering a bad line (a line with too many fields). Allowed values are :</p> <ul class="simple"> <li><p>‘error’, raise an ParserError when a bad line is encountered.</p></li> <li><p>‘warn’, print a warning when a bad line is encountered and skip that line.</p></li> <li><p>‘skip’, skip bad lines without raising or warning when they are encountered.</p></li> </ul> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> </dd> </dl> </section> </section> <section id="specifying-column-data-types"> <h3>Specifying column data types</h3> <p>You can indicate the data type for the whole <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> or individual columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [9]: import numpy as np

In [10]: data = "a,b,c,d\n1,2,3,4\n5,6,7,8\n9,10,11"

In [11]: print(data)
a,b,c,d
1,2,3,4
5,6,7,8
9,10,11

In [12]: df = pd.read_csv(StringIO(data), dtype=object)

In [13]: df
Out[13]: 
   a   b   c    d
0  1   2   3    4
1  5   6   7    8
2  9  10  11  NaN

In [14]: df["a"][0]
Out[14]: '1'

In [15]: df = pd.read_csv(StringIO(data), dtype={"b": object, "c": np.float64, "d": "Int64"})

In [16]: df.dtypes
Out[16]: 
a      int64
b     object
c    float64
d      Int64
dtype: object
</pre></div> </div> <p>Fortunately, pandas offers more than one way to ensure that your column(s) contain only one <code class="docutils literal notranslate"><span class="pre">dtype</span></code>. If you’re unfamiliar with these concepts, you can see <a class="reference internal" href="basics.html#basics-dtypes"><span class="std std-ref">here</span></a> to learn more about dtypes, and <a class="reference internal" href="basics.html#basics-object-conversion"><span class="std std-ref">here</span></a> to learn more about <code class="docutils literal notranslate"><span class="pre">object</span></code> conversion in pandas.</p> <p>For instance, you can use the <code class="docutils literal notranslate"><span class="pre">converters</span></code> argument of <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [17]: data = "col_1\n1\n2\n'A'\n4.22"

In [18]: df = pd.read_csv(StringIO(data), converters={"col_1": str})

In [19]: df
Out[19]: 
  col_1
0     1
1     2
2   'A'
3  4.22

In [20]: df["col_1"].apply(type).value_counts()
Out[20]: 
col_1
&lt;class 'str'&gt;    4
Name: count, dtype: int64
</pre></div> </div> <p>Or you can use the <a class="reference internal" href="../reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code></a> function to coerce the dtypes after reading in the data,</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: df2 = pd.read_csv(StringIO(data))

In [22]: df2["col_1"] = pd.to_numeric(df2["col_1"], errors="coerce")

In [23]: df2
Out[23]: 
   col_1
0   1.00
1   2.00
2    NaN
3   4.22

In [24]: df2["col_1"].apply(type).value_counts()
Out[24]: 
col_1
&lt;class 'float'&gt;    4
Name: count, dtype: int64
</pre></div> </div> <p>which will convert all valid parsing to floats, leaving the invalid parsing as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <p>Ultimately, how you deal with reading in columns containing mixed dtypes depends on your specific needs. In the case above, if you wanted to <code class="docutils literal notranslate"><span class="pre">NaN</span></code> out the data anomalies, then <a class="reference internal" href="../reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code></a> is probably your best option. However, if you wanted for all the data to be coerced, no matter the type, then using the <code class="docutils literal notranslate"><span class="pre">converters</span></code> argument of <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a> would certainly be worth trying.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In some cases, reading in abnormal data with columns containing mixed dtypes will result in an inconsistent dataset. If you rely on pandas to infer the dtypes of your columns, the parsing engine will go and infer the dtypes for different chunks of the data, rather than the whole dataset at once. Consequently, you can end up with column(s) with mixed dtypes. For example,</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: col_1 = list(range(500000)) + ["a", "b"] + list(range(500000))

In [26]: df = pd.DataFrame({"col_1": col_1})

In [27]: df.to_csv("foo.csv")

In [28]: mixed_df = pd.read_csv("foo.csv")

In [29]: mixed_df["col_1"].apply(type).value_counts()
Out[29]: 
col_1
&lt;class 'int'&gt;    737858
&lt;class 'str'&gt;    262144
Name: count, dtype: int64

In [30]: mixed_df["col_1"].dtype
Out[30]: dtype('O')
</pre></div> </div> <p>will result with <code class="docutils literal notranslate"><span class="pre">mixed_df</span></code> containing an <code class="docutils literal notranslate"><span class="pre">int</span></code> dtype for certain chunks of the column, and <code class="docutils literal notranslate"><span class="pre">str</span></code> for others due to the mixed dtypes from the data that was read in. It is important to note that the overall column will be marked with a <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of <code class="docutils literal notranslate"><span class="pre">object</span></code>, which is used for columns with mixed dtypes.</p> </div> <p>Setting <code class="docutils literal notranslate"><span class="pre">dtype_backend="numpy_nullable"</span></code> will result in nullable dtypes for every column.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [31]: data = """a,b,c,d,e,f,g,h,i,j
   ....: 1,2.5,True,a,,,,,12-31-2019,
   ....: 3,4.5,False,b,6,7.5,True,a,12-31-2019,
   ....: """
   ....: 

In [32]: df = pd.read_csv(StringIO(data), dtype_backend="numpy_nullable", parse_dates=["i"])

In [33]: df
Out[33]: 
   a    b      c  d     e     f     g     h          i     j
0  1  2.5   True  a  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; 2019-12-31  &lt;NA&gt;
1  3  4.5  False  b     6   7.5  True     a 2019-12-31  &lt;NA&gt;

In [34]: df.dtypes
Out[34]: 
a             Int64
b           Float64
c           boolean
d    string[python]
e             Int64
f           Float64
g           boolean
h    string[python]
i    datetime64[ns]
j             Int64
dtype: object
</pre></div> </div> </section> <section id="specifying-categorical-dtype"> <h3>Specifying categorical dtype</h3> <p><code class="docutils literal notranslate"><span class="pre">Categorical</span></code> columns can be parsed directly by specifying <code class="docutils literal notranslate"><span class="pre">dtype='category'</span></code> or <code class="docutils literal notranslate"><span class="pre">dtype=CategoricalDtype(categories,</span> <span class="pre">ordered)</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [35]: data = "col1,col2,col3\na,b,1\na,b,2\nc,d,3"

In [36]: pd.read_csv(StringIO(data))
Out[36]: 
  col1 col2  col3
0    a    b     1
1    a    b     2
2    c    d     3

In [37]: pd.read_csv(StringIO(data)).dtypes
Out[37]: 
col1    object
col2    object
col3     int64
dtype: object

In [38]: pd.read_csv(StringIO(data), dtype="category").dtypes
Out[38]: 
col1    category
col2    category
col3    category
dtype: object
</pre></div> </div> <p>Individual columns can be parsed as a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> using a dict specification:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: pd.read_csv(StringIO(data), dtype={"col1": "category"}).dtypes
Out[39]: 
col1    category
col2      object
col3       int64
dtype: object
</pre></div> </div> <p>Specifying <code class="docutils literal notranslate"><span class="pre">dtype='category'</span></code> will result in an unordered <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> whose <code class="docutils literal notranslate"><span class="pre">categories</span></code> are the unique values observed in the data. For more control on the categories and order, create a <code class="xref py py-class docutils literal notranslate"><span class="pre">CategoricalDtype</span></code> ahead of time, and pass that for that column’s <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [40]: from pandas.api.types import CategoricalDtype

In [41]: dtype = CategoricalDtype(["d", "c", "b", "a"], ordered=True)

In [42]: pd.read_csv(StringIO(data), dtype={"col1": dtype}).dtypes
Out[42]: 
col1    category
col2      object
col3       int64
dtype: object
</pre></div> </div> <p>When using <code class="docutils literal notranslate"><span class="pre">dtype=CategoricalDtype</span></code>, “unexpected” values outside of <code class="docutils literal notranslate"><span class="pre">dtype.categories</span></code> are treated as missing values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [43]: dtype = CategoricalDtype(["a", "b", "d"])  # No 'c'

In [44]: pd.read_csv(StringIO(data), dtype={"col1": dtype}).col1
Out[44]: 
0      a
1      a
2    NaN
Name: col1, dtype: category
Categories (3, object): ['a', 'b', 'd']
</pre></div> </div> <p>This matches the behavior of <code class="xref py py-meth docutils literal notranslate"><span class="pre">Categorical.set_categories()</span></code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>With <code class="docutils literal notranslate"><span class="pre">dtype='category'</span></code>, the resulting categories will always be parsed as strings (object dtype). If the categories are numeric they can be converted using the <a class="reference internal" href="../reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_numeric()</span></code></a> function, or as appropriate, another converter such as <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code></a>.</p> <p>When <code class="docutils literal notranslate"><span class="pre">dtype</span></code> is a <code class="docutils literal notranslate"><span class="pre">CategoricalDtype</span></code> with homogeneous <code class="docutils literal notranslate"><span class="pre">categories</span></code> ( all numeric, all datetimes, etc.), the conversion is done automatically.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [45]: df = pd.read_csv(StringIO(data), dtype="category")

In [46]: df.dtypes
Out[46]: 
col1    category
col2    category
col3    category
dtype: object

In [47]: df["col3"]
Out[47]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, object): ['1', '2', '3']

In [48]: new_categories = pd.to_numeric(df["col3"].cat.categories)

In [49]: df["col3"] = df["col3"].cat.rename_categories(new_categories)

In [50]: df["col3"]
Out[50]: 
0    1
1    2
2    3
Name: col3, dtype: category
Categories (3, int64): [1, 2, 3]
</pre></div> </div> </div> </section> <section id="naming-and-using-columns"> <h3>Naming and using columns</h3> <section id="handling-column-names"> <h4>Handling column names</h4> <p>A file may or may not have a header row. pandas assumes the first row should be used as the column names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [51]: data = "a,b,c\n1,2,3\n4,5,6\n7,8,9"

In [52]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [53]: pd.read_csv(StringIO(data))
Out[53]: 
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</pre></div> </div> <p>By specifying the <code class="docutils literal notranslate"><span class="pre">names</span></code> argument in conjunction with <code class="docutils literal notranslate"><span class="pre">header</span></code> you can indicate other names to use and whether or not to throw away the header row (if any):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [54]: print(data)
a,b,c
1,2,3
4,5,6
7,8,9

In [55]: pd.read_csv(StringIO(data), names=["foo", "bar", "baz"], header=0)
Out[55]: 
   foo  bar  baz
0    1    2    3
1    4    5    6
2    7    8    9

In [56]: pd.read_csv(StringIO(data), names=["foo", "bar", "baz"], header=None)
Out[56]: 
  foo bar baz
0   a   b   c
1   1   2   3
2   4   5   6
3   7   8   9
</pre></div> </div> <p>If the header is in a row other than the first, pass the row number to <code class="docutils literal notranslate"><span class="pre">header</span></code>. This will skip the preceding rows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [57]: data = "skip this skip it\na,b,c\n1,2,3\n4,5,6\n7,8,9"

In [58]: pd.read_csv(StringIO(data), header=1)
Out[58]: 
   a  b  c
0  1  2  3
1  4  5  6
2  7  8  9
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Default behavior is to infer the column names: if no names are passed the behavior is identical to <code class="docutils literal notranslate"><span class="pre">header=0</span></code> and column names are inferred from the first non-blank line of the file, if column names are passed explicitly then the behavior is identical to <code class="docutils literal notranslate"><span class="pre">header=None</span></code>.</p> </div> </section> </section> <section id="duplicate-names-parsing"> <h3>Duplicate names parsing</h3> <p>If the file or header contains duplicate names, pandas will by default distinguish between them so as to prevent overwriting data:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [59]: data = "a,b,a\n0,1,2\n3,4,5"

In [60]: pd.read_csv(StringIO(data))
Out[60]: 
   a  b  a.1
0  0  1    2
1  3  4    5
</pre></div> </div> <p>There is no more duplicate data because duplicate columns ‘X’, …, ‘X’ become ‘X’, ‘X.1’, …, ‘X.N’.</p> <section id="filtering-columns-usecols"> <h4>Filtering columns (<code class="docutils literal notranslate"><span class="pre">usecols</span></code>)</h4> <p>The <code class="docutils literal notranslate"><span class="pre">usecols</span></code> argument allows you to select any subset of the columns in a file, either using the column names, position numbers or a callable:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [61]: data = "a,b,c,d\n1,2,3,foo\n4,5,6,bar\n7,8,9,baz"

In [62]: pd.read_csv(StringIO(data))
Out[62]: 
   a  b  c    d
0  1  2  3  foo
1  4  5  6  bar
2  7  8  9  baz

In [63]: pd.read_csv(StringIO(data), usecols=["b", "d"])
Out[63]: 
   b    d
0  2  foo
1  5  bar
2  8  baz

In [64]: pd.read_csv(StringIO(data), usecols=[0, 2, 3])
Out[64]: 
   a  c    d
0  1  3  foo
1  4  6  bar
2  7  9  baz

In [65]: pd.read_csv(StringIO(data), usecols=lambda x: x.upper() in ["A", "C"])
Out[65]: 
   a  c
0  1  3
1  4  6
2  7  9
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">usecols</span></code> argument can also be used to specify which columns not to use in the final result:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [66]: pd.read_csv(StringIO(data), usecols=lambda x: x not in ["a", "c"])
Out[66]: 
   b    d
0  2  foo
1  5  bar
2  8  baz
</pre></div> </div> <p>In this case, the callable is specifying that we exclude the “a” and “c” columns from the output.</p> </section> </section> <section id="comments-and-empty-lines"> <h3>Comments and empty lines</h3> <section id="ignoring-line-comments-and-empty-lines"> <h4>Ignoring line comments and empty lines</h4> <p>If the <code class="docutils literal notranslate"><span class="pre">comment</span></code> parameter is specified, then completely commented lines will be ignored. By default, completely blank lines will be ignored as well.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [67]: data = "\na,b,c\n  \n# commented line\n1,2,3\n\n4,5,6"

In [68]: print(data)

a,b,c
  
# commented line
1,2,3

4,5,6

In [69]: pd.read_csv(StringIO(data), comment="#")
Out[69]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre></div> </div> <p>If <code class="docutils literal notranslate"><span class="pre">skip_blank_lines=False</span></code>, then <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> will not ignore blank lines:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [70]: data = "a,b,c\n\n1,2,3\n\n\n4,5,6"

In [71]: pd.read_csv(StringIO(data), skip_blank_lines=False)
Out[71]: 
     a    b    c
0  NaN  NaN  NaN
1  1.0  2.0  3.0
2  NaN  NaN  NaN
3  NaN  NaN  NaN
4  4.0  5.0  6.0
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The presence of ignored lines might create ambiguities involving line numbers; the parameter <code class="docutils literal notranslate"><span class="pre">header</span></code> uses row numbers (ignoring commented/empty lines), while <code class="docutils literal notranslate"><span class="pre">skiprows</span></code> uses line numbers (including commented/empty lines):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [72]: data = "#comment\na,b,c\nA,B,C\n1,2,3"

In [73]: pd.read_csv(StringIO(data), comment="#", header=1)
Out[73]: 
   A  B  C
0  1  2  3

In [74]: data = "A,B,C\n#comment\na,b,c\n1,2,3"

In [75]: pd.read_csv(StringIO(data), comment="#", skiprows=2)
Out[75]: 
   a  b  c
0  1  2  3
</pre></div> </div> <p>If both <code class="docutils literal notranslate"><span class="pre">header</span></code> and <code class="docutils literal notranslate"><span class="pre">skiprows</span></code> are specified, <code class="docutils literal notranslate"><span class="pre">header</span></code> will be relative to the end of <code class="docutils literal notranslate"><span class="pre">skiprows</span></code>. For example:</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [76]: data = (
   ....:     "# empty\n"
   ....:     "# second empty line\n"
   ....:     "# third emptyline\n"
   ....:     "X,Y,Z\n"
   ....:     "1,2,3\n"
   ....:     "A,B,C\n"
   ....:     "1,2.,4.\n"
   ....:     "5.,NaN,10.0\n"
   ....: )
   ....: 

In [77]: print(data)
# empty
# second empty line
# third emptyline
X,Y,Z
1,2,3
A,B,C
1,2.,4.
5.,NaN,10.0


In [78]: pd.read_csv(StringIO(data), comment="#", skiprows=4, header=1)
Out[78]: 
     A    B     C
0  1.0  2.0   4.0
1  5.0  NaN  10.0
</pre></div> </div> </section> <section id="comments"> <h4>Comments</h4> <p>Sometimes comments or meta data may be included in a file:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: data = (
   ....:     "ID,level,category\n"
   ....:     "Patient1,123000,x # really unpleasant\n"
   ....:     "Patient2,23000,y # wouldn't take his medicine\n"
   ....:     "Patient3,1234018,z # awesome"
   ....: )
   ....: 

In [80]: with open("tmp.csv", "w") as fh:
   ....:     fh.write(data)
   ....: 

In [81]: print(open("tmp.csv").read())
ID,level,category
Patient1,123000,x # really unpleasant
Patient2,23000,y # wouldn't take his medicine
Patient3,1234018,z # awesome
</pre></div> </div> <p>By default, the parser includes the comments in the output:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [82]: df = pd.read_csv("tmp.csv")

In [83]: df
Out[83]: 
         ID    level                        category
0  Patient1   123000           x # really unpleasant
1  Patient2    23000  y # wouldn't take his medicine
2  Patient3  1234018                     z # awesome
</pre></div> </div> <p>We can suppress the comments using the <code class="docutils literal notranslate"><span class="pre">comment</span></code> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [84]: df = pd.read_csv("tmp.csv", comment="#")

In [85]: df
Out[85]: 
         ID    level category
0  Patient1   123000       x 
1  Patient2    23000       y 
2  Patient3  1234018       z 
</pre></div> </div> </section> </section> <section id="dealing-with-unicode-data"> <h3>Dealing with Unicode data</h3> <p>The <code class="docutils literal notranslate"><span class="pre">encoding</span></code> argument should be used for encoded unicode data, which will result in byte strings being decoded to unicode in the result:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [86]: from io import BytesIO

In [87]: data = b"word,length\n" b"Tr\xc3\xa4umen,7\n" b"Gr\xc3\xbc\xc3\x9fe,5"

In [88]: data = data.decode("utf8").encode("latin-1")

In [89]: df = pd.read_csv(BytesIO(data), encoding="latin-1")

In [90]: df
Out[90]: 
      word  length
0  Träumen       7
1    Grüße       5

In [91]: df["word"][1]
Out[91]: 'Grüße'
</pre></div> </div> <p>Some formats which encode all characters as multiple bytes, like UTF-16, won’t parse correctly at all without specifying the encoding. <a class="reference external" href="https://docs.python.org/3/library/codecs.html#standard-encodings">Full list of Python standard encodings</a>.</p> </section> <section id="index-columns-and-trailing-delimiters"> <h3>Index columns and trailing delimiters</h3> <p>If a file has one more column of data than the number of column names, the first column will be used as the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>’s row names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [92]: data = "a,b,c\n4,apple,bat,5.7\n8,orange,cow,10"

In [93]: pd.read_csv(StringIO(data))
Out[93]: 
        a    b     c
4   apple  bat   5.7
8  orange  cow  10.0
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [94]: data = "index,a,b,c\n4,apple,bat,5.7\n8,orange,cow,10"

In [95]: pd.read_csv(StringIO(data), index_col=0)
Out[95]: 
            a    b     c
index                   
4       apple  bat   5.7
8      orange  cow  10.0
</pre></div> </div> <p>Ordinarily, you can achieve this behavior using the <code class="docutils literal notranslate"><span class="pre">index_col</span></code> option.</p> <p>There are some exception cases when a file has been prepared with delimiters at the end of each data line, confusing the parser. To explicitly disable the index column inference and discard the last column, pass <code class="docutils literal notranslate"><span class="pre">index_col=False</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [96]: data = "a,b,c\n4,apple,bat,\n8,orange,cow,"

In [97]: print(data)
a,b,c
4,apple,bat,
8,orange,cow,

In [98]: pd.read_csv(StringIO(data))
Out[98]: 
        a    b   c
4   apple  bat NaN
8  orange  cow NaN

In [99]: pd.read_csv(StringIO(data), index_col=False)
Out[99]: 
   a       b    c
0  4   apple  bat
1  8  orange  cow
</pre></div> </div> <p>If a subset of data is being parsed using the <code class="docutils literal notranslate"><span class="pre">usecols</span></code> option, the <code class="docutils literal notranslate"><span class="pre">index_col</span></code> specification is based on that subset, not the original data.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [100]: data = "a,b,c\n4,apple,bat,\n8,orange,cow,"

In [101]: print(data)
a,b,c
4,apple,bat,
8,orange,cow,

In [102]: pd.read_csv(StringIO(data), usecols=["b", "c"])
Out[102]: 
     b   c
4  bat NaN
8  cow NaN

In [103]: pd.read_csv(StringIO(data), usecols=["b", "c"], index_col=0)
Out[103]: 
     b   c
4  bat NaN
8  cow NaN
</pre></div> </div> </section> <section id="date-handling"> <h3>Date Handling</h3> <section id="specifying-date-columns"> <h4>Specifying date columns</h4> <p>To better facilitate working with datetime data, <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a> uses the keyword arguments <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code> and <code class="docutils literal notranslate"><span class="pre">date_format</span></code> to allow users to specify a variety of columns and date/time formats to turn the input text data into <code class="docutils literal notranslate"><span class="pre">datetime</span></code> objects.</p> <p>The simplest case is to just pass in <code class="docutils literal notranslate"><span class="pre">parse_dates=True</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [104]: with open("foo.csv", mode="w") as f:
   .....:     f.write("date,A,B,C\n20090101,a,1,2\n20090102,b,3,4\n20090103,c,4,5")
   .....: 

# Use a column as an index, and parse it as dates.
In [105]: df = pd.read_csv("foo.csv", index_col=0, parse_dates=True)

In [106]: df
Out[106]: 
            A  B  C
date               
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5

# These are Python datetime objects
In [107]: df.index
Out[107]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', name='date', freq=None)
</pre></div> </div> <p>It is often the case that we may want to store date and time data separately, or store various date fields separately. the <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code> keyword can be used to specify a combination of columns to parse the dates and/or times from.</p> <p>You can specify a list of column lists to <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code>, the resulting date columns will be prepended to the output (so as to not affect the existing column order) and the new column names will be the concatenation of the component column names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [108]: data = (
   .....:     "KORD,19990127, 19:00:00, 18:56:00, 0.8100\n"
   .....:     "KORD,19990127, 20:00:00, 19:56:00, 0.0100\n"
   .....:     "KORD,19990127, 21:00:00, 20:56:00, -0.5900\n"
   .....:     "KORD,19990127, 21:00:00, 21:18:00, -0.9900\n"
   .....:     "KORD,19990127, 22:00:00, 21:56:00, -0.5900\n"
   .....:     "KORD,19990127, 23:00:00, 22:56:00, -0.5900"
   .....: )
   .....: 

In [109]: with open("tmp.csv", "w") as fh:
   .....:     fh.write(data)
   .....: 

In [110]: df = pd.read_csv("tmp.csv", header=None, parse_dates=[[1, 2], [1, 3]])

In [111]: df
Out[111]: 
                  1_2                 1_3     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre></div> </div> <p>By default the parser removes the component date columns, but you can choose to retain them via the <code class="docutils literal notranslate"><span class="pre">keep_date_col</span></code> keyword:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: df = pd.read_csv(
   .....:     "tmp.csv", header=None, parse_dates=[[1, 2], [1, 3]], keep_date_col=True
   .....: )
   .....: 

In [113]: df
Out[113]: 
                  1_2                 1_3     0  ...          2          3     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  ...   19:00:00   18:56:00  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  ...   20:00:00   19:56:00  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD  ...   21:00:00   20:56:00 -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD  ...   21:00:00   21:18:00 -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD  ...   22:00:00   21:56:00 -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD  ...   23:00:00   22:56:00 -0.59

[6 rows x 7 columns]
</pre></div> </div> <p>Note that if you wish to combine multiple columns into a single date column, a nested list must be used. In other words, <code class="docutils literal notranslate"><span class="pre">parse_dates=[1,</span> <span class="pre">2]</span></code> indicates that the second and third columns should each be parsed as separate date columns while <code class="docutils literal notranslate"><span class="pre">parse_dates=[[1,</span> <span class="pre">2]]</span></code> means the two columns should be parsed into a single column.</p> <p>You can also use a dict to specify custom name columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [114]: date_spec = {"nominal": [1, 2], "actual": [1, 3]}

In [115]: df = pd.read_csv("tmp.csv", header=None, parse_dates=date_spec)

In [116]: df
Out[116]: 
              nominal              actual     0     4
0 1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1 1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
2 1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
3 1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
4 1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
5 1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre></div> </div> <p>It is important to remember that if multiple text columns are to be parsed into a single date column, then a new column is prepended to the data. The <code class="docutils literal notranslate"><span class="pre">index_col</span></code> specification is based off of this new set of columns rather than the original data columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [117]: date_spec = {"nominal": [1, 2], "actual": [1, 3]}

In [118]: df = pd.read_csv(
   .....:     "tmp.csv", header=None, parse_dates=date_spec, index_col=0
   .....: )  # index is the nominal column
   .....: 

In [119]: df
Out[119]: 
                                 actual     0     4
nominal                                            
1999-01-27 19:00:00 1999-01-27 18:56:00  KORD  0.81
1999-01-27 20:00:00 1999-01-27 19:56:00  KORD  0.01
1999-01-27 21:00:00 1999-01-27 20:56:00  KORD -0.59
1999-01-27 21:00:00 1999-01-27 21:18:00  KORD -0.99
1999-01-27 22:00:00 1999-01-27 21:56:00  KORD -0.59
1999-01-27 23:00:00 1999-01-27 22:56:00  KORD -0.59
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If a column or index contains an unparsable date, the entire column or index will be returned unaltered as an object data type. For non-standard datetime parsing, use <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code></a> after <code class="docutils literal notranslate"><span class="pre">pd.read_csv</span></code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>read_csv has a fast_path for parsing datetime strings in iso8601 format, e.g “2000-01-01T00:01:02+00:00” and similar variations. If you can arrange for your data to store datetimes in this format, load times will be significantly faster, ~20x has been observed.</p> </div> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 2.2.0: </span>Combining date columns inside read_csv is deprecated. Use <code class="docutils literal notranslate"><span class="pre">pd.to_datetime</span></code> on the relevant result columns instead.</p> </div> </section> <section id="date-parsing-functions"> <h4>Date parsing functions</h4> <p>Finally, the parser allows you to specify a custom <code class="docutils literal notranslate"><span class="pre">date_format</span></code>. Performance-wise, you should try these methods of parsing dates in order:</p> <ol class="arabic simple"> <li><p>If you know the format, use <code class="docutils literal notranslate"><span class="pre">date_format</span></code>, e.g.: <code class="docutils literal notranslate"><span class="pre">date_format="%d/%m/%Y"</span></code> or <code class="docutils literal notranslate"><span class="pre">date_format={column_name:</span> <span class="pre">"%d/%m/%Y"}</span></code>.</p></li> <li><p>If you different formats for different columns, or want to pass any extra options (such as <code class="docutils literal notranslate"><span class="pre">utc</span></code>) to <code class="docutils literal notranslate"><span class="pre">to_datetime</span></code>, then you should read in your data as <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype, and then use <code class="docutils literal notranslate"><span class="pre">to_datetime</span></code>.</p></li> </ol> </section> <section id="parsing-a-csv-with-mixed-timezones"> <h4>Parsing a CSV with mixed timezones</h4> <p>pandas cannot natively represent a column or index with mixed timezones. If your CSV file contains columns with a mixture of timezones, the default result will be an object-dtype column with strings, even with <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code>. To parse the mixed-timezone values as a datetime column, read in as <code class="docutils literal notranslate"><span class="pre">object</span></code> dtype and then call <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_datetime()</span></code></a> with <code class="docutils literal notranslate"><span class="pre">utc=True</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [120]: content = """\
   .....: a
   .....: 2000-01-01T00:00:00+05:00
   .....: 2000-01-01T00:00:00+06:00"""
   .....: 

In [121]: df = pd.read_csv(StringIO(content))

In [122]: df["a"] = pd.to_datetime(df["a"], utc=True)

In [123]: df["a"]
Out[123]: 
0   1999-12-31 19:00:00+00:00
1   1999-12-31 18:00:00+00:00
Name: a, dtype: datetime64[ns, UTC]
</pre></div> </div> </section> <section id="inferring-datetime-format"> <h4>Inferring datetime format</h4> <p>Here are some examples of datetime strings that can be guessed (all representing December 30th, 2011 at 00:00:00):</p> <ul class="simple"> <li><p>“20111230”</p></li> <li><p>“2011/12/30”</p></li> <li><p>“20111230 00:00:00”</p></li> <li><p>“12/30/2011 00:00:00”</p></li> <li><p>“30/Dec/2011 00:00:00”</p></li> <li><p>“30/December/2011 00:00:00”</p></li> </ul> <p>Note that format inference is sensitive to <code class="docutils literal notranslate"><span class="pre">dayfirst</span></code>. With <code class="docutils literal notranslate"><span class="pre">dayfirst=True</span></code>, it will guess “01/12/2011” to be December 1st. With <code class="docutils literal notranslate"><span class="pre">dayfirst=False</span></code> (default) it will guess “01/12/2011” to be January 12th.</p> <p>If you try to parse a column of date strings, pandas will attempt to guess the format from the first non-NaN element, and will then parse the rest of the column with that format. If pandas fails to guess the format (for example if your first string is <code class="docutils literal notranslate"><span class="pre">'01</span> <span class="pre">December</span> <span class="pre">US/Pacific</span> <span class="pre">2000'</span></code>), then a warning will be raised and each row will be parsed individually by <code class="docutils literal notranslate"><span class="pre">dateutil.parser.parse</span></code>. The safest way to parse dates is to explicitly set <code class="docutils literal notranslate"><span class="pre">format=</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [124]: df = pd.read_csv(
   .....:     "foo.csv",
   .....:     index_col=0,
   .....:     parse_dates=True,
   .....: )
   .....: 

In [125]: df
Out[125]: 
            A  B  C
date               
2009-01-01  a  1  2
2009-01-02  b  3  4
2009-01-03  c  4  5
</pre></div> </div> <p>In the case that you have mixed datetime formats within the same column, you can pass <code class="docutils literal notranslate"><span class="pre">format='mixed'</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [126]: data = StringIO("date\n12 Jan 2000\n2000-01-13\n")

In [127]: df = pd.read_csv(data)

In [128]: df['date'] = pd.to_datetime(df['date'], format='mixed')

In [129]: df
Out[129]: 
        date
0 2000-01-12
1 2000-01-13
</pre></div> </div> <p>or, if your datetime formats are all ISO8601 (possibly not identically-formatted):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [130]: data = StringIO("date\n2020-01-01\n2020-01-01 03:00\n")

In [131]: df = pd.read_csv(data)

In [132]: df['date'] = pd.to_datetime(df['date'], format='ISO8601')

In [133]: df
Out[133]: 
                 date
0 2020-01-01 00:00:00
1 2020-01-01 03:00:00
</pre></div> </div> </section> <section id="international-date-formats"> <h4>International date formats</h4> <p>While US date formats tend to be MM/DD/YYYY, many international formats use DD/MM/YYYY instead. For convenience, a <code class="docutils literal notranslate"><span class="pre">dayfirst</span></code> keyword is provided:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [134]: data = "date,value,cat\n1/6/2000,5,a\n2/6/2000,10,b\n3/6/2000,15,c"

In [135]: print(data)
date,value,cat
1/6/2000,5,a
2/6/2000,10,b
3/6/2000,15,c

In [136]: with open("tmp.csv", "w") as fh:
   .....:     fh.write(data)
   .....: 

In [137]: pd.read_csv("tmp.csv", parse_dates=[0])
Out[137]: 
        date  value cat
0 2000-01-06      5   a
1 2000-02-06     10   b
2 2000-03-06     15   c

In [138]: pd.read_csv("tmp.csv", dayfirst=True, parse_dates=[0])
Out[138]: 
        date  value cat
0 2000-06-01      5   a
1 2000-06-02     10   b
2 2000-06-03     15   c
</pre></div> </div> </section> <section id="writing-csvs-to-binary-file-objects"> <h4>Writing CSVs to binary file objects</h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.2.0.</span></p> </div> <p><code class="docutils literal notranslate"><span class="pre">df.to_csv(...,</span> <span class="pre">mode="wb")</span></code> allows writing a CSV to a file object opened binary mode. In most cases, it is not necessary to specify <code class="docutils literal notranslate"><span class="pre">mode</span></code> as Pandas will auto-detect whether the file object is opened in text or binary mode.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [139]: import io

In [140]: data = pd.DataFrame([0, 1, 2])

In [141]: buffer = io.BytesIO()

In [142]: data.to_csv(buffer, encoding="utf-8", compression="gzip")
</pre></div> </div> </section> </section> <section id="specifying-method-for-floating-point-conversion"> <h3>Specifying method for floating-point conversion</h3> <p>The parameter <code class="docutils literal notranslate"><span class="pre">float_precision</span></code> can be specified in order to use a specific floating-point converter during parsing with the C engine. The options are the ordinary converter, the high-precision converter, and the round-trip converter (which is guaranteed to round-trip values after writing to a file). For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [143]: val = "0.3066101993807095471566981359501369297504425048828125"

In [144]: data = "a,b,c\n1,2,{0}".format(val)

In [145]: abs(
   .....:     pd.read_csv(
   .....:         StringIO(data),
   .....:         engine="c",
   .....:         float_precision=None,
   .....:     )["c"][0] - float(val)
   .....: )
   .....: 
Out[145]: 5.551115123125783e-17

In [146]: abs(
   .....:     pd.read_csv(
   .....:         StringIO(data),
   .....:         engine="c",
   .....:         float_precision="high",
   .....:     )["c"][0] - float(val)
   .....: )
   .....: 
Out[146]: 5.551115123125783e-17

In [147]: abs(
   .....:     pd.read_csv(StringIO(data), engine="c", float_precision="round_trip")["c"][0]
   .....:     - float(val)
   .....: )
   .....: 
Out[147]: 0.0
</pre></div> </div> </section> <section id="thousand-separators"> <h3>Thousand separators</h3> <p>For large numbers that have been written with a thousands separator, you can set the <code class="docutils literal notranslate"><span class="pre">thousands</span></code> keyword to a string of length 1 so that integers will be parsed correctly:</p> <p>By default, numbers with a thousands separator will be parsed as strings:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [148]: data = (
   .....:     "ID|level|category\n"
   .....:     "Patient1|123,000|x\n"
   .....:     "Patient2|23,000|y\n"
   .....:     "Patient3|1,234,018|z"
   .....: )
   .....: 

In [149]: with open("tmp.csv", "w") as fh:
   .....:     fh.write(data)
   .....: 

In [150]: df = pd.read_csv("tmp.csv", sep="|")

In [151]: df
Out[151]: 
         ID      level category
0  Patient1    123,000        x
1  Patient2     23,000        y
2  Patient3  1,234,018        z

In [152]: df.level.dtype
Out[152]: dtype('O')
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">thousands</span></code> keyword allows integers to be parsed correctly:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [153]: df = pd.read_csv("tmp.csv", sep="|", thousands=",")

In [154]: df
Out[154]: 
         ID    level category
0  Patient1   123000        x
1  Patient2    23000        y
2  Patient3  1234018        z

In [155]: df.level.dtype
Out[155]: dtype('int64')
</pre></div> </div> </section> <section id="na-values"> <h3>NA values</h3> <p>To control which values are parsed as missing values (which are signified by <code class="docutils literal notranslate"><span class="pre">NaN</span></code>), specify a string in <code class="docutils literal notranslate"><span class="pre">na_values</span></code>. If you specify a list of strings, then all values in it are considered to be missing values. If you specify a number (a <code class="docutils literal notranslate"><span class="pre">float</span></code>, like <code class="docutils literal notranslate"><span class="pre">5.0</span></code> or an <code class="docutils literal notranslate"><span class="pre">integer</span></code> like <code class="docutils literal notranslate"><span class="pre">5</span></code>), the corresponding equivalent values will also imply a missing value (in this case effectively <code class="docutils literal notranslate"><span class="pre">[5.0,</span> <span class="pre">5]</span></code> are recognized as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>).</p> <p>To completely override the default values that are recognized as missing, specify <code class="docutils literal notranslate"><span class="pre">keep_default_na=False</span></code>.</p> <p id="io-navaluesconst">The default <code class="docutils literal notranslate"><span class="pre">NaN</span></code> recognized values are <code class="docutils literal notranslate"><span class="pre">['-1.#IND',</span> <span class="pre">'1.#QNAN',</span> <span class="pre">'1.#IND',</span> <span class="pre">'-1.#QNAN',</span> <span class="pre">'#N/A</span> <span class="pre">N/A',</span> <span class="pre">'#N/A',</span> <span class="pre">'N/A',</span>
<span class="pre">'n/a',</span> <span class="pre">'NA',</span> <span class="pre">'&lt;NA&gt;',</span> <span class="pre">'#NA',</span> <span class="pre">'NULL',</span> <span class="pre">'null',</span> <span class="pre">'NaN',</span> <span class="pre">'-NaN',</span> <span class="pre">'nan',</span> <span class="pre">'-nan',</span> <span class="pre">'None',</span> <span class="pre">'']</span></code>.</p> <p>Let us consider some examples:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv("path_to_file.csv", na_values=[5])
</pre></div> </div> <p>In the example above <code class="docutils literal notranslate"><span class="pre">5</span></code> and <code class="docutils literal notranslate"><span class="pre">5.0</span></code> will be recognized as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, in addition to the defaults. A string will first be interpreted as a numerical <code class="docutils literal notranslate"><span class="pre">5</span></code>, then as a <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv("path_to_file.csv", keep_default_na=False, na_values=[""])
</pre></div> </div> <p>Above, only an empty field will be recognized as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv("path_to_file.csv", keep_default_na=False, na_values=["NA", "0"])
</pre></div> </div> <p>Above, both <code class="docutils literal notranslate"><span class="pre">NA</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span></code> as strings are <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv("path_to_file.csv", na_values=["Nope"])
</pre></div> </div> <p>The default values, in addition to the string <code class="docutils literal notranslate"><span class="pre">"Nope"</span></code> are recognized as <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> </section> <section id="infinity"> <h3>Infinity</h3> <p><code class="docutils literal notranslate"><span class="pre">inf</span></code> like values will be parsed as <code class="docutils literal notranslate"><span class="pre">np.inf</span></code> (positive infinity), and <code class="docutils literal notranslate"><span class="pre">-inf</span></code> as <code class="docutils literal notranslate"><span class="pre">-np.inf</span></code> (negative infinity). These will ignore the case of the value, meaning <code class="docutils literal notranslate"><span class="pre">Inf</span></code>, will also be parsed as <code class="docutils literal notranslate"><span class="pre">np.inf</span></code>.</p> </section> <section id="boolean-values"> <h3>Boolean values</h3> <p>The common values <code class="docutils literal notranslate"><span class="pre">True</span></code>, <code class="docutils literal notranslate"><span class="pre">False</span></code>, <code class="docutils literal notranslate"><span class="pre">TRUE</span></code>, and <code class="docutils literal notranslate"><span class="pre">FALSE</span></code> are all recognized as boolean. Occasionally you might want to recognize other values as being boolean. To do this, use the <code class="docutils literal notranslate"><span class="pre">true_values</span></code> and <code class="docutils literal notranslate"><span class="pre">false_values</span></code> options as follows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [156]: data = "a,b,c\n1,Yes,2\n3,No,4"

In [157]: print(data)
a,b,c
1,Yes,2
3,No,4

In [158]: pd.read_csv(StringIO(data))
Out[158]: 
   a    b  c
0  1  Yes  2
1  3   No  4

In [159]: pd.read_csv(StringIO(data), true_values=["Yes"], false_values=["No"])
Out[159]: 
   a      b  c
0  1   True  2
1  3  False  4
</pre></div> </div> </section> <section id="handling-bad-lines"> <h3>Handling “bad” lines</h3> <p>Some files may have malformed lines with too few fields or too many. Lines with too few fields will have NA values filled in the trailing fields. Lines with too many fields will raise an error by default:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [160]: data = "a,b,c\n1,2,3\n4,5,6,7\n8,9,10"

In [161]: pd.read_csv(StringIO(data))
---------------------------------------------------------------------------
ParserError                               Traceback (most recent call last)
Cell In[161], line 1
----&gt; 1 pd.read_csv(StringIO(data))

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)
   1013 kwds_defaults = _refine_defaults_read(
   1014     dialect,
   1015     delimiter,
   (...)
   1022     dtype_backend=dtype_backend,
   1023 )
   1024 kwds.update(kwds_defaults)
-&gt; 1026 return _read(filepath_or_buffer, kwds)

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:626, in _read(filepath_or_buffer, kwds)
    623     return parser
    625 with parser:
--&gt; 626     return parser.read(nrows)

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:1923, in TextFileReader.read(self, nrows)
   1916 nrows = validate_integer("nrows", nrows)
   1917 try:
   1918     # error: "ParserBase" has no attribute "read"
   1919     (
   1920         index,
   1921         columns,
   1922         col_dict,
-&gt; 1923     ) = self._engine.read(  # type: ignore[attr-defined]
   1924         nrows
   1925     )
   1926 except Exception:
   1927     self.close()

File ~/work/pandas/pandas/pandas/io/parsers/c_parser_wrapper.py:234, in CParserWrapper.read(self, nrows)
    232 try:
    233     if self.low_memory:
--&gt; 234         chunks = self._reader.read_low_memory(nrows)
    235         # destructive to chunks
    236         data = _concatenate_chunks(chunks)

File parsers.pyx:838, in pandas._libs.parsers.TextReader.read_low_memory()

File parsers.pyx:905, in pandas._libs.parsers.TextReader._read_rows()

File parsers.pyx:874, in pandas._libs.parsers.TextReader._tokenize_rows()

File parsers.pyx:891, in pandas._libs.parsers.TextReader._check_tokenize_status()

File parsers.pyx:2061, in pandas._libs.parsers.raise_parser_error()

ParserError: Error tokenizing data. C error: Expected 3 fields in line 3, saw 4
</pre></div> </div> <p>You can elect to skip bad lines:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [162]: data = "a,b,c\n1,2,3\n4,5,6,7\n8,9,10"

In [163]: pd.read_csv(StringIO(data), on_bad_lines="skip")
Out[163]: 
   a  b   c
0  1  2   3
1  8  9  10
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.0.</span></p> </div> <p>Or pass a callable function to handle the bad line if <code class="docutils literal notranslate"><span class="pre">engine="python"</span></code>. The bad line will be a list of strings that was split by the <code class="docutils literal notranslate"><span class="pre">sep</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [164]: external_list = []

In [165]: def bad_lines_func(line):
   .....:     external_list.append(line)
   .....:     return line[-3:]
   .....: 

In [166]: external_list
Out[166]: []
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The callable function will handle only a line with too many fields. Bad lines caused by other errors will be silently skipped.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [167]: bad_lines_func = lambda line: print(line)

In [168]: data = 'name,type\nname a,a is of type a\nname b,"b\" is of type b"'

In [169]: data
Out[169]: 'name,type\nname a,a is of type a\nname b,"b" is of type b"'

In [170]: pd.read_csv(StringIO(data), on_bad_lines=bad_lines_func, engine="python")
Out[170]: 
     name            type
0  name a  a is of type a
</pre></div> </div> <p>The line was not processed in this case, as a “bad line” here is caused by an escape character.</p> </div> <p>You can also use the <code class="docutils literal notranslate"><span class="pre">usecols</span></code> parameter to eliminate extraneous column data that appear in some lines but not others:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [171]: pd.read_csv(StringIO(data), usecols=[0, 1, 2])
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[171], line 1
----&gt; 1 pd.read_csv(StringIO(data), usecols=[0, 1, 2])

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:1026, in read_csv(filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend)
   1013 kwds_defaults = _refine_defaults_read(
   1014     dialect,
   1015     delimiter,
   (...)
   1022     dtype_backend=dtype_backend,
   1023 )
   1024 kwds.update(kwds_defaults)
-&gt; 1026 return _read(filepath_or_buffer, kwds)

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:620, in _read(filepath_or_buffer, kwds)
    617 _validate_names(kwds.get("names", None))
    619 # Create the parser.
--&gt; 620 parser = TextFileReader(filepath_or_buffer, **kwds)
    622 if chunksize or iterator:
    623     return parser

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:1620, in TextFileReader.__init__(self, f, engine, **kwds)
   1617     self.options["has_index_names"] = kwds["has_index_names"]
   1619 self.handles: IOHandles | None = None
-&gt; 1620 self._engine = self._make_engine(f, self.engine)

File ~/work/pandas/pandas/pandas/io/parsers/readers.py:1898, in TextFileReader._make_engine(self, f, engine)
   1895     raise ValueError(msg)
   1897 try:
-&gt; 1898     return mapping[engine](f, **self.options)
   1899 except Exception:
   1900     if self.handles is not None:

File ~/work/pandas/pandas/pandas/io/parsers/c_parser_wrapper.py:155, in CParserWrapper.__init__(self, src, **kwds)
    152     # error: Cannot determine type of 'names'
    153     if len(self.names) &lt; len(usecols):  # type: ignore[has-type]
    154         # error: Cannot determine type of 'names'
--&gt; 155         self._validate_usecols_names(
    156             usecols,
    157             self.names,  # type: ignore[has-type]
    158         )
    160 # error: Cannot determine type of 'names'
    161 self._validate_parse_dates_presence(self.names)  # type: ignore[has-type]

File ~/work/pandas/pandas/pandas/io/parsers/base_parser.py:979, in ParserBase._validate_usecols_names(self, usecols, names)
    977 missing = [c for c in usecols if c not in names]
    978 if len(missing) &gt; 0:
--&gt; 979     raise ValueError(
    980         f"Usecols do not match columns, columns expected but not found: "
    981         f"{missing}"
    982     )
    984 return usecols

ValueError: Usecols do not match columns, columns expected but not found: [0, 1, 2]
</pre></div> </div> <p>In case you want to keep all data including the lines with too many fields, you can specify a sufficient number of <code class="docutils literal notranslate"><span class="pre">names</span></code>. This ensures that lines with not enough fields are filled with <code class="docutils literal notranslate"><span class="pre">NaN</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [172]: pd.read_csv(StringIO(data), names=['a', 'b', 'c', 'd'])
Out[172]: 
        a                b   c   d
0    name             type NaN NaN
1  name a   a is of type a NaN NaN
2  name b  b is of type b" NaN NaN
</pre></div> </div> </section> <section id="dialect"> <h3>Dialect</h3> <p>The <code class="docutils literal notranslate"><span class="pre">dialect</span></code> keyword gives greater flexibility in specifying the file format. By default it uses the Excel dialect but you can specify either the dialect name or a <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Dialect" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">csv.Dialect</span></code></a> instance.</p> <p>Suppose you had data with unenclosed quotes:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [173]: data = "label1,label2,label3\n" 'index1,"a,c,e\n' "index2,b,d,f"

In [174]: print(data)
label1,label2,label3
index1,"a,c,e
index2,b,d,f
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> uses the Excel dialect and treats the double quote as the quote character, which causes it to fail when it finds a newline before it finds the closing double quote.</p> <p>We can get around this using <code class="docutils literal notranslate"><span class="pre">dialect</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [175]: import csv

In [176]: dia = csv.excel()

In [177]: dia.quoting = csv.QUOTE_NONE

In [178]: pd.read_csv(StringIO(data), dialect=dia)
Out[178]: 
       label1 label2 label3
index1     "a      c      e
index2      b      d      f
</pre></div> </div> <p>All of the dialect options can be specified separately by keyword arguments:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [179]: data = "a,b,c~1,2,3~4,5,6"

In [180]: pd.read_csv(StringIO(data), lineterminator="~")
Out[180]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre></div> </div> <p>Another common dialect option is <code class="docutils literal notranslate"><span class="pre">skipinitialspace</span></code>, to skip any whitespace after a delimiter:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [181]: data = "a, b, c\n1, 2, 3\n4, 5, 6"

In [182]: print(data)
a, b, c
1, 2, 3
4, 5, 6

In [183]: pd.read_csv(StringIO(data), skipinitialspace=True)
Out[183]: 
   a  b  c
0  1  2  3
1  4  5  6
</pre></div> </div> <p>The parsers make every attempt to “do the right thing” and not be fragile. Type inference is a pretty big deal. If a column can be coerced to integer dtype without altering the contents, the parser will do so. Any non-numeric columns will come through as object dtype as with the rest of pandas objects.</p> </section> <section id="quoting-and-escape-characters"> <h3>Quoting and Escape Characters</h3> <p>Quotes (and other escape characters) in embedded fields can be handled in any number of ways. One way is to use backslashes; to properly parse this data, you should pass the <code class="docutils literal notranslate"><span class="pre">escapechar</span></code> option:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [184]: data = 'a,b\n"hello, \\"Bob\\", nice to see you",5'

In [185]: print(data)
a,b
"hello, \"Bob\", nice to see you",5

In [186]: pd.read_csv(StringIO(data), escapechar="\\")
Out[186]: 
                               a  b
0  hello, "Bob", nice to see you  5
</pre></div> </div> </section> <section id="files-with-fixed-width-columns"> <h3>Files with fixed width columns</h3> <p>While <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_csv()</span></code></a> reads delimited data, the <a class="reference internal" href="../reference/api/pandas.read_fwf.html#pandas.read_fwf" title="pandas.read_fwf"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_fwf()</span></code></a> function works with data files that have known and fixed column widths. The function parameters to <code class="docutils literal notranslate"><span class="pre">read_fwf</span></code> are largely the same as <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> with two extra parameters, and a different usage of the <code class="docutils literal notranslate"><span class="pre">delimiter</span></code> parameter:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">colspecs</span></code>: A list of pairs (tuples) giving the extents of the fixed-width fields of each line as half-open intervals (i.e., [from, to[ ). String value ‘infer’ can be used to instruct the parser to try detecting the column specifications from the first 100 rows of the data. Default behavior, if not specified, is to infer.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">widths</span></code>: A list of field widths which can be used instead of ‘colspecs’ if the intervals are contiguous.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">delimiter</span></code>: Characters to consider as filler characters in the fixed-width file. Can be used to specify the filler character of the fields if it is not spaces (e.g., ‘~’).</p></li> </ul> <p>Consider a typical fixed-width data file:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [187]: data1 = (
   .....:     "id8141    360.242940   149.910199   11950.7\n"
   .....:     "id1594    444.953632   166.985655   11788.4\n"
   .....:     "id1849    364.136849   183.628767   11806.2\n"
   .....:     "id1230    413.836124   184.375703   11916.8\n"
   .....:     "id1948    502.953953   173.237159   12468.3"
   .....: )
   .....: 

In [188]: with open("bar.csv", "w") as f:
   .....:     f.write(data1)
   .....: 
</pre></div> </div> <p>In order to parse this file into a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, we simply need to supply the column specifications to the <code class="docutils literal notranslate"><span class="pre">read_fwf</span></code> function along with the file name:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># Column specifications are a list of half-intervals
In [189]: colspecs = [(0, 6), (8, 20), (21, 33), (34, 43)]

In [190]: df = pd.read_fwf("bar.csv", colspecs=colspecs, header=None, index_col=0)

In [191]: df
Out[191]: 
                 1           2        3
0                                      
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</pre></div> </div> <p>Note how the parser automatically picks column names X.&lt;column number&gt; when <code class="docutils literal notranslate"><span class="pre">header=None</span></code> argument is specified. Alternatively, you can supply just the column widths for contiguous columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># Widths are a list of integers
In [192]: widths = [6, 14, 13, 10]

In [193]: df = pd.read_fwf("bar.csv", widths=widths, header=None)

In [194]: df
Out[194]: 
        0           1           2        3
0  id8141  360.242940  149.910199  11950.7
1  id1594  444.953632  166.985655  11788.4
2  id1849  364.136849  183.628767  11806.2
3  id1230  413.836124  184.375703  11916.8
4  id1948  502.953953  173.237159  12468.3
</pre></div> </div> <p>The parser will take care of extra white spaces around the columns so it’s ok to have extra separation between the columns in the file.</p> <p>By default, <code class="docutils literal notranslate"><span class="pre">read_fwf</span></code> will try to infer the file’s <code class="docutils literal notranslate"><span class="pre">colspecs</span></code> by using the first 100 rows of the file. It can do it only in cases when the columns are aligned and correctly separated by the provided <code class="docutils literal notranslate"><span class="pre">delimiter</span></code> (default delimiter is whitespace).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [195]: df = pd.read_fwf("bar.csv", header=None, index_col=0)

In [196]: df
Out[196]: 
                 1           2        3
0                                      
id8141  360.242940  149.910199  11950.7
id1594  444.953632  166.985655  11788.4
id1849  364.136849  183.628767  11806.2
id1230  413.836124  184.375703  11916.8
id1948  502.953953  173.237159  12468.3
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">read_fwf</span></code> supports the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> parameter for specifying the types of parsed columns to be different from the inferred type.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [197]: pd.read_fwf("bar.csv", header=None, index_col=0).dtypes
Out[197]: 
1    float64
2    float64
3    float64
dtype: object

In [198]: pd.read_fwf("bar.csv", header=None, dtype={2: "object"}).dtypes
Out[198]: 
0     object
1    float64
2     object
3    float64
dtype: object
</pre></div> </div> </section> <section id="indexes"> <h3>Indexes</h3> <section id="files-with-an-implicit-index-column"> <h4>Files with an “implicit” index column</h4> <p>Consider a file with one less entry in the header than the number of data column:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [199]: data = "A,B,C\n20090101,a,1,2\n20090102,b,3,4\n20090103,c,4,5"

In [200]: print(data)
A,B,C
20090101,a,1,2
20090102,b,3,4
20090103,c,4,5

In [201]: with open("foo.csv", "w") as f:
   .....:     f.write(data)
   .....: 
</pre></div> </div> <p>In this special case, <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> assumes that the first column is to be used as the index of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [202]: pd.read_csv("foo.csv")
Out[202]: 
          A  B  C
20090101  a  1  2
20090102  b  3  4
20090103  c  4  5
</pre></div> </div> <p>Note that the dates weren’t automatically parsed. In that case you would need to do as before:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [203]: df = pd.read_csv("foo.csv", parse_dates=True)

In [204]: df.index
Out[204]: DatetimeIndex(['2009-01-01', '2009-01-02', '2009-01-03'], dtype='datetime64[ns]', freq=None)
</pre></div> </div> </section> <section id="reading-an-index-with-a-multiindex"> <h4>Reading an index with a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>
</h4> <p id="io-csv-multiindex">Suppose you have data indexed by two columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [205]: data = 'year,indiv,zit,xit\n1977,"A",1.2,.6\n1977,"B",1.5,.5'

In [206]: print(data)
year,indiv,zit,xit
1977,"A",1.2,.6
1977,"B",1.5,.5

In [207]: with open("mindex_ex.csv", mode="w") as f:
   .....:     f.write(data)
   .....: 
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">index_col</span></code> argument to <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> can take a list of column numbers to turn multiple columns into a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the index of the returned object:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [208]: df = pd.read_csv("mindex_ex.csv", index_col=[0, 1])

In [209]: df
Out[209]: 
            zit  xit
year indiv          
1977 A      1.2  0.6
     B      1.5  0.5

In [210]: df.loc[1977]
Out[210]: 
       zit  xit
indiv          
A      1.2  0.6
B      1.5  0.5
</pre></div> </div> </section> <section id="reading-columns-with-a-multiindex"> <h4>Reading columns with a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>
</h4> <p>By specifying list of row locations for the <code class="docutils literal notranslate"><span class="pre">header</span></code> argument, you can read in a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the columns. Specifying non-consecutive rows will skip the intervening rows.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [211]: mi_idx = pd.MultiIndex.from_arrays([[1, 2, 3, 4], list("abcd")], names=list("ab"))

In [212]: mi_col = pd.MultiIndex.from_arrays([[1, 2], list("ab")], names=list("cd"))

In [213]: df = pd.DataFrame(np.ones((4, 2)), index=mi_idx, columns=mi_col)

In [214]: df.to_csv("mi.csv")

In [215]: print(open("mi.csv").read())
c,,1,2
d,,a,b
a,b,,
1,a,1.0,1.0
2,b,1.0,1.0
3,c,1.0,1.0
4,d,1.0,1.0


In [216]: pd.read_csv("mi.csv", header=[0, 1, 2, 3], index_col=[0, 1])
Out[216]: 
c                    1                  2
d                    a                  b
a   Unnamed: 2_level_2 Unnamed: 3_level_2
1                  1.0                1.0
2 b                1.0                1.0
3 c                1.0                1.0
4 d                1.0                1.0
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">read_csv</span></code> is also able to interpret a more common format of multi-columns indices.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [217]: data = ",a,a,a,b,c,c\n,q,r,s,t,u,v\none,1,2,3,4,5,6\ntwo,7,8,9,10,11,12"

In [218]: print(data)
,a,a,a,b,c,c
,q,r,s,t,u,v
one,1,2,3,4,5,6
two,7,8,9,10,11,12

In [219]: with open("mi2.csv", "w") as fh:
   .....:     fh.write(data)
   .....: 

In [220]: pd.read_csv("mi2.csv", header=[0, 1], index_col=0)
Out[220]: 
     a         b   c    
     q  r  s   t   u   v
one  1  2  3   4   5   6
two  7  8  9  10  11  12
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If an <code class="docutils literal notranslate"><span class="pre">index_col</span></code> is not specified (e.g. you don’t have an index, or wrote it with <code class="docutils literal notranslate"><span class="pre">df.to_csv(...,</span> <span class="pre">index=False)</span></code>, then any <code class="docutils literal notranslate"><span class="pre">names</span></code> on the columns index will be <em>lost</em>.</p> </div> </section> </section> <section id="automatically-sniffing-the-delimiter"> <h3>Automatically “sniffing” the delimiter</h3> <p><code class="docutils literal notranslate"><span class="pre">read_csv</span></code> is capable of inferring delimited (not necessarily comma-separated) files, as pandas uses the <a class="reference external" href="https://docs.python.org/3/library/csv.html#csv.Sniffer" title="(in Python v3.12)"><code class="docutils literal notranslate"><span class="pre">csv.Sniffer</span></code></a> class of the csv module. For this, you have to specify <code class="docutils literal notranslate"><span class="pre">sep=None</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [221]: df = pd.DataFrame(np.random.randn(10, 4))

In [222]: df.to_csv("tmp2.csv", sep=":", index=False)

In [223]: pd.read_csv("tmp2.csv", sep=None, engine="python")
Out[223]: 
          0         1         2         3
0  0.469112 -0.282863 -1.509059 -1.135632
1  1.212112 -0.173215  0.119209 -1.044236
2 -0.861849 -2.104569 -0.494929  1.071804
3  0.721555 -0.706771 -1.039575  0.271860
4 -0.424972  0.567020  0.276232 -1.087401
5 -0.673690  0.113648 -1.478427  0.524988
6  0.404705  0.577046 -1.715002 -1.039268
7 -0.370647 -1.157892 -1.344312  0.844885
8  1.075770 -0.109050  1.643563 -1.469388
9  0.357021 -0.674600 -1.776904 -0.968914
</pre></div> </div> </section> <section id="reading-multiple-files-to-create-a-single-dataframe"> <h3>Reading multiple files to create a single DataFrame</h3> <p>It’s best to use <a class="reference internal" href="../reference/api/pandas.concat.html#pandas.concat" title="pandas.concat"><code class="xref py py-func docutils literal notranslate"><span class="pre">concat()</span></code></a> to combine multiple files. See the <a class="reference internal" href="cookbook.html#cookbook-csv-multiple-files"><span class="std std-ref">cookbook</span></a> for an example.</p> </section> <section id="iterating-through-files-chunk-by-chunk"> <h3>Iterating through files chunk by chunk</h3> <p>Suppose you wish to iterate through a (potentially very large) file lazily rather than reading the entire file into memory, such as the following:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [224]: df = pd.DataFrame(np.random.randn(10, 4))

In [225]: df.to_csv("tmp.csv", index=False)

In [226]: table = pd.read_csv("tmp.csv")

In [227]: table
Out[227]: 
          0         1         2         3
0 -1.294524  0.413738  0.276662 -0.472035
1 -0.013960 -0.362543 -0.006154 -0.923061
2  0.895717  0.805244 -1.206412  2.565646
3  1.431256  1.340309 -1.170299 -0.226169
4  0.410835  0.813850  0.132003 -0.827317
5 -0.076467 -1.187678  1.130127 -1.436737
6 -1.413681  1.607920  1.024180  0.569605
7  0.875906 -2.211372  0.974466 -2.006747
8 -0.410001 -0.078638  0.545952 -1.219217
9 -1.226825  0.769804 -1.281247 -0.727707
</pre></div> </div> <p>By specifying a <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> to <code class="docutils literal notranslate"><span class="pre">read_csv</span></code>, the return value will be an iterable object of type <code class="docutils literal notranslate"><span class="pre">TextFileReader</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [228]: with pd.read_csv("tmp.csv", chunksize=4) as reader:
   .....:     print(reader)
   .....:     for chunk in reader:
   .....:         print(chunk)
   .....: 
&lt;pandas.io.parsers.readers.TextFileReader object at 0x7ff2e5421db0&gt;
          0         1         2         3
0 -1.294524  0.413738  0.276662 -0.472035
1 -0.013960 -0.362543 -0.006154 -0.923061
2  0.895717  0.805244 -1.206412  2.565646
3  1.431256  1.340309 -1.170299 -0.226169
          0         1         2         3
4  0.410835  0.813850  0.132003 -0.827317
5 -0.076467 -1.187678  1.130127 -1.436737
6 -1.413681  1.607920  1.024180  0.569605
7  0.875906 -2.211372  0.974466 -2.006747
          0         1         2         3
8 -0.410001 -0.078638  0.545952 -1.219217
9 -1.226825  0.769804 -1.281247 -0.727707
</pre></div> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.2: </span><code class="docutils literal notranslate"><span class="pre">read_csv/json/sas</span></code> return a context-manager when iterating through a file.</p> </div> <p>Specifying <code class="docutils literal notranslate"><span class="pre">iterator=True</span></code> will also return the <code class="docutils literal notranslate"><span class="pre">TextFileReader</span></code> object:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [229]: with pd.read_csv("tmp.csv", iterator=True) as reader:
   .....:     print(reader.get_chunk(5))
   .....: 
          0         1         2         3
0 -1.294524  0.413738  0.276662 -0.472035
1 -0.013960 -0.362543 -0.006154 -0.923061
2  0.895717  0.805244 -1.206412  2.565646
3  1.431256  1.340309 -1.170299 -0.226169
4  0.410835  0.813850  0.132003 -0.827317
</pre></div> </div> </section> <section id="specifying-the-parser-engine"> <h3>Specifying the parser engine</h3> <p>Pandas currently supports three engines, the C engine, the python engine, and an experimental pyarrow engine (requires the <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> package). In general, the pyarrow engine is fastest on larger workloads and is equivalent in speed to the C engine on most other workloads. The python engine tends to be slower than the pyarrow and C engines on most workloads. However, the pyarrow engine is much less robust than the C engine, which lacks a few features compared to the Python engine.</p> <p>Where possible, pandas uses the C parser (specified as <code class="docutils literal notranslate"><span class="pre">engine='c'</span></code>), but it may fall back to Python if C-unsupported options are specified.</p> <p>Currently, options unsupported by the C and pyarrow engines include:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">sep</span></code> other than a single character (e.g. regex separators)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">skipfooter</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">sep=None</span></code> with <code class="docutils literal notranslate"><span class="pre">delim_whitespace=False</span></code></p></li> </ul> <p>Specifying any of the above options will produce a <code class="docutils literal notranslate"><span class="pre">ParserWarning</span></code> unless the python engine is selected explicitly using <code class="docutils literal notranslate"><span class="pre">engine='python'</span></code>.</p> <p>Options that are unsupported by the pyarrow engine which are not covered by the list above include:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">float_precision</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">chunksize</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">comment</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">nrows</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">thousands</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">memory_map</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">dialect</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">on_bad_lines</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">delim_whitespace</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">quoting</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lineterminator</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">converters</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">decimal</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">iterator</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">dayfirst</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">infer_datetime_format</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">verbose</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">skipinitialspace</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">low_memory</span></code></p></li> </ul> <p>Specifying these options with <code class="docutils literal notranslate"><span class="pre">engine='pyarrow'</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p> </section> <section id="reading-writing-remote-files"> <h3>Reading/writing remote files</h3> <p>You can pass in a URL to read or write remote files to many of pandas’ IO functions - the following example shows reading a CSV file:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.read_csv("https://download.bls.gov/pub/time.series/cu/cu.item", sep="\t")
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>A custom header can be sent alongside HTTP(s) requests by passing a dictionary of header key value mappings to the <code class="docutils literal notranslate"><span class="pre">storage_options</span></code> keyword argument as shown below:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">headers = {"User-Agent": "pandas"}
df = pd.read_csv(
    "https://download.bls.gov/pub/time.series/cu/cu.item",
    sep="\t",
    storage_options=headers
)
</pre></div> </div> <p>All URLs which are not local files or HTTP(s) are handled by <a class="reference external" href="https://filesystem-spec.readthedocs.io/en/latest/">fsspec</a>, if installed, and its various filesystem implementations (including Amazon S3, Google Cloud, SSH, FTP, webHDFS…). Some of these implementations will require additional packages to be installed, for example S3 URLs require the <a class="reference external" href="https://pypi.org/project/s3fs/">s3fs</a> library:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.read_json("s3://pandas-test/adatafile.json")
</pre></div> </div> <p>When dealing with remote storage systems, you might need extra configuration with environment variables or config files in special locations. For example, to access data in your S3 bucket, you will need to define credentials in one of the several ways listed in the <a class="reference external" href="https://s3fs.readthedocs.io/en/latest/#credentials">S3Fs documentation</a>. The same is true for several of the storage backends, and you should follow the links at <a class="reference external" href="https://filesystem-spec.readthedocs.io/en/latest/api.html#built-in-implementations">fsimpl1</a> for implementations built into <code class="docutils literal notranslate"><span class="pre">fsspec</span></code> and <a class="reference external" href="https://filesystem-spec.readthedocs.io/en/latest/api.html#other-known-implementations">fsimpl2</a> for those not included in the main <code class="docutils literal notranslate"><span class="pre">fsspec</span></code> distribution.</p> <p>You can also pass parameters directly to the backend driver. Since <code class="docutils literal notranslate"><span class="pre">fsspec</span></code> does not utilize the <code class="docutils literal notranslate"><span class="pre">AWS_S3_HOST</span></code> environment variable, we can directly define a dictionary containing the endpoint_url and pass the object into the storage option parameter:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">storage_options = {"client_kwargs": {"endpoint_url": "http://127.0.0.1:5555"}}}
df = pd.read_json("s3://pandas-test/test-1", storage_options=storage_options)
</pre></div> </div> <p>More sample configurations and documentation can be found at <a class="reference external" href="https://s3fs.readthedocs.io/en/latest/index.html?highlight=host#s3-compatible-storage">S3Fs documentation</a>.</p> <p>If you do <em>not</em> have S3 credentials, you can still access public data by specifying an anonymous connection, such as</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.2.0.</span></p> </div> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv(
    "s3://ncei-wcsd-archive/data/processed/SH1305/18kHz/SaKe2013"
    "-D20130523-T080854_to_SaKe2013-D20130523-T085643.csv",
    storage_options={"anon": True},
)
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">fsspec</span></code> also allows complex URLs, for accessing data in compressed archives, local caching of files, and more. To locally cache the above example, you would modify the call to</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_csv(
    "simplecache::s3://ncei-wcsd-archive/data/processed/SH1305/18kHz/"
    "SaKe2013-D20130523-T080854_to_SaKe2013-D20130523-T085643.csv",
    storage_options={"s3": {"anon": True}},
)
</pre></div> </div> <p>where we specify that the “anon” parameter is meant for the “s3” part of the implementation, not to the caching implementation. Note that this caches to a temporary directory for the duration of the session only, but you can also specify a permanent store.</p> </section> <section id="writing-out-data"> <h3>Writing out data</h3> <section id="writing-to-csv-format"> <h4>Writing to CSV format</h4> <p>The <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects have an instance method <code class="docutils literal notranslate"><span class="pre">to_csv</span></code> which allows storing the contents of the object as a comma-separated-values file. The function takes a number of arguments. Only the first is required.</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">path_or_buf</span></code>: A string path to the file to write or a file object. If a file object it must be opened with <code class="docutils literal notranslate"><span class="pre">newline=''</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">sep</span></code> : Field delimiter for the output file (default “,”)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">na_rep</span></code>: A string representation of a missing value (default ‘’)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">float_format</span></code>: Format string for floating point numbers</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">columns</span></code>: Columns to write (default None)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">header</span></code>: Whether to write out the column names (default True)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">index</span></code>: whether to write row (index) names (default True)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">index_label</span></code>: Column label(s) for index column(s) if desired. If None (default), and <code class="docutils literal notranslate"><span class="pre">header</span></code> and <code class="docutils literal notranslate"><span class="pre">index</span></code> are True, then the index names are used. (A sequence should be given if the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> uses MultiIndex).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code> : Python write mode, default ‘w’</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">encoding</span></code>: a string representing the encoding to use if the contents are non-ASCII, for Python versions prior to 3</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lineterminator</span></code>: Character sequence denoting line end (default <code class="docutils literal notranslate"><span class="pre">os.linesep</span></code>)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">quoting</span></code>: Set quoting rules as in csv module (default csv.QUOTE_MINIMAL). Note that if you have set a <code class="docutils literal notranslate"><span class="pre">float_format</span></code> then floats are converted to strings and csv.QUOTE_NONNUMERIC will treat them as non-numeric</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">quotechar</span></code>: Character used to quote fields (default ‘”’)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">doublequote</span></code>: Control quoting of <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> in fields (default True)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">escapechar</span></code>: Character used to escape <code class="docutils literal notranslate"><span class="pre">sep</span></code> and <code class="docutils literal notranslate"><span class="pre">quotechar</span></code> when appropriate (default None)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">chunksize</span></code>: Number of rows to write at a time</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">date_format</span></code>: Format string for datetime objects</p></li> </ul> </section> <section id="writing-a-formatted-string"> <h4>Writing a formatted string</h4> <p id="io-formatting">The <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object has an instance method <code class="docutils literal notranslate"><span class="pre">to_string</span></code> which allows control over the string representation of the object. All arguments are optional:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">buf</span></code> default None, for example a StringIO object</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">columns</span></code> default None, which columns to write</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">col_space</span></code> default None, minimum width of each column.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">na_rep</span></code> default <code class="docutils literal notranslate"><span class="pre">NaN</span></code>, representation of NA value</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">formatters</span></code> default None, a dictionary (by column) of functions each of which takes a single argument and returns a formatted string</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">float_format</span></code> default None, a function which takes a single (float) argument and returns a formatted string; to be applied to floats in the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">sparsify</span></code> default True, set to False for a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with a hierarchical index to print every MultiIndex key at each row.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">index_names</span></code> default True, will print the names of the indices</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">index</span></code> default True, will print the index (ie, row labels)</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">header</span></code> default True, will print the column labels</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">justify</span></code> default <code class="docutils literal notranslate"><span class="pre">left</span></code>, will print column headers left- or right-justified</p></li> </ul> <p>The <code class="docutils literal notranslate"><span class="pre">Series</span></code> object also has a <code class="docutils literal notranslate"><span class="pre">to_string</span></code> method, but with only the <code class="docutils literal notranslate"><span class="pre">buf</span></code>, <code class="docutils literal notranslate"><span class="pre">na_rep</span></code>, <code class="docutils literal notranslate"><span class="pre">float_format</span></code> arguments. There is also a <code class="docutils literal notranslate"><span class="pre">length</span></code> argument which, if set to <code class="docutils literal notranslate"><span class="pre">True</span></code>, will additionally output the length of the Series.</p> </section> </section> </section> <section id="json"> <h2>JSON</h2> <p>Read and write <code class="docutils literal notranslate"><span class="pre">JSON</span></code> format files and strings.</p> <section id="writing-json"> <h3>Writing JSON</h3> <p>A <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> can be converted to a valid JSON string. Use <code class="docutils literal notranslate"><span class="pre">to_json</span></code> with optional parameters:</p> <ul> <li><p><code class="docutils literal notranslate"><span class="pre">path_or_buf</span></code> : the pathname or buffer to write the output. This can be <code class="docutils literal notranslate"><span class="pre">None</span></code> in which case a JSON string is returned.</p></li> <li>
<p><code class="docutils literal notranslate"><span class="pre">orient</span></code> :</p> <dl class="simple"> <dt>
<code class="docutils literal notranslate"><span class="pre">Series</span></code>:</dt>
<dd>
<ul class="simple"> <li><p>default is <code class="docutils literal notranslate"><span class="pre">index</span></code></p></li> <li><p>allowed values are {<code class="docutils literal notranslate"><span class="pre">split</span></code>, <code class="docutils literal notranslate"><span class="pre">records</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code>}</p></li> </ul> </dd> <dt>
<code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</dt>
<dd>
<ul class="simple"> <li><p>default is <code class="docutils literal notranslate"><span class="pre">columns</span></code></p></li> <li><p>allowed values are {<code class="docutils literal notranslate"><span class="pre">split</span></code>, <code class="docutils literal notranslate"><span class="pre">records</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">columns</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code>, <code class="docutils literal notranslate"><span class="pre">table</span></code>}</p></li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class="table"> <colgroup> <col style="width: 11.8%"> <col style="width: 88.2%"> </colgroup> <tbody> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">split</span></code></p></td> <td><p>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">records</span></code></p></td> <td><p>list like [{column -&gt; value}, … , {column -&gt; value}]</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">index</span></code></p></td> <td><p>dict like {index -&gt; {column -&gt; value}}</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">columns</span></code></p></td> <td><p>dict like {column -&gt; {index -&gt; value}}</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td> <td><p>just the values array</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">table</span></code></p></td> <td><p>adhering to the JSON <a class="reference external" href="https://specs.frictionlessdata.io/table-schema/">Table Schema</a></p></td> </tr> </tbody> </table> </li> <li><p><code class="docutils literal notranslate"><span class="pre">date_format</span></code> : string, type of date conversion, ‘epoch’ for timestamp, ‘iso’ for ISO8601.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">double_precision</span></code> : The number of decimal places to use when encoding floating point values, default 10.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">force_ascii</span></code> : force encoded string to be ASCII, default True.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">date_unit</span></code> : The time unit to encode to, governs timestamp and ISO8601 precision. One of ‘s’, ‘ms’, ‘us’ or ‘ns’ for seconds, milliseconds, microseconds and nanoseconds respectively. Default ‘ms’.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">default_handler</span></code> : The handler to call if an object cannot otherwise be converted to a suitable format for JSON. Takes a single argument, which is the object to convert, and returns a serializable object.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code> : If <code class="docutils literal notranslate"><span class="pre">records</span></code> orient, then will write each record per line as json.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">mode</span></code> : string, writer mode when writing to path. ‘w’ for write, ‘a’ for append. Default ‘w’</p></li> </ul> <p>Note <code class="docutils literal notranslate"><span class="pre">NaN</span></code>’s, <code class="docutils literal notranslate"><span class="pre">NaT</span></code>’s and <code class="docutils literal notranslate"><span class="pre">None</span></code> will be converted to <code class="docutils literal notranslate"><span class="pre">null</span></code> and <code class="docutils literal notranslate"><span class="pre">datetime</span></code> objects will be converted based on the <code class="docutils literal notranslate"><span class="pre">date_format</span></code> and <code class="docutils literal notranslate"><span class="pre">date_unit</span></code> parameters.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [230]: dfj = pd.DataFrame(np.random.randn(5, 2), columns=list("AB"))

In [231]: json = dfj.to_json()

In [232]: json
Out[232]: '{"A":{"0":-0.1213062281,"1":0.6957746499,"2":0.9597255933,"3":-0.6199759194,"4":-0.7323393705},"B":{"0":-0.0978826728,"1":0.3417343559,"2":-1.1103361029,"3":0.1497483186,"4":0.6877383895}}'
</pre></div> </div> <section id="orient-options"> <h4>Orient options</h4> <p>There are a number of different options for the format of the resulting JSON file / string. Consider the following <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [233]: dfjo = pd.DataFrame(
   .....:     dict(A=range(1, 4), B=range(4, 7), C=range(7, 10)),
   .....:     columns=list("ABC"),
   .....:     index=list("xyz"),
   .....: )
   .....: 

In [234]: dfjo
Out[234]: 
   A  B  C
x  1  4  7
y  2  5  8
z  3  6  9

In [235]: sjo = pd.Series(dict(x=15, y=16, z=17), name="D")

In [236]: sjo
Out[236]: 
x    15
y    16
z    17
Name: D, dtype: int64
</pre></div> </div> <p><strong>Column oriented</strong> (the default for <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>) serializes the data as nested JSON objects with column labels acting as the primary index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [237]: dfjo.to_json(orient="columns")
Out[237]: '{"A":{"x":1,"y":2,"z":3},"B":{"x":4,"y":5,"z":6},"C":{"x":7,"y":8,"z":9}}'

# Not available for Series
</pre></div> </div> <p><strong>Index oriented</strong> (the default for <code class="docutils literal notranslate"><span class="pre">Series</span></code>) similar to column oriented but the index labels are now primary:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [238]: dfjo.to_json(orient="index")
Out[238]: '{"x":{"A":1,"B":4,"C":7},"y":{"A":2,"B":5,"C":8},"z":{"A":3,"B":6,"C":9}}'

In [239]: sjo.to_json(orient="index")
Out[239]: '{"x":15,"y":16,"z":17}'
</pre></div> </div> <p><strong>Record oriented</strong> serializes the data to a JSON array of column -&gt; value records, index labels are not included. This is useful for passing <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> data to plotting libraries, for example the JavaScript library <code class="docutils literal notranslate"><span class="pre">d3.js</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [240]: dfjo.to_json(orient="records")
Out[240]: '[{"A":1,"B":4,"C":7},{"A":2,"B":5,"C":8},{"A":3,"B":6,"C":9}]'

In [241]: sjo.to_json(orient="records")
Out[241]: '[15,16,17]'
</pre></div> </div> <p><strong>Value oriented</strong> is a bare-bones option which serializes to nested JSON arrays of values only, column and index labels are not included:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [242]: dfjo.to_json(orient="values")
Out[242]: '[[1,4,7],[2,5,8],[3,6,9]]'

# Not available for Series
</pre></div> </div> <p><strong>Split oriented</strong> serializes to a JSON object containing separate entries for values, index and columns. Name is also included for <code class="docutils literal notranslate"><span class="pre">Series</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [243]: dfjo.to_json(orient="split")
Out[243]: '{"columns":["A","B","C"],"index":["x","y","z"],"data":[[1,4,7],[2,5,8],[3,6,9]]}'

In [244]: sjo.to_json(orient="split")
Out[244]: '{"name":"D","index":["x","y","z"],"data":[15,16,17]}'
</pre></div> </div> <p><strong>Table oriented</strong> serializes to the JSON <a class="reference external" href="https://specs.frictionlessdata.io/table-schema/">Table Schema</a>, allowing for the preservation of metadata including but not limited to dtypes and index names.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Any orient option that encodes to a JSON object will not preserve the ordering of index and column labels during round-trip serialization. If you wish to preserve label ordering use the <code class="docutils literal notranslate"><span class="pre">split</span></code> option as it uses ordered containers.</p> </div> </section> <section id="id1"> <h4>Date handling</h4> <p>Writing in ISO date format:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [245]: dfd = pd.DataFrame(np.random.randn(5, 2), columns=list("AB"))

In [246]: dfd["date"] = pd.Timestamp("20130101")

In [247]: dfd = dfd.sort_index(axis=1, ascending=False)

In [248]: json = dfd.to_json(date_format="iso")

In [249]: json
Out[249]: '{"date":{"0":"2013-01-01T00:00:00.000","1":"2013-01-01T00:00:00.000","2":"2013-01-01T00:00:00.000","3":"2013-01-01T00:00:00.000","4":"2013-01-01T00:00:00.000"},"B":{"0":0.403309524,"1":0.3016244523,"2":-1.3698493577,"3":1.4626960492,"4":-0.8265909164},"A":{"0":0.1764443426,"1":-0.1549507744,"2":-2.1798606054,"3":-0.9542078401,"4":-1.7431609117}}'
</pre></div> </div> <p>Writing in ISO date format, with microseconds:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [250]: json = dfd.to_json(date_format="iso", date_unit="us")

In [251]: json
Out[251]: '{"date":{"0":"2013-01-01T00:00:00.000000","1":"2013-01-01T00:00:00.000000","2":"2013-01-01T00:00:00.000000","3":"2013-01-01T00:00:00.000000","4":"2013-01-01T00:00:00.000000"},"B":{"0":0.403309524,"1":0.3016244523,"2":-1.3698493577,"3":1.4626960492,"4":-0.8265909164},"A":{"0":0.1764443426,"1":-0.1549507744,"2":-2.1798606054,"3":-0.9542078401,"4":-1.7431609117}}'
</pre></div> </div> <p>Epoch timestamps, in seconds:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [252]: json = dfd.to_json(date_format="epoch", date_unit="s")

In [253]: json
Out[253]: '{"date":{"0":1,"1":1,"2":1,"3":1,"4":1},"B":{"0":0.403309524,"1":0.3016244523,"2":-1.3698493577,"3":1.4626960492,"4":-0.8265909164},"A":{"0":0.1764443426,"1":-0.1549507744,"2":-2.1798606054,"3":-0.9542078401,"4":-1.7431609117}}'
</pre></div> </div> <p>Writing to a file, with a date index and a date column:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [254]: dfj2 = dfj.copy()

In [255]: dfj2["date"] = pd.Timestamp("20130101")

In [256]: dfj2["ints"] = list(range(5))

In [257]: dfj2["bools"] = True

In [258]: dfj2.index = pd.date_range("20130101", periods=5)

In [259]: dfj2.to_json("test.json")

In [260]: with open("test.json") as fh:
   .....:     print(fh.read())
   .....: 
{"A":{"1356998400000":-0.1213062281,"1357084800000":0.6957746499,"1357171200000":0.9597255933,"1357257600000":-0.6199759194,"1357344000000":-0.7323393705},"B":{"1356998400000":-0.0978826728,"1357084800000":0.3417343559,"1357171200000":-1.1103361029,"1357257600000":0.1497483186,"1357344000000":0.6877383895},"date":{"1356998400000":1356,"1357084800000":1356,"1357171200000":1356,"1357257600000":1356,"1357344000000":1356},"ints":{"1356998400000":0,"1357084800000":1,"1357171200000":2,"1357257600000":3,"1357344000000":4},"bools":{"1356998400000":true,"1357084800000":true,"1357171200000":true,"1357257600000":true,"1357344000000":true}}
</pre></div> </div> </section> <section id="fallback-behavior"> <h4>Fallback behavior</h4> <p>If the JSON serializer cannot handle the container contents directly it will fall back in the following manner:</p> <ul> <li><p>if the dtype is unsupported (e.g. <code class="docutils literal notranslate"><span class="pre">np.complex_</span></code>) then the <code class="docutils literal notranslate"><span class="pre">default_handler</span></code>, if provided, will be called for each value, otherwise an exception is raised.</p></li> <li>
<p>if an object is unsupported it will attempt the following:</p> <blockquote> <div>
<ul class="simple"> <li><p>check if the object has defined a <code class="docutils literal notranslate"><span class="pre">toDict</span></code> method and call it. A <code class="docutils literal notranslate"><span class="pre">toDict</span></code> method should return a <code class="docutils literal notranslate"><span class="pre">dict</span></code> which will then be JSON serialized.</p></li> <li><p>invoke the <code class="docutils literal notranslate"><span class="pre">default_handler</span></code> if one was provided.</p></li> <li><p>convert the object to a <code class="docutils literal notranslate"><span class="pre">dict</span></code> by traversing its contents. However this will often fail with an <code class="docutils literal notranslate"><span class="pre">OverflowError</span></code> or give unexpected results.</p></li> </ul> </div>
</blockquote> </li> </ul> <p>In general the best approach for unsupported objects or dtypes is to provide a <code class="docutils literal notranslate"><span class="pre">default_handler</span></code>. For example:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json()  # raises
RuntimeError: Unhandled numpy dtype 15
</pre></div> </div> <p>can be dealt with by specifying a simple <code class="docutils literal notranslate"><span class="pre">default_handler</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [261]: pd.DataFrame([1.0, 2.0, complex(1.0, 2.0)]).to_json(default_handler=str)
Out[261]: '{"0":{"0":"(1+0j)","1":"(2+0j)","2":"(1+2j)"}}'
</pre></div> </div> </section> </section> <section id="reading-json"> <h3>Reading JSON</h3> <p>Reading a JSON string to pandas object can take a number of parameters. The parser will try to parse a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> if <code class="docutils literal notranslate"><span class="pre">typ</span></code> is not supplied or is <code class="docutils literal notranslate"><span class="pre">None</span></code>. To explicitly force <code class="docutils literal notranslate"><span class="pre">Series</span></code> parsing, pass <code class="docutils literal notranslate"><span class="pre">typ=series</span></code></p> <ul> <li><p><code class="docutils literal notranslate"><span class="pre">filepath_or_buffer</span></code> : a <strong>VALID</strong> JSON string or file handle / StringIO. The string could be a URL. Valid URL schemes include http, ftp, S3, and file. For file URLs, a host is expected. For instance, a local file could be file ://localhost/path/to/table.json</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">typ</span></code> : type of object to recover (series or frame), default ‘frame’</p></li> <li>
<p><code class="docutils literal notranslate"><span class="pre">orient</span></code> :</p> <dl class="simple"> <dt>Series :</dt>
<dd>
<ul class="simple"> <li><p>default is <code class="docutils literal notranslate"><span class="pre">index</span></code></p></li> <li><p>allowed values are {<code class="docutils literal notranslate"><span class="pre">split</span></code>, <code class="docutils literal notranslate"><span class="pre">records</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code>}</p></li> </ul> </dd> <dt>DataFrame</dt>
<dd>
<ul class="simple"> <li><p>default is <code class="docutils literal notranslate"><span class="pre">columns</span></code></p></li> <li><p>allowed values are {<code class="docutils literal notranslate"><span class="pre">split</span></code>, <code class="docutils literal notranslate"><span class="pre">records</span></code>, <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">columns</span></code>, <code class="docutils literal notranslate"><span class="pre">values</span></code>, <code class="docutils literal notranslate"><span class="pre">table</span></code>}</p></li> </ul> </dd> </dl> <p>The format of the JSON string</p> <table class="table"> <colgroup> <col style="width: 11.8%"> <col style="width: 88.2%"> </colgroup> <tbody> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">split</span></code></p></td> <td><p>dict like {index -&gt; [index], columns -&gt; [columns], data -&gt; [values]}</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">records</span></code></p></td> <td><p>list like [{column -&gt; value}, … , {column -&gt; value}]</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">index</span></code></p></td> <td><p>dict like {index -&gt; {column -&gt; value}}</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">columns</span></code></p></td> <td><p>dict like {column -&gt; {index -&gt; value}}</p></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">values</span></code></p></td> <td><p>just the values array</p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">table</span></code></p></td> <td><p>adhering to the JSON <a class="reference external" href="https://specs.frictionlessdata.io/table-schema/">Table Schema</a></p></td> </tr> </tbody> </table> </li> <li><p><code class="docutils literal notranslate"><span class="pre">dtype</span></code> : if True, infer dtypes, if a dict of column to dtype, then use those, if <code class="docutils literal notranslate"><span class="pre">False</span></code>, then don’t infer dtypes at all, default is True, apply only to the data.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">convert_axes</span></code> : boolean, try to convert the axes to the proper dtypes, default is <code class="docutils literal notranslate"><span class="pre">True</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">convert_dates</span></code> : a list of columns to parse for dates; If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then try to parse date-like columns, default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">keep_default_dates</span></code> : boolean, default <code class="docutils literal notranslate"><span class="pre">True</span></code>. If parsing dates, then parse the default date-like columns.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">precise_float</span></code> : boolean, default <code class="docutils literal notranslate"><span class="pre">False</span></code>. Set to enable usage of higher precision (strtod) function when decoding string to double values. Default (<code class="docutils literal notranslate"><span class="pre">False</span></code>) is to use fast but less precise builtin functionality.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">date_unit</span></code> : string, the timestamp unit to detect if converting dates. Default None. By default the timestamp precision will be detected, if this is not desired then pass one of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force timestamp precision to seconds, milliseconds, microseconds or nanoseconds respectively.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">lines</span></code> : reads file as one json object per line.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">encoding</span></code> : The encoding to use to decode py3 bytes.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">chunksize</span></code> : when used in combination with <code class="docutils literal notranslate"><span class="pre">lines=True</span></code>, return a <code class="docutils literal notranslate"><span class="pre">pandas.api.typing.JsonReader</span></code> which reads in <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> lines per iteration.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">engine</span></code>: Either <code class="docutils literal notranslate"><span class="pre">"ujson"</span></code>, the built-in JSON parser, or <code class="docutils literal notranslate"><span class="pre">"pyarrow"</span></code> which dispatches to pyarrow’s <code class="docutils literal notranslate"><span class="pre">pyarrow.json.read_json</span></code>. The <code class="docutils literal notranslate"><span class="pre">"pyarrow"</span></code> is only available when <code class="docutils literal notranslate"><span class="pre">lines=True</span></code></p></li> </ul> <p>The parser will raise one of <code class="docutils literal notranslate"><span class="pre">ValueError/TypeError/AssertionError</span></code> if the JSON is not parseable.</p> <p>If a non-default <code class="docutils literal notranslate"><span class="pre">orient</span></code> was used when encoding to JSON be sure to pass the same option here so that decoding produces sensible results, see <a class="reference internal" href="#orient-options">Orient Options</a> for an overview.</p> <section id="data-conversion"> <h4>Data conversion</h4> <p>The default of <code class="docutils literal notranslate"><span class="pre">convert_axes=True</span></code>, <code class="docutils literal notranslate"><span class="pre">dtype=True</span></code>, and <code class="docutils literal notranslate"><span class="pre">convert_dates=True</span></code> will try to parse the axes, and all of the data into appropriate types, including dates. If you need to override specific dtypes, pass a dict to <code class="docutils literal notranslate"><span class="pre">dtype</span></code>. <code class="docutils literal notranslate"><span class="pre">convert_axes</span></code> should only be set to <code class="docutils literal notranslate"><span class="pre">False</span></code> if you need to preserve string-like numbers (e.g. ‘1’, ‘2’) in an axes.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Large integer values may be converted to dates if <code class="docutils literal notranslate"><span class="pre">convert_dates=True</span></code> and the data and / or column labels appear ‘date-like’. The exact threshold depends on the <code class="docutils literal notranslate"><span class="pre">date_unit</span></code> specified. ‘date-like’ means that the column label meets one of the following criteria:</p> <ul class="simple"> <li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_at'</span></code></p></li> <li><p>it ends with <code class="docutils literal notranslate"><span class="pre">'_time'</span></code></p></li> <li><p>it begins with <code class="docutils literal notranslate"><span class="pre">'timestamp'</span></code></p></li> <li><p>it is <code class="docutils literal notranslate"><span class="pre">'modified'</span></code></p></li> <li><p>it is <code class="docutils literal notranslate"><span class="pre">'date'</span></code></p></li> </ul> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When reading JSON data, automatic coercing into dtypes has some quirks:</p> <ul class="simple"> <li><p>an index can be reconstructed in a different order from serialization, that is, the returned order is not guaranteed to be the same as before serialization</p></li> <li><p>a column that was <code class="docutils literal notranslate"><span class="pre">float</span></code> data will be converted to <code class="docutils literal notranslate"><span class="pre">integer</span></code> if it can be done safely, e.g. a column of <code class="docutils literal notranslate"><span class="pre">1.</span></code></p></li> <li><p>bool columns will be converted to <code class="docutils literal notranslate"><span class="pre">integer</span></code> on reconstruction</p></li> </ul> <p>Thus there are times where you may want to specify specific dtypes via the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> keyword argument.</p> </div> <p>Reading from a JSON string:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [262]: from io import StringIO

In [263]: pd.read_json(StringIO(json))
Out[263]: 
   date         B         A
0     1  0.403310  0.176444
1     1  0.301624 -0.154951
2     1 -1.369849 -2.179861
3     1  1.462696 -0.954208
4     1 -0.826591 -1.743161
</pre></div> </div> <p>Reading from a file:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [264]: pd.read_json("test.json")
Out[264]: 
                   A         B  date  ints  bools
2013-01-01 -0.121306 -0.097883  1356     0   True
2013-01-02  0.695775  0.341734  1356     1   True
2013-01-03  0.959726 -1.110336  1356     2   True
2013-01-04 -0.619976  0.149748  1356     3   True
2013-01-05 -0.732339  0.687738  1356     4   True
</pre></div> </div> <p>Don’t convert any data (but still convert axes and dates):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [265]: pd.read_json("test.json", dtype=object).dtypes
Out[265]: 
A        object
B        object
date     object
ints     object
bools    object
dtype: object
</pre></div> </div> <p>Specify dtypes for conversion:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [266]: pd.read_json("test.json", dtype={"A": "float32", "bools": "int8"}).dtypes
Out[266]: 
A        float32
B        float64
date       int64
ints       int64
bools       int8
dtype: object
</pre></div> </div> <p>Preserve string indices:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [267]: from io import StringIO

In [268]: si = pd.DataFrame(
   .....:     np.zeros((4, 4)), columns=list(range(4)), index=[str(i) for i in range(4)]
   .....: )
   .....: 

In [269]: si
Out[269]: 
     0    1    2    3
0  0.0  0.0  0.0  0.0
1  0.0  0.0  0.0  0.0
2  0.0  0.0  0.0  0.0
3  0.0  0.0  0.0  0.0

In [270]: si.index
Out[270]: Index(['0', '1', '2', '3'], dtype='object')

In [271]: si.columns
Out[271]: Index([0, 1, 2, 3], dtype='int64')

In [272]: json = si.to_json()

In [273]: sij = pd.read_json(StringIO(json), convert_axes=False)

In [274]: sij
Out[274]: 
   0  1  2  3
0  0  0  0  0
1  0  0  0  0
2  0  0  0  0
3  0  0  0  0

In [275]: sij.index
Out[275]: Index(['0', '1', '2', '3'], dtype='object')

In [276]: sij.columns
Out[276]: Index(['0', '1', '2', '3'], dtype='object')
</pre></div> </div> <p>Dates written in nanoseconds need to be read back in nanoseconds:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [277]: from io import StringIO

In [278]: json = dfj2.to_json(date_unit="ns")

# Try to parse timestamps as milliseconds -&gt; Won't Work
In [279]: dfju = pd.read_json(StringIO(json), date_unit="ms")

In [280]: dfju
Out[280]: 
                            A         B        date  ints  bools
1356998400000000000 -0.121306 -0.097883  1356998400     0   True
1357084800000000000  0.695775  0.341734  1356998400     1   True
1357171200000000000  0.959726 -1.110336  1356998400     2   True
1357257600000000000 -0.619976  0.149748  1356998400     3   True
1357344000000000000 -0.732339  0.687738  1356998400     4   True

# Let pandas detect the correct precision
In [281]: dfju = pd.read_json(StringIO(json))

In [282]: dfju
Out[282]: 
                   A         B       date  ints  bools
2013-01-01 -0.121306 -0.097883 2013-01-01     0   True
2013-01-02  0.695775  0.341734 2013-01-01     1   True
2013-01-03  0.959726 -1.110336 2013-01-01     2   True
2013-01-04 -0.619976  0.149748 2013-01-01     3   True
2013-01-05 -0.732339  0.687738 2013-01-01     4   True

# Or specify that all timestamps are in nanoseconds
In [283]: dfju = pd.read_json(StringIO(json), date_unit="ns")

In [284]: dfju
Out[284]: 
                   A         B        date  ints  bools
2013-01-01 -0.121306 -0.097883  1356998400     0   True
2013-01-02  0.695775  0.341734  1356998400     1   True
2013-01-03  0.959726 -1.110336  1356998400     2   True
2013-01-04 -0.619976  0.149748  1356998400     3   True
2013-01-05 -0.732339  0.687738  1356998400     4   True
</pre></div> </div> <p>By setting the <code class="docutils literal notranslate"><span class="pre">dtype_backend</span></code> argument you can control the default dtypes used for the resulting DataFrame.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [285]: data = (
   .....:  '{"a":{"0":1,"1":3},"b":{"0":2.5,"1":4.5},"c":{"0":true,"1":false},"d":{"0":"a","1":"b"},'
   .....:  '"e":{"0":null,"1":6.0},"f":{"0":null,"1":7.5},"g":{"0":null,"1":true},"h":{"0":null,"1":"a"},'
   .....:  '"i":{"0":"12-31-2019","1":"12-31-2019"},"j":{"0":null,"1":null}}'
   .....: )
   .....: 

In [286]: df = pd.read_json(StringIO(data), dtype_backend="pyarrow")

In [287]: df
Out[287]: 
   a    b      c  d     e     f     g     h           i     j
0  1  2.5   True  a  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt;  12-31-2019  None
1  3  4.5  False  b     6   7.5  True     a  12-31-2019  None

In [288]: df.dtypes
Out[288]: 
a     int64[pyarrow]
b    double[pyarrow]
c      bool[pyarrow]
d    string[pyarrow]
e     int64[pyarrow]
f    double[pyarrow]
g      bool[pyarrow]
h    string[pyarrow]
i    string[pyarrow]
j      null[pyarrow]
dtype: object
</pre></div> </div> </section> </section> <section id="normalization"> <h3>Normalization</h3> <p>pandas provides a utility function to take a dict or list of dicts and <em>normalize</em> this semi-structured data into a flat table.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [289]: data = [
   .....:     {"id": 1, "name": {"first": "Coleen", "last": "Volk"}},
   .....:     {"name": {"given": "Mark", "family": "Regner"}},
   .....:     {"id": 2, "name": "Faye Raker"},
   .....: ]
   .....: 

In [290]: pd.json_normalize(data)
Out[290]: 
    id name.first name.last name.given name.family        name
0  1.0     Coleen      Volk        NaN         NaN         NaN
1  NaN        NaN       NaN       Mark      Regner         NaN
2  2.0        NaN       NaN        NaN         NaN  Faye Raker
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [291]: data = [
   .....:     {
   .....:         "state": "Florida",
   .....:         "shortname": "FL",
   .....:         "info": {"governor": "Rick Scott"},
   .....:         "county": [
   .....:             {"name": "Dade", "population": 12345},
   .....:             {"name": "Broward", "population": 40000},
   .....:             {"name": "Palm Beach", "population": 60000},
   .....:         ],
   .....:     },
   .....:     {
   .....:         "state": "Ohio",
   .....:         "shortname": "OH",
   .....:         "info": {"governor": "John Kasich"},
   .....:         "county": [
   .....:             {"name": "Summit", "population": 1234},
   .....:             {"name": "Cuyahoga", "population": 1337},
   .....:         ],
   .....:     },
   .....: ]
   .....: 

In [292]: pd.json_normalize(data, "county", ["state", "shortname", ["info", "governor"]])
Out[292]: 
         name  population    state shortname info.governor
0        Dade       12345  Florida        FL    Rick Scott
1     Broward       40000  Florida        FL    Rick Scott
2  Palm Beach       60000  Florida        FL    Rick Scott
3      Summit        1234     Ohio        OH   John Kasich
4    Cuyahoga        1337     Ohio        OH   John Kasich
</pre></div> </div> <p>The max_level parameter provides more control over which level to end normalization. With max_level=1 the following snippet normalizes until 1st nesting level of the provided dict.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [293]: data = [
   .....:     {
   .....:         "CreatedBy": {"Name": "User001"},
   .....:         "Lookup": {
   .....:             "TextField": "Some text",
   .....:             "UserField": {"Id": "ID001", "Name": "Name001"},
   .....:         },
   .....:         "Image": {"a": "b"},
   .....:     }
   .....: ]
   .....: 

In [294]: pd.json_normalize(data, max_level=1)
Out[294]: 
  CreatedBy.Name Lookup.TextField                    Lookup.UserField Image.a
0        User001        Some text  {'Id': 'ID001', 'Name': 'Name001'}       b
</pre></div> </div> </section> <section id="line-delimited-json"> <h3>Line delimited json</h3> <p>pandas is able to read and write line-delimited json files that are common in data processing pipelines using Hadoop or Spark.</p> <p>For line-delimited json files, pandas can also return an iterator which reads in <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> lines at a time. This can be useful for large files or to read from a stream.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [295]: from io import StringIO

In [296]: jsonl = """
   .....:     {"a": 1, "b": 2}
   .....:     {"a": 3, "b": 4}
   .....: """
   .....: 

In [297]: df = pd.read_json(StringIO(jsonl), lines=True)

In [298]: df
Out[298]: 
   a  b
0  1  2
1  3  4

In [299]: df.to_json(orient="records", lines=True)
Out[299]: '{"a":1,"b":2}\n{"a":3,"b":4}\n'

# reader is an iterator that returns ``chunksize`` lines each iteration
In [300]: with pd.read_json(StringIO(jsonl), lines=True, chunksize=1) as reader:
   .....:     reader
   .....:     for chunk in reader:
   .....:         print(chunk)
   .....: 
Empty DataFrame
Columns: []
Index: []
   a  b
0  1  2
   a  b
1  3  4
</pre></div> </div> <p>Line-limited json can also be read using the pyarrow reader by specifying <code class="docutils literal notranslate"><span class="pre">engine="pyarrow"</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [301]: from io import BytesIO

In [302]: df = pd.read_json(BytesIO(jsonl.encode()), lines=True, engine="pyarrow")

In [303]: df
Out[303]: 
   a  b
0  1  2
1  3  4
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.0.</span></p> </div> </section> <section id="table-schema"> <h3>Table schema</h3> <p><a class="reference external" href="https://specs.frictionlessdata.io/table-schema/">Table Schema</a> is a spec for describing tabular datasets as a JSON object. The JSON includes information on the field names, types, and other attributes. You can use the orient <code class="docutils literal notranslate"><span class="pre">table</span></code> to build a JSON string with two fields, <code class="docutils literal notranslate"><span class="pre">schema</span></code> and <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [304]: df = pd.DataFrame(
   .....:     {
   .....:         "A": [1, 2, 3],
   .....:         "B": ["a", "b", "c"],
   .....:         "C": pd.date_range("2016-01-01", freq="d", periods=3),
   .....:     },
   .....:     index=pd.Index(range(3), name="idx"),
   .....: )
   .....: 

In [305]: df
Out[305]: 
     A  B          C
idx                 
0    1  a 2016-01-01
1    2  b 2016-01-02
2    3  c 2016-01-03

In [306]: df.to_json(orient="table", date_format="iso")
Out[306]: '{"schema":{"fields":[{"name":"idx","type":"integer"},{"name":"A","type":"integer"},{"name":"B","type":"string"},{"name":"C","type":"datetime"}],"primaryKey":["idx"],"pandas_version":"1.4.0"},"data":[{"idx":0,"A":1,"B":"a","C":"2016-01-01T00:00:00.000"},{"idx":1,"A":2,"B":"b","C":"2016-01-02T00:00:00.000"},{"idx":2,"A":3,"B":"c","C":"2016-01-03T00:00:00.000"}]}'
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">schema</span></code> field contains the <code class="docutils literal notranslate"><span class="pre">fields</span></code> key, which itself contains a list of column name to type pairs, including the <code class="docutils literal notranslate"><span class="pre">Index</span></code> or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> (see below for a list of types). The <code class="docutils literal notranslate"><span class="pre">schema</span></code> field also contains a <code class="docutils literal notranslate"><span class="pre">primaryKey</span></code> field if the (Multi)index is unique.</p> <p>The second field, <code class="docutils literal notranslate"><span class="pre">data</span></code>, contains the serialized data with the <code class="docutils literal notranslate"><span class="pre">records</span></code> orient. The index is included, and any datetimes are ISO 8601 formatted, as required by the Table Schema spec.</p> <p>The full list of types supported are described in the Table Schema spec. This table shows the mapping from pandas types:</p> <table class="table"> <thead> <tr class="row-odd">
<th class="head"><p>pandas type</p></th> <th class="head"><p>Table Schema type</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>int64</p></td> <td><p>integer</p></td> </tr> <tr class="row-odd">
<td><p>float64</p></td> <td><p>number</p></td> </tr> <tr class="row-even">
<td><p>bool</p></td> <td><p>boolean</p></td> </tr> <tr class="row-odd">
<td><p>datetime64[ns]</p></td> <td><p>datetime</p></td> </tr> <tr class="row-even">
<td><p>timedelta64[ns]</p></td> <td><p>duration</p></td> </tr> <tr class="row-odd">
<td><p>categorical</p></td> <td><p>any</p></td> </tr> <tr class="row-even">
<td><p>object</p></td> <td><p>str</p></td> </tr> </tbody> </table> <p>A few notes on the generated table schema:</p> <ul> <li><p>The <code class="docutils literal notranslate"><span class="pre">schema</span></code> object contains a <code class="docutils literal notranslate"><span class="pre">pandas_version</span></code> field. This contains the version of pandas’ dialect of the schema, and will be incremented with each revision.</p></li> <li>
<p>All dates are converted to UTC when serializing. Even timezone naive values, which are treated as UTC with an offset of 0.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [307]: from pandas.io.json import build_table_schema

In [308]: s = pd.Series(pd.date_range("2016", periods=4))

In [309]: build_table_schema(s)
Out[309]: 
{'fields': [{'name': 'index', 'type': 'integer'},
  {'name': 'values', 'type': 'datetime'}],
 'primaryKey': ['index'],
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>datetimes with a timezone (before serializing), include an additional field <code class="docutils literal notranslate"><span class="pre">tz</span></code> with the time zone name (e.g. <code class="docutils literal notranslate"><span class="pre">'US/Central'</span></code>).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [310]: s_tz = pd.Series(pd.date_range("2016", periods=12, tz="US/Central"))

In [311]: build_table_schema(s_tz)
Out[311]: 
{'fields': [{'name': 'index', 'type': 'integer'},
  {'name': 'values', 'type': 'datetime', 'tz': 'US/Central'}],
 'primaryKey': ['index'],
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>Periods are converted to timestamps before serialization, and so have the same behavior of being converted to UTC. In addition, periods will contain and additional field <code class="docutils literal notranslate"><span class="pre">freq</span></code> with the period’s frequency, e.g. <code class="docutils literal notranslate"><span class="pre">'A-DEC'</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [312]: s_per = pd.Series(1, index=pd.period_range("2016", freq="Y-DEC", periods=4))

In [313]: build_table_schema(s_per)
Out[313]: 
{'fields': [{'name': 'index', 'type': 'datetime', 'freq': 'YE-DEC'},
  {'name': 'values', 'type': 'integer'}],
 'primaryKey': ['index'],
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>Categoricals use the <code class="docutils literal notranslate"><span class="pre">any</span></code> type and an <code class="docutils literal notranslate"><span class="pre">enum</span></code> constraint listing the set of possible values. Additionally, an <code class="docutils literal notranslate"><span class="pre">ordered</span></code> field is included:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [314]: s_cat = pd.Series(pd.Categorical(["a", "b", "a"]))

In [315]: build_table_schema(s_cat)
Out[315]: 
{'fields': [{'name': 'index', 'type': 'integer'},
  {'name': 'values',
   'type': 'any',
   'constraints': {'enum': ['a', 'b']},
   'ordered': False}],
 'primaryKey': ['index'],
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>A <code class="docutils literal notranslate"><span class="pre">primaryKey</span></code> field, containing an array of labels, is included <em>if the index is unique</em>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [316]: s_dupe = pd.Series([1, 2], index=[1, 1])

In [317]: build_table_schema(s_dupe)
Out[317]: 
{'fields': [{'name': 'index', 'type': 'integer'},
  {'name': 'values', 'type': 'integer'}],
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>The <code class="docutils literal notranslate"><span class="pre">primaryKey</span></code> behavior is the same with MultiIndexes, but in this case the <code class="docutils literal notranslate"><span class="pre">primaryKey</span></code> is an array:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [318]: s_multi = pd.Series(1, index=pd.MultiIndex.from_product([("a", "b"), (0, 1)]))

In [319]: build_table_schema(s_multi)
Out[319]: 
{'fields': [{'name': 'level_0', 'type': 'string'},
  {'name': 'level_1', 'type': 'integer'},
  {'name': 'values', 'type': 'integer'}],
 'primaryKey': FrozenList(['level_0', 'level_1']),
 'pandas_version': '1.4.0'}
</pre></div> </div> </li> <li>
<p>The default naming roughly follows these rules:</p> <blockquote> <div>
<ul class="simple"> <li><p>For series, the <code class="docutils literal notranslate"><span class="pre">object.name</span></code> is used. If that’s none, then the name is <code class="docutils literal notranslate"><span class="pre">values</span></code></p></li> <li><p>For <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>, the stringified version of the column name is used</p></li> <li><p>For <code class="docutils literal notranslate"><span class="pre">Index</span></code> (not <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>), <code class="docutils literal notranslate"><span class="pre">index.name</span></code> is used, with a fallback to <code class="docutils literal notranslate"><span class="pre">index</span></code> if that is None.</p></li> <li><p>For <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>, <code class="docutils literal notranslate"><span class="pre">mi.names</span></code> is used. If any level has no name, then <code class="docutils literal notranslate"><span class="pre">level_&lt;i&gt;</span></code> is used.</p></li> </ul> </div>
</blockquote> </li> </ul> <p><code class="docutils literal notranslate"><span class="pre">read_json</span></code> also accepts <code class="docutils literal notranslate"><span class="pre">orient='table'</span></code> as an argument. This allows for the preservation of metadata such as dtypes and index names in a round-trippable manner.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [320]: df = pd.DataFrame(
   .....:     {
   .....:         "foo": [1, 2, 3, 4],
   .....:         "bar": ["a", "b", "c", "d"],
   .....:         "baz": pd.date_range("2018-01-01", freq="d", periods=4),
   .....:         "qux": pd.Categorical(["a", "b", "c", "c"]),
   .....:     },
   .....:     index=pd.Index(range(4), name="idx"),
   .....: )
   .....: 

In [321]: df
Out[321]: 
     foo bar        baz qux
idx                        
0      1   a 2018-01-01   a
1      2   b 2018-01-02   b
2      3   c 2018-01-03   c
3      4   d 2018-01-04   c

In [322]: df.dtypes
Out[322]: 
foo             int64
bar            object
baz    datetime64[ns]
qux          category
dtype: object

In [323]: df.to_json("test.json", orient="table")

In [324]: new_df = pd.read_json("test.json", orient="table")

In [325]: new_df
Out[325]: 
     foo bar        baz qux
idx                        
0      1   a 2018-01-01   a
1      2   b 2018-01-02   b
2      3   c 2018-01-03   c
3      4   d 2018-01-04   c

In [326]: new_df.dtypes
Out[326]: 
foo             int64
bar            object
baz    datetime64[ns]
qux          category
dtype: object
</pre></div> </div> <p>Please note that the literal string ‘index’ as the name of an <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> is not round-trippable, nor are any names beginning with <code class="docutils literal notranslate"><span class="pre">'level_'</span></code> within a <a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a>. These are used by default in <a class="reference internal" href="../reference/api/pandas.dataframe.to_json.html#pandas.DataFrame.to_json" title="pandas.DataFrame.to_json"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.to_json()</span></code></a> to indicate missing values and the subsequent read cannot distinguish the intent.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [327]: df.index.name = "index"

In [328]: df.to_json("test.json", orient="table")

In [329]: new_df = pd.read_json("test.json", orient="table")

In [330]: print(new_df.index.name)
None
</pre></div> </div> <p>When using <code class="docutils literal notranslate"><span class="pre">orient='table'</span></code> along with user-defined <code class="docutils literal notranslate"><span class="pre">ExtensionArray</span></code>, the generated schema will contain an additional <code class="docutils literal notranslate"><span class="pre">extDtype</span></code> key in the respective <code class="docutils literal notranslate"><span class="pre">fields</span></code> element. This extra key is not standard but does enable JSON roundtrips for extension types (e.g. <code class="docutils literal notranslate"><span class="pre">read_json(df.to_json(orient="table"),</span> <span class="pre">orient="table")</span></code>).</p> <p>The <code class="docutils literal notranslate"><span class="pre">extDtype</span></code> key carries the name of the extension, if you have properly registered the <code class="docutils literal notranslate"><span class="pre">ExtensionDtype</span></code>, pandas will use said name to perform a lookup into the registry and re-convert the serialized data into your custom dtype.</p> </section> </section> <section id="html"> <h2>HTML</h2> <section id="reading-html-content"> <h3>Reading HTML content</h3> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>We <strong>highly encourage</strong> you to read the <a class="reference internal" href="#io-html-gotchas"><span class="std std-ref">HTML Table Parsing gotchas</span></a> below regarding the issues surrounding the BeautifulSoup4/html5lib/lxml parsers.</p> </div> <p>The top-level <code class="xref py py-func docutils literal notranslate"><span class="pre">read_html()</span></code> function can accept an HTML string/file/URL and will parse HTML tables into list of pandas <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>. Let’s look at a few examples.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">read_html</span></code> returns a <code class="docutils literal notranslate"><span class="pre">list</span></code> of <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects, even if there is only a single table contained in the HTML content.</p> </div> <p>Read a URL with no options:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [320]: url = "https://www.fdic.gov/resources/resolutions/bank-failures/failed-bank-list"
In [321]: pd.read_html(url)
Out[321]:
[                         Bank NameBank           CityCity StateSt  ...              Acquiring InstitutionAI Closing DateClosing FundFund
 0                    Almena State Bank             Almena      KS  ...                          Equity Bank    October 23, 2020    10538
 1           First City Bank of Florida  Fort Walton Beach      FL  ...            United Fidelity Bank, fsb    October 16, 2020    10537
 2                 The First State Bank      Barboursville      WV  ...                       MVB Bank, Inc.       April 3, 2020    10536
 3                   Ericson State Bank            Ericson      NE  ...           Farmers and Merchants Bank   February 14, 2020    10535
 4     City National Bank of New Jersey             Newark      NJ  ...                      Industrial Bank    November 1, 2019    10534
 ..                                 ...                ...     ...  ...                                  ...                 ...      ...
 558                 Superior Bank, FSB           Hinsdale      IL  ...                Superior Federal, FSB       July 27, 2001     6004
 559                Malta National Bank              Malta      OH  ...                    North Valley Bank         May 3, 2001     4648
 560    First Alliance Bank &amp; Trust Co.         Manchester      NH  ...  Southern New Hampshire Bank &amp; Trust    February 2, 2001     4647
 561  National State Bank of Metropolis         Metropolis      IL  ...              Banterra Bank of Marion   December 14, 2000     4646
 562                   Bank of Honolulu           Honolulu      HI  ...                   Bank of the Orient    October 13, 2000     4645

 [563 rows x 7 columns]]
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The data from the above URL changes every Monday so the resulting data above may be slightly different.</p> </div> <p>Read a URL while passing headers alongside the HTTP request:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [322]: url = 'https://www.sump.org/notes/request/' # HTTP request reflector
In [323]: pd.read_html(url)
Out[323]:
[                   0                    1
 0     Remote Socket:  51.15.105.256:51760
 1  Protocol Version:             HTTP/1.1
 2    Request Method:                  GET
 3       Request URI:      /notes/request/
 4     Request Query:                  NaN,
 0   Accept-Encoding:             identity
 1              Host:         www.sump.org
 2        User-Agent:    Python-urllib/3.8
 3        Connection:                close]
In [324]: headers = {
In [325]:    'User-Agent':'Mozilla Firefox v14.0',
In [326]:    'Accept':'application/json',
In [327]:    'Connection':'keep-alive',
In [328]:    'Auth':'Bearer 2*/f3+fe68df*4'
In [329]: }
In [340]: pd.read_html(url, storage_options=headers)
Out[340]:
[                   0                    1
 0     Remote Socket:  51.15.105.256:51760
 1  Protocol Version:             HTTP/1.1
 2    Request Method:                  GET
 3       Request URI:      /notes/request/
 4     Request Query:                  NaN,
 0        User-Agent: Mozilla Firefox v14.0
 1    AcceptEncoding:   gzip,  deflate,  br
 2            Accept:      application/json
 3        Connection:             keep-alive
 4              Auth:  Bearer 2*/f3+fe68df*4]
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>We see above that the headers we passed are reflected in the HTTP request.</p> </div> <p>Read in the content of the file from the above URL and pass it to <code class="docutils literal notranslate"><span class="pre">read_html</span></code> as a string:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [331]: html_str = """
   .....:          &lt;table&gt;
   .....:              &lt;tr&gt;
   .....:                  &lt;th&gt;A&lt;/th&gt;
   .....:                  &lt;th colspan="1"&gt;B&lt;/th&gt;
   .....:                  &lt;th rowspan="1"&gt;C&lt;/th&gt;
   .....:              &lt;/tr&gt;
   .....:              &lt;tr&gt;
   .....:                  &lt;td&gt;a&lt;/td&gt;
   .....:                  &lt;td&gt;b&lt;/td&gt;
   .....:                  &lt;td&gt;c&lt;/td&gt;
   .....:              &lt;/tr&gt;
   .....:          &lt;/table&gt;
   .....:      """
   .....: 

In [332]: with open("tmp.html", "w") as f:
   .....:     f.write(html_str)
   .....: 

In [333]: df = pd.read_html("tmp.html")

In [334]: df[0]
Out[334]: 
   A  B  C
0  a  b  c
</pre></div> </div> <p>You can even pass in an instance of <code class="docutils literal notranslate"><span class="pre">StringIO</span></code> if you so desire:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [335]: dfs = pd.read_html(StringIO(html_str))

In [336]: dfs[0]
Out[336]: 
   A  B  C
0  a  b  c
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The following examples are not run by the IPython evaluator due to the fact that having so many network-accessing functions slows down the documentation build. If you spot an error or an example that doesn’t run, please do not hesitate to report it over on <a class="reference external" href="https://github.com/pandas-dev/pandas/issues">pandas GitHub issues page</a>.</p> </div> <p>Read a URL and match a table that contains specific text:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">match = "Metcalf Bank"
df_list = pd.read_html(url, match=match)
</pre></div> </div> <p>Specify a header row (by default <code class="docutils literal notranslate"><span class="pre">&lt;th&gt;</span></code> or <code class="docutils literal notranslate"><span class="pre">&lt;td&gt;</span></code> elements located within a <code class="docutils literal notranslate"><span class="pre">&lt;thead&gt;</span></code> are used to form the column index, if multiple rows are contained within <code class="docutils literal notranslate"><span class="pre">&lt;thead&gt;</span></code> then a MultiIndex is created); if specified, the header row is taken from the data minus the parsed header elements (<code class="docutils literal notranslate"><span class="pre">&lt;th&gt;</span></code> elements).</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, header=0)
</pre></div> </div> <p>Specify an index column:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, index_col=0)
</pre></div> </div> <p>Specify a number of rows to skip:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, skiprows=0)
</pre></div> </div> <p>Specify a number of rows to skip using a list (<code class="docutils literal notranslate"><span class="pre">range</span></code> works as well):</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, skiprows=range(2))
</pre></div> </div> <p>Specify an HTML attribute:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs1 = pd.read_html(url, attrs={"id": "table"})
dfs2 = pd.read_html(url, attrs={"class": "sortable"})
print(np.array_equal(dfs1[0], dfs2[0]))  # Should be True
</pre></div> </div> <p>Specify values that should be converted to NaN:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, na_values=["No Acquirer"])
</pre></div> </div> <p>Specify whether to keep the default set of NaN values:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, keep_default_na=False)
</pre></div> </div> <p>Specify converters for columns. This is useful for numerical text data that has leading zeros. By default columns that are numerical are cast to numeric types and the leading zeros are lost. To avoid this, we can convert these columns to strings.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">url_mcc = "https://en.wikipedia.org/wiki/Mobile_country_code?oldid=899173761"
dfs = pd.read_html(
    url_mcc,
    match="Telekom Albania",
    header=0,
    converters={"MNC": str},
)
</pre></div> </div> <p>Use some combination of the above:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, match="Metcalf Bank", index_col=0)
</pre></div> </div> <p>Read in pandas <code class="docutils literal notranslate"><span class="pre">to_html</span></code> output (with some loss of floating point precision):</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.DataFrame(np.random.randn(2, 2))
s = df.to_html(float_format="{0:.40g}".format)
dfin = pd.read_html(s, index_col=0)
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">lxml</span></code> backend will raise an error on a failed parse if that is the only parser you provide. If you only have a single parser you can provide just a string, but it is considered good practice to pass a list with one string if, for example, the function expects a sequence of strings. You may use:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, "Metcalf Bank", index_col=0, flavor=["lxml"])
</pre></div> </div> <p>Or you could pass <code class="docutils literal notranslate"><span class="pre">flavor='lxml'</span></code> without a list:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, "Metcalf Bank", index_col=0, flavor="lxml")
</pre></div> </div> <p>However, if you have bs4 and html5lib installed and pass <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">['lxml',</span>
<span class="pre">'bs4']</span></code> then the parse will most likely succeed. Note that <em>as soon as a parse succeeds, the function will return</em>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfs = pd.read_html(url, "Metcalf Bank", index_col=0, flavor=["lxml", "bs4"])
</pre></div> </div> <p>Links can be extracted from cells along with the text using <code class="docutils literal notranslate"><span class="pre">extract_links="all"</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [337]: html_table = """
   .....: &lt;table&gt;
   .....:   &lt;tr&gt;
   .....:     &lt;th&gt;GitHub&lt;/th&gt;
   .....:   &lt;/tr&gt;
   .....:   &lt;tr&gt;
   .....:     &lt;td&gt;&lt;a href="https://github.com/pandas-dev/pandas"&gt;pandas&lt;/a&gt;&lt;/td&gt;
   .....:   &lt;/tr&gt;
   .....: &lt;/table&gt;
   .....: """
   .....: 

In [338]: df = pd.read_html(
   .....:     StringIO(html_table),
   .....:     extract_links="all"
   .....: )[0]
   .....: 

In [339]: df
Out[339]: 
                                   (GitHub, None)
0  (pandas, https://github.com/pandas-dev/pandas)

In [340]: df[("GitHub", None)]
Out[340]: 
0    (pandas, https://github.com/pandas-dev/pandas)
Name: (GitHub, None), dtype: object

In [341]: df[("GitHub", None)].str[1]
Out[341]: 
0    https://github.com/pandas-dev/pandas
Name: (GitHub, None), dtype: object
</pre></div> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.5.0.</span></p> </div> </section> <section id="writing-to-html-files"> <h3>Writing to HTML files</h3> <p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects have an instance method <code class="docutils literal notranslate"><span class="pre">to_html</span></code> which renders the contents of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as an HTML table. The function arguments are as in the method <code class="docutils literal notranslate"><span class="pre">to_string</span></code> described above.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Not all of the possible options for <code class="docutils literal notranslate"><span class="pre">DataFrame.to_html</span></code> are shown here for brevity’s sake. See <code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.to_html()</span></code> for the full set of options.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In an HTML-rendering supported environment like a Jupyter Notebook, <code class="docutils literal notranslate"><span class="pre">display(HTML(...))`</span></code> will render the raw HTML into the environment.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [342]: from IPython.display import display, HTML

In [343]: df = pd.DataFrame(np.random.randn(2, 2))

In [344]: df
Out[344]: 
          0         1
0 -0.345352  1.314232
1  0.690579  0.995761

In [345]: html = df.to_html()

In [346]: print(html)  # raw html
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.345352&lt;/td&gt;
      &lt;td&gt;1.314232&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;0.690579&lt;/td&gt;
      &lt;td&gt;0.995761&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [347]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">columns</span></code> argument will limit the columns shown:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [348]: html = df.to_html(columns=[0])

In [349]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.345352&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;0.690579&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [350]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">float_format</span></code> takes a Python callable to control the precision of floating point values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [351]: html = df.to_html(float_format="{0:.10f}".format)

In [352]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.3453521949&lt;/td&gt;
      &lt;td&gt;1.3142323796&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;0.6905793352&lt;/td&gt;
      &lt;td&gt;0.9957609037&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [353]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">bold_rows</span></code> will make the row labels bold by default, but you can turn that off:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [354]: html = df.to_html(bold_rows=False)

In [355]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;0&lt;/td&gt;
      &lt;td&gt;-0.345352&lt;/td&gt;
      &lt;td&gt;1.314232&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;1&lt;/td&gt;
      &lt;td&gt;0.690579&lt;/td&gt;
      &lt;td&gt;0.995761&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [356]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">classes</span></code> argument provides the ability to give the resulting HTML table CSS classes. Note that these classes are <em>appended</em> to the existing <code class="docutils literal notranslate"><span class="pre">'dataframe'</span></code> class.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [357]: print(df.to_html(classes=["awesome_table_class", "even_more_awesome_class"]))
&lt;table border="1" class="dataframe awesome_table_class even_more_awesome_class"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;th&gt;1&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;-0.345352&lt;/td&gt;
      &lt;td&gt;1.314232&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;0.690579&lt;/td&gt;
      &lt;td&gt;0.995761&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">render_links</span></code> argument provides the ability to add hyperlinks to cells that contain URLs.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [358]: url_df = pd.DataFrame(
   .....:     {
   .....:         "name": ["Python", "pandas"],
   .....:         "url": ["https://www.python.org/", "https://pandas.pydata.org"],
   .....:     }
   .....: )
   .....: 

In [359]: html = url_df.to_html(render_links=True)

In [360]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;name&lt;/th&gt;
      &lt;th&gt;url&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;&lt;a href="https://www.python.org/" target="_blank"&gt;https://www.python.org/&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;pandas&lt;/td&gt;
      &lt;td&gt;&lt;a href="https://pandas.pydata.org" target="_blank"&gt;https://pandas.pydata.org&lt;/a&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [361]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p>Finally, the <code class="docutils literal notranslate"><span class="pre">escape</span></code> argument allows you to control whether the “&lt;”, “&gt;” and “&amp;” characters escaped in the resulting HTML (by default it is <code class="docutils literal notranslate"><span class="pre">True</span></code>). So to get the HTML without escaped characters pass <code class="docutils literal notranslate"><span class="pre">escape=False</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [362]: df = pd.DataFrame({"a": list("&amp;&lt;&gt;"), "b": np.random.randn(3)})
</pre></div> </div> <p>Escaped:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [363]: html = df.to_html()

In [364]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;&amp;amp;&lt;/td&gt;
      &lt;td&gt;2.396780&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;&amp;lt;&lt;/td&gt;
      &lt;td&gt;0.014871&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;&amp;gt;&lt;/td&gt;
      &lt;td&gt;3.357427&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [365]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <p>Not escaped:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [366]: html = df.to_html(escape=False)

In [367]: print(html)
&lt;table border="1" class="dataframe"&gt;
  &lt;thead&gt;
    &lt;tr style="text-align: right;"&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;a&lt;/th&gt;
      &lt;th&gt;b&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;th&gt;0&lt;/th&gt;
      &lt;td&gt;&amp;&lt;/td&gt;
      &lt;td&gt;2.396780&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;1&lt;/th&gt;
      &lt;td&gt;&lt;&lt;/td&gt;
      &lt;td&gt;0.014871&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;th&gt;2&lt;/th&gt;
      &lt;td&gt;&gt;&lt;/td&gt;
      &lt;td&gt;3.357427&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

In [368]: display(HTML(html))
&lt;IPython.core.display.HTML object&gt;
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Some browsers may not show a difference in the rendering of the previous two HTML tables.</p> </div> </section> <section id="html-table-parsing-gotchas"> <h3>HTML Table Parsing Gotchas</h3> <p>There are some versioning issues surrounding the libraries that are used to parse HTML tables in the top-level pandas io function <code class="docutils literal notranslate"><span class="pre">read_html</span></code>.</p> <p><strong>Issues with</strong> <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a></p> <ul> <li>
<p>Benefits</p> <blockquote> <div>
<ul class="simple"> <li><p><a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> is very fast.</p></li> <li><p><a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> requires Cython to install correctly.</p></li> </ul> </div>
</blockquote> </li> <li>
<p>Drawbacks</p> <blockquote> <div>
<ul class="simple"> <li><p><a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> does <em>not</em> make any guarantees about the results of its parse <em>unless</em> it is given <a class="reference external" href="https://validator.w3.org/docs/help.html#validation_basics"><strong>strictly valid markup</strong></a>.</p></li> <li><p>In light of the above, we have chosen to allow you, the user, to use the <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> backend, but <strong>this backend will use</strong> <a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> if <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> fails to parse</p></li> <li><p>It is therefore <em>highly recommended</em> that you install both <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup"><strong>BeautifulSoup4</strong></a> and <a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a>, so that you will still get a valid result (provided everything else is valid) even if <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> fails.</p></li> </ul> </div>
</blockquote> </li> </ul> <p><strong>Issues with</strong> <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup"><strong>BeautifulSoup4</strong></a> <strong>using</strong> <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> <strong>as a backend</strong></p> <ul class="simple"> <li><p>The above issues hold here as well since <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup"><strong>BeautifulSoup4</strong></a> is essentially just a wrapper around a parser backend.</p></li> </ul> <p><strong>Issues with</strong> <a class="reference external" href="https://www.crummy.com/software/BeautifulSoup"><strong>BeautifulSoup4</strong></a> <strong>using</strong> <a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> <strong>as a backend</strong></p> <ul> <li>
<p>Benefits</p> <blockquote> <div>
<ul class="simple"> <li><p><a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> is far more lenient than <a class="reference external" href="https://lxml.de"><strong>lxml</strong></a> and consequently deals with <em>real-life markup</em> in a much saner way rather than just, e.g., dropping an element without notifying you.</p></li> <li><p><a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> <em>generates valid HTML5 markup from invalid markup automatically</em>. This is extremely important for parsing HTML tables, since it guarantees a valid document. However, that does NOT mean that it is “correct”, since the process of fixing markup does not have a single definition.</p></li> <li><p><a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> is pure Python and requires no additional build steps beyond its own installation.</p></li> </ul> </div>
</blockquote> </li> <li>
<p>Drawbacks</p> <blockquote> <div>
<ul class="simple"> <li><p>The biggest drawback to using <a class="reference external" href="https://github.com/html5lib/html5lib-python"><strong>html5lib</strong></a> is that it is slow as molasses. However consider the fact that many tables on the web are not big enough for the parsing algorithm runtime to matter. It is more likely that the bottleneck will be in the process of reading the raw text from the URL over the web, i.e., IO (input-output). For very large tables, this might not be true.</p></li> </ul> </div>
</blockquote> </li> </ul> </section> </section> <section id="latex"> <h2>LaTeX</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>Currently there are no methods to read from LaTeX, only output methods.</p> <section id="writing-to-latex-files"> <h3>Writing to LaTeX files</h3> <div class="admonition note"> <p class="admonition-title">Note</p> <p>DataFrame <em>and</em> Styler objects currently have a <code class="docutils literal notranslate"><span class="pre">to_latex</span></code> method. We recommend using the <a class="reference internal" href="../reference/api/pandas.io.formats.style.styler.to_latex.html"><span class="doc">Styler.to_latex()</span></a> method over <a class="reference internal" href="../reference/api/pandas.dataframe.to_latex.html"><span class="doc">DataFrame.to_latex()</span></a> due to the former’s greater flexibility with conditional styling, and the latter’s possible future deprecation.</p> </div> <p>Review the documentation for <a class="reference internal" href="../reference/api/pandas.io.formats.style.styler.to_latex.html"><span class="doc">Styler.to_latex</span></a>, which gives examples of conditional styling and explains the operation of its keyword arguments.</p> <p>For simple application the following pattern is sufficient.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [369]: df = pd.DataFrame([[1, 2], [3, 4]], index=["a", "b"], columns=["c", "d"])

In [370]: print(df.style.to_latex())
\begin{tabular}{lrr}
 &amp; c &amp; d \\
a &amp; 1 &amp; 2 \\
b &amp; 3 &amp; 4 \\
\end{tabular}
</pre></div> </div> <p>To format values before output, chain the <a class="reference internal" href="../reference/api/pandas.io.formats.style.styler.format.html"><span class="doc">Styler.format</span></a> method.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [371]: print(df.style.format("€ {}").to_latex())
\begin{tabular}{lrr}
 &amp; c &amp; d \\
a &amp; € 1 &amp; € 2 \\
b &amp; € 3 &amp; € 4 \\
\end{tabular}
</pre></div> </div> </section> </section> <section id="xml"> <h2>XML</h2> <section id="reading-xml"> <h3>Reading XML</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p>The top-level <code class="xref py py-func docutils literal notranslate"><span class="pre">read_xml()</span></code> function can accept an XML string/file/URL and will parse nodes and attributes into a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since there is no standard XML structure where design types can vary in many ways, <code class="docutils literal notranslate"><span class="pre">read_xml</span></code> works best with flatter, shallow versions. If an XML document is deeply nested, use the <code class="docutils literal notranslate"><span class="pre">stylesheet</span></code> feature to transform XML into a flatter version.</p> </div> <p>Let’s look at a few examples.</p> <p>Read an XML string:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [372]: from io import StringIO

In [373]: xml = """&lt;?xml version="1.0" encoding="UTF-8"?&gt;
   .....: &lt;bookstore&gt;
   .....:   &lt;book category="cooking"&gt;
   .....:     &lt;title lang="en"&gt;Everyday Italian&lt;/title&gt;
   .....:     &lt;author&gt;Giada De Laurentiis&lt;/author&gt;
   .....:     &lt;year&gt;2005&lt;/year&gt;
   .....:     &lt;price&gt;30.00&lt;/price&gt;
   .....:   &lt;/book&gt;
   .....:   &lt;book category="children"&gt;
   .....:     &lt;title lang="en"&gt;Harry Potter&lt;/title&gt;
   .....:     &lt;author&gt;J K. Rowling&lt;/author&gt;
   .....:     &lt;year&gt;2005&lt;/year&gt;
   .....:     &lt;price&gt;29.99&lt;/price&gt;
   .....:   &lt;/book&gt;
   .....:   &lt;book category="web"&gt;
   .....:     &lt;title lang="en"&gt;Learning XML&lt;/title&gt;
   .....:     &lt;author&gt;Erik T. Ray&lt;/author&gt;
   .....:     &lt;year&gt;2003&lt;/year&gt;
   .....:     &lt;price&gt;39.95&lt;/price&gt;
   .....:   &lt;/book&gt;
   .....: &lt;/bookstore&gt;"""
   .....: 

In [374]: df = pd.read_xml(StringIO(xml))

In [375]: df
Out[375]: 
   category             title               author  year  price
0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00
1  children      Harry Potter         J K. Rowling  2005  29.99
2       web      Learning XML          Erik T. Ray  2003  39.95
</pre></div> </div> <p>Read a URL with no options:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [376]: df = pd.read_xml("https://www.w3schools.com/xml/books.xml")

In [377]: df
Out[377]: 
   category              title                  author  year  price      cover
0   cooking   Everyday Italian     Giada De Laurentiis  2005  30.00       None
1  children       Harry Potter            J K. Rowling  2005  29.99       None
2       web  XQuery Kick Start  Vaidyanathan Nagarajan  2003  49.99       None
3       web       Learning XML             Erik T. Ray  2003  39.95  paperback
</pre></div> </div> <p>Read in the content of the “books.xml” file and pass it to <code class="docutils literal notranslate"><span class="pre">read_xml</span></code> as a string:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [378]: file_path = "books.xml"

In [379]: with open(file_path, "w") as f:
   .....:     f.write(xml)
   .....: 

In [380]: with open(file_path, "r") as f:
   .....:     df = pd.read_xml(StringIO(f.read()))
   .....: 

In [381]: df
Out[381]: 
   category             title               author  year  price
0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00
1  children      Harry Potter         J K. Rowling  2005  29.99
2       web      Learning XML          Erik T. Ray  2003  39.95
</pre></div> </div> <p>Read in the content of the “books.xml” as instance of <code class="docutils literal notranslate"><span class="pre">StringIO</span></code> or <code class="docutils literal notranslate"><span class="pre">BytesIO</span></code> and pass it to <code class="docutils literal notranslate"><span class="pre">read_xml</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [382]: with open(file_path, "r") as f:
   .....:     sio = StringIO(f.read())
   .....: 

In [383]: df = pd.read_xml(sio)

In [384]: df
Out[384]: 
   category             title               author  year  price
0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00
1  children      Harry Potter         J K. Rowling  2005  29.99
2       web      Learning XML          Erik T. Ray  2003  39.95
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [385]: with open(file_path, "rb") as f:
   .....:     bio = BytesIO(f.read())
   .....: 

In [386]: df = pd.read_xml(bio)

In [387]: df
Out[387]: 
   category             title               author  year  price
0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00
1  children      Harry Potter         J K. Rowling  2005  29.99
2       web      Learning XML          Erik T. Ray  2003  39.95
</pre></div> </div> <p>Even read XML from AWS S3 buckets such as NIH NCBI PMC Article Datasets providing Biomedical and Life Science Jorurnals:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [388]: df = pd.read_xml(
   .....:     "s3://pmc-oa-opendata/oa_comm/xml/all/PMC1236943.xml",
   .....:     xpath=".//journal-meta",
   .....: )
   .....: 

In [389]: df
Out[389]: 
              journal-id              journal-title       issn  publisher
0  Cardiovasc Ultrasound  Cardiovascular Ultrasound  1476-7120        NaN
</pre></div> </div> <p>With <a class="reference external" href="https://lxml.de">lxml</a> as default <code class="docutils literal notranslate"><span class="pre">parser</span></code>, you access the full-featured XML library that extends Python’s ElementTree API. One powerful tool is ability to query nodes selectively or conditionally with more expressive XPath:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [390]: df = pd.read_xml(file_path, xpath="//book[year=2005]")

In [391]: df
Out[391]: 
   category             title               author  year  price
0   cooking  Everyday Italian  Giada De Laurentiis  2005  30.00
1  children      Harry Potter         J K. Rowling  2005  29.99
</pre></div> </div> <p>Specify only elements or only attributes to parse:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [392]: df = pd.read_xml(file_path, elems_only=True)

In [393]: df
Out[393]: 
              title               author  year  price
0  Everyday Italian  Giada De Laurentiis  2005  30.00
1      Harry Potter         J K. Rowling  2005  29.99
2      Learning XML          Erik T. Ray  2003  39.95
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [394]: df = pd.read_xml(file_path, attrs_only=True)

In [395]: df
Out[395]: 
   category
0   cooking
1  children
2       web
</pre></div> </div> <p>XML documents can have namespaces with prefixes and default namespaces without prefixes both of which are denoted with a special attribute <code class="docutils literal notranslate"><span class="pre">xmlns</span></code>. In order to parse by node under a namespace context, <code class="docutils literal notranslate"><span class="pre">xpath</span></code> must reference a prefix.</p> <p>For example, below XML contains a namespace with prefix, <code class="docutils literal notranslate"><span class="pre">doc</span></code>, and URI at <code class="docutils literal notranslate"><span class="pre">https://example.com</span></code>. In order to parse <code class="docutils literal notranslate"><span class="pre">doc:row</span></code> nodes, <code class="docutils literal notranslate"><span class="pre">namespaces</span></code> must be used.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [396]: xml = """&lt;?xml version='1.0' encoding='utf-8'?&gt;
   .....: &lt;doc:data xmlns:doc="https://example.com"&gt;
   .....:   &lt;doc:row&gt;
   .....:     &lt;doc:shape&gt;square&lt;/doc:shape&gt;
   .....:     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
   .....:     &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;
   .....:   &lt;/doc:row&gt;
   .....:   &lt;doc:row&gt;
   .....:     &lt;doc:shape&gt;circle&lt;/doc:shape&gt;
   .....:     &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
   .....:     &lt;doc:sides/&gt;
   .....:   &lt;/doc:row&gt;
   .....:   &lt;doc:row&gt;
   .....:     &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;
   .....:     &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;
   .....:     &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;
   .....:   &lt;/doc:row&gt;
   .....: &lt;/doc:data&gt;"""
   .....: 

In [397]: df = pd.read_xml(StringIO(xml),
   .....:                  xpath="//doc:row",
   .....:                  namespaces={"doc": "https://example.com"})
   .....: 

In [398]: df
Out[398]: 
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0
</pre></div> </div> <p>Similarly, an XML document can have a default namespace without prefix. Failing to assign a temporary prefix will return no nodes and raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>. But assigning <em>any</em> temporary name to correct URI allows parsing by nodes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [399]: xml = """&lt;?xml version='1.0' encoding='utf-8'?&gt;
   .....: &lt;data xmlns="https://example.com"&gt;
   .....:  &lt;row&gt;
   .....:    &lt;shape&gt;square&lt;/shape&gt;
   .....:    &lt;degrees&gt;360&lt;/degrees&gt;
   .....:    &lt;sides&gt;4.0&lt;/sides&gt;
   .....:  &lt;/row&gt;
   .....:  &lt;row&gt;
   .....:    &lt;shape&gt;circle&lt;/shape&gt;
   .....:    &lt;degrees&gt;360&lt;/degrees&gt;
   .....:    &lt;sides/&gt;
   .....:  &lt;/row&gt;
   .....:  &lt;row&gt;
   .....:    &lt;shape&gt;triangle&lt;/shape&gt;
   .....:    &lt;degrees&gt;180&lt;/degrees&gt;
   .....:    &lt;sides&gt;3.0&lt;/sides&gt;
   .....:  &lt;/row&gt;
   .....: &lt;/data&gt;"""
   .....: 

In [400]: df = pd.read_xml(StringIO(xml),
   .....:                  xpath="//pandas:row",
   .....:                  namespaces={"pandas": "https://example.com"})
   .....: 

In [401]: df
Out[401]: 
      shape  degrees  sides
0    square      360    4.0
1    circle      360    NaN
2  triangle      180    3.0
</pre></div> </div> <p>However, if XPath does not reference node names such as default, <code class="docutils literal notranslate"><span class="pre">/*</span></code>, then <code class="docutils literal notranslate"><span class="pre">namespaces</span></code> is not required.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Since <code class="docutils literal notranslate"><span class="pre">xpath</span></code> identifies the parent of content to be parsed, only immediate desendants which include child nodes or current attributes are parsed. Therefore, <code class="docutils literal notranslate"><span class="pre">read_xml</span></code> will not parse the text of grandchildren or other descendants and will not parse attributes of any descendant. To retrieve lower level content, adjust xpath to lower level. For example,</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [402]: xml = """
   .....: &lt;data&gt;
   .....:   &lt;row&gt;
   .....:     &lt;shape sides="4"&gt;square&lt;/shape&gt;
   .....:     &lt;degrees&gt;360&lt;/degrees&gt;
   .....:   &lt;/row&gt;
   .....:   &lt;row&gt;
   .....:     &lt;shape sides="0"&gt;circle&lt;/shape&gt;
   .....:     &lt;degrees&gt;360&lt;/degrees&gt;
   .....:   &lt;/row&gt;
   .....:   &lt;row&gt;
   .....:     &lt;shape sides="3"&gt;triangle&lt;/shape&gt;
   .....:     &lt;degrees&gt;180&lt;/degrees&gt;
   .....:   &lt;/row&gt;
   .....: &lt;/data&gt;"""
   .....: 

In [403]: df = pd.read_xml(StringIO(xml), xpath="./row")

In [404]: df
Out[404]: 
      shape  degrees
0    square      360
1    circle      360
2  triangle      180
</pre></div> </div> <p>shows the attribute <code class="docutils literal notranslate"><span class="pre">sides</span></code> on <code class="docutils literal notranslate"><span class="pre">shape</span></code> element was not parsed as expected since this attribute resides on the child of <code class="docutils literal notranslate"><span class="pre">row</span></code> element and not <code class="docutils literal notranslate"><span class="pre">row</span></code> element itself. In other words, <code class="docutils literal notranslate"><span class="pre">sides</span></code> attribute is a grandchild level descendant of <code class="docutils literal notranslate"><span class="pre">row</span></code> element. However, the <code class="docutils literal notranslate"><span class="pre">xpath</span></code> targets <code class="docutils literal notranslate"><span class="pre">row</span></code> element which covers only its children and attributes.</p> </div> <p>With <a class="reference external" href="https://lxml.de">lxml</a> as parser, you can flatten nested XML documents with an XSLT script which also can be string/file/URL types. As background, <a class="reference external" href="https://www.w3.org/TR/xslt/">XSLT</a> is a special-purpose language written in a special XML file that can transform original XML documents into other XML, HTML, even text (CSV, JSON, etc.) using an XSLT processor.</p> <p>For example, consider this somewhat nested structure of Chicago “L” Rides where station and rides elements encapsulate data in their own sections. With below XSLT, <code class="docutils literal notranslate"><span class="pre">lxml</span></code> can transform original nested document into a flatter output (as shown below for demonstration) for easier parse into <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [405]: xml = """&lt;?xml version='1.0' encoding='utf-8'?&gt;
   .....:  &lt;response&gt;
   .....:   &lt;row&gt;
   .....:     &lt;station id="40850" name="Library"/&gt;
   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:     &lt;rides&gt;
   .....:       &lt;avg_weekday_rides&gt;864.2&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;534&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;417.2&lt;/avg_sunday_holiday_rides&gt;
   .....:     &lt;/rides&gt;
   .....:   &lt;/row&gt;
   .....:   &lt;row&gt;
   .....:     &lt;station id="41700" name="Washington/Wabash"/&gt;
   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:     &lt;rides&gt;
   .....:       &lt;avg_weekday_rides&gt;2707.4&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;1909.8&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;1438.6&lt;/avg_sunday_holiday_rides&gt;
   .....:     &lt;/rides&gt;
   .....:   &lt;/row&gt;
   .....:   &lt;row&gt;
   .....:     &lt;station id="40380" name="Clark/Lake"/&gt;
   .....:     &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:     &lt;rides&gt;
   .....:       &lt;avg_weekday_rides&gt;2949.6&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;1657&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;1453.8&lt;/avg_sunday_holiday_rides&gt;
   .....:     &lt;/rides&gt;
   .....:   &lt;/row&gt;
   .....:  &lt;/response&gt;"""
   .....: 

In [406]: xsl = """&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
   .....:    &lt;xsl:output method="xml" omit-xml-declaration="no" indent="yes"/&gt;
   .....:    &lt;xsl:strip-space elements="*"/&gt;
   .....:    &lt;xsl:template match="/response"&gt;
   .....:       &lt;xsl:copy&gt;
   .....:         &lt;xsl:apply-templates select="row"/&gt;
   .....:       &lt;/xsl:copy&gt;
   .....:    &lt;/xsl:template&gt;
   .....:    &lt;xsl:template match="row"&gt;
   .....:       &lt;xsl:copy&gt;
   .....:         &lt;station_id&gt;&lt;xsl:value-of select="station/@id"/&gt;&lt;/station_id&gt;
   .....:         &lt;station_name&gt;&lt;xsl:value-of select="station/@name"/&gt;&lt;/station_name&gt;
   .....:         &lt;xsl:copy-of select="month|rides/*"/&gt;
   .....:       &lt;/xsl:copy&gt;
   .....:    &lt;/xsl:template&gt;
   .....:  &lt;/xsl:stylesheet&gt;"""
   .....: 

In [407]: output = """&lt;?xml version='1.0' encoding='utf-8'?&gt;
   .....:  &lt;response&gt;
   .....:    &lt;row&gt;
   .....:       &lt;station_id&gt;40850&lt;/station_id&gt;
   .....:       &lt;station_name&gt;Library&lt;/station_name&gt;
   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:       &lt;avg_weekday_rides&gt;864.2&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;534&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;417.2&lt;/avg_sunday_holiday_rides&gt;
   .....:    &lt;/row&gt;
   .....:    &lt;row&gt;
   .....:       &lt;station_id&gt;41700&lt;/station_id&gt;
   .....:       &lt;station_name&gt;Washington/Wabash&lt;/station_name&gt;
   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:       &lt;avg_weekday_rides&gt;2707.4&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;1909.8&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;1438.6&lt;/avg_sunday_holiday_rides&gt;
   .....:    &lt;/row&gt;
   .....:    &lt;row&gt;
   .....:       &lt;station_id&gt;40380&lt;/station_id&gt;
   .....:       &lt;station_name&gt;Clark/Lake&lt;/station_name&gt;
   .....:       &lt;month&gt;2020-09-01T00:00:00&lt;/month&gt;
   .....:       &lt;avg_weekday_rides&gt;2949.6&lt;/avg_weekday_rides&gt;
   .....:       &lt;avg_saturday_rides&gt;1657&lt;/avg_saturday_rides&gt;
   .....:       &lt;avg_sunday_holiday_rides&gt;1453.8&lt;/avg_sunday_holiday_rides&gt;
   .....:    &lt;/row&gt;
   .....:  &lt;/response&gt;"""
   .....: 

In [408]: df = pd.read_xml(StringIO(xml), stylesheet=xsl)

In [409]: df
Out[409]: 
   station_id       station_name  ... avg_saturday_rides  avg_sunday_holiday_rides
0       40850            Library  ...              534.0                     417.2
1       41700  Washington/Wabash  ...             1909.8                    1438.6
2       40380         Clark/Lake  ...             1657.0                    1453.8

[3 rows x 6 columns]
</pre></div> </div> <p>For very large XML files that can range in hundreds of megabytes to gigabytes, <a class="reference internal" href="../reference/api/pandas.read_xml.html#pandas.read_xml" title="pandas.read_xml"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_xml()</span></code></a> supports parsing such sizeable files using <a class="reference external" href="https://lxml.de/3.2/parsing.html#iterparse-and-iterwalk">lxml’s iterparse</a> and <a class="reference external" href="https://docs.python.org/3/library/xml.etree.elementtree.html#xml.etree.ElementTree.iterparse">etree’s iterparse</a> which are memory-efficient methods to iterate through an XML tree and extract specific elements and attributes. without holding entire tree in memory.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.5.0.</span></p> </div> <p>To use this feature, you must pass a physical XML file path into <code class="docutils literal notranslate"><span class="pre">read_xml</span></code> and use the <code class="docutils literal notranslate"><span class="pre">iterparse</span></code> argument. Files should not be compressed or point to online sources but stored on local disk. Also, <code class="docutils literal notranslate"><span class="pre">iterparse</span></code> should be a dictionary where the key is the repeating nodes in document (which become the rows) and the value is a list of any element or attribute that is a descendant (i.e., child, grandchild) of repeating node. Since XPath is not used in this method, descendants do not need to share same relationship with one another. Below shows example of reading in Wikipedia’s very large (12 GB+) latest article data dump.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: df = pd.read_xml(
...         "/path/to/downloaded/enwikisource-latest-pages-articles.xml",
...         iterparse = {"page": ["title", "ns", "id"]}
...     )
...     df
Out[2]:
                                                     title   ns        id
0                                       Gettysburg Address    0     21450
1                                                Main Page    0     42950
2                            Declaration by United Nations    0      8435
3             Constitution of the United States of America    0      8435
4                     Declaration of Independence (Israel)    0     17858
...                                                    ...  ...       ...
3578760               Page:Black cat 1897 07 v2 n10.pdf/17  104    219649
3578761               Page:Black cat 1897 07 v2 n10.pdf/43  104    219649
3578762               Page:Black cat 1897 07 v2 n10.pdf/44  104    219649
3578763      The History of Tom Jones, a Foundling/Book IX    0  12084291
3578764  Page:Shakespeare of Stratford (1926) Yale.djvu/91  104     21450

[3578765 rows x 3 columns]
</pre></div> </div> </section> <section id="writing-xml"> <h3>Writing XML</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.3.0.</span></p> </div> <p><code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> objects have an instance method <code class="docutils literal notranslate"><span class="pre">to_xml</span></code> which renders the contents of the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> as an XML document.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This method does not support special properties of XML including DTD, CData, XSD schemas, processing instructions, comments, and others. Only namespaces at the root level is supported. However, <code class="docutils literal notranslate"><span class="pre">stylesheet</span></code> allows design changes after initial output.</p> </div> <p>Let’s look at a few examples.</p> <p>Write an XML without options:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [410]: geom_df = pd.DataFrame(
   .....:     {
   .....:         "shape": ["square", "circle", "triangle"],
   .....:         "degrees": [360, 360, 180],
   .....:         "sides": [4, np.nan, 3],
   .....:     }
   .....: )
   .....: 

In [411]: print(geom_df.to_xml())
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data&gt;
  &lt;row&gt;
    &lt;index&gt;0&lt;/index&gt;
    &lt;shape&gt;square&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides&gt;4.0&lt;/sides&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;index&gt;1&lt;/index&gt;
    &lt;shape&gt;circle&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides/&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;index&gt;2&lt;/index&gt;
    &lt;shape&gt;triangle&lt;/shape&gt;
    &lt;degrees&gt;180&lt;/degrees&gt;
    &lt;sides&gt;3.0&lt;/sides&gt;
  &lt;/row&gt;
&lt;/data&gt;
</pre></div> </div> <p>Write an XML with new root and row name:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [412]: print(geom_df.to_xml(root_name="geometry", row_name="objects"))
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;geometry&gt;
  &lt;objects&gt;
    &lt;index&gt;0&lt;/index&gt;
    &lt;shape&gt;square&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides&gt;4.0&lt;/sides&gt;
  &lt;/objects&gt;
  &lt;objects&gt;
    &lt;index&gt;1&lt;/index&gt;
    &lt;shape&gt;circle&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides/&gt;
  &lt;/objects&gt;
  &lt;objects&gt;
    &lt;index&gt;2&lt;/index&gt;
    &lt;shape&gt;triangle&lt;/shape&gt;
    &lt;degrees&gt;180&lt;/degrees&gt;
    &lt;sides&gt;3.0&lt;/sides&gt;
  &lt;/objects&gt;
&lt;/geometry&gt;
</pre></div> </div> <p>Write an attribute-centric XML:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [413]: print(geom_df.to_xml(attr_cols=geom_df.columns.tolist()))
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data&gt;
  &lt;row index="0" shape="square" degrees="360" sides="4.0"/&gt;
  &lt;row index="1" shape="circle" degrees="360"/&gt;
  &lt;row index="2" shape="triangle" degrees="180" sides="3.0"/&gt;
&lt;/data&gt;
</pre></div> </div> <p>Write a mix of elements and attributes:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [414]: print(
   .....:     geom_df.to_xml(
   .....:         index=False,
   .....:         attr_cols=['shape'],
   .....:         elem_cols=['degrees', 'sides'])
   .....: )
   .....: 
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data&gt;
  &lt;row shape="square"&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides&gt;4.0&lt;/sides&gt;
  &lt;/row&gt;
  &lt;row shape="circle"&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides/&gt;
  &lt;/row&gt;
  &lt;row shape="triangle"&gt;
    &lt;degrees&gt;180&lt;/degrees&gt;
    &lt;sides&gt;3.0&lt;/sides&gt;
  &lt;/row&gt;
&lt;/data&gt;
</pre></div> </div> <p>Any <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> with hierarchical columns will be flattened for XML element names with levels delimited by underscores:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [415]: ext_geom_df = pd.DataFrame(
   .....:     {
   .....:         "type": ["polygon", "other", "polygon"],
   .....:         "shape": ["square", "circle", "triangle"],
   .....:         "degrees": [360, 360, 180],
   .....:         "sides": [4, np.nan, 3],
   .....:     }
   .....: )
   .....: 

In [416]: pvt_df = ext_geom_df.pivot_table(index='shape',
   .....:                                  columns='type',
   .....:                                  values=['degrees', 'sides'],
   .....:                                  aggfunc='sum')
   .....: 

In [417]: pvt_df
Out[417]: 
         degrees         sides        
type       other polygon other polygon
shape                                 
circle     360.0     NaN   0.0     NaN
square       NaN   360.0   NaN     4.0
triangle     NaN   180.0   NaN     3.0

In [418]: print(pvt_df.to_xml())
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data&gt;
  &lt;row&gt;
    &lt;shape&gt;circle&lt;/shape&gt;
    &lt;degrees_other&gt;360.0&lt;/degrees_other&gt;
    &lt;degrees_polygon/&gt;
    &lt;sides_other&gt;0.0&lt;/sides_other&gt;
    &lt;sides_polygon/&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;shape&gt;square&lt;/shape&gt;
    &lt;degrees_other/&gt;
    &lt;degrees_polygon&gt;360.0&lt;/degrees_polygon&gt;
    &lt;sides_other/&gt;
    &lt;sides_polygon&gt;4.0&lt;/sides_polygon&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;shape&gt;triangle&lt;/shape&gt;
    &lt;degrees_other/&gt;
    &lt;degrees_polygon&gt;180.0&lt;/degrees_polygon&gt;
    &lt;sides_other/&gt;
    &lt;sides_polygon&gt;3.0&lt;/sides_polygon&gt;
  &lt;/row&gt;
&lt;/data&gt;
</pre></div> </div> <p>Write an XML with default namespace:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [419]: print(geom_df.to_xml(namespaces={"": "https://example.com"}))
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;data xmlns="https://example.com"&gt;
  &lt;row&gt;
    &lt;index&gt;0&lt;/index&gt;
    &lt;shape&gt;square&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides&gt;4.0&lt;/sides&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;index&gt;1&lt;/index&gt;
    &lt;shape&gt;circle&lt;/shape&gt;
    &lt;degrees&gt;360&lt;/degrees&gt;
    &lt;sides/&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;index&gt;2&lt;/index&gt;
    &lt;shape&gt;triangle&lt;/shape&gt;
    &lt;degrees&gt;180&lt;/degrees&gt;
    &lt;sides&gt;3.0&lt;/sides&gt;
  &lt;/row&gt;
&lt;/data&gt;
</pre></div> </div> <p>Write an XML with namespace prefix:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [420]: print(
   .....:     geom_df.to_xml(namespaces={"doc": "https://example.com"},
   .....:                    prefix="doc")
   .....: )
   .....: 
&lt;?xml version='1.0' encoding='utf-8'?&gt;
&lt;doc:data xmlns:doc="https://example.com"&gt;
  &lt;doc:row&gt;
    &lt;doc:index&gt;0&lt;/doc:index&gt;
    &lt;doc:shape&gt;square&lt;/doc:shape&gt;
    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
    &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;
  &lt;/doc:row&gt;
  &lt;doc:row&gt;
    &lt;doc:index&gt;1&lt;/doc:index&gt;
    &lt;doc:shape&gt;circle&lt;/doc:shape&gt;
    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;
    &lt;doc:sides/&gt;
  &lt;/doc:row&gt;
  &lt;doc:row&gt;
    &lt;doc:index&gt;2&lt;/doc:index&gt;
    &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;
    &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;
    &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;
  &lt;/doc:row&gt;
&lt;/doc:data&gt;
</pre></div> </div> <p>Write an XML without declaration or pretty print:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [421]: print(
   .....:     geom_df.to_xml(xml_declaration=False,
   .....:                    pretty_print=False)
   .....: )
   .....: 
&lt;data&gt;&lt;row&gt;&lt;index&gt;0&lt;/index&gt;&lt;shape&gt;square&lt;/shape&gt;&lt;degrees&gt;360&lt;/degrees&gt;&lt;sides&gt;4.0&lt;/sides&gt;&lt;/row&gt;&lt;row&gt;&lt;index&gt;1&lt;/index&gt;&lt;shape&gt;circle&lt;/shape&gt;&lt;degrees&gt;360&lt;/degrees&gt;&lt;sides/&gt;&lt;/row&gt;&lt;row&gt;&lt;index&gt;2&lt;/index&gt;&lt;shape&gt;triangle&lt;/shape&gt;&lt;degrees&gt;180&lt;/degrees&gt;&lt;sides&gt;3.0&lt;/sides&gt;&lt;/row&gt;&lt;/data&gt;
</pre></div> </div> <p>Write an XML and transform with stylesheet:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [422]: xsl = """&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
   .....:    &lt;xsl:output method="xml" omit-xml-declaration="no" indent="yes"/&gt;
   .....:    &lt;xsl:strip-space elements="*"/&gt;
   .....:    &lt;xsl:template match="/data"&gt;
   .....:      &lt;geometry&gt;
   .....:        &lt;xsl:apply-templates select="row"/&gt;
   .....:      &lt;/geometry&gt;
   .....:    &lt;/xsl:template&gt;
   .....:    &lt;xsl:template match="row"&gt;
   .....:      &lt;object index="{index}"&gt;
   .....:        &lt;xsl:if test="shape!='circle'"&gt;
   .....:            &lt;xsl:attribute name="type"&gt;polygon&lt;/xsl:attribute&gt;
   .....:        &lt;/xsl:if&gt;
   .....:        &lt;xsl:copy-of select="shape"/&gt;
   .....:        &lt;property&gt;
   .....:            &lt;xsl:copy-of select="degrees|sides"/&gt;
   .....:        &lt;/property&gt;
   .....:      &lt;/object&gt;
   .....:    &lt;/xsl:template&gt;
   .....:  &lt;/xsl:stylesheet&gt;"""
   .....: 

In [423]: print(geom_df.to_xml(stylesheet=xsl))
&lt;?xml version="1.0"?&gt;
&lt;geometry&gt;
  &lt;object index="0" type="polygon"&gt;
    &lt;shape&gt;square&lt;/shape&gt;
    &lt;property&gt;
      &lt;degrees&gt;360&lt;/degrees&gt;
      &lt;sides&gt;4.0&lt;/sides&gt;
    &lt;/property&gt;
  &lt;/object&gt;
  &lt;object index="1"&gt;
    &lt;shape&gt;circle&lt;/shape&gt;
    &lt;property&gt;
      &lt;degrees&gt;360&lt;/degrees&gt;
      &lt;sides/&gt;
    &lt;/property&gt;
  &lt;/object&gt;
  &lt;object index="2" type="polygon"&gt;
    &lt;shape&gt;triangle&lt;/shape&gt;
    &lt;property&gt;
      &lt;degrees&gt;180&lt;/degrees&gt;
      &lt;sides&gt;3.0&lt;/sides&gt;
    &lt;/property&gt;
  &lt;/object&gt;
&lt;/geometry&gt;
</pre></div> </div> </section> <section id="xml-final-notes"> <h3>XML Final Notes</h3> <ul class="simple"> <li><p>All XML documents adhere to <a class="reference external" href="https://www.w3.org/TR/xml/">W3C specifications</a>. Both <code class="docutils literal notranslate"><span class="pre">etree</span></code> and <code class="docutils literal notranslate"><span class="pre">lxml</span></code> parsers will fail to parse any markup document that is not well-formed or follows XML syntax rules. Do be aware HTML is not an XML document unless it follows XHTML specs. However, other popular markup types including KML, XAML, RSS, MusicML, MathML are compliant <a class="reference external" href="https://en.wikipedia.org/wiki/List_of_types_of_XML_schemas">XML schemas</a>.</p></li> <li><p>For above reason, if your application builds XML prior to pandas operations, use appropriate DOM libraries like <code class="docutils literal notranslate"><span class="pre">etree</span></code> and <code class="docutils literal notranslate"><span class="pre">lxml</span></code> to build the necessary document and not by string concatenation or regex adjustments. Always remember XML is a <em>special</em> text file with markup rules.</p></li> <li><p>With very large XML files (several hundred MBs to GBs), XPath and XSLT can become memory-intensive operations. Be sure to have enough available RAM for reading and writing to large XML files (roughly about 5 times the size of text).</p></li> <li><p>Because XSLT is a programming language, use it with caution since such scripts can pose a security risk in your environment and can run large or infinite recursive operations. Always test scripts on small fragments before full run.</p></li> <li><p>The <a class="reference external" href="https://docs.python.org/3/library/xml.etree.elementtree.html">etree</a> parser supports all functionality of both <code class="docutils literal notranslate"><span class="pre">read_xml</span></code> and <code class="docutils literal notranslate"><span class="pre">to_xml</span></code> except for complex XPath and any XSLT. Though limited in features, <code class="docutils literal notranslate"><span class="pre">etree</span></code> is still a reliable and capable parser and tree builder. Its performance may trail <code class="docutils literal notranslate"><span class="pre">lxml</span></code> to a certain degree for larger files but relatively unnoticeable on small to medium size files.</p></li> </ul> </section> </section> <section id="excel-files"> <h2>Excel files</h2> <p>The <a class="reference internal" href="../reference/api/pandas.read_excel.html#pandas.read_excel" title="pandas.read_excel"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_excel()</span></code></a> method can read Excel 2007+ (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>) files using the <code class="docutils literal notranslate"><span class="pre">openpyxl</span></code> Python module. Excel 2003 (<code class="docutils literal notranslate"><span class="pre">.xls</span></code>) files can be read using <code class="docutils literal notranslate"><span class="pre">xlrd</span></code>. Binary Excel (<code class="docutils literal notranslate"><span class="pre">.xlsb</span></code>) files can be read using <code class="docutils literal notranslate"><span class="pre">pyxlsb</span></code>. All formats can be read using <a class="reference internal" href="#io-calamine"><span class="std std-ref">calamine</span></a> engine. The <a class="reference internal" href="../reference/api/pandas.dataframe.to_excel.html#pandas.DataFrame.to_excel" title="pandas.DataFrame.to_excel"><code class="xref py py-meth docutils literal notranslate"><span class="pre">to_excel()</span></code></a> instance method is used for saving a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to Excel. Generally the semantics are similar to working with <a class="reference internal" href="#io-read-csv-table"><span class="std std-ref">csv</span></a> data. See the <a class="reference internal" href="cookbook.html#cookbook-excel"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When <code class="docutils literal notranslate"><span class="pre">engine=None</span></code>, the following logic will be used to determine the engine:</p> <ul class="simple"> <li><p>If <code class="docutils literal notranslate"><span class="pre">path_or_buffer</span></code> is an OpenDocument format (.odf, .ods, .odt), then <a class="reference external" href="https://pypi.org/project/odfpy/">odf</a> will be used.</p></li> <li><p>Otherwise if <code class="docutils literal notranslate"><span class="pre">path_or_buffer</span></code> is an xls format, <code class="docutils literal notranslate"><span class="pre">xlrd</span></code> will be used.</p></li> <li><p>Otherwise if <code class="docutils literal notranslate"><span class="pre">path_or_buffer</span></code> is in xlsb format, <code class="docutils literal notranslate"><span class="pre">pyxlsb</span></code> will be used.</p></li> <li><p>Otherwise <code class="docutils literal notranslate"><span class="pre">openpyxl</span></code> will be used.</p></li> </ul> </div> <section id="reading-excel-files"> <h3>Reading Excel files</h3> <p>In the most basic use-case, <code class="docutils literal notranslate"><span class="pre">read_excel</span></code> takes a path to an Excel file, and the <code class="docutils literal notranslate"><span class="pre">sheet_name</span></code> indicating which sheet to parse.</p> <p>When using the <code class="docutils literal notranslate"><span class="pre">engine_kwargs</span></code> parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.</p> <ul class="simple"> <li><p>For the engine openpyxl, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">openpyxl.load_workbook()</span></code> to read in (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>) and (<code class="docutils literal notranslate"><span class="pre">.xlsm</span></code>) files.</p></li> <li><p>For the engine xlrd, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">xlrd.open_workbook()</span></code> to read in (<code class="docutils literal notranslate"><span class="pre">.xls</span></code>) files.</p></li> <li><p>For the engine pyxlsb, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">pyxlsb.open_workbook()</span></code> to read in (<code class="docutils literal notranslate"><span class="pre">.xlsb</span></code>) files.</p></li> <li><p>For the engine odf, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">odf.opendocument.load()</span></code> to read in (<code class="docutils literal notranslate"><span class="pre">.ods</span></code>) files.</p></li> <li><p>For the engine calamine, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">python_calamine.load_workbook()</span></code> to read in (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>), (<code class="docutils literal notranslate"><span class="pre">.xlsm</span></code>), (<code class="docutils literal notranslate"><span class="pre">.xls</span></code>), (<code class="docutils literal notranslate"><span class="pre">.xlsb</span></code>), (<code class="docutils literal notranslate"><span class="pre">.ods</span></code>) files.</p></li> </ul> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xls", sheet_name="Sheet1")
</pre></div> </div> <section id="excelfile-class"> <h4>
<code class="docutils literal notranslate"><span class="pre">ExcelFile</span></code> class</h4> <p>To facilitate working with multiple sheets from the same file, the <code class="docutils literal notranslate"><span class="pre">ExcelFile</span></code> class can be used to wrap the file and can be passed into <code class="docutils literal notranslate"><span class="pre">read_excel</span></code> There will be a performance benefit for reading multiple sheets as the file is read into memory only once.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">xlsx = pd.ExcelFile("path_to_file.xls")
df = pd.read_excel(xlsx, "Sheet1")
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">ExcelFile</span></code> class can also be used as a context manager.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">with pd.ExcelFile("path_to_file.xls") as xls:
    df1 = pd.read_excel(xls, "Sheet1")
    df2 = pd.read_excel(xls, "Sheet2")
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">sheet_names</span></code> property will generate a list of the sheet names in the file.</p> <p>The primary use-case for an <code class="docutils literal notranslate"><span class="pre">ExcelFile</span></code> is parsing multiple sheets with different parameters:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">data = {}
# For when Sheet1's format differs from Sheet2
with pd.ExcelFile("path_to_file.xls") as xls:
    data["Sheet1"] = pd.read_excel(xls, "Sheet1", index_col=None, na_values=["NA"])
    data["Sheet2"] = pd.read_excel(xls, "Sheet2", index_col=1)
</pre></div> </div> <p>Note that if the same parsing parameters are used for all sheets, a list of sheet names can simply be passed to <code class="docutils literal notranslate"><span class="pre">read_excel</span></code> with no loss in performance.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># using the ExcelFile class
data = {}
with pd.ExcelFile("path_to_file.xls") as xls:
    data["Sheet1"] = pd.read_excel(xls, "Sheet1", index_col=None, na_values=["NA"])
    data["Sheet2"] = pd.read_excel(xls, "Sheet2", index_col=None, na_values=["NA"])

# equivalent using the read_excel function
data = pd.read_excel(
    "path_to_file.xls", ["Sheet1", "Sheet2"], index_col=None, na_values=["NA"]
)
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">ExcelFile</span></code> can also be called with a <code class="docutils literal notranslate"><span class="pre">xlrd.book.Book</span></code> object as a parameter. This allows the user to control how the excel file is read. For example, sheets can be loaded on demand by calling <code class="docutils literal notranslate"><span class="pre">xlrd.open_workbook()</span></code> with <code class="docutils literal notranslate"><span class="pre">on_demand=True</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">import xlrd

xlrd_book = xlrd.open_workbook("path_to_file.xls", on_demand=True)
with pd.ExcelFile(xlrd_book) as xls:
    df1 = pd.read_excel(xls, "Sheet1")
    df2 = pd.read_excel(xls, "Sheet2")
</pre></div> </div> </section> <section id="specifying-sheets"> <h4>Specifying sheets</h4> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The second argument is <code class="docutils literal notranslate"><span class="pre">sheet_name</span></code>, not to be confused with <code class="docutils literal notranslate"><span class="pre">ExcelFile.sheet_names</span></code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>An ExcelFile’s attribute <code class="docutils literal notranslate"><span class="pre">sheet_names</span></code> provides access to a list of sheets.</p> </div> <ul class="simple"> <li><p>The arguments <code class="docutils literal notranslate"><span class="pre">sheet_name</span></code> allows specifying the sheet or sheets to read.</p></li> <li><p>The default value for <code class="docutils literal notranslate"><span class="pre">sheet_name</span></code> is 0, indicating to read the first sheet</p></li> <li><p>Pass a string to refer to the name of a particular sheet in the workbook.</p></li> <li><p>Pass an integer to refer to the index of a sheet. Indices follow Python convention, beginning at 0.</p></li> <li><p>Pass a list of either strings or integers, to return a dictionary of specified sheets.</p></li> <li><p>Pass a <code class="docutils literal notranslate"><span class="pre">None</span></code> to return a dictionary of all available sheets.</p></li> </ul> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xls", "Sheet1", index_col=None, na_values=["NA"])
</pre></div> </div> <p>Using the sheet index:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xls", 0, index_col=None, na_values=["NA"])
</pre></div> </div> <p>Using all default values:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xls")
</pre></div> </div> <p>Using None to get all sheets:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a dictionary of DataFrames
pd.read_excel("path_to_file.xls", sheet_name=None)
</pre></div> </div> <p>Using a list to get multiple sheets:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns the 1st and 4th sheet, as a dictionary of DataFrames.
pd.read_excel("path_to_file.xls", sheet_name=["Sheet1", 3])
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">read_excel</span></code> can read more than one sheet, by setting <code class="docutils literal notranslate"><span class="pre">sheet_name</span></code> to either a list of sheet names, a list of sheet positions, or <code class="docutils literal notranslate"><span class="pre">None</span></code> to read all sheets. Sheets can be specified by sheet index or sheet name, using an integer or string, respectively.</p> </section> <section id="reading-a-multiindex"> <h4>Reading a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>
</h4> <p><code class="docutils literal notranslate"><span class="pre">read_excel</span></code> can read a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> index, by passing a list of columns to <code class="docutils literal notranslate"><span class="pre">index_col</span></code> and a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> column by passing a list of rows to <code class="docutils literal notranslate"><span class="pre">header</span></code>. If either the <code class="docutils literal notranslate"><span class="pre">index</span></code> or <code class="docutils literal notranslate"><span class="pre">columns</span></code> have serialized level names those will be read in as well by specifying the rows/columns that make up the levels.</p> <p>For example, to read in a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> index without names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [424]: df = pd.DataFrame(
   .....:     {"a": [1, 2, 3, 4], "b": [5, 6, 7, 8]},
   .....:     index=pd.MultiIndex.from_product([["a", "b"], ["c", "d"]]),
   .....: )
   .....: 

In [425]: df.to_excel("path_to_file.xlsx")

In [426]: df = pd.read_excel("path_to_file.xlsx", index_col=[0, 1])

In [427]: df
Out[427]: 
     a  b
a c  1  5
  d  2  6
b c  3  7
  d  4  8
</pre></div> </div> <p>If the index has level names, they will parsed as well, using the same parameters.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [428]: df.index = df.index.set_names(["lvl1", "lvl2"])

In [429]: df.to_excel("path_to_file.xlsx")

In [430]: df = pd.read_excel("path_to_file.xlsx", index_col=[0, 1])

In [431]: df
Out[431]: 
           a  b
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8
</pre></div> </div> <p>If the source file has both <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> index and columns, lists specifying each should be passed to <code class="docutils literal notranslate"><span class="pre">index_col</span></code> and <code class="docutils literal notranslate"><span class="pre">header</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [432]: df.columns = pd.MultiIndex.from_product([["a"], ["b", "d"]], names=["c1", "c2"])

In [433]: df.to_excel("path_to_file.xlsx")

In [434]: df = pd.read_excel("path_to_file.xlsx", index_col=[0, 1], header=[0, 1])

In [435]: df
Out[435]: 
c1         a   
c2         b  d
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8
</pre></div> </div> <p>Missing values in columns specified in <code class="docutils literal notranslate"><span class="pre">index_col</span></code> will be forward filled to allow roundtripping with <code class="docutils literal notranslate"><span class="pre">to_excel</span></code> for <code class="docutils literal notranslate"><span class="pre">merged_cells=True</span></code>. To avoid forward filling the missing values use <code class="docutils literal notranslate"><span class="pre">set_index</span></code> after reading the data instead of <code class="docutils literal notranslate"><span class="pre">index_col</span></code>.</p> </section> <section id="parsing-specific-columns"> <h4>Parsing specific columns</h4> <p>It is often the case that users will insert columns to do temporary computations in Excel and you may not want to read in those columns. <code class="docutils literal notranslate"><span class="pre">read_excel</span></code> takes a <code class="docutils literal notranslate"><span class="pre">usecols</span></code> keyword to allow you to specify a subset of columns to parse.</p> <p>You can specify a comma-delimited set of Excel columns and ranges as a string:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", usecols="A,C:E")
</pre></div> </div> <p>If <code class="docutils literal notranslate"><span class="pre">usecols</span></code> is a list of integers, then it is assumed to be the file column indices to be parsed.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", usecols=[0, 2, 3])
</pre></div> </div> <p>Element order is ignored, so <code class="docutils literal notranslate"><span class="pre">usecols=[0,</span> <span class="pre">1]</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0]</span></code>.</p> <p>If <code class="docutils literal notranslate"><span class="pre">usecols</span></code> is a list of strings, it is assumed that each string corresponds to a column name provided either by the user in <code class="docutils literal notranslate"><span class="pre">names</span></code> or inferred from the document header row(s). Those strings define which columns will be parsed:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", usecols=["foo", "bar"])
</pre></div> </div> <p>Element order is ignored, so <code class="docutils literal notranslate"><span class="pre">usecols=['baz',</span> <span class="pre">'joe']</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">['joe',</span> <span class="pre">'baz']</span></code>.</p> <p>If <code class="docutils literal notranslate"><span class="pre">usecols</span></code> is callable, the callable function will be evaluated against the column names, returning names where the callable function evaluates to <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", usecols=lambda x: x.isalpha())
</pre></div> </div> </section> <section id="parsing-dates"> <h4>Parsing dates</h4> <p>Datetime-like values are normally automatically converted to the appropriate dtype when reading the excel file. But if you have a column of strings that <em>look</em> like dates (but are not actually formatted as dates in excel), you can use the <code class="docutils literal notranslate"><span class="pre">parse_dates</span></code> keyword to parse those strings to datetimes:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", parse_dates=["date_strings"])
</pre></div> </div> </section> <section id="cell-converters"> <h4>Cell converters</h4> <p>It is possible to transform the contents of Excel cells via the <code class="docutils literal notranslate"><span class="pre">converters</span></code> option. For instance, to convert a column to boolean:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", "Sheet1", converters={"MyBools": bool})
</pre></div> </div> <p>This options handles missing values and treats exceptions in the converters as missing data. Transformations are applied cell by cell rather than to the column as a whole, so the array dtype is not guaranteed. For instance, a column of integers with missing values cannot be transformed to an array with integer dtype, because NaN is strictly a float. You can manually mask missing data to recover integer dtype:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">def cfun(x):
    return int(x) if x else -1


pd.read_excel("path_to_file.xls", "Sheet1", converters={"MyInts": cfun})
</pre></div> </div> </section> <section id="dtype-specifications"> <h4>Dtype specifications</h4> <p>As an alternative to converters, the type for an entire column can be specified using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> keyword, which takes a dictionary mapping column names to types. To interpret data with no type inference, use the type <code class="docutils literal notranslate"><span class="pre">str</span></code> or <code class="docutils literal notranslate"><span class="pre">object</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_excel("path_to_file.xls", dtype={"MyInts": "int64", "MyText": str})
</pre></div> </div> </section> </section> <section id="writing-excel-files"> <h3>Writing Excel files</h3> <section id="writing-excel-files-to-disk"> <h4>Writing Excel files to disk</h4> <p>To write a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object to a sheet of an Excel file, you can use the <code class="docutils literal notranslate"><span class="pre">to_excel</span></code> instance method. The arguments are largely the same as <code class="docutils literal notranslate"><span class="pre">to_csv</span></code> described above, the first argument being the name of the excel file, and the optional second argument the name of the sheet to which the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> should be written. For example:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.to_excel("path_to_file.xlsx", sheet_name="Sheet1")
</pre></div> </div> <p>Files with a <code class="docutils literal notranslate"><span class="pre">.xlsx</span></code> extension will be written using <code class="docutils literal notranslate"><span class="pre">xlsxwriter</span></code> (if available) or <code class="docutils literal notranslate"><span class="pre">openpyxl</span></code>.</p> <p>The <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> will be written in a way that tries to mimic the REPL output. The <code class="docutils literal notranslate"><span class="pre">index_label</span></code> will be placed in the second row instead of the first. You can place it in the first row by setting the <code class="docutils literal notranslate"><span class="pre">merge_cells</span></code> option in <code class="docutils literal notranslate"><span class="pre">to_excel()</span></code> to <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.to_excel("path_to_file.xlsx", index_label="label", merge_cells=False)
</pre></div> </div> <p>In order to write separate <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> to separate sheets in a single Excel file, one can pass an <code class="xref py py-class docutils literal notranslate"><span class="pre">ExcelWriter</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">with pd.ExcelWriter("path_to_file.xlsx") as writer:
    df1.to_excel(writer, sheet_name="Sheet1")
    df2.to_excel(writer, sheet_name="Sheet2")
</pre></div> </div> <p id="io-excel-writing-buffer">When using the <code class="docutils literal notranslate"><span class="pre">engine_kwargs</span></code> parameter, pandas will pass these arguments to the engine. For this, it is important to know which function pandas is using internally.</p> <ul class="simple"> <li><p>For the engine openpyxl, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">openpyxl.Workbook()</span></code> to create a new sheet and <code class="xref py py-func docutils literal notranslate"><span class="pre">openpyxl.load_workbook()</span></code> to append data to an existing sheet. The openpyxl engine writes to (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>) and (<code class="docutils literal notranslate"><span class="pre">.xlsm</span></code>) files.</p></li> <li><p>For the engine xlsxwriter, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">xlsxwriter.Workbook()</span></code> to write to (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>) files.</p></li> <li><p>For the engine odf, pandas is using <code class="xref py py-func docutils literal notranslate"><span class="pre">odf.opendocument.OpenDocumentSpreadsheet()</span></code> to write to (<code class="docutils literal notranslate"><span class="pre">.ods</span></code>) files.</p></li> </ul> </section> <section id="writing-excel-files-to-memory"> <h4>Writing Excel files to memory</h4> <p>pandas supports writing Excel files to buffer-like objects such as <code class="docutils literal notranslate"><span class="pre">StringIO</span></code> or <code class="docutils literal notranslate"><span class="pre">BytesIO</span></code> using <code class="xref py py-class docutils literal notranslate"><span class="pre">ExcelWriter</span></code>.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">from io import BytesIO

bio = BytesIO()

# By setting the 'engine' in the ExcelWriter constructor.
writer = pd.ExcelWriter(bio, engine="xlsxwriter")
df.to_excel(writer, sheet_name="Sheet1")

# Save the workbook
writer.save()

# Seek to the beginning and read to copy the workbook to a variable in memory
bio.seek(0)
workbook = bio.read()
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">engine</span></code> is optional but recommended. Setting the engine determines the version of workbook produced. Setting <code class="docutils literal notranslate"><span class="pre">engine='xlrd'</span></code> will produce an Excel 2003-format workbook (xls). Using either <code class="docutils literal notranslate"><span class="pre">'openpyxl'</span></code> or <code class="docutils literal notranslate"><span class="pre">'xlsxwriter'</span></code> will produce an Excel 2007-format workbook (xlsx). If omitted, an Excel 2007-formatted workbook is produced.</p> </div> </section> </section> <section id="excel-writer-engines"> <h3>Excel writer engines</h3> <p>pandas chooses an Excel writer via two methods:</p> <ol class="arabic simple"> <li><p>the <code class="docutils literal notranslate"><span class="pre">engine</span></code> keyword argument</p></li> <li><p>the filename extension (via the default specified in config options)</p></li> </ol> <p>By default, pandas uses the <a class="reference external" href="https://xlsxwriter.readthedocs.io">XlsxWriter</a> for <code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>, <a class="reference external" href="https://openpyxl.readthedocs.io/">openpyxl</a> for <code class="docutils literal notranslate"><span class="pre">.xlsm</span></code>. If you have multiple engines installed, you can set the default engine through <a class="reference internal" href="options.html#options"><span class="std std-ref">setting the config options</span></a> <code class="docutils literal notranslate"><span class="pre">io.excel.xlsx.writer</span></code> and <code class="docutils literal notranslate"><span class="pre">io.excel.xls.writer</span></code>. pandas will fall back on <a class="reference external" href="https://openpyxl.readthedocs.io/">openpyxl</a> for <code class="docutils literal notranslate"><span class="pre">.xlsx</span></code> files if <a class="reference external" href="https://xlsxwriter.readthedocs.io">Xlsxwriter</a> is not available.</p> <p>To specify which writer you want to use, you can pass an engine keyword argument to <code class="docutils literal notranslate"><span class="pre">to_excel</span></code> and to <code class="docutils literal notranslate"><span class="pre">ExcelWriter</span></code>. The built-in engines are:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">openpyxl</span></code>: version 2.4 or higher is required</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">xlsxwriter</span></code></p></li> </ul> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># By setting the 'engine' in the DataFrame 'to_excel()' methods.
df.to_excel("path_to_file.xlsx", sheet_name="Sheet1", engine="xlsxwriter")

# By setting the 'engine' in the ExcelWriter constructor.
writer = pd.ExcelWriter("path_to_file.xlsx", engine="xlsxwriter")

# Or via pandas configuration.
from pandas import options  # noqa: E402

options.io.excel.xlsx.writer = "xlsxwriter"

df.to_excel("path_to_file.xlsx", sheet_name="Sheet1")
</pre></div> </div> </section> <section id="style-and-formatting"> <h3>Style and formatting</h3> <p>The look and feel of Excel worksheets created from pandas can be modified using the following parameters on the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>’s <code class="docutils literal notranslate"><span class="pre">to_excel</span></code> method.</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">float_format</span></code> : Format string for floating point numbers (default <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">freeze_panes</span></code> : A tuple of two integers representing the bottommost row and rightmost column to freeze. Each of these parameters is one-based, so (1, 1) will freeze the first row and first column (default <code class="docutils literal notranslate"><span class="pre">None</span></code>).</p></li> </ul> <p>Using the <a class="reference external" href="https://xlsxwriter.readthedocs.io">Xlsxwriter</a> engine provides many options for controlling the format of an Excel worksheet created with the <code class="docutils literal notranslate"><span class="pre">to_excel</span></code> method. Excellent examples can be found in the <a class="reference external" href="https://xlsxwriter.readthedocs.io">Xlsxwriter</a> documentation here: <a class="reference external" href="https://xlsxwriter.readthedocs.io/working_with_pandas.html">https://xlsxwriter.readthedocs.io/working_with_pandas.html</a></p> </section> </section> <section id="opendocument-spreadsheets"> <h2>OpenDocument Spreadsheets</h2> <p>The io methods for <a class="reference internal" href="#excel-files">Excel files</a> also support reading and writing OpenDocument spreadsheets using the <a class="reference external" href="https://pypi.org/project/odfpy/">odfpy</a> module. The semantics and features for reading and writing OpenDocument spreadsheets match what can be done for <a class="reference internal" href="#excel-files">Excel files</a> using <code class="docutils literal notranslate"><span class="pre">engine='odf'</span></code>. The optional dependency ‘odfpy’ needs to be installed.</p> <p>The <a class="reference internal" href="../reference/api/pandas.read_excel.html#pandas.read_excel" title="pandas.read_excel"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_excel()</span></code></a> method can read OpenDocument spreadsheets</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.ods", engine="odf")
</pre></div> </div> <p>Similarly, the <code class="xref py py-func docutils literal notranslate"><span class="pre">to_excel()</span></code> method can write OpenDocument spreadsheets</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Writes DataFrame to a .ods file
df.to_excel("path_to_file.ods", engine="odf")
</pre></div> </div> </section> <section id="binary-excel-xlsb-files"> <h2>Binary Excel (.xlsb) files</h2> <p>The <a class="reference internal" href="../reference/api/pandas.read_excel.html#pandas.read_excel" title="pandas.read_excel"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_excel()</span></code></a> method can also read binary Excel files using the <code class="docutils literal notranslate"><span class="pre">pyxlsb</span></code> module. The semantics and features for reading binary Excel files mostly match what can be done for <a class="reference internal" href="#excel-files">Excel files</a> using <code class="docutils literal notranslate"><span class="pre">engine='pyxlsb'</span></code>. <code class="docutils literal notranslate"><span class="pre">pyxlsb</span></code> does not recognize datetime types in files and will return floats instead (you can use <a class="reference internal" href="#io-calamine"><span class="std std-ref">calamine</span></a> if you need recognize datetime types).</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xlsb", engine="pyxlsb")
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Currently pandas only supports <em>reading</em> binary Excel files. Writing is not implemented.</p> </div> </section> <section id="calamine-excel-and-ods-files"> <h2>Calamine (Excel and ODS files)</h2> <p>The <a class="reference internal" href="../reference/api/pandas.read_excel.html#pandas.read_excel" title="pandas.read_excel"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_excel()</span></code></a> method can read Excel file (<code class="docutils literal notranslate"><span class="pre">.xlsx</span></code>, <code class="docutils literal notranslate"><span class="pre">.xlsm</span></code>, <code class="docutils literal notranslate"><span class="pre">.xls</span></code>, <code class="docutils literal notranslate"><span class="pre">.xlsb</span></code>) and OpenDocument spreadsheets (<code class="docutils literal notranslate"><span class="pre">.ods</span></code>) using the <code class="docutils literal notranslate"><span class="pre">python-calamine</span></code> module. This module is a binding for Rust library <a class="reference external" href="https://crates.io/crates/calamine">calamine</a> and is faster than other engines in most cases. The optional dependency ‘python-calamine’ needs to be installed.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python"># Returns a DataFrame
pd.read_excel("path_to_file.xlsb", engine="calamine")
</pre></div> </div> </section> <section id="clipboard"> <h2>Clipboard</h2> <p>A handy way to grab data is to use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">read_clipboard()</span></code> method, which takes the contents of the clipboard buffer and passes them to the <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> method. For instance, you can copy the following text to the clipboard (CTRL-C on many operating systems):</p> <div class="highlight-console notranslate">
<div class="highlight"><pre data-language="python">  A B C
x 1 4 p
y 2 5 q
z 3 6 r
</pre></div> </div> <p>And then import the data directly to a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> by calling:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; clipdf = pd.read_clipboard()
&gt;&gt;&gt; clipdf
  A B C
x 1 4 p
y 2 5 q
z 3 6 r
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">to_clipboard</span></code> method can be used to write the contents of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to the clipboard. Following which you can paste the clipboard contents into other applications (CTRL-V on many operating systems). Here we illustrate writing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> into clipboard and reading it back.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df = pd.DataFrame(
...     {"A": [1, 2, 3], "B": [4, 5, 6], "C": ["p", "q", "r"]}, index=["x", "y", "z"]
... )

&gt;&gt;&gt; df
  A B C
x 1 4 p
y 2 5 q
z 3 6 r
&gt;&gt;&gt; df.to_clipboard()
&gt;&gt;&gt; pd.read_clipboard()
  A B C
x 1 4 p
y 2 5 q
z 3 6 r
</pre></div> </div> <p>We can see that we got the same content back, which we had earlier written to the clipboard.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You may need to install xclip or xsel (with PyQt5, PyQt4 or qtpy) on Linux to use these methods.</p> </div> </section> <section id="pickling"> <h2>Pickling</h2> <p>All pandas objects are equipped with <code class="docutils literal notranslate"><span class="pre">to_pickle</span></code> methods which use Python’s <code class="docutils literal notranslate"><span class="pre">cPickle</span></code> module to save data structures to disk using the pickle format.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [436]: df
Out[436]: 
c1         a   
c2         b  d
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8

In [437]: df.to_pickle("foo.pkl")
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">read_pickle</span></code> function in the <code class="docutils literal notranslate"><span class="pre">pandas</span></code> namespace can be used to load any pickled pandas object (or any other pickled object) from file:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [438]: pd.read_pickle("foo.pkl")
Out[438]: 
c1         a   
c2         b  d
lvl1 lvl2      
a    c     1  5
     d     2  6
b    c     3  7
     d     4  8
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Loading pickled data received from untrusted sources can be unsafe.</p> <p>See: <a class="reference external" href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a></p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="../reference/api/pandas.read_pickle.html#pandas.read_pickle" title="pandas.read_pickle"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_pickle()</span></code></a> is only guaranteed backwards compatible back to a few minor release.</p> </div> <section id="compressed-pickle-files"> <h3>Compressed pickle files</h3> <p><a class="reference internal" href="../reference/api/pandas.read_pickle.html#pandas.read_pickle" title="pandas.read_pickle"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_pickle()</span></code></a>, <a class="reference internal" href="../reference/api/pandas.dataframe.to_pickle.html#pandas.DataFrame.to_pickle" title="pandas.DataFrame.to_pickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.to_pickle()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.series.to_pickle.html#pandas.Series.to_pickle" title="pandas.Series.to_pickle"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Series.to_pickle()</span></code></a> can read and write compressed pickle files. The compression types of <code class="docutils literal notranslate"><span class="pre">gzip</span></code>, <code class="docutils literal notranslate"><span class="pre">bz2</span></code>, <code class="docutils literal notranslate"><span class="pre">xz</span></code>, <code class="docutils literal notranslate"><span class="pre">zstd</span></code> are supported for reading and writing. The <code class="docutils literal notranslate"><span class="pre">zip</span></code> file format only supports reading and must contain only one data file to be read.</p> <p>The compression type can be an explicit parameter or be inferred from the file extension. If ‘infer’, then use <code class="docutils literal notranslate"><span class="pre">gzip</span></code>, <code class="docutils literal notranslate"><span class="pre">bz2</span></code>, <code class="docutils literal notranslate"><span class="pre">zip</span></code>, <code class="docutils literal notranslate"><span class="pre">xz</span></code>, <code class="docutils literal notranslate"><span class="pre">zstd</span></code> if filename ends in <code class="docutils literal notranslate"><span class="pre">'.gz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'.bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'.zip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'.xz'</span></code>, or <code class="docutils literal notranslate"><span class="pre">'.zst'</span></code>, respectively.</p> <p>The compression parameter can also be a <code class="docutils literal notranslate"><span class="pre">dict</span></code> in order to pass options to the compression protocol. It must have a <code class="docutils literal notranslate"><span class="pre">'method'</span></code> key set to the name of the compression protocol, which must be one of {<code class="docutils literal notranslate"><span class="pre">'zip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'gzip'</span></code>, <code class="docutils literal notranslate"><span class="pre">'bz2'</span></code>, <code class="docutils literal notranslate"><span class="pre">'xz'</span></code>, <code class="docutils literal notranslate"><span class="pre">'zstd'</span></code>}. All other key-value pairs are passed to the underlying compression library.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [439]: df = pd.DataFrame(
   .....:     {
   .....:         "A": np.random.randn(1000),
   .....:         "B": "foo",
   .....:         "C": pd.date_range("20130101", periods=1000, freq="s"),
   .....:     }
   .....: )
   .....: 

In [440]: df
Out[440]: 
            A    B                   C
0   -0.317441  foo 2013-01-01 00:00:00
1   -1.236269  foo 2013-01-01 00:00:01
2    0.896171  foo 2013-01-01 00:00:02
3   -0.487602  foo 2013-01-01 00:00:03
4   -0.082240  foo 2013-01-01 00:00:04
..        ...  ...                 ...
995 -0.171092  foo 2013-01-01 00:16:35
996  1.786173  foo 2013-01-01 00:16:36
997 -0.575189  foo 2013-01-01 00:16:37
998  0.820750  foo 2013-01-01 00:16:38
999 -1.256530  foo 2013-01-01 00:16:39

[1000 rows x 3 columns]
</pre></div> </div> <p>Using an explicit compression type:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [441]: df.to_pickle("data.pkl.compress", compression="gzip")

In [442]: rt = pd.read_pickle("data.pkl.compress", compression="gzip")

In [443]: rt
Out[443]: 
            A    B                   C
0   -0.317441  foo 2013-01-01 00:00:00
1   -1.236269  foo 2013-01-01 00:00:01
2    0.896171  foo 2013-01-01 00:00:02
3   -0.487602  foo 2013-01-01 00:00:03
4   -0.082240  foo 2013-01-01 00:00:04
..        ...  ...                 ...
995 -0.171092  foo 2013-01-01 00:16:35
996  1.786173  foo 2013-01-01 00:16:36
997 -0.575189  foo 2013-01-01 00:16:37
998  0.820750  foo 2013-01-01 00:16:38
999 -1.256530  foo 2013-01-01 00:16:39

[1000 rows x 3 columns]
</pre></div> </div> <p>Inferring compression type from the extension:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [444]: df.to_pickle("data.pkl.xz", compression="infer")

In [445]: rt = pd.read_pickle("data.pkl.xz", compression="infer")

In [446]: rt
Out[446]: 
            A    B                   C
0   -0.317441  foo 2013-01-01 00:00:00
1   -1.236269  foo 2013-01-01 00:00:01
2    0.896171  foo 2013-01-01 00:00:02
3   -0.487602  foo 2013-01-01 00:00:03
4   -0.082240  foo 2013-01-01 00:00:04
..        ...  ...                 ...
995 -0.171092  foo 2013-01-01 00:16:35
996  1.786173  foo 2013-01-01 00:16:36
997 -0.575189  foo 2013-01-01 00:16:37
998  0.820750  foo 2013-01-01 00:16:38
999 -1.256530  foo 2013-01-01 00:16:39

[1000 rows x 3 columns]
</pre></div> </div> <p>The default is to ‘infer’:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [447]: df.to_pickle("data.pkl.gz")

In [448]: rt = pd.read_pickle("data.pkl.gz")

In [449]: rt
Out[449]: 
            A    B                   C
0   -0.317441  foo 2013-01-01 00:00:00
1   -1.236269  foo 2013-01-01 00:00:01
2    0.896171  foo 2013-01-01 00:00:02
3   -0.487602  foo 2013-01-01 00:00:03
4   -0.082240  foo 2013-01-01 00:00:04
..        ...  ...                 ...
995 -0.171092  foo 2013-01-01 00:16:35
996  1.786173  foo 2013-01-01 00:16:36
997 -0.575189  foo 2013-01-01 00:16:37
998  0.820750  foo 2013-01-01 00:16:38
999 -1.256530  foo 2013-01-01 00:16:39

[1000 rows x 3 columns]

In [450]: df["A"].to_pickle("s1.pkl.bz2")

In [451]: rt = pd.read_pickle("s1.pkl.bz2")

In [452]: rt
Out[452]: 
0     -0.317441
1     -1.236269
2      0.896171
3     -0.487602
4     -0.082240
         ...   
995   -0.171092
996    1.786173
997   -0.575189
998    0.820750
999   -1.256530
Name: A, Length: 1000, dtype: float64
</pre></div> </div> <p>Passing options to the compression protocol in order to speed up compression:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [453]: df.to_pickle("data.pkl.gz", compression={"method": "gzip", "compresslevel": 1})
</pre></div> </div> </section> </section> <section id="msgpack"> <h2>msgpack</h2> <p>pandas support for <code class="docutils literal notranslate"><span class="pre">msgpack</span></code> has been removed in version 1.0.0. It is recommended to use <a class="reference internal" href="#io-pickle"><span class="std std-ref">pickle</span></a> instead.</p> <p>Alternatively, you can also the Arrow IPC serialization format for on-the-wire transmission of pandas objects. For documentation on pyarrow, see <a class="reference external" href="https://arrow.apache.org/docs/python/ipc.html">here</a>.</p> </section> <section id="hdf5-pytables"> <h2>HDF5 (PyTables)</h2> <p><code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> is a dict-like object which reads and writes pandas using the high performance HDF5 format using the excellent <a class="reference external" href="https://www.pytables.org/">PyTables</a> library. See the <a class="reference internal" href="cookbook.html#cookbook-hdf"><span class="std std-ref">cookbook</span></a> for some advanced strategies</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle. Loading pickled data received from untrusted sources can be unsafe.</p> <p>See: <a class="reference external" href="https://docs.python.org/3/library/pickle.html">https://docs.python.org/3/library/pickle.html</a> for more.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [454]: store = pd.HDFStore("store.h5")

In [455]: print(store)
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
</pre></div> </div> <p>Objects can be written to the file just like adding key-value pairs to a dict:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [456]: index = pd.date_range("1/1/2000", periods=8)

In [457]: s = pd.Series(np.random.randn(5), index=["a", "b", "c", "d", "e"])

In [458]: df = pd.DataFrame(np.random.randn(8, 3), index=index, columns=["A", "B", "C"])

# store.put('s', s) is an equivalent method
In [459]: store["s"] = s

In [460]: store["df"] = df

In [461]: store
Out[461]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
</pre></div> </div> <p>In a current or later Python session, you can retrieve stored objects:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># store.get('df') is an equivalent method
In [462]: store["df"]
Out[462]: 
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517

# dotted (attribute) access provides get as well
In [463]: store.df
Out[463]: 
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517
</pre></div> </div> <p>Deletion of the object specified by the key:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># store.remove('df') is an equivalent method
In [464]: del store["df"]

In [465]: store
Out[465]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
</pre></div> </div> <p>Closing a Store and using a context manager:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [466]: store.close()

In [467]: store
Out[467]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5

In [468]: store.is_open
Out[468]: False

# Working with, and automatically closing the store using a context manager
In [469]: with pd.HDFStore("store.h5") as store:
   .....:     store.keys()
   .....: 
</pre></div> </div> <section id="read-write-api"> <h3>Read/write API</h3> <p><code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> supports a top-level API using <code class="docutils literal notranslate"><span class="pre">read_hdf</span></code> for reading and <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code> for writing, similar to how <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> and <code class="docutils literal notranslate"><span class="pre">to_csv</span></code> work.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [470]: df_tl = pd.DataFrame({"A": list(range(5)), "B": list(range(5))})

In [471]: df_tl.to_hdf("store_tl.h5", key="table", append=True)

In [472]: pd.read_hdf("store_tl.h5", "table", where=["index&gt;2"])
Out[472]: 
   A  B
3  3  3
4  4  4
</pre></div> </div> <p>HDFStore will by default not drop rows that are all missing. This behavior can be changed by setting <code class="docutils literal notranslate"><span class="pre">dropna=True</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [473]: df_with_missing = pd.DataFrame(
   .....:     {
   .....:         "col1": [0, np.nan, 2],
   .....:         "col2": [1, np.nan, np.nan],
   .....:     }
   .....: )
   .....: 

In [474]: df_with_missing
Out[474]: 
   col1  col2
0   0.0   1.0
1   NaN   NaN
2   2.0   NaN

In [475]: df_with_missing.to_hdf("file.h5", key="df_with_missing", format="table", mode="w")

In [476]: pd.read_hdf("file.h5", "df_with_missing")
Out[476]: 
   col1  col2
0   0.0   1.0
1   NaN   NaN
2   2.0   NaN

In [477]: df_with_missing.to_hdf(
   .....:     "file.h5", key="df_with_missing", format="table", mode="w", dropna=True
   .....: )
   .....: 

In [478]: pd.read_hdf("file.h5", "df_with_missing")
Out[478]: 
   col1  col2
0   0.0   1.0
2   2.0   NaN
</pre></div> </div> </section> <section id="fixed-format"> <h3>Fixed format</h3> <p>The examples above show storing using <code class="docutils literal notranslate"><span class="pre">put</span></code>, which write the HDF5 to <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> in a fixed array format, called the <code class="docutils literal notranslate"><span class="pre">fixed</span></code> format. These types of stores are <strong>not</strong> appendable once written (though you can simply remove them and rewrite). Nor are they <strong>queryable</strong>; they must be retrieved in their entirety. They also do not support dataframes with non-unique column names. The <code class="docutils literal notranslate"><span class="pre">fixed</span></code> format stores offer very fast writing and slightly faster reading than <code class="docutils literal notranslate"><span class="pre">table</span></code> stores. This format is specified by default when using <code class="docutils literal notranslate"><span class="pre">put</span></code> or <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code> or by <code class="docutils literal notranslate"><span class="pre">format='fixed'</span></code> or <code class="docutils literal notranslate"><span class="pre">format='f'</span></code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>A <code class="docutils literal notranslate"><span class="pre">fixed</span></code> format will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code> if you try to retrieve using a <code class="docutils literal notranslate"><span class="pre">where</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [479]: pd.DataFrame(np.random.randn(10, 2)).to_hdf("test_fixed.h5", key="df")

In [480]: pd.read_hdf("test_fixed.h5", "df", where="index&gt;5")
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[480], line 1
----&gt; 1 pd.read_hdf("test_fixed.h5", "df", where="index&gt;5")

File ~/work/pandas/pandas/pandas/io/pytables.py:452, in read_hdf(path_or_buf, key, mode, errors, where, start, stop, columns, iterator, chunksize, **kwargs)
    447                 raise ValueError(
    448                     "key must be provided when HDF5 "
    449                     "file contains multiple datasets."
    450                 )
    451         key = candidate_only_group._v_pathname
--&gt; 452     return store.select(
    453         key,
    454         where=where,
    455         start=start,
    456         stop=stop,
    457         columns=columns,
    458         iterator=iterator,
    459         chunksize=chunksize,
    460         auto_close=auto_close,
    461     )
    462 except (ValueError, TypeError, LookupError):
    463     if not isinstance(path_or_buf, HDFStore):
    464         # if there is an error, close the store if we opened it.

File ~/work/pandas/pandas/pandas/io/pytables.py:906, in HDFStore.select(self, key, where, start, stop, columns, iterator, chunksize, auto_close)
    892 # create the iterator
    893 it = TableIterator(
    894     self,
    895     s,
   (...)
    903     auto_close=auto_close,
    904 )
--&gt; 906 return it.get_result()

File ~/work/pandas/pandas/pandas/io/pytables.py:2029, in TableIterator.get_result(self, coordinates)
   2026     where = self.where
   2028 # directly return the result
-&gt; 2029 results = self.func(self.start, self.stop, where)
   2030 self.close()
   2031 return results

File ~/work/pandas/pandas/pandas/io/pytables.py:890, in HDFStore.select.&lt;locals&gt;.func(_start, _stop, _where)
    889 def func(_start, _stop, _where):
--&gt; 890     return s.read(start=_start, stop=_stop, where=_where, columns=columns)

File ~/work/pandas/pandas/pandas/io/pytables.py:3278, in BlockManagerFixed.read(self, where, columns, start, stop)
   3270 def read(
   3271     self,
   3272     where=None,
   (...)
   3276 ) -&gt; DataFrame:
   3277     # start, stop applied to rows, so 0th axis only
-&gt; 3278     self.validate_read(columns, where)
   3279     select_axis = self.obj_type()._get_block_manager_axis(0)
   3281     axes = []

File ~/work/pandas/pandas/pandas/io/pytables.py:2922, in GenericFixed.validate_read(self, columns, where)
   2917     raise TypeError(
   2918         "cannot pass a column specification when reading "
   2919         "a Fixed format store. this store must be selected in its entirety"
   2920     )
   2921 if where is not None:
-&gt; 2922     raise TypeError(
   2923         "cannot pass a where specification when reading "
   2924         "from a Fixed format store. this store must be selected in its entirety"
   2925     )

TypeError: cannot pass a where specification when reading from a Fixed format store. this store must be selected in its entirety
</pre></div> </div> </div> </section> <section id="table-format"> <h3>Table format</h3> <p><code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> supports another <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> format on disk, the <code class="docutils literal notranslate"><span class="pre">table</span></code> format. Conceptually a <code class="docutils literal notranslate"><span class="pre">table</span></code> is shaped very much like a DataFrame, with rows and columns. A <code class="docutils literal notranslate"><span class="pre">table</span></code> may be appended to in the same or other sessions. In addition, delete and query type operations are supported. This format is specified by <code class="docutils literal notranslate"><span class="pre">format='table'</span></code> or <code class="docutils literal notranslate"><span class="pre">format='t'</span></code> to <code class="docutils literal notranslate"><span class="pre">append</span></code> or <code class="docutils literal notranslate"><span class="pre">put</span></code> or <code class="docutils literal notranslate"><span class="pre">to_hdf</span></code>.</p> <p>This format can be set as an option as well <code class="docutils literal notranslate"><span class="pre">pd.set_option('io.hdf.default_format','table')</span></code> to enable <code class="docutils literal notranslate"><span class="pre">put/append/to_hdf</span></code> to by default store in the <code class="docutils literal notranslate"><span class="pre">table</span></code> format.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [481]: store = pd.HDFStore("store.h5")

In [482]: df1 = df[0:4]

In [483]: df2 = df[4:]

# append data (creates a table automatically)
In [484]: store.append("df", df1)

In [485]: store.append("df", df2)

In [486]: store
Out[486]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5

# select the entire object
In [487]: store.select("df")
Out[487]: 
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517

# the type of stored data
In [488]: store.root.df._v_attrs.pandas_type
Out[488]: 'frame_table'
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You can also create a <code class="docutils literal notranslate"><span class="pre">table</span></code> by passing <code class="docutils literal notranslate"><span class="pre">format='table'</span></code> or <code class="docutils literal notranslate"><span class="pre">format='t'</span></code> to a <code class="docutils literal notranslate"><span class="pre">put</span></code> operation.</p> </div> </section> <section id="hierarchical-keys"> <h3>Hierarchical keys</h3> <p>Keys to a store can be specified as a string. These can be in a hierarchical path-name like format (e.g. <code class="docutils literal notranslate"><span class="pre">foo/bar/bah</span></code>), which will generate a hierarchy of sub-stores (or <code class="docutils literal notranslate"><span class="pre">Groups</span></code> in PyTables parlance). Keys can be specified without the leading ‘/’ and are <strong>always</strong> absolute (e.g. ‘foo’ refers to ‘/foo’). Removal operations can remove everything in the sub-store and <strong>below</strong>, so be <em>careful</em>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [489]: store.put("foo/bar/bah", df)

In [490]: store.append("food/orange", df)

In [491]: store.append("food/apple", df)

In [492]: store
Out[492]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5

# a list of keys are returned
In [493]: store.keys()
Out[493]: ['/df', '/food/apple', '/food/orange', '/foo/bar/bah']

# remove all nodes under this level
In [494]: store.remove("food")

In [495]: store
Out[495]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5
</pre></div> </div> <p>You can walk through the group hierarchy using the <code class="docutils literal notranslate"><span class="pre">walk</span></code> method which will yield a tuple for each group key along with the relative keys of its contents.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [496]: for (path, subgroups, subkeys) in store.walk():
   .....:     for subgroup in subgroups:
   .....:         print("GROUP: {}/{}".format(path, subgroup))
   .....:     for subkey in subkeys:
   .....:         key = "/".join([path, subkey])
   .....:         print("KEY: {}".format(key))
   .....:         print(store.get(key))
   .....: 
GROUP: /foo
KEY: /df
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517
GROUP: /foo/bar
KEY: /foo/bar/bah
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Hierarchical keys cannot be retrieved as dotted (attribute) access as described above for items stored under the root node.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [497]: store.foo.bar.bah
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[497], line 1
----&gt; 1 store.foo.bar.bah

File ~/work/pandas/pandas/pandas/io/pytables.py:613, in HDFStore.__getattr__(self, name)
    611 """allow attribute access to get stores"""
    612 try:
--&gt; 613     return self.get(name)
    614 except (KeyError, ClosedFileError):
    615     pass

File ~/work/pandas/pandas/pandas/io/pytables.py:813, in HDFStore.get(self, key)
    811 if group is None:
    812     raise KeyError(f"No object named {key} in the file")
--&gt; 813 return self._read_group(group)

File ~/work/pandas/pandas/pandas/io/pytables.py:1878, in HDFStore._read_group(self, group)
   1877 def _read_group(self, group: Node):
-&gt; 1878     s = self._create_storer(group)
   1879     s.infer_axes()
   1880     return s.read()

File ~/work/pandas/pandas/pandas/io/pytables.py:1752, in HDFStore._create_storer(self, group, format, value, encoding, errors)
   1750         tt = "generic_table"
   1751     else:
-&gt; 1752         raise TypeError(
   1753             "cannot create a storer if the object is not existing "
   1754             "nor a value are passed"
   1755         )
   1756 else:
   1757     if isinstance(value, Series):

TypeError: cannot create a storer if the object is not existing nor a value are passed
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># you can directly access the actual PyTables node but using the root node
In [498]: store.root.foo.bar.bah
Out[498]: 
/foo/bar/bah (Group) ''
  children := ['axis0' (Array), 'axis1' (Array), 'block0_items' (Array), 'block0_values' (Array)]
</pre></div> </div> <p>Instead, use explicit string based keys:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [499]: store["foo/bar/bah"]
Out[499]: 
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517
</pre></div> </div> </div> </section> <section id="storing-types"> <h3>Storing types</h3> <section id="storing-mixed-types-in-a-table"> <h4>Storing mixed types in a table</h4> <p>Storing mixed-dtype data is supported. Strings are stored as a fixed-width using the maximum size of the appended column. Subsequent attempts at appending longer strings will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p> <p>Passing <code class="docutils literal notranslate"><span class="pre">min_itemsize={`values`:</span> <span class="pre">size}</span></code> as a parameter to append will set a larger minimum for the string columns. Storing <code class="docutils literal notranslate"><span class="pre">floats,</span>
<span class="pre">strings,</span> <span class="pre">ints,</span> <span class="pre">bools,</span> <span class="pre">datetime64</span></code> are currently supported. For string columns, passing <code class="docutils literal notranslate"><span class="pre">nan_rep</span> <span class="pre">=</span> <span class="pre">'nan'</span></code> to append will change the default nan representation on disk (which converts to/from <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>), this defaults to <code class="docutils literal notranslate"><span class="pre">nan</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [500]: df_mixed = pd.DataFrame(
   .....:     {
   .....:         "A": np.random.randn(8),
   .....:         "B": np.random.randn(8),
   .....:         "C": np.array(np.random.randn(8), dtype="float32"),
   .....:         "string": "string",
   .....:         "int": 1,
   .....:         "bool": True,
   .....:         "datetime64": pd.Timestamp("20010102"),
   .....:     },
   .....:     index=list(range(8)),
   .....: )
   .....: 

In [501]: df_mixed.loc[df_mixed.index[3:5], ["A", "B", "string", "datetime64"]] = np.nan

In [502]: store.append("df_mixed", df_mixed, min_itemsize={"values": 50})

In [503]: df_mixed1 = store.select("df_mixed")

In [504]: df_mixed1
Out[504]: 
          A         B         C  ... int  bool                    datetime64
0  0.013747 -1.166078 -1.292080  ...   1  True 1970-01-01 00:00:00.978393600
1 -0.712009  0.247572  1.526911  ...   1  True 1970-01-01 00:00:00.978393600
2 -0.645096  1.687406  0.288504  ...   1  True 1970-01-01 00:00:00.978393600
3       NaN       NaN  0.097771  ...   1  True                           NaT
4       NaN       NaN  1.536408  ...   1  True                           NaT
5 -0.023202  0.043702  0.926790  ...   1  True 1970-01-01 00:00:00.978393600
6  2.359782  0.088224 -0.676448  ...   1  True 1970-01-01 00:00:00.978393600
7 -0.143428 -0.813360 -0.179724  ...   1  True 1970-01-01 00:00:00.978393600

[8 rows x 7 columns]

In [505]: df_mixed1.dtypes.value_counts()
Out[505]: 
float64           2
float32           1
object            1
int64             1
bool              1
datetime64[ns]    1
Name: count, dtype: int64

# we have provided a minimum string column size
In [506]: store.root.df_mixed.table
Out[506]: 
/df_mixed/table (Table(8,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(2,), dflt=0.0, pos=1),
  "values_block_1": Float32Col(shape=(1,), dflt=0.0, pos=2),
  "values_block_2": StringCol(itemsize=50, shape=(1,), dflt=b'', pos=3),
  "values_block_3": Int64Col(shape=(1,), dflt=0, pos=4),
  "values_block_4": BoolCol(shape=(1,), dflt=False, pos=5),
  "values_block_5": Int64Col(shape=(1,), dflt=0, pos=6)}
  byteorder := 'little'
  chunkshape := (689,)
  autoindex := True
  colindexes := {
    "index": Index(6, mediumshuffle, zlib(1)).is_csi=False}
</pre></div> </div> </section> <section id="storing-multiindex-dataframes"> <h4>Storing MultiIndex DataFrames</h4> <p>Storing MultiIndex <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code> as tables is very similar to storing/selecting from homogeneous index <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [507]: index = pd.MultiIndex(
   .....:    levels=[["foo", "bar", "baz", "qux"], ["one", "two", "three"]],
   .....:    codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
   .....:    names=["foo", "bar"],
   .....: )
   .....: 

In [508]: df_mi = pd.DataFrame(np.random.randn(10, 3), index=index, columns=["A", "B", "C"])

In [509]: df_mi
Out[509]: 
                  A         B         C
foo bar                                
foo one   -1.303456 -0.642994 -0.649456
    two    1.012694  0.414147  1.950460
    three  1.094544 -0.802899 -0.583343
bar one    0.410395  0.618321  0.560398
    two    1.434027 -0.033270  0.343197
baz two   -1.646063 -0.695847 -0.429156
    three -0.244688 -1.428229 -0.138691
qux one    1.866184 -1.446617  0.036660
    two   -1.660522  0.929553 -1.298649
    three  3.565769  0.682402  1.041927

In [510]: store.append("df_mi", df_mi)

In [511]: store.select("df_mi")
Out[511]: 
                  A         B         C
foo bar                                
foo one   -1.303456 -0.642994 -0.649456
    two    1.012694  0.414147  1.950460
    three  1.094544 -0.802899 -0.583343
bar one    0.410395  0.618321  0.560398
    two    1.434027 -0.033270  0.343197
baz two   -1.646063 -0.695847 -0.429156
    three -0.244688 -1.428229 -0.138691
qux one    1.866184 -1.446617  0.036660
    two   -1.660522  0.929553 -1.298649
    three  3.565769  0.682402  1.041927

# the levels are automatically included as data columns
In [512]: store.select("df_mi", "foo=bar")
Out[512]: 
                A         B         C
foo bar                              
bar one  0.410395  0.618321  0.560398
    two  1.434027 -0.033270  0.343197
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code class="docutils literal notranslate"><span class="pre">index</span></code> keyword is reserved and cannot be use as a level name.</p> </div> </section> </section> <section id="querying"> <h3>Querying</h3> <section id="querying-a-table"> <h4>Querying a table</h4> <p><code class="docutils literal notranslate"><span class="pre">select</span></code> and <code class="docutils literal notranslate"><span class="pre">delete</span></code> operations have an optional criterion that can be specified to select/delete only a subset of the data. This allows one to have a very large on-disk table and retrieve only a portion of the data.</p> <p>A query is specified using the <code class="docutils literal notranslate"><span class="pre">Term</span></code> class under the hood, as a boolean expression.</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">index</span></code> and <code class="docutils literal notranslate"><span class="pre">columns</span></code> are supported indexers of <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>.</p></li> <li><p>if <code class="docutils literal notranslate"><span class="pre">data_columns</span></code> are specified, these can be used as additional indexers.</p></li> <li><p>level name in a MultiIndex, with default name <code class="docutils literal notranslate"><span class="pre">level_0</span></code>, <code class="docutils literal notranslate"><span class="pre">level_1</span></code>, … if not provided.</p></li> </ul> <p>Valid comparison operators are:</p> <p><code class="docutils literal notranslate"><span class="pre">=,</span> <span class="pre">==,</span> <span class="pre">!=,</span> <span class="pre">&gt;,</span> <span class="pre">&gt;=,</span> <span class="pre">&lt;,</span> <span class="pre">&lt;=</span></code></p> <p>Valid boolean expressions are combined with:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">|</span></code> : or</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">&amp;</span></code> : and</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">(</span></code> and <code class="docutils literal notranslate"><span class="pre">)</span></code> : for grouping</p></li> </ul> <p>These rules are similar to how boolean expressions are used in pandas for indexing.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">=</span></code> will be automatically expanded to the comparison operator <code class="docutils literal notranslate"><span class="pre">==</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">~</span></code> is the not operator, but can only be used in very limited circumstances</p></li> <li><p>If a list/tuple of expressions is passed they will be combined via <code class="docutils literal notranslate"><span class="pre">&amp;</span></code></p></li> </ul> </div> <p>The following are valid expressions:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">'index</span> <span class="pre">&gt;=</span> <span class="pre">date'</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">"columns</span> <span class="pre">=</span> <span class="pre">['A',</span> <span class="pre">'D']"</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">"columns</span> <span class="pre">in</span> <span class="pre">['A',</span> <span class="pre">'D']"</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'columns</span> <span class="pre">=</span> <span class="pre">A'</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'columns</span> <span class="pre">==</span> <span class="pre">A'</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">"~(columns</span> <span class="pre">=</span> <span class="pre">['A',</span> <span class="pre">'B'])"</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'index</span> <span class="pre">&gt;</span> <span class="pre">df.index[3]</span> <span class="pre">&amp;</span> <span class="pre">string</span> <span class="pre">=</span> <span class="pre">"bar"'</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'(index</span> <span class="pre">&gt;</span> <span class="pre">df.index[3]</span> <span class="pre">&amp;</span> <span class="pre">index</span> <span class="pre">&lt;=</span> <span class="pre">df.index[6])</span> <span class="pre">|</span> <span class="pre">string</span> <span class="pre">=</span> <span class="pre">"bar"'</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">"ts</span> <span class="pre">&gt;=</span> <span class="pre">Timestamp('2012-02-01')"</span></code></p></li> <li><p><code class="docutils literal notranslate"><span class="pre">"major_axis&gt;=20130101"</span></code></p></li> </ul> <p>The <code class="docutils literal notranslate"><span class="pre">indexers</span></code> are on the left-hand side of the sub-expression:</p> <p><code class="docutils literal notranslate"><span class="pre">columns</span></code>, <code class="docutils literal notranslate"><span class="pre">major_axis</span></code>, <code class="docutils literal notranslate"><span class="pre">ts</span></code></p> <p>The right-hand side of the sub-expression (after a comparison operator) can be:</p> <ul class="simple"> <li><p>functions that will be evaluated, e.g. <code class="docutils literal notranslate"><span class="pre">Timestamp('2012-02-01')</span></code></p></li> <li><p>strings, e.g. <code class="docutils literal notranslate"><span class="pre">"bar"</span></code></p></li> <li><p>date-like, e.g. <code class="docutils literal notranslate"><span class="pre">20130101</span></code>, or <code class="docutils literal notranslate"><span class="pre">"20130101"</span></code></p></li> <li><p>lists, e.g. <code class="docutils literal notranslate"><span class="pre">"['A',</span> <span class="pre">'B']"</span></code></p></li> <li><p>variables that are defined in the local names space, e.g. <code class="docutils literal notranslate"><span class="pre">date</span></code></p></li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Passing a string to a query by interpolating it into the query expression is not recommended. Simply assign the string of interest to a variable and use that variable in an expression. For example, do this</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">string = "HolyMoly'"
store.select("df", "index == string")
</pre></div> </div> <p>instead of this</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">string = "HolyMoly'"
store.select('df', f'index == {string}')
</pre></div> </div> <p>The latter will <strong>not</strong> work and will raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code>.Note that there’s a single quote followed by a double quote in the <code class="docutils literal notranslate"><span class="pre">string</span></code> variable.</p> <p>If you <em>must</em> interpolate, use the <code class="docutils literal notranslate"><span class="pre">'%r'</span></code> format specifier</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">store.select("df", "index == %r" % string)
</pre></div> </div> <p>which will quote <code class="docutils literal notranslate"><span class="pre">string</span></code>.</p> </div> <p>Here are some examples:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [513]: dfq = pd.DataFrame(
   .....:     np.random.randn(10, 4),
   .....:     columns=list("ABCD"),
   .....:     index=pd.date_range("20130101", periods=10),
   .....: )
   .....: 

In [514]: store.append("dfq", dfq, format="table", data_columns=True)
</pre></div> </div> <p>Use boolean expressions, with in-line function evaluation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [515]: store.select("dfq", "index&gt;pd.Timestamp('20130104') &amp; columns=['A', 'B']")
Out[515]: 
                   A         B
2013-01-05 -0.830545 -0.457071
2013-01-06  0.431186  1.049421
2013-01-07  0.617509 -0.811230
2013-01-08  0.947422 -0.671233
2013-01-09 -0.183798 -1.211230
2013-01-10  0.361428  0.887304
</pre></div> </div> <p>Use inline column reference.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [516]: store.select("dfq", where="A&gt;0 or C&gt;0")
Out[516]: 
                   A         B         C         D
2013-01-02  0.658179  0.362814 -0.917897  0.010165
2013-01-03  0.905122  1.848731 -1.184241  0.932053
2013-01-05 -0.830545 -0.457071  1.565581  1.148032
2013-01-06  0.431186  1.049421  0.383309  0.595013
2013-01-07  0.617509 -0.811230 -2.088563 -1.393500
2013-01-08  0.947422 -0.671233 -0.847097 -1.187785
2013-01-10  0.361428  0.887304  0.266457 -0.399641
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">columns</span></code> keyword can be supplied to select a list of columns to be returned, this is equivalent to passing a <code class="docutils literal notranslate"><span class="pre">'columns=list_of_columns_to_filter'</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [517]: store.select("df", "columns=['A', 'B']")
Out[517]: 
                   A         B
2000-01-01  0.858644 -0.851236
2000-01-02 -0.080372 -1.268121
2000-01-03  0.816983  1.965656
2000-01-04  0.712795 -0.062433
2000-01-05 -0.298721 -1.988045
2000-01-06  1.103675  1.382242
2000-01-07 -0.729161 -0.142928
2000-01-08 -1.005977  0.465222
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">start</span></code> and <code class="docutils literal notranslate"><span class="pre">stop</span></code> parameters can be specified to limit the total search space. These are in terms of the total number of rows in a table.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code class="docutils literal notranslate"><span class="pre">select</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> if the query expression has an unknown variable reference. Usually this means that you are trying to select on a column that is <strong>not</strong> a data_column.</p> <p><code class="docutils literal notranslate"><span class="pre">select</span></code> will raise a <code class="docutils literal notranslate"><span class="pre">SyntaxError</span></code> if the query expression is not valid.</p> </div> </section> <section id="query-timedelta64-ns"> <h4>Query timedelta64[ns]</h4> <p>You can store and query using the <code class="docutils literal notranslate"><span class="pre">timedelta64[ns]</span></code> type. Terms can be specified in the format: <code class="docutils literal notranslate"><span class="pre">&lt;float&gt;(&lt;unit&gt;)</span></code>, where float may be signed (and fractional), and unit can be <code class="docutils literal notranslate"><span class="pre">D,s,ms,us,ns</span></code> for the timedelta. Here’s an example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [518]: from datetime import timedelta

In [519]: dftd = pd.DataFrame(
   .....:     {
   .....:         "A": pd.Timestamp("20130101"),
   .....:         "B": [
   .....:             pd.Timestamp("20130101") + timedelta(days=i, seconds=10)
   .....:             for i in range(10)
   .....:         ],
   .....:     }
   .....: )
   .....: 

In [520]: dftd["C"] = dftd["A"] - dftd["B"]

In [521]: dftd
Out[521]: 
           A                   B                  C
0 2013-01-01 2013-01-01 00:00:10  -1 days +23:59:50
1 2013-01-01 2013-01-02 00:00:10  -2 days +23:59:50
2 2013-01-01 2013-01-03 00:00:10  -3 days +23:59:50
3 2013-01-01 2013-01-04 00:00:10  -4 days +23:59:50
4 2013-01-01 2013-01-05 00:00:10  -5 days +23:59:50
5 2013-01-01 2013-01-06 00:00:10  -6 days +23:59:50
6 2013-01-01 2013-01-07 00:00:10  -7 days +23:59:50
7 2013-01-01 2013-01-08 00:00:10  -8 days +23:59:50
8 2013-01-01 2013-01-09 00:00:10  -9 days +23:59:50
9 2013-01-01 2013-01-10 00:00:10 -10 days +23:59:50

In [522]: store.append("dftd", dftd, data_columns=True)

In [523]: store.select("dftd", "C&lt;'-3.5D'")
Out[523]: 
                              A                   B                  C
4 1970-01-01 00:00:01.356998400 2013-01-05 00:00:10  -5 days +23:59:50
5 1970-01-01 00:00:01.356998400 2013-01-06 00:00:10  -6 days +23:59:50
6 1970-01-01 00:00:01.356998400 2013-01-07 00:00:10  -7 days +23:59:50
7 1970-01-01 00:00:01.356998400 2013-01-08 00:00:10  -8 days +23:59:50
8 1970-01-01 00:00:01.356998400 2013-01-09 00:00:10  -9 days +23:59:50
9 1970-01-01 00:00:01.356998400 2013-01-10 00:00:10 -10 days +23:59:50
</pre></div> </div> </section> <section id="query-multiindex"> <h4>Query MultiIndex</h4> <p>Selecting from a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> can be achieved by using the name of the level.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [524]: df_mi.index.names
Out[524]: FrozenList(['foo', 'bar'])

In [525]: store.select("df_mi", "foo=baz and bar=two")
Out[525]: 
                A         B         C
foo bar                              
baz two -1.646063 -0.695847 -0.429156
</pre></div> </div> <p>If the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> levels names are <code class="docutils literal notranslate"><span class="pre">None</span></code>, the levels are automatically made available via the <code class="docutils literal notranslate"><span class="pre">level_n</span></code> keyword with <code class="docutils literal notranslate"><span class="pre">n</span></code> the level of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> you want to select from.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [526]: index = pd.MultiIndex(
   .....:     levels=[["foo", "bar", "baz", "qux"], ["one", "two", "three"]],
   .....:     codes=[[0, 0, 0, 1, 1, 2, 2, 3, 3, 3], [0, 1, 2, 0, 1, 1, 2, 0, 1, 2]],
   .....: )
   .....: 

In [527]: df_mi_2 = pd.DataFrame(np.random.randn(10, 3), index=index, columns=["A", "B", "C"])

In [528]: df_mi_2
Out[528]: 
                  A         B         C
foo one   -0.219582  1.186860 -1.437189
    two    0.053768  1.872644 -1.469813
    three -0.564201  0.876341  0.407749
bar one   -0.232583  0.179812  0.922152
    two   -1.820952 -0.641360  2.133239
baz two   -0.941248 -0.136307 -1.271305
    three -0.099774 -0.061438 -0.845172
qux one    0.465793  0.756995 -0.541690
    two   -0.802241  0.877657 -2.553831
    three  0.094899 -2.319519  0.293601

In [529]: store.append("df_mi_2", df_mi_2)

# the levels are automatically included as data columns with keyword level_n
In [530]: store.select("df_mi_2", "level_0=foo and level_1=two")
Out[530]: 
                A         B         C
foo two  0.053768  1.872644 -1.469813
</pre></div> </div> </section> <section id="indexing"> <h4>Indexing</h4> <p>You can create/modify an index for a table with <code class="docutils literal notranslate"><span class="pre">create_table_index</span></code> after data is already in the table (after and <code class="docutils literal notranslate"><span class="pre">append/put</span></code> operation). Creating a table index is <strong>highly</strong> encouraged. This will speed your queries a great deal when you use a <code class="docutils literal notranslate"><span class="pre">select</span></code> with the indexed dimension as the <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Indexes are automagically created on the indexables and any data columns you specify. This behavior can be turned off by passing <code class="docutils literal notranslate"><span class="pre">index=False</span></code> to <code class="docutils literal notranslate"><span class="pre">append</span></code>.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># we have automagically already created an index (in the first section)
In [531]: i = store.root.df.table.cols.index.index

In [532]: i.optlevel, i.kind
Out[532]: (6, 'medium')

# change an index by passing new parameters
In [533]: store.create_table_index("df", optlevel=9, kind="full")

In [534]: i = store.root.df.table.cols.index.index

In [535]: i.optlevel, i.kind
Out[535]: (9, 'full')
</pre></div> </div> <p>Oftentimes when appending large amounts of data to a store, it is useful to turn off index creation for each append, then recreate at the end.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [536]: df_1 = pd.DataFrame(np.random.randn(10, 2), columns=list("AB"))

In [537]: df_2 = pd.DataFrame(np.random.randn(10, 2), columns=list("AB"))

In [538]: st = pd.HDFStore("appends.h5", mode="w")

In [539]: st.append("df", df_1, data_columns=["B"], index=False)

In [540]: st.append("df", df_2, data_columns=["B"], index=False)

In [541]: st.get_storer("df").table
Out[541]: 
/df/table (Table(20,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2)}
  byteorder := 'little'
  chunkshape := (2730,)
</pre></div> </div> <p>Then create the index when finished appending.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [542]: st.create_table_index("df", columns=["B"], optlevel=9, kind="full")

In [543]: st.get_storer("df").table
Out[543]: 
/df/table (Table(20,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2)}
  byteorder := 'little'
  chunkshape := (2730,)
  autoindex := True
  colindexes := {
    "B": Index(9, fullshuffle, zlib(1)).is_csi=True}

In [544]: st.close()
</pre></div> </div> <p>See <a class="reference external" href="https://stackoverflow.com/questions/17893370/ptrepack-sortby-needs-full-index">here</a> for how to create a completely-sorted-index (CSI) on an existing store.</p> </section> <section id="query-via-data-columns"> <h4>Query via data columns</h4> <p>You can designate (and index) certain columns that you want to be able to perform queries (other than the <code class="docutils literal notranslate"><span class="pre">indexable</span></code> columns, which you can always query). For instance say you want to perform this common operation, on-disk, and return just the frame that matches this query. You can specify <code class="docutils literal notranslate"><span class="pre">data_columns</span> <span class="pre">=</span> <span class="pre">True</span></code> to force all columns to be <code class="docutils literal notranslate"><span class="pre">data_columns</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [545]: df_dc = df.copy()

In [546]: df_dc["string"] = "foo"

In [547]: df_dc.loc[df_dc.index[4:6], "string"] = np.nan

In [548]: df_dc.loc[df_dc.index[7:9], "string"] = "bar"

In [549]: df_dc["string2"] = "cool"

In [550]: df_dc.loc[df_dc.index[1:3], ["B", "C"]] = 1.0

In [551]: df_dc
Out[551]: 
                   A         B         C string string2
2000-01-01  0.858644 -0.851236  1.058006    foo    cool
2000-01-02 -0.080372  1.000000  1.000000    foo    cool
2000-01-03  0.816983  1.000000  1.000000    foo    cool
2000-01-04  0.712795 -0.062433  0.736755    foo    cool
2000-01-05 -0.298721 -1.988045  1.475308    NaN    cool
2000-01-06  1.103675  1.382242 -0.650762    NaN    cool
2000-01-07 -0.729161 -0.142928 -1.063038    foo    cool
2000-01-08 -1.005977  0.465222 -0.094517    bar    cool

# on-disk operations
In [552]: store.append("df_dc", df_dc, data_columns=["B", "C", "string", "string2"])

In [553]: store.select("df_dc", where="B &gt; 0")
Out[553]: 
                   A         B         C string string2
2000-01-02 -0.080372  1.000000  1.000000    foo    cool
2000-01-03  0.816983  1.000000  1.000000    foo    cool
2000-01-06  1.103675  1.382242 -0.650762    NaN    cool
2000-01-08 -1.005977  0.465222 -0.094517    bar    cool

# getting creative
In [554]: store.select("df_dc", "B &gt; 0 &amp; C &gt; 0 &amp; string == foo")
Out[554]: 
                   A    B    C string string2
2000-01-02 -0.080372  1.0  1.0    foo    cool
2000-01-03  0.816983  1.0  1.0    foo    cool

# this is in-memory version of this type of selection
In [555]: df_dc[(df_dc.B &gt; 0) &amp; (df_dc.C &gt; 0) &amp; (df_dc.string == "foo")]
Out[555]: 
                   A    B    C string string2
2000-01-02 -0.080372  1.0  1.0    foo    cool
2000-01-03  0.816983  1.0  1.0    foo    cool

# we have automagically created this index and the B/C/string/string2
# columns are stored separately as ``PyTables`` columns
In [556]: store.root.df_dc.table
Out[556]: 
/df_dc/table (Table(8,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": Float64Col(shape=(1,), dflt=0.0, pos=1),
  "B": Float64Col(shape=(), dflt=0.0, pos=2),
  "C": Float64Col(shape=(), dflt=0.0, pos=3),
  "string": StringCol(itemsize=3, shape=(), dflt=b'', pos=4),
  "string2": StringCol(itemsize=4, shape=(), dflt=b'', pos=5)}
  byteorder := 'little'
  chunkshape := (1680,)
  autoindex := True
  colindexes := {
    "index": Index(6, mediumshuffle, zlib(1)).is_csi=False,
    "B": Index(6, mediumshuffle, zlib(1)).is_csi=False,
    "C": Index(6, mediumshuffle, zlib(1)).is_csi=False,
    "string": Index(6, mediumshuffle, zlib(1)).is_csi=False,
    "string2": Index(6, mediumshuffle, zlib(1)).is_csi=False}
</pre></div> </div> <p>There is some performance degradation by making lots of columns into <code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">columns</span></code>, so it is up to the user to designate these. In addition, you cannot change data columns (nor indexables) after the first append/put operation (Of course you can simply read in the data and create a new table!).</p> </section> <section id="iterator"> <h4>Iterator</h4> <p>You can pass <code class="docutils literal notranslate"><span class="pre">iterator=True</span></code> or <code class="docutils literal notranslate"><span class="pre">chunksize=number_in_a_chunk</span></code> to <code class="docutils literal notranslate"><span class="pre">select</span></code> and <code class="docutils literal notranslate"><span class="pre">select_as_multiple</span></code> to return an iterator on the results. The default is 50,000 rows returned in a chunk.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [557]: for df in store.select("df", chunksize=3):
   .....:     print(df)
   .....: 
                   A         B         C
2000-01-01  0.858644 -0.851236  1.058006
2000-01-02 -0.080372 -1.268121  1.561967
2000-01-03  0.816983  1.965656 -1.169408
                   A         B         C
2000-01-04  0.712795 -0.062433  0.736755
2000-01-05 -0.298721 -1.988045  1.475308
2000-01-06  1.103675  1.382242 -0.650762
                   A         B         C
2000-01-07 -0.729161 -0.142928 -1.063038
2000-01-08 -1.005977  0.465222 -0.094517
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You can also use the iterator with <code class="docutils literal notranslate"><span class="pre">read_hdf</span></code> which will open, then automatically close the store when finished iterating.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">for df in pd.read_hdf("store.h5", "df", chunksize=3):
    print(df)
</pre></div> </div> </div> <p>Note, that the chunksize keyword applies to the <strong>source</strong> rows. So if you are doing a query, then the chunksize will subdivide the total rows in the table and the query applied, returning an iterator on potentially unequal sized chunks.</p> <p>Here is a recipe for generating a query and using it to create equal sized return chunks.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [558]: dfeq = pd.DataFrame({"number": np.arange(1, 11)})

In [559]: dfeq
Out[559]: 
   number
0       1
1       2
2       3
3       4
4       5
5       6
6       7
7       8
8       9
9      10

In [560]: store.append("dfeq", dfeq, data_columns=["number"])

In [561]: def chunks(l, n):
   .....:     return [l[i: i + n] for i in range(0, len(l), n)]
   .....: 

In [562]: evens = [2, 4, 6, 8, 10]

In [563]: coordinates = store.select_as_coordinates("dfeq", "number=evens")

In [564]: for c in chunks(coordinates, 2):
   .....:     print(store.select("dfeq", where=c))
   .....: 
   number
1       2
3       4
   number
5       6
7       8
   number
9      10
</pre></div> </div> </section> <section id="advanced-queries"> <h4>Advanced queries</h4> <section id="select-a-single-column"> <h5>Select a single column</h5> <p>To retrieve a single indexable or data column, use the method <code class="docutils literal notranslate"><span class="pre">select_column</span></code>. This will, for example, enable you to get the index very quickly. These return a <code class="docutils literal notranslate"><span class="pre">Series</span></code> of the result, indexed by the row number. These do not currently accept the <code class="docutils literal notranslate"><span class="pre">where</span></code> selector.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [565]: store.select_column("df_dc", "index")
Out[565]: 
0   2000-01-01
1   2000-01-02
2   2000-01-03
3   2000-01-04
4   2000-01-05
5   2000-01-06
6   2000-01-07
7   2000-01-08
Name: index, dtype: datetime64[ns]

In [566]: store.select_column("df_dc", "string")
Out[566]: 
0    foo
1    foo
2    foo
3    foo
4    NaN
5    NaN
6    foo
7    bar
Name: string, dtype: object
</pre></div> </div> </section> <section id="selecting-coordinates"> <h5>Selecting coordinates</h5> <p>Sometimes you want to get the coordinates (a.k.a the index locations) of your query. This returns an <code class="docutils literal notranslate"><span class="pre">Index</span></code> of the resulting locations. These coordinates can also be passed to subsequent <code class="docutils literal notranslate"><span class="pre">where</span></code> operations.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [567]: df_coord = pd.DataFrame(
   .....:     np.random.randn(1000, 2), index=pd.date_range("20000101", periods=1000)
   .....: )
   .....: 

In [568]: store.append("df_coord", df_coord)

In [569]: c = store.select_as_coordinates("df_coord", "index &gt; 20020101")

In [570]: c
Out[570]: 
Index([732, 733, 734, 735, 736, 737, 738, 739, 740, 741,
       ...
       990, 991, 992, 993, 994, 995, 996, 997, 998, 999],
      dtype='int64', length=268)

In [571]: store.select("df_coord", where=c)
Out[571]: 
                   0         1
2002-01-02  0.007717  1.168386
2002-01-03  0.759328 -0.638934
2002-01-04 -1.154018 -0.324071
2002-01-05 -0.804551 -1.280593
2002-01-06 -0.047208  1.260503
...              ...       ...
2002-09-22 -1.139583  0.344316
2002-09-23 -0.760643 -1.306704
2002-09-24  0.059018  1.775482
2002-09-25  1.242255 -0.055457
2002-09-26  0.410317  2.194489

[268 rows x 2 columns]
</pre></div> </div> </section> <section id="selecting-using-a-where-mask"> <h5>Selecting using a where mask</h5> <p>Sometime your query can involve creating a list of rows to select. Usually this <code class="docutils literal notranslate"><span class="pre">mask</span></code> would be a resulting <code class="docutils literal notranslate"><span class="pre">index</span></code> from an indexing operation. This example selects the months of a datetimeindex which are 5.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [572]: df_mask = pd.DataFrame(
   .....:     np.random.randn(1000, 2), index=pd.date_range("20000101", periods=1000)
   .....: )
   .....: 

In [573]: store.append("df_mask", df_mask)

In [574]: c = store.select_column("df_mask", "index")

In [575]: where = c[pd.DatetimeIndex(c).month == 5].index

In [576]: store.select("df_mask", where=where)
Out[576]: 
                   0         1
2000-05-01  1.479511  0.516433
2000-05-02 -0.334984 -1.493537
2000-05-03  0.900321  0.049695
2000-05-04  0.614266 -1.077151
2000-05-05  0.233881  0.493246
...              ...       ...
2002-05-27  0.294122  0.457407
2002-05-28 -1.102535  1.215650
2002-05-29 -0.432911  0.753606
2002-05-30 -1.105212  2.311877
2002-05-31  2.567296  2.610691

[93 rows x 2 columns]
</pre></div> </div> </section> <section id="storer-object"> <h5>Storer object</h5> <p>If you want to inspect the stored object, retrieve via <code class="docutils literal notranslate"><span class="pre">get_storer</span></code>. You could use this programmatically to say get the number of rows in an object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [577]: store.get_storer("df_dc").nrows
Out[577]: 8
</pre></div> </div> </section> </section> <section id="multiple-table-queries"> <h4>Multiple table queries</h4> <p>The methods <code class="docutils literal notranslate"><span class="pre">append_to_multiple</span></code> and <code class="docutils literal notranslate"><span class="pre">select_as_multiple</span></code> can perform appending/selecting from multiple tables at once. The idea is to have one table (call it the selector table) that you index most/all of the columns, and perform your queries. The other table(s) are data tables with an index matching the selector table’s index. You can then perform a very fast query on the selector table, yet get lots of data back. This method is similar to having a very wide table, but enables more efficient queries.</p> <p>The <code class="docutils literal notranslate"><span class="pre">append_to_multiple</span></code> method splits a given single DataFrame into multiple tables according to <code class="docutils literal notranslate"><span class="pre">d</span></code>, a dictionary that maps the table names to a list of ‘columns’ you want in that table. If <code class="docutils literal notranslate"><span class="pre">None</span></code> is used in place of a list, that table will have the remaining unspecified columns of the given DataFrame. The argument <code class="docutils literal notranslate"><span class="pre">selector</span></code> defines which table is the selector table (which you can make queries from). The argument <code class="docutils literal notranslate"><span class="pre">dropna</span></code> will drop rows from the input <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to ensure tables are synchronized. This means that if a row for one of the tables being written to is entirely <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, that row will be dropped from all tables.</p> <p>If <code class="docutils literal notranslate"><span class="pre">dropna</span></code> is False, <strong>THE USER IS RESPONSIBLE FOR SYNCHRONIZING THE TABLES</strong>. Remember that entirely <code class="docutils literal notranslate"><span class="pre">np.Nan</span></code> rows are not written to the HDFStore, so if you choose to call <code class="docutils literal notranslate"><span class="pre">dropna=False</span></code>, some tables may have more rows than others, and therefore <code class="docutils literal notranslate"><span class="pre">select_as_multiple</span></code> may not work or it may return unexpected results.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [578]: df_mt = pd.DataFrame(
   .....:     np.random.randn(8, 6),
   .....:     index=pd.date_range("1/1/2000", periods=8),
   .....:     columns=["A", "B", "C", "D", "E", "F"],
   .....: )
   .....: 

In [579]: df_mt["foo"] = "bar"

In [580]: df_mt.loc[df_mt.index[1], ("A", "B")] = np.nan

# you can also create the tables individually
In [581]: store.append_to_multiple(
   .....:     {"df1_mt": ["A", "B"], "df2_mt": None}, df_mt, selector="df1_mt"
   .....: )
   .....: 

In [582]: store
Out[582]: 
&lt;class 'pandas.io.pytables.HDFStore'&gt;
File path: store.h5

# individual tables were created
In [583]: store.select("df1_mt")
Out[583]: 
                   A         B
2000-01-01  0.162291 -0.430489
2000-01-02       NaN       NaN
2000-01-03  0.429207 -1.099274
2000-01-04  1.869081 -1.466039
2000-01-05  0.092130 -1.726280
2000-01-06  0.266901 -0.036854
2000-01-07 -0.517871 -0.990317
2000-01-08 -0.231342  0.557402

In [584]: store.select("df2_mt")
Out[584]: 
                   C         D         E         F  foo
2000-01-01 -2.502042  0.668149  0.460708  1.834518  bar
2000-01-02  0.130441 -0.608465  0.439872  0.506364  bar
2000-01-03 -1.069546  1.236277  0.116634 -1.772519  bar
2000-01-04  0.137462  0.313939  0.748471 -0.943009  bar
2000-01-05  0.836517  2.049798  0.562167  0.189952  bar
2000-01-06  1.112750 -0.151596  1.503311  0.939470  bar
2000-01-07 -0.294348  0.335844 -0.794159  1.495614  bar
2000-01-08  0.860312 -0.538674 -0.541986 -1.759606  bar

# as a multiple
In [585]: store.select_as_multiple(
   .....:     ["df1_mt", "df2_mt"],
   .....:     where=["A&gt;0", "B&gt;0"],
   .....:     selector="df1_mt",
   .....: )
   .....: 
Out[585]: 
Empty DataFrame
Columns: [A, B, C, D, E, F, foo]
Index: []
</pre></div> </div> </section> </section> <section id="delete-from-a-table"> <h3>Delete from a table</h3> <p>You can delete from a table selectively by specifying a <code class="docutils literal notranslate"><span class="pre">where</span></code>. In deleting rows, it is important to understand the <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> deletes rows by erasing the rows, then <strong>moving</strong> the following data. Thus deleting can potentially be a very expensive operation depending on the orientation of your data. To get optimal performance, it’s worthwhile to have the dimension you are deleting be the first of the <code class="docutils literal notranslate"><span class="pre">indexables</span></code>.</p> <p>Data is ordered (on the disk) in terms of the <code class="docutils literal notranslate"><span class="pre">indexables</span></code>. Here’s a simple use case. You store panel-type data, with dates in the <code class="docutils literal notranslate"><span class="pre">major_axis</span></code> and ids in the <code class="docutils literal notranslate"><span class="pre">minor_axis</span></code>. The data is then interleaved like this:</p> <ul class="simple"> <li>
<dl class="simple"> <dt>date_1</dt>
<dd>
<ul> <li><p>id_1</p></li> <li><p>id_2</p></li> <li><p>.</p></li> <li><p>id_n</p></li> </ul> </dd> </dl> </li> <li>
<dl class="simple"> <dt>date_2</dt>
<dd>
<ul> <li><p>id_1</p></li> <li><p>.</p></li> <li><p>id_n</p></li> </ul> </dd> </dl> </li> </ul> <p>It should be clear that a delete operation on the <code class="docutils literal notranslate"><span class="pre">major_axis</span></code> will be fairly quick, as one chunk is removed, then the following data moved. On the other hand a delete operation on the <code class="docutils literal notranslate"><span class="pre">minor_axis</span></code> will be very expensive. In this case it would almost certainly be faster to rewrite the table using a <code class="docutils literal notranslate"><span class="pre">where</span></code> that selects all but the missing data.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Please note that HDF5 <strong>DOES NOT RECLAIM SPACE</strong> in the h5 files automatically. Thus, repeatedly deleting (or removing nodes) and adding again, <strong>WILL TEND TO INCREASE THE FILE SIZE</strong>.</p> <p>To <em>repack and clean</em> the file, use <a class="reference internal" href="#io-hdf5-ptrepack"><span class="std std-ref">ptrepack</span></a>.</p> </div> </section> <section id="notes-caveats"> <h3>Notes &amp; caveats</h3> <section id="compression"> <h4>Compression</h4> <p><code class="docutils literal notranslate"><span class="pre">PyTables</span></code> allows the stored data to be compressed. This applies to all kinds of stores, not just tables. Two parameters are used to control compression: <code class="docutils literal notranslate"><span class="pre">complevel</span></code> and <code class="docutils literal notranslate"><span class="pre">complib</span></code>.</p> <ul> <li><p><code class="docutils literal notranslate"><span class="pre">complevel</span></code> specifies if and how hard data is to be compressed. <code class="docutils literal notranslate"><span class="pre">complevel=0</span></code> and <code class="docutils literal notranslate"><span class="pre">complevel=None</span></code> disables compression and <code class="docutils literal notranslate"><span class="pre">0&lt;complevel&lt;10</span></code> enables compression.</p></li> <li>
<p><code class="docutils literal notranslate"><span class="pre">complib</span></code> specifies which compression library to use. If nothing is specified the default library <code class="docutils literal notranslate"><span class="pre">zlib</span></code> is used. A compression library usually optimizes for either good compression rates or speed and the results will depend on the type of data. Which type of compression to choose depends on your specific needs and data. The list of supported compression libraries:</p> <ul> <li><p><a class="reference external" href="https://zlib.net/">zlib</a>: The default compression library. A classic in terms of compression, achieves good compression rates but is somewhat slow.</p></li> <li><p><a class="reference external" href="https://www.oberhumer.com/opensource/lzo/">lzo</a>: Fast compression and decompression.</p></li> <li><p><a class="reference external" href="https://sourceware.org/bzip2/">bzip2</a>: Good compression rates.</p></li> <li>
<p><a class="reference external" href="https://www.blosc.org/">blosc</a>: Fast compression and decompression.</p> <p>Support for alternative blosc compressors:</p> <ul class="simple"> <li><p><a class="reference external" href="https://www.blosc.org/">blosc:blosclz</a> This is the default compressor for <code class="docutils literal notranslate"><span class="pre">blosc</span></code></p></li> <li><p><a class="reference external" href="https://fastcompression.blogspot.com/p/lz4.html">blosc:lz4</a>: A compact, very popular and fast compressor.</p></li> <li><p><a class="reference external" href="https://fastcompression.blogspot.com/p/lz4.html">blosc:lz4hc</a>: A tweaked version of LZ4, produces better compression ratios at the expense of speed.</p></li> <li><p><a class="reference external" href="https://google.github.io/snappy/">blosc:snappy</a>: A popular compressor used in many places.</p></li> <li><p><a class="reference external" href="https://zlib.net/">blosc:zlib</a>: A classic; somewhat slower than the previous ones, but achieving better compression ratios.</p></li> <li><p><a class="reference external" href="https://facebook.github.io/zstd/">blosc:zstd</a>: An extremely well balanced codec; it provides the best compression ratios among the others above, and at reasonably fast speed.</p></li> </ul> </li> </ul> <p>If <code class="docutils literal notranslate"><span class="pre">complib</span></code> is defined as something other than the listed libraries a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code> exception is issued.</p> </li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the library specified with the <code class="docutils literal notranslate"><span class="pre">complib</span></code> option is missing on your platform, compression defaults to <code class="docutils literal notranslate"><span class="pre">zlib</span></code> without further ado.</p> </div> <p>Enable compression for all objects within the file:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">store_compressed = pd.HDFStore(
    "store_compressed.h5", complevel=9, complib="blosc:blosclz"
)
</pre></div> </div> <p>Or on-the-fly compression (this only applies to tables) in stores where compression is not enabled:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">store.append("df", df, complib="zlib", complevel=5)
</pre></div> </div> </section> <section id="ptrepack"> <h4>ptrepack</h4> <p><code class="docutils literal notranslate"><span class="pre">PyTables</span></code> offers better write performance when tables are compressed after they are written, as opposed to turning on compression at the very beginning. You can use the supplied <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> utility <code class="docutils literal notranslate"><span class="pre">ptrepack</span></code>. In addition, <code class="docutils literal notranslate"><span class="pre">ptrepack</span></code> can change compression levels after the fact.</p> <div class="highlight-console notranslate">
<div class="highlight"><pre data-language="python">ptrepack --chunkshape=auto --propindexes --complevel=9 --complib=blosc in.h5 out.h5
</pre></div> </div> <p>Furthermore <code class="docutils literal notranslate"><span class="pre">ptrepack</span> <span class="pre">in.h5</span> <span class="pre">out.h5</span></code> will <em>repack</em> the file to allow you to reuse previously deleted space. Alternatively, one can simply remove the file and write again, or use the <code class="docutils literal notranslate"><span class="pre">copy</span></code> method.</p> </section> <section id="caveats"> <h4>Caveats</h4> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> is <strong>not-threadsafe for writing</strong>. The underlying <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> only supports concurrent reads (via threading or processes). If you need reading and writing <em>at the same time</em>, you need to serialize these operations in a single thread in a single process. You will corrupt your data otherwise. See the (<a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2397">GH 2397</a>) for more information.</p> </div> <ul class="simple"> <li><p>If you use locks to manage write access between multiple processes, you may want to use <a class="reference external" href="https://docs.python.org/3/library/os.html#os.fsync" title="(in Python v3.12)"><code class="xref py py-func docutils literal notranslate"><span class="pre">fsync()</span></code></a> before releasing write locks. For convenience you can use <code class="docutils literal notranslate"><span class="pre">store.flush(fsync=True)</span></code> to do this for you.</p></li> <li><p>Once a <code class="docutils literal notranslate"><span class="pre">table</span></code> is created columns (DataFrame) are fixed; only exactly the same columns can be appended</p></li> <li><p>Be aware that timezones (e.g., <code class="docutils literal notranslate"><span class="pre">pytz.timezone('US/Eastern')</span></code>) are not necessarily equal across timezone versions. So if data is localized to a specific timezone in the HDFStore using one version of a timezone library and that data is updated with another version, the data will be converted to UTC since these timezones are not considered equal. Either use the same version of timezone library or use <code class="docutils literal notranslate"><span class="pre">tz_convert</span></code> with the updated timezone definition.</p></li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code class="docutils literal notranslate"><span class="pre">PyTables</span></code> will show a <code class="docutils literal notranslate"><span class="pre">NaturalNameWarning</span></code> if a column name cannot be used as an attribute selector. <em>Natural</em> identifiers contain only letters, numbers, and underscores, and may not begin with a number. Other identifiers cannot be used in a <code class="docutils literal notranslate"><span class="pre">where</span></code> clause and are generally a bad idea.</p> </div> </section> </section> <section id="datatypes"> <h3>DataTypes</h3> <p><code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> will map an object dtype to the <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> underlying dtype. This means the following types are known to work:</p> <table class="table"> <thead> <tr class="row-odd">
<th class="head"><p>Type</p></th> <th class="head"><p>Represents missing values</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>floating : <code class="docutils literal notranslate"><span class="pre">float64,</span> <span class="pre">float32,</span> <span class="pre">float16</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">np.nan</span></code></p></td> </tr> <tr class="row-odd">
<td><p>integer : <code class="docutils literal notranslate"><span class="pre">int64,</span> <span class="pre">int32,</span> <span class="pre">int8,</span> <span class="pre">uint64,uint32,</span> <span class="pre">uint8</span></code></p></td> <td></td> </tr> <tr class="row-even">
<td><p>boolean</p></td> <td></td> </tr> <tr class="row-odd">
<td><p><code class="docutils literal notranslate"><span class="pre">datetime64[ns]</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">NaT</span></code></p></td> </tr> <tr class="row-even">
<td><p><code class="docutils literal notranslate"><span class="pre">timedelta64[ns]</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">NaT</span></code></p></td> </tr> <tr class="row-odd">
<td><p>categorical : see the section below</p></td> <td></td> </tr> <tr class="row-even">
<td><p>object : <code class="docutils literal notranslate"><span class="pre">strings</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">np.nan</span></code></p></td> </tr> </tbody> </table> <p><code class="docutils literal notranslate"><span class="pre">unicode</span></code> columns are not supported, and <strong>WILL FAIL</strong>.</p> <section id="categorical-data"> <h4>Categorical data</h4> <p>You can write data that contains <code class="docutils literal notranslate"><span class="pre">category</span></code> dtypes to a <code class="docutils literal notranslate"><span class="pre">HDFStore</span></code>. Queries work the same as if it was an object array. However, the <code class="docutils literal notranslate"><span class="pre">category</span></code> dtyped data is stored in a more efficient manner.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [586]: dfcat = pd.DataFrame(
   .....:     {"A": pd.Series(list("aabbcdba")).astype("category"), "B": np.random.randn(8)}
   .....: )
   .....: 

In [587]: dfcat
Out[587]: 
   A         B
0  a -1.520478
1  a -1.069391
2  b -0.551981
3  b  0.452407
4  c  0.409257
5  d  0.301911
6  b -0.640843
7  a -2.253022

In [588]: dfcat.dtypes
Out[588]: 
A    category
B     float64
dtype: object

In [589]: cstore = pd.HDFStore("cats.h5", mode="w")

In [590]: cstore.append("dfcat", dfcat, format="table", data_columns=["A"])

In [591]: result = cstore.select("dfcat", where="A in ['b', 'c']")

In [592]: result
Out[592]: 
   A         B
2  b -0.551981
3  b  0.452407
4  c  0.409257
6  b -0.640843

In [593]: result.dtypes
Out[593]: 
A    category
B     float64
dtype: object
</pre></div> </div> </section> <section id="string-columns"> <h4>String columns</h4> <p><strong>min_itemsize</strong></p> <p>The underlying implementation of <code class="docutils literal notranslate"><span class="pre">HDFStore</span></code> uses a fixed column width (itemsize) for string columns. A string column itemsize is calculated as the maximum of the length of data (for that column) that is passed to the <code class="docutils literal notranslate"><span class="pre">HDFStore</span></code>, <strong>in the first append</strong>. Subsequent appends, may introduce a string for a column <strong>larger</strong> than the column can hold, an Exception will be raised (otherwise you could have a silent truncation of these columns, leading to loss of information). In the future we may relax this and allow a user-specified truncation to occur.</p> <p>Pass <code class="docutils literal notranslate"><span class="pre">min_itemsize</span></code> on the first table creation to a-priori specify the minimum length of a particular string column. <code class="docutils literal notranslate"><span class="pre">min_itemsize</span></code> can be an integer, or a dict mapping a column name to an integer. You can pass <code class="docutils literal notranslate"><span class="pre">values</span></code> as a key to allow all <em>indexables</em> or <em>data_columns</em> to have this min_itemsize.</p> <p>Passing a <code class="docutils literal notranslate"><span class="pre">min_itemsize</span></code> dict will cause all passed columns to be created as <em>data_columns</em> automatically.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are not passing any <code class="docutils literal notranslate"><span class="pre">data_columns</span></code>, then the <code class="docutils literal notranslate"><span class="pre">min_itemsize</span></code> will be the maximum of the length of any string passed</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [594]: dfs = pd.DataFrame({"A": "foo", "B": "bar"}, index=list(range(5)))

In [595]: dfs
Out[595]: 
     A    B
0  foo  bar
1  foo  bar
2  foo  bar
3  foo  bar
4  foo  bar

# A and B have a size of 30
In [596]: store.append("dfs", dfs, min_itemsize=30)

In [597]: store.get_storer("dfs").table
Out[597]: 
/dfs/table (Table(5,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": StringCol(itemsize=30, shape=(2,), dflt=b'', pos=1)}
  byteorder := 'little'
  chunkshape := (963,)
  autoindex := True
  colindexes := {
    "index": Index(6, mediumshuffle, zlib(1)).is_csi=False}

# A is created as a data_column with a size of 30
# B is size is calculated
In [598]: store.append("dfs2", dfs, min_itemsize={"A": 30})

In [599]: store.get_storer("dfs2").table
Out[599]: 
/dfs2/table (Table(5,)) ''
  description := {
  "index": Int64Col(shape=(), dflt=0, pos=0),
  "values_block_0": StringCol(itemsize=3, shape=(1,), dflt=b'', pos=1),
  "A": StringCol(itemsize=30, shape=(), dflt=b'', pos=2)}
  byteorder := 'little'
  chunkshape := (1598,)
  autoindex := True
  colindexes := {
    "index": Index(6, mediumshuffle, zlib(1)).is_csi=False,
    "A": Index(6, mediumshuffle, zlib(1)).is_csi=False}
</pre></div> </div> <p><strong>nan_rep</strong></p> <p>String columns will serialize a <code class="docutils literal notranslate"><span class="pre">np.nan</span></code> (a missing value) with the <code class="docutils literal notranslate"><span class="pre">nan_rep</span></code> string representation. This defaults to the string value <code class="docutils literal notranslate"><span class="pre">nan</span></code>. You could inadvertently turn an actual <code class="docutils literal notranslate"><span class="pre">nan</span></code> value into a missing value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [600]: dfss = pd.DataFrame({"A": ["foo", "bar", "nan"]})

In [601]: dfss
Out[601]: 
     A
0  foo
1  bar
2  nan

In [602]: store.append("dfss", dfss)

In [603]: store.select("dfss")
Out[603]: 
     A
0  foo
1  bar
2  NaN

# here you need to specify a different nan rep
In [604]: store.append("dfss2", dfss, nan_rep="_nan_")

In [605]: store.select("dfss2")
Out[605]: 
     A
0  foo
1  bar
2  nan
</pre></div> </div> </section> </section> <section id="performance"> <h3>Performance</h3> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">tables</span></code> format come with a writing performance penalty as compared to <code class="docutils literal notranslate"><span class="pre">fixed</span></code> stores. The benefit is the ability to append/delete and query (potentially very large amounts of data). Write times are generally longer as compared with regular stores. Query times can be quite fast, especially on an indexed axis.</p></li> <li><p>You can pass <code class="docutils literal notranslate"><span class="pre">chunksize=&lt;int&gt;</span></code> to <code class="docutils literal notranslate"><span class="pre">append</span></code>, specifying the write chunksize (default is 50000). This will significantly lower your memory usage on writing.</p></li> <li><p>You can pass <code class="docutils literal notranslate"><span class="pre">expectedrows=&lt;int&gt;</span></code> to the first <code class="docutils literal notranslate"><span class="pre">append</span></code>, to set the TOTAL number of rows that <code class="docutils literal notranslate"><span class="pre">PyTables</span></code> will expect. This will optimize read/write performance.</p></li> <li><p>Duplicate rows can be written to tables, but are filtered out in selection (with the last items being selected; thus a table is unique on major, minor pairs)</p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">PerformanceWarning</span></code> will be raised if you are attempting to store types that will be pickled by PyTables (rather than stored as endemic types). See <a class="reference external" href="https://stackoverflow.com/questions/14355151/how-to-make-pandas-hdfstore-put-operation-faster/14370190#14370190">Here</a> for more information and some solutions.</p></li> </ul> </section> </section> <section id="feather"> <h2>Feather</h2> <p>Feather provides binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy.</p> <p>Feather is designed to faithfully serialize and de-serialize DataFrames, supporting all of the pandas dtypes, including extension dtypes such as categorical and datetime with tz.</p> <p>Several caveats:</p> <ul class="simple"> <li><p>The format will NOT write an <code class="docutils literal notranslate"><span class="pre">Index</span></code>, or <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> for the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> and will raise an error if a non-default one is provided. You can <code class="docutils literal notranslate"><span class="pre">.reset_index()</span></code> to store the index or <code class="docutils literal notranslate"><span class="pre">.reset_index(drop=True)</span></code> to ignore it.</p></li> <li><p>Duplicate column names and non-string columns names are not supported</p></li> <li><p>Actual Python objects in object dtype columns are not supported. These will raise a helpful error message on an attempt at serialization.</p></li> </ul> <p>See the <a class="reference external" href="https://github.com/wesm/feather">Full Documentation</a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [606]: df = pd.DataFrame(
   .....:     {
   .....:         "a": list("abc"),
   .....:         "b": list(range(1, 4)),
   .....:         "c": np.arange(3, 6).astype("u1"),
   .....:         "d": np.arange(4.0, 7.0, dtype="float64"),
   .....:         "e": [True, False, True],
   .....:         "f": pd.Categorical(list("abc")),
   .....:         "g": pd.date_range("20130101", periods=3),
   .....:         "h": pd.date_range("20130101", periods=3, tz="US/Eastern"),
   .....:         "i": pd.date_range("20130101", periods=3, freq="ns"),
   .....:     }
   .....: )
   .....: 

In [607]: df
Out[607]: 
   a  b  c  ...          g                         h                             i
0  a  1  3  ... 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00.000000000
1  b  2  4  ... 2013-01-02 2013-01-02 00:00:00-05:00 2013-01-01 00:00:00.000000001
2  c  3  5  ... 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-01 00:00:00.000000002

[3 rows x 9 columns]

In [608]: df.dtypes
Out[608]: 
a                        object
b                         int64
c                         uint8
d                       float64
e                          bool
f                      category
g                datetime64[ns]
h    datetime64[ns, US/Eastern]
i                datetime64[ns]
dtype: object
</pre></div> </div> <p>Write to a feather file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [609]: df.to_feather("example.feather")
</pre></div> </div> <p>Read from a feather file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [610]: result = pd.read_feather("example.feather")

In [611]: result
Out[611]: 
   a  b  c  ...          g                         h                             i
0  a  1  3  ... 2013-01-01 2013-01-01 00:00:00-05:00 2013-01-01 00:00:00.000000000
1  b  2  4  ... 2013-01-02 2013-01-02 00:00:00-05:00 2013-01-01 00:00:00.000000001
2  c  3  5  ... 2013-01-03 2013-01-03 00:00:00-05:00 2013-01-01 00:00:00.000000002

[3 rows x 9 columns]

# we preserve dtypes
In [612]: result.dtypes
Out[612]: 
a                        object
b                         int64
c                         uint8
d                       float64
e                          bool
f                      category
g                datetime64[ns]
h    datetime64[ns, US/Eastern]
i                datetime64[ns]
dtype: object
</pre></div> </div> </section> <section id="parquet"> <h2>Parquet</h2> <p><a class="reference external" href="https://parquet.apache.org/">Apache Parquet</a> provides a partitioned binary columnar serialization for data frames. It is designed to make reading and writing data frames efficient, and to make sharing data across data analysis languages easy. Parquet can use a variety of compression techniques to shrink the file size as much as possible while still maintaining good read performance.</p> <p>Parquet is designed to faithfully serialize and de-serialize <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> s, supporting all of the pandas dtypes, including extension dtypes such as datetime with tz.</p> <p>Several caveats.</p> <ul class="simple"> <li><p>Duplicate column names and non-string columns names are not supported.</p></li> <li><p>The <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> engine always writes the index to the output, but <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code> only writes non-default indexes. This extra column can cause problems for non-pandas consumers that are not expecting it. You can force including or omitting indexes with the <code class="docutils literal notranslate"><span class="pre">index</span></code> argument, regardless of the underlying engine.</p></li> <li><p>Index level names, if specified, must be strings.</p></li> <li><p>In the <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> engine, categorical dtypes for non-string types can be serialized to parquet, but will de-serialize as their primitive dtype.</p></li> <li><p>The <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> engine preserves the <code class="docutils literal notranslate"><span class="pre">ordered</span></code> flag of categorical dtypes with string types. <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code> does not preserve the <code class="docutils literal notranslate"><span class="pre">ordered</span></code> flag.</p></li> <li><p>Non supported types include <code class="docutils literal notranslate"><span class="pre">Interval</span></code> and actual Python object types. These will raise a helpful error message on an attempt at serialization. <code class="docutils literal notranslate"><span class="pre">Period</span></code> type is supported with pyarrow &gt;= 0.16.0.</p></li> <li><p>The <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> engine preserves extension data types such as the nullable integer and string data type (requiring pyarrow &gt;= 0.16.0, and requiring the extension type to implement the needed protocols, see the <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/2.2.2/development/extending.html#extending-extension-arrow"><span class="std std-ref">extension types documentation</span></a>).</p></li> </ul> <p>You can specify an <code class="docutils literal notranslate"><span class="pre">engine</span></code> to direct the serialization. This can be one of <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code>, or <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code>, or <code class="docutils literal notranslate"><span class="pre">auto</span></code>. If the engine is NOT specified, then the <code class="docutils literal notranslate"><span class="pre">pd.options.io.parquet.engine</span></code> option is checked; if this is also <code class="docutils literal notranslate"><span class="pre">auto</span></code>, then <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> is tried, and falling back to <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code>.</p> <p>See the documentation for <a class="reference external" href="https://arrow.apache.org/docs/python/">pyarrow</a> and <a class="reference external" href="https://fastparquet.readthedocs.io/en/latest/">fastparquet</a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These engines are very similar and should read/write nearly identical parquet format files. <code class="docutils literal notranslate"><span class="pre">pyarrow&gt;=8.0.0</span></code> supports timedelta data, <code class="docutils literal notranslate"><span class="pre">fastparquet&gt;=0.1.4</span></code> supports timezone aware datetimes. These libraries differ by having different underlying dependencies (<code class="docutils literal notranslate"><span class="pre">fastparquet</span></code> by using <code class="docutils literal notranslate"><span class="pre">numba</span></code>, while <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> uses a c-library).</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [613]: df = pd.DataFrame(
   .....:     {
   .....:         "a": list("abc"),
   .....:         "b": list(range(1, 4)),
   .....:         "c": np.arange(3, 6).astype("u1"),
   .....:         "d": np.arange(4.0, 7.0, dtype="float64"),
   .....:         "e": [True, False, True],
   .....:         "f": pd.date_range("20130101", periods=3),
   .....:         "g": pd.date_range("20130101", periods=3, tz="US/Eastern"),
   .....:         "h": pd.Categorical(list("abc")),
   .....:         "i": pd.Categorical(list("abc"), ordered=True),
   .....:     }
   .....: )
   .....: 

In [614]: df
Out[614]: 
   a  b  c    d      e          f                         g  h  i
0  a  1  3  4.0   True 2013-01-01 2013-01-01 00:00:00-05:00  a  a
1  b  2  4  5.0  False 2013-01-02 2013-01-02 00:00:00-05:00  b  b
2  c  3  5  6.0   True 2013-01-03 2013-01-03 00:00:00-05:00  c  c

In [615]: df.dtypes
Out[615]: 
a                        object
b                         int64
c                         uint8
d                       float64
e                          bool
f                datetime64[ns]
g    datetime64[ns, US/Eastern]
h                      category
i                      category
dtype: object
</pre></div> </div> <p>Write to a parquet file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [616]: df.to_parquet("example_pa.parquet", engine="pyarrow")

In [617]: df.to_parquet("example_fp.parquet", engine="fastparquet")
</pre></div> </div> <p>Read from a parquet file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [618]: result = pd.read_parquet("example_fp.parquet", engine="fastparquet")

In [619]: result = pd.read_parquet("example_pa.parquet", engine="pyarrow")

In [620]: result.dtypes
Out[620]: 
a                        object
b                         int64
c                         uint8
d                       float64
e                          bool
f                datetime64[ns]
g    datetime64[ns, US/Eastern]
h                      category
i                      category
dtype: object
</pre></div> </div> <p>By setting the <code class="docutils literal notranslate"><span class="pre">dtype_backend</span></code> argument you can control the default dtypes used for the resulting DataFrame.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [621]: result = pd.read_parquet("example_pa.parquet", engine="pyarrow", dtype_backend="pyarrow")

In [622]: result.dtypes
Out[622]: 
a                                      string[pyarrow]
b                                       int64[pyarrow]
c                                       uint8[pyarrow]
d                                      double[pyarrow]
e                                        bool[pyarrow]
f                               timestamp[ns][pyarrow]
g                timestamp[ns, tz=US/Eastern][pyarrow]
h    dictionary&lt;values=string, indices=int32, order...
i    dictionary&lt;values=string, indices=int32, order...
dtype: object
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Note that this is not supported for <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code>.</p> </div> <p>Read only certain columns of a parquet file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [623]: result = pd.read_parquet(
   .....:     "example_fp.parquet",
   .....:     engine="fastparquet",
   .....:     columns=["a", "b"],
   .....: )
   .....: 

In [624]: result = pd.read_parquet(
   .....:     "example_pa.parquet",
   .....:     engine="pyarrow",
   .....:     columns=["a", "b"],
   .....: )
   .....: 

In [625]: result.dtypes
Out[625]: 
a    object
b     int64
dtype: object
</pre></div> </div> <section id="handling-indexes"> <h3>Handling indexes</h3> <p>Serializing a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> to parquet may include the implicit index as one or more columns in the output file. Thus, this code:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [626]: df = pd.DataFrame({"a": [1, 2], "b": [3, 4]})

In [627]: df.to_parquet("test.parquet", engine="pyarrow")
</pre></div> </div> <p>creates a parquet file with <em>three</em> columns if you use <code class="docutils literal notranslate"><span class="pre">pyarrow</span></code> for serialization: <code class="docutils literal notranslate"><span class="pre">a</span></code>, <code class="docutils literal notranslate"><span class="pre">b</span></code>, and <code class="docutils literal notranslate"><span class="pre">__index_level_0__</span></code>. If you’re using <code class="docutils literal notranslate"><span class="pre">fastparquet</span></code>, the index <a class="reference external" href="https://fastparquet.readthedocs.io/en/latest/api.html#fastparquet.write">may or may not</a> be written to the file.</p> <p>This unexpected extra column causes some databases like Amazon Redshift to reject the file, because that column doesn’t exist in the target table.</p> <p>If you want to omit a dataframe’s indexes when writing, pass <code class="docutils literal notranslate"><span class="pre">index=False</span></code> to <a class="reference internal" href="../reference/api/pandas.dataframe.to_parquet.html#pandas.DataFrame.to_parquet" title="pandas.DataFrame.to_parquet"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_parquet()</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [628]: df.to_parquet("test.parquet", index=False)
</pre></div> </div> <p>This creates a parquet file with just the two expected columns, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>. If your <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> has a custom index, you won’t get it back when you load this file into a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <p>Passing <code class="docutils literal notranslate"><span class="pre">index=True</span></code> will <em>always</em> write the index, even if that’s not the underlying engine’s default behavior.</p> </section> <section id="partitioning-parquet-files"> <h3>Partitioning Parquet files</h3> <p>Parquet supports partitioning of data based on the values of one or more columns.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [629]: df = pd.DataFrame({"a": [0, 0, 1, 1], "b": [0, 1, 0, 1]})

In [630]: df.to_parquet(path="test", engine="pyarrow", partition_cols=["a"], compression=None)
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">path</span></code> specifies the parent directory to which data will be saved. The <code class="docutils literal notranslate"><span class="pre">partition_cols</span></code> are the column names by which the dataset will be partitioned. Columns are partitioned in the order they are given. The partition splits are determined by the unique values in the partition columns. The above example creates a partitioned dataset that may look like:</p> <div class="highlight-text notranslate">
<div class="highlight"><pre data-language="python">test
├── a=0
│   ├── 0bac803e32dc42ae83fddfd029cbdebc.parquet
│   └──  ...
└── a=1
    ├── e6ab24a4f45147b49b54a662f0c412a3.parquet
    └── ...
</pre></div> </div> </section> </section> <section id="orc"> <h2>ORC</h2> <p>Similar to the <a class="reference internal" href="#io-parquet"><span class="std std-ref">parquet</span></a> format, the <a class="reference external" href="https://orc.apache.org/">ORC Format</a> is a binary columnar serialization for data frames. It is designed to make reading data frames efficient. pandas provides both the reader and the writer for the ORC format, <a class="reference internal" href="../reference/api/pandas.read_orc.html#pandas.read_orc" title="pandas.read_orc"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_orc()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.to_orc.html#pandas.DataFrame.to_orc" title="pandas.DataFrame.to_orc"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_orc()</span></code></a>. This requires the <a class="reference external" href="https://arrow.apache.org/docs/python/">pyarrow</a> library.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <ul class="simple"> <li><p>It is <em>highly recommended</em> to install pyarrow using conda due to some issues occurred by pyarrow.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.dataframe.to_orc.html#pandas.DataFrame.to_orc" title="pandas.DataFrame.to_orc"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_orc()</span></code></a> requires pyarrow&gt;=7.0.0.</p></li> <li><p><a class="reference internal" href="../reference/api/pandas.read_orc.html#pandas.read_orc" title="pandas.read_orc"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_orc()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.to_orc.html#pandas.DataFrame.to_orc" title="pandas.DataFrame.to_orc"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_orc()</span></code></a> are not supported on Windows yet, you can find valid environments on <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/2.2.2/getting_started/install.html#install-warn-orc"><span class="std std-ref">install optional dependencies</span></a>.</p></li> <li><p>For supported dtypes please refer to <a class="reference external" href="https://arrow.apache.org/docs/cpp/orc.html#data-types">supported ORC features in Arrow</a>.</p></li> <li><p>Currently timezones in datetime columns are not preserved when a dataframe is converted into ORC files.</p></li> </ul> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [631]: df = pd.DataFrame(
   .....:     {
   .....:         "a": list("abc"),
   .....:         "b": list(range(1, 4)),
   .....:         "c": np.arange(4.0, 7.0, dtype="float64"),
   .....:         "d": [True, False, True],
   .....:         "e": pd.date_range("20130101", periods=3),
   .....:     }
   .....: )
   .....: 

In [632]: df
Out[632]: 
   a  b    c      d          e
0  a  1  4.0   True 2013-01-01
1  b  2  5.0  False 2013-01-02
2  c  3  6.0   True 2013-01-03

In [633]: df.dtypes
Out[633]: 
a            object
b             int64
c           float64
d              bool
e    datetime64[ns]
dtype: object
</pre></div> </div> <p>Write to an orc file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [634]: df.to_orc("example_pa.orc", engine="pyarrow")
</pre></div> </div> <p>Read from an orc file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [635]: result = pd.read_orc("example_pa.orc")

In [636]: result.dtypes
Out[636]: 
a            object
b             int64
c           float64
d              bool
e    datetime64[ns]
dtype: object
</pre></div> </div> <p>Read only certain columns of an orc file.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [637]: result = pd.read_orc(
   .....:     "example_pa.orc",
   .....:     columns=["a", "b"],
   .....: )
   .....: 

In [638]: result.dtypes
Out[638]: 
a    object
b     int64
dtype: object
</pre></div> </div> </section> <section id="sql-queries"> <h2>SQL queries</h2> <p>The <code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas.io.sql</span></code> module provides a collection of query wrappers to both facilitate data retrieval and to reduce dependency on DB-specific API.</p> <p>Where available, users may first want to opt for <a class="reference external" href="https://arrow.apache.org/adbc/current/index.html">Apache Arrow ADBC</a> drivers. These drivers should provide the best performance, null handling, and type detection.</p> <blockquote> <div>
<div class="versionadded"> <p><span class="versionmodified added">New in version 2.2.0: </span>Added native support for ADBC drivers</p> </div> </div>
</blockquote> <p>For a full list of ADBC drivers and their development status, see the <a class="reference external" href="https://arrow.apache.org/adbc/current/driver/status.html">ADBC Driver Implementation Status</a> documentation.</p> <p>Where an ADBC driver is not available or may be missing functionality, users should opt for installing SQLAlchemy alongside their database driver library. Examples of such drivers are <a class="reference external" href="https://www.psycopg.org/">psycopg2</a> for PostgreSQL or <a class="reference external" href="https://github.com/PyMySQL/PyMySQL">pymysql</a> for MySQL. For <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html">SQLite</a> this is included in Python’s standard library by default. You can find an overview of supported drivers for each SQL dialect in the <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/dialects/index.html">SQLAlchemy docs</a>.</p> <p>If SQLAlchemy is not installed, you can use a <a class="reference external" href="https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection" title="(in Python v3.12)"><code class="xref py py-class docutils literal notranslate"><span class="pre">sqlite3.Connection</span></code></a> in place of a SQLAlchemy engine, connection, or URI string.</p> <p>See also some <a class="reference internal" href="cookbook.html#cookbook-sql"><span class="std std-ref">cookbook examples</span></a> for some advanced strategies.</p> <p>The key functions are:</p> <table class="autosummary longtable table autosummary"> <tbody> <tr class="row-odd">
<td><p><a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_sql_table</span></code></a>(table_name, con[, schema, ...])</p></td> <td><p>Read SQL database table into a DataFrame.</p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="../reference/api/pandas.read_sql_query.html#pandas.read_sql_query" title="pandas.read_sql_query"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_sql_query</span></code></a>(sql, con[, index_col, ...])</p></td> <td><p>Read SQL query into a DataFrame.</p></td> </tr> <tr class="row-odd">
<td><p><a class="reference internal" href="../reference/api/pandas.read_sql.html#pandas.read_sql" title="pandas.read_sql"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read_sql</span></code></a>(sql, con[, index_col, ...])</p></td> <td><p>Read SQL query or database table into a DataFrame.</p></td> </tr> <tr class="row-even">
<td><p><a class="reference internal" href="../reference/api/pandas.dataframe.to_sql.html#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.to_sql</span></code></a>(name, con, *[, schema, ...])</p></td> <td><p>Write records stored in a DataFrame to a SQL database.</p></td> </tr> </tbody> </table> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The function <a class="reference internal" href="../reference/api/pandas.read_sql.html#pandas.read_sql" title="pandas.read_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql()</span></code></a> is a convenience wrapper around <a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_table()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.read_sql_query.html#pandas.read_sql_query" title="pandas.read_sql_query"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_query()</span></code></a> (and for backward compatibility) and will delegate to specific function depending on the provided input (database table name or sql query). Table names do not need to be quoted if they have special characters.</p> </div> <p>In the following example, we use the <a class="reference external" href="https://www.sqlite.org/index.html">SQlite</a> SQL database engine. You can use a temporary SQLite database where data are stored in “memory”.</p> <p>To connect using an ADBC driver you will want to install the <code class="docutils literal notranslate"><span class="pre">adbc_driver_sqlite</span></code> using your package manager. Once installed, you can use the DBAPI interface provided by the ADBC driver to connect to your database.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">import adbc_driver_sqlite.dbapi as sqlite_dbapi

# Create the connection
with sqlite_dbapi.connect("sqlite:///:memory:") as conn:
     df = pd.read_sql_table("data", conn)
</pre></div> </div> <p>To connect with SQLAlchemy you use the <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to. For more information on <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> and the URI formatting, see the examples below and the SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html">documentation</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [639]: from sqlalchemy import create_engine

# Create your engine.
In [640]: engine = create_engine("sqlite:///:memory:")
</pre></div> </div> <p>If you want to manage your own connections you can pass one of those instead. The example below opens a connection to the database using a Python context manager that automatically closes the connection after the block has completed. See the <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/connections.html#basic-usage">SQLAlchemy docs</a> for an explanation of how the database connection is handled.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">with engine.connect() as conn, conn.begin():
    data = pd.read_sql_table("data", conn)
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>When you open a connection to a database you are also responsible for closing it. Side effects of leaving a connection open may include locking the database or other breaking behaviour.</p> </div> <section id="writing-dataframes"> <h3>Writing DataFrames</h3> <p>Assuming the following data is in a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> <code class="docutils literal notranslate"><span class="pre">data</span></code>, we can insert it into the database using <a class="reference internal" href="../reference/api/pandas.dataframe.to_sql.html#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_sql()</span></code></a>.</p> <table class="table"> <thead> <tr class="row-odd">
<th class="head"><p>id</p></th> <th class="head"><p>Date</p></th> <th class="head"><p>Col_1</p></th> <th class="head"><p>Col_2</p></th> <th class="head"><p>Col_3</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>26</p></td> <td><p>2012-10-18</p></td> <td><p>X</p></td> <td><p>25.7</p></td> <td><p>True</p></td> </tr> <tr class="row-odd">
<td><p>42</p></td> <td><p>2012-10-19</p></td> <td><p>Y</p></td> <td><p>-12.4</p></td> <td><p>False</p></td> </tr> <tr class="row-even">
<td><p>63</p></td> <td><p>2012-10-20</p></td> <td><p>Z</p></td> <td><p>5.73</p></td> <td><p>True</p></td> </tr> </tbody> </table> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [641]: import datetime

In [642]: c = ["id", "Date", "Col_1", "Col_2", "Col_3"]

In [643]: d = [
   .....:     (26, datetime.datetime(2010, 10, 18), "X", 27.5, True),
   .....:     (42, datetime.datetime(2010, 10, 19), "Y", -12.5, False),
   .....:     (63, datetime.datetime(2010, 10, 20), "Z", 5.73, True),
   .....: ]
   .....: 

In [644]: data = pd.DataFrame(d, columns=c)

In [645]: data
Out[645]: 
   id       Date Col_1  Col_2  Col_3
0  26 2010-10-18     X  27.50   True
1  42 2010-10-19     Y -12.50  False
2  63 2010-10-20     Z   5.73   True

In [646]: data.to_sql("data", con=engine)
Out[646]: 3
</pre></div> </div> <p>With some databases, writing large DataFrames can result in errors due to packet size limitations being exceeded. This can be avoided by setting the <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> parameter when calling <code class="docutils literal notranslate"><span class="pre">to_sql</span></code>. For example, the following writes <code class="docutils literal notranslate"><span class="pre">data</span></code> to the database in batches of 1000 rows at a time:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [647]: data.to_sql("data_chunked", con=engine, chunksize=1000)
Out[647]: 3
</pre></div> </div> <section id="sql-data-types"> <h4>SQL data types</h4> <p>Ensuring consistent data type management across SQL databases is challenging. Not every SQL database offers the same types, and even when they do the implementation of a given type can vary in ways that have subtle effects on how types can be preserved.</p> <p>For the best odds at preserving database types users are advised to use ADBC drivers when available. The Arrow type system offers a wider array of types that more closely match database types than the historical pandas/NumPy type system. To illustrate, note this (non-exhaustive) listing of types available in different databases and pandas backends:</p> <table class="table"> <thead> <tr class="row-odd">
<th class="head"><p>numpy/pandas</p></th> <th class="head"><p>arrow</p></th> <th class="head"><p>postgres</p></th> <th class="head"><p>sqlite</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>int16/Int16</p></td> <td><p>int16</p></td> <td><p>SMALLINT</p></td> <td><p>INTEGER</p></td> </tr> <tr class="row-odd">
<td><p>int32/Int32</p></td> <td><p>int32</p></td> <td><p>INTEGER</p></td> <td><p>INTEGER</p></td> </tr> <tr class="row-even">
<td><p>int64/Int64</p></td> <td><p>int64</p></td> <td><p>BIGINT</p></td> <td><p>INTEGER</p></td> </tr> <tr class="row-odd">
<td><p>float32</p></td> <td><p>float32</p></td> <td><p>REAL</p></td> <td><p>REAL</p></td> </tr> <tr class="row-even">
<td><p>float64</p></td> <td><p>float64</p></td> <td><p>DOUBLE PRECISION</p></td> <td><p>REAL</p></td> </tr> <tr class="row-odd">
<td><p>object</p></td> <td><p>string</p></td> <td><p>TEXT</p></td> <td><p>TEXT</p></td> </tr> <tr class="row-even">
<td><p>bool</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">bool_</span></code></p></td> <td><p>BOOLEAN</p></td> <td></td> </tr> <tr class="row-odd">
<td><p>datetime64[ns]</p></td> <td><p>timestamp(us)</p></td> <td><p>TIMESTAMP</p></td> <td></td> </tr> <tr class="row-even">
<td><p>datetime64[ns,tz]</p></td> <td><p>timestamp(us,tz)</p></td> <td><p>TIMESTAMPTZ</p></td> <td></td> </tr> <tr class="row-odd">
<td></td> <td><p>date32</p></td> <td><p>DATE</p></td> <td></td> </tr> <tr class="row-even">
<td></td> <td><p>month_day_nano_interval</p></td> <td><p>INTERVAL</p></td> <td></td> </tr> <tr class="row-odd">
<td></td> <td><p>binary</p></td> <td><p>BINARY</p></td> <td><p>BLOB</p></td> </tr> <tr class="row-even">
<td></td> <td><p>decimal128</p></td> <td><p>DECIMAL <a class="footnote-reference brackets" href="#f1" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> </tr> <tr class="row-odd">
<td></td> <td><p>list</p></td> <td><p>ARRAY <a class="footnote-reference brackets" href="#f1" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p></td> <td></td> </tr> <tr class="row-even">
<td></td> <td><p>struct</p></td> <td>
<dl class="simple"> <dt>COMPOSITE TYPE</dt>
<dd>
<p><a class="footnote-reference brackets" href="#f1" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p> </dd> </dl> </td> <td></td> </tr> </tbody> </table> <p class="rubric">Footnotes</p> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="f1" role="doc-footnote"> <span class="label"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id6">2</a>,<a role="doc-backlink" href="#id7">3</a>)</span> <p>Not implemented as of writing, but theoretically possible</p> </aside> </aside> <p>If you are interested in preserving database types as best as possible throughout the lifecycle of your DataFrame, users are encouraged to leverage the <code class="docutils literal notranslate"><span class="pre">dtype_backend="pyarrow"</span></code> argument of <a class="reference internal" href="../reference/api/pandas.read_sql.html#pandas.read_sql" title="pandas.read_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql()</span></code></a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># for roundtripping
with pg_dbapi.connect(uri) as conn:
    df2 = pd.read_sql("pandas_table", conn, dtype_backend="pyarrow")
</pre></div> </div> <p>This will prevent your data from being converted to the traditional pandas/NumPy type system, which often converts SQL types in ways that make them impossible to round-trip.</p> <p>In case an ADBC driver is not available, <a class="reference internal" href="../reference/api/pandas.dataframe.to_sql.html#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_sql()</span></code></a> will try to map your data to an appropriate SQL data type based on the dtype of the data. When you have columns of dtype <code class="docutils literal notranslate"><span class="pre">object</span></code>, pandas will try to infer the data type.</p> <p>You can always override the default type by specifying the desired SQL type of any of the columns by using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> argument. This argument needs a dictionary mapping column names to SQLAlchemy types (or strings for the sqlite3 fallback mode). For example, specifying to use the sqlalchemy <code class="docutils literal notranslate"><span class="pre">String</span></code> type instead of the default <code class="docutils literal notranslate"><span class="pre">Text</span></code> type for string columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [648]: from sqlalchemy.types import String

In [649]: data.to_sql("data_dtype", con=engine, dtype={"Col_1": String})
Out[649]: 3
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Due to the limited support for timedelta’s in the different database flavors, columns with type <code class="docutils literal notranslate"><span class="pre">timedelta64</span></code> will be written as integer values as nanoseconds to the database and a warning will be raised. The only exception to this is when using the ADBC PostgreSQL driver in which case a timedelta will be written to the database as an <code class="docutils literal notranslate"><span class="pre">INTERVAL</span></code></p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Columns of <code class="docutils literal notranslate"><span class="pre">category</span></code> dtype will be converted to the dense representation as you would get with <code class="docutils literal notranslate"><span class="pre">np.asarray(categorical)</span></code> (e.g. for string categories this gives an array of strings). Because of this, reading the database table back in does <strong>not</strong> generate a categorical.</p> </div> </section> </section> <section id="datetime-data-types"> <h3>Datetime data types</h3> <p>Using ADBC or SQLAlchemy, <a class="reference internal" href="../reference/api/pandas.dataframe.to_sql.html#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_sql()</span></code></a> is capable of writing datetime data that is timezone naive or timezone aware. However, the resulting data stored in the database ultimately depends on the supported data type for datetime data of the database system being used.</p> <p>The following table lists supported data types for datetime data for some common databases. Other database dialects may have different data types for datetime data.</p> <table class="table"> <thead> <tr class="row-odd">
<th class="head"><p>Database</p></th> <th class="head"><p>SQL Datetime Types</p></th> <th class="head"><p>Timezone Support</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>SQLite</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">TEXT</span></code></p></td> <td><p>No</p></td> </tr> <tr class="row-odd">
<td><p>MySQL</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">TIMESTAMP</span></code> or <code class="docutils literal notranslate"><span class="pre">DATETIME</span></code></p></td> <td><p>No</p></td> </tr> <tr class="row-even">
<td><p>PostgreSQL</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">TIMESTAMP</span></code> or <code class="docutils literal notranslate"><span class="pre">TIMESTAMP</span> <span class="pre">WITH</span> <span class="pre">TIME</span> <span class="pre">ZONE</span></code></p></td> <td><p>Yes</p></td> </tr> </tbody> </table> <p>When writing timezone aware data to databases that do not support timezones, the data will be written as timezone naive timestamps that are in local time with respect to the timezone.</p> <p><a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_table()</span></code></a> is also capable of reading datetime data that is timezone aware or naive. When reading <code class="docutils literal notranslate"><span class="pre">TIMESTAMP</span> <span class="pre">WITH</span> <span class="pre">TIME</span> <span class="pre">ZONE</span></code> types, pandas will convert the data to UTC.</p> <section id="insertion-method"> <h4>Insertion method</h4> <p>The parameter <code class="docutils literal notranslate"><span class="pre">method</span></code> controls the SQL insertion clause used. Possible values are:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">None</span></code>: Uses standard SQL <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> clause (one per row).</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'multi'</span></code>: Pass multiple values in a single <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> clause. It uses a <em>special</em> SQL syntax not supported by all backends. This usually provides better performance for analytic databases like <em>Presto</em> and <em>Redshift</em>, but has worse performance for traditional SQL backend if the table contains many columns. For more information check the SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/dml.html#sqlalchemy.sql.expression.Insert.values.params.*args">documentation</a>.</p></li> <li><p>callable with signature <code class="docutils literal notranslate"><span class="pre">(pd_table,</span> <span class="pre">conn,</span> <span class="pre">keys,</span> <span class="pre">data_iter)</span></code>: This can be used to implement a more performant insertion method based on specific backend dialect features.</p></li> </ul> <p>Example of a callable using PostgreSQL <a class="reference external" href="https://www.postgresql.org/docs/current/sql-copy.html">COPY clause</a>:</p> <div class="highlight-default notranslate">
<div class="highlight"><pre data-language="python"># Alternative to_sql() *method* for DBs that support COPY FROM
import csv
from io import StringIO

def psql_insert_copy(table, conn, keys, data_iter):
    """
    Execute SQL statement inserting data

    Parameters
    ----------
    table : pandas.io.sql.SQLTable
    conn : sqlalchemy.engine.Engine or sqlalchemy.engine.Connection
    keys : list of str
        Column names
    data_iter : Iterable that iterates the values to be inserted
    """
    # gets a DBAPI connection that can provide a cursor
    dbapi_conn = conn.connection
    with dbapi_conn.cursor() as cur:
        s_buf = StringIO()
        writer = csv.writer(s_buf)
        writer.writerows(data_iter)
        s_buf.seek(0)

        columns = ', '.join(['"{}"'.format(k) for k in keys])
        if table.schema:
            table_name = '{}.{}'.format(table.schema, table.name)
        else:
            table_name = table.name

        sql = 'COPY {} ({}) FROM STDIN WITH CSV'.format(
            table_name, columns)
        cur.copy_expert(sql=sql, file=s_buf)
</pre></div> </div> </section> </section> <section id="reading-tables"> <h3>Reading tables</h3> <p><a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_table()</span></code></a> will read a database table given the table name and optionally a subset of columns to read.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In order to use <a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_table()</span></code></a>, you <strong>must</strong> have the ADBC driver or SQLAlchemy optional dependency installed.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [650]: pd.read_sql_table("data", engine)
Out[650]: 
   index  id       Date Col_1  Col_2  Col_3
0      0  26 2010-10-18     X  27.50   True
1      1  42 2010-10-19     Y -12.50  False
2      2  63 2010-10-20     Z   5.73   True
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>ADBC drivers will map database types directly back to arrow types. For other drivers note that pandas infers column dtypes from query outputs, and not by looking up data types in the physical database schema. For example, assume <code class="docutils literal notranslate"><span class="pre">userid</span></code> is an integer column in a table. Then, intuitively, <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">userid</span> <span class="pre">...</span></code> will return integer-valued series, while <code class="docutils literal notranslate"><span class="pre">select</span> <span class="pre">cast(userid</span> <span class="pre">as</span> <span class="pre">text)</span> <span class="pre">...</span></code> will return object-valued (str) series. Accordingly, if the query output is empty, then all resulting columns will be returned as object-valued (since they are most general). If you foresee that your query will sometimes generate an empty result, you may want to explicitly typecast afterwards to ensure dtype integrity.</p> </div> <p>You can also specify the name of the column as the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> index, and specify a subset of columns to be read.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [651]: pd.read_sql_table("data", engine, index_col="id")
Out[651]: 
    index       Date Col_1  Col_2  Col_3
id                                      
26      0 2010-10-18     X  27.50   True
42      1 2010-10-19     Y -12.50  False
63      2 2010-10-20     Z   5.73   True

In [652]: pd.read_sql_table("data", engine, columns=["Col_1", "Col_2"])
Out[652]: 
  Col_1  Col_2
0     X  27.50
1     Y -12.50
2     Z   5.73
</pre></div> </div> <p>And you can explicitly force columns to be parsed as dates:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [653]: pd.read_sql_table("data", engine, parse_dates=["Date"])
Out[653]: 
   index  id       Date Col_1  Col_2  Col_3
0      0  26 2010-10-18     X  27.50   True
1      1  42 2010-10-19     Y -12.50  False
2      2  63 2010-10-20     Z   5.73   True
</pre></div> </div> <p>If needed you can explicitly specify a format string, or a dict of arguments to pass to <a class="reference internal" href="../reference/api/pandas.to_datetime.html#pandas.to_datetime" title="pandas.to_datetime"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.to_datetime()</span></code></a>:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">pd.read_sql_table("data", engine, parse_dates={"Date": "%Y-%m-%d"})
pd.read_sql_table(
    "data",
    engine,
    parse_dates={"Date": {"format": "%Y-%m-%d %H:%M:%S"}},
)
</pre></div> </div> <p>You can check if a table exists using <code class="xref py py-func docutils literal notranslate"><span class="pre">has_table()</span></code></p> </section> <section id="schema-support"> <h3>Schema support</h3> <p>Reading from and writing to different schema’s is supported through the <code class="docutils literal notranslate"><span class="pre">schema</span></code> keyword in the <a class="reference internal" href="../reference/api/pandas.read_sql_table.html#pandas.read_sql_table" title="pandas.read_sql_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_table()</span></code></a> and <a class="reference internal" href="../reference/api/pandas.dataframe.to_sql.html#pandas.DataFrame.to_sql" title="pandas.DataFrame.to_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">to_sql()</span></code></a> functions. Note however that this depends on the database flavor (sqlite does not have schema’s). For example:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.to_sql(name="table", con=engine, schema="other_schema")
pd.read_sql_table("table", engine, schema="other_schema")
</pre></div> </div> </section> <section id="id8"> <h3>Querying</h3> <p>You can query using raw SQL in the <a class="reference internal" href="../reference/api/pandas.read_sql_query.html#pandas.read_sql_query" title="pandas.read_sql_query"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_query()</span></code></a> function. In this case you must use the SQL variant appropriate for your database. When using SQLAlchemy, you can also pass SQLAlchemy Expression language constructs, which are database-agnostic.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [654]: pd.read_sql_query("SELECT * FROM data", engine)
Out[654]: 
   index  id                        Date Col_1  Col_2  Col_3
0      0  26  2010-10-18 00:00:00.000000     X  27.50      1
1      1  42  2010-10-19 00:00:00.000000     Y -12.50      0
2      2  63  2010-10-20 00:00:00.000000     Z   5.73      1
</pre></div> </div> <p>Of course, you can specify a more “complex” query.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [655]: pd.read_sql_query("SELECT id, Col_1, Col_2 FROM data WHERE id = 42;", engine)
Out[655]: 
   id Col_1  Col_2
0  42     Y  -12.5
</pre></div> </div> <p>The <a class="reference internal" href="../reference/api/pandas.read_sql_query.html#pandas.read_sql_query" title="pandas.read_sql_query"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql_query()</span></code></a> function supports a <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> argument. Specifying this will return an iterator through chunks of the query result:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [656]: df = pd.DataFrame(np.random.randn(20, 3), columns=list("abc"))

In [657]: df.to_sql(name="data_chunks", con=engine, index=False)
Out[657]: 20
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [658]: for chunk in pd.read_sql_query("SELECT * FROM data_chunks", engine, chunksize=5):
   .....:     print(chunk)
   .....: 
          a         b         c
0 -0.395347 -0.822726 -0.363777
1  1.676124 -0.908102 -1.391346
2 -1.094269  0.278380  1.205899
3  1.503443  0.932171 -0.709459
4 -0.645944 -1.351389  0.132023
          a         b         c
0  0.210427  0.192202  0.661949
1  1.690629 -1.046044  0.618697
2 -0.013863  1.314289  1.951611
3 -1.485026  0.304662  1.194757
4 -0.446717  0.528496 -0.657575
          a         b         c
0 -0.876654  0.336252  0.172668
1  0.337684 -0.411202 -0.828394
2 -0.244413  1.094948  0.087183
3  1.125934 -1.480095  1.205944
4 -0.451849  0.452214 -2.208192
          a         b         c
0 -2.061019  0.044184 -0.017118
1  1.248959 -0.675595 -1.908296
2 -0.125934  1.491974  0.648726
3  0.391214  0.438609  1.634248
4  1.208707 -1.535740  1.620399
</pre></div> </div> </section> <section id="engine-connection-examples"> <h3>Engine connection examples</h3> <p>To connect with SQLAlchemy you use the <code class="xref py py-func docutils literal notranslate"><span class="pre">create_engine()</span></code> function to create an engine object from database URI. You only need to create the engine once per database you are connecting to.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">from sqlalchemy import create_engine

engine = create_engine("postgresql://scott:tiger@localhost:5432/mydatabase")

engine = create_engine("mysql+mysqldb://scott:tiger@localhost/foo")

engine = create_engine("oracle://scott:tiger@127.0.0.1:1521/sidname")

engine = create_engine("mssql+pyodbc://mydsn")

# sqlite://&lt;nohostname&gt;/&lt;path&gt;
# where &lt;path&gt; is relative:
engine = create_engine("sqlite:///foo.db")

# or absolute, starting with a slash:
engine = create_engine("sqlite:////absolute/path/to/foo.db")
</pre></div> </div> <p>For more information see the examples the SQLAlchemy <a class="reference external" href="https://docs.sqlalchemy.org/en/latest/core/engines.html">documentation</a></p> </section> <section id="advanced-sqlalchemy-queries"> <h3>Advanced SQLAlchemy queries</h3> <p>You can use SQLAlchemy constructs to describe your query.</p> <p>Use <code class="xref py py-func docutils literal notranslate"><span class="pre">sqlalchemy.text()</span></code> to specify query parameters in a backend-neutral way</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [659]: import sqlalchemy as sa

In [660]: pd.read_sql(
   .....:     sa.text("SELECT * FROM data where Col_1=:col1"), engine, params={"col1": "X"}
   .....: )
   .....: 
Out[660]: 
   index  id                        Date Col_1  Col_2  Col_3
0      0  26  2010-10-18 00:00:00.000000     X   27.5      1
</pre></div> </div> <p>If you have an SQLAlchemy description of your database you can express where conditions using SQLAlchemy expressions</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [661]: metadata = sa.MetaData()

In [662]: data_table = sa.Table(
   .....:     "data",
   .....:     metadata,
   .....:     sa.Column("index", sa.Integer),
   .....:     sa.Column("Date", sa.DateTime),
   .....:     sa.Column("Col_1", sa.String),
   .....:     sa.Column("Col_2", sa.Float),
   .....:     sa.Column("Col_3", sa.Boolean),
   .....: )
   .....: 

In [663]: pd.read_sql(sa.select(data_table).where(data_table.c.Col_3 is True), engine)
Out[663]: 
Empty DataFrame
Columns: [index, Date, Col_1, Col_2, Col_3]
Index: []
</pre></div> </div> <p>You can combine SQLAlchemy expressions with parameters passed to <a class="reference internal" href="../reference/api/pandas.read_sql.html#pandas.read_sql" title="pandas.read_sql"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sql()</span></code></a> using <code class="xref py py-func docutils literal notranslate"><span class="pre">sqlalchemy.bindparam()</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [664]: import datetime as dt

In [665]: expr = sa.select(data_table).where(data_table.c.Date &gt; sa.bindparam("date"))

In [666]: pd.read_sql(expr, engine, params={"date": dt.datetime(2010, 10, 18)})
Out[666]: 
   index       Date Col_1  Col_2  Col_3
0      1 2010-10-19     Y -12.50  False
1      2 2010-10-20     Z   5.73   True
</pre></div> </div> </section> <section id="sqlite-fallback"> <h3>Sqlite fallback</h3> <p>The use of sqlite is supported without using SQLAlchemy. This mode requires a Python database adapter which respect the <a class="reference external" href="https://www.python.org/dev/peps/pep-0249/">Python DB-API</a>.</p> <p>You can create connections like so:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">import sqlite3

con = sqlite3.connect(":memory:")
</pre></div> </div> <p>And then issue the following queries:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">data.to_sql("data", con)
pd.read_sql_query("SELECT * FROM data", con)
</pre></div> </div> </section> </section> <section id="google-bigquery"> <h2>Google BigQuery</h2> <p>The <code class="docutils literal notranslate"><span class="pre">pandas-gbq</span></code> package provides functionality to read/write from Google BigQuery.</p> <p>pandas integrates with this external package. if <code class="docutils literal notranslate"><span class="pre">pandas-gbq</span></code> is installed, you can use the pandas methods <code class="docutils literal notranslate"><span class="pre">pd.read_gbq</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame.to_gbq</span></code>, which will call the respective functions from <code class="docutils literal notranslate"><span class="pre">pandas-gbq</span></code>.</p> <p>Full documentation can be found <a class="reference external" href="https://pandas-gbq.readthedocs.io/en/latest/">here</a>.</p> </section> <section id="stata-format"> <h2>Stata format</h2> <section id="writing-to-stata-format"> <h3>Writing to stata format</h3> <p>The method <code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.to_stata()</span></code> will write a DataFrame into a .dta file. The format version of this file is always 115 (Stata 12).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [667]: df = pd.DataFrame(np.random.randn(10, 2), columns=list("AB"))

In [668]: df.to_stata("stata.dta")
</pre></div> </div> <p><em>Stata</em> data files have limited data type support; only strings with 244 or fewer characters, <code class="docutils literal notranslate"><span class="pre">int8</span></code>, <code class="docutils literal notranslate"><span class="pre">int16</span></code>, <code class="docutils literal notranslate"><span class="pre">int32</span></code>, <code class="docutils literal notranslate"><span class="pre">float32</span></code> and <code class="docutils literal notranslate"><span class="pre">float64</span></code> can be stored in <code class="docutils literal notranslate"><span class="pre">.dta</span></code> files. Additionally, <em>Stata</em> reserves certain values to represent missing data. Exporting a non-missing value that is outside of the permitted range in Stata for a particular data type will retype the variable to the next larger size. For example, <code class="docutils literal notranslate"><span class="pre">int8</span></code> values are restricted to lie between -127 and 100 in Stata, and so variables with values above 100 will trigger a conversion to <code class="docutils literal notranslate"><span class="pre">int16</span></code>. <code class="docutils literal notranslate"><span class="pre">nan</span></code> values in floating points data types are stored as the basic missing data type (<code class="docutils literal notranslate"><span class="pre">.</span></code> in <em>Stata</em>).</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>It is not possible to export missing data values for integer data types.</p> </div> <p>The <em>Stata</em> writer gracefully handles other data types including <code class="docutils literal notranslate"><span class="pre">int64</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, <code class="docutils literal notranslate"><span class="pre">uint8</span></code>, <code class="docutils literal notranslate"><span class="pre">uint16</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32</span></code> by casting to the smallest supported type that can represent the data. For example, data with a type of <code class="docutils literal notranslate"><span class="pre">uint8</span></code> will be cast to <code class="docutils literal notranslate"><span class="pre">int8</span></code> if all values are less than 100 (the upper bound for non-missing <code class="docutils literal notranslate"><span class="pre">int8</span></code> data in <em>Stata</em>), or, if values are outside of this range, the variable is cast to <code class="docutils literal notranslate"><span class="pre">int16</span></code>.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Conversion from <code class="docutils literal notranslate"><span class="pre">int64</span></code> to <code class="docutils literal notranslate"><span class="pre">float64</span></code> may result in a loss of precision if <code class="docutils literal notranslate"><span class="pre">int64</span></code> values are larger than 2**53.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code class="xref py py-class docutils literal notranslate"><span class="pre">StataWriter</span></code> and <code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.to_stata()</span></code> only support fixed width strings containing up to 244 characters, a limitation imposed by the version 115 dta file format. Attempting to write <em>Stata</em> dta files with strings longer than 244 characters raises a <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p> </div> </section> <section id="reading-from-stata-format"> <h3>Reading from Stata format</h3> <p>The top-level function <code class="docutils literal notranslate"><span class="pre">read_stata</span></code> will read a dta file and return either a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> or a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.api.typing.StataReader</span></code> that can be used to read the file incrementally.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [669]: pd.read_stata("stata.dta")
Out[669]: 
   index         A         B
0      0 -0.165614  0.490482
1      1 -0.637829  0.067091
2      2 -0.242577  1.348038
3      3  0.647699 -0.644937
4      4  0.625771  0.918376
5      5  0.401781 -1.488919
6      6 -0.981845 -0.046882
7      7 -0.306796  0.877025
8      8 -0.336606  0.624747
9      9 -1.582600  0.806340
</pre></div> </div> <p>Specifying a <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> yields a <code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.api.typing.StataReader</span></code> instance that can be used to read <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> lines from the file at a time. The <code class="docutils literal notranslate"><span class="pre">StataReader</span></code> object can be used as an iterator.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [670]: with pd.read_stata("stata.dta", chunksize=3) as reader:
   .....:     for df in reader:
   .....:         print(df.shape)
   .....: 
(3, 3)
(3, 3)
(3, 3)
(1, 3)
</pre></div> </div> <p>For more fine-grained control, use <code class="docutils literal notranslate"><span class="pre">iterator=True</span></code> and specify <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> with each call to <code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [671]: with pd.read_stata("stata.dta", iterator=True) as reader:
   .....:     chunk1 = reader.read(5)
   .....:     chunk2 = reader.read(5)
   .....: 
</pre></div> </div> <p>Currently the <code class="docutils literal notranslate"><span class="pre">index</span></code> is retrieved as a column.</p> <p>The parameter <code class="docutils literal notranslate"><span class="pre">convert_categoricals</span></code> indicates whether value labels should be read and used to create a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variable from them. Value labels can also be retrieved by the function <code class="docutils literal notranslate"><span class="pre">value_labels</span></code>, which requires <code class="xref py py-func docutils literal notranslate"><span class="pre">read()</span></code> to be called before use.</p> <p>The parameter <code class="docutils literal notranslate"><span class="pre">convert_missing</span></code> indicates whether missing value representations in Stata should be preserved. If <code class="docutils literal notranslate"><span class="pre">False</span></code> (the default), missing values are represented as <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>. If <code class="docutils literal notranslate"><span class="pre">True</span></code>, missing values are represented using <code class="docutils literal notranslate"><span class="pre">StataMissingValue</span></code> objects, and columns containing missing values will have <code class="docutils literal notranslate"><span class="pre">object</span></code> data type.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p><a class="reference internal" href="../reference/api/pandas.read_stata.html#pandas.read_stata" title="pandas.read_stata"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_stata()</span></code></a> and <code class="xref py py-class docutils literal notranslate"><span class="pre">StataReader</span></code> support .dta formats 113-115 (Stata 10-12), 117 (Stata 13), and 118 (Stata 14).</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Setting <code class="docutils literal notranslate"><span class="pre">preserve_dtypes=False</span></code> will upcast to the standard pandas data types: <code class="docutils literal notranslate"><span class="pre">int64</span></code> for all integer types and <code class="docutils literal notranslate"><span class="pre">float64</span></code> for floating point data. By default, the Stata data types are preserved when importing.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>All <code class="xref py py-class docutils literal notranslate"><span class="pre">StataReader</span></code> objects, whether created by <a class="reference internal" href="../reference/api/pandas.read_stata.html#pandas.read_stata" title="pandas.read_stata"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_stata()</span></code></a> (when using <code class="docutils literal notranslate"><span class="pre">iterator=True</span></code> or <code class="docutils literal notranslate"><span class="pre">chunksize</span></code>) or instantiated by hand, must be used as context managers (e.g. the <code class="docutils literal notranslate"><span class="pre">with</span></code> statement). While the <code class="xref py py-meth docutils literal notranslate"><span class="pre">close()</span></code> method is available, its use is unsupported. It is not part of the public API and will be removed in with future without warning.</p> </div> <section id="io-stata-categorical"> <h4>Categorical data</h4> <p><code class="docutils literal notranslate"><span class="pre">Categorical</span></code> data can be exported to <em>Stata</em> data files as value labeled data. The exported data consists of the underlying category codes as integer data values and the categories as value labels. <em>Stata</em> does not have an explicit equivalent to a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> and information about <em>whether</em> the variable is ordered is lost when exporting.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><em>Stata</em> only supports string value labels, and so <code class="docutils literal notranslate"><span class="pre">str</span></code> is called on the categories when exporting data. Exporting <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variables with non-string categories produces a warning, and can result a loss of information if the <code class="docutils literal notranslate"><span class="pre">str</span></code> representations of the categories are not unique.</p> </div> <p>Labeled data can similarly be imported from <em>Stata</em> data files as <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variables using the keyword argument <code class="docutils literal notranslate"><span class="pre">convert_categoricals</span></code> (<code class="docutils literal notranslate"><span class="pre">True</span></code> by default). The keyword argument <code class="docutils literal notranslate"><span class="pre">order_categoricals</span></code> (<code class="docutils literal notranslate"><span class="pre">True</span></code> by default) determines whether imported <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variables are ordered.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When importing categorical data, the values of the variables in the <em>Stata</em> data file are not preserved since <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> variables always use integer data types between <code class="docutils literal notranslate"><span class="pre">-1</span></code> and <code class="docutils literal notranslate"><span class="pre">n-1</span></code> where <code class="docutils literal notranslate"><span class="pre">n</span></code> is the number of categories. If the original values in the <em>Stata</em> data file are required, these can be imported by setting <code class="docutils literal notranslate"><span class="pre">convert_categoricals=False</span></code>, which will import original data (but not the variable labels). The original values can be matched to the imported categorical data since there is a simple mapping between the original <em>Stata</em> data values and the category codes of imported Categorical variables: missing values are assigned code <code class="docutils literal notranslate"><span class="pre">-1</span></code>, and the smallest original value is assigned <code class="docutils literal notranslate"><span class="pre">0</span></code>, the second smallest is assigned <code class="docutils literal notranslate"><span class="pre">1</span></code> and so on until the largest original value is assigned the code <code class="docutils literal notranslate"><span class="pre">n-1</span></code>.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><em>Stata</em> supports partially labeled series. These series have value labels for some but not all data values. Importing a partially labeled series will produce a <code class="docutils literal notranslate"><span class="pre">Categorical</span></code> with string categories for the values that are labeled and numeric categories for values with no label.</p> </div> </section> </section> </section> <section id="sas-formats"> <h2>SAS formats</h2> <p>The top-level function <a class="reference internal" href="../reference/api/pandas.read_sas.html#pandas.read_sas" title="pandas.read_sas"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_sas()</span></code></a> can read (but not write) SAS XPORT (.xpt) and SAS7BDAT (.sas7bdat) format files.</p> <p>SAS files only contain two value types: ASCII text and floating point values (usually 8 bytes but sometimes truncated). For xport files, there is no automatic type conversion to integers, dates, or categoricals. For SAS7BDAT files, the format codes may allow date variables to be automatically converted to dates. By default the whole file is read and returned as a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <p>Specify a <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> or use <code class="docutils literal notranslate"><span class="pre">iterator=True</span></code> to obtain reader objects (<code class="docutils literal notranslate"><span class="pre">XportReader</span></code> or <code class="docutils literal notranslate"><span class="pre">SAS7BDATReader</span></code>) for incrementally reading the file. The reader objects also have attributes that contain additional information about the file and its variables.</p> <p>Read a SAS7BDAT file:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.read_sas("sas_data.sas7bdat")
</pre></div> </div> <p>Obtain an iterator and read an XPORT file 100,000 lines at a time:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">def do_something(chunk):
    pass


with pd.read_sas("sas_xport.xpt", chunk=100000) as rdr:
    for chunk in rdr:
        do_something(chunk)
</pre></div> </div> <p>The <a class="reference external" href="https://support.sas.com/content/dam/SAS/support/en/technical-papers/record-layout-of-a-sas-version-5-or-6-data-set-in-sas-transport-xport-format.pdf">specification</a> for the xport file format is available from the SAS web site.</p> <p>No official documentation is available for the SAS7BDAT format.</p> </section> <section id="spss-formats"> <h2>SPSS formats</h2> <p>The top-level function <a class="reference internal" href="../reference/api/pandas.read_spss.html#pandas.read_spss" title="pandas.read_spss"><code class="xref py py-func docutils literal notranslate"><span class="pre">read_spss()</span></code></a> can read (but not write) SPSS SAV (.sav) and ZSAV (.zsav) format files.</p> <p>SPSS files contain column names. By default the whole file is read, categorical columns are converted into <code class="docutils literal notranslate"><span class="pre">pd.Categorical</span></code>, and a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with all columns is returned.</p> <p>Specify the <code class="docutils literal notranslate"><span class="pre">usecols</span></code> parameter to obtain a subset of columns. Specify <code class="docutils literal notranslate"><span class="pre">convert_categoricals=False</span></code> to avoid converting categorical columns into <code class="docutils literal notranslate"><span class="pre">pd.Categorical</span></code>.</p> <p>Read an SPSS file:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.read_spss("spss_data.sav")
</pre></div> </div> <p>Extract a subset of columns contained in <code class="docutils literal notranslate"><span class="pre">usecols</span></code> from an SPSS file and avoid converting categorical columns into <code class="docutils literal notranslate"><span class="pre">pd.Categorical</span></code>:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df = pd.read_spss(
    "spss_data.sav",
    usecols=["foo", "bar"],
    convert_categoricals=False,
)
</pre></div> </div> <p>More information about the SAV and ZSAV file formats is available <a class="reference external" href="https://www.ibm.com/docs/en/spss-statistics/22.0.0">here</a>.</p> </section> <section id="other-file-formats"> <h2>Other file formats</h2> <p>pandas itself only supports IO with a limited set of file formats that map cleanly to its tabular data model. For reading and writing other file formats into and from pandas, we recommend these packages from the broader community.</p> <section id="netcdf"> <h3>netCDF</h3> <p><a class="reference external" href="https://xarray.pydata.org/en/stable/">xarray</a> provides data structures inspired by the pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> for working with multi-dimensional datasets, with a focus on the netCDF file format and easy conversion to and from pandas.</p> </section> </section> <section id="performance-considerations"> <h2>Performance considerations</h2> <p>This is an informal comparison of various IO methods, using pandas 0.24.2. Timings are machine dependent and small differences should be ignored.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: sz = 1000000
In [2]: df = pd.DataFrame({'A': np.random.randn(sz), 'B': [1] * sz})

In [3]: df.info()
&lt;class 'pandas.core.frame.DataFrame'&gt;
RangeIndex: 1000000 entries, 0 to 999999
Data columns (total 2 columns):
A    1000000 non-null float64
B    1000000 non-null int64
dtypes: float64(1), int64(1)
memory usage: 15.3 MB
</pre></div> </div> <p>The following test functions will be used below to compare the performance of several IO methods:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">import numpy as np

import os

sz = 1000000
df = pd.DataFrame({"A": np.random.randn(sz), "B": [1] * sz})

sz = 1000000
np.random.seed(42)
df = pd.DataFrame({"A": np.random.randn(sz), "B": [1] * sz})


def test_sql_write(df):
    if os.path.exists("test.sql"):
        os.remove("test.sql")
    sql_db = sqlite3.connect("test.sql")
    df.to_sql(name="test_table", con=sql_db)
    sql_db.close()


def test_sql_read():
    sql_db = sqlite3.connect("test.sql")
    pd.read_sql_query("select * from test_table", sql_db)
    sql_db.close()


def test_hdf_fixed_write(df):
    df.to_hdf("test_fixed.hdf", key="test", mode="w")


def test_hdf_fixed_read():
    pd.read_hdf("test_fixed.hdf", "test")


def test_hdf_fixed_write_compress(df):
    df.to_hdf("test_fixed_compress.hdf", key="test", mode="w", complib="blosc")


def test_hdf_fixed_read_compress():
    pd.read_hdf("test_fixed_compress.hdf", "test")


def test_hdf_table_write(df):
    df.to_hdf("test_table.hdf", key="test", mode="w", format="table")


def test_hdf_table_read():
    pd.read_hdf("test_table.hdf", "test")


def test_hdf_table_write_compress(df):
    df.to_hdf(
        "test_table_compress.hdf", key="test", mode="w", complib="blosc", format="table"
    )


def test_hdf_table_read_compress():
    pd.read_hdf("test_table_compress.hdf", "test")


def test_csv_write(df):
    df.to_csv("test.csv", mode="w")


def test_csv_read():
    pd.read_csv("test.csv", index_col=0)


def test_feather_write(df):
    df.to_feather("test.feather")


def test_feather_read():
    pd.read_feather("test.feather")


def test_pickle_write(df):
    df.to_pickle("test.pkl")


def test_pickle_read():
    pd.read_pickle("test.pkl")


def test_pickle_write_compress(df):
    df.to_pickle("test.pkl.compress", compression="xz")


def test_pickle_read_compress():
    pd.read_pickle("test.pkl.compress", compression="xz")


def test_parquet_write(df):
    df.to_parquet("test.parquet")


def test_parquet_read():
    pd.read_parquet("test.parquet")
</pre></div> </div> <p>When writing, the top three functions in terms of speed are <code class="docutils literal notranslate"><span class="pre">test_feather_write</span></code>, <code class="docutils literal notranslate"><span class="pre">test_hdf_fixed_write</span></code> and <code class="docutils literal notranslate"><span class="pre">test_hdf_fixed_write_compress</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [4]: %timeit test_sql_write(df)
3.29 s ± 43.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [5]: %timeit test_hdf_fixed_write(df)
19.4 ms ± 560 µs per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [6]: %timeit test_hdf_fixed_write_compress(df)
19.6 ms ± 308 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [7]: %timeit test_hdf_table_write(df)
449 ms ± 5.61 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [8]: %timeit test_hdf_table_write_compress(df)
448 ms ± 11.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [9]: %timeit test_csv_write(df)
3.66 s ± 26.2 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [10]: %timeit test_feather_write(df)
9.75 ms ± 117 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [11]: %timeit test_pickle_write(df)
30.1 ms ± 229 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [12]: %timeit test_pickle_write_compress(df)
4.29 s ± 15.9 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [13]: %timeit test_parquet_write(df)
67.6 ms ± 706 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre></div> </div> <p>When reading, the top three functions in terms of speed are <code class="docutils literal notranslate"><span class="pre">test_feather_read</span></code>, <code class="docutils literal notranslate"><span class="pre">test_pickle_read</span></code> and <code class="docutils literal notranslate"><span class="pre">test_hdf_fixed_read</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: %timeit test_sql_read()
1.77 s ± 17.7 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [15]: %timeit test_hdf_fixed_read()
19.4 ms ± 436 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [16]: %timeit test_hdf_fixed_read_compress()
19.5 ms ± 222 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [17]: %timeit test_hdf_table_read()
38.6 ms ± 857 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [18]: %timeit test_hdf_table_read_compress()
38.8 ms ± 1.49 ms per loop (mean ± std. dev. of 7 runs, 10 loops each)

In [19]: %timeit test_csv_read()
452 ms ± 9.04 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [20]: %timeit test_feather_read()
12.4 ms ± 99.7 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [21]: %timeit test_pickle_read()
18.4 ms ± 191 µs per loop (mean ± std. dev. of 7 runs, 100 loops each)

In [22]: %timeit test_pickle_read_compress()
915 ms ± 7.48 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)

In [23]: %timeit test_parquet_read()
24.4 ms ± 146 µs per loop (mean ± std. dev. of 7 runs, 10 loops each)
</pre></div> </div> <p>The files <code class="docutils literal notranslate"><span class="pre">test.pkl.compress</span></code>, <code class="docutils literal notranslate"><span class="pre">test.parquet</span></code> and <code class="docutils literal notranslate"><span class="pre">test.feather</span></code> took the least space on disk (in bytes).</p> <div class="highlight-none notranslate">
<div class="highlight"><pre data-language="python">29519500 Oct 10 06:45 test.csv
16000248 Oct 10 06:45 test.feather
8281983  Oct 10 06:49 test.parquet
16000857 Oct 10 06:47 test.pkl
7552144  Oct 10 06:48 test.pkl.compress
34816000 Oct 10 06:42 test.sql
24009288 Oct 10 06:43 test_fixed.hdf
24009288 Oct 10 06:43 test_fixed_compress.hdf
24458940 Oct 10 06:44 test_table.hdf
24458940 Oct 10 06:44 test_table_compress.hdf
</pre></div> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/io.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/io.html</a>
  </p>
</div>
