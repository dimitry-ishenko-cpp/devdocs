<h1>Indexing and selecting data</h1> <p>The axis labeling information in pandas objects serves many purposes:</p> <ul class="simple"> <li><p>Identifies data (i.e. provides <em>metadata</em>) using known indicators, important for analysis, visualization, and interactive console display.</p></li> <li><p>Enables automatic and explicit data alignment.</p></li> <li><p>Allows intuitive getting and setting of subsets of the data set.</p></li> </ul> <p>In this section, we will focus on the final point: namely, how to slice, dice, and generally get and set subsets of pandas objects. The primary focus will be on Series and DataFrame as they have received more development attention in this area.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The Python and NumPy indexing operators <code class="docutils literal notranslate"><span class="pre">[]</span></code> and attribute operator <code class="docutils literal notranslate"><span class="pre">.</span></code> provide quick and easy access to pandas data structures across a wide range of use cases. This makes interactive work intuitive, as there’s little new to learn if you already know how to deal with Python dictionaries and NumPy arrays. However, since the type of the data to be accessed isn’t known in advance, directly using standard operators has some optimization limits. For production code, we recommended that you take advantage of the optimized pandas data access methods exposed in this chapter.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided. See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p> </div> <p>See the <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">MultiIndex / Advanced Indexing</span></a> for <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> and more advanced indexing documentation.</p> <p>See the <a class="reference internal" href="cookbook.html#cookbook-selection"><span class="std std-ref">cookbook</span></a> for some advanced strategies.</p> <section id="different-choices-for-indexing"> <h2>Different choices for indexing</h2> <p>Object selection has had a number of user-requested additions in order to support more explicit location based indexing. pandas now supports three types of multi-axis indexing.</p> <ul> <li>
<p><code class="docutils literal notranslate"><span class="pre">.loc</span></code> is primarily label based, but may also be used with a boolean array. <code class="docutils literal notranslate"><span class="pre">.loc</span></code> will raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> when the items are not found. Allowed inputs are:</p> <blockquote> <div>
<ul class="simple"> <li><p>A single label, e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code> or <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (Note that <code class="docutils literal notranslate"><span class="pre">5</span></code> is interpreted as a <em>label</em> of the index. This use is <strong>not</strong> an integer position along the index.).</p></li> <li><p>A list or array of labels <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>.</p></li> <li><p>A slice object with labels <code class="docutils literal notranslate"><span class="pre">'a':'f'</span></code> (Note that contrary to usual Python slices, <strong>both</strong> the start and the stop are included, when present in the index! See <a class="reference internal" href="#indexing-slicing-with-labels"><span class="std std-ref">Slicing with labels</span></a> and <a class="reference internal" href="advanced.html#advanced-endpoints-are-inclusive"><span class="std std-ref">Endpoints are inclusive</span></a>.)</p></li> <li><p>A boolean array (any <code class="docutils literal notranslate"><span class="pre">NA</span></code> values will be treated as <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code> function with one argument (the calling Series or DataFrame) and that returns valid output for indexing (one of the above).</p></li> <li><p>A tuple of row (and column) indices whose elements are one of the above inputs.</p></li> </ul> </div>
</blockquote> <p>See more at <a class="reference internal" href="#indexing-label"><span class="std std-ref">Selection by Label</span></a>.</p> </li> <li>
<p><code class="docutils literal notranslate"><span class="pre">.iloc</span></code> is primarily integer position based (from <code class="docutils literal notranslate"><span class="pre">0</span></code> to <code class="docutils literal notranslate"><span class="pre">length-1</span></code> of the axis), but may also be used with a boolean array. <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> will raise <code class="docutils literal notranslate"><span class="pre">IndexError</span></code> if a requested indexer is out-of-bounds, except <em>slice</em> indexers which allow out-of-bounds indexing. (this conforms with Python/NumPy <em>slice</em> semantics). Allowed inputs are:</p> <blockquote> <div>
<ul class="simple"> <li><p>An integer e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li> <li><p>A list or array of integers <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0]</span></code>.</p></li> <li><p>A slice object with ints <code class="docutils literal notranslate"><span class="pre">1:7</span></code>.</p></li> <li><p>A boolean array (any <code class="docutils literal notranslate"><span class="pre">NA</span></code> values will be treated as <code class="docutils literal notranslate"><span class="pre">False</span></code>).</p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code> function with one argument (the calling Series or DataFrame) and that returns valid output for indexing (one of the above).</p></li> <li><p>A tuple of row (and column) indices whose elements are one of the above inputs.</p></li> </ul> </div>
</blockquote> <p>See more at <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a>, <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> and <a class="reference internal" href="advanced.html#advanced-advanced-hierarchical"><span class="std std-ref">Advanced Hierarchical</span></a>.</p> </li> <li>
<p><code class="docutils literal notranslate"><span class="pre">.loc</span></code>, <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, and also <code class="docutils literal notranslate"><span class="pre">[]</span></code> indexing can accept a <code class="docutils literal notranslate"><span class="pre">callable</span></code> as indexer. See more at <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Destructuring tuple keys into row (and column) indexes occurs <em>before</em> callables are applied, so you cannot return a tuple from a callable to index both rows and columns.</p> </div> </li> </ul> <p>Getting values from an object with multi-axes selection uses the following notation (using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> as an example, but the following applies to <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> as well). Any of the axes accessors may be the null slice <code class="docutils literal notranslate"><span class="pre">:</span></code>. Axes left out of the specification are assumed to be <code class="docutils literal notranslate"><span class="pre">:</span></code>, e.g. <code class="docutils literal notranslate"><span class="pre">p.loc['a']</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">p.loc['a',</span> <span class="pre">:]</span></code>.</p> <table class="table"> <colgroup> <col style="width: 37.5%"> <col style="width: 62.5%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Object Type</p></th> <th class="head"><p>Indexers</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>Series</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">s.loc[indexer]</span></code></p></td> </tr> <tr class="row-odd">
<td><p>DataFrame</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">df.loc[row_indexer,column_indexer]</span></code></p></td> </tr> </tbody> </table> </section> <section id="basics"> <h2>Basics</h2> <p>As mentioned when introducing the data structures in the <a class="reference internal" href="basics.html#basics"><span class="std std-ref">last section</span></a>, the primary function of indexing with <code class="docutils literal notranslate"><span class="pre">[]</span></code> (a.k.a. <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> for those familiar with implementing class behavior in Python) is selecting out lower-dimensional slices. The following table shows return type values when indexing pandas objects with <code class="docutils literal notranslate"><span class="pre">[]</span></code>:</p> <table class="table"> <colgroup> <col style="width: 25.0%"> <col style="width: 25.0%"> <col style="width: 50.0%"> </colgroup> <thead> <tr class="row-odd">
<th class="head"><p>Object Type</p></th> <th class="head"><p>Selection</p></th> <th class="head"><p>Return Value Type</p></th> </tr> </thead> <tbody> <tr class="row-even">
<td><p>Series</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">series[label]</span></code></p></td> <td><p>scalar value</p></td> </tr> <tr class="row-odd">
<td><p>DataFrame</p></td> <td><p><code class="docutils literal notranslate"><span class="pre">frame[colname]</span></code></p></td> <td><p><code class="docutils literal notranslate"><span class="pre">Series</span></code> corresponding to colname</p></td> </tr> </tbody> </table> <p>Here we construct a simple time series data set to use for illustrating the indexing functionality:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: dates = pd.date_range('1/1/2000', periods=8)

In [2]: df = pd.DataFrame(np.random.randn(8, 4),
   ...:                   index=dates, columns=['A', 'B', 'C', 'D'])
   ...: 

In [3]: df
Out[3]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>None of the indexing functionality is time series specific unless specifically stated.</p> </div> <p>Thus, as per above, we have the most basic indexing using <code class="docutils literal notranslate"><span class="pre">[]</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [4]: s = df['A']

In [5]: s[dates[5]]
Out[5]: -0.6736897080883706
</pre></div> </div> <p>You can pass a list of columns to <code class="docutils literal notranslate"><span class="pre">[]</span></code> to select columns in that order. If a column is not contained in the DataFrame, an exception will be raised. Multiple columns can also be set in this manner:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [6]: df
Out[6]: 
                   A         B         C         D
2000-01-01  0.469112 -0.282863 -1.509059 -1.135632
2000-01-02  1.212112 -0.173215  0.119209 -1.044236
2000-01-03 -0.861849 -2.104569 -0.494929  1.071804
2000-01-04  0.721555 -0.706771 -1.039575  0.271860
2000-01-05 -0.424972  0.567020  0.276232 -1.087401
2000-01-06 -0.673690  0.113648 -1.478427  0.524988
2000-01-07  0.404705  0.577046 -1.715002 -1.039268
2000-01-08 -0.370647 -1.157892 -1.344312  0.844885

In [7]: df[['B', 'A']] = df[['A', 'B']]

In [8]: df
Out[8]: 
                   A         B         C         D
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632
2000-01-02 -0.173215  1.212112  0.119209 -1.044236
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804
2000-01-04 -0.706771  0.721555 -1.039575  0.271860
2000-01-05  0.567020 -0.424972  0.276232 -1.087401
2000-01-06  0.113648 -0.673690 -1.478427  0.524988
2000-01-07  0.577046  0.404705 -1.715002 -1.039268
2000-01-08 -1.157892 -0.370647 -1.344312  0.844885
</pre></div> </div> <p>You may find this useful for applying a transform (in-place) to a subset of the columns.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>pandas aligns all AXES when setting <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from <code class="docutils literal notranslate"><span class="pre">.loc</span></code>.</p> <p>This will <strong>not</strong> modify <code class="docutils literal notranslate"><span class="pre">df</span></code> because the column alignment is before value assignment.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [9]: df[['A', 'B']]
Out[9]: 
                   A         B
2000-01-01 -0.282863  0.469112
2000-01-02 -0.173215  1.212112
2000-01-03 -2.104569 -0.861849
2000-01-04 -0.706771  0.721555
2000-01-05  0.567020 -0.424972
2000-01-06  0.113648 -0.673690
2000-01-07  0.577046  0.404705
2000-01-08 -1.157892 -0.370647

In [10]: df.loc[:, ['B', 'A']] = df[['A', 'B']]

In [11]: df[['A', 'B']]
Out[11]: 
                   A         B
2000-01-01 -0.282863  0.469112
2000-01-02 -0.173215  1.212112
2000-01-03 -2.104569 -0.861849
2000-01-04 -0.706771  0.721555
2000-01-05  0.567020 -0.424972
2000-01-06  0.113648 -0.673690
2000-01-07  0.577046  0.404705
2000-01-08 -1.157892 -0.370647
</pre></div> </div> <p>The correct way to swap column values is by using raw values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [12]: df.loc[:, ['B', 'A']] = df[['A', 'B']].to_numpy()

In [13]: df[['A', 'B']]
Out[13]: 
                   A         B
2000-01-01  0.469112 -0.282863
2000-01-02  1.212112 -0.173215
2000-01-03 -0.861849 -2.104569
2000-01-04  0.721555 -0.706771
2000-01-05 -0.424972  0.567020
2000-01-06 -0.673690  0.113648
2000-01-07  0.404705  0.577046
2000-01-08 -0.370647 -1.157892
</pre></div> </div> <p>However, pandas does not align AXES when setting <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> from <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> because <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> operates by position.</p> <p>This will modify <code class="docutils literal notranslate"><span class="pre">df</span></code> because the column alignment is not done before value assignment.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: df[['A', 'B']]
Out[14]: 
                   A         B
2000-01-01  0.469112 -0.282863
2000-01-02  1.212112 -0.173215
2000-01-03 -0.861849 -2.104569
2000-01-04  0.721555 -0.706771
2000-01-05 -0.424972  0.567020
2000-01-06 -0.673690  0.113648
2000-01-07  0.404705  0.577046
2000-01-08 -0.370647 -1.157892

In [15]: df.iloc[:, [1, 0]] = df[['A', 'B']]

In [16]: df[['A','B']]
Out[16]: 
                   A         B
2000-01-01 -0.282863  0.469112
2000-01-02 -0.173215  1.212112
2000-01-03 -2.104569 -0.861849
2000-01-04 -0.706771  0.721555
2000-01-05  0.567020 -0.424972
2000-01-06  0.113648 -0.673690
2000-01-07  0.577046  0.404705
2000-01-08 -1.157892 -0.370647
</pre></div> </div> </div> </section> <section id="attribute-access"> <h2>Attribute access</h2> <p id="indexing-attribute-access">You may access an index on a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or column on a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> directly as an attribute:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [17]: sa = pd.Series([1, 2, 3], index=list('abc'))

In [18]: dfa = df.copy()
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [19]: sa.b
Out[19]: 2

In [20]: dfa.A
Out[20]: 
2000-01-01   -0.282863
2000-01-02   -0.173215
2000-01-03   -2.104569
2000-01-04   -0.706771
2000-01-05    0.567020
2000-01-06    0.113648
2000-01-07    0.577046
2000-01-08   -1.157892
Freq: D, Name: A, dtype: float64
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: sa.a = 5

In [22]: sa
Out[22]: 
a    5
b    2
c    3
dtype: int64

In [23]: dfa.A = list(range(len(dfa.index)))  # ok if A already exists

In [24]: dfa
Out[24]: 
            A         B         C         D
2000-01-01  0  0.469112 -1.509059 -1.135632
2000-01-02  1  1.212112  0.119209 -1.044236
2000-01-03  2 -0.861849 -0.494929  1.071804
2000-01-04  3  0.721555 -1.039575  0.271860
2000-01-05  4 -0.424972  0.276232 -1.087401
2000-01-06  5 -0.673690 -1.478427  0.524988
2000-01-07  6  0.404705 -1.715002 -1.039268
2000-01-08  7 -0.370647 -1.344312  0.844885

In [25]: dfa['A'] = list(range(len(dfa.index)))  # use this form to create a new column

In [26]: dfa
Out[26]: 
            A         B         C         D
2000-01-01  0  0.469112 -1.509059 -1.135632
2000-01-02  1  1.212112  0.119209 -1.044236
2000-01-03  2 -0.861849 -0.494929  1.071804
2000-01-04  3  0.721555 -1.039575  0.271860
2000-01-05  4 -0.424972  0.276232 -1.087401
2000-01-06  5 -0.673690 -1.478427  0.524988
2000-01-07  6  0.404705 -1.715002 -1.039268
2000-01-08  7 -0.370647 -1.344312  0.844885
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <ul class="simple"> <li><p>You can use this access only if the index element is a valid Python identifier, e.g. <code class="docutils literal notranslate"><span class="pre">s.1</span></code> is not allowed. See <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#identifiers">here for an explanation of valid identifiers</a>.</p></li> <li><p>The attribute will not be available if it conflicts with an existing method name, e.g. <code class="docutils literal notranslate"><span class="pre">s.min</span></code> is not allowed, but <code class="docutils literal notranslate"><span class="pre">s['min']</span></code> is possible.</p></li> <li><p>Similarly, the attribute will not be available if it conflicts with any of the following list: <code class="docutils literal notranslate"><span class="pre">index</span></code>, <code class="docutils literal notranslate"><span class="pre">major_axis</span></code>, <code class="docutils literal notranslate"><span class="pre">minor_axis</span></code>, <code class="docutils literal notranslate"><span class="pre">items</span></code>.</p></li> <li><p>In any of these cases, standard indexing will still work, e.g. <code class="docutils literal notranslate"><span class="pre">s['1']</span></code>, <code class="docutils literal notranslate"><span class="pre">s['min']</span></code>, and <code class="docutils literal notranslate"><span class="pre">s['index']</span></code> will access the corresponding element or column.</p></li> </ul> </div> <p>If you are using the IPython environment, you may also use tab-completion to see these accessible attributes.</p> <p>You can also assign a <code class="docutils literal notranslate"><span class="pre">dict</span></code> to a row of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [27]: x = pd.DataFrame({'x': [1, 2, 3], 'y': [3, 4, 5]})

In [28]: x.iloc[1] = {'x': 9, 'y': 99}

In [29]: x
Out[29]: 
   x   y
0  1   3
1  9  99
2  3   5
</pre></div> </div> <p>You can use attribute access to modify an existing element of a Series or column of a DataFrame, but be careful; if you try to use attribute access to create a new column, it creates a new attribute rather than a new column and will this raise a <code class="docutils literal notranslate"><span class="pre">UserWarning</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [30]: df_new = pd.DataFrame({'one': [1., 2., 3.]})

In [31]: df_new.two = [4, 5, 6]

In [32]: df_new
Out[32]: 
   one
0  1.0
1  2.0
2  3.0
</pre></div> </div> </section> <section id="slicing-ranges"> <h2>Slicing ranges</h2> <p>The most robust and consistent way of slicing ranges along arbitrary axes is described in the <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a> section detailing the <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> method. For now, we explain the semantics of slicing using the <code class="docutils literal notranslate"><span class="pre">[]</span></code> operator.</p> <p>With Series, the syntax works exactly as with an ndarray, returning a slice of the values and the corresponding labels:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [33]: s[:5]
Out[33]: 
2000-01-01    0.469112
2000-01-02    1.212112
2000-01-03   -0.861849
2000-01-04    0.721555
2000-01-05   -0.424972
Freq: D, Name: A, dtype: float64

In [34]: s[::2]
Out[34]: 
2000-01-01    0.469112
2000-01-03   -0.861849
2000-01-05   -0.424972
2000-01-07    0.404705
Freq: 2D, Name: A, dtype: float64

In [35]: s[::-1]
Out[35]: 
2000-01-08   -0.370647
2000-01-07    0.404705
2000-01-06   -0.673690
2000-01-05   -0.424972
2000-01-04    0.721555
2000-01-03   -0.861849
2000-01-02    1.212112
2000-01-01    0.469112
Freq: -1D, Name: A, dtype: float64
</pre></div> </div> <p>Note that setting works as well:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [36]: s2 = s.copy()

In [37]: s2[:5] = 0

In [38]: s2
Out[38]: 
2000-01-01    0.000000
2000-01-02    0.000000
2000-01-03    0.000000
2000-01-04    0.000000
2000-01-05    0.000000
2000-01-06   -0.673690
2000-01-07    0.404705
2000-01-08   -0.370647
Freq: D, Name: A, dtype: float64
</pre></div> </div> <p>With DataFrame, slicing inside of <code class="docutils literal notranslate"><span class="pre">[]</span></code> <strong>slices the rows</strong>. This is provided largely as a convenience since it is such a common operation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: df[:3]
Out[39]: 
                   A         B         C         D
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632
2000-01-02 -0.173215  1.212112  0.119209 -1.044236
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804

In [40]: df[::-1]
Out[40]: 
                   A         B         C         D
2000-01-08 -1.157892 -0.370647 -1.344312  0.844885
2000-01-07  0.577046  0.404705 -1.715002 -1.039268
2000-01-06  0.113648 -0.673690 -1.478427  0.524988
2000-01-05  0.567020 -0.424972  0.276232 -1.087401
2000-01-04 -0.706771  0.721555 -1.039575  0.271860
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804
2000-01-02 -0.173215  1.212112  0.119209 -1.044236
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632
</pre></div> </div> </section> <section id="selection-by-label"> <h2>Selection by label</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided. See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <blockquote> <div>
<p><code class="docutils literal notranslate"><span class="pre">.loc</span></code> is strict when you present slicers that are not compatible (or convertible) with the index type. For example using integers in a <code class="docutils literal notranslate"><span class="pre">DatetimeIndex</span></code>. These will raise a <code class="docutils literal notranslate"><span class="pre">TypeError</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [41]: dfl = pd.DataFrame(np.random.randn(5, 4),
   ....:                    columns=list('ABCD'),
   ....:                    index=pd.date_range('20130101', periods=5))
   ....: 

In [42]: dfl
Out[42]: 
                   A         B         C         D
2013-01-01  1.075770 -0.109050  1.643563 -1.469388
2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
2013-01-03 -1.294524  0.413738  0.276662 -0.472035
2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
2013-01-05  0.895717  0.805244 -1.206412  2.565646

In [43]: dfl.loc[2:3]
---------------------------------------------------------------------------
TypeError                                 Traceback (most recent call last)
Cell In[43], line 1
----&gt; 1 dfl.loc[2:3]

File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)
   1189 maybe_callable = com.apply_if_callable(key, self.obj)
   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)
-&gt; 1191 return self._getitem_axis(maybe_callable, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1411, in _LocIndexer._getitem_axis(self, key, axis)
   1409 if isinstance(key, slice):
   1410     self._validate_key(key, axis)
-&gt; 1411     return self._get_slice_axis(key, axis=axis)
   1412 elif com.is_bool_indexer(key):
   1413     return self._getbool_axis(key, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1443, in _LocIndexer._get_slice_axis(self, slice_obj, axis)
   1440     return obj.copy(deep=False)
   1442 labels = obj._get_axis(axis)
-&gt; 1443 indexer = labels.slice_indexer(slice_obj.start, slice_obj.stop, slice_obj.step)
   1445 if isinstance(indexer, slice):
   1446     return self.obj._slice(indexer, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:682, in DatetimeIndex.slice_indexer(self, start, end, step)
    674 # GH#33146 if start and end are combinations of str and None and Index is not
    675 # monotonic, we can not use Index.slice_indexer because it does not honor the
    676 # actual elements, is only searching for start and end
    677 if (
    678     check_str_or_none(start)
    679     or check_str_or_none(end)
    680     or self.is_monotonic_increasing
    681 ):
--&gt; 682     return Index.slice_indexer(self, start, end, step)
    684 mask = np.array(True)
    685 in_index = True

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6662, in Index.slice_indexer(self, start, end, step)
   6618 def slice_indexer(
   6619     self,
   6620     start: Hashable | None = None,
   6621     end: Hashable | None = None,
   6622     step: int | None = None,
   6623 ) -&gt; slice:
   6624     """
   6625     Compute the slice indexer for input labels and step.
   6626 
   (...)
   6660     slice(1, 3, None)
   6661     """
-&gt; 6662     start_slice, end_slice = self.slice_locs(start, end, step=step)
   6664     # return a slice
   6665     if not is_scalar(start_slice):

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6879, in Index.slice_locs(self, start, end, step)
   6877 start_slice = None
   6878 if start is not None:
-&gt; 6879     start_slice = self.get_slice_bound(start, "left")
   6880 if start_slice is None:
   6881     start_slice = 0

File ~/work/pandas/pandas/pandas/core/indexes/base.py:6794, in Index.get_slice_bound(self, label, side)
   6790 original_label = label
   6792 # For datetime indices label may be a string that has to be converted
   6793 # to datetime boundary according to its resolution.
-&gt; 6794 label = self._maybe_cast_slice_bound(label, side)
   6796 # we need to look up the label
   6797 try:

File ~/work/pandas/pandas/pandas/core/indexes/datetimes.py:642, in DatetimeIndex._maybe_cast_slice_bound(self, label, side)
    637 if isinstance(label, dt.date) and not isinstance(label, dt.datetime):
    638     # Pandas supports slicing with dates, treated as datetimes at midnight.
    639     # https://github.com/pandas-dev/pandas/issues/31501
    640     label = Timestamp(label).to_pydatetime()
--&gt; 642 label = super()._maybe_cast_slice_bound(label, side)
    643 self._data._assert_tzawareness_compat(label)
    644 return Timestamp(label)

File ~/work/pandas/pandas/pandas/core/indexes/datetimelike.py:378, in DatetimeIndexOpsMixin._maybe_cast_slice_bound(self, label, side)
    376     return lower if side == "left" else upper
    377 elif not isinstance(label, self._data._recognized_scalars):
--&gt; 378     self._raise_invalid_indexer("slice", label)
    380 return label

File ~/work/pandas/pandas/pandas/core/indexes/base.py:4301, in Index._raise_invalid_indexer(self, form, key, reraise)
   4299 if reraise is not lib.no_default:
   4300     raise TypeError(msg) from reraise
-&gt; 4301 raise TypeError(msg)

TypeError: cannot do slice indexing on DatetimeIndex with these indexers [2] of type int
</pre></div> </div> </div>
</blockquote> <p>String likes in slicing <em>can</em> be convertible to the type of the index and lead to natural slicing.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [44]: dfl.loc['20130102':'20130104']
Out[44]: 
                   A         B         C         D
2013-01-02  0.357021 -0.674600 -1.776904 -0.968914
2013-01-03 -1.294524  0.413738  0.276662 -0.472035
2013-01-04 -0.013960 -0.362543 -0.006154 -0.923061
</pre></div> </div> </div> <p>pandas provides a suite of methods in order to have <strong>purely label based indexing</strong>. This is a strict inclusion based protocol. Every label asked for must be in the index, or a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code> will be raised. When slicing, both the start bound <strong>AND</strong> the stop bound are <em>included</em>, if present in the index. Integers are valid labels, but they refer to the label <strong>and not the position</strong>.</p> <p>The <code class="docutils literal notranslate"><span class="pre">.loc</span></code> attribute is the primary access method. The following are valid inputs:</p> <ul class="simple"> <li><p>A single label, e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code> or <code class="docutils literal notranslate"><span class="pre">'a'</span></code> (Note that <code class="docutils literal notranslate"><span class="pre">5</span></code> is interpreted as a <em>label</em> of the index. This use is <strong>not</strong> an integer position along the index.).</p></li> <li><p>A list or array of labels <code class="docutils literal notranslate"><span class="pre">['a',</span> <span class="pre">'b',</span> <span class="pre">'c']</span></code>.</p></li> <li><p>A slice object with labels <code class="docutils literal notranslate"><span class="pre">'a':'f'</span></code> (Note that contrary to usual Python slices, <strong>both</strong> the start and the stop are included, when present in the index! See <a class="reference internal" href="#indexing-slicing-with-labels"><span class="std std-ref">Slicing with labels</span></a>.</p></li> <li><p>A boolean array.</p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code>, see <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [45]: s1 = pd.Series(np.random.randn(6), index=list('abcdef'))

In [46]: s1
Out[46]: 
a    1.431256
b    1.340309
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
dtype: float64

In [47]: s1.loc['c':]
Out[47]: 
c   -1.170299
d   -0.226169
e    0.410835
f    0.813850
dtype: float64

In [48]: s1.loc['b']
Out[48]: 1.3403088497993827
</pre></div> </div> <p>Note that setting works as well:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [49]: s1.loc['c':] = 0

In [50]: s1
Out[50]: 
a    1.431256
b    1.340309
c    0.000000
d    0.000000
e    0.000000
f    0.000000
dtype: float64
</pre></div> </div> <p>With a DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [51]: df1 = pd.DataFrame(np.random.randn(6, 4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [52]: df1
Out[52]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
c  1.024180  0.569605  0.875906 -2.211372
d  0.974466 -2.006747 -0.410001 -0.078638
e  0.545952 -1.219217 -1.226825  0.769804
f -1.281247 -0.727707 -0.121306 -0.097883

In [53]: df1.loc[['a', 'b', 'd'], :]
Out[53]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
b  1.130127 -1.436737 -1.413681  1.607920
d  0.974466 -2.006747 -0.410001 -0.078638
</pre></div> </div> <p>Accessing via label slices:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [54]: df1.loc['d':, 'A':'C']
Out[54]: 
          A         B         C
d  0.974466 -2.006747 -0.410001
e  0.545952 -1.219217 -1.226825
f -1.281247 -0.727707 -0.121306
</pre></div> </div> <p>For getting a cross section using a label (equivalent to <code class="docutils literal notranslate"><span class="pre">df.xs('a')</span></code>):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [55]: df1.loc['a']
Out[55]: 
A    0.132003
B   -0.827317
C   -0.076467
D   -1.187678
Name: a, dtype: float64
</pre></div> </div> <p>For getting values with a boolean array:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [56]: df1.loc['a'] &gt; 0
Out[56]: 
A     True
B    False
C    False
D    False
Name: a, dtype: bool

In [57]: df1.loc[:, df1.loc['a'] &gt; 0]
Out[57]: 
          A
a  0.132003
b  1.130127
c  1.024180
d  0.974466
e  0.545952
f -1.281247
</pre></div> </div> <p>NA values in a boolean array propagate as <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [58]: mask = pd.array([True, False, True, False, pd.NA, False], dtype="boolean")

In [59]: mask
Out[59]: 
&lt;BooleanArray&gt;
[True, False, True, False, &lt;NA&gt;, False]
Length: 6, dtype: boolean

In [60]: df1[mask]
Out[60]: 
          A         B         C         D
a  0.132003 -0.827317 -0.076467 -1.187678
c  1.024180  0.569605  0.875906 -2.211372
</pre></div> </div> <p>For getting a value explicitly:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># this is also equivalent to ``df1.at['a','A']``
In [61]: df1.loc['a', 'A']
Out[61]: 0.13200317033032932
</pre></div> </div> <section id="slicing-with-labels"> <h3>Slicing with labels</h3> <p>When using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> with slices, if both the start and the stop labels are present in the index, then elements <em>located</em> between the two (including them) are returned:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [62]: s = pd.Series(list('abcde'), index=[0, 3, 2, 5, 4])

In [63]: s.loc[3:5]
Out[63]: 
3    b
2    c
5    d
dtype: object
</pre></div> </div> <p>If at least one of the two is absent, but the index is sorted, and can be compared against start and stop labels, then slicing will still work as expected, by selecting labels which <em>rank</em> between the two:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [64]: s.sort_index()
Out[64]: 
0    a
2    c
3    b
4    e
5    d
dtype: object

In [65]: s.sort_index().loc[1:6]
Out[65]: 
2    c
3    b
4    e
5    d
dtype: object
</pre></div> </div> <p>However, if at least one of the two is absent <em>and</em> the index is not sorted, an error will be raised (since doing otherwise would be computationally expensive, as well as potentially ambiguous for mixed type indexes). For instance, in the above example, <code class="docutils literal notranslate"><span class="pre">s.loc[1:6]</span></code> would raise <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p> <p>For the rationale behind this behavior, see <a class="reference internal" href="advanced.html#advanced-endpoints-are-inclusive"><span class="std std-ref">Endpoints are inclusive</span></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [66]: s = pd.Series(list('abcdef'), index=[0, 3, 2, 5, 4, 2])

In [67]: s.loc[3:5]
Out[67]: 
3    b
2    c
5    d
dtype: object
</pre></div> </div> <p>Also, if the index has duplicate labels <em>and</em> either the start or the stop label is duplicated, an error will be raised. For instance, in the above example, <code class="docutils literal notranslate"><span class="pre">s.loc[2:5]</span></code> would raise a <code class="docutils literal notranslate"><span class="pre">KeyError</span></code>.</p> <p>For more information about duplicate labels, see <a class="reference internal" href="duplicates.html#duplicates"><span class="std std-ref">Duplicate Labels</span></a>.</p> </section> </section> <section id="selection-by-position"> <h2>Selection by position</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Whether a copy or a reference is returned for a setting operation, may depend on the context. This is sometimes called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">assignment</span></code> and should be avoided. See <a class="reference internal" href="#indexing-view-versus-copy"><span class="std std-ref">Returning a View versus Copy</span></a>.</p> </div> <p>pandas provides a suite of methods in order to get <strong>purely integer based indexing</strong>. The semantics follow closely Python and NumPy slicing. These are <code class="docutils literal notranslate"><span class="pre">0-based</span></code> indexing. When slicing, the start bound is <em>included</em>, while the upper bound is <em>excluded</em>. Trying to use a non-integer, even a <strong>valid</strong> label will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p> <p>The <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> attribute is the primary access method. The following are valid inputs:</p> <ul class="simple"> <li><p>An integer e.g. <code class="docutils literal notranslate"><span class="pre">5</span></code>.</p></li> <li><p>A list or array of integers <code class="docutils literal notranslate"><span class="pre">[4,</span> <span class="pre">3,</span> <span class="pre">0]</span></code>.</p></li> <li><p>A slice object with ints <code class="docutils literal notranslate"><span class="pre">1:7</span></code>.</p></li> <li><p>A boolean array.</p></li> <li><p>A <code class="docutils literal notranslate"><span class="pre">callable</span></code>, see <a class="reference internal" href="#indexing-callable"><span class="std std-ref">Selection By Callable</span></a>.</p></li> <li><p>A tuple of row (and column) indexes, whose elements are one of the above types.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [68]: s1 = pd.Series(np.random.randn(5), index=list(range(0, 10, 2)))

In [69]: s1
Out[69]: 
0    0.695775
2    0.341734
4    0.959726
6   -1.110336
8   -0.619976
dtype: float64

In [70]: s1.iloc[:3]
Out[70]: 
0    0.695775
2    0.341734
4    0.959726
dtype: float64

In [71]: s1.iloc[3]
Out[71]: -1.110336102891167
</pre></div> </div> <p>Note that setting works as well:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [72]: s1.iloc[:3] = 0

In [73]: s1
Out[73]: 
0    0.000000
2    0.000000
4    0.000000
6   -1.110336
8   -0.619976
dtype: float64
</pre></div> </div> <p>With a DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [74]: df1 = pd.DataFrame(np.random.randn(6, 4),
   ....:                    index=list(range(0, 12, 2)),
   ....:                    columns=list(range(0, 8, 2)))
   ....: 

In [75]: df1
Out[75]: 
           0         2         4         6
0   0.149748 -0.732339  0.687738  0.176444
2   0.403310 -0.154951  0.301624 -2.179861
4  -1.369849 -0.954208  1.462696 -1.743161
6  -0.826591 -0.345352  1.314232  0.690579
8   0.995761  2.396780  0.014871  3.357427
10 -0.317441 -1.236269  0.896171 -0.487602
</pre></div> </div> <p>Select via integer slicing:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [76]: df1.iloc[:3]
Out[76]: 
          0         2         4         6
0  0.149748 -0.732339  0.687738  0.176444
2  0.403310 -0.154951  0.301624 -2.179861
4 -1.369849 -0.954208  1.462696 -1.743161

In [77]: df1.iloc[1:5, 2:4]
Out[77]: 
          4         6
2  0.301624 -2.179861
4  1.462696 -1.743161
6  1.314232  0.690579
8  0.014871  3.357427
</pre></div> </div> <p>Select via integer list:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [78]: df1.iloc[[1, 3, 5], [1, 3]]
Out[78]: 
           2         6
2  -0.154951 -2.179861
6  -0.345352  0.690579
10 -1.236269 -0.487602
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: df1.iloc[1:3, :]
Out[79]: 
          0         2         4         6
2  0.403310 -0.154951  0.301624 -2.179861
4 -1.369849 -0.954208  1.462696 -1.743161
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [80]: df1.iloc[:, 1:3]
Out[80]: 
           2         4
0  -0.732339  0.687738
2  -0.154951  0.301624
4  -0.954208  1.462696
6  -0.345352  1.314232
8   2.396780  0.014871
10 -1.236269  0.896171
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># this is also equivalent to ``df1.iat[1,1]``
In [81]: df1.iloc[1, 1]
Out[81]: -0.1549507744249032
</pre></div> </div> <p>For getting a cross section using an integer position (equiv to <code class="docutils literal notranslate"><span class="pre">df.xs(1)</span></code>):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [82]: df1.iloc[1]
Out[82]: 
0    0.403310
2   -0.154951
4    0.301624
6   -2.179861
Name: 2, dtype: float64
</pre></div> </div> <p>Out of range slice indexes are handled gracefully just as in Python/NumPy.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># these are allowed in Python/NumPy.
In [83]: x = list('abcdef')

In [84]: x
Out[84]: ['a', 'b', 'c', 'd', 'e', 'f']

In [85]: x[4:10]
Out[85]: ['e', 'f']

In [86]: x[8:10]
Out[86]: []

In [87]: s = pd.Series(x)

In [88]: s
Out[88]: 
0    a
1    b
2    c
3    d
4    e
5    f
dtype: object

In [89]: s.iloc[4:10]
Out[89]: 
4    e
5    f
dtype: object

In [90]: s.iloc[8:10]
Out[90]: Series([], dtype: object)
</pre></div> </div> <p>Note that using slices that go out of bounds can result in an empty axis (e.g. an empty DataFrame being returned).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [91]: dfl = pd.DataFrame(np.random.randn(5, 2), columns=list('AB'))

In [92]: dfl
Out[92]: 
          A         B
0 -0.082240 -2.182937
1  0.380396  0.084844
2  0.432390  1.519970
3 -0.493662  0.600178
4  0.274230  0.132885

In [93]: dfl.iloc[:, 2:3]
Out[93]: 
Empty DataFrame
Columns: []
Index: [0, 1, 2, 3, 4]

In [94]: dfl.iloc[:, 1:3]
Out[94]: 
          B
0 -2.182937
1  0.084844
2  1.519970
3  0.600178
4  0.132885

In [95]: dfl.iloc[4:6]
Out[95]: 
         A         B
4  0.27423  0.132885
</pre></div> </div> <p>A single indexer that is out of bounds will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>. A list of indexers where any element is out of bounds will raise an <code class="docutils literal notranslate"><span class="pre">IndexError</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [96]: dfl.iloc[[4, 5, 6]]
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
File ~/work/pandas/pandas/pandas/core/indexing.py:1714, in _iLocIndexer._get_list_axis(self, key, axis)
   1713 try:
-&gt; 1714     return self.obj._take_with_is_copy(key, axis=axis)
   1715 except IndexError as err:
   1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d

File ~/work/pandas/pandas/pandas/core/generic.py:4153, in NDFrame._take_with_is_copy(self, indices, axis)
   4144 """
   4145 Internal version of the `take` method that sets the `_is_copy`
   4146 attribute to keep track of the parent dataframe (using in indexing
   (...)
   4151 See the docstring of `take` for full explanation of the parameters.
   4152 """
-&gt; 4153 result = self.take(indices=indices, axis=axis)
   4154 # Maybe set copy if we didn't actually change the index.

File ~/work/pandas/pandas/pandas/core/generic.py:4133, in NDFrame.take(self, indices, axis, **kwargs)
   4129     indices = np.arange(
   4130         indices.start, indices.stop, indices.step, dtype=np.intp
   4131     )
-&gt; 4133 new_data = self._mgr.take(
   4134     indices,
   4135     axis=self._get_block_manager_axis(axis),
   4136     verify=True,
   4137 )
   4138 return self._constructor_from_mgr(new_data, axes=new_data.axes).__finalize__(
   4139     self, method="take"
   4140 )

File ~/work/pandas/pandas/pandas/core/internals/managers.py:891, in BaseBlockManager.take(self, indexer, axis, verify)
    890 n = self.shape[axis]
--&gt; 891 indexer = maybe_convert_indices(indexer, n, verify=verify)
    893 new_labels = self.axes[axis].take(indexer)

File ~/work/pandas/pandas/pandas/core/indexers/utils.py:282, in maybe_convert_indices(indices, n, verify)
    281     if mask.any():
--&gt; 282         raise IndexError("indices are out-of-bounds")
    283 return indices

IndexError: indices are out-of-bounds

The above exception was the direct cause of the following exception:

IndexError                                Traceback (most recent call last)
Cell In[96], line 1
----&gt; 1 dfl.iloc[[4, 5, 6]]

File ~/work/pandas/pandas/pandas/core/indexing.py:1191, in _LocationIndexer.__getitem__(self, key)
   1189 maybe_callable = com.apply_if_callable(key, self.obj)
   1190 maybe_callable = self._check_deprecated_callable_usage(key, maybe_callable)
-&gt; 1191 return self._getitem_axis(maybe_callable, axis=axis)

File ~/work/pandas/pandas/pandas/core/indexing.py:1743, in _iLocIndexer._getitem_axis(self, key, axis)
   1741 # a list of integers
   1742 elif is_list_like_indexer(key):
-&gt; 1743     return self._get_list_axis(key, axis=axis)
   1745 # a single integer
   1746 else:
   1747     key = item_from_zerodim(key)

File ~/work/pandas/pandas/pandas/core/indexing.py:1717, in _iLocIndexer._get_list_axis(self, key, axis)
   1714     return self.obj._take_with_is_copy(key, axis=axis)
   1715 except IndexError as err:
   1716     # re-raise with different error message, e.g. test_getitem_ndarray_3d
-&gt; 1717     raise IndexError("positional indexers are out-of-bounds") from err

IndexError: positional indexers are out-of-bounds
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [97]: dfl.iloc[:, 4]
---------------------------------------------------------------------------
IndexError                                Traceback (most recent call last)
Cell In[97], line 1
----&gt; 1 dfl.iloc[:, 4]

File ~/work/pandas/pandas/pandas/core/indexing.py:1184, in _LocationIndexer.__getitem__(self, key)
   1182     if self._is_scalar_access(key):
   1183         return self.obj._get_value(*key, takeable=self._takeable)
-&gt; 1184     return self._getitem_tuple(key)
   1185 else:
   1186     # we by definition only have the 0th axis
   1187     axis = self.axis or 0

File ~/work/pandas/pandas/pandas/core/indexing.py:1690, in _iLocIndexer._getitem_tuple(self, tup)
   1689 def _getitem_tuple(self, tup: tuple):
-&gt; 1690     tup = self._validate_tuple_indexer(tup)
   1691     with suppress(IndexingError):
   1692         return self._getitem_lowerdim(tup)

File ~/work/pandas/pandas/pandas/core/indexing.py:966, in _LocationIndexer._validate_tuple_indexer(self, key)
    964 for i, k in enumerate(key):
    965     try:
--&gt; 966         self._validate_key(k, i)
    967     except ValueError as err:
    968         raise ValueError(
    969             "Location based indexing can only have "
    970             f"[{self._valid_types}] types"
    971         ) from err

File ~/work/pandas/pandas/pandas/core/indexing.py:1592, in _iLocIndexer._validate_key(self, key, axis)
   1590     return
   1591 elif is_integer(key):
-&gt; 1592     self._validate_integer(key, axis)
   1593 elif isinstance(key, tuple):
   1594     # a tuple should already have been caught by this point
   1595     # so don't treat a tuple as a valid indexer
   1596     raise IndexingError("Too many indexers")

File ~/work/pandas/pandas/pandas/core/indexing.py:1685, in _iLocIndexer._validate_integer(self, key, axis)
   1683 len_axis = len(self.obj._get_axis(axis))
   1684 if key &gt;= len_axis or key &lt; -len_axis:
-&gt; 1685     raise IndexError("single positional indexer is out-of-bounds")

IndexError: single positional indexer is out-of-bounds
</pre></div> </div> </section> <section id="selection-by-callable"> <h2>Selection by callable</h2> <p><code class="docutils literal notranslate"><span class="pre">.loc</span></code>, <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, and also <code class="docutils literal notranslate"><span class="pre">[]</span></code> indexing can accept a <code class="docutils literal notranslate"><span class="pre">callable</span></code> as indexer. The <code class="docutils literal notranslate"><span class="pre">callable</span></code> must be a function with one argument (the calling Series or DataFrame) that returns valid output for indexing.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For <code class="docutils literal notranslate"><span class="pre">.iloc</span></code> indexing, returning a tuple from the callable is not supported, since tuple destructuring for row and column indexes occurs <em>before</em> applying callables.</p> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [98]: df1 = pd.DataFrame(np.random.randn(6, 4),
   ....:                    index=list('abcdef'),
   ....:                    columns=list('ABCD'))
   ....: 

In [99]: df1
Out[99]: 
          A         B         C         D
a -0.023688  2.410179  1.450520  0.206053
b -0.251905 -2.213588  1.063327  1.266143
c  0.299368 -0.863838  0.408204 -1.048089
d -0.025747 -0.988387  0.094055  1.262731
e  1.289997  0.082423 -0.055758  0.536580
f -0.489682  0.369374 -0.034571 -2.484478

In [100]: df1.loc[lambda df: df['A'] &gt; 0, :]
Out[100]: 
          A         B         C         D
c  0.299368 -0.863838  0.408204 -1.048089
e  1.289997  0.082423 -0.055758  0.536580

In [101]: df1.loc[:, lambda df: ['A', 'B']]
Out[101]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

In [102]: df1.iloc[:, lambda df: [0, 1]]
Out[102]: 
          A         B
a -0.023688  2.410179
b -0.251905 -2.213588
c  0.299368 -0.863838
d -0.025747 -0.988387
e  1.289997  0.082423
f -0.489682  0.369374

In [103]: df1[lambda df: df.columns[0]]
Out[103]: 
a   -0.023688
b   -0.251905
c    0.299368
d   -0.025747
e    1.289997
f   -0.489682
Name: A, dtype: float64
</pre></div> </div> <p>You can use callable indexing in <code class="docutils literal notranslate"><span class="pre">Series</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [104]: df1['A'].loc[lambda s: s &gt; 0]
Out[104]: 
c    0.299368
e    1.289997
Name: A, dtype: float64
</pre></div> </div> <p>Using these methods / indexers, you can chain data selection operations without using a temporary variable.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [105]: bb = pd.read_csv('data/baseball.csv', index_col='id')

In [106]: (bb.groupby(['year', 'team']).sum(numeric_only=True)
   .....:    .loc[lambda df: df['r'] &gt; 100])
   .....: 
Out[106]: 
           stint    g    ab    r    h  X2b  ...     so   ibb   hbp    sh    sf  gidp
year team                                   ...                                     
2007 CIN       6  379   745  101  203   35  ...  127.0  14.0   1.0   1.0  15.0  18.0
     DET       5  301  1062  162  283   54  ...  176.0   3.0  10.0   4.0   8.0  28.0
     HOU       4  311   926  109  218   47  ...  212.0   3.0   9.0  16.0   6.0  17.0
     LAN      11  413  1021  153  293   61  ...  141.0   8.0   9.0   3.0   8.0  29.0
     NYN      13  622  1854  240  509  101  ...  310.0  24.0  23.0  18.0  15.0  48.0
     SFN       5  482  1305  198  337   67  ...  188.0  51.0   8.0  16.0   6.0  41.0
     TEX       2  198   729  115  200   40  ...  140.0   4.0   5.0   2.0   8.0  16.0
     TOR       4  459  1408  187  378   96  ...  265.0  16.0  12.0   4.0  16.0  38.0

[8 rows x 18 columns]
</pre></div> </div> </section> <section id="combining-positional-and-label-based-indexing"> <h2>Combining positional and label-based indexing</h2> <p>If you wish to get the 0th and the 2nd elements from the index in the ‘A’ column, you can do:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [107]: dfd = pd.DataFrame({'A': [1, 2, 3],
   .....:                     'B': [4, 5, 6]},
   .....:                    index=list('abc'))
   .....: 

In [108]: dfd
Out[108]: 
   A  B
a  1  4
b  2  5
c  3  6

In [109]: dfd.loc[dfd.index[[0, 2]], 'A']
Out[109]: 
a    1
c    3
Name: A, dtype: int64
</pre></div> </div> <p>This can also be expressed using <code class="docutils literal notranslate"><span class="pre">.iloc</span></code>, by explicitly getting locations on the indexers, and using <em>positional</em> indexing to select things.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [110]: dfd.iloc[[0, 2], dfd.columns.get_loc('A')]
Out[110]: 
a    1
c    3
Name: A, dtype: int64
</pre></div> </div> <p>For getting <em>multiple</em> indexers, using <code class="docutils literal notranslate"><span class="pre">.get_indexer</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [111]: dfd.iloc[[0, 2], dfd.columns.get_indexer(['A', 'B'])]
Out[111]: 
   A  B
a  1  4
c  3  6
</pre></div> </div> <section id="reindexing"> <h3>Reindexing</h3> <p>The idiomatic way to achieve selecting potentially not-found elements is via <code class="docutils literal notranslate"><span class="pre">.reindex()</span></code>. See also the section on <a class="reference internal" href="basics.html#basics-reindexing"><span class="std std-ref">reindexing</span></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: s = pd.Series([1, 2, 3])

In [113]: s.reindex([1, 2, 3])
Out[113]: 
1    2.0
2    3.0
3    NaN
dtype: float64
</pre></div> </div> <p>Alternatively, if you want to select only <em>valid</em> keys, the following is idiomatic and efficient; it is guaranteed to preserve the dtype of the selection.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [114]: labels = [1, 2, 3]

In [115]: s.loc[s.index.intersection(labels)]
Out[115]: 
1    2
2    3
dtype: int64
</pre></div> </div> <p>Having a duplicated index will raise for a <code class="docutils literal notranslate"><span class="pre">.reindex()</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [116]: s = pd.Series(np.arange(4), index=['a', 'a', 'b', 'c'])

In [117]: labels = ['c', 'd']

In [118]: s.reindex(labels)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[118], line 1
----&gt; 1 s.reindex(labels)

File ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)
   5136 @doc(
   5137     NDFrame.reindex,  # type: ignore[has-type]
   5138     klass=_shared_doc_kwargs["klass"],
   (...)
   5151     tolerance=None,
   5152 ) -&gt; Series:
-&gt; 5153     return super().reindex(
   5154         index=index,
   5155         method=method,
   5156         copy=copy,
   5157         level=level,
   5158         fill_value=fill_value,
   5159         limit=limit,
   5160         tolerance=tolerance,
   5161     )

File ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)
   5607     return self._reindex_multi(axes, copy, fill_value)
   5609 # perform the reindex on the axes
-&gt; 5610 return self._reindex_axes(
   5611     axes, level, limit, tolerance, method, fill_value, copy
   5612 ).__finalize__(self, method="reindex")

File ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)
   5630     continue
   5632 ax = self._get_axis(a)
-&gt; 5633 new_index, indexer = ax.reindex(
   5634     labels, level=level, limit=limit, tolerance=tolerance, method=method
   5635 )
   5637 axis = self._get_axis_number(a)
   5638 obj = obj._reindex_with_indexers(
   5639     {axis: [new_index, indexer]},
   5640     fill_value=fill_value,
   5641     copy=copy,
   5642     allow_dups=False,
   5643 )

File ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)
   4426     raise ValueError("cannot handle a non-unique multi-index!")
   4427 elif not self.is_unique:
   4428     # GH#42568
-&gt; 4429     raise ValueError("cannot reindex on an axis with duplicate labels")
   4430 else:
   4431     indexer, _ = self.get_indexer_non_unique(target)

ValueError: cannot reindex on an axis with duplicate labels
</pre></div> </div> <p>Generally, you can intersect the desired labels with the current axis, and then reindex.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [119]: s.loc[s.index.intersection(labels)].reindex(labels)
Out[119]: 
c    3.0
d    NaN
dtype: float64
</pre></div> </div> <p>However, this would <em>still</em> raise if your resulting index is duplicated.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [120]: labels = ['a', 'd']

In [121]: s.loc[s.index.intersection(labels)].reindex(labels)
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
Cell In[121], line 1
----&gt; 1 s.loc[s.index.intersection(labels)].reindex(labels)

File ~/work/pandas/pandas/pandas/core/series.py:5153, in Series.reindex(self, index, axis, method, copy, level, fill_value, limit, tolerance)
   5136 @doc(
   5137     NDFrame.reindex,  # type: ignore[has-type]
   5138     klass=_shared_doc_kwargs["klass"],
   (...)
   5151     tolerance=None,
   5152 ) -&gt; Series:
-&gt; 5153     return super().reindex(
   5154         index=index,
   5155         method=method,
   5156         copy=copy,
   5157         level=level,
   5158         fill_value=fill_value,
   5159         limit=limit,
   5160         tolerance=tolerance,
   5161     )

File ~/work/pandas/pandas/pandas/core/generic.py:5610, in NDFrame.reindex(self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance)
   5607     return self._reindex_multi(axes, copy, fill_value)
   5609 # perform the reindex on the axes
-&gt; 5610 return self._reindex_axes(
   5611     axes, level, limit, tolerance, method, fill_value, copy
   5612 ).__finalize__(self, method="reindex")

File ~/work/pandas/pandas/pandas/core/generic.py:5633, in NDFrame._reindex_axes(self, axes, level, limit, tolerance, method, fill_value, copy)
   5630     continue
   5632 ax = self._get_axis(a)
-&gt; 5633 new_index, indexer = ax.reindex(
   5634     labels, level=level, limit=limit, tolerance=tolerance, method=method
   5635 )
   5637 axis = self._get_axis_number(a)
   5638 obj = obj._reindex_with_indexers(
   5639     {axis: [new_index, indexer]},
   5640     fill_value=fill_value,
   5641     copy=copy,
   5642     allow_dups=False,
   5643 )

File ~/work/pandas/pandas/pandas/core/indexes/base.py:4429, in Index.reindex(self, target, method, level, limit, tolerance)
   4426     raise ValueError("cannot handle a non-unique multi-index!")
   4427 elif not self.is_unique:
   4428     # GH#42568
-&gt; 4429     raise ValueError("cannot reindex on an axis with duplicate labels")
   4430 else:
   4431     indexer, _ = self.get_indexer_non_unique(target)

ValueError: cannot reindex on an axis with duplicate labels
</pre></div> </div> </section> </section> <section id="selecting-random-samples"> <h2>Selecting random samples</h2> <p>A random selection of rows or columns from a Series or DataFrame with the <a class="reference internal" href="../reference/api/pandas.dataframe.sample.html#pandas.DataFrame.sample" title="pandas.DataFrame.sample"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sample()</span></code></a> method. The method will sample rows by default, and accepts a specific number of rows/columns to return, or a fraction of rows.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [122]: s = pd.Series([0, 1, 2, 3, 4, 5])

# When no arguments are passed, returns 1 row.
In [123]: s.sample()
Out[123]: 
4    4
dtype: int64

# One may specify either a number of rows:
In [124]: s.sample(n=3)
Out[124]: 
0    0
4    4
1    1
dtype: int64

# Or a fraction of the rows:
In [125]: s.sample(frac=0.5)
Out[125]: 
5    5
3    3
1    1
dtype: int64
</pre></div> </div> <p>By default, <code class="docutils literal notranslate"><span class="pre">sample</span></code> will return each row at most once, but one can also sample with replacement using the <code class="docutils literal notranslate"><span class="pre">replace</span></code> option:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [126]: s = pd.Series([0, 1, 2, 3, 4, 5])

# Without replacement (default):
In [127]: s.sample(n=6, replace=False)
Out[127]: 
0    0
1    1
5    5
3    3
2    2
4    4
dtype: int64

# With replacement:
In [128]: s.sample(n=6, replace=True)
Out[128]: 
0    0
4    4
3    3
2    2
4    4
4    4
dtype: int64
</pre></div> </div> <p>By default, each row has an equal probability of being selected, but if you want rows to have different probabilities, you can pass the <code class="docutils literal notranslate"><span class="pre">sample</span></code> function sampling weights as <code class="docutils literal notranslate"><span class="pre">weights</span></code>. These weights can be a list, a NumPy array, or a Series, but they must be of the same length as the object you are sampling. Missing values will be treated as a weight of zero, and inf values are not allowed. If weights do not sum to 1, they will be re-normalized by dividing all weights by the sum of the weights. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [129]: s = pd.Series([0, 1, 2, 3, 4, 5])

In [130]: example_weights = [0, 0, 0.2, 0.2, 0.2, 0.4]

In [131]: s.sample(n=3, weights=example_weights)
Out[131]: 
5    5
4    4
3    3
dtype: int64

# Weights will be re-normalized automatically
In [132]: example_weights2 = [0.5, 0, 0, 0, 0, 0]

In [133]: s.sample(n=1, weights=example_weights2)
Out[133]: 
0    0
dtype: int64
</pre></div> </div> <p>When applied to a DataFrame, you can use a column of the DataFrame as sampling weights (provided you are sampling rows and not columns) by simply passing the name of the column as a string.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [134]: df2 = pd.DataFrame({'col1': [9, 8, 7, 6],
   .....:                     'weight_column': [0.5, 0.4, 0.1, 0]})
   .....: 

In [135]: df2.sample(n=3, weights='weight_column')
Out[135]: 
   col1  weight_column
1     8            0.4
0     9            0.5
2     7            0.1
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">sample</span></code> also allows users to sample columns instead of rows using the <code class="docutils literal notranslate"><span class="pre">axis</span></code> argument.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [136]: df3 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})

In [137]: df3.sample(n=1, axis=1)
Out[137]: 
   col1
0     1
1     2
2     3
</pre></div> </div> <p>Finally, one can also set a seed for <code class="docutils literal notranslate"><span class="pre">sample</span></code>’s random number generator using the <code class="docutils literal notranslate"><span class="pre">random_state</span></code> argument, which will accept either an integer (as a seed) or a NumPy RandomState object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [138]: df4 = pd.DataFrame({'col1': [1, 2, 3], 'col2': [2, 3, 4]})

# With a given seed, the sample will always draw the same rows.
In [139]: df4.sample(n=2, random_state=2)
Out[139]: 
   col1  col2
2     3     4
1     2     3

In [140]: df4.sample(n=2, random_state=2)
Out[140]: 
   col1  col2
2     3     4
1     2     3
</pre></div> </div> </section> <section id="setting-with-enlargement"> <h2>Setting with enlargement</h2> <p>The <code class="docutils literal notranslate"><span class="pre">.loc/[]</span></code> operations can perform enlargement when setting a non-existent key for that axis.</p> <p>In the <code class="docutils literal notranslate"><span class="pre">Series</span></code> case this is effectively an appending operation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [141]: se = pd.Series([1, 2, 3])

In [142]: se
Out[142]: 
0    1
1    2
2    3
dtype: int64

In [143]: se[5] = 5.

In [144]: se
Out[144]: 
0    1.0
1    2.0
2    3.0
5    5.0
dtype: float64
</pre></div> </div> <p>A <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> can be enlarged on either axis via <code class="docutils literal notranslate"><span class="pre">.loc</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [145]: dfi = pd.DataFrame(np.arange(6).reshape(3, 2),
   .....:                    columns=['A', 'B'])
   .....: 

In [146]: dfi
Out[146]: 
   A  B
0  0  1
1  2  3
2  4  5

In [147]: dfi.loc[:, 'C'] = dfi.loc[:, 'A']

In [148]: dfi
Out[148]: 
   A  B  C
0  0  1  0
1  2  3  2
2  4  5  4
</pre></div> </div> <p>This is like an <code class="docutils literal notranslate"><span class="pre">append</span></code> operation on the <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [149]: dfi.loc[3] = 5

In [150]: dfi
Out[150]: 
   A  B  C
0  0  1  0
1  2  3  2
2  4  5  4
3  5  5  5
</pre></div> </div> </section> <section id="fast-scalar-value-getting-and-setting"> <h2>Fast scalar value getting and setting</h2> <p>Since indexing with <code class="docutils literal notranslate"><span class="pre">[]</span></code> must handle a lot of cases (single-label access, slicing, boolean indexing, etc.), it has a bit of overhead in order to figure out what you’re asking for. If you only want to access a scalar value, the fastest way is to use the <code class="docutils literal notranslate"><span class="pre">at</span></code> and <code class="docutils literal notranslate"><span class="pre">iat</span></code> methods, which are implemented on all of the data structures.</p> <p>Similarly to <code class="docutils literal notranslate"><span class="pre">loc</span></code>, <code class="docutils literal notranslate"><span class="pre">at</span></code> provides <strong>label</strong> based scalar lookups, while, <code class="docutils literal notranslate"><span class="pre">iat</span></code> provides <strong>integer</strong> based lookups analogously to <code class="docutils literal notranslate"><span class="pre">iloc</span></code></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [151]: s.iat[5]
Out[151]: 5

In [152]: df.at[dates[5], 'A']
Out[152]: 0.1136484096888855

In [153]: df.iat[3, 0]
Out[153]: -0.7067711336300845
</pre></div> </div> <p>You can also set using these same indexers.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [154]: df.at[dates[5], 'E'] = 7

In [155]: df.iat[3, 0] = 7
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">at</span></code> may enlarge the object in-place as above if the indexer is missing.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [156]: df.at[dates[-1] + pd.Timedelta('1 day'), 0] = 7

In [157]: df
Out[157]: 
                   A         B         C         D    E    0
2000-01-01 -0.282863  0.469112 -1.509059 -1.135632  NaN  NaN
2000-01-02 -0.173215  1.212112  0.119209 -1.044236  NaN  NaN
2000-01-03 -2.104569 -0.861849 -0.494929  1.071804  NaN  NaN
2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN  NaN
2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN  NaN
2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0  NaN
2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN  NaN
2000-01-08 -1.157892 -0.370647 -1.344312  0.844885  NaN  NaN
2000-01-09       NaN       NaN       NaN       NaN  NaN  7.0
</pre></div> </div> </section> <section id="boolean-indexing"> <h2>Boolean indexing</h2> <p id="indexing-boolean">Another common operation is the use of boolean vectors to filter the data. The operators are: <code class="docutils literal notranslate"><span class="pre">|</span></code> for <code class="docutils literal notranslate"><span class="pre">or</span></code>, <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> for <code class="docutils literal notranslate"><span class="pre">and</span></code>, and <code class="docutils literal notranslate"><span class="pre">~</span></code> for <code class="docutils literal notranslate"><span class="pre">not</span></code>. These <strong>must</strong> be grouped by using parentheses, since by default Python will evaluate an expression such as <code class="docutils literal notranslate"><span class="pre">df['A']</span> <span class="pre">&gt;</span> <span class="pre">2</span> <span class="pre">&amp;</span> <span class="pre">df['B']</span> <span class="pre">&lt;</span> <span class="pre">3</span></code> as <code class="docutils literal notranslate"><span class="pre">df['A']</span> <span class="pre">&gt;</span> <span class="pre">(2</span> <span class="pre">&amp;</span> <span class="pre">df['B'])</span> <span class="pre">&lt;</span> <span class="pre">3</span></code>, while the desired evaluation order is <code class="docutils literal notranslate"><span class="pre">(df['A']</span> <span class="pre">&gt;</span> <span class="pre">2)</span> <span class="pre">&amp;</span> <span class="pre">(df['B']</span> <span class="pre">&lt;</span> <span class="pre">3)</span></code>.</p> <p>Using a boolean vector to index a Series works exactly as in a NumPy ndarray:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [158]: s = pd.Series(range(-3, 4))

In [159]: s
Out[159]: 
0   -3
1   -2
2   -1
3    0
4    1
5    2
6    3
dtype: int64

In [160]: s[s &gt; 0]
Out[160]: 
4    1
5    2
6    3
dtype: int64

In [161]: s[(s &lt; -1) | (s &gt; 0.5)]
Out[161]: 
0   -3
1   -2
4    1
5    2
6    3
dtype: int64

In [162]: s[~(s &lt; 0)]
Out[162]: 
3    0
4    1
5    2
6    3
dtype: int64
</pre></div> </div> <p>You may select rows from a DataFrame using a boolean vector the same length as the DataFrame’s index (for example, something derived from one of the columns of the DataFrame):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [163]: df[df['A'] &gt; 0]
Out[163]: 
                   A         B         C         D    E   0
2000-01-04  7.000000  0.721555 -1.039575  0.271860  NaN NaN
2000-01-05  0.567020 -0.424972  0.276232 -1.087401  NaN NaN
2000-01-06  0.113648 -0.673690 -1.478427  0.524988  7.0 NaN
2000-01-07  0.577046  0.404705 -1.715002 -1.039268  NaN NaN
</pre></div> </div> <p>List comprehensions and the <code class="docutils literal notranslate"><span class="pre">map</span></code> method of Series can also be used to produce more complex criteria:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [164]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'three', 'two', 'one', 'six'],
   .....:                     'b': ['x', 'y', 'y', 'x', 'y', 'x', 'x'],
   .....:                     'c': np.random.randn(7)})
   .....: 

# only want 'two' or 'three'
In [165]: criterion = df2['a'].map(lambda x: x.startswith('t'))

In [166]: df2[criterion]
Out[166]: 
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

# equivalent but slower
In [167]: df2[[x.startswith('t') for x in df2['a']]]
Out[167]: 
       a  b         c
2    two  y  0.041290
3  three  x  0.361719
4    two  y -0.238075

# Multiple criteria
In [168]: df2[criterion &amp; (df2['b'] == 'x')]
Out[168]: 
       a  b         c
3  three  x  0.361719
</pre></div> </div> <p>With the choice methods <a class="reference internal" href="#indexing-label"><span class="std std-ref">Selection by Label</span></a>, <a class="reference internal" href="#indexing-integer"><span class="std std-ref">Selection by Position</span></a>, and <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> you may select along more than one axis using boolean vectors combined with other indexing expressions.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [169]: df2.loc[criterion &amp; (df2['b'] == 'x'), 'b':'c']
Out[169]: 
   b         c
3  x  0.361719
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><code class="docutils literal notranslate"><span class="pre">iloc</span></code> supports two kinds of boolean indexing. If the indexer is a boolean <code class="docutils literal notranslate"><span class="pre">Series</span></code>, an error will be raised. For instance, in the following example, <code class="docutils literal notranslate"><span class="pre">df.iloc[s.values,</span> <span class="pre">1]</span></code> is ok. The boolean indexer is an array. But <code class="docutils literal notranslate"><span class="pre">df.iloc[s,</span> <span class="pre">1]</span></code> would raise <code class="docutils literal notranslate"><span class="pre">ValueError</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [170]: df = pd.DataFrame([[1, 2], [3, 4], [5, 6]],
   .....:                   index=list('abc'),
   .....:                   columns=['A', 'B'])
   .....: 

In [171]: s = (df['A'] &gt; 2)

In [172]: s
Out[172]: 
a    False
b     True
c     True
Name: A, dtype: bool

In [173]: df.loc[s, 'B']
Out[173]: 
b    4
c    6
Name: B, dtype: int64

In [174]: df.iloc[s.values, 1]
Out[174]: 
b    4
c    6
Name: B, dtype: int64
</pre></div> </div> </div> </section> <section id="indexing-with-isin"> <h2>Indexing with isin</h2> <p>Consider the <a class="reference internal" href="../reference/api/pandas.series.isin.html#pandas.Series.isin" title="pandas.Series.isin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isin()</span></code></a> method of <code class="docutils literal notranslate"><span class="pre">Series</span></code>, which returns a boolean vector that is true wherever the <code class="docutils literal notranslate"><span class="pre">Series</span></code> elements exist in the passed list. This allows you to select rows where one or more columns have values you want:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [175]: s = pd.Series(np.arange(5), index=np.arange(5)[::-1], dtype='int64')

In [176]: s
Out[176]: 
4    0
3    1
2    2
1    3
0    4
dtype: int64

In [177]: s.isin([2, 4, 6])
Out[177]: 
4    False
3    False
2     True
1    False
0     True
dtype: bool

In [178]: s[s.isin([2, 4, 6])]
Out[178]: 
2    2
0    4
dtype: int64
</pre></div> </div> <p>The same method is available for <code class="docutils literal notranslate"><span class="pre">Index</span></code> objects and is useful for the cases when you don’t know which of the sought labels are in fact present:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [179]: s[s.index.isin([2, 4, 6])]
Out[179]: 
4    0
2    2
dtype: int64

# compare it to the following
In [180]: s.reindex([2, 4, 6])
Out[180]: 
2    2.0
4    0.0
6    NaN
dtype: float64
</pre></div> </div> <p>In addition to that, <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> allows selecting a separate level to use in the membership check:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [181]: s_mi = pd.Series(np.arange(6),
   .....:                  index=pd.MultiIndex.from_product([[0, 1], ['a', 'b', 'c']]))
   .....: 

In [182]: s_mi
Out[182]: 
0  a    0
   b    1
   c    2
1  a    3
   b    4
   c    5
dtype: int64

In [183]: s_mi.iloc[s_mi.index.isin([(1, 'a'), (2, 'b'), (0, 'c')])]
Out[183]: 
0  c    2
1  a    3
dtype: int64

In [184]: s_mi.iloc[s_mi.index.isin(['a', 'c', 'e'], level=1)]
Out[184]: 
0  a    0
   c    2
1  a    3
   c    5
dtype: int64
</pre></div> </div> <p>DataFrame also has an <a class="reference internal" href="../reference/api/pandas.dataframe.isin.html#pandas.DataFrame.isin" title="pandas.DataFrame.isin"><code class="xref py py-meth docutils literal notranslate"><span class="pre">isin()</span></code></a> method. When calling <code class="docutils literal notranslate"><span class="pre">isin</span></code>, pass a set of values as either an array or dict. If values is an array, <code class="docutils literal notranslate"><span class="pre">isin</span></code> returns a DataFrame of booleans that is the same shape as the original DataFrame, with True wherever the element is in the sequence of values.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [185]: df = pd.DataFrame({'vals': [1, 2, 3, 4], 'ids': ['a', 'b', 'f', 'n'],
   .....:                    'ids2': ['a', 'n', 'c', 'n']})
   .....: 

In [186]: values = ['a', 'b', 1, 3]

In [187]: df.isin(values)
Out[187]: 
    vals    ids   ids2
0   True   True   True
1  False   True  False
2   True  False  False
3  False  False  False
</pre></div> </div> <p>Oftentimes you’ll want to match certain values with certain columns. Just make values a <code class="docutils literal notranslate"><span class="pre">dict</span></code> where the key is the column, and the value is a list of items you want to check for.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [188]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}

In [189]: df.isin(values)
Out[189]: 
    vals    ids   ids2
0   True   True  False
1  False   True  False
2   True  False  False
3  False  False  False
</pre></div> </div> <p>To return the DataFrame of booleans where the values are <em>not</em> in the original DataFrame, use the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [190]: values = {'ids': ['a', 'b'], 'vals': [1, 3]}

In [191]: ~df.isin(values)
Out[191]: 
    vals    ids  ids2
0  False  False  True
1   True  False  True
2  False   True  True
3   True   True  True
</pre></div> </div> <p>Combine DataFrame’s <code class="docutils literal notranslate"><span class="pre">isin</span></code> with the <code class="docutils literal notranslate"><span class="pre">any()</span></code> and <code class="docutils literal notranslate"><span class="pre">all()</span></code> methods to quickly select subsets of your data that meet a given criteria. To select a row where each column meets its own criterion:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [192]: values = {'ids': ['a', 'b'], 'ids2': ['a', 'c'], 'vals': [1, 3]}

In [193]: row_mask = df.isin(values).all(1)

In [194]: df[row_mask]
Out[194]: 
   vals ids ids2
0     1   a    a
</pre></div> </div> </section> <section id="the-where-method-and-masking"> <h2>The <a class="reference internal" href="../reference/api/pandas.dataframe.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">where()</span></code></a> Method and Masking</h2> <p>Selecting values from a Series with a boolean vector generally returns a subset of the data. To guarantee that selection output has the same shape as the original data, you can use the <code class="docutils literal notranslate"><span class="pre">where</span></code> method in <code class="docutils literal notranslate"><span class="pre">Series</span></code> and <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <p>To return only the selected rows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [195]: s[s &gt; 0]
Out[195]: 
3    1
2    2
1    3
0    4
dtype: int64
</pre></div> </div> <p>To return a Series of the same shape as the original:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [196]: s.where(s &gt; 0)
Out[196]: 
4    NaN
3    1.0
2    2.0
1    3.0
0    4.0
dtype: float64
</pre></div> </div> <p>Selecting values from a DataFrame with a boolean criterion now also preserves input data shape. <code class="docutils literal notranslate"><span class="pre">where</span></code> is used under the hood as the implementation. The code below is equivalent to <code class="docutils literal notranslate"><span class="pre">df.where(df</span> <span class="pre">&lt;</span> <span class="pre">0)</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [197]: dates = pd.date_range('1/1/2000', periods=8)

In [198]: df = pd.DataFrame(np.random.randn(8, 4),
   .....:                   index=dates, columns=['A', 'B', 'C', 'D'])
   .....: 

In [199]: df[df &lt; 0]
Out[199]: 
                   A         B         C         D
2000-01-01 -2.104139 -1.309525       NaN       NaN
2000-01-02 -0.352480       NaN -1.192319       NaN
2000-01-03 -0.864883       NaN -0.227870       NaN
2000-01-04       NaN -1.222082       NaN -1.233203
2000-01-05       NaN -0.605656 -1.169184       NaN
2000-01-06       NaN -0.948458       NaN -0.684718
2000-01-07 -2.670153 -0.114722       NaN -0.048048
2000-01-08       NaN       NaN -0.048788 -0.808838
</pre></div> </div> <p>In addition, <code class="docutils literal notranslate"><span class="pre">where</span></code> takes an optional <code class="docutils literal notranslate"><span class="pre">other</span></code> argument for replacement of values where the condition is False, in the returned copy.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [200]: df.where(df &lt; 0, -df)
Out[200]: 
                   A         B         C         D
2000-01-01 -2.104139 -1.309525 -0.485855 -0.245166
2000-01-02 -0.352480 -0.390389 -1.192319 -1.655824
2000-01-03 -0.864883 -0.299674 -0.227870 -0.281059
2000-01-04 -0.846958 -1.222082 -0.600705 -1.233203
2000-01-05 -0.669692 -0.605656 -1.169184 -0.342416
2000-01-06 -0.868584 -0.948458 -2.297780 -0.684718
2000-01-07 -2.670153 -0.114722 -0.168904 -0.048048
2000-01-08 -0.801196 -1.392071 -0.048788 -0.808838
</pre></div> </div> <p>You may wish to set values based on some boolean criteria. This can be done intuitively like so:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [201]: s2 = s.copy()

In [202]: s2[s2 &lt; 0] = 0

In [203]: s2
Out[203]: 
4    0
3    1
2    2
1    3
0    4
dtype: int64

In [204]: df2 = df.copy()

In [205]: df2[df2 &lt; 0] = 0

In [206]: df2
Out[206]: 
                   A         B         C         D
2000-01-01  0.000000  0.000000  0.485855  0.245166
2000-01-02  0.000000  0.390389  0.000000  1.655824
2000-01-03  0.000000  0.299674  0.000000  0.281059
2000-01-04  0.846958  0.000000  0.600705  0.000000
2000-01-05  0.669692  0.000000  0.000000  0.342416
2000-01-06  0.868584  0.000000  2.297780  0.000000
2000-01-07  0.000000  0.000000  0.168904  0.000000
2000-01-08  0.801196  1.392071  0.000000  0.000000
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">where</span></code> returns a modified copy of the data.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The signature for <a class="reference internal" href="../reference/api/pandas.dataframe.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.where()</span></code></a> differs from <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Roughly <code class="docutils literal notranslate"><span class="pre">df1.where(m,</span> <span class="pre">df2)</span></code> is equivalent to <code class="docutils literal notranslate"><span class="pre">np.where(m,</span> <span class="pre">df1,</span> <span class="pre">df2)</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [207]: df.where(df &lt; 0, -df) == np.where(df &lt; 0, df, -df)
Out[207]: 
               A     B     C     D
2000-01-01  True  True  True  True
2000-01-02  True  True  True  True
2000-01-03  True  True  True  True
2000-01-04  True  True  True  True
2000-01-05  True  True  True  True
2000-01-06  True  True  True  True
2000-01-07  True  True  True  True
2000-01-08  True  True  True  True
</pre></div> </div> </div> <p><strong>Alignment</strong></p> <p>Furthermore, <code class="docutils literal notranslate"><span class="pre">where</span></code> aligns the input boolean condition (ndarray or DataFrame), such that partial selection with setting is possible. This is analogous to partial setting via <code class="docutils literal notranslate"><span class="pre">.loc</span></code> (but on the contents rather than the axis labels).</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [208]: df2 = df.copy()

In [209]: df2[df2[1:4] &gt; 0] = 3

In [210]: df2
Out[210]: 
                   A         B         C         D
2000-01-01 -2.104139 -1.309525  0.485855  0.245166
2000-01-02 -0.352480  3.000000 -1.192319  3.000000
2000-01-03 -0.864883  3.000000 -0.227870  3.000000
2000-01-04  3.000000 -1.222082  3.000000 -1.233203
2000-01-05  0.669692 -0.605656 -1.169184  0.342416
2000-01-06  0.868584 -0.948458  2.297780 -0.684718
2000-01-07 -2.670153 -0.114722  0.168904 -0.048048
2000-01-08  0.801196  1.392071 -0.048788 -0.808838
</pre></div> </div> <p>Where can also accept <code class="docutils literal notranslate"><span class="pre">axis</span></code> and <code class="docutils literal notranslate"><span class="pre">level</span></code> parameters to align the input when performing the <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [211]: df2 = df.copy()

In [212]: df2.where(df2 &gt; 0, df2['A'], axis='index')
Out[212]: 
                   A         B         C         D
2000-01-01 -2.104139 -2.104139  0.485855  0.245166
2000-01-02 -0.352480  0.390389 -0.352480  1.655824
2000-01-03 -0.864883  0.299674 -0.864883  0.281059
2000-01-04  0.846958  0.846958  0.600705  0.846958
2000-01-05  0.669692  0.669692  0.669692  0.342416
2000-01-06  0.868584  0.868584  2.297780  0.868584
2000-01-07 -2.670153 -2.670153  0.168904 -2.670153
2000-01-08  0.801196  1.392071  0.801196  0.801196
</pre></div> </div> <p>This is equivalent to (but faster than) the following.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [213]: df2 = df.copy()

In [214]: df.apply(lambda x, y: x.where(x &gt; 0, y), y=df['A'])
Out[214]: 
                   A         B         C         D
2000-01-01 -2.104139 -2.104139  0.485855  0.245166
2000-01-02 -0.352480  0.390389 -0.352480  1.655824
2000-01-03 -0.864883  0.299674 -0.864883  0.281059
2000-01-04  0.846958  0.846958  0.600705  0.846958
2000-01-05  0.669692  0.669692  0.669692  0.342416
2000-01-06  0.868584  0.868584  2.297780  0.868584
2000-01-07 -2.670153 -2.670153  0.168904 -2.670153
2000-01-08  0.801196  1.392071  0.801196  0.801196
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">where</span></code> can accept a callable as condition and <code class="docutils literal notranslate"><span class="pre">other</span></code> arguments. The function must be with one argument (the calling Series or DataFrame) and that returns valid output as condition and <code class="docutils literal notranslate"><span class="pre">other</span></code> argument.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [215]: df3 = pd.DataFrame({'A': [1, 2, 3],
   .....:                     'B': [4, 5, 6],
   .....:                     'C': [7, 8, 9]})
   .....: 

In [216]: df3.where(lambda x: x &gt; 4, lambda x: x + 10)
Out[216]: 
    A   B  C
0  11  14  7
1  12   5  8
2  13   6  9
</pre></div> </div> <section id="mask"> <h3>Mask</h3> <p><a class="reference internal" href="../reference/api/pandas.dataframe.mask.html#pandas.DataFrame.mask" title="pandas.DataFrame.mask"><code class="xref py py-meth docutils literal notranslate"><span class="pre">mask()</span></code></a> is the inverse boolean operation of <code class="docutils literal notranslate"><span class="pre">where</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [217]: s.mask(s &gt;= 0)
Out[217]: 
4   NaN
3   NaN
2   NaN
1   NaN
0   NaN
dtype: float64

In [218]: df.mask(df &gt;= 0)
Out[218]: 
                   A         B         C         D
2000-01-01 -2.104139 -1.309525       NaN       NaN
2000-01-02 -0.352480       NaN -1.192319       NaN
2000-01-03 -0.864883       NaN -0.227870       NaN
2000-01-04       NaN -1.222082       NaN -1.233203
2000-01-05       NaN -0.605656 -1.169184       NaN
2000-01-06       NaN -0.948458       NaN -0.684718
2000-01-07 -2.670153 -0.114722       NaN -0.048048
2000-01-08       NaN       NaN -0.048788 -0.808838
</pre></div> </div> </section> </section> <section id="setting-with-enlargement-conditionally-using-numpy"> <h2>Setting with enlargement conditionally using <code class="xref py py-func docutils literal notranslate"><span class="pre">numpy()</span></code>
</h2> <p>An alternative to <a class="reference internal" href="../reference/api/pandas.dataframe.where.html#pandas.DataFrame.where" title="pandas.DataFrame.where"><code class="xref py py-meth docutils literal notranslate"><span class="pre">where()</span></code></a> is to use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.where()</span></code></a>. Combined with setting a new column, you can use it to enlarge a DataFrame where the values are determined conditionally.</p> <p>Consider you have two choices to choose from in the following DataFrame. And you want to set a new column color to ‘green’ when the second column has ‘Z’. You can do the following:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [219]: df = pd.DataFrame({'col1': list('ABBC'), 'col2': list('ZZXY')})

In [220]: df['color'] = np.where(df['col2'] == 'Z', 'green', 'red')

In [221]: df
Out[221]: 
  col1 col2  color
0    A    Z  green
1    B    Z  green
2    B    X    red
3    C    Y    red
</pre></div> </div> <p>If you have multiple conditions, you can use <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select" title="(in NumPy v1.26)"><code class="xref py py-func docutils literal notranslate"><span class="pre">numpy.select()</span></code></a> to achieve that. Say corresponding to three conditions there are three choice of colors, with a fourth color as a fallback, you can do the following.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [222]: conditions = [
   .....:     (df['col2'] == 'Z') &amp; (df['col1'] == 'A'),
   .....:     (df['col2'] == 'Z') &amp; (df['col1'] == 'B'),
   .....:     (df['col1'] == 'B')
   .....: ]
   .....: 

In [223]: choices = ['yellow', 'blue', 'purple']

In [224]: df['color'] = np.select(conditions, choices, default='black')

In [225]: df
Out[225]: 
  col1 col2   color
0    A    Z  yellow
1    B    Z    blue
2    B    X  purple
3    C    Y   black
</pre></div> </div> </section> <section id="the-query-method"> <h2>The <a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Method</h2> <p><a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects have a <a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> method that allows selection using an expression.</p> <p>You can get the value of the frame where column <code class="docutils literal notranslate"><span class="pre">b</span></code> has values between the values of columns <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">c</span></code>. For example:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [226]: n = 10

In [227]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [228]: df
Out[228]: 
          a         b         c
0  0.438921  0.118680  0.863670
1  0.138138  0.577363  0.686602
2  0.595307  0.564592  0.520630
3  0.913052  0.926075  0.616184
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
6  0.792342  0.216974  0.564056
7  0.397890  0.454131  0.915716
8  0.074315  0.437913  0.019794
9  0.559209  0.502065  0.026437

# pure python
In [229]: df[(df['a'] &lt; df['b']) &amp; (df['b'] &lt; df['c'])]
Out[229]: 
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716

# query
In [230]: df.query('(a &lt; b) &amp; (b &lt; c)')
Out[230]: 
          a         b         c
1  0.138138  0.577363  0.686602
4  0.078718  0.854477  0.898725
5  0.076404  0.523211  0.591538
7  0.397890  0.454131  0.915716
</pre></div> </div> <p>Do the same thing but fall back on a named index if there is no column with the name <code class="docutils literal notranslate"><span class="pre">a</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [231]: df = pd.DataFrame(np.random.randint(n / 2, size=(n, 2)), columns=list('bc'))

In [232]: df.index.name = 'a'

In [233]: df
Out[233]: 
   b  c
a      
0  0  4
1  0  1
2  3  4
3  4  3
4  1  4
5  0  3
6  0  1
7  3  4
8  2  3
9  1  1

In [234]: df.query('a &lt; b and b &lt; c')
Out[234]: 
   b  c
a      
2  3  4
</pre></div> </div> <p>If instead you don’t want to or cannot name your index, you can use the name <code class="docutils literal notranslate"><span class="pre">index</span></code> in your query expression:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [235]: df = pd.DataFrame(np.random.randint(n, size=(n, 2)), columns=list('bc'))

In [236]: df
Out[236]: 
   b  c
0  3  1
1  3  0
2  5  6
3  5  2
4  7  4
5  0  1
6  2  5
7  0  1
8  6  0
9  7  9

In [237]: df.query('index &lt; b &lt; c')
Out[237]: 
   b  c
2  5  6
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If the name of your index overlaps with a column name, the column name is given precedence. For example,</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [238]: df = pd.DataFrame({'a': np.random.randint(5, size=5)})

In [239]: df.index.name = 'a'

In [240]: df.query('a &gt; 2')  # uses the column 'a', not the index
Out[240]: 
   a
a   
1  3
3  3
</pre></div> </div> <p>You can still use the index in a query expression by using the special identifier ‘index’:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [241]: df.query('index &gt; 2')
Out[241]: 
   a
a   
3  3
4  2
</pre></div> </div> <p>If for some reason you have a column named <code class="docutils literal notranslate"><span class="pre">index</span></code>, then you can refer to the index as <code class="docutils literal notranslate"><span class="pre">ilevel_0</span></code> as well, but at this point you should consider renaming your columns to something less ambiguous.</p> </div> <section id="multiindex-query-syntax"> <h3>
<a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> <a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Syntax</h3> <p>You can also use the levels of a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with a <a class="reference internal" href="../reference/api/pandas.multiindex.html#pandas.MultiIndex" title="pandas.MultiIndex"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiIndex</span></code></a> as if they were columns in the frame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [242]: n = 10

In [243]: colors = np.random.choice(['red', 'green'], size=n)

In [244]: foods = np.random.choice(['eggs', 'ham'], size=n)

In [245]: colors
Out[245]: 
array(['red', 'red', 'red', 'green', 'green', 'green', 'green', 'green',
       'green', 'green'], dtype='&lt;U5')

In [246]: foods
Out[246]: 
array(['ham', 'ham', 'eggs', 'eggs', 'eggs', 'ham', 'ham', 'eggs', 'eggs',
       'eggs'], dtype='&lt;U4')

In [247]: index = pd.MultiIndex.from_arrays([colors, foods], names=['color', 'food'])

In [248]: df = pd.DataFrame(np.random.randn(n, 2), index=index)

In [249]: df
Out[249]: 
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

In [250]: df.query('color == "red"')
Out[250]: 
                   0         1
color food                    
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
</pre></div> </div> <p>If the levels of the <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code> are unnamed, you can refer to them using special names:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [251]: df.index.names = [None, None]

In [252]: df
Out[252]: 
                   0         1
red   ham   0.194889 -0.381994
      ham   0.318587  2.089075
      eggs -0.728293 -0.090255
green eggs -0.748199  1.318931
      eggs -2.029766  0.792652
      ham   0.461007 -0.542749
      ham  -0.305384 -0.479195
      eggs  0.095031 -0.270099
      eggs -0.707140 -0.773882
      eggs  0.229453  0.304418

In [253]: df.query('ilevel_0 == "red"')
Out[253]: 
                 0         1
red ham   0.194889 -0.381994
    ham   0.318587  2.089075
    eggs -0.728293 -0.090255
</pre></div> </div> <p>The convention is <code class="docutils literal notranslate"><span class="pre">ilevel_0</span></code>, which means “index level 0” for the 0th level of the <code class="docutils literal notranslate"><span class="pre">index</span></code>.</p> </section> <section id="query-use-cases"> <h3>
<a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Use Cases</h3> <p>A use case for <a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> is when you have a collection of <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> objects that have a subset of column names (or index levels/names) in common. You can pass the same query to both frames <em>without</em> having to specify which frame you’re interested in querying</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [254]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [255]: df
Out[255]: 
          a         b         c
0  0.224283  0.736107  0.139168
1  0.302827  0.657803  0.713897
2  0.611185  0.136624  0.984960
3  0.195246  0.123436  0.627712
4  0.618673  0.371660  0.047902
5  0.480088  0.062993  0.185760
6  0.568018  0.483467  0.445289
7  0.309040  0.274580  0.587101
8  0.258993  0.477769  0.370255
9  0.550459  0.840870  0.304611

In [256]: df2 = pd.DataFrame(np.random.rand(n + 2, 3), columns=df.columns)

In [257]: df2
Out[257]: 
           a         b         c
0   0.357579  0.229800  0.596001
1   0.309059  0.957923  0.965663
2   0.123102  0.336914  0.318616
3   0.526506  0.323321  0.860813
4   0.518736  0.486514  0.384724
5   0.190804  0.505723  0.614533
6   0.891939  0.623977  0.676639
7   0.480559  0.378528  0.460858
8   0.420223  0.136404  0.141295
9   0.732206  0.419540  0.604675
10  0.604466  0.848974  0.896165
11  0.589168  0.920046  0.732716

In [258]: expr = '0.0 &lt;= a &lt;= c &lt;= 0.5'

In [259]: map(lambda frame: frame.query(expr), [df, df2])
Out[259]: &lt;map at 0x7ff2e57db2e0&gt;
</pre></div> </div> </section> <section id="query-python-versus-pandas-syntax-comparison"> <h3>
<a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> Python versus pandas Syntax Comparison</h3> <p>Full numpy-like syntax:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [260]: df = pd.DataFrame(np.random.randint(n, size=(n, 3)), columns=list('abc'))

In [261]: df
Out[261]: 
   a  b  c
0  7  8  9
1  1  0  7
2  2  7  2
3  6  2  2
4  2  6  3
5  3  8  2
6  1  7  2
7  5  1  5
8  9  8  0
9  1  5  0

In [262]: df.query('(a &lt; b) &amp; (b &lt; c)')
Out[262]: 
   a  b  c
0  7  8  9

In [263]: df[(df['a'] &lt; df['b']) &amp; (df['b'] &lt; df['c'])]
Out[263]: 
   a  b  c
0  7  8  9
</pre></div> </div> <p>Slightly nicer by removing the parentheses (comparison operators bind tighter than <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">|</span></code>):</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [264]: df.query('a &lt; b &amp; b &lt; c')
Out[264]: 
   a  b  c
0  7  8  9
</pre></div> </div> <p>Use English instead of symbols:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [265]: df.query('a &lt; b and b &lt; c')
Out[265]: 
   a  b  c
0  7  8  9
</pre></div> </div> <p>Pretty close to how you might write it on paper:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [266]: df.query('a &lt; b &lt; c')
Out[266]: 
   a  b  c
0  7  8  9
</pre></div> </div> </section> <section id="the-in-and-not-in-operators"> <h3>The <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> operators</h3> <p><a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> also supports special use of Python’s <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> comparison operators, providing a succinct syntax for calling the <code class="docutils literal notranslate"><span class="pre">isin</span></code> method of a <code class="docutils literal notranslate"><span class="pre">Series</span></code> or <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># get all rows where columns "a" and "b" have overlapping values
In [267]: df = pd.DataFrame({'a': list('aabbccddeeff'), 'b': list('aaaabbbbcccc'),
   .....:                    'c': np.random.randint(5, size=12),
   .....:                    'd': np.random.randint(9, size=12)})
   .....: 

In [268]: df
Out[268]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

In [269]: df.query('a in b')
Out[269]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

# How you'd do it in pure Python
In [270]: df[df['a'].isin(df['b'])]
Out[270]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
3  b  a  2  1
4  c  b  3  6
5  c  b  0  2

In [271]: df.query('a not in b')
Out[271]: 
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

# pure Python
In [272]: df[~df['a'].isin(df['b'])]
Out[272]: 
    a  b  c  d
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2
</pre></div> </div> <p>You can combine this with other expressions for very succinct queries:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># rows where cols a and b have overlapping values
# and col c's values are less than col d's
In [273]: df.query('a in b and c &lt; d')
Out[273]: 
   a  b  c  d
0  a  a  2  6
1  a  a  4  7
2  b  a  1  6
4  c  b  3  6
5  c  b  0  2

# pure Python
In [274]: df[df['b'].isin(df['a']) &amp; (df['c'] &lt; df['d'])]
Out[274]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
4   c  b  3  6
5   c  b  0  2
10  f  c  0  6
11  f  c  1  2
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Note that <code class="docutils literal notranslate"><span class="pre">in</span></code> and <code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> are evaluated in Python, since <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> has no equivalent of this operation. However, <strong>only the</strong> <code class="docutils literal notranslate"><span class="pre">in</span></code>/<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code> <strong>expression itself</strong> is evaluated in vanilla Python. For example, in the expression</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">df.query('a in b + c + d')
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">(b</span> <span class="pre">+</span> <span class="pre">c</span> <span class="pre">+</span> <span class="pre">d)</span></code> is evaluated by <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> and <em>then</em> the <code class="docutils literal notranslate"><span class="pre">in</span></code> operation is evaluated in plain Python. In general, any operations that can be evaluated using <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> will be.</p> </div> </section> <section id="special-use-of-the-operator-with-list-objects"> <h3>Special use of the <code class="docutils literal notranslate"><span class="pre">==</span></code> operator with <code class="docutils literal notranslate"><span class="pre">list</span></code> objects</h3> <p>Comparing a <code class="docutils literal notranslate"><span class="pre">list</span></code> of values to a column using <code class="docutils literal notranslate"><span class="pre">==</span></code>/<code class="docutils literal notranslate"><span class="pre">!=</span></code> works similarly to <code class="docutils literal notranslate"><span class="pre">in</span></code>/<code class="docutils literal notranslate"><span class="pre">not</span> <span class="pre">in</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [275]: df.query('b == ["a", "b", "c"]')
Out[275]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

# pure Python
In [276]: df[df['b'].isin(["a", "b", "c"])]
Out[276]: 
    a  b  c  d
0   a  a  2  6
1   a  a  4  7
2   b  a  1  6
3   b  a  2  1
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
7   d  b  2  1
8   e  c  4  3
9   e  c  2  0
10  f  c  0  6
11  f  c  1  2

In [277]: df.query('c == [1, 2]')
Out[277]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

In [278]: df.query('c != [1, 2]')
Out[278]: 
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

# using in/not in
In [279]: df.query('[1, 2] in c')
Out[279]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2

In [280]: df.query('[1, 2] not in c')
Out[280]: 
    a  b  c  d
1   a  a  4  7
4   c  b  3  6
5   c  b  0  2
6   d  b  3  3
8   e  c  4  3
10  f  c  0  6

# pure Python
In [281]: df[df['c'].isin([1, 2])]
Out[281]: 
    a  b  c  d
0   a  a  2  6
2   b  a  1  6
3   b  a  2  1
7   d  b  2  1
9   e  c  2  0
11  f  c  1  2
</pre></div> </div> </section> <section id="boolean-operators"> <h3>Boolean operators</h3> <p>You can negate boolean expressions with the word <code class="docutils literal notranslate"><span class="pre">not</span></code> or the <code class="docutils literal notranslate"><span class="pre">~</span></code> operator.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [282]: df = pd.DataFrame(np.random.rand(n, 3), columns=list('abc'))

In [283]: df['bools'] = np.random.rand(len(df)) &gt; 0.5

In [284]: df.query('~bools')
Out[284]: 
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

In [285]: df.query('not bools')
Out[285]: 
          a         b         c  bools
2  0.697753  0.212799  0.329209  False
7  0.275396  0.691034  0.826619  False
8  0.190649  0.558748  0.262467  False

In [286]: df.query('not bools') == df[~df['bools']]
Out[286]: 
      a     b     c  bools
2  True  True  True   True
7  True  True  True   True
8  True  True  True   True
</pre></div> </div> <p>Of course, expressions can be arbitrarily complex too:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># short query syntax
In [287]: shorter = df.query('a &lt; b &lt; c and (not bools) or bools &gt; 2')

# equivalent in pure Python
In [288]: longer = df[(df['a'] &lt; df['b'])
   .....:             &amp; (df['b'] &lt; df['c'])
   .....:             &amp; (~df['bools'])
   .....:             | (df['bools'] &gt; 2)]
   .....: 

In [289]: shorter
Out[289]: 
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

In [290]: longer
Out[290]: 
          a         b         c  bools
7  0.275396  0.691034  0.826619  False

In [291]: shorter == longer
Out[291]: 
      a     b     c  bools
7  True  True  True   True
</pre></div> </div> </section> <section id="performance-of-query"> <h3>Performance of <a class="reference internal" href="../reference/api/pandas.dataframe.query.html#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a>
</h3> <p><code class="docutils literal notranslate"><span class="pre">DataFrame.query()</span></code> using <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> is slightly faster than Python for large frames.</p> <img alt="../_images/query-perf.png" src="data:image/png;base64,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"> <p>You will only see the performance benefits of using the <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> engine with <code class="docutils literal notranslate"><span class="pre">DataFrame.query()</span></code> if your frame has more than approximately 100,000 rows.</p> <p>This plot was created using a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> with 3 columns each containing floating point values generated using <code class="docutils literal notranslate"><span class="pre">numpy.random.randn()</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [292]: df = pd.DataFrame(np.random.randn(8, 4),
   .....:                   index=dates, columns=['A', 'B', 'C', 'D'])
   .....: 

In [293]: df2 = df.copy()
</pre></div> </div> </section> </section> <section id="duplicate-data"> <h2>Duplicate data</h2> <p id="indexing-duplicate">If you want to identify and remove duplicate rows in a DataFrame, there are two methods that will help: <code class="docutils literal notranslate"><span class="pre">duplicated</span></code> and <code class="docutils literal notranslate"><span class="pre">drop_duplicates</span></code>. Each takes as an argument the columns to use to identify duplicated rows.</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">duplicated</span></code> returns a boolean vector whose length is the number of rows, and which indicates whether a row is duplicated.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">drop_duplicates</span></code> removes duplicate rows.</p></li> </ul> <p>By default, the first observed row of a duplicate set is considered unique, but each method has a <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter to specify targets to be kept.</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">keep='first'</span></code> (default): mark / drop duplicates except for the first occurrence.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">keep='last'</span></code>: mark / drop duplicates except for the last occurrence.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">keep=False</span></code>: mark / drop all duplicates.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [294]: df2 = pd.DataFrame({'a': ['one', 'one', 'two', 'two', 'two', 'three', 'four'],
   .....:                     'b': ['x', 'y', 'x', 'y', 'x', 'x', 'x'],
   .....:                     'c': np.random.randn(7)})
   .....: 

In [295]: df2
Out[295]: 
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

In [296]: df2.duplicated('a')
Out[296]: 
0    False
1     True
2    False
3     True
4     True
5    False
6    False
dtype: bool

In [297]: df2.duplicated('a', keep='last')
Out[297]: 
0     True
1    False
2     True
3     True
4    False
5    False
6    False
dtype: bool

In [298]: df2.duplicated('a', keep=False)
Out[298]: 
0     True
1     True
2     True
3     True
4     True
5    False
6    False
dtype: bool

In [299]: df2.drop_duplicates('a')
Out[299]: 
       a  b         c
0    one  x -1.067137
2    two  x -0.211056
5  three  x -1.964475
6   four  x  1.298329

In [300]: df2.drop_duplicates('a', keep='last')
Out[300]: 
       a  b         c
1    one  y  0.309500
4    two  x -0.390820
5  three  x -1.964475
6   four  x  1.298329

In [301]: df2.drop_duplicates('a', keep=False)
Out[301]: 
       a  b         c
5  three  x -1.964475
6   four  x  1.298329
</pre></div> </div> <p>Also, you can pass a list of columns to identify duplications.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [302]: df2.duplicated(['a', 'b'])
Out[302]: 
0    False
1    False
2    False
3    False
4     True
5    False
6    False
dtype: bool

In [303]: df2.drop_duplicates(['a', 'b'])
Out[303]: 
       a  b         c
0    one  x -1.067137
1    one  y  0.309500
2    two  x -0.211056
3    two  y -1.842023
5  three  x -1.964475
6   four  x  1.298329
</pre></div> </div> <p>To drop duplicates by index value, use <code class="docutils literal notranslate"><span class="pre">Index.duplicated</span></code> then perform slicing. The same set of options are available for the <code class="docutils literal notranslate"><span class="pre">keep</span></code> parameter.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [304]: df3 = pd.DataFrame({'a': np.arange(6),
   .....:                     'b': np.random.randn(6)},
   .....:                    index=['a', 'a', 'b', 'c', 'b', 'a'])
   .....: 

In [305]: df3
Out[305]: 
   a         b
a  0  1.440455
a  1  2.456086
b  2  1.038402
c  3 -0.894409
b  4  0.683536
a  5  3.082764

In [306]: df3.index.duplicated()
Out[306]: array([False,  True, False, False,  True,  True])

In [307]: df3[~df3.index.duplicated()]
Out[307]: 
   a         b
a  0  1.440455
b  2  1.038402
c  3 -0.894409

In [308]: df3[~df3.index.duplicated(keep='last')]
Out[308]: 
   a         b
c  3 -0.894409
b  4  0.683536
a  5  3.082764

In [309]: df3[~df3.index.duplicated(keep=False)]
Out[309]: 
   a         b
c  3 -0.894409
</pre></div> </div> </section> <section id="dictionary-like-get-method"> <h2>Dictionary-like <a class="reference internal" href="../reference/api/pandas.dataframe.get.html#pandas.DataFrame.get" title="pandas.DataFrame.get"><code class="xref py py-meth docutils literal notranslate"><span class="pre">get()</span></code></a> method</h2> <p>Each of Series or DataFrame have a <code class="docutils literal notranslate"><span class="pre">get</span></code> method which can return a default value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [310]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [311]: s.get('a')  # equivalent to s['a']
Out[311]: 1

In [312]: s.get('x', default=-1)
Out[312]: -1
</pre></div> </div> </section> <section id="looking-up-values-by-index-column-labels"> <h2>Looking up values by index/column labels</h2> <p>Sometimes you want to extract a set of values given a sequence of row labels and column labels, this can be achieved by <code class="docutils literal notranslate"><span class="pre">pandas.factorize</span></code> and NumPy indexing. For instance:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [313]: df = pd.DataFrame({'col': ["A", "A", "B", "B"],
   .....:                    'A': [80, 23, np.nan, 22],
   .....:                    'B': [80, 55, 76, 67]})
   .....: 

In [314]: df
Out[314]: 
  col     A   B
0   A  80.0  80
1   A  23.0  55
2   B   NaN  76
3   B  22.0  67

In [315]: idx, cols = pd.factorize(df['col'])

In [316]: df.reindex(cols, axis=1).to_numpy()[np.arange(len(df)), idx]
Out[316]: array([80., 23., 76., 67.])
</pre></div> </div> <p>Formerly this could be achieved with the dedicated <code class="docutils literal notranslate"><span class="pre">DataFrame.lookup</span></code> method which was deprecated in version 1.2.0 and removed in version 2.0.0.</p> </section> <section id="index-objects"> <h2>Index objects</h2> <p>The pandas <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> class and its subclasses can be viewed as implementing an <em>ordered multiset</em>. Duplicates are allowed.</p> <p><a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> also provides the infrastructure necessary for lookups, data alignment, and reindexing. The easiest way to create an <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a> directly is to pass a <code class="docutils literal notranslate"><span class="pre">list</span></code> or other sequence to <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [317]: index = pd.Index(['e', 'd', 'a', 'b'])

In [318]: index
Out[318]: Index(['e', 'd', 'a', 'b'], dtype='object')

In [319]: 'd' in index
Out[319]: True
</pre></div> </div> <p>or using numbers:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [320]: index = pd.Index([1, 5, 12])

In [321]: index
Out[321]: Index([1, 5, 12], dtype='int64')

In [322]: 5 in index
Out[322]: True
</pre></div> </div> <p>If no dtype is given, <code class="docutils literal notranslate"><span class="pre">Index</span></code> tries to infer the dtype from the data. It is also possible to give an explicit dtype when instantiating an <a class="reference internal" href="../reference/api/pandas.index.html#pandas.Index" title="pandas.Index"><code class="xref py py-class docutils literal notranslate"><span class="pre">Index</span></code></a>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [323]: index = pd.Index(['e', 'd', 'a', 'b'], dtype="string")

In [324]: index
Out[324]: Index(['e', 'd', 'a', 'b'], dtype='string')

In [325]: index = pd.Index([1, 5, 12], dtype="int8")

In [326]: index
Out[326]: Index([1, 5, 12], dtype='int8')

In [327]: index = pd.Index([1, 5, 12], dtype="float32")

In [328]: index
Out[328]: Index([1.0, 5.0, 12.0], dtype='float32')
</pre></div> </div> <p>You can also pass a <code class="docutils literal notranslate"><span class="pre">name</span></code> to be stored in the index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [329]: index = pd.Index(['e', 'd', 'a', 'b'], name='something')

In [330]: index.name
Out[330]: 'something'
</pre></div> </div> <p>The name, if set, will be shown in the console display:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [331]: index = pd.Index(list(range(5)), name='rows')

In [332]: columns = pd.Index(['A', 'B', 'C'], name='cols')

In [333]: df = pd.DataFrame(np.random.randn(5, 3), index=index, columns=columns)

In [334]: df
Out[334]: 
cols         A         B         C
rows                              
0     1.295989 -1.051694  1.340429
1    -2.366110  0.428241  0.387275
2     0.433306  0.929548  0.278094
3     2.154730 -0.315628  0.264223
4     1.126818  1.132290 -0.353310

In [335]: df['A']
Out[335]: 
rows
0    1.295989
1   -2.366110
2    0.433306
3    2.154730
4    1.126818
Name: A, dtype: float64
</pre></div> </div> <section id="setting-metadata"> <h3>Setting metadata</h3> <p>Indexes are “mostly immutable”, but it is possible to set and change their <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute. You can use the <code class="docutils literal notranslate"><span class="pre">rename</span></code>, <code class="docutils literal notranslate"><span class="pre">set_names</span></code> to set these attributes directly, and they default to returning a copy.</p> <p>See <a class="reference internal" href="advanced.html#advanced"><span class="std std-ref">Advanced Indexing</span></a> for usage of MultiIndexes.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [336]: ind = pd.Index([1, 2, 3])

In [337]: ind.rename("apple")
Out[337]: Index([1, 2, 3], dtype='int64', name='apple')

In [338]: ind
Out[338]: Index([1, 2, 3], dtype='int64')

In [339]: ind = ind.set_names(["apple"])

In [340]: ind.name = "bob"

In [341]: ind
Out[341]: Index([1, 2, 3], dtype='int64', name='bob')
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">set_names</span></code>, <code class="docutils literal notranslate"><span class="pre">set_levels</span></code>, and <code class="docutils literal notranslate"><span class="pre">set_codes</span></code> also take an optional <code class="docutils literal notranslate"><span class="pre">level</span></code> argument</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [342]: index = pd.MultiIndex.from_product([range(3), ['one', 'two']], names=['first', 'second'])

In [343]: index
Out[343]: 
MultiIndex([(0, 'one'),
            (0, 'two'),
            (1, 'one'),
            (1, 'two'),
            (2, 'one'),
            (2, 'two')],
           names=['first', 'second'])

In [344]: index.levels[1]
Out[344]: Index(['one', 'two'], dtype='object', name='second')

In [345]: index.set_levels(["a", "b"], level=1)
Out[345]: 
MultiIndex([(0, 'a'),
            (0, 'b'),
            (1, 'a'),
            (1, 'b'),
            (2, 'a'),
            (2, 'b')],
           names=['first', 'second'])
</pre></div> </div> </section> <section id="set-operations-on-index-objects"> <h3>Set operations on Index objects</h3> <p>The two main operations are <code class="docutils literal notranslate"><span class="pre">union</span></code> and <code class="docutils literal notranslate"><span class="pre">intersection</span></code>. Difference is provided via the <code class="docutils literal notranslate"><span class="pre">.difference()</span></code> method.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [346]: a = pd.Index(['c', 'b', 'a'])

In [347]: b = pd.Index(['c', 'e', 'd'])

In [348]: a.difference(b)
Out[348]: Index(['a', 'b'], dtype='object')
</pre></div> </div> <p>Also available is the <code class="docutils literal notranslate"><span class="pre">symmetric_difference</span></code> operation, which returns elements that appear in either <code class="docutils literal notranslate"><span class="pre">idx1</span></code> or <code class="docutils literal notranslate"><span class="pre">idx2</span></code>, but not in both. This is equivalent to the Index created by <code class="docutils literal notranslate"><span class="pre">idx1.difference(idx2).union(idx2.difference(idx1))</span></code>, with duplicates dropped.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [349]: idx1 = pd.Index([1, 2, 3, 4])

In [350]: idx2 = pd.Index([2, 3, 4, 5])

In [351]: idx1.symmetric_difference(idx2)
Out[351]: Index([1, 5], dtype='int64')
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The resulting index from a set operation will be sorted in ascending order.</p> </div> <p>When performing <a class="reference internal" href="../reference/api/pandas.index.union.html#pandas.Index.union" title="pandas.Index.union"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Index.union()</span></code></a> between indexes with different dtypes, the indexes must be cast to a common dtype. Typically, though not always, this is object dtype. The exception is when performing a union between integer and float data. In this case, the integer values are converted to float</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [352]: idx1 = pd.Index([0, 1, 2])

In [353]: idx2 = pd.Index([0.5, 1.5])

In [354]: idx1.union(idx2)
Out[354]: Index([0.0, 0.5, 1.0, 1.5, 2.0], dtype='float64')
</pre></div> </div> </section> <section id="missing-values"> <h3>Missing values</h3> <div class="admonition important"> <p class="admonition-title">Important</p> <p>Even though <code class="docutils literal notranslate"><span class="pre">Index</span></code> can hold missing values (<code class="docutils literal notranslate"><span class="pre">NaN</span></code>), it should be avoided if you do not want any unexpected results. For example, some operations exclude missing values implicitly.</p> </div> <p><code class="docutils literal notranslate"><span class="pre">Index.fillna</span></code> fills missing values with specified scalar value.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [355]: idx1 = pd.Index([1, np.nan, 3, 4])

In [356]: idx1
Out[356]: Index([1.0, nan, 3.0, 4.0], dtype='float64')

In [357]: idx1.fillna(2)
Out[357]: Index([1.0, 2.0, 3.0, 4.0], dtype='float64')

In [358]: idx2 = pd.DatetimeIndex([pd.Timestamp('2011-01-01'),
   .....:                          pd.NaT,
   .....:                          pd.Timestamp('2011-01-03')])
   .....: 

In [359]: idx2
Out[359]: DatetimeIndex(['2011-01-01', 'NaT', '2011-01-03'], dtype='datetime64[ns]', freq=None)

In [360]: idx2.fillna(pd.Timestamp('2011-01-02'))
Out[360]: DatetimeIndex(['2011-01-01', '2011-01-02', '2011-01-03'], dtype='datetime64[ns]', freq=None)
</pre></div> </div> </section> </section> <section id="set-reset-index"> <h2>Set / reset index</h2> <p>Occasionally you will load or create a data set into a DataFrame and want to add an index after you’ve already done so. There are a couple of different ways.</p> <section id="set-an-index"> <h3>Set an index</h3> <p>DataFrame has a <a class="reference internal" href="../reference/api/pandas.dataframe.set_index.html#pandas.DataFrame.set_index" title="pandas.DataFrame.set_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_index()</span></code></a> method which takes a column name (for a regular <code class="docutils literal notranslate"><span class="pre">Index</span></code>) or a list of column names (for a <code class="docutils literal notranslate"><span class="pre">MultiIndex</span></code>). To create a new, re-indexed DataFrame:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [361]: data = pd.DataFrame({'a': ['bar', 'bar', 'foo', 'foo'],
   .....:                      'b': ['one', 'two', 'one', 'two'],
   .....:                      'c': ['z', 'y', 'x', 'w'],
   .....:                      'd': [1., 2., 3, 4]})
   .....: 

In [362]: data
Out[362]: 
     a    b  c    d
0  bar  one  z  1.0
1  bar  two  y  2.0
2  foo  one  x  3.0
3  foo  two  w  4.0

In [363]: indexed1 = data.set_index('c')

In [364]: indexed1
Out[364]: 
     a    b    d
c               
z  bar  one  1.0
y  bar  two  2.0
x  foo  one  3.0
w  foo  two  4.0

In [365]: indexed2 = data.set_index(['a', 'b'])

In [366]: indexed2
Out[366]: 
         c    d
a   b          
bar one  z  1.0
    two  y  2.0
foo one  x  3.0
    two  w  4.0
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">append</span></code> keyword option allow you to keep the existing index and append the given columns to a MultiIndex:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [367]: frame = data.set_index('c', drop=False)

In [368]: frame = frame.set_index(['a', 'b'], append=True)

In [369]: frame
Out[369]: 
           c    d
c a   b          
z bar one  z  1.0
y bar two  y  2.0
x foo one  x  3.0
w foo two  w  4.0
</pre></div> </div> <p>Other options in <code class="docutils literal notranslate"><span class="pre">set_index</span></code> allow you not drop the index columns.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [370]: data.set_index('c', drop=False)
Out[370]: 
     a    b  c    d
c                  
z  bar  one  z  1.0
y  bar  two  y  2.0
x  foo  one  x  3.0
w  foo  two  w  4.0
</pre></div> </div> </section> <section id="reset-the-index"> <h3>Reset the index</h3> <p>As a convenience, there is a new function on DataFrame called <a class="reference internal" href="../reference/api/pandas.dataframe.reset_index.html#pandas.DataFrame.reset_index" title="pandas.DataFrame.reset_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reset_index()</span></code></a> which transfers the index values into the DataFrame’s columns and sets a simple integer index. This is the inverse operation of <a class="reference internal" href="../reference/api/pandas.dataframe.set_index.html#pandas.DataFrame.set_index" title="pandas.DataFrame.set_index"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_index()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [371]: data
Out[371]: 
     a    b  c    d
0  bar  one  z  1.0
1  bar  two  y  2.0
2  foo  one  x  3.0
3  foo  two  w  4.0

In [372]: data.reset_index()
Out[372]: 
   index    a    b  c    d
0      0  bar  one  z  1.0
1      1  bar  two  y  2.0
2      2  foo  one  x  3.0
3      3  foo  two  w  4.0
</pre></div> </div> <p>The output is more similar to a SQL table or a record array. The names for the columns derived from the index are the ones stored in the <code class="docutils literal notranslate"><span class="pre">names</span></code> attribute.</p> <p>You can use the <code class="docutils literal notranslate"><span class="pre">level</span></code> keyword to remove only a portion of the index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [373]: frame
Out[373]: 
           c    d
c a   b          
z bar one  z  1.0
y bar two  y  2.0
x foo one  x  3.0
w foo two  w  4.0

In [374]: frame.reset_index(level=1)
Out[374]: 
         a  c    d
c b               
z one  bar  z  1.0
y two  bar  y  2.0
x one  foo  x  3.0
w two  foo  w  4.0
</pre></div> </div> <p><code class="docutils literal notranslate"><span class="pre">reset_index</span></code> takes an optional parameter <code class="docutils literal notranslate"><span class="pre">drop</span></code> which if true simply discards the index, instead of putting index values in the DataFrame’s columns.</p> </section> <section id="adding-an-ad-hoc-index"> <h3>Adding an ad hoc index</h3> <p>You can assign a custom index to the <code class="docutils literal notranslate"><span class="pre">index</span></code> attribute:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [375]: df_idx = pd.DataFrame(range(4))

In [376]: df_idx.index = pd.Index([10, 20, 30, 40], name="a")

In [377]: df_idx
Out[377]: 
    0
a    
10  0
20  1
30  2
40  3
</pre></div> </div> </section> </section> <section id="returning-a-view-versus-a-copy"> <h2>Returning a view versus a copy</h2> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="copy_on_write.html#copy-on-write"><span class="std std-ref">Copy-on-Write</span></a> will become the new default in pandas 3.0. This means than chained indexing will never work. As a consequence, the <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> won’t be necessary anymore. See <a class="reference internal" href="copy_on_write.html#copy-on-write-chained-assignment"><span class="std std-ref">this section</span></a> for more context. We recommend turning Copy-on-Write on to leverage the improvements with</p> <p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">pd.options.mode.copy_on_write</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">`</span></code></p> <p>even before pandas 3.0 is available.</p> </div> <p>When setting values in a pandas object, care must be taken to avoid what is called <code class="docutils literal notranslate"><span class="pre">chained</span> <span class="pre">indexing</span></code>. Here is an example.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [378]: dfmi = pd.DataFrame([list('abcd'),
   .....:                      list('efgh'),
   .....:                      list('ijkl'),
   .....:                      list('mnop')],
   .....:                     columns=pd.MultiIndex.from_product([['one', 'two'],
   .....:                                                         ['first', 'second']]))
   .....: 

In [379]: dfmi
Out[379]: 
    one          two       
  first second first second
0     a      b     c      d
1     e      f     g      h
2     i      j     k      l
3     m      n     o      p
</pre></div> </div> <p>Compare these two access methods:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [380]: dfmi['one']['second']
Out[380]: 
0    b
1    f
2    j
3    n
Name: second, dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [381]: dfmi.loc[:, ('one', 'second')]
Out[381]: 
0    b
1    f
2    j
3    n
Name: (one, second), dtype: object
</pre></div> </div> <p>These both yield the same results, so which should you use? It is instructive to understand the order of operations on these and why method 2 (<code class="docutils literal notranslate"><span class="pre">.loc</span></code>) is much preferred over method 1 (chained <code class="docutils literal notranslate"><span class="pre">[]</span></code>).</p> <p><code class="docutils literal notranslate"><span class="pre">dfmi['one']</span></code> selects the first level of the columns and returns a DataFrame that is singly-indexed. Then another Python operation <code class="docutils literal notranslate"><span class="pre">dfmi_with_one['second']</span></code> selects the series indexed by <code class="docutils literal notranslate"><span class="pre">'second'</span></code>. This is indicated by the variable <code class="docutils literal notranslate"><span class="pre">dfmi_with_one</span></code> because pandas sees these operations as separate events. e.g. separate calls to <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>, so it has to treat them as linear operations, they happen one after another.</p> <p>Contrast this to <code class="docutils literal notranslate"><span class="pre">df.loc[:,('one','second')]</span></code> which passes a nested tuple of <code class="docutils literal notranslate"><span class="pre">(slice(None),('one','second'))</span></code> to a single call to <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code>. This allows pandas to deal with this as a single entity. Furthermore this order of operations <em>can</em> be significantly faster, and allows one to index <em>both</em> axes if so desired.</p> <section id="why-does-assignment-fail-when-using-chained-indexing"> <h3>Why does assignment fail when using chained indexing?</h3> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="copy_on_write.html#copy-on-write"><span class="std std-ref">Copy-on-Write</span></a> will become the new default in pandas 3.0. This means than chained indexing will never work. As a consequence, the <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> won’t be necessary anymore. See <a class="reference internal" href="copy_on_write.html#copy-on-write-chained-assignment"><span class="std std-ref">this section</span></a> for more context. We recommend turning Copy-on-Write on to leverage the improvements with</p> <p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">pd.options.mode.copy_on_write</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">`</span></code></p> <p>even before pandas 3.0 is available.</p> </div> <p>The problem in the previous section is just a performance issue. What’s up with the <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> warning? We don’t <strong>usually</strong> throw warnings around when you do something that might cost a few extra milliseconds!</p> <p>But it turns out that assigning to the product of chained indexing has inherently unpredictable results. To see this, think about how the Python interpreter executes this code:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfmi.loc[:, ('one', 'second')] = value
# becomes
dfmi.loc.__setitem__((slice(None), ('one', 'second')), value)
</pre></div> </div> <p>But this code is handled differently:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">dfmi['one']['second'] = value
# becomes
dfmi.__getitem__('one').__setitem__('second', value)
</pre></div> </div> <p>See that <code class="docutils literal notranslate"><span class="pre">__getitem__</span></code> in there? Outside of simple cases, it’s very hard to predict whether it will return a view or a copy (it depends on the memory layout of the array, about which pandas makes no guarantees), and therefore whether the <code class="docutils literal notranslate"><span class="pre">__setitem__</span></code> will modify <code class="docutils literal notranslate"><span class="pre">dfmi</span></code> or a temporary object that gets thrown out immediately afterward. <strong>That’s</strong> what <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> is warning you about!</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You may be wondering whether we should be concerned about the <code class="docutils literal notranslate"><span class="pre">loc</span></code> property in the first example. But <code class="docutils literal notranslate"><span class="pre">dfmi.loc</span></code> is guaranteed to be <code class="docutils literal notranslate"><span class="pre">dfmi</span></code> itself with modified indexing behavior, so <code class="docutils literal notranslate"><span class="pre">dfmi.loc.__getitem__</span></code> / <code class="docutils literal notranslate"><span class="pre">dfmi.loc.__setitem__</span></code> operate on <code class="docutils literal notranslate"><span class="pre">dfmi</span></code> directly. Of course, <code class="docutils literal notranslate"><span class="pre">dfmi.loc.__getitem__(idx)</span></code> may be a view or a copy of <code class="docutils literal notranslate"><span class="pre">dfmi</span></code>.</p> </div> <p>Sometimes a <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> warning will arise at times when there’s no obvious chained indexing going on. <strong>These</strong> are the bugs that <code class="docutils literal notranslate"><span class="pre">SettingWithCopy</span></code> is designed to catch! pandas is probably trying to warn you that you’ve done this:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">def do_something(df):
    foo = df[['bar', 'baz']]  # Is foo a view? A copy? Nobody knows!
    # ... many lines here ...
    # We don't know whether this will modify df or not!
    foo['quux'] = value
    return foo
</pre></div> </div> <p>Yikes!</p> </section> <section id="evaluation-order-matters"> <h3>Evaluation order matters</h3> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p><a class="reference internal" href="copy_on_write.html#copy-on-write"><span class="std std-ref">Copy-on-Write</span></a> will become the new default in pandas 3.0. This means than chained indexing will never work. As a consequence, the <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> won’t be necessary anymore. See <a class="reference internal" href="copy_on_write.html#copy-on-write-chained-assignment"><span class="std std-ref">this section</span></a> for more context. We recommend turning Copy-on-Write on to leverage the improvements with</p> <p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">pd.options.mode.copy_on_write</span> <span class="pre">=</span> <span class="pre">True</span>
<span class="pre">`</span></code></p> <p>even before pandas 3.0 is available.</p> </div> <p>When you use chained indexing, the order and type of the indexing operation partially determine whether the result is a slice into the original object, or a copy of the slice.</p> <p>pandas has the <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> because assigning to a copy of a slice is frequently not intentional, but a mistake caused by chained indexing returning a copy where a slice was expected.</p> <p>If you would like pandas to be more or less trusting about assignment to a chained indexing expression, you can set the <a class="reference internal" href="options.html#options"><span class="std std-ref">option</span></a> <code class="docutils literal notranslate"><span class="pre">mode.chained_assignment</span></code> to one of these values:</p> <ul class="simple"> <li><p><code class="docutils literal notranslate"><span class="pre">'warn'</span></code>, the default, means a <code class="docutils literal notranslate"><span class="pre">SettingWithCopyWarning</span></code> is printed.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">'raise'</span></code> means pandas will raise a <code class="docutils literal notranslate"><span class="pre">SettingWithCopyError</span></code> you have to deal with.</p></li> <li><p><code class="docutils literal notranslate"><span class="pre">None</span></code> will suppress the warnings entirely.</p></li> </ul> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [382]: dfb = pd.DataFrame({'a': ['one', 'one', 'two',
   .....:                           'three', 'two', 'one', 'six'],
   .....:                     'c': np.arange(7)})
   .....: 

# This will show the SettingWithCopyWarning
# but the frame values will be set
In [383]: dfb['c'][dfb['a'].str.startswith('o')] = 42
</pre></div> </div> <p>This however is operating on a copy and will not work.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [384]: with pd.option_context('mode.chained_assignment','warn'):
   .....:     dfb[dfb['a'].str.startswith('o')]['c'] = 42
   .....: 
</pre></div> </div> <p>A chained assignment can also crop up in setting in a mixed dtype frame.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These setting rules apply to all of <code class="docutils literal notranslate"><span class="pre">.loc/.iloc</span></code>.</p> </div> <p>The following is the recommended access method using <code class="docutils literal notranslate"><span class="pre">.loc</span></code> for multiple items (using <code class="docutils literal notranslate"><span class="pre">mask</span></code>) and a single item using a fixed index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [385]: dfc = pd.DataFrame({'a': ['one', 'one', 'two',
   .....:                           'three', 'two', 'one', 'six'],
   .....:                     'c': np.arange(7)})
   .....: 

In [386]: dfd = dfc.copy()

# Setting multiple items using a mask
In [387]: mask = dfd['a'].str.startswith('o')

In [388]: dfd.loc[mask, 'c'] = 42

In [389]: dfd
Out[389]: 
       a   c
0    one  42
1    one  42
2    two   2
3  three   3
4    two   4
5    one  42
6    six   6

# Setting a single item
In [390]: dfd = dfc.copy()

In [391]: dfd.loc[2, 'a'] = 11

In [392]: dfd
Out[392]: 
       a  c
0    one  0
1    one  1
2     11  2
3  three  3
4    two  4
5    one  5
6    six  6
</pre></div> </div> <p>The following <em>can</em> work at times, but it is not guaranteed to, and therefore should be avoided:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [393]: dfd = dfc.copy()

In [394]: dfd['a'][2] = 111

In [395]: dfd
Out[395]: 
       a  c
0    one  0
1    one  1
2    111  2
3  three  3
4    two  4
5    one  5
6    six  6
</pre></div> </div> <p>Last, the subsequent example will <strong>not</strong> work at all, and so should be avoided:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [396]: with pd.option_context('mode.chained_assignment','raise'):
   .....:     dfd.loc[0]['a'] = 1111
   .....: 
---------------------------------------------------------------------------
SettingWithCopyError                      Traceback (most recent call last)
&lt;ipython-input-396-32ce785aaa5b&gt; in ?()
      1 with pd.option_context('mode.chained_assignment','raise'):
----&gt; 2     dfd.loc[0]['a'] = 1111

~/work/pandas/pandas/pandas/core/series.py in ?(self, key, value)
   1284                 )
   1285 
   1286         check_dict_or_set_indexers(key)
   1287         key = com.apply_if_callable(key, self)
-&gt; 1288         cacher_needs_updating = self._check_is_chained_assignment_possible()
   1289 
   1290         if key is Ellipsis:
   1291             key = slice(None)

~/work/pandas/pandas/pandas/core/series.py in ?(self)
   1489             ref = self._get_cacher()
   1490             if ref is not None and ref._is_mixed_type:
   1491                 self._check_setitem_copy(t="referent", force=True)
   1492             return True
-&gt; 1493         return super()._check_is_chained_assignment_possible()

~/work/pandas/pandas/pandas/core/generic.py in ?(self)
   4395         single-dtype meaning that the cacher should be updated following
   4396         setting.
   4397         """
   4398         if self._is_copy:
-&gt; 4399             self._check_setitem_copy(t="referent")
   4400         return False

~/work/pandas/pandas/pandas/core/generic.py in ?(self, t, force)
   4469                 "indexing.html#returning-a-view-versus-a-copy"
   4470             )
   4471 
   4472         if value == "raise":
-&gt; 4473             raise SettingWithCopyError(t)
   4474         if value == "warn":
   4475             warnings.warn(t, SettingWithCopyWarning, stacklevel=find_stack_level())

SettingWithCopyError: 
A value is trying to be set on a copy of a slice from a DataFrame

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
</pre></div> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>The chained assignment warnings / exceptions are aiming to inform the user of a possibly invalid assignment. There may be false positives; situations where a chained assignment is inadvertently reported.</p> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/indexing.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/indexing.html</a>
  </p>
</div>
