<h1>Cookbook</h1> <p>This is a repository for <em>short and sweet</em> examples and links for useful pandas recipes. We encourage users to add to this documentation.</p> <p>Adding interesting links and/or inline examples to this section is a great <em>First Pull Request</em>.</p> <p>Simplified, condensed, new-user friendly, in-line examples have been inserted where possible to augment the Stack-Overflow and GitHub links. Many of the links contain expanded information, above what the in-line examples offer.</p> <p>pandas (pd) and NumPy (np) are the only two abbreviated imported modules. The rest are kept explicitly imported for newer users.</p> <section id="idioms"> <h2>Idioms</h2> <p id="cookbook-idioms">These are some neat pandas <code class="docutils literal notranslate"><span class="pre">idioms</span></code></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17128302/python-pandas-idiom-for-if-then-else">if-then/if-then-else on one column, and assignment to another one or more columns:</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: df = pd.DataFrame(
   ...:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ...: )
   ...: 

In [2]: df
Out[2]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50
</pre></div> </div> <section id="if-then"> <h3>if-then…</h3> <p>An if-then on one column</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [3]: df.loc[df.AAA &gt;= 5, "BBB"] = -1

In [4]: df
Out[4]: 
   AAA  BBB  CCC
0    4   10  100
1    5   -1   50
2    6   -1  -30
3    7   -1  -50
</pre></div> </div> <p>An if-then with assignment to 2 columns:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [5]: df.loc[df.AAA &gt;= 5, ["BBB", "CCC"]] = 555

In [6]: df
Out[6]: 
   AAA  BBB  CCC
0    4   10  100
1    5  555  555
2    6  555  555
3    7  555  555
</pre></div> </div> <p>Add another line with different logic, to do the -else</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [7]: df.loc[df.AAA &lt; 5, ["BBB", "CCC"]] = 2000

In [8]: df
Out[8]: 
   AAA   BBB   CCC
0    4  2000  2000
1    5   555   555
2    6   555   555
3    7   555   555
</pre></div> </div> <p>Or use pandas where after you’ve set up a mask</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [9]: df_mask = pd.DataFrame(
   ...:     {"AAA": [True] * 4, "BBB": [False] * 4, "CCC": [True, False] * 2}
   ...: )
   ...: 

In [10]: df.where(df_mask, -1000)
Out[10]: 
   AAA   BBB   CCC
0    4 -1000  2000
1    5 -1000 -1000
2    6 -1000   555
3    7 -1000 -1000
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/19913659/pandas-conditional-creation-of-a-series-dataframe-column">if-then-else using NumPy’s where()</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [11]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [12]: df
Out[12]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [13]: df["logic"] = np.where(df["AAA"] &gt; 5, "high", "low")

In [14]: df
Out[14]: 
   AAA  BBB  CCC logic
0    4   10  100   low
1    5   20   50   low
2    6   30  -30  high
3    7   40  -50  high
</pre></div> </div> </section> <section id="splitting"> <h3>Splitting</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/14957116/how-to-split-a-dataframe-according-to-a-boolean-criterion">Split a frame with a boolean criterion</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [15]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [16]: df
Out[16]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [17]: df[df.AAA &lt;= 5]
Out[17]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50

In [18]: df[df.AAA &gt; 5]
Out[18]: 
   AAA  BBB  CCC
2    6   30  -30
3    7   40  -50
</pre></div> </div> </section> <section id="building-criteria"> <h3>Building criteria</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/15315452/selecting-with-complex-criteria-from-pandas-dataframe">Select with multi-column criteria</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [19]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [20]: df
Out[20]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50
</pre></div> </div> <p>…and (without assignment returns a Series)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [21]: df.loc[(df["BBB"] &lt; 25) &amp; (df["CCC"] &gt;= -40), "AAA"]
Out[21]: 
0    4
1    5
Name: AAA, dtype: int64
</pre></div> </div> <p>…or (without assignment returns a Series)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [22]: df.loc[(df["BBB"] &gt; 25) | (df["CCC"] &gt;= -40), "AAA"]
Out[22]: 
0    4
1    5
2    6
3    7
Name: AAA, dtype: int64
</pre></div> </div> <p>…or (with assignment modifies the DataFrame.)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [23]: df.loc[(df["BBB"] &gt; 25) | (df["CCC"] &gt;= 75), "AAA"] = 999

In [24]: df
Out[24]: 
   AAA  BBB  CCC
0  999   10  100
1    5   20   50
2  999   30  -30
3  999   40  -50
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/17758023/return-rows-in-a-dataframe-closest-to-a-user-defined-number">Select rows with data closest to certain value using argsort</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [26]: df
Out[26]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [27]: aValue = 43.0

In [28]: df.loc[(df.CCC - aValue).abs().argsort()]
Out[28]: 
   AAA  BBB  CCC
1    5   20   50
0    4   10  100
2    6   30  -30
3    7   40  -50
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/21058254/pandas-boolean-operation-in-a-python-list/21058331">Dynamically reduce a list of criteria using a binary operators</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [29]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [30]: df
Out[30]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [31]: Crit1 = df.AAA &lt;= 5.5

In [32]: Crit2 = df.BBB == 10.0

In [33]: Crit3 = df.CCC &gt; -40.0
</pre></div> </div> <p>One could hard code:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [34]: AllCrit = Crit1 &amp; Crit2 &amp; Crit3
</pre></div> </div> <p>…Or it can be done with a list of dynamically built criteria</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [35]: import functools

In [36]: CritList = [Crit1, Crit2, Crit3]

In [37]: AllCrit = functools.reduce(lambda x, y: x &amp; y, CritList)

In [38]: df[AllCrit]
Out[38]: 
   AAA  BBB  CCC
0    4   10  100
</pre></div> </div> </section> </section> <section id="selection"> <h2>Selection</h2> <section id="dataframes"> <h3>Dataframes</h3> <p>The <a class="reference internal" href="indexing.html#indexing"><span class="std std-ref">indexing</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/14725068/pandas-using-row-labels-in-boolean-indexing">Using both row labels and value conditionals</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [39]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [40]: df
Out[40]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [41]: df[(df.AAA &lt;= 6) &amp; (df.index.isin([0, 2, 4]))]
Out[41]: 
   AAA  BBB  CCC
0    4   10  100
2    6   30  -30
</pre></div> </div> <p>Use loc for label-oriented slicing and iloc positional slicing <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2904">GH 2904</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]},
   ....:     index=["foo", "bar", "boo", "kar"],
   ....: )
   ....: 
</pre></div> </div> <p>There are 2 explicit slicing methods, with a third general case</p> <ol class="arabic simple"> <li><p>Positional-oriented (Python slicing style : exclusive of end)</p></li> <li><p>Label-oriented (Non-Python slicing style : inclusive of end)</p></li> <li><p>General (Either slicing style : depends on if the slice contains labels or positions)</p></li> </ol> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [43]: df.loc["bar":"kar"]  # Label
Out[43]: 
     AAA  BBB  CCC
bar    5   20   50
boo    6   30  -30
kar    7   40  -50

# Generic
In [44]: df[0:3]
Out[44]: 
     AAA  BBB  CCC
foo    4   10  100
bar    5   20   50
boo    6   30  -30

In [45]: df["bar":"kar"]
Out[45]: 
     AAA  BBB  CCC
bar    5   20   50
boo    6   30  -30
kar    7   40  -50
</pre></div> </div> <p>Ambiguity arises when an index consists of integers with a non-zero start or non-unit increment.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [46]: data = {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}

In [47]: df2 = pd.DataFrame(data=data, index=[1, 2, 3, 4])  # Note index starts at 1.

In [48]: df2.iloc[1:3]  # Position-oriented
Out[48]: 
   AAA  BBB  CCC
2    5   20   50
3    6   30  -30

In [49]: df2.loc[1:3]  # Label-oriented
Out[49]: 
   AAA  BBB  CCC
1    4   10  100
2    5   20   50
3    6   30  -30
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/14986510">Using inverse operator (~) to take the complement of a mask</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [50]: df = pd.DataFrame(
   ....:     {"AAA": [4, 5, 6, 7], "BBB": [10, 20, 30, 40], "CCC": [100, 50, -30, -50]}
   ....: )
   ....: 

In [51]: df
Out[51]: 
   AAA  BBB  CCC
0    4   10  100
1    5   20   50
2    6   30  -30
3    7   40  -50

In [52]: df[~((df.AAA &lt;= 6) &amp; (df.index.isin([0, 2, 4])))]
Out[52]: 
   AAA  BBB  CCC
1    5   20   50
3    7   40  -50
</pre></div> </div> </section> <section id="new-columns"> <h3>New columns</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/16575868/efficiently-creating-additional-columns-in-a-pandas-dataframe-using-map">Efficiently and dynamically creating new columns using DataFrame.map (previously named applymap)</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [53]: df = pd.DataFrame({"AAA": [1, 2, 1, 3], "BBB": [1, 1, 2, 2], "CCC": [2, 1, 3, 1]})

In [54]: df
Out[54]: 
   AAA  BBB  CCC
0    1    1    2
1    2    1    1
2    1    2    3
3    3    2    1

In [55]: source_cols = df.columns  # Or some subset would work too

In [56]: new_cols = [str(x) + "_cat" for x in source_cols]

In [57]: categories = {1: "Alpha", 2: "Beta", 3: "Charlie"}

In [58]: df[new_cols] = df[source_cols].map(categories.get)

In [59]: df
Out[59]: 
   AAA  BBB  CCC  AAA_cat BBB_cat  CCC_cat
0    1    1    2    Alpha   Alpha     Beta
1    2    1    1     Beta   Alpha    Alpha
2    1    2    3    Alpha    Beta  Charlie
3    3    2    1  Charlie    Beta    Alpha
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/23394476">Keep other columns when using min() with groupby</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [60]: df = pd.DataFrame(
   ....:     {"AAA": [1, 1, 1, 2, 2, 2, 3, 3], "BBB": [2, 1, 3, 4, 5, 1, 2, 3]}
   ....: )
   ....: 

In [61]: df
Out[61]: 
   AAA  BBB
0    1    2
1    1    1
2    1    3
3    2    4
4    2    5
5    2    1
6    3    2
7    3    3
</pre></div> </div> <p>Method 1 : idxmin() to get the index of the minimums</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [62]: df.loc[df.groupby("AAA")["BBB"].idxmin()]
Out[62]: 
   AAA  BBB
1    1    1
5    2    1
6    3    2
</pre></div> </div> <p>Method 2 : sort then take first of each</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [63]: df.sort_values(by="BBB").groupby("AAA", as_index=False).first()
Out[63]: 
   AAA  BBB
0    1    1
1    2    1
2    3    2
</pre></div> </div> <p>Notice the same results, with the exception of the index.</p> </section> </section> <section id="multiindexing"> <h2>Multiindexing</h2> <p>The <a class="reference internal" href="advanced.html#advanced-hierarchical"><span class="std std-ref">multindexing</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/14916358/reshaping-dataframes-in-pandas-based-on-column-labels">Creating a MultiIndex from a labeled frame</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [64]: df = pd.DataFrame(
   ....:     {
   ....:         "row": [0, 1, 2],
   ....:         "One_X": [1.1, 1.1, 1.1],
   ....:         "One_Y": [1.2, 1.2, 1.2],
   ....:         "Two_X": [1.11, 1.11, 1.11],
   ....:         "Two_Y": [1.22, 1.22, 1.22],
   ....:     }
   ....: )
   ....: 

In [65]: df
Out[65]: 
   row  One_X  One_Y  Two_X  Two_Y
0    0    1.1    1.2   1.11   1.22
1    1    1.1    1.2   1.11   1.22
2    2    1.1    1.2   1.11   1.22

# As Labelled Index
In [66]: df = df.set_index("row")

In [67]: df
Out[67]: 
     One_X  One_Y  Two_X  Two_Y
row                            
0      1.1    1.2   1.11   1.22
1      1.1    1.2   1.11   1.22
2      1.1    1.2   1.11   1.22

# With Hierarchical Columns
In [68]: df.columns = pd.MultiIndex.from_tuples([tuple(c.split("_")) for c in df.columns])

In [69]: df
Out[69]: 
     One        Two      
       X    Y     X     Y
row                      
0    1.1  1.2  1.11  1.22
1    1.1  1.2  1.11  1.22
2    1.1  1.2  1.11  1.22

# Now stack &amp; Reset
In [70]: df = df.stack(0, future_stack=True).reset_index(1)

In [71]: df
Out[71]: 
    level_1     X     Y
row                    
0       One  1.10  1.20
0       Two  1.11  1.22
1       One  1.10  1.20
1       Two  1.11  1.22
2       One  1.10  1.20
2       Two  1.11  1.22

# And fix the labels (Notice the label 'level_1' got added automatically)
In [72]: df.columns = ["Sample", "All_X", "All_Y"]

In [73]: df
Out[73]: 
    Sample  All_X  All_Y
row                     
0      One   1.10   1.20
0      Two   1.11   1.22
1      One   1.10   1.20
1      Two   1.11   1.22
2      One   1.10   1.20
2      Two   1.11   1.22
</pre></div> </div> <section id="arithmetic"> <h3>Arithmetic</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/19501510/divide-entire-pandas-multiindex-dataframe-by-dataframe-variable/19502176#19502176">Performing arithmetic with a MultiIndex that needs broadcasting</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [74]: cols = pd.MultiIndex.from_tuples(
   ....:     [(x, y) for x in ["A", "B", "C"] for y in ["O", "I"]]
   ....: )
   ....: 

In [75]: df = pd.DataFrame(np.random.randn(2, 6), index=["n", "m"], columns=cols)

In [76]: df
Out[76]: 
          A                   B                   C          
          O         I         O         I         O         I
n  0.469112 -0.282863 -1.509059 -1.135632  1.212112 -0.173215
m  0.119209 -1.044236 -0.861849 -2.104569 -0.494929  1.071804

In [77]: df = df.div(df["C"], level=1)

In [78]: df
Out[78]: 
          A                   B              C     
          O         I         O         I    O    I
n  0.387021  1.633022 -1.244983  6.556214  1.0  1.0
m -0.240860 -0.974279  1.741358 -1.963577  1.0  1.0
</pre></div> </div> </section> <section id="slicing"> <h3>Slicing</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/12590131/how-to-slice-multindex-columns-in-pandas-dataframes">Slicing a MultiIndex with xs</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [79]: coords = [("AA", "one"), ("AA", "six"), ("BB", "one"), ("BB", "two"), ("BB", "six")]

In [80]: index = pd.MultiIndex.from_tuples(coords)

In [81]: df = pd.DataFrame([11, 22, 33, 44, 55], index, ["MyData"])

In [82]: df
Out[82]: 
        MyData
AA one      11
   six      22
BB one      33
   two      44
   six      55
</pre></div> </div> <p>To take the cross section of the 1st level and 1st axis the index:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python"># Note : level and axis are optional, and default to zero
In [83]: df.xs("BB", level=0, axis=0)
Out[83]: 
     MyData
one      33
two      44
six      55
</pre></div> </div> <p>…and now the 2nd level of the 1st axis.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [84]: df.xs("six", level=1, axis=0)
Out[84]: 
    MyData
AA      22
BB      55
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14964493/multiindex-based-indexing-in-pandas">Slicing a MultiIndex with xs, method #2</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [85]: import itertools

In [86]: index = list(itertools.product(["Ada", "Quinn", "Violet"], ["Comp", "Math", "Sci"]))

In [87]: headr = list(itertools.product(["Exams", "Labs"], ["I", "II"]))

In [88]: indx = pd.MultiIndex.from_tuples(index, names=["Student", "Course"])

In [89]: cols = pd.MultiIndex.from_tuples(headr)  # Notice these are un-named

In [90]: data = [[70 + x + y + (x * y) % 3 for x in range(4)] for y in range(9)]

In [91]: df = pd.DataFrame(data, indx, cols)

In [92]: df
Out[92]: 
               Exams     Labs    
                   I  II    I  II
Student Course                   
Ada     Comp      70  71   72  73
        Math      71  73   75  74
        Sci       72  75   75  75
Quinn   Comp      73  74   75  76
        Math      74  76   78  77
        Sci       75  78   78  78
Violet  Comp      76  77   78  79
        Math      77  79   81  80
        Sci       78  81   81  81

In [93]: All = slice(None)

In [94]: df.loc["Violet"]
Out[94]: 
       Exams     Labs    
           I  II    I  II
Course                   
Comp      76  77   78  79
Math      77  79   81  80
Sci       78  81   81  81

In [95]: df.loc[(All, "Math"), All]
Out[95]: 
               Exams     Labs    
                   I  II    I  II
Student Course                   
Ada     Math      71  73   75  74
Quinn   Math      74  76   78  77
Violet  Math      77  79   81  80

In [96]: df.loc[(slice("Ada", "Quinn"), "Math"), All]
Out[96]: 
               Exams     Labs    
                   I  II    I  II
Student Course                   
Ada     Math      71  73   75  74
Quinn   Math      74  76   78  77

In [97]: df.loc[(All, "Math"), ("Exams")]
Out[97]: 
                 I  II
Student Course        
Ada     Math    71  73
Quinn   Math    74  76
Violet  Math    77  79

In [98]: df.loc[(All, "Math"), (All, "II")]
Out[98]: 
               Exams Labs
                  II   II
Student Course           
Ada     Math      73   74
Quinn   Math      76   77
Violet  Math      79   80
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/19319432/pandas-selecting-a-lower-level-in-a-dataframe-to-do-a-ffill">Setting portions of a MultiIndex with xs</a></p> </section> <section id="sorting"> <h3>Sorting</h3> <p><a class="reference external" href="https://stackoverflow.com/q/14733871">Sort by specific column or an ordered list of columns, with a MultiIndex</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [99]: df.sort_values(by=("Labs", "II"), ascending=False)
Out[99]: 
               Exams     Labs    
                   I  II    I  II
Student Course                   
Violet  Sci       78  81   81  81
        Math      77  79   81  80
        Comp      76  77   78  79
Quinn   Sci       75  78   78  78
        Math      74  76   78  77
        Comp      73  74   75  76
Ada     Sci       72  75   75  75
        Math      71  73   75  74
        Comp      70  71   72  73
</pre></div> </div> <p>Partial selection, the need for sortedness <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2995">GH 2995</a></p> </section> <section id="levels"> <h3>Levels</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/14744068/prepend-a-level-to-a-pandas-multiindex">Prepending a level to a multiindex</a></p> <p><a class="reference external" href="https://stackoverflow.com/q/14507794">Flatten Hierarchical columns</a></p> </section> </section> <section id="missing-data"> <h2>Missing data</h2> <p>The <a class="reference internal" href="missing_data.html#missing-data"><span class="std std-ref">missing data</span></a> docs.</p> <p>Fill forward a reversed timeseries</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [100]: df = pd.DataFrame(
   .....:     np.random.randn(6, 1),
   .....:     index=pd.date_range("2013-08-01", periods=6, freq="B"),
   .....:     columns=list("A"),
   .....: )
   .....: 

In [101]: df.loc[df.index[3], "A"] = np.nan

In [102]: df
Out[102]: 
                   A
2013-08-01  0.721555
2013-08-02 -0.706771
2013-08-05 -1.039575
2013-08-06       NaN
2013-08-07 -0.424972
2013-08-08  0.567020

In [103]: df.bfill()
Out[103]: 
                   A
2013-08-01  0.721555
2013-08-02 -0.706771
2013-08-05 -1.039575
2013-08-06 -0.424972
2013-08-07 -0.424972
2013-08-08  0.567020
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/18196811/cumsum-reset-at-nan">cumsum reset at NaN values</a></p> <section id="replace"> <h3>Replace</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/16818871/extracting-value-and-creating-new-column-out-of-it">Using replace with backrefs</a></p> </section> </section> <section id="grouping"> <h2>Grouping</h2> <p>The <a class="reference internal" href="groupby.html#groupby"><span class="std std-ref">grouping</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/15322632/python-pandas-df-groupy-agg-column-reference-in-agg">Basic grouping with apply</a></p> <p>Unlike agg, apply’s callable is passed a sub-DataFrame which gives you access to all the columns</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [104]: df = pd.DataFrame(
   .....:     {
   .....:         "animal": "cat dog cat fish dog cat cat".split(),
   .....:         "size": list("SSMMMLL"),
   .....:         "weight": [8, 10, 11, 1, 20, 12, 12],
   .....:         "adult": [False] * 5 + [True] * 2,
   .....:     }
   .....: )
   .....: 

In [105]: df
Out[105]: 
  animal size  weight  adult
0    cat    S       8  False
1    dog    S      10  False
2    cat    M      11  False
3   fish    M       1  False
4    dog    M      20  False
5    cat    L      12   True
6    cat    L      12   True

# List the size of the animals with the highest weight.
In [106]: df.groupby("animal").apply(lambda subf: subf["size"][subf["weight"].idxmax()], include_groups=False)
Out[106]: 
animal
cat     L
dog     M
fish    M
dtype: object
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14734533/how-to-access-pandas-groupby-dataframe-by-key">Using get_group</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [107]: gb = df.groupby("animal")

In [108]: gb.get_group("cat")
Out[108]: 
  animal size  weight  adult
0    cat    S       8  False
2    cat    M      11  False
5    cat    L      12   True
6    cat    L      12   True
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/15262134/apply-different-functions-to-different-items-in-group-object-python-pandas">Apply to different items in a group</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [109]: def GrowUp(x):
   .....:     avg_weight = sum(x[x["size"] == "S"].weight * 1.5)
   .....:     avg_weight += sum(x[x["size"] == "M"].weight * 1.25)
   .....:     avg_weight += sum(x[x["size"] == "L"].weight)
   .....:     avg_weight /= len(x)
   .....:     return pd.Series(["L", avg_weight, True], index=["size", "weight", "adult"])
   .....: 

In [110]: expected_df = gb.apply(GrowUp, include_groups=False)

In [111]: expected_df
Out[111]: 
       size   weight  adult
animal                     
cat       L  12.4375   True
dog       L  20.0000   True
fish      L   1.2500   True
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14542145/reductions-down-a-column-in-pandas">Expanding apply</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [112]: S = pd.Series([i / 100.0 for i in range(1, 11)])

In [113]: def cum_ret(x, y):
   .....:     return x * (1 + y)
   .....: 

In [114]: def red(x):
   .....:     return functools.reduce(cum_ret, x, 1.0)
   .....: 

In [115]: S.expanding().apply(red, raw=True)
Out[115]: 
0    1.010000
1    1.030200
2    1.061106
3    1.103550
4    1.158728
5    1.228251
6    1.314229
7    1.419367
8    1.547110
9    1.701821
dtype: float64
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14760757/replacing-values-with-groupby-means">Replacing some values with mean of the rest of a group</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [116]: df = pd.DataFrame({"A": [1, 1, 2, 2], "B": [1, -1, 1, 2]})

In [117]: gb = df.groupby("A")

In [118]: def replace(g):
   .....:     mask = g &lt; 0
   .....:     return g.where(~mask, g[~mask].mean())
   .....: 

In [119]: gb.transform(replace)
Out[119]: 
   B
0  1
1  1
2  1
3  2
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14941366/pandas-sort-by-group-aggregate-and-column">Sort groups by aggregated data</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [120]: df = pd.DataFrame(
   .....:     {
   .....:         "code": ["foo", "bar", "baz"] * 2,
   .....:         "data": [0.16, -0.21, 0.33, 0.45, -0.59, 0.62],
   .....:         "flag": [False, True] * 3,
   .....:     }
   .....: )
   .....: 

In [121]: code_groups = df.groupby("code")

In [122]: agg_n_sort_order = code_groups[["data"]].transform("sum").sort_values(by="data")

In [123]: sorted_df = df.loc[agg_n_sort_order.index]

In [124]: sorted_df
Out[124]: 
  code  data   flag
1  bar -0.21   True
4  bar -0.59  False
0  foo  0.16  False
3  foo  0.45   True
2  baz  0.33  False
5  baz  0.62   True
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14897100/create-multiple-columns-in-pandas-aggregation-function">Create multiple aggregated columns</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [125]: rng = pd.date_range(start="2014-10-07", periods=10, freq="2min")

In [126]: ts = pd.Series(data=list(range(10)), index=rng)

In [127]: def MyCust(x):
   .....:     if len(x) &gt; 2:
   .....:         return x.iloc[1] * 1.234
   .....:     return pd.NaT
   .....: 

In [128]: mhc = {"Mean": "mean", "Max": "max", "Custom": MyCust}

In [129]: ts.resample("5min").apply(mhc)
Out[129]: 
                     Mean  Max Custom
2014-10-07 00:00:00   1.0    2  1.234
2014-10-07 00:05:00   3.5    4    NaT
2014-10-07 00:10:00   6.0    7  7.404
2014-10-07 00:15:00   8.5    9    NaT

In [130]: ts
Out[130]: 
2014-10-07 00:00:00    0
2014-10-07 00:02:00    1
2014-10-07 00:04:00    2
2014-10-07 00:06:00    3
2014-10-07 00:08:00    4
2014-10-07 00:10:00    5
2014-10-07 00:12:00    6
2014-10-07 00:14:00    7
2014-10-07 00:16:00    8
2014-10-07 00:18:00    9
Freq: 2min, dtype: int64
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/17709270">Create a value counts column and reassign back to the DataFrame</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [131]: df = pd.DataFrame(
   .....:     {"Color": "Red Red Red Blue".split(), "Value": [100, 150, 50, 50]}
   .....: )
   .....: 

In [132]: df
Out[132]: 
  Color  Value
0   Red    100
1   Red    150
2   Red     50
3  Blue     50

In [133]: df["Counts"] = df.groupby(["Color"]).transform(len)

In [134]: df
Out[134]: 
  Color  Value  Counts
0   Red    100       3
1   Red    150       3
2   Red     50       3
3  Blue     50       1
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/23198053/190597">Shift groups of the values in a column based on the index</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [135]: df = pd.DataFrame(
   .....:     {"line_race": [10, 10, 8, 10, 10, 8], "beyer": [99, 102, 103, 103, 88, 100]},
   .....:     index=[
   .....:         "Last Gunfighter",
   .....:         "Last Gunfighter",
   .....:         "Last Gunfighter",
   .....:         "Paynter",
   .....:         "Paynter",
   .....:         "Paynter",
   .....:     ],
   .....: )
   .....: 

In [136]: df
Out[136]: 
                 line_race  beyer
Last Gunfighter         10     99
Last Gunfighter         10    102
Last Gunfighter          8    103
Paynter                 10    103
Paynter                 10     88
Paynter                  8    100

In [137]: df["beyer_shifted"] = df.groupby(level=0)["beyer"].shift(1)

In [138]: df
Out[138]: 
                 line_race  beyer  beyer_shifted
Last Gunfighter         10     99            NaN
Last Gunfighter         10    102           99.0
Last Gunfighter          8    103          102.0
Paynter                 10    103            NaN
Paynter                 10     88          103.0
Paynter                  8    100           88.0
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/26701849/190597">Select row with maximum value from each group</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [139]: df = pd.DataFrame(
   .....:     {
   .....:         "host": ["other", "other", "that", "this", "this"],
   .....:         "service": ["mail", "web", "mail", "mail", "web"],
   .....:         "no": [1, 2, 1, 2, 1],
   .....:     }
   .....: ).set_index(["host", "service"])
   .....: 

In [140]: mask = df.groupby(level=0).agg("idxmax")

In [141]: df_count = df.loc[mask["no"]].reset_index()

In [142]: df_count
Out[142]: 
    host service  no
0  other     web   2
1   that    mail   1
2   this    mail   2
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/q/29142487/846892">Grouping like Python’s itertools.groupby</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [143]: df = pd.DataFrame([0, 1, 0, 1, 1, 1, 0, 1, 1], columns=["A"])

In [144]: df["A"].groupby((df["A"] != df["A"].shift()).cumsum()).groups
Out[144]: {1: [0], 2: [1], 3: [2], 4: [3, 4, 5], 5: [6], 6: [7, 8]}

In [145]: df["A"].groupby((df["A"] != df["A"].shift()).cumsum()).cumsum()
Out[145]: 
0    0
1    1
2    0
3    1
4    2
5    3
6    0
7    1
8    2
Name: A, dtype: int64
</pre></div> </div> <section id="expanding-data"> <h3>Expanding data</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/15489011/python-time-series-alignment-and-to-date-functions">Alignment and to-date</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/14300768/pandas-rolling-computation-with-window-based-on-values-instead-of-counts">Rolling Computation window based on values instead of counts</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15771472/pandas-rolling-mean-by-time-interval">Rolling Mean by Time Interval</a></p> </section> <section id="id2"> <h3>Splitting</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/13353233/best-way-to-split-a-dataframe-given-an-edge/15449992#15449992">Splitting a frame</a></p> <p>Create a list of dataframes, split using a delineation based on logic included in rows.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [146]: df = pd.DataFrame(
   .....:     data={
   .....:         "Case": ["A", "A", "A", "B", "A", "A", "B", "A", "A"],
   .....:         "Data": np.random.randn(9),
   .....:     }
   .....: )
   .....: 

In [147]: dfs = list(
   .....:     zip(
   .....:         *df.groupby(
   .....:             (1 * (df["Case"] == "B"))
   .....:             .cumsum()
   .....:             .rolling(window=3, min_periods=1)
   .....:             .median()
   .....:         )
   .....:     )
   .....: )[-1]
   .....: 

In [148]: dfs[0]
Out[148]: 
  Case      Data
0    A  0.276232
1    A -1.087401
2    A -0.673690
3    B  0.113648

In [149]: dfs[1]
Out[149]: 
  Case      Data
4    A -1.478427
5    A  0.524988
6    B  0.404705

In [150]: dfs[2]
Out[150]: 
  Case      Data
7    A  0.577046
8    A -1.715002
</pre></div> </div> </section> <section id="pivot"> <h3>Pivot</h3> <p>The <a class="reference internal" href="reshaping.html#reshaping-pivot"><span class="std std-ref">Pivot</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/a/15574875">Partial sums and subtotals</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [151]: df = pd.DataFrame(
   .....:     data={
   .....:         "Province": ["ON", "QC", "BC", "AL", "AL", "MN", "ON"],
   .....:         "City": [
   .....:             "Toronto",
   .....:             "Montreal",
   .....:             "Vancouver",
   .....:             "Calgary",
   .....:             "Edmonton",
   .....:             "Winnipeg",
   .....:             "Windsor",
   .....:         ],
   .....:         "Sales": [13, 6, 16, 8, 4, 3, 1],
   .....:     }
   .....: )
   .....: 

In [152]: table = pd.pivot_table(
   .....:     df,
   .....:     values=["Sales"],
   .....:     index=["Province"],
   .....:     columns=["City"],
   .....:     aggfunc="sum",
   .....:     margins=True,
   .....: )
   .....: 

In [153]: table.stack("City", future_stack=True)
Out[153]: 
                    Sales
Province City            
AL       Calgary      8.0
         Edmonton     4.0
         Montreal     NaN
         Toronto      NaN
         Vancouver    NaN
...                   ...
All      Toronto     13.0
         Vancouver   16.0
         Windsor      1.0
         Winnipeg     3.0
         All         51.0

[48 rows x 1 columns]
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/15589354/frequency-tables-in-pandas-like-plyr-in-r">Frequency table like plyr in R</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [154]: grades = [48, 99, 75, 80, 42, 80, 72, 68, 36, 78]

In [155]: df = pd.DataFrame(
   .....:     {
   .....:         "ID": ["x%d" % r for r in range(10)],
   .....:         "Gender": ["F", "M", "F", "M", "F", "M", "F", "M", "M", "M"],
   .....:         "ExamYear": [
   .....:             "2007",
   .....:             "2007",
   .....:             "2007",
   .....:             "2008",
   .....:             "2008",
   .....:             "2008",
   .....:             "2008",
   .....:             "2009",
   .....:             "2009",
   .....:             "2009",
   .....:         ],
   .....:         "Class": [
   .....:             "algebra",
   .....:             "stats",
   .....:             "bio",
   .....:             "algebra",
   .....:             "algebra",
   .....:             "stats",
   .....:             "stats",
   .....:             "algebra",
   .....:             "bio",
   .....:             "bio",
   .....:         ],
   .....:         "Participated": [
   .....:             "yes",
   .....:             "yes",
   .....:             "yes",
   .....:             "yes",
   .....:             "no",
   .....:             "yes",
   .....:             "yes",
   .....:             "yes",
   .....:             "yes",
   .....:             "yes",
   .....:         ],
   .....:         "Passed": ["yes" if x &gt; 50 else "no" for x in grades],
   .....:         "Employed": [
   .....:             True,
   .....:             True,
   .....:             True,
   .....:             False,
   .....:             False,
   .....:             False,
   .....:             False,
   .....:             True,
   .....:             True,
   .....:             False,
   .....:         ],
   .....:         "Grade": grades,
   .....:     }
   .....: )
   .....: 

In [156]: df.groupby("ExamYear").agg(
   .....:     {
   .....:         "Participated": lambda x: x.value_counts()["yes"],
   .....:         "Passed": lambda x: sum(x == "yes"),
   .....:         "Employed": lambda x: sum(x),
   .....:         "Grade": lambda x: sum(x) / len(x),
   .....:     }
   .....: )
   .....: 
Out[156]: 
          Participated  Passed  Employed      Grade
ExamYear                                           
2007                 3       2         3  74.000000
2008                 3       3         0  68.500000
2009                 3       2         2  60.666667
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/30379789/plot-pandas-data-frame-with-year-over-year-data">Plot pandas DataFrame with year over year data</a></p> <p>To create year and month cross tabulation:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [157]: df = pd.DataFrame(
   .....:     {"value": np.random.randn(36)},
   .....:     index=pd.date_range("2011-01-01", freq="ME", periods=36),
   .....: )
   .....: 

In [158]: pd.pivot_table(
   .....:     df, index=df.index.month, columns=df.index.year, values="value", aggfunc="sum"
   .....: )
   .....: 
Out[158]: 
        2011      2012      2013
1  -1.039268 -0.968914  2.565646
2  -0.370647 -1.294524  1.431256
3  -1.157892  0.413738  1.340309
4  -1.344312  0.276662 -1.170299
5   0.844885 -0.472035 -0.226169
6   1.075770 -0.013960  0.410835
7  -0.109050 -0.362543  0.813850
8   1.643563 -0.006154  0.132003
9  -1.469388 -0.923061 -0.827317
10  0.357021  0.895717 -0.076467
11 -0.674600  0.805244 -1.187678
12 -1.776904 -1.206412  1.130127
</pre></div> </div> </section> <section id="apply"> <h3>Apply</h3> <p><a class="reference external" href="https://stackoverflow.com/questions/17349981/converting-pandas-dataframe-with-categorical-values-into-binary-values">Rolling apply to organize - Turning embedded lists into a MultiIndex frame</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [159]: df = pd.DataFrame(
   .....:     data={
   .....:         "A": [[2, 4, 8, 16], [100, 200], [10, 20, 30]],
   .....:         "B": [["a", "b", "c"], ["jj", "kk"], ["ccc"]],
   .....:     },
   .....:     index=["I", "II", "III"],
   .....: )
   .....: 

In [160]: def SeriesFromSubList(aList):
   .....:     return pd.Series(aList)
   .....: 

In [161]: df_orgz = pd.concat(
   .....:     {ind: row.apply(SeriesFromSubList) for ind, row in df.iterrows()}
   .....: )
   .....: 

In [162]: df_orgz
Out[162]: 
         0     1     2     3
I   A    2     4     8  16.0
    B    a     b     c   NaN
II  A  100   200   NaN   NaN
    B   jj    kk   NaN   NaN
III A   10  20.0  30.0   NaN
    B  ccc   NaN   NaN   NaN
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/19121854/using-rolling-apply-on-a-dataframe-object">Rolling apply with a DataFrame returning a Series</a></p> <p>Rolling Apply to multiple columns where function calculates a Series before a Scalar from the Series is returned</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [163]: df = pd.DataFrame(
   .....:     data=np.random.randn(2000, 2) / 10000,
   .....:     index=pd.date_range("2001-01-01", periods=2000),
   .....:     columns=["A", "B"],
   .....: )
   .....: 

In [164]: df
Out[164]: 
                   A         B
2001-01-01 -0.000144 -0.000141
2001-01-02  0.000161  0.000102
2001-01-03  0.000057  0.000088
2001-01-04 -0.000221  0.000097
2001-01-05 -0.000201 -0.000041
...              ...       ...
2006-06-19  0.000040 -0.000235
2006-06-20 -0.000123 -0.000021
2006-06-21 -0.000113  0.000114
2006-06-22  0.000136  0.000109
2006-06-23  0.000027  0.000030

[2000 rows x 2 columns]

In [165]: def gm(df, const):
   .....:     v = ((((df["A"] + df["B"]) + 1).cumprod()) - 1) * const
   .....:     return v.iloc[-1]
   .....: 

In [166]: s = pd.Series(
   .....:     {
   .....:         df.index[i]: gm(df.iloc[i: min(i + 51, len(df) - 1)], 5)
   .....:         for i in range(len(df) - 50)
   .....:     }
   .....: )
   .....: 

In [167]: s
Out[167]: 
2001-01-01    0.000930
2001-01-02    0.002615
2001-01-03    0.001281
2001-01-04    0.001117
2001-01-05    0.002772
                ...   
2006-04-30    0.003296
2006-05-01    0.002629
2006-05-02    0.002081
2006-05-03    0.004247
2006-05-04    0.003928
Length: 1950, dtype: float64
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/21040766/python-pandas-rolling-apply-two-column-input-into-function/21045831#21045831">Rolling apply with a DataFrame returning a Scalar</a></p> <p>Rolling Apply to multiple columns where function returns a Scalar (Volume Weighted Average Price)</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [168]: rng = pd.date_range(start="2014-01-01", periods=100)

In [169]: df = pd.DataFrame(
   .....:     {
   .....:         "Open": np.random.randn(len(rng)),
   .....:         "Close": np.random.randn(len(rng)),
   .....:         "Volume": np.random.randint(100, 2000, len(rng)),
   .....:     },
   .....:     index=rng,
   .....: )
   .....: 

In [170]: df
Out[170]: 
                Open     Close  Volume
2014-01-01 -1.611353 -0.492885    1219
2014-01-02 -3.000951  0.445794    1054
2014-01-03 -0.138359 -0.076081    1381
2014-01-04  0.301568  1.198259    1253
2014-01-05  0.276381 -0.669831    1728
...              ...       ...     ...
2014-04-06 -0.040338  0.937843    1188
2014-04-07  0.359661 -0.285908    1864
2014-04-08  0.060978  1.714814     941
2014-04-09  1.759055 -0.455942    1065
2014-04-10  0.138185 -1.147008    1453

[100 rows x 3 columns]

In [171]: def vwap(bars):
   .....:     return (bars.Close * bars.Volume).sum() / bars.Volume.sum()
   .....: 

In [172]: window = 5

In [173]: s = pd.concat(
   .....:     [
   .....:         (pd.Series(vwap(df.iloc[i: i + window]), index=[df.index[i + window]]))
   .....:         for i in range(len(df) - window)
   .....:     ]
   .....: )
   .....: 

In [174]: s.round(2)
Out[174]: 
2014-01-06    0.02
2014-01-07    0.11
2014-01-08    0.10
2014-01-09    0.07
2014-01-10   -0.29
              ... 
2014-04-06   -0.63
2014-04-07   -0.02
2014-04-08   -0.03
2014-04-09    0.34
2014-04-10    0.29
Length: 95, dtype: float64
</pre></div> </div> </section> </section> <section id="timeseries"> <h2>Timeseries</h2> <p><a class="reference external" href="https://stackoverflow.com/questions/14539992/pandas-drop-rows-outside-of-time-range">Between times</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17559885/pandas-dataframe-mask-based-on-index">Using indexer between time</a></p> <p><a class="reference external" href="https://stackoverflow.com/a/24014440">Constructing a datetime range that excludes weekends and includes only certain times</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/13893227/vectorized-look-up-of-values-in-pandas-dataframe">Vectorized Lookup</a></p> <p><a class="reference external" href="https://nipunbatra.github.io/blog/visualisation/2013/05/01/aggregation-timeseries.html">Aggregation and plotting time series</a></p> <p>Turn a matrix with hours in columns and days in rows into a continuous row sequence in the form of a time series. <a class="reference external" href="https://stackoverflow.com/questions/15432659/how-to-rearrange-a-python-pandas-dataframe">How to rearrange a Python pandas DataFrame?</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/22244383/pandas-df-refill-adding-two-columns-of-different-shape">Dealing with duplicates when reindexing a timeseries to a specified frequency</a></p> <p>Calculate the first day of the month for each entry in a DatetimeIndex</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [175]: dates = pd.date_range("2000-01-01", periods=5)

In [176]: dates.to_period(freq="M").to_timestamp()
Out[176]: 
DatetimeIndex(['2000-01-01', '2000-01-01', '2000-01-01', '2000-01-01',
               '2000-01-01'],
              dtype='datetime64[ns]', freq=None)
</pre></div> </div> <section id="resampling"> <h3>Resampling</h3> <p>The <a class="reference internal" href="timeseries.html#timeseries-resampling"><span class="std std-ref">Resample</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/15297053/how-can-i-divide-single-values-of-a-dataframe-by-monthly-averages">Using Grouper instead of TimeGrouper for time grouping of values</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/33637312/pandas-grouper-by-frequency-with-completeness-requirement">Time grouping with some missing values</a></p> <p>Valid frequency arguments to Grouper <a class="reference internal" href="timeseries.html#timeseries-offset-aliases"><span class="std std-ref">Timeseries</span></a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/41483763/pandas-timegrouper-on-multiindex">Grouping using a MultiIndex</a></p> <p>Using TimeGrouper and another grouping to create subgroups, then apply a custom function <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/3791">GH 3791</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15408156/resampling-with-custom-periods">Resampling with custom periods</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/14898574/resample-intrday-pandas-dataframe-without-add-new-days">Resample intraday frame without adding new days</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/14861023/resampling-minute-data">Resample minute data</a></p> <p><a class="reference external" href="https://stackoverflow.com/q/18677271/564538">Resample with groupby</a></p> </section> </section> <section id="merge"> <h2>Merge</h2> <p>The <a class="reference internal" href="merging.html#merging-join"><span class="std std-ref">Join</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/14988480/pandas-version-of-rbind">Concatenate two dataframes with overlapping index (emulate R rbind)</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [177]: rng = pd.date_range("2000-01-01", periods=6)

In [178]: df1 = pd.DataFrame(np.random.randn(6, 3), index=rng, columns=["A", "B", "C"])

In [179]: df2 = df1.copy()
</pre></div> </div> <p>Depending on df construction, <code class="docutils literal notranslate"><span class="pre">ignore_index</span></code> may be needed</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [180]: df = pd.concat([df1, df2], ignore_index=True)

In [181]: df
Out[181]: 
           A         B         C
0  -0.870117 -0.479265 -0.790855
1   0.144817  1.726395 -0.464535
2  -0.821906  1.597605  0.187307
3  -0.128342 -1.511638 -0.289858
4   0.399194 -1.430030 -0.639760
5   1.115116 -2.012600  1.810662
6  -0.870117 -0.479265 -0.790855
7   0.144817  1.726395 -0.464535
8  -0.821906  1.597605  0.187307
9  -0.128342 -1.511638 -0.289858
10  0.399194 -1.430030 -0.639760
11  1.115116 -2.012600  1.810662
</pre></div> </div> <p>Self Join of a DataFrame <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2996">GH 2996</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [182]: df = pd.DataFrame(
   .....:     data={
   .....:         "Area": ["A"] * 5 + ["C"] * 2,
   .....:         "Bins": [110] * 2 + [160] * 3 + [40] * 2,
   .....:         "Test_0": [0, 1, 0, 1, 2, 0, 1],
   .....:         "Data": np.random.randn(7),
   .....:     }
   .....: )
   .....: 

In [183]: df
Out[183]: 
  Area  Bins  Test_0      Data
0    A   110       0 -0.433937
1    A   110       1 -0.160552
2    A   160       0  0.744434
3    A   160       1  1.754213
4    A   160       2  0.000850
5    C    40       0  0.342243
6    C    40       1  1.070599

In [184]: df["Test_1"] = df["Test_0"] - 1

In [185]: pd.merge(
   .....:     df,
   .....:     df,
   .....:     left_on=["Bins", "Area", "Test_0"],
   .....:     right_on=["Bins", "Area", "Test_1"],
   .....:     suffixes=("_L", "_R"),
   .....: )
   .....: 
Out[185]: 
  Area  Bins  Test_0_L    Data_L  Test_1_L  Test_0_R    Data_R  Test_1_R
0    A   110         0 -0.433937        -1         1 -0.160552         0
1    A   160         0  0.744434        -1         1  1.754213         0
2    A   160         1  1.754213         0         2  0.000850         1
3    C    40         0  0.342243        -1         1  1.070599         0
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/14341805/pandas-merge-pd-merge-how-to-set-the-index-and-join">How to set the index and join</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/12322289/kdb-like-asof-join-for-timeseries-data-in-pandas/12336039#12336039">KDB like asof join</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15581829/how-to-perform-an-inner-or-outer-join-of-dataframes-with-pandas-on-non-simplisti">Join with a criteria based on the values</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/25125626/pandas-merge-with-logic/2512764">Using searchsorted to merge based on values inside a range</a></p> </section> <section id="plotting"> <h2>Plotting</h2> <p>The <a class="reference internal" href="visualization.html#visualization"><span class="std std-ref">Plotting</span></a> docs.</p> <p><a class="reference external" href="https://stackoverflow.com/questions/14349055/making-matplotlib-graphs-look-like-r-by-default">Make Matplotlib look like R</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/12945971/pandas-timeseries-plot-setting-x-axis-major-and-minor-ticks-and-labels">Setting x-axis major and minor labels</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/16392921/make-more-than-one-chart-in-same-ipython-notebook-cell">Plotting multiple charts in an IPython Jupyter notebook</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/16568964/make-a-multiline-plot-from-csv-file-in-matplotlib">Creating a multi-line plot</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17050202/plot-timeseries-of-histograms-in-python">Plotting a heatmap</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/11067368/annotate-time-series-plot-in-matplotlib">Annotate a time-series plot</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17891493/annotating-points-from-a-pandas-dataframe-in-matplotlib-plot">Annotate a time-series plot #2</a></p> <p><a class="reference external" href="https://pandas-xlsxwriter-charts.readthedocs.io/">Generate Embedded plots in excel files using Pandas, Vincent and xlsxwriter</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/23232989/boxplot-stratified-by-column-in-python-pandas">Boxplot for each quartile of a stratifying variable</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [186]: df = pd.DataFrame(
   .....:     {
   .....:         "stratifying_var": np.random.uniform(0, 100, 20),
   .....:         "price": np.random.normal(100, 5, 20),
   .....:     }
   .....: )
   .....: 

In [187]: df["quartiles"] = pd.qcut(
   .....:     df["stratifying_var"], 4, labels=["0-25%", "25-50%", "50-75%", "75-100%"]
   .....: )
   .....: 

In [188]: df.boxplot(column="price", by="quartiles")
Out[188]: &lt;Axes: title={'center': 'price'}, xlabel='quartiles'&gt;
</pre></div> </div> <img alt="../_images/quartile_boxplot.png" src="data:image/png;base64,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"> </section> <section id="data-in-out"> <h2>Data in/out</h2> <p><a class="reference external" href="https://stackoverflow.com/q/16628329">Performance comparison of SQL vs HDF5</a></p> <section id="csv"> <h3>CSV</h3> <p>The <a class="reference internal" href="io.html#io-read-csv-table"><span class="std std-ref">CSV</span></a> docs</p> <p><a class="reference external" href="https://wesmckinney.com/blog/update-on-upcoming-pandas-v0-10-new-file-parser-other-performance-wins/">read_csv in action</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17134942/pandas-dataframe-output-end-of-csv">appending to a csv</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/11622652/large-persistent-dataframe-in-pandas/12193309#12193309">Reading a csv chunk-by-chunk</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/19674212/pandas-data-frame-select-rows-and-clear-memory">Reading only certain rows of a csv chunk-by-chunk</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15008970/way-to-read-first-few-lines-for-pandas-dataframe">Reading the first few lines of a frame</a></p> <p>Reading a file that is compressed but not by <code class="docutils literal notranslate"><span class="pre">gzip/bz2</span></code> (the native compressed formats which <code class="docutils literal notranslate"><span class="pre">read_csv</span></code> understands). This example shows a <code class="docutils literal notranslate"><span class="pre">WinZipped</span></code> file, but is a general application of opening the file within a context manager and using that handle to read. <a class="reference external" href="https://stackoverflow.com/questions/17789907/pandas-convert-winzipped-csv-file-to-data-frame">See here</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15555005/get-inferred-dataframe-types-iteratively-using-chunksize">Inferring dtypes from a file</a></p> <p>Dealing with bad lines <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/2886">GH 2886</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17349574/pandas-write-multiindex-rows-with-to-csv">Write a multi-row index CSV without writing duplicates</a></p> <section id="reading-multiple-files-to-create-a-single-dataframe"> <h4>Reading multiple files to create a single DataFrame</h4> <p>The best way to combine multiple files into a single DataFrame is to read the individual frames one by one, put all of the individual frames into a list, and then combine the frames in the list using <code class="xref py py-func docutils literal notranslate"><span class="pre">pd.concat()</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [189]: for i in range(3):
   .....:     data = pd.DataFrame(np.random.randn(10, 4))
   .....:     data.to_csv("file_{}.csv".format(i))
   .....: 

In [190]: files = ["file_0.csv", "file_1.csv", "file_2.csv"]

In [191]: result = pd.concat([pd.read_csv(f) for f in files], ignore_index=True)
</pre></div> </div> <p>You can use the same approach to read all files matching a pattern. Here is an example using <code class="docutils literal notranslate"><span class="pre">glob</span></code>:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [192]: import glob

In [193]: import os

In [194]: files = glob.glob("file_*.csv")

In [195]: result = pd.concat([pd.read_csv(f) for f in files], ignore_index=True)
</pre></div> </div> <p>Finally, this strategy will work with the other <code class="docutils literal notranslate"><span class="pre">pd.read_*(...)</span></code> functions described in the <a class="reference internal" href="io.html#io"><span class="std std-ref">io docs</span></a>.</p> </section> <section id="parsing-date-components-in-multi-columns"> <h4>Parsing date components in multi-columns</h4> <p>Parsing date components in multi-columns is faster with a format</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [196]: i = pd.date_range("20000101", periods=10000)

In [197]: df = pd.DataFrame({"year": i.year, "month": i.month, "day": i.day})

In [198]: df.head()
Out[198]: 
   year  month  day
0  2000      1    1
1  2000      1    2
2  2000      1    3
3  2000      1    4
4  2000      1    5

In [199]: %timeit pd.to_datetime(df.year * 10000 + df.month * 100 + df.day, format='%Y%m%d')
   .....: ds = df.apply(lambda x: "%04d%02d%02d" % (x["year"], x["month"], x["day"]), axis=1)
   .....: ds.head()
   .....: %timeit pd.to_datetime(ds)
   .....: 
4.01 ms +- 635 us per loop (mean +- std. dev. of 7 runs, 100 loops each)
1.05 ms +- 7.39 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each)
</pre></div> </div> </section> <section id="skip-row-between-header-and-data"> <h4>Skip row between header and data</h4> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [200]: data = """;;;;
   .....:  ;;;;
   .....:  ;;;;
   .....:  ;;;;
   .....:  ;;;;
   .....:  ;;;;
   .....: ;;;;
   .....:  ;;;;
   .....:  ;;;;
   .....: ;;;;
   .....: date;Param1;Param2;Param4;Param5
   .....:     ;m²;°C;m²;m
   .....: ;;;;
   .....: 01.01.1990 00:00;1;1;2;3
   .....: 01.01.1990 01:00;5;3;4;5
   .....: 01.01.1990 02:00;9;5;6;7
   .....: 01.01.1990 03:00;13;7;8;9
   .....: 01.01.1990 04:00;17;9;10;11
   .....: 01.01.1990 05:00;21;11;12;13
   .....: """
   .....: 
</pre></div> </div> <section id="option-1-pass-rows-explicitly-to-skip-rows"> <h5>Option 1: pass rows explicitly to skip rows</h5> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [201]: from io import StringIO

In [202]: pd.read_csv(
   .....:     StringIO(data),
   .....:     sep=";",
   .....:     skiprows=[11, 12],
   .....:     index_col=0,
   .....:     parse_dates=True,
   .....:     header=10,
   .....: )
   .....: 
Out[202]: 
                     Param1  Param2  Param4  Param5
date                                               
1990-01-01 00:00:00       1       1       2       3
1990-01-01 01:00:00       5       3       4       5
1990-01-01 02:00:00       9       5       6       7
1990-01-01 03:00:00      13       7       8       9
1990-01-01 04:00:00      17       9      10      11
1990-01-01 05:00:00      21      11      12      13
</pre></div> </div> </section> <section id="option-2-read-column-names-and-then-data"> <h5>Option 2: read column names and then data</h5> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [203]: pd.read_csv(StringIO(data), sep=";", header=10, nrows=10).columns
Out[203]: Index(['date', 'Param1', 'Param2', 'Param4', 'Param5'], dtype='object')

In [204]: columns = pd.read_csv(StringIO(data), sep=";", header=10, nrows=10).columns

In [205]: pd.read_csv(
   .....:     StringIO(data), sep=";", index_col=0, header=12, parse_dates=True, names=columns
   .....: )
   .....: 
Out[205]: 
                     Param1  Param2  Param4  Param5
date                                               
1990-01-01 00:00:00       1       1       2       3
1990-01-01 01:00:00       5       3       4       5
1990-01-01 02:00:00       9       5       6       7
1990-01-01 03:00:00      13       7       8       9
1990-01-01 04:00:00      17       9      10      11
1990-01-01 05:00:00      21      11      12      13
</pre></div> </div> </section> </section> </section> <section id="sql"> <h3>SQL</h3> <p>The <a class="reference internal" href="io.html#io-sql"><span class="std std-ref">SQL</span></a> docs</p> <p><a class="reference external" href="https://stackoverflow.com/questions/10065051/python-pandas-and-databases-like-mysql">Reading from databases with SQL</a></p> </section> <section id="excel"> <h3>Excel</h3> <p>The <a class="reference internal" href="io.html#io-excel"><span class="std std-ref">Excel</span></a> docs</p> <p><a class="reference external" href="https://stackoverflow.com/questions/15588713/sheets-of-excel-workbook-from-a-url-into-a-pandas-dataframe">Reading from a filelike handle</a></p> <p><a class="reference external" href="https://pbpython.com/improve-pandas-excel-output.html">Modifying formatting in XlsxWriter output</a></p> <p>Loading only visible sheets <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/19842#issuecomment-892150745">GH 19842#issuecomment-892150745</a></p> </section> <section id="html"> <h3>HTML</h3> <p><a class="reference external" href="https://stackoverflow.com/a/18939272/564538">Reading HTML tables from a server that cannot handle the default request header</a></p> </section> <section id="hdfstore"> <h3>HDFStore</h3> <p>The <a class="reference internal" href="io.html#io-hdf5"><span class="std std-ref">HDFStores</span></a> docs</p> <p><a class="reference external" href="https://stackoverflow.com/questions/13926089/selecting-columns-from-pandas-hdfstore-table">Simple queries with a Timestamp Index</a></p> <p>Managing heterogeneous data using a linked multiple table hierarchy <a class="reference external" href="https://github.com/pandas-dev/pandas/issues/3032">GH 3032</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/14614512/merging-two-tables-with-millions-of-rows-in-python/14617925#14617925">Merging on-disk tables with millions of rows</a></p> <p><a class="reference external" href="https://stackoverflow.com/a/29014295/2858145">Avoiding inconsistencies when writing to a store from multiple processes/threads</a></p> <p>De-duplicating a large store by chunks, essentially a recursive reduction operation. Shows a function for taking in data from csv file and creating a store by chunks, with date parsing as well. <a class="reference external" href="https://stackoverflow.com/questions/16110252/need-to-compare-very-large-files-around-1-5gb-in-python/16110391#16110391">See here</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/20428355/appending-column-to-frame-of-hdf-file-in-pandas/20428786#20428786">Creating a store chunk-by-chunk from a csv file</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/16997048/how-does-one-append-large-amounts-of-data-to-a-pandas-hdfstore-and-get-a-natural/16999397#16999397">Appending to a store, while creating a unique index</a></p> <p><a class="reference external" href="https://stackoverflow.com/q/14262433">Large Data work flows</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/16997048/how-does-one-append-large-amounts-of-data-to-a-pandas-hdfstore-and-get-a-natural">Reading in a sequence of files, then providing a global unique index to a store while appending</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15798209/pandas-group-by-query-on-large-data-in-hdfstore">Groupby on a HDFStore with low group density</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/25459982/trouble-with-grouby-on-millions-of-keys-on-a-chunked-file-in-python-pandas/25471765#25471765">Groupby on a HDFStore with high group density</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/22777284/improve-query-performance-from-a-large-hdfstore-table-with-pandas/22820780#22820780">Hierarchical queries on a HDFStore</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/20497897/converting-dict-of-dicts-into-pandas-dataframe-memory-issues">Counting with a HDFStore</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15488809/how-to-trouble-shoot-hdfstore-exception-cannot-find-the-correct-atom-type">Troubleshoot HDFStore exceptions</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/15988871/hdfstore-appendstring-dataframe-fails-when-string-column-contents-are-longer">Setting min_itemsize with strings</a></p> <p><a class="reference external" href="https://stackoverflow.com/questions/17893370/ptrepack-sortby-needs-full-index">Using ptrepack to create a completely-sorted-index on a store</a></p> <p>Storing Attributes to a group node</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [206]: df = pd.DataFrame(np.random.randn(8, 3))

In [207]: store = pd.HDFStore("test.h5")

In [208]: store.put("df", df)

# you can store an arbitrary Python object via pickle
In [209]: store.get_storer("df").attrs.my_attribute = {"A": 10}

In [210]: store.get_storer("df").attrs.my_attribute
Out[210]: {'A': 10}
</pre></div> </div> <p>You can create or load a HDFStore in-memory by passing the <code class="docutils literal notranslate"><span class="pre">driver</span></code> parameter to PyTables. Changes are only written to disk when the HDFStore is closed.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [211]: store = pd.HDFStore("test.h5", "w", driver="H5FD_CORE")

In [212]: df = pd.DataFrame(np.random.randn(8, 3))

In [213]: store["test"] = df

# only after closing the store, data is written to disk:
In [214]: store.close()
</pre></div> </div> </section> <section id="binary-files"> <h3>Binary files</h3> <p>pandas readily accepts NumPy record arrays, if you need to read in a binary file consisting of an array of C structs. For example, given this C program in a file called <code class="docutils literal notranslate"><span class="pre">main.c</span></code> compiled with <code class="docutils literal notranslate"><span class="pre">gcc</span> <span class="pre">main.c</span> <span class="pre">-std=gnu99</span></code> on a 64-bit machine,</p> <div class="highlight-c notranslate">
<div class="highlight"><pre data-language="python">#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;

typedef struct _Data
{
    int32_t count;
    double avg;
    float scale;
} Data;

int main(int argc, const char *argv[])
{
    size_t n = 10;
    Data d[n];

    for (int i = 0; i &lt; n; ++i)
    {
        d[i].count = i;
        d[i].avg = i + 1.0;
        d[i].scale = (float) i + 2.0f;
    }

    FILE *file = fopen("binary.dat", "wb");
    fwrite(&amp;d, sizeof(Data), n, file);
    fclose(file);

    return 0;
}
</pre></div> </div> <p>the following Python code will read the binary file <code class="docutils literal notranslate"><span class="pre">'binary.dat'</span></code> into a pandas <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>, where each element of the struct corresponds to a column in the frame:</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">names = "count", "avg", "scale"

# note that the offsets are larger than the size of the type because of
# struct padding
offsets = 0, 8, 16
formats = "i4", "f8", "f4"
dt = np.dtype({"names": names, "offsets": offsets, "formats": formats}, align=True)
df = pd.DataFrame(np.fromfile("binary.dat", dt))
</pre></div> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The offsets of the structure elements may be different depending on the architecture of the machine on which the file was created. Using a raw binary file format like this for general data storage is not recommended, as it is not cross platform. We recommended either HDF5 or parquet, both of which are supported by pandas’ IO facilities.</p> </div> </section> </section> <section id="computation"> <h2>Computation</h2> <p><a class="reference external" href="https://nbviewer.ipython.org/gist/metakermit/5720498">Numerical integration (sample-based) of a time series</a></p> <section id="correlation"> <h3>Correlation</h3> <p>Often it’s useful to obtain the lower (or upper) triangular form of a correlation matrix calculated from <a class="reference internal" href="../reference/api/pandas.dataframe.corr.html#pandas.DataFrame.corr" title="pandas.DataFrame.corr"><code class="xref py py-func docutils literal notranslate"><span class="pre">DataFrame.corr()</span></code></a>. This can be achieved by passing a boolean mask to <code class="docutils literal notranslate"><span class="pre">where</span></code> as follows:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [215]: df = pd.DataFrame(np.random.random(size=(100, 5)))

In [216]: corr_mat = df.corr()

In [217]: mask = np.tril(np.ones_like(corr_mat, dtype=np.bool_), k=-1)

In [218]: corr_mat.where(mask)
Out[218]: 
          0         1         2        3   4
0       NaN       NaN       NaN      NaN NaN
1 -0.079861       NaN       NaN      NaN NaN
2 -0.236573  0.183801       NaN      NaN NaN
3 -0.013795 -0.051975  0.037235      NaN NaN
4 -0.031974  0.118342 -0.073499 -0.02063 NaN
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">method</span></code> argument within <code class="docutils literal notranslate"><span class="pre">DataFrame.corr</span></code> can accept a callable in addition to the named correlation types. Here we compute the <a class="reference external" href="https://en.wikipedia.org/wiki/Distance_correlation">distance correlation</a> matrix for a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [219]: def distcorr(x, y):
   .....:     n = len(x)
   .....:     a = np.zeros(shape=(n, n))
   .....:     b = np.zeros(shape=(n, n))
   .....:     for i in range(n):
   .....:         for j in range(i + 1, n):
   .....:             a[i, j] = abs(x[i] - x[j])
   .....:             b[i, j] = abs(y[i] - y[j])
   .....:     a += a.T
   .....:     b += b.T
   .....:     a_bar = np.vstack([np.nanmean(a, axis=0)] * n)
   .....:     b_bar = np.vstack([np.nanmean(b, axis=0)] * n)
   .....:     A = a - a_bar - a_bar.T + np.full(shape=(n, n), fill_value=a_bar.mean())
   .....:     B = b - b_bar - b_bar.T + np.full(shape=(n, n), fill_value=b_bar.mean())
   .....:     cov_ab = np.sqrt(np.nansum(A * B)) / n
   .....:     std_a = np.sqrt(np.sqrt(np.nansum(A ** 2)) / n)
   .....:     std_b = np.sqrt(np.sqrt(np.nansum(B ** 2)) / n)
   .....:     return cov_ab / std_a / std_b
   .....: 

In [220]: df = pd.DataFrame(np.random.normal(size=(100, 3)))

In [221]: df.corr(method=distcorr)
Out[221]: 
          0         1         2
0  1.000000  0.197613  0.216328
1  0.197613  1.000000  0.208749
2  0.216328  0.208749  1.000000
</pre></div> </div> </section> </section> <section id="timedeltas"> <h2>Timedeltas</h2> <p>The <a class="reference internal" href="timedeltas.html#timedeltas-timedeltas"><span class="std std-ref">Timedeltas</span></a> docs.</p> <p><a class="reference external" href="https://github.com/pandas-dev/pandas/pull/2899">Using timedeltas</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [222]: import datetime

In [223]: s = pd.Series(pd.date_range("2012-1-1", periods=3, freq="D"))

In [224]: s - s.max()
Out[224]: 
0   -2 days
1   -1 days
2    0 days
dtype: timedelta64[ns]

In [225]: s.max() - s
Out[225]: 
0   2 days
1   1 days
2   0 days
dtype: timedelta64[ns]

In [226]: s - datetime.datetime(2011, 1, 1, 3, 5)
Out[226]: 
0   364 days 20:55:00
1   365 days 20:55:00
2   366 days 20:55:00
dtype: timedelta64[ns]

In [227]: s + datetime.timedelta(minutes=5)
Out[227]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]

In [228]: datetime.datetime(2011, 1, 1, 3, 5) - s
Out[228]: 
0   -365 days +03:05:00
1   -366 days +03:05:00
2   -367 days +03:05:00
dtype: timedelta64[ns]

In [229]: datetime.timedelta(minutes=5) + s
Out[229]: 
0   2012-01-01 00:05:00
1   2012-01-02 00:05:00
2   2012-01-03 00:05:00
dtype: datetime64[ns]
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/16385785/add-days-to-dates-in-dataframe">Adding and subtracting deltas and dates</a></p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [230]: deltas = pd.Series([datetime.timedelta(days=i) for i in range(3)])

In [231]: df = pd.DataFrame({"A": s, "B": deltas})

In [232]: df
Out[232]: 
           A      B
0 2012-01-01 0 days
1 2012-01-02 1 days
2 2012-01-03 2 days

In [233]: df["New Dates"] = df["A"] + df["B"]

In [234]: df["Delta"] = df["A"] - df["New Dates"]

In [235]: df
Out[235]: 
           A      B  New Dates   Delta
0 2012-01-01 0 days 2012-01-01  0 days
1 2012-01-02 1 days 2012-01-03 -1 days
2 2012-01-03 2 days 2012-01-05 -2 days

In [236]: df.dtypes
Out[236]: 
A             datetime64[ns]
B            timedelta64[ns]
New Dates     datetime64[ns]
Delta        timedelta64[ns]
dtype: object
</pre></div> </div> <p><a class="reference external" href="https://stackoverflow.com/questions/15683588/iterating-through-a-pandas-dataframe">Another example</a></p> <p>Values can be set to NaT using np.nan, similar to datetime</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [237]: y = s - s.shift()

In [238]: y
Out[238]: 
0      NaT
1   1 days
2   1 days
dtype: timedelta64[ns]

In [239]: y[1] = np.nan

In [240]: y
Out[240]: 
0      NaT
1      NaT
2   1 days
dtype: timedelta64[ns]
</pre></div> </div> </section> <section id="creating-example-data"> <h2>Creating example data</h2> <p>To create a dataframe from every combination of some given values, like R’s <code class="docutils literal notranslate"><span class="pre">expand.grid()</span></code> function, we can create a dict where the keys are column names and the values are lists of the data values:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [241]: def expand_grid(data_dict):
   .....:     rows = itertools.product(*data_dict.values())
   .....:     return pd.DataFrame.from_records(rows, columns=data_dict.keys())
   .....: 

In [242]: df = expand_grid(
   .....:     {"height": [60, 70], "weight": [100, 140, 180], "sex": ["Male", "Female"]}
   .....: )
   .....: 

In [243]: df
Out[243]: 
    height  weight     sex
0       60     100    Male
1       60     100  Female
2       60     140    Male
3       60     140  Female
4       60     180    Male
5       60     180  Female
6       70     100    Male
7       70     100  Female
8       70     140    Male
9       70     140  Female
10      70     180    Male
11      70     180  Female
</pre></div> </div> </section> <section id="constant-series"> <h2>Constant series</h2> <p>To assess if a series has a constant value, we can check if <code class="docutils literal notranslate"><span class="pre">series.nunique()</span> <span class="pre">&lt;=</span> <span class="pre">1</span></code>. However, a more performant approach, that does not count all unique values first, is:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [244]: v = s.to_numpy()

In [245]: is_constant = v.shape[0] == 0 or (s[0] == s).all()
</pre></div> </div> <p>This approach assumes that the series does not contain missing values. For the case that we would drop NA values, we can simply remove those values first:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [246]: v = s.dropna().to_numpy()

In [247]: is_constant = v.shape[0] == 0 or (s[0] == s).all()
</pre></div> </div> <p>If missing values are considered distinct from any other value, then one could use:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [248]: v = s.to_numpy()

In [249]: is_constant = v.shape[0] == 0 or (s[0] == s).all() or not pd.notna(v).any()
</pre></div> </div> <p>(Note that this example does not disambiguate between <code class="docutils literal notranslate"><span class="pre">np.nan</span></code>, <code class="docutils literal notranslate"><span class="pre">pd.NA</span></code> and <code class="docutils literal notranslate"><span class="pre">None</span></code>)</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/cookbook.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/user_guide/cookbook.html</a>
  </p>
</div>
