<h1>Scaling to large datasets</h1> <p>pandas provides data structures for in-memory analytics, which makes using pandas to analyze datasets that are larger than memory datasets somewhat tricky. Even datasets that are a sizable fraction of memory become unwieldy, as some pandas operations need to make intermediate copies.</p> <p>This document provides a few recommendations for scaling your analysis to larger datasets. It’s a complement to <a class="reference internal" href="enhancingperf.html#enhancingperf"><span class="std std-ref">Enhancing performance</span></a>, which focuses on speeding up analysis for datasets that fit in memory.</p> <p>But first, it’s worth considering <em>not using pandas</em>. pandas isn’t the right tool for all situations. If you’re working with very large datasets and a tool like PostgreSQL fits your needs, then you should probably be using that. Assuming you want or need the expressiveness and power of pandas, let’s carry on.</p> <section id="load-less-data"> <h2>Load less data</h2> <p>Suppose our raw dataset on disk has many columns:</p> <div class="highlight-default notranslate">
<div class="highlight"><pre data-language="python">                     id_0    name_0       x_0       y_0  id_1   name_1       x_1  ...  name_8       x_8       y_8  id_9   name_9       x_9       y_9
timestamp                                                                         ...
2000-01-01 00:00:00  1015   Michael -0.399453  0.095427   994    Frank -0.176842  ...     Dan -0.315310  0.713892  1025   Victor -0.135779  0.346801
2000-01-01 00:01:00   969  Patricia  0.650773 -0.874275  1003    Laura  0.459153  ...  Ursula  0.913244 -0.630308  1047    Wendy -0.886285  0.035852
2000-01-01 00:02:00  1016    Victor -0.721465 -0.584710  1046  Michael  0.524994  ...     Ray -0.656593  0.692568  1064   Yvonne  0.070426  0.432047
2000-01-01 00:03:00   939     Alice -0.746004 -0.908008   996   Ingrid -0.414523  ...   Jerry -0.958994  0.608210   978    Wendy  0.855949 -0.648988
2000-01-01 00:04:00  1017       Dan  0.919451 -0.803504  1048    Jerry -0.569235  ...   Frank -0.577022 -0.409088   994      Bob -0.270132  0.335176
...                   ...       ...       ...       ...   ...      ...       ...  ...     ...       ...       ...   ...      ...       ...       ...
2000-12-30 23:56:00   999       Tim  0.162578  0.512817   973    Kevin -0.403352  ...     Tim -0.380415  0.008097  1041  Charlie  0.191477 -0.599519
2000-12-30 23:57:00   970     Laura -0.433586 -0.600289   958   Oliver -0.966577  ...   Zelda  0.971274  0.402032  1038   Ursula  0.574016 -0.930992
2000-12-30 23:58:00  1065     Edith  0.232211 -0.454540   971      Tim  0.158484  ...   Alice -0.222079 -0.919274  1022      Dan  0.031345 -0.657755
2000-12-30 23:59:00  1019    Ingrid  0.322208 -0.615974   981   Hannah  0.607517  ...   Sarah -0.424440 -0.117274   990   George -0.375530  0.563312
2000-12-31 00:00:00   937    Ursula -0.906523  0.943178  1018    Alice -0.564513  ...   Jerry  0.236837  0.807650   985   Oliver  0.777642  0.783392

[525601 rows x 40 columns]
</pre></div> </div> <p>That can be generated by the following code snippet:</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [1]: import pandas as pd

In [2]: import numpy as np

In [3]: def make_timeseries(start="2000-01-01", end="2000-12-31", freq="1D", seed=None):
   ...:     index = pd.date_range(start=start, end=end, freq=freq, name="timestamp")
   ...:     n = len(index)
   ...:     state = np.random.RandomState(seed)
   ...:     columns = {
   ...:         "name": state.choice(["Alice", "Bob", "Charlie"], size=n),
   ...:         "id": state.poisson(1000, size=n),
   ...:         "x": state.rand(n) * 2 - 1,
   ...:         "y": state.rand(n) * 2 - 1,
   ...:     }
   ...:     df = pd.DataFrame(columns, index=index, columns=sorted(columns))
   ...:     if df.index[-1] == end:
   ...:         df = df.iloc[:-1]
   ...:     return df
   ...: 

In [4]: timeseries = [
   ...:     make_timeseries(freq="1T", seed=i).rename(columns=lambda x: f"{x}_{i}")
   ...:     for i in range(10)
   ...: ]
   ...: 

In [5]: ts_wide = pd.concat(timeseries, axis=1)

In [6]: ts_wide.to_parquet("timeseries_wide.parquet")
</pre></div> </div> <p>To load the columns we want, we have two options. Option 1 loads in all the data and then filters to what we need.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [7]: columns = ["id_0", "name_0", "x_0", "y_0"]

In [8]: pd.read_parquet("timeseries_wide.parquet")[columns]
Out[8]: 
                     id_0 name_0       x_0       y_0
timestamp                                           
2000-01-01 00:00:00   977  Alice -0.821225  0.906222
2000-01-01 00:01:00  1018    Bob -0.219182  0.350855
2000-01-01 00:02:00   927  Alice  0.660908 -0.798511
2000-01-01 00:03:00   997    Bob -0.852458  0.735260
2000-01-01 00:04:00   965    Bob  0.717283  0.393391
...                   ...    ...       ...       ...
2000-12-30 23:56:00  1037    Bob -0.814321  0.612836
2000-12-30 23:57:00   980    Bob  0.232195 -0.618828
2000-12-30 23:58:00   965  Alice -0.231131  0.026310
2000-12-30 23:59:00   984  Alice  0.942819  0.853128
2000-12-31 00:00:00  1003  Alice  0.201125 -0.136655

[525601 rows x 4 columns]
</pre></div> </div> <p>Option 2 only loads the columns we request.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [9]: pd.read_parquet("timeseries_wide.parquet", columns=columns)
Out[9]: 
                     id_0 name_0       x_0       y_0
timestamp                                           
2000-01-01 00:00:00   977  Alice -0.821225  0.906222
2000-01-01 00:01:00  1018    Bob -0.219182  0.350855
2000-01-01 00:02:00   927  Alice  0.660908 -0.798511
2000-01-01 00:03:00   997    Bob -0.852458  0.735260
2000-01-01 00:04:00   965    Bob  0.717283  0.393391
...                   ...    ...       ...       ...
2000-12-30 23:56:00  1037    Bob -0.814321  0.612836
2000-12-30 23:57:00   980    Bob  0.232195 -0.618828
2000-12-30 23:58:00   965  Alice -0.231131  0.026310
2000-12-30 23:59:00   984  Alice  0.942819  0.853128
2000-12-31 00:00:00  1003  Alice  0.201125 -0.136655

[525601 rows x 4 columns]
</pre></div> </div> <p>If we were to measure the memory usage of the two calls, we’d see that specifying <code class="docutils literal notranslate"><span class="pre">columns</span></code> uses about 1/10th the memory in this case.</p> <p>With <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a>, you can specify <code class="docutils literal notranslate"><span class="pre">usecols</span></code> to limit the columns read into memory. Not all file formats that can be read by pandas provide an option to read a subset of columns.</p> </section> <section id="use-efficient-datatypes"> <h2>Use efficient datatypes</h2> <p>The default pandas data types are not the most memory efficient. This is especially true for text data columns with relatively few unique values (commonly referred to as “low-cardinality” data). By using more efficient data types, you can store larger datasets in memory.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [10]: ts = make_timeseries(freq="30S", seed=0)

In [11]: ts.to_parquet("timeseries.parquet")

In [12]: ts = pd.read_parquet("timeseries.parquet")

In [13]: ts
Out[13]: 
                       id     name         x         y
timestamp                                             
2000-01-01 00:00:00  1041    Alice  0.889987  0.281011
2000-01-01 00:00:30   988      Bob -0.455299  0.488153
2000-01-01 00:01:00  1018    Alice  0.096061  0.580473
2000-01-01 00:01:30   992      Bob  0.142482  0.041665
2000-01-01 00:02:00   960      Bob -0.036235  0.802159
...                   ...      ...       ...       ...
2000-12-30 23:58:00  1022    Alice  0.266191  0.875579
2000-12-30 23:58:30   974    Alice -0.009826  0.413686
2000-12-30 23:59:00  1028  Charlie  0.307108 -0.656789
2000-12-30 23:59:30  1002    Alice  0.202602  0.541335
2000-12-31 00:00:00   987    Alice  0.200832  0.615972

[1051201 rows x 4 columns]
</pre></div> </div> <p>Now, let’s inspect the data types and memory usage to see where we should focus our attention.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [14]: ts.dtypes
Out[14]: 
id        int64
name     object
x       float64
y       float64
dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [15]: ts.memory_usage(deep=True)  # memory usage in bytes
Out[15]: 
Index     8409608
id        8409608
name     65176434
x         8409608
y         8409608
dtype: int64
</pre></div> </div> <p>The <code class="docutils literal notranslate"><span class="pre">name</span></code> column is taking up much more memory than any other. It has just a few unique values, so it’s a good candidate for converting to a <a class="reference internal" href="../reference/api/pandas.categorical.html#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Categorical</span></code></a>. With a <a class="reference internal" href="../reference/api/pandas.categorical.html#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Categorical</span></code></a>, we store each unique name once and use space-efficient integers to know which specific name is used in each row.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [16]: ts2 = ts.copy()

In [17]: ts2["name"] = ts2["name"].astype("category")

In [18]: ts2.memory_usage(deep=True)
Out[18]: 
Index    8409608
id       8409608
name     1051495
x        8409608
y        8409608
dtype: int64
</pre></div> </div> <p>We can go a bit further and downcast the numeric columns to their smallest types using <a class="reference internal" href="../reference/api/pandas.to_numeric.html#pandas.to_numeric" title="pandas.to_numeric"><code class="xref py py-func docutils literal notranslate"><span class="pre">pandas.to_numeric()</span></code></a>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [19]: ts2["id"] = pd.to_numeric(ts2["id"], downcast="unsigned")

In [20]: ts2[["x", "y"]] = ts2[["x", "y"]].apply(pd.to_numeric, downcast="float")

In [21]: ts2.dtypes
Out[21]: 
id        uint16
name    category
x        float32
y        float32
dtype: object
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [22]: ts2.memory_usage(deep=True)
Out[22]: 
Index    8409608
id       2102402
name     1051495
x        4204804
y        4204804
dtype: int64
</pre></div> </div> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [23]: reduction = ts2.memory_usage(deep=True).sum() / ts.memory_usage(deep=True).sum()

In [24]: print(f"{reduction:0.2f}")
0.20
</pre></div> </div> <p>In all, we’ve reduced the in-memory footprint of this dataset to 1/5 of its original size.</p> <p>See <a class="reference internal" href="categorical.html#categorical"><span class="std std-ref">Categorical data</span></a> for more on <a class="reference internal" href="../reference/api/pandas.categorical.html#pandas.Categorical" title="pandas.Categorical"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Categorical</span></code></a> and <a class="reference internal" href="basics.html#basics-dtypes"><span class="std std-ref">dtypes</span></a> for an overview of all of pandas’ dtypes.</p> </section> <section id="use-chunking"> <h2>Use chunking</h2> <p>Some workloads can be achieved with chunking: splitting a large problem like “convert this directory of CSVs to parquet” into a bunch of small problems (“convert this individual CSV file into a Parquet file. Now repeat that for each file in this directory.”). As long as each chunk fits in memory, you can work with datasets that are much larger than memory.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Chunking works well when the operation you’re performing requires zero or minimal coordination between chunks. For more complicated workflows, you’re better off <a class="reference internal" href="#scale-other-libraries"><span class="std std-ref">using another library</span></a>.</p> </div> <p>Suppose we have an even larger “logical dataset” on disk that’s a directory of parquet files. Each file in the directory represents a different year of the entire dataset.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [25]: import pathlib

In [26]: N = 12

In [27]: starts = [f"20{i:&gt;02d}-01-01" for i in range(N)]

In [28]: ends = [f"20{i:&gt;02d}-12-13" for i in range(N)]

In [29]: pathlib.Path("data/timeseries").mkdir(exist_ok=True)

In [30]: for i, (start, end) in enumerate(zip(starts, ends)):
   ....:     ts = make_timeseries(start=start, end=end, freq="1T", seed=i)
   ....:     ts.to_parquet(f"data/timeseries/ts-{i:0&gt;2d}.parquet")
   ....: 
</pre></div> </div> <div class="highlight-default notranslate">
<div class="highlight"><pre data-language="python">data
└── timeseries
    ├── ts-00.parquet
    ├── ts-01.parquet
    ├── ts-02.parquet
    ├── ts-03.parquet
    ├── ts-04.parquet
    ├── ts-05.parquet
    ├── ts-06.parquet
    ├── ts-07.parquet
    ├── ts-08.parquet
    ├── ts-09.parquet
    ├── ts-10.parquet
    └── ts-11.parquet
</pre></div> </div> <p>Now we’ll implement an out-of-core <a class="reference internal" href="../reference/api/pandas.series.value_counts.html#pandas.Series.value_counts" title="pandas.Series.value_counts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.Series.value_counts()</span></code></a>. The peak memory usage of this workflow is the single largest chunk, plus a small series storing the unique value counts up to this point. As long as each individual file fits in memory, this will work for arbitrary-sized datasets.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [31]: %%time
   ....: files = pathlib.Path("data/timeseries/").glob("ts*.parquet")
   ....: counts = pd.Series(dtype=int)
   ....: for path in files:
   ....:     df = pd.read_parquet(path)
   ....:     counts = counts.add(df["name"].value_counts(), fill_value=0)
   ....: counts.astype(int)
   ....: 
CPU times: user 893 ms, sys: 91.5 ms, total: 984 ms
Wall time: 960 ms
Out[31]: 
Alice      1994645
Bob        1993692
Charlie    1994875
dtype: int64
</pre></div> </div> <p>Some readers, like <a class="reference internal" href="../reference/api/pandas.read_csv.html#pandas.read_csv" title="pandas.read_csv"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.read_csv()</span></code></a>, offer parameters to control the <code class="docutils literal notranslate"><span class="pre">chunksize</span></code> when reading a single file.</p> <p>Manually chunking is an OK option for workflows that don’t require too sophisticated of operations. Some operations, like <a class="reference internal" href="../reference/api/pandas.dataframe.groupby.html#pandas.DataFrame.groupby" title="pandas.DataFrame.groupby"><code class="xref py py-meth docutils literal notranslate"><span class="pre">pandas.DataFrame.groupby()</span></code></a>, are much harder to do chunkwise. In these cases, you may be better switching to a different library that implements these out-of-core algorithms for you.</p> </section> <section id="use-other-libraries"> <h2>Use other libraries</h2> <p>pandas is just one library offering a DataFrame API. Because of its popularity, pandas’ API has become something of a standard that other libraries implement. The pandas documentation maintains a list of libraries implementing a DataFrame API in <a class="reference internal" href="https://pandas.pydata.org/pandas-docs/version/1.5.0/ecosystem.html#ecosystem-out-of-core"><span class="std std-ref">our ecosystem page</span></a>.</p> <p>For example, <a class="reference external" href="https://dask.org">Dask</a>, a parallel computing library, has <a class="reference external" href="https://docs.dask.org/en/latest/dataframe.html">dask.dataframe</a>, a pandas-like API for working with larger than memory datasets in parallel. Dask can use multiple threads or processes on a single machine, or a cluster of machines to process data in parallel.</p> <p>We’ll import <code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code> and notice that the API feels similar to pandas. We can use Dask’s <code class="docutils literal notranslate"><span class="pre">read_parquet</span></code> function, but provide a globstring of files to read in.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [32]: import dask.dataframe as dd

In [33]: ddf = dd.read_parquet("data/timeseries/ts*.parquet", engine="pyarrow")

In [34]: ddf
Out[34]: 
Dask DataFrame Structure:
                   id    name        x        y
npartitions=12                                 
                int64  object  float64  float64
                  ...     ...      ...      ...
...               ...     ...      ...      ...
                  ...     ...      ...      ...
                  ...     ...      ...      ...
Dask Name: read-parquet, 1 graph layer
</pre></div> </div> <p>Inspecting the <code class="docutils literal notranslate"><span class="pre">ddf</span></code> object, we see a few things</p> <ul class="simple"> <li><p>There are familiar attributes like <code class="docutils literal notranslate"><span class="pre">.columns</span></code> and <code class="docutils literal notranslate"><span class="pre">.dtypes</span></code></p></li> <li><p>There are familiar methods like <code class="docutils literal notranslate"><span class="pre">.groupby</span></code>, <code class="docutils literal notranslate"><span class="pre">.sum</span></code>, etc.</p></li> <li><p>There are new attributes like <code class="docutils literal notranslate"><span class="pre">.npartitions</span></code> and <code class="docutils literal notranslate"><span class="pre">.divisions</span></code></p></li> </ul> <p>The partitions and divisions are how Dask parallelizes computation. A <strong>Dask</strong> DataFrame is made up of many pandas <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a>. A single method call on a Dask DataFrame ends up making many pandas method calls, and Dask knows how to coordinate everything to get the result.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [35]: ddf.columns
Out[35]: Index(['id', 'name', 'x', 'y'], dtype='object')

In [36]: ddf.dtypes
Out[36]: 
id        int64
name     object
x       float64
y       float64
dtype: object

In [37]: ddf.npartitions
Out[37]: 12
</pre></div> </div> <p>One major difference: the <code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code> API is <em>lazy</em>. If you look at the repr above, you’ll notice that the values aren’t actually printed out; just the column names and dtypes. That’s because Dask hasn’t actually read the data yet. Rather than executing immediately, doing operations build up a <strong>task graph</strong>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [38]: ddf
Out[38]: 
Dask DataFrame Structure:
                   id    name        x        y
npartitions=12                                 
                int64  object  float64  float64
                  ...     ...      ...      ...
...               ...     ...      ...      ...
                  ...     ...      ...      ...
                  ...     ...      ...      ...
Dask Name: read-parquet, 1 graph layer

In [39]: ddf["name"]
Out[39]: 
Dask Series Structure:
npartitions=12
    object
       ...
     ...  
       ...
       ...
Name: name, dtype: object
Dask Name: getitem, 2 graph layers

In [40]: ddf["name"].value_counts()
Out[40]: 
Dask Series Structure:
npartitions=1
    int64
      ...
Name: name, dtype: int64
Dask Name: value-counts-agg, 4 graph layers
</pre></div> </div> <p>Each of these calls is instant because the result isn’t being computed yet. We’re just building up a list of computation to do when someone needs the result. Dask knows that the return type of a <a class="reference internal" href="../reference/api/pandas.series.value_counts.html#pandas.Series.value_counts" title="pandas.Series.value_counts"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series.value_counts</span></code></a> is a pandas <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code></a> with a certain dtype and a certain name. So the Dask version returns a Dask Series with the same dtype and the same name.</p> <p>To get the actual result you can call <code class="docutils literal notranslate"><span class="pre">.compute()</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [41]: %time ddf["name"].value_counts().compute()
CPU times: user 914 ms, sys: 28.6 ms, total: 943 ms
Wall time: 931 ms
Out[41]: 
Charlie    1994875
Alice      1994645
Bob        1993692
Name: name, dtype: int64
</pre></div> </div> <p>At that point, you get back the same thing you’d get with pandas, in this case a concrete pandas <a class="reference internal" href="../reference/api/pandas.series.html#pandas.Series" title="pandas.Series"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.Series</span></code></a> with the count of each <code class="docutils literal notranslate"><span class="pre">name</span></code>.</p> <p>Calling <code class="docutils literal notranslate"><span class="pre">.compute</span></code> causes the full task graph to be executed. This includes reading the data, selecting the columns, and doing the <code class="docutils literal notranslate"><span class="pre">value_counts</span></code>. The execution is done <em>in parallel</em> where possible, and Dask tries to keep the overall memory footprint small. You can work with datasets that are much larger than memory, as long as each partition (a regular pandas <a class="reference internal" href="../reference/api/pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">pandas.DataFrame</span></code></a>) fits in memory.</p> <p>By default, <code class="docutils literal notranslate"><span class="pre">dask.dataframe</span></code> operations use a threadpool to do operations in parallel. We can also connect to a cluster to distribute the work on many machines. In this case we’ll connect to a local “cluster” made up of several processes on this single machine.</p> <div class="highlight-python notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; from dask.distributed import Client, LocalCluster

&gt;&gt;&gt; cluster = LocalCluster()
&gt;&gt;&gt; client = Client(cluster)
&gt;&gt;&gt; client
&lt;Client: 'tcp://127.0.0.1:53349' processes=4 threads=8, memory=17.18 GB&gt;
</pre></div> </div> <p>Once this <code class="docutils literal notranslate"><span class="pre">client</span></code> is created, all of Dask’s computation will take place on the cluster (which is just processes in this case).</p> <p>Dask implements the most used parts of the pandas API. For example, we can do a familiar groupby aggregation.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [42]: %time ddf.groupby("name")[["x", "y"]].mean().compute().head()
CPU times: user 2.04 s, sys: 119 ms, total: 2.16 s
Wall time: 1.99 s
Out[42]: 
                x         y
name                       
Alice   -0.000224 -0.000194
Bob     -0.000746  0.000349
Charlie  0.000604  0.000250
</pre></div> </div> <p>The grouping and aggregation is done out-of-core and in parallel.</p> <p>When Dask knows the <code class="docutils literal notranslate"><span class="pre">divisions</span></code> of a dataset, certain optimizations are possible. When reading parquet datasets written by dask, the divisions will be known automatically. In this case, since we created the parquet files manually, we need to supply the divisions manually.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [43]: N = 12

In [44]: starts = [f"20{i:&gt;02d}-01-01" for i in range(N)]

In [45]: ends = [f"20{i:&gt;02d}-12-13" for i in range(N)]

In [46]: divisions = tuple(pd.to_datetime(starts)) + (pd.Timestamp(ends[-1]),)

In [47]: ddf.divisions = divisions

In [48]: ddf
Out[48]: 
Dask DataFrame Structure:
                   id    name        x        y
npartitions=12                                 
2000-01-01      int64  object  float64  float64
2001-01-01        ...     ...      ...      ...
...               ...     ...      ...      ...
2011-01-01        ...     ...      ...      ...
2011-12-13        ...     ...      ...      ...
Dask Name: read-parquet, 1 graph layer
</pre></div> </div> <p>Now we can do things like fast random access with <code class="docutils literal notranslate"><span class="pre">.loc</span></code>.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [49]: ddf.loc["2002-01-01 12:01":"2002-01-01 12:05"].compute()
Out[49]: 
                       id     name         x         y
timestamp                                             
2002-01-01 12:01:00   971      Bob -0.659481  0.556184
2002-01-01 12:02:00  1015  Charlie  0.120131 -0.609522
2002-01-01 12:03:00   991      Bob -0.357816  0.811362
2002-01-01 12:04:00   984    Alice -0.608760  0.034187
2002-01-01 12:05:00   998  Charlie  0.551662 -0.461972
</pre></div> </div> <p>Dask knows to just look in the 3rd partition for selecting values in 2002. It doesn’t need to look at any other data.</p> <p>Many workflows involve a large amount of data and processing it in a way that reduces the size to something that fits in memory. In this case, we’ll resample to daily frequency and take the mean. Once we’ve taken the mean, we know the results will fit in memory, so we can safely call <code class="docutils literal notranslate"><span class="pre">compute</span></code> without running out of memory. At that point it’s just a regular pandas object.</p> <div class="highlight-ipython notranslate">
<div class="highlight"><pre data-language="python">In [50]: ddf[["x", "y"]].resample("1D").mean().cumsum().compute().plot()
Out[50]: &lt;AxesSubplot: xlabel='timestamp'&gt;
</pre></div> </div> <img alt="../_images/dask_resample.png" src="data:image/png;base64,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"> <p>These Dask examples have all be done using multiple processes on a single machine. Dask can be <a class="reference external" href="https://docs.dask.org/en/latest/setup.html">deployed on a cluster</a> to scale up to even larger datasets.</p> <p>You see more dask examples at <a class="reference external" href="https://examples.dask.org">https://examples.dask.org</a>.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/1.5.0/user_guide/scale.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/1.5.0/user_guide/scale.html</a>
  </p>
</div>
