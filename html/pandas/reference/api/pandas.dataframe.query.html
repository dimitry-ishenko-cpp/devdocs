<h1>pandas.DataFrame.query</h1> <dl class="py method"> <dt class="sig sig-object py" id="pandas.DataFrame.query"> <span class="sig-prename descclassname"><span class="pre">DataFrame.</span></span><span class="sig-name descname"><span class="pre">query</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">expr</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/pandas-dev/pandas/blob/v2.2.2/pandas/core/frame.py#L4680-L4836"><span class="viewcode-link"><span class="pre">[source]</span></span></a>
</dt> <dd>
<p>Query the columns of a DataFrame with a boolean expression.</p> <dl class="field-list"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<dl> <dt>
<strong>expr</strong><span class="classifier">:str</span>
</dt>
<dd>
<p>The query string to evaluate.</p> <p>You can refer to variables in the environment by prefixing them with an ‘@’ character like <code class="docutils literal notranslate"><span class="pre">@a</span> <span class="pre">+</span> <span class="pre">b</span></code>.</p> <p>You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named “Area (cm^2)” would be referenced as <code class="docutils literal notranslate"><span class="pre">`Area</span> <span class="pre">(cm^2)`</span></code>). Column names which are Python keywords (like “list”, “for”, “import”, etc) cannot be used.</p> <p>For example, if one of your columns is called <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">a</span></code> and you want to sum it with <code class="docutils literal notranslate"><span class="pre">b</span></code>, your query should be <code class="docutils literal notranslate"><span class="pre">`a</span> <span class="pre">a`</span> <span class="pre">+</span> <span class="pre">b</span></code>.</p> </dd> <dt>
<strong>inplace</strong><span class="classifier">:bool</span>
</dt>
<dd>
<p>Whether to modify the DataFrame rather than creating a new one.</p> </dd> <dt><strong>**kwargs</strong></dt>
<dd>
<p>See the documentation for <a class="reference internal" href="pandas.eval.html#pandas.eval" title="pandas.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> for complete details on the keyword arguments accepted by <a class="reference internal" href="#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.query()</span></code></a>.</p> </dd> </dl> </dd> <dt class="field-even">Returns<span class="colon">:</span>
</dt> <dd class="field-even">
<dl class="simple"> <dt>DataFrame or None</dt>
<dd>
<p>DataFrame resulting from the provided query expression or None if <code class="docutils literal notranslate"><span class="pre">inplace=True</span></code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="pandas.eval.html#pandas.eval" title="pandas.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eval</span></code></a></dt>
<dd>
<p>Evaluate a string describing operations on DataFrame columns.</p> </dd> <dt><a class="reference internal" href="pandas.dataframe.eval.html#pandas.DataFrame.eval" title="pandas.DataFrame.eval"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DataFrame.eval</span></code></a></dt>
<dd>
<p>Evaluate a string describing operations on DataFrame columns.</p> </dd> </dl> </div> <p class="rubric">Notes</p> <p>The result of the evaluation of this expression is first passed to <a class="reference internal" href="pandas.dataframe.loc.html#pandas.DataFrame.loc" title="pandas.DataFrame.loc"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataFrame.loc</span></code></a> and if that fails because of a multidimensional key (e.g., a DataFrame) then the result will be passed to <code class="xref py py-meth docutils literal notranslate"><span class="pre">DataFrame.__getitem__()</span></code>.</p> <p>This method uses the top-level <a class="reference internal" href="pandas.eval.html#pandas.eval" title="pandas.eval"><code class="xref py py-func docutils literal notranslate"><span class="pre">eval()</span></code></a> function to evaluate the passed query.</p> <p>The <a class="reference internal" href="#pandas.DataFrame.query" title="pandas.DataFrame.query"><code class="xref py py-meth docutils literal notranslate"><span class="pre">query()</span></code></a> method uses a slightly modified Python syntax by default. For example, the <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">|</span></code> (bitwise) operators have the precedence of their boolean cousins, <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#and" title="(in Python v3.12)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">and</span></code></a> and <a class="reference external" href="https://docs.python.org/3/reference/expressions.html#or" title="(in Python v3.12)"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">or</span></code></a>. This <em>is</em> syntactically valid Python, however the semantics are different.</p> <p>You can change the semantics of the expression by passing the keyword argument <code class="docutils literal notranslate"><span class="pre">parser='python'</span></code>. This enforces the same semantics as evaluation in Python space. Likewise, you can pass <code class="docutils literal notranslate"><span class="pre">engine='python'</span></code> to evaluate an expression using Python itself as a backend. This is not recommended as it is inefficient compared to using <code class="docutils literal notranslate"><span class="pre">numexpr</span></code> as the engine.</p> <p>The <a class="reference internal" href="pandas.dataframe.index.html#pandas.DataFrame.index" title="pandas.DataFrame.index"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataFrame.index</span></code></a> and <a class="reference internal" href="pandas.dataframe.columns.html#pandas.DataFrame.columns" title="pandas.DataFrame.columns"><code class="xref py py-attr docutils literal notranslate"><span class="pre">DataFrame.columns</span></code></a> attributes of the <a class="reference internal" href="pandas.dataframe.html#pandas.DataFrame" title="pandas.DataFrame"><code class="xref py py-class docutils literal notranslate"><span class="pre">DataFrame</span></code></a> instance are placed in the query namespace by default, which allows you to treat both the index and columns of the frame as a column in the frame. The identifier <code class="docutils literal notranslate"><span class="pre">index</span></code> is used for the frame index; you can also use the name of the index to identify it in a query. Please note that Python keywords may not be used as identifiers.</p> <p>For further details and examples see the <code class="docutils literal notranslate"><span class="pre">query</span></code> documentation in <a class="reference internal" href="../../user_guide/indexing.html#indexing-query"><span class="std std-ref">indexing</span></a>.</p> <p><em>Backtick quoted variables</em></p> <p>Backtick quoted variables are parsed as literal Python code and are converted internally to a Python valid identifier. This can lead to the following problems.</p> <p>During parsing a number of disallowed characters inside the backtick quoted string are replaced by strings that are allowed as a Python identifier. These characters include all operators in Python, the space character, the question mark, the exclamation mark, the dollar sign, and the euro sign. For other characters that fall outside the ASCII range (U+0001..U+007F) and those that are not further specified in PEP 3131, the query parser will raise an error. This excludes whitespace different than the space character, but also the hashtag (as it is used for comments) and the backtick itself (backtick can also not be escaped).</p> <p>In a special case, quotes that make a pair around a backtick can confuse the parser. For example, <code class="docutils literal notranslate"><span class="pre">`it's`</span> <span class="pre">&gt;</span> <span class="pre">`that's`</span></code> will raise an error, as it forms a quoted string (<code class="docutils literal notranslate"><span class="pre">'s</span> <span class="pre">&gt;</span> <span class="pre">`that'</span></code>) with a backtick inside.</p> <p>See also the Python documentation about lexical analysis (<a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html">https://docs.python.org/3/reference/lexical_analysis.html</a>) in combination with the source code in <code class="xref py py-mod docutils literal notranslate"><span class="pre">pandas.core.computation.parsing</span></code>.</p> <p class="rubric">Examples</p> <div class="doctest highlight-default notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df = pd.DataFrame({'A': range(1, 6),
...                    'B': range(10, 0, -2),
...                    'C C': range(10, 5, -1)})
&gt;&gt;&gt; df
   A   B  C C
0  1  10   10
1  2   8    9
2  3   6    8
3  4   4    7
4  5   2    6
&gt;&gt;&gt; df.query('A &gt; B')
   A  B  C C
4  5  2    6
</pre></div> </div> <p>The previous expression is equivalent to</p> <div class="doctest highlight-default notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df[df.A &gt; df.B]
   A  B  C C
4  5  2    6
</pre></div> </div> <p>For columns with spaces in their name, you can use backtick quoting.</p> <div class="doctest highlight-default notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df.query('B == `C C`')
   A   B  C C
0  1  10   10
</pre></div> </div> <p>The previous expression is equivalent to</p> <div class="doctest highlight-default notranslate">
<div class="highlight"><pre data-language="python">&gt;&gt;&gt; df[df.B == df['C C']]
   A   B  C C
0  1  10   10
</pre></div> </div> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2008&ndash;2022, AQR Capital Management, LLC, Lambda Foundry, Inc. and PyData Development Team<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://pandas.pydata.org/pandas-docs/version/2.2.2/reference/api/pandas.DataFrame.query.html" class="_attribution-link">https://pandas.pydata.org/pandas-docs/version/2.2.2/reference/api/pandas.DataFrame.query.html</a>
  </p>
</div>
