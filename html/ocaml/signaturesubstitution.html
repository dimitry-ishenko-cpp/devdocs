<h2 class="section" id="s:signature-substitution">
<a class="section-anchor" href="#s:signature-substitution" aria-hidden="true">﻿</a>12.7 Substituting inside a signature</h2> <ul> <li>
<a href="signaturesubstitution.html#ss%3Adestructive-substitution">12.7.1 Destructive substitutions</a> </li>
<li>
<a href="signaturesubstitution.html#ss%3Alocal-substitution">12.7.2 Local substitution declarations</a> </li>
<li>
<a href="signaturesubstitution.html#ss%3Amodule-type-substitution">12.7.3 Module type substitutions</a> </li>
</ul>  <h3 class="subsection" id="ss:destructive-substitution">
<a class="section-anchor" href="#ss:destructive-substitution" aria-hidden="true">﻿</a>12.7.1 Destructive substitutions</h3> <p>(Introduced in OCaml 3.12, generalized in 4.06)</p>
<div class="syntax"><table class="display dcenter">
<tr class="c009"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c008"><a class="syntax" href="modtypes.html#mod-constraint"><span class="nonterminal">mod-constraint</span></a></td>
<td class="c005">::=</td>
<td class="c007"> ... </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">type</span> [<a class="syntax" href="typedecl.html#type-params"><span class="nonterminal">type-params</span></a>] <a class="syntax" href="names.html#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">module</span> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="names.html#extended-module-path"><span class="nonterminal">extended-module-path</span></a> </td>
</tr> </table></td></tr> </table></div>
<p>A “destructive” substitution (<span class="syntax-token">with</span> ... <span class="syntax-token">:=</span> ...) behaves essentially like normal signature constraints (<span class="syntax-token">with</span> ... <span class="syntax-token">=</span> ...), but it additionally removes the redefined type or module from the signature.</p>
<p>Prior to OCaml 4.06, there were a number of restrictions: one could only remove types and modules at the outermost level (not inside submodules), and in the case of <span class="syntax-token">with type</span> the definition had to be another type constructor with the same type parameters.</p>
<p>A natural application of destructive substitution is merging two signatures sharing a type name. </p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">module type Printable = sig
  type t
  val print : Format.formatter -&gt; t -&gt; unit
end
module type Comparable = sig
  type t
  val compare : t -&gt; t -&gt; int
end
module type PrintableComparable = sig
  include Printable
  include Comparable with type t := t
end</pre>
</div> </div>
<p>One can also use this to completely remove a field: </p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">module type S = Comparable with type t := int

module type S = sig val compare : int -&gt; int -&gt; int end</pre> </div> </div>
<p> or to rename one: </p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">module type S = sig
  type u
  include Comparable with type t := u
end

module type S = sig type u val compare : u -&gt; u -&gt; int end</pre> </div> </div>
<p>Note that you can also remove manifest types, by substituting with the same type. </p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">module type ComparableInt = Comparable with type t = int ;;

module type ComparableInt = sig type t = int val compare : t -&gt; t -&gt; int end</pre> </div> <div class="ocaml"> <pre data-language="ocaml">module type CompareInt = ComparableInt with type t := int

module type CompareInt = sig val compare : int -&gt; int -&gt; int end</pre> </div> </div> <h3 class="subsection" id="ss:local-substitution">
<a class="section-anchor" href="#ss:local-substitution" aria-hidden="true">﻿</a>12.7.2 Local substitution declarations</h3> <p>(Introduced in OCaml 4.08)</p>
<div class="syntax"><table class="display dcenter">
<tr class="c009"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c008"><a class="syntax" href="modtypes.html#specification"><span class="nonterminal">specification</span></a></td>
<td class="c005">::=</td>
<td class="c007"> ... </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">type</span> <a class="syntax" href="#type-subst"><span class="nonterminal">type-subst</span></a> { <span class="syntax-token">and</span> <a class="syntax" href="#type-subst"><span class="nonterminal">type-subst</span></a> } </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">module</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="names.html#extended-module-path"><span class="nonterminal">extended-module-path</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="names.html#module-name"><span class="nonterminal">module-name</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a>
</td>
</tr> <tr><td class="c008"> </td></tr> <tr>
<td class="c008"><a class="syntax" id="type-subst"><span class="nonterminal">type-subst</span></a></td>
<td class="c005">::=</td>
<td class="c007"> [<a class="syntax" href="typedecl.html#type-params"><span class="nonterminal">type-params</span></a>] <a class="syntax" href="names.html#typeconstr-name"><span class="nonterminal">typeconstr-name</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> { <a class="syntax" href="typedecl.html#type-constraint"><span class="nonterminal">type-constraint</span></a> } </td>
</tr> </table></td></tr> </table></div>
<p>Local substitutions behave like destructive substitutions (<span class="syntax-token">with</span> ... <span class="syntax-token">:=</span> ...) but instead of being applied to a whole signature after the fact, they are introduced during the specification of the signature, and will apply to all the items that follow.</p>
<p>This provides a convenient way to introduce local names for types and modules when defining a signature:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">module type S = sig
  type t
  module Sub : sig
    type outer := t
    type t
    val to_outer : t -&gt; outer
  end
end

module type S =
  sig type t module Sub : sig type t val to_outer : t/1 -&gt; t/2 end end</pre> </div> </div>
<p>Note that, unlike type declarations, type substitution declarations are not recursive, so substitutions like the following are rejected:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># module type S = sig
    type 'a poly_list := [ `Cons of 'a * 'a poly_list | `Nil ]
  end ;;

Error: Unbound type constructor poly_list</pre> </div> </div> <h3 class="subsection" id="ss:module-type-substitution">
<a class="section-anchor" href="#ss:module-type-substitution" aria-hidden="true">﻿</a>12.7.3 Module type substitutions</h3> <p>(Introduced in OCaml 4.13)</p>
<div class="syntax"><table class="display dcenter">
<tr class="c009"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c008"><a class="syntax" href="modtypes.html#mod-constraint"><span class="nonterminal">mod-constraint</span></a></td>
<td class="c005">::=</td>
<td class="c007"> ... </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="names.html#modtype-path"><span class="nonterminal">modtype-path</span></a> <span class="syntax-token">=</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">module</span> <span class="syntax-token">type</span> <a class="syntax" href="names.html#modtype-path"><span class="nonterminal">modtype-path</span></a> <span class="syntax-token">:=</span> <a class="syntax" href="modtypes.html#module-type"><span class="nonterminal">module-type</span></a> </td>
</tr> </table></td></tr> </table></div>
<p>Module type substitution essentially behaves like type substitutions. They are useful to refine an abstract module type in a signature into a concrete module type,</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># module type ENDO = sig
    module type T
    module F: T -&gt; T
  end
  module Endo(X: sig module type T end): ENDO with module type T = X.T =
  struct
      module type T = X.T
      module F(X:T) = X
   end;;

module type ENDO = sig module type T module F : T -&gt; T end
module Endo :
  functor (X : sig module type T end) -&gt;
    sig module type T = X.T module F : T -&gt; T end</pre> </div> </div>
<p>It is also possible to substitute a concrete module type with an equivalent module types.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">module type A = sig
  type x
  module type R = sig
    type a = A of x
    type b
  end
end
module type S = sig
  type a = A of int
  type b
end
module type B = A with type x = int and module type R = S</pre>
</div> </div>
<p> However, such substitutions are never necessary.</p>
<p>Destructive module type substitution removes the module type substitution from the signature </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># module type ENDO' = ENDO with module type T := ENDO;;

module type ENDO' = sig module F : ENDO -&gt; ENDO end</pre> </div> </div>
<p> If the right hand side of the substitution is not a path, then the destructive substitution is only valid if the left-hand side of the substitution is never used as the type of a first-class module in the original module type.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">module type T = sig module type S val x: (module S) end
module type Error = T with module type S := sig end

Error: This `with' constraint S := sig end makes a packed module ill-formed.</pre> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/signaturesubstitution.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/signaturesubstitution.html</a>
  </p>
</div>
