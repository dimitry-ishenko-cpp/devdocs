<h1>Module Oo</h1> <pre id="MODULEOo" data-type="module Oo [Module Oo]" data-language="ocaml">module Oo: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Operations on objects</p> </div> </div>  <pre id="VALcopy" data-type="val copy [Module Oo]" data-language="ocaml">val copy : (&lt; .. &gt; as 'a) -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Oo</span>.copyÂ o</code> returns a copy of object <code class="code">o</code>, that is a fresh object with the same methods and instance variables as <code class="code">o</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Alert unsynchronized_access.</b> Unsynchronized accesses to mutable objects are a programming error.</li> </ul> </div> <pre id="VALid" data-type="val id [Module Oo]" data-language="ocaml">val id : &lt; .. &gt; -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return an integer identifying this object, unique for the current execution of the program. The generic comparison and hashing functions are based on this integer. When an object is obtained by unmarshaling, the id is refreshed, and thus different from the original object. As a consequence, the internal invariants of data structures such as hash table or sets containing objects are broken after unmarshaling the data structures.</p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/Oo.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/Oo.html</a>
  </p>
</div>
