<h1>Module ArrayLabels</h1> <pre id="MODULEArrayLabels" data-type="module ArrayLabels [Module ArrayLabels]" data-language="ocaml">module ArrayLabels: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Array operations.</p> <p>The labeled version of this module can be used as described in the <a href="stdlabels.html"><code class="code"><span class="constructor">StdLabels</span></code></a> module.</p> </div> </div>  <pre id="TYPEt" data-type="type 'a t [Module ArrayLabels]" data-language="ocaml">type 'a t = 'a array </pre> <div class="info "> <div class="info-desc"> <p>An alias for the type of arrays.</p> </div> </div> <pre id="VALlength" data-type="val length [Module ArrayLabels]" data-language="ocaml">val length : 'a array -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the length (number of elements) of the given array.</p> </div> </div> <pre id="VALget" data-type="val get [Module ArrayLabels]" data-language="ocaml">val get : 'a array -&gt; int -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get a n</code> returns the element number <code class="code">n</code> of array <code class="code">a</code>. The first element has number 0. The last element has number <code class="code">length a - 1</code>. You can also write <code class="code">a.(n)</code> instead of <code class="code">get a n</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is outside the range 0 to <code class="code">(length a - 1)</code>.</li> </ul> </div> <pre id="VALset" data-type="val set [Module ArrayLabels]" data-language="ocaml">val set : 'a array -&gt; int -&gt; 'a -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set a n x</code> modifies array <code class="code">a</code> in place, replacing element number <code class="code">n</code> with <code class="code">x</code>. You can also write <code class="code">a.(n) &lt;- x</code> instead of <code class="code">set a n x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is outside the range 0 to <code class="code">length a - 1</code>.</li> </ul> </div> <pre id="VALmake" data-type="val make [Module ArrayLabels]" data-language="ocaml">val make : int -&gt; 'a -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make n x</code> returns a fresh array of length <code class="code">n</code>, initialized with <code class="code">x</code>. All the elements of this new array are initially physically equal to <code class="code">x</code> (in the sense of the <code class="code">==</code> predicate). Consequently, if <code class="code">x</code> is mutable, it is shared among all elements of the array, and modifying <code class="code">x</code> through one of the array entries will modify all other entries at the same time.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; <span class="constructor">Sys</span>.max_array_length</code>. If the value of <code class="code">x</code> is a floating-point number, then the maximum size is only <code class="code"><span class="constructor">Sys</span>.max_array_length / 2</code>.</li> </ul> </div> <pre id="VALcreate_float" data-type="val create_float [Module ArrayLabels]" data-language="ocaml">val create_float : int -&gt; float array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">create_float n</code> returns a fresh float array of length <code class="code">n</code>, with uninitialized data.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03</li> </ul> </div> <pre id="VALinit" data-type="val init [Module ArrayLabels]" data-language="ocaml">val init : int -&gt; f:(int -&gt; 'a) -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">init n ~f</code> returns a fresh array of length <code class="code">n</code>, with element number <code class="code">i</code> initialized to the result of <code class="code">f i</code>. In other terms, <code class="code">init n ~f</code> tabulates the results of <code class="code">f</code> applied to the integers <code class="code">0</code> to <code class="code">n-1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; <span class="constructor">Sys</span>.max_array_length</code>. If the return type of <code class="code">f</code> is <code class="code">float</code>, then the maximum size is only <code class="code"><span class="constructor">Sys</span>.max_array_length / 2</code>.</li> </ul> </div> <pre id="VALmake_matrix" data-type="val make_matrix [Module ArrayLabels]" data-language="ocaml">val make_matrix : dimx:int -&gt; dimy:int -&gt; 'a -&gt; 'a array array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make_matrix ~dimx ~dimy e</code> returns a two-dimensional array (an array of arrays) with first dimension <code class="code">dimx</code> and second dimension <code class="code">dimy</code>. All the elements of this new matrix are initially physically equal to <code class="code">e</code>. The element (<code class="code">x,y</code>) of a matrix <code class="code">m</code> is accessed with the notation <code class="code">m.(x).(y)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">dimx</code> or <code class="code">dimy</code> is negative or greater than <a href="sys.html#VALmax_array_length"><code class="code"><span class="constructor">Sys</span>.max_array_length</code></a>. If the value of <code class="code">e</code> is a floating-point number, then the maximum size is only <code class="code"><span class="constructor">Sys</span>.max_array_length / 2</code>.</li> </ul> </div> <pre id="VALappend" data-type="val append [Module ArrayLabels]" data-language="ocaml">val append : 'a array -&gt; 'a array -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">append v1 v2</code> returns a fresh array containing the concatenation of the arrays <code class="code">v1</code> and <code class="code">v2</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">length v1 + length v2 &gt; <span class="constructor">Sys</span>.max_array_length</code>.</li> </ul> </div> <pre id="VALconcat" data-type="val concat [Module ArrayLabels]" data-language="ocaml">val concat : 'a array list -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALappend"><code class="code"><span class="constructor">ArrayLabels</span>.append</code></a>, but concatenates a list of arrays.</p> </div> </div> <pre id="VALsub" data-type="val sub [Module ArrayLabels]" data-language="ocaml">val sub : 'a array -&gt; pos:int -&gt; len:int -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">sub a ~pos ~len</code> returns a fresh array of length <code class="code">len</code>, containing the elements number <code class="code">pos</code> to <code class="code">pos + len - 1</code> of array <code class="code">a</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">pos</code> and <code class="code">len</code> do not designate a valid subarray of <code class="code">a</code>; that is, if <code class="code">pos &lt; 0</code>, or <code class="code">len &lt; 0</code>, or <code class="code">pos + len &gt; length a</code>.</li> </ul> </div> <pre id="VALcopy" data-type="val copy [Module ArrayLabels]" data-language="ocaml">val copy : 'a array -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">copy a</code> returns a copy of <code class="code">a</code>, that is, a fresh array containing the same elements as <code class="code">a</code>.</p> </div> </div> <pre id="VALfill" data-type="val fill [Module ArrayLabels]" data-language="ocaml">val fill : 'a array -&gt; pos:int -&gt; len:int -&gt; 'a -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fill a ~pos ~len x</code> modifies the array <code class="code">a</code> in place, storing <code class="code">x</code> in elements number <code class="code">pos</code> to <code class="code">pos + len - 1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">pos</code> and <code class="code">len</code> do not designate a valid subarray of <code class="code">a</code>.</li> </ul> </div> <pre id="VALblit" data-type="val blit [Module ArrayLabels]" data-language="ocaml">val blit : src:'a array -&gt; src_pos:int -&gt; dst:'a array -&gt; dst_pos:int -&gt; len:int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">blit ~src ~src_pos ~dst ~dst_pos ~len</code> copies <code class="code">len</code> elements from array <code class="code">src</code>, starting at element number <code class="code">src_pos</code>, to array <code class="code">dst</code>, starting at element number <code class="code">dst_pos</code>. It works correctly even if <code class="code">src</code> and <code class="code">dst</code> are the same array, and the source and destination chunks overlap.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">src_pos</code> and <code class="code">len</code> do not designate a valid subarray of <code class="code">src</code>, or if <code class="code">dst_pos</code> and <code class="code">len</code> do not designate a valid subarray of <code class="code">dst</code>.</li> </ul> </div> <pre id="VALto_list" data-type="val to_list [Module ArrayLabels]" data-language="ocaml">val to_list : 'a array -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_list a</code> returns the list of all the elements of <code class="code">a</code>.</p> </div> </div> <pre id="VALof_list" data-type="val of_list [Module ArrayLabels]" data-language="ocaml">val of_list : 'a list -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_list l</code> returns a fresh array containing the elements of <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the length of <code class="code">l</code> is greater than <code class="code"><span class="constructor">Sys</span>.max_array_length</code>.</li> </ul> </div> <h2 id="1_Iterators">Iterators</h2> <pre id="VALiter" data-type="val iter [Module ArrayLabels]" data-language="ocaml">val iter : f:('a -&gt; unit) -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter ~f a</code> applies function <code class="code">f</code> in turn to all the elements of <code class="code">a</code>. It is equivalent to <code class="code">f a.(0); f a.(1); ...; f a.(length a - 1); ()</code>.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module ArrayLabels]" data-language="ocaml">val iteri : f:(int -&gt; 'a -&gt; unit) -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALiter"><code class="code"><span class="constructor">ArrayLabels</span>.iter</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p> </div> </div> <pre id="VALmap" data-type="val map [Module ArrayLabels]" data-language="ocaml">val map : f:('a -&gt; 'b) -&gt; 'a array -&gt; 'b array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map ~f a</code> applies function <code class="code">f</code> to all the elements of <code class="code">a</code>, and builds an array with the results returned by <code class="code">f</code>: <code class="code">[| f a.(0); f a.(1); ...; f a.(length a - 1) |]</code>.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module ArrayLabels]" data-language="ocaml">val mapi : f:(int -&gt; 'a -&gt; 'b) -&gt; 'a array -&gt; 'b array</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALmap"><code class="code"><span class="constructor">ArrayLabels</span>.map</code></a>, but the function is applied to the index of the element as first argument, and the element itself as second argument.</p> </div> </div> <pre id="VALfold_left" data-type="val fold_left [Module ArrayLabels]" data-language="ocaml">val fold_left : f:('a -&gt; 'b -&gt; 'a) -&gt; init:'a -&gt; 'b array -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left ~f ~init a</code> computes <code class="code">f (... (f (f init a.(0)) a.(1)) ...) a.(n-1)</code>, where <code class="code">n</code> is the length of the array <code class="code">a</code>.</p> </div> </div> <pre id="VALfold_left_map" data-type="val fold_left_map [Module ArrayLabels]" data-language="ocaml">val fold_left_map : f:('a -&gt; 'b -&gt; 'a * 'c) -&gt; init:'a -&gt; 'b array -&gt; 'a * 'c array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left_map</code> is a combination of <a href="arraylabels.html#VALfold_left"><code class="code"><span class="constructor">ArrayLabels</span>.fold_left</code></a> and <a href="arraylabels.html#VALmap"><code class="code"><span class="constructor">ArrayLabels</span>.map</code></a> that threads an accumulator through calls to <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13.0</li> </ul> </div> <pre id="VALfold_right" data-type="val fold_right [Module ArrayLabels]" data-language="ocaml">val fold_right : f:('b -&gt; 'a -&gt; 'a) -&gt; 'b array -&gt; init:'a -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_right ~f a ~init</code> computes <code class="code">f a.(0) (f a.(1) ( ... (f a.(n-1) init) ...))</code>, where <code class="code">n</code> is the length of the array <code class="code">a</code>.</p> </div> </div> <h2 id="1_Iteratorsontwoarrays">Iterators on two arrays</h2> <pre id="VALiter2" data-type="val iter2 [Module ArrayLabels]" data-language="ocaml">val iter2 : f:('a -&gt; 'b -&gt; unit) -&gt; 'a array -&gt; 'b array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter2 ~f a b</code> applies function <code class="code">f</code> to all the elements of <code class="code">a</code> and <code class="code">b</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the arrays are not the same size.</li> </ul> </div> <pre id="VALmap2" data-type="val map2 [Module ArrayLabels]" data-language="ocaml">val map2 : f:('a -&gt; 'b -&gt; 'c) -&gt; 'a array -&gt; 'b array -&gt; 'c array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map2 ~f a b</code> applies function <code class="code">f</code> to all the elements of <code class="code">a</code> and <code class="code">b</code>, and builds an array with the results returned by <code class="code">f</code>: <code class="code">[| f a.(0) b.(0); ...; f a.(length a - 1) b.(length b - 1)|]</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the arrays are not the same size.</li> </ul> </div> <h2 id="1_Arrayscanning">Array scanning</h2> <pre id="VALfor_all" data-type="val for_all [Module ArrayLabels]" data-language="ocaml">val for_all : f:('a -&gt; bool) -&gt; 'a array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all ~f [|a1; ...; an|]</code> checks if all elements of the array satisfy the predicate <code class="code">f</code>. That is, it returns <code class="code">(f a1) <span class="keywordsign">&amp;&amp;</span> (f a2) <span class="keywordsign">&amp;&amp;</span> ... <span class="keywordsign">&amp;&amp;</span> (f an)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALexists" data-type="val exists [Module ArrayLabels]" data-language="ocaml">val exists : f:('a -&gt; bool) -&gt; 'a array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists ~f [|a1; ...; an|]</code> checks if at least one element of the array satisfies the predicate <code class="code">f</code>. That is, it returns <code class="code">(f a1) <span class="keywordsign">||</span> (f a2) <span class="keywordsign">||</span> ... <span class="keywordsign">||</span> (f an)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALfor_all2" data-type="val for_all2 [Module ArrayLabels]" data-language="ocaml">val for_all2 : f:('a -&gt; 'b -&gt; bool) -&gt; 'a array -&gt; 'b array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALfor_all"><code class="code"><span class="constructor">ArrayLabels</span>.for_all</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two arrays have different lengths.</li> </ul> </div> <pre id="VALexists2" data-type="val exists2 [Module ArrayLabels]" data-language="ocaml">val exists2 : f:('a -&gt; 'b -&gt; bool) -&gt; 'a array -&gt; 'b array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALexists"><code class="code"><span class="constructor">ArrayLabels</span>.exists</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two arrays have different lengths.</li> </ul> </div> <pre id="VALmem" data-type="val mem [Module ArrayLabels]" data-language="ocaml">val mem : 'a -&gt; set:'a array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mem a ~set</code> is true if and only if <code class="code">a</code> is structurally equal to an element of <code class="code">l</code> (i.e. there is an <code class="code">x</code> in <code class="code">l</code> such that <code class="code">compare a x = 0</code>).</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALmemq" data-type="val memq [Module ArrayLabels]" data-language="ocaml">val memq : 'a -&gt; set:'a array -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALmem"><code class="code"><span class="constructor">ArrayLabels</span>.mem</code></a>, but uses physical equality instead of structural equality to compare list elements.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALfind_opt" data-type="val find_opt [Module ArrayLabels]" data-language="ocaml">val find_opt : f:('a -&gt; bool) -&gt; 'a array -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_opt ~f a</code> returns the first element of the array <code class="code">a</code> that satisfies the predicate <code class="code">f</code>, or <code class="code"><span class="constructor">None</span></code> if there is no value that satisfies <code class="code">f</code> in the array <code class="code">a</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13.0</li> </ul> </div> <pre id="VALfind_map" data-type="val find_map [Module ArrayLabels]" data-language="ocaml">val find_map : f:('a -&gt; 'b option) -&gt; 'a array -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_map ~f a</code> applies <code class="code">f</code> to the elements of <code class="code">a</code> in order, and returns the first result of the form <code class="code"><span class="constructor">Some</span> v</code>, or <code class="code"><span class="constructor">None</span></code> if none exist.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13.0</li> </ul> </div> <h2 id="1_Arraysofpairs">Arrays of pairs</h2> <pre id="VALsplit" data-type="val split [Module ArrayLabels]" data-language="ocaml">val split : ('a * 'b) array -&gt; 'a array * 'b array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">split [|(a1,b1); ...; (an,bn)|]</code> is <code class="code">([|a1; ...; an|], [|b1; ...; bn|])</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13.0</li> </ul> </div> <pre id="VALcombine" data-type="val combine [Module ArrayLabels]" data-language="ocaml">val combine : 'a array -&gt; 'b array -&gt; ('a * 'b) array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">combine [|a1; ...; an|] [|b1; ...; bn|]</code> is <code class="code">[|(a1,b1); ...; (an,bn)|]</code>. Raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the two arrays have different lengths.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13.0</li> </ul> </div> <h2 id="1_Sorting">Sorting</h2> <pre id="VALsort" data-type="val sort [Module ArrayLabels]" data-language="ocaml">val sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Sort an array in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see below for a complete specification). For example, <a href="stdlib.html#VALcompare"><code class="code">compare</code></a> is a suitable comparison function. After calling <code class="code">sort</code>, the array is sorted in place in increasing order. <code class="code">sort</code> is guaranteed to run in constant heap space and (at most) logarithmic stack space.</p> <p>The current implementation uses Heap Sort. It runs in constant stack space.</p> <p>Specification of the comparison function: Let <code class="code">a</code> be the array and <code class="code">cmp</code> the comparison function. The following must be true for all <code class="code">x</code>, <code class="code">y</code>, <code class="code">z</code> in <code class="code">a</code> :</p> <ul> <li> <code class="code">cmp x y</code> &gt; 0 if and only if <code class="code">cmp y x</code> &lt; 0</li> <li> if <code class="code">cmp x y</code> &gt;= 0 and <code class="code">cmp y z</code> &gt;= 0 then <code class="code">cmp x z</code> &gt;= 0</li> </ul> <p>When <code class="code">sort</code> returns, <code class="code">a</code> contains the same elements as before, reordered in such a way that for all i and j valid indices of <code class="code">a</code> :</p> <ul> <li> <code class="code">cmp a.(i) a.(j)</code> &gt;= 0 if and only if i &gt;= j</li> </ul> </div> </div> <pre id="VALstable_sort" data-type="val stable_sort [Module ArrayLabels]" data-language="ocaml">val stable_sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALsort"><code class="code"><span class="constructor">ArrayLabels</span>.sort</code></a>, but the sorting algorithm is stable (i.e. elements that compare equal are kept in their original order) and not guaranteed to run in constant heap space.</p> <p>The current implementation uses Merge Sort. It uses a temporary array of length <code class="code">n/2</code>, where <code class="code">n</code> is the length of the array. It is usually faster than the current implementation of <a href="arraylabels.html#VALsort"><code class="code"><span class="constructor">ArrayLabels</span>.sort</code></a>.</p> </div> </div> <pre id="VALfast_sort" data-type="val fast_sort [Module ArrayLabels]" data-language="ocaml">val fast_sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="arraylabels.html#VALsort"><code class="code"><span class="constructor">ArrayLabels</span>.sort</code></a> or <a href="arraylabels.html#VALstable_sort"><code class="code"><span class="constructor">ArrayLabels</span>.stable_sort</code></a>, whichever is faster on typical input.</p> </div> </div> <h2 id="1_ArraysandSequences">Arrays and Sequences</h2> <pre id="VALto_seq" data-type="val to_seq [Module ArrayLabels]" data-language="ocaml">val to_seq : 'a array -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the array, in increasing order. Modifications of the array during iteration will be reflected in the sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALto_seqi" data-type="val to_seqi [Module ArrayLabels]" data-language="ocaml">val to_seqi : 'a array -&gt; (int * 'a) Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the array, in increasing order, yielding indices along elements. Modifications of the array during iteration will be reflected in the sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALof_seq" data-type="val of_seq [Module ArrayLabels]" data-language="ocaml">val of_seq : 'a Seq.t -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p>Create an array from the generator</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <h2 id="array_concurrency">Arrays and concurrency safety</h2> <p>Care must be taken when concurrently accessing arrays from multiple domains: accessing an array will never crash a program, but unsynchronized accesses might yield surprising (non-sequentially-consistent) results.</p> <h3 id="array_atomicity">Atomicity</h3> <p>Every array operation that accesses more than one array element is not atomic. This includes iteration, scanning, sorting, splitting and combining arrays.</p> <p>For example, consider the following program:</p> <pre class="codepre" data-language="ocaml">let size = 100_000_000
let a = ArrayLabels.make size 1
let d1 = Domain.spawn (fun () -&gt;
   ArrayLabels.iteri ~f:(fun i x -&gt; a.(i) &lt;- x + 1) a
)
let d2 = Domain.spawn (fun () -&gt;
  ArrayLabels.iteri ~f:(fun i x -&gt; a.(i) &lt;- 2 * x + 1) a
)
let () = Domain.join d1; Domain.join d2
</pre> <p>After executing this code, each field of the array <code class="code">a</code> is either <code class="code">2</code>, <code class="code">3</code>, <code class="code">4</code> or <code class="code">5</code>. If atomicity is required, then the user must implement their own synchronization (for example, using <a href="mutex.html#TYPEt"><code class="code"><span class="constructor">Mutex</span>.t</code></a>).</p> <h3 id="array_data_race">Data races</h3> <p>If two domains only access disjoint parts of the array, then the observed behaviour is the equivalent to some sequential interleaving of the operations from the two domains.</p> <p>A data race is said to occur when two domains access the same array element without synchronization and at least one of the accesses is a write. In the absence of data races, the observed behaviour is equivalent to some sequential interleaving of the operations from different domains.</p> <p>Whenever possible, data races should be avoided by using synchronization to mediate the accesses to the array elements.</p> <p>Indeed, in the presence of data races, programs will not crash but the observed behaviour may not be equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the presence of data races, a read operation will return the value of some prior write to that location (with a few exceptions for float arrays).</p> <h3 id="array_data_race_exceptions">Float arrays</h3> <p>Float arrays have two supplementary caveats in the presence of data races.</p> <p>First, the blit operation might copy an array byte-by-byte. Data races between such a blit operation and another operation might produce surprising values due to tearing: partial writes interleaved with other operations can create float values that would not exist with a sequential execution.</p> <p>For instance, at the end of</p> <pre class="codepre" data-language="ocaml">let zeros = Array.make size 0.
let max_floats = Array.make size Float.max_float
let res = Array.copy zeros
let d1 = Domain.spawn (fun () -&gt; Array.blit zeros 0 res 0 size)
let d2 = Domain.spawn (fun () -&gt; Array.blit max_floats 0 res 0 size)
let () = Domain.join d1; Domain.join d2
</pre>
<p>the <code class="code">res</code> array might contain values that are neither <code class="code">0.</code> nor <code class="code">max_float</code>.</p> <p>Second, on 32-bit architectures, getting or setting a field involves two separate memory accesses. In the presence of data races, the user may observe tearing on any operation.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/ArrayLabels.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/ArrayLabels.html</a>
  </p>
</div>
