<h1>Module Bigarray</h1> <pre id="MODULEBigarray" data-type="module Bigarray [Module Bigarray]" data-language="ocaml">module Bigarray: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Large, multi-dimensional, numerical arrays.</p> <p>This module implements multi-dimensional arrays of integers and floating-point numbers, thereafter referred to as 'Bigarrays', to distinguish them from the standard OCaml arrays described in <a href="array.html"><code class="code"><span class="constructor">Array</span></code></a>.</p> <p>The implementation allows efficient sharing of large numerical arrays between OCaml code and C or Fortran numerical libraries.</p> <p>The main differences between 'Bigarrays' and standard OCaml arrays are as follows:</p> <ul> <li>Bigarrays are not limited in size, unlike OCaml arrays. (Normal float arrays are limited to 2,097,151 elements on a 32-bit platform, and normal arrays of other types to 4,194,303 elements.)</li> <li>Bigarrays are multi-dimensional. Any number of dimensions between 0 and 16 is supported. In contrast, OCaml arrays are mono-dimensional and require encoding multi-dimensional arrays as arrays of arrays.</li> <li>Bigarrays can only contain integers and floating-point numbers, while OCaml arrays can contain arbitrary OCaml data types.</li> <li>Bigarrays provide more space-efficient storage of integer and floating-point elements than normal OCaml arrays, in particular because they support 'small' types such as single-precision floats and 8 and 16-bit integers, in addition to the standard OCaml types of double-precision floats and 32 and 64-bit integers.</li> <li>The memory layout of Bigarrays is entirely compatible with that of arrays in C and Fortran, allowing large arrays to be passed back and forth between OCaml code and C / Fortran code with no data copying at all.</li> <li>Bigarrays support interesting high-level operations that normal arrays do not provide efficiently, such as extracting sub-arrays and 'slicing' a multi-dimensional array along certain dimensions, all without any copying.</li> </ul> <p>Users of this module are encouraged to do <code class="code"><span class="keyword">open</span>Â <span class="constructor">Bigarray</span></code> in their source, then refer to array types and operations via short dot notation, e.g. <code class="code"><span class="constructor">Array1</span>.t</code> or <code class="code"><span class="constructor">Array2</span>.sub</code>.</p> <p>Bigarrays support all the OCaml ad-hoc polymorphic operations:</p> <ul> <li>comparisons (<code class="code">=</code>, <code class="code">&lt;&gt;</code>, <code class="code">&lt;=</code>, etc, as well as <a href="stdlib.html#VALcompare"><code class="code">compare</code></a>);</li> <li>hashing (module <code class="code"><span class="constructor">Hash</span></code>);</li> <li>and structured input-output (the functions from the <a href="marshal.html"><code class="code"><span class="constructor">Marshal</span></code></a> module, as well as <a href="stdlib.html#VALoutput_value"><code class="code">output_value</code></a> and <a href="stdlib.html#VALinput_value"><code class="code">input_value</code></a>).</li> </ul> </div> </div>  <h2 id="1_Elementkinds">Element kinds</h2>
<p>Bigarrays can contain elements of the following kinds:</p> <ul> <li>IEEE single precision (32 bits) floating-point numbers (<a href="bigarray.html#TYPEfloat32_elt"><code class="code"><span class="constructor">Bigarray</span>.float32_elt</code></a>),</li> <li>IEEE double precision (64 bits) floating-point numbers (<a href="bigarray.html#TYPEfloat64_elt"><code class="code"><span class="constructor">Bigarray</span>.float64_elt</code></a>),</li> <li>IEEE single precision (2 * 32 bits) floating-point complex numbers (<a href="bigarray.html#TYPEcomplex32_elt"><code class="code"><span class="constructor">Bigarray</span>.complex32_elt</code></a>),</li> <li>IEEE double precision (2 * 64 bits) floating-point complex numbers (<a href="bigarray.html#TYPEcomplex64_elt"><code class="code"><span class="constructor">Bigarray</span>.complex64_elt</code></a>),</li> <li>8-bit integers (signed or unsigned) (<a href="bigarray.html#TYPEint8_signed_elt"><code class="code"><span class="constructor">Bigarray</span>.int8_signed_elt</code></a> or <a href="bigarray.html#TYPEint8_unsigned_elt"><code class="code"><span class="constructor">Bigarray</span>.int8_unsigned_elt</code></a>),</li> <li>16-bit integers (signed or unsigned) (<a href="bigarray.html#TYPEint16_signed_elt"><code class="code"><span class="constructor">Bigarray</span>.int16_signed_elt</code></a> or <a href="bigarray.html#TYPEint16_unsigned_elt"><code class="code"><span class="constructor">Bigarray</span>.int16_unsigned_elt</code></a>),</li> <li>OCaml integers (signed, 31 bits on 32-bit architectures, 63 bits on 64-bit architectures) (<a href="bigarray.html#TYPEint_elt"><code class="code"><span class="constructor">Bigarray</span>.int_elt</code></a>),</li> <li>32-bit signed integers (<a href="bigarray.html#TYPEint32_elt"><code class="code"><span class="constructor">Bigarray</span>.int32_elt</code></a>),</li> <li>64-bit signed integers (<a href="bigarray.html#TYPEint64_elt"><code class="code"><span class="constructor">Bigarray</span>.int64_elt</code></a>),</li> <li>platform-native signed integers (32 bits on 32-bit architectures, 64 bits on 64-bit architectures) (<a href="bigarray.html#TYPEnativeint_elt"><code class="code"><span class="constructor">Bigarray</span>.nativeint_elt</code></a>).</li> </ul> <p>Each element kind is represented at the type level by one of the <code class="code">*_elt</code> types defined below (defined with a single constructor instead of abstract types for technical injectivity reasons).</p> <pre id="TYPEfloat32_elt" data-type="type float32_elt [Module Bigarray]" data-language="ocaml">type float32_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTfloat32_elt.Float32_elt"><span class="constructor">Float32_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEfloat64_elt" data-type="type float64_elt [Module Bigarray]" data-language="ocaml">type float64_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTfloat64_elt.Float64_elt"><span class="constructor">Float64_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint8_signed_elt" data-type="type int8_signed_elt [Module Bigarray]" data-language="ocaml">type int8_signed_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint8_signed_elt.Int8_signed_elt"><span class="constructor">Int8_signed_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint8_unsigned_elt" data-type="type int8_unsigned_elt [Module Bigarray]" data-language="ocaml">type int8_unsigned_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint8_unsigned_elt.Int8_unsigned_elt"><span class="constructor">Int8_unsigned_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint16_signed_elt" data-type="type int16_signed_elt [Module Bigarray]" data-language="ocaml">type int16_signed_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint16_signed_elt.Int16_signed_elt"><span class="constructor">Int16_signed_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint16_unsigned_elt" data-type="type int16_unsigned_elt [Module Bigarray]" data-language="ocaml">type int16_unsigned_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint16_unsigned_elt.Int16_unsigned_elt"><span class="constructor">Int16_unsigned_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint32_elt" data-type="type int32_elt [Module Bigarray]" data-language="ocaml">type int32_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint32_elt.Int32_elt"><span class="constructor">Int32_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint64_elt" data-type="type int64_elt [Module Bigarray]" data-language="ocaml">type int64_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint64_elt.Int64_elt"><span class="constructor">Int64_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEint_elt" data-type="type int_elt [Module Bigarray]" data-language="ocaml">type int_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTint_elt.Int_elt"><span class="constructor">Int_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEnativeint_elt" data-type="type nativeint_elt [Module Bigarray]" data-language="ocaml">type nativeint_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTnativeint_elt.Nativeint_elt"><span class="constructor">Nativeint_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEcomplex32_elt" data-type="type complex32_elt [Module Bigarray]" data-language="ocaml">type complex32_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTcomplex32_elt.Complex32_elt"><span class="constructor">Complex32_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEcomplex64_elt" data-type="type complex64_elt [Module Bigarray]" data-language="ocaml">type complex64_elt = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTcomplex64_elt.Complex64_elt"><span class="constructor">Complex64_elt</span></span></code>
</td> </tr>
</table> <pre id="TYPEkind" data-type="type ('a, 'b) kind [Module Bigarray]" data-language="ocaml">type ('a, 'b) kind = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Float32"><span class="constructor">Float32</span></span> <span class="keyword">:</span> <code class="type">(float, <a href="bigarray.html#TYPEfloat32_elt">float32_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Float64"><span class="constructor">Float64</span></span> <span class="keyword">:</span> <code class="type">(float, <a href="bigarray.html#TYPEfloat64_elt">float64_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int8_signed"><span class="constructor">Int8_signed</span></span> <span class="keyword">:</span> <code class="type">(int, <a href="bigarray.html#TYPEint8_signed_elt">int8_signed_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int8_unsigned"><span class="constructor">Int8_unsigned</span></span> <span class="keyword">:</span> <code class="type">(int, <a href="bigarray.html#TYPEint8_unsigned_elt">int8_unsigned_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int16_signed"><span class="constructor">Int16_signed</span></span> <span class="keyword">:</span> <code class="type">(int, <a href="bigarray.html#TYPEint16_signed_elt">int16_signed_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int16_unsigned"><span class="constructor">Int16_unsigned</span></span> <span class="keyword">:</span> <code class="type">(int, <a href="bigarray.html#TYPEint16_unsigned_elt">int16_unsigned_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int32"><span class="constructor">Int32</span></span> <span class="keyword">:</span> <code class="type">(int32, <a href="bigarray.html#TYPEint32_elt">int32_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int64"><span class="constructor">Int64</span></span> <span class="keyword">:</span> <code class="type">(int64, <a href="bigarray.html#TYPEint64_elt">int64_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Int"><span class="constructor">Int</span></span> <span class="keyword">:</span> <code class="type">(int, <a href="bigarray.html#TYPEint_elt">int_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Nativeint"><span class="constructor">Nativeint</span></span> <span class="keyword">:</span> <code class="type">(nativeint, <a href="bigarray.html#TYPEnativeint_elt">nativeint_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Complex32"><span class="constructor">Complex32</span></span> <span class="keyword">:</span> <code class="type">(<a href="complex.html#TYPEt">Complex.t</a>, <a href="bigarray.html#TYPEcomplex32_elt">complex32_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Complex64"><span class="constructor">Complex64</span></span> <span class="keyword">:</span> <code class="type">(<a href="complex.html#TYPEt">Complex.t</a>, <a href="bigarray.html#TYPEcomplex64_elt">complex64_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTkind.Char"><span class="constructor">Char</span></span> <span class="keyword">:</span> <code class="type">(char, <a href="bigarray.html#TYPEint8_unsigned_elt">int8_unsigned_elt</a>) <a href="bigarray.html#TYPEkind">kind</a></code></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>To each element kind is associated an OCaml type, which is the type of OCaml values that can be stored in the Bigarray or read back from it. This type is not necessarily the same as the type of the array elements proper: for instance, a Bigarray whose elements are of kind <code class="code">float32_elt</code> contains 32-bit single precision floats, but reading or writing one of its elements from OCaml uses the OCaml type <code class="code">float</code>, which is 64-bit double precision floats.</p> <p>The GADT type <code class="code">(<span class="keywordsign">'</span>a,Â <span class="keywordsign">'</span>b)Â kind</code> captures this association of an OCaml type <code class="code"><span class="keywordsign">'</span>a</code> for values read or written in the Bigarray, and of an element kind <code class="code"><span class="keywordsign">'</span>b</code> which represents the actual contents of the Bigarray. Its constructors list all possible associations of OCaml types with element kinds, and are re-exported below for backward-compatibility reasons.</p> <p>Using a generalized algebraic datatype (GADT) here allows writing well-typed polymorphic functions whose return type depend on the argument type, such as:</p> <pre class="codepre" data-language="ocaml">  let zero : type a b. (a, b) kind -&gt; a = function
    | Float32 -&gt; 0.0 | Complex32 -&gt; Complex.zero
    | Float64 -&gt; 0.0 | Complex64 -&gt; Complex.zero
    | Int8_signed -&gt; 0 | Int8_unsigned -&gt; 0
    | Int16_signed -&gt; 0 | Int16_unsigned -&gt; 0
    | Int32 -&gt; 0l | Int64 -&gt; 0L
    | Int -&gt; 0 | Nativeint -&gt; 0n
    | Char -&gt; '\000'
</pre>
</div> </div> <pre id="VALfloat32" data-type="val float32 [Module Bigarray]" data-language="ocaml">val float32 : (float, float32_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALfloat64" data-type="val float64 [Module Bigarray]" data-language="ocaml">val float64 : (float, float64_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALcomplex32" data-type="val complex32 [Module Bigarray]" data-language="ocaml">val complex32 : (Complex.t, complex32_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALcomplex64" data-type="val complex64 [Module Bigarray]" data-language="ocaml">val complex64 : (Complex.t, complex64_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint8_signed" data-type="val int8_signed [Module Bigarray]" data-language="ocaml">val int8_signed : (int, int8_signed_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint8_unsigned" data-type="val int8_unsigned [Module Bigarray]" data-language="ocaml">val int8_unsigned : (int, int8_unsigned_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint16_signed" data-type="val int16_signed [Module Bigarray]" data-language="ocaml">val int16_signed : (int, int16_signed_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint16_unsigned" data-type="val int16_unsigned [Module Bigarray]" data-language="ocaml">val int16_unsigned : (int, int16_unsigned_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint" data-type="val int [Module Bigarray]" data-language="ocaml">val int : (int, int_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint32" data-type="val int32 [Module Bigarray]" data-language="ocaml">val int32 : (int32, int32_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALint64" data-type="val int64 [Module Bigarray]" data-language="ocaml">val int64 : (int64, int64_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALnativeint" data-type="val nativeint [Module Bigarray]" data-language="ocaml">val nativeint : (nativeint, nativeint_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#VALchar"><code class="code"><span class="constructor">Bigarray</span>.char</code></a>.</p> </div> </div> <pre id="VALchar" data-type="val char [Module Bigarray]" data-language="ocaml">val char : (char, int8_unsigned_elt) kind</pre>
<div class="info "> <div class="info-desc"> <p>As shown by the types of the values above, Bigarrays of kind <code class="code">float32_elt</code> and <code class="code">float64_elt</code> are accessed using the OCaml type <code class="code">float</code>. Bigarrays of complex kinds <code class="code">complex32_elt</code>, <code class="code">complex64_elt</code> are accessed with the OCaml type <a href="complex.html#TYPEt"><code class="code"><span class="constructor">Complex</span>.t</code></a>. Bigarrays of integer kinds are accessed using the smallest OCaml integer type large enough to represent the array elements: <code class="code">int</code> for 8- and 16-bit integer Bigarrays, as well as OCaml-integer Bigarrays; <code class="code">int32</code> for 32-bit integer Bigarrays; <code class="code">int64</code> for 64-bit integer Bigarrays; and <code class="code">nativeint</code> for platform-native integer Bigarrays. Finally, Bigarrays of kind <code class="code">int8_unsigned_elt</code> can also be accessed as arrays of characters instead of arrays of small integers, by using the kind value <code class="code">char</code> instead of <code class="code">int8_unsigned</code>.</p> </div> </div> <pre id="VALkind_size_in_bytes" data-type="val kind_size_in_bytes [Module Bigarray]" data-language="ocaml">val kind_size_in_bytes : ('a, 'b) kind -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">kind_size_in_bytesÂ k</code> is the number of bytes used to store an element of type <code class="code">k</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <h2 id="1_Arraylayouts">Array layouts</h2> <pre id="TYPEc_layout" data-type="type c_layout [Module Bigarray]" data-language="ocaml">type c_layout = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTc_layout.C_layout_typ"><span class="constructor">C_layout_typ</span></span></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>See <a href="bigarray.html#TYPEfortran_layout"><code class="code"><span class="constructor">Bigarray</span>.fortran_layout</code></a>.</p> </div> </div> <pre id="TYPEfortran_layout" data-type="type fortran_layout [Module Bigarray]" data-language="ocaml">type fortran_layout = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTfortran_layout.Fortran_layout_typ"><span class="constructor">Fortran_layout_typ</span></span></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>To facilitate interoperability with existing C and Fortran code, this library supports two different memory layouts for Bigarrays, one compatible with the C conventions, the other compatible with the Fortran conventions.</p> <p>In the C-style layout, array indices start at 0, and multi-dimensional arrays are laid out in row-major format. That is, for a two-dimensional array, all elements of row 0 are contiguous in memory, followed by all elements of row 1, etc. In other terms, the array elements at <code class="code">(x,y)</code> and <code class="code">(x,Â y+1)</code> are adjacent in memory.</p> <p>In the Fortran-style layout, array indices start at 1, and multi-dimensional arrays are laid out in column-major format. That is, for a two-dimensional array, all elements of column 0 are contiguous in memory, followed by all elements of column 1, etc. In other terms, the array elements at <code class="code">(x,y)</code> and <code class="code">(x+1,Â y)</code> are adjacent in memory.</p> <p>Each layout style is identified at the type level by the phantom types <a href="bigarray.html#TYPEc_layout"><code class="code"><span class="constructor">Bigarray</span>.c_layout</code></a> and <a href="bigarray.html#TYPEfortran_layout"><code class="code"><span class="constructor">Bigarray</span>.fortran_layout</code></a> respectively.</p> </div> </div> <h3 id="2_Supportedlayouts">Supported layouts</h3> <p>The GADT type <code class="code"><span class="keywordsign">'</span>aÂ layout</code> represents one of the two supported memory layouts: C-style or Fortran-style. Its constructors are re-exported as values below for backward-compatibility reasons.</p> <pre id="TYPElayout" data-type="type 'a layout [Module Bigarray]" data-language="ocaml">type 'a layout = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTlayout.C_layout"><span class="constructor">C_layout</span></span> <span class="keyword">:</span> <code class="type"><a href="bigarray.html#TYPEc_layout">c_layout</a> <a href="bigarray.html#TYPElayout">layout</a></code></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTlayout.Fortran_layout"><span class="constructor">Fortran_layout</span></span> <span class="keyword">:</span> <code class="type"><a href="bigarray.html#TYPEfortran_layout">fortran_layout</a> <a href="bigarray.html#TYPElayout">layout</a></code></code>
</td> </tr>
</table> <pre id="VALc_layout" data-type="val c_layout [Module Bigarray]" data-language="ocaml">val c_layout : c_layout layout</pre> <pre id="VALfortran_layout" data-type="val fortran_layout [Module Bigarray]" data-language="ocaml">val fortran_layout : fortran_layout layout</pre>
<h2 id="1_Genericarraysofarbitrarilymanydimensions">Generic arrays (of arbitrarily many dimensions)</h2> <pre id="MODULEGenarray" data-type="module Genarray [Module Bigarray]" data-language="ocaml">module Genarray: sig .. end</pre>
<h2 id="1_Zerodimensionalarrays">Zero-dimensional arrays</h2> <pre id="MODULEArray0" data-type="module Array0 [Module Bigarray]" data-language="ocaml">module Array0: sig .. end</pre>
<div class="info"> <p>Zero-dimensional arrays.</p> </div> <h2 id="1_Onedimensionalarrays">One-dimensional arrays</h2> <pre id="MODULEArray1" data-type="module Array1 [Module Bigarray]" data-language="ocaml">module Array1: sig .. end</pre>
<div class="info"> <p>One-dimensional arrays.</p> </div> <h2 id="1_Twodimensionalarrays">Two-dimensional arrays</h2> <pre id="MODULEArray2" data-type="module Array2 [Module Bigarray]" data-language="ocaml">module Array2: sig .. end</pre>
<div class="info"> <p>Two-dimensional arrays.</p> </div> <h2 id="1_Threedimensionalarrays">Three-dimensional arrays</h2> <pre id="MODULEArray3" data-type="module Array3 [Module Bigarray]" data-language="ocaml">module Array3: sig .. end</pre>
<div class="info"> <p>Three-dimensional arrays.</p> </div> <h2 id="1_CoercionsbetweengenericBigarraysandfixeddimensionBigarrays">Coercions between generic Bigarrays and fixed-dimension Bigarrays</h2> <pre id="VALgenarray_of_array0" data-type="val genarray_of_array0 [Module Bigarray]" data-language="ocaml">val genarray_of_array0 : ('a, 'b, 'c) Array0.t -&gt; ('a, 'b, 'c) Genarray.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the generic Bigarray corresponding to the given zero-dimensional Bigarray.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALgenarray_of_array1" data-type="val genarray_of_array1 [Module Bigarray]" data-language="ocaml">val genarray_of_array1 : ('a, 'b, 'c) Array1.t -&gt; ('a, 'b, 'c) Genarray.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the generic Bigarray corresponding to the given one-dimensional Bigarray.</p> </div> </div> <pre id="VALgenarray_of_array2" data-type="val genarray_of_array2 [Module Bigarray]" data-language="ocaml">val genarray_of_array2 : ('a, 'b, 'c) Array2.t -&gt; ('a, 'b, 'c) Genarray.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the generic Bigarray corresponding to the given two-dimensional Bigarray.</p> </div> </div> <pre id="VALgenarray_of_array3" data-type="val genarray_of_array3 [Module Bigarray]" data-language="ocaml">val genarray_of_array3 : ('a, 'b, 'c) Array3.t -&gt; ('a, 'b, 'c) Genarray.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the generic Bigarray corresponding to the given three-dimensional Bigarray.</p> </div> </div> <pre id="VALarray0_of_genarray" data-type="val array0_of_genarray [Module Bigarray]" data-language="ocaml">val array0_of_genarray : ('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array0.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the zero-dimensional Bigarray corresponding to the given generic Bigarray.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the generic Bigarray does not have exactly zero dimension.</li> </ul> </div> <pre id="VALarray1_of_genarray" data-type="val array1_of_genarray [Module Bigarray]" data-language="ocaml">val array1_of_genarray : ('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array1.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the one-dimensional Bigarray corresponding to the given generic Bigarray.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the generic Bigarray does not have exactly one dimension.</li> </ul> </div> <pre id="VALarray2_of_genarray" data-type="val array2_of_genarray [Module Bigarray]" data-language="ocaml">val array2_of_genarray : ('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array2.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the two-dimensional Bigarray corresponding to the given generic Bigarray.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the generic Bigarray does not have exactly two dimensions.</li> </ul> </div> <pre id="VALarray3_of_genarray" data-type="val array3_of_genarray [Module Bigarray]" data-language="ocaml">val array3_of_genarray : ('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array3.t</pre>
<div class="info "> <div class="info-desc"> <p>Return the three-dimensional Bigarray corresponding to the given generic Bigarray.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the generic Bigarray does not have exactly three dimensions.</li> </ul> </div> <h2 id="1_ReshapingBigarrays">Re-shaping Bigarrays</h2> <pre id="VALreshape" data-type="val reshape [Module Bigarray]" data-language="ocaml">val reshape : ('a, 'b, 'c) Genarray.t -&gt;       int array -&gt; ('a, 'b, 'c) Genarray.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">reshapeÂ bÂ [|d1;...;dN|]</code> converts the Bigarray <code class="code">b</code> to a <code class="code"><span class="constructor">N</span></code>-dimensional array of dimensions <code class="code">d1</code>...<code class="code">dN</code>. The returned array and the original array <code class="code">b</code> share their data and have the same layout. For instance, assuming that <code class="code">b</code> is a one-dimensional array of dimension 12, <code class="code">reshapeÂ bÂ [|3;4|]</code> returns a two-dimensional array <code class="code">b'</code> of dimensions 3 and 4. If <code class="code">b</code> has C layout, the element <code class="code">(x,y)</code> of <code class="code">b'</code> corresponds to the element <code class="code">xÂ *Â 3Â +Â y</code> of <code class="code">b</code>. If <code class="code">b</code> has Fortran layout, the element <code class="code">(x,y)</code> of <code class="code">b'</code> corresponds to the element <code class="code">xÂ +Â (yÂ -Â 1)Â *Â 4</code> of <code class="code">b</code>. The returned Bigarray must have exactly the same number of elements as the original Bigarray <code class="code">b</code>. That is, the product of the dimensions of <code class="code">b</code> must be equal to <code class="code">i1Â *Â ...Â *Â iN</code>. Otherwise, <code class="code"><span class="constructor">Invalid_argument</span></code> is raised.</p> </div> </div> <pre id="VALreshape_0" data-type="val reshape_0 [Module Bigarray]" data-language="ocaml">val reshape_0 : ('a, 'b, 'c) Genarray.t -&gt; ('a, 'b, 'c) Array0.t</pre>
<div class="info "> <div class="info-desc"> <p>Specialized version of <a href="bigarray.html#VALreshape"><code class="code"><span class="constructor">Bigarray</span>.reshape</code></a> for reshaping to zero-dimensional arrays.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALreshape_1" data-type="val reshape_1 [Module Bigarray]" data-language="ocaml">val reshape_1 : ('a, 'b, 'c) Genarray.t -&gt; int -&gt; ('a, 'b, 'c) Array1.t</pre>
<div class="info "> <div class="info-desc"> <p>Specialized version of <a href="bigarray.html#VALreshape"><code class="code"><span class="constructor">Bigarray</span>.reshape</code></a> for reshaping to one-dimensional arrays.</p> </div> </div> <pre id="VALreshape_2" data-type="val reshape_2 [Module Bigarray]" data-language="ocaml">val reshape_2 : ('a, 'b, 'c) Genarray.t -&gt;       int -&gt; int -&gt; ('a, 'b, 'c) Array2.t</pre>
<div class="info "> <div class="info-desc"> <p>Specialized version of <a href="bigarray.html#VALreshape"><code class="code"><span class="constructor">Bigarray</span>.reshape</code></a> for reshaping to two-dimensional arrays.</p> </div> </div> <pre id="VALreshape_3" data-type="val reshape_3 [Module Bigarray]" data-language="ocaml">val reshape_3 : ('a, 'b, 'c) Genarray.t -&gt;       int -&gt; int -&gt; int -&gt; ('a, 'b, 'c) Array3.t</pre>
<div class="info "> <div class="info-desc"> <p>Specialized version of <a href="bigarray.html#VALreshape"><code class="code"><span class="constructor">Bigarray</span>.reshape</code></a> for reshaping to three-dimensional arrays.</p> </div> </div> <h2 id="bigarray_concurrency">Bigarrays and concurrency safety</h2> <p>Care must be taken when concurrently accessing bigarrays from multiple domains: accessing a bigarray will never crash a program, but unsynchronized accesses might yield surprising (non-sequentially-consistent) results.</p> <h3 id="bigarray_atomicity">Atomicity</h3> <p>Every bigarray operation that accesses more than one array element is not atomic. This includes slicing, bliting, and filling bigarrays.</p> <p>For example, consider the following program:</p> <pre class="codepre" data-language="ocaml">open Bigarray
let size = 100_000_000
let a = Array1.init Int C_layout size (fun _ -&gt; 1)
let update f a () =
  for i = 0 to size - 1 do a.{i} &lt;- f a.{i} done
let d1 = Domain.spawn (update (fun x -&gt; x + 1) a)
let d2 = Domain.spawn (update (fun x -&gt; 2 * x + 1) a)
let () = Domain.join d1; Domain.join d2
</pre> <p>After executing this code, each field of the bigarray <code class="code">a</code> is either <code class="code">2</code>, <code class="code">3</code>, <code class="code">4</code> or <code class="code">5</code>. If atomicity is required, then the user must implement their own synchronization (for example, using <a href="mutex.html#TYPEt"><code class="code"><span class="constructor">Mutex</span>.t</code></a>).</p> <h3 id="bigarray_data_race">Data races</h3> <p>If two domains only access disjoint parts of the bigarray, then the observed behaviour is the equivalent to some sequential interleaving of the operations from the two domains.</p> <p>A data race is said to occur when two domains access the same bigarray element without synchronization and at least one of the accesses is a write. In the absence of data races, the observed behaviour is equivalent to some sequential interleaving of the operations from different domains.</p> <p>Whenever possible, data races should be avoided by using synchronization to mediate the accesses to the bigarray elements.</p> <p>Indeed, in the presence of data races, programs will not crash but the observed behaviour may not be equivalent to any sequential interleaving of operations from different domains.</p> <h3 id="bigarrarray_data_race_tearing">Tearing</h3> <p>Bigarrays have a distinct caveat in the presence of data races: concurrent bigarray operations might produce surprising values due to tearing. More precisely, the interleaving of partial writes and reads might create values that would not exist with a sequential execution. For instance, at the end of</p> <pre class="codepre" data-language="ocaml">let res = Array1.init Complex64 c_layout size (fun _ -&gt; Complex.zero)
let d1 = Domain.spawn (fun () -&gt; Array1.fill res Complex.one)
let d2 = Domain.spawn (fun () -&gt; Array1.fill res Complex.i)
let () = Domain.join d1; Domain.join d2
</pre>
<p>the <code class="code">res</code> bigarray might contain values that are neither <code class="code"><span class="constructor">Complex</span>.i</code> nor <code class="code"><span class="constructor">Complex</span>.one</code> (for instance <code class="code">1Â +Â i</code>).</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/Bigarray.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/Bigarray.html</a>
  </p>
</div>
