<h1>Module Domain</h1> <pre id="MODULEDomain" data-type="module Domain [Module Domain]" data-language="ocaml">module Domain: sig .. end</pre>
<div class="info module top"> <ul class="info-attributes"> <li>
<b>Alert unstable.</b> The Domain interface may change in incompatible ways in the future.</li> </ul> </div>  <p>Domains.</p> <p>See 'Parallel programming' chapter in the manual.</p> <pre id="TYPEt" data-type="type 'a t [Module Domain]" data-language="ocaml">type 'a t </pre> <div class="info "> <div class="info-desc"> <p>A domain of type <code class="code"><span class="keywordsign">'</span>a t</code> runs independently, eventually producing a result of type 'a, or an exception</p> </div> </div> <pre id="VALspawn" data-type="val spawn [Module Domain]" data-language="ocaml">val spawn : (unit -&gt; 'a) -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">spawn f</code> creates a new domain that runs in parallel with the current domain.</p> </div> </div> <pre id="VALjoin" data-type="val join [Module Domain]" data-language="ocaml">val join : 'a t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">join d</code> blocks until domain <code class="code">d</code> runs to completion. If <code class="code">d</code> results in a value, then that is returned by <code class="code">join d</code>. If <code class="code">d</code> raises an uncaught exception, then that is re-raised by <code class="code">join d</code>.</p> </div> </div> <pre id="TYPEid" data-type="type id [Module Domain]" data-language="ocaml">type id = private int </pre> <div class="info "> <div class="info-desc"> <p>Domains have unique integer identifiers</p> </div> </div> <pre id="VALget_id" data-type="val get_id [Module Domain]" data-language="ocaml">val get_id : 'a t -&gt; id</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_id d</code> returns the identifier of the domain <code class="code">d</code></p> </div> </div> <pre id="VALself" data-type="val self [Module Domain]" data-language="ocaml">val self : unit -&gt; id</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">self ()</code> is the identifier of the currently running domain</p> </div> </div> <pre id="VALbefore_first_spawn" data-type="val before_first_spawn [Module Domain]" data-language="ocaml">val before_first_spawn : (unit -&gt; unit) -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">before_first_spawn f</code> registers <code class="code">f</code> to be called before the first domain is spawned by the program. The functions registered with <code class="code">before_first_spawn</code> are called on the main (initial) domain. The functions registered with <code class="code">before_first_spawn</code> are called in 'first in, first out' order: the oldest function added with <code class="code">before_first_spawn</code> is called first.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the program has already spawned a domain.</li> </ul> </div> <pre id="VALat_exit" data-type="val at_exit [Module Domain]" data-language="ocaml">val at_exit : (unit -&gt; unit) -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">at_exit f</code> registers <code class="code">f</code> to be called when the current domain exits. Note that <code class="code">at_exit</code> callbacks are domain-local and only apply to the calling domain. The registered functions are called in 'last in, first out' order: the function most recently added with <code class="code">at_exit</code> is called first. An example:</p> <pre class="codepre" data-language="ocaml">let temp_file_key = Domain.DLS.new_key (fun _ -&gt;
  let tmp = snd (Filename.open_temp_file "" "") in
  Domain.at_exit (fun () -&gt; close_out_noerr tmp);
  tmp)
    </pre> <p>The snippet above creates a key that when retrieved for the first time will open a temporary file and register an <code class="code">at_exit</code> callback to close it, thus guaranteeing the descriptor is not leaked in case the current domain exits.</p> </div> </div> <pre id="VALcpu_relax" data-type="val cpu_relax [Module Domain]" data-language="ocaml">val cpu_relax : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>If busy-waiting, calling cpu_relax () between iterations will improve performance on some CPU architectures</p> </div> </div> <pre id="VALis_main_domain" data-type="val is_main_domain [Module Domain]" data-language="ocaml">val is_main_domain : unit -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_main_domain ()</code> returns true if called from the initial domain.</p> </div> </div> <pre id="VALrecommended_domain_count" data-type="val recommended_domain_count [Module Domain]" data-language="ocaml">val recommended_domain_count : unit -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>The recommended maximum number of domains which should be running simultaneously (including domains already running).</p> <p>The value returned is at least <code class="code">1</code>.</p> </div> </div> <pre id="MODULEDLS" data-type="module DLS [Module Domain]" data-language="ocaml">module DLS: sig .. end</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/Domain.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/Domain.html</a>
  </p>
</div>
