<h1>Module Seq</h1> <pre id="MODULESeq" data-type="module Seq [Module Seq]" data-language="ocaml">module Seq: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Sequences.</p> <p>A sequence of type <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Seq</span>.t</code> can be thought of as a <b>delayed list</b>, that is, a list whose elements are computed only when they are demanded by a consumer. This allows sequences to be produced and transformed lazily (one element at a time) rather than eagerly (all elements at once). This also allows constructing conceptually infinite sequences.</p> <p>The type <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Seq</span>.t</code> is defined as a synonym for <code class="code">unit <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="constructor">Seq</span>.node</code>. This is a function type: therefore, it is opaque. The consumer can <b> query</b> a sequence in order to request the next element (if there is one), but cannot otherwise inspect the sequence in any way.</p> <p>Because it is opaque, the type <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Seq</span>.t</code> does <i>not</i> reveal whether a sequence is:</p> <ul> <li>
<b>persistent</b>, which means that the sequence can be used as many times as desired, producing the same elements every time, just like an immutable list; or</li> <li>
<b>ephemeral</b>, which means that the sequence is not persistent. Querying an ephemeral sequence might have an observable side effect, such as incrementing a mutable counter. As a common special case, an ephemeral sequence can be <b>affine</b>, which means that it must be queried at most once.</li> </ul> <p>It also does <i>not</i> reveal whether the elements of the sequence are:</p> <ul> <li>
<b>pre-computed and stored</b> in memory, which means that querying the sequence is cheap;</li> <li>
<b>computed when first demanded and then stored</b> in memory, which means that querying the sequence once can be expensive, but querying the same sequence again is cheap; or</li> <li>
<b>re-computed every time they are demanded</b>, which may or may not be cheap.</li> </ul> <p>It is up to the programmer to keep these distinctions in mind so as to understand the time and space requirements of sequences.</p> <p>For the sake of simplicity, most of the documentation that follows is written under the implicit assumption that the sequences at hand are persistent. We normally do not point out <i>when</i> or <i>how many times</i> each function is invoked, because that would be too verbose. For instance, in the description of <code class="code">map</code>, we write: "if <code class="code">xs</code> is the sequence <code class="code">x0; x1; ...</code> then <code class="code">map f xs</code> is the sequence <code class="code">f x0; f x1; ...</code>". If we wished to be more explicit, we could point out that the transformation takes place on demand: that is, the elements of <code class="code">map f xs</code> are computed only when they are demanded. In other words, the definition <code class="code"><span class="keyword">let</span> ys = map f xs</code> terminates immediately and does not invoke <code class="code">f</code>. The function call <code class="code">f x0</code> takes place only when the first element of <code class="code">ys</code> is demanded, via the function call <code class="code">ys()</code>. Furthermore, calling <code class="code">ys()</code> twice causes <code class="code">f x0</code> to be called twice as well. If one wishes for <code class="code">f</code> to be applied at most once to each element of <code class="code">xs</code>, even in scenarios where <code class="code">ys</code> is queried more than once, then one should use <code class="code"><span class="keyword">let</span> ys = memoize (map f xs)</code>.</p> <p>As a general rule, the functions that build sequences, such as <code class="code">map</code>, <code class="code">filter</code>, <code class="code">scan</code>, <code class="code">take</code>, etc., produce sequences whose elements are computed only on demand. The functions that eagerly consume sequences, such as <code class="code">is_empty</code>, <code class="code">find</code>, <code class="code">length</code>, <code class="code">iter</code>, <code class="code">fold_left</code>, etc., are the functions that force computation to take place.</p> <p>When possible, we recommend using sequences rather than dispensers (functions of type <code class="code">unit <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a option</code> that produce elements upon demand). Whereas sequences can be persistent or ephemeral, dispensers are always ephemeral, and are typically more difficult to work with than sequences. Two conversion functions, <a href="seq.html#VALto_dispenser"><code class="code"><span class="constructor">Seq</span>.to_dispenser</code></a> and <a href="seq.html#VALof_dispenser"><code class="code"><span class="constructor">Seq</span>.of_dispenser</code></a>, are provided.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div>  <pre id="TYPEt" data-type="type 'a t [Module Seq]" data-language="ocaml">type 'a t = unit -&gt; 'a node </pre> <div class="info "> <div class="info-desc"> <p>A sequence <code class="code">xs</code> of type <code class="code"><span class="keywordsign">'</span>a t</code> is a delayed list of elements of type <code class="code"><span class="keywordsign">'</span>a</code>. Such a sequence is queried by performing a function application <code class="code">xs()</code>. This function application returns a node, allowing the caller to determine whether the sequence is empty or nonempty, and in the latter case, to obtain its head and tail.</p> </div> </div> <pre id="TYPEnode" data-type="type 'a node [Module Seq]" data-language="ocaml">type 'a node = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTnode.Nil"><span class="constructor">Nil</span></span></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTnode.Cons"><span class="constructor">Cons</span></span> <span class="keyword">of</span> <code class="type">'a * 'a <a href="seq.html#TYPEt">t</a></code></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>A node is either <code class="code"><span class="constructor">Nil</span></code>, which means that the sequence is empty, or <code class="code"><span class="constructor">Cons</span> (x, xs)</code>, which means that <code class="code">x</code> is the first element of the sequence and that <code class="code">xs</code> is the remainder of the sequence.</p> </div> </div> <h2 id="1_Consumingsequences">Consuming sequences</h2>
<p>The functions in this section consume their argument, a sequence, either partially or completely:</p> <ul> <li>
<code class="code">is_empty</code> and <code class="code">uncons</code> consume the sequence down to depth 1. That is, they demand the first argument of the sequence, if there is one.</li> <li>
<code class="code">iter</code>, <code class="code">fold_left</code>, <code class="code">length</code>, etc., consume the sequence all the way to its end. They terminate only if the sequence is finite.</li> <li>
<code class="code">for_all</code>, <code class="code">exists</code>, <code class="code">find</code>, etc. consume the sequence down to a certain depth, which is a priori unpredictable.</li> </ul> <p>Similarly, among the functions that consume two sequences, one can distinguish two groups:</p> <ul> <li>
<code class="code">iter2</code> and <code class="code">fold_left2</code> consume both sequences all the way to the end, provided the sequences have the same length.</li> <li>
<code class="code">for_all2</code>, <code class="code">exists2</code>, <code class="code">equal</code>, <code class="code">compare</code> consume the sequences down to a certain depth, which is a priori unpredictable.</li> </ul> <p>The functions that consume two sequences can be applied to two sequences of distinct lengths: in that case, the excess elements in the longer sequence are ignored. (It may be the case that one excess element is demanded, even though this element is not used.)</p> <p>None of the functions in this section is lazy. These functions are consumers: they force some computation to take place.</p> <pre id="VALis_empty" data-type="val is_empty [Module Seq]" data-language="ocaml">val is_empty : 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_empty xs</code> determines whether the sequence <code class="code">xs</code> is empty.</p> <p>It is recommended that the sequence <code class="code">xs</code> be persistent. Indeed, <code class="code">is_empty xs</code> demands the head of the sequence <code class="code">xs</code>, so, if <code class="code">xs</code> is ephemeral, it may be the case that <code class="code">xs</code> cannot be used any more after this call has taken place.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALuncons" data-type="val uncons [Module Seq]" data-language="ocaml">val uncons : 'a t -&gt; ('a * 'a t) option</pre>
<div class="info "> <div class="info-desc"> <p>If <code class="code">xs</code> is empty, then <code class="code">uncons xs</code> is <code class="code"><span class="constructor">None</span></code>.</p> <p>If <code class="code">xs</code> is nonempty, then <code class="code">uncons xs</code> is <code class="code"><span class="constructor">Some</span> (x, ys)</code> where <code class="code">x</code> is the head of the sequence and <code class="code">ys</code> its tail.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALlength" data-type="val length [Module Seq]" data-language="ocaml">val length : 'a t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">length xs</code> is the length of the sequence <code class="code">xs</code>.</p> <p>The sequence <code class="code">xs</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALiter" data-type="val iter [Module Seq]" data-language="ocaml">val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter f xs</code> invokes <code class="code">f x</code> successively for every element <code class="code">x</code> of the sequence <code class="code">xs</code>, from left to right.</p> <p>It terminates only if the sequence <code class="code">xs</code> is finite.</p> </div> </div> <pre id="VALfold_left" data-type="val fold_left [Module Seq]" data-language="ocaml">val fold_left : ('a -&gt; 'b -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left f _ xs</code> invokes <code class="code">f _ x</code> successively for every element <code class="code">x</code> of the sequence <code class="code">xs</code>, from left to right.</p> <p>An accumulator of type <code class="code"><span class="keywordsign">'</span>a</code> is threaded through the calls to <code class="code">f</code>.</p> <p>It terminates only if the sequence <code class="code">xs</code> is finite.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module Seq]" data-language="ocaml">val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iteri f xs</code> invokes <code class="code">f i x</code> successively for every element <code class="code">x</code> located at index <code class="code">i</code> in the sequence <code class="code">xs</code>.</p> <p>It terminates only if the sequence <code class="code">xs</code> is finite.</p> <p><code class="code">iteri f xs</code> is equivalent to <code class="code">iter (<span class="keyword">fun</span> (i, x) <span class="keywordsign">-&gt;</span> f i x) (zip (ints 0) xs)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfold_lefti" data-type="val fold_lefti [Module Seq]" data-language="ocaml">val fold_lefti : ('b -&gt; int -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'a t -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_lefti f _ xs</code> invokes <code class="code">f _ i x</code> successively for every element <code class="code">x</code> located at index <code class="code">i</code> of the sequence <code class="code">xs</code>.</p> <p>An accumulator of type <code class="code"><span class="keywordsign">'</span>b</code> is threaded through the calls to <code class="code">f</code>.</p> <p>It terminates only if the sequence <code class="code">xs</code> is finite.</p> <p><code class="code">fold_lefti f accu xs</code> is equivalent to <code class="code">fold_left (<span class="keyword">fun</span> accu (i, x) <span class="keywordsign">-&gt;</span> f accu i x) accu (zip (ints 0) xs)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfor_all" data-type="val for_all [Module Seq]" data-language="ocaml">val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all p xs</code> determines whether all elements <code class="code">x</code> of the sequence <code class="code">xs</code> satisfy <code class="code">p x</code>.</p> <p>The sequence <code class="code">xs</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALexists" data-type="val exists [Module Seq]" data-language="ocaml">val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists xs p</code> determines whether at least one element <code class="code">x</code> of the sequence <code class="code">xs</code> satisfies <code class="code">p x</code>.</p> <p>The sequence <code class="code">xs</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfind" data-type="val find [Module Seq]" data-language="ocaml">val find : ('a -&gt; bool) -&gt; 'a t -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find p xs</code> returns <code class="code"><span class="constructor">Some</span> x</code>, where <code class="code">x</code> is the first element of the sequence <code class="code">xs</code> that satisfies <code class="code">p x</code>, if there is such an element.</p> <p>It returns <code class="code"><span class="constructor">None</span></code> if there is no such element.</p> <p>The sequence <code class="code">xs</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfind_map" data-type="val find_map [Module Seq]" data-language="ocaml">val find_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_map f xs</code> returns <code class="code"><span class="constructor">Some</span> y</code>, where <code class="code">x</code> is the first element of the sequence <code class="code">xs</code> such that <code class="code">f x = <span class="constructor">Some</span> _</code>, if there is such an element, and where <code class="code">y</code> is defined by <code class="code">f x = <span class="constructor">Some</span> y</code>.</p> <p>It returns <code class="code"><span class="constructor">None</span></code> if there is no such element.</p> <p>The sequence <code class="code">xs</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALiter2" data-type="val iter2 [Module Seq]" data-language="ocaml">val iter2 : ('a -&gt; 'b -&gt; unit) -&gt; 'a t -&gt; 'b t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter2 f xs ys</code> invokes <code class="code">f x y</code> successively for every pair <code class="code">(x, y)</code> of elements drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then iteration stops as soon as one sequence is exhausted; the excess elements in the other sequence are ignored.</p> <p>Iteration terminates only if at least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> is finite.</p> <p><code class="code">iter2 f xs ys</code> is equivalent to <code class="code">iter (<span class="keyword">fun</span> (x, y) <span class="keywordsign">-&gt;</span> f x y) (zip xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfold_left2" data-type="val fold_left2 [Module Seq]" data-language="ocaml">val fold_left2 : ('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; 'a -&gt; 'b t -&gt; 'c t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left2 f _ xs ys</code> invokes <code class="code">f _ x y</code> successively for every pair <code class="code">(x, y)</code> of elements drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>An accumulator of type <code class="code"><span class="keywordsign">'</span>a</code> is threaded through the calls to <code class="code">f</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then iteration stops as soon as one sequence is exhausted; the excess elements in the other sequence are ignored.</p> <p>Iteration terminates only if at least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> is finite.</p> <p><code class="code">fold_left2 f accu xs ys</code> is equivalent to <code class="code">fold_left (<span class="keyword">fun</span> accu (x, y) <span class="keywordsign">-&gt;</span> f accu x y) (zip xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfor_all2" data-type="val for_all2 [Module Seq]" data-language="ocaml">val for_all2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all2 p xs ys</code> determines whether all pairs <code class="code">(x, y)</code> of elements drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code> satisfy <code class="code">p x y</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then iteration stops as soon as one sequence is exhausted; the excess elements in the other sequence are ignored. In particular, if <code class="code">xs</code> or <code class="code">ys</code> is empty, then <code class="code">for_all2 p xs ys</code> is true. This is where <code class="code">for_all2</code> and <code class="code">equal</code> differ: <code class="code">equal eq xs ys</code> can be true only if <code class="code">xs</code> and <code class="code">ys</code> have the same length.</p> <p>At least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> must be finite.</p> <p><code class="code">for_all2 p xs ys</code> is equivalent to <code class="code">for_all (<span class="keyword">fun</span> b <span class="keywordsign">-&gt;</span> b) (map2 p xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALexists2" data-type="val exists2 [Module Seq]" data-language="ocaml">val exists2 : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists2 p xs ys</code> determines whether some pair <code class="code">(x, y)</code> of elements drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code> satisfies <code class="code">p x y</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then iteration must stop as soon as one sequence is exhausted; the excess elements in the other sequence are ignored.</p> <p>At least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> must be finite.</p> <p><code class="code">exists2 p xs ys</code> is equivalent to <code class="code">exists (<span class="keyword">fun</span> b <span class="keywordsign">-&gt;</span> b) (map2 p xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALequal" data-type="val equal [Module Seq]" data-language="ocaml">val equal : ('a -&gt; 'b -&gt; bool) -&gt; 'a t -&gt; 'b t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Provided the function <code class="code">eq</code> defines an equality on elements, <code class="code">equal eq xs ys</code> determines whether the sequences <code class="code">xs</code> and <code class="code">ys</code> are pointwise equal.</p> <p>At least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALcompare" data-type="val compare [Module Seq]" data-language="ocaml">val compare : ('a -&gt; 'b -&gt; int) -&gt; 'a t -&gt; 'b t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Provided the function <code class="code">cmp</code> defines a preorder on elements, <code class="code">compare cmp xs ys</code> compares the sequences <code class="code">xs</code> and <code class="code">ys</code> according to the lexicographic preorder.</p> <p>For more details on comparison functions, see <a href="array.html#VALsort"><code class="code"><span class="constructor">Array</span>.sort</code></a>.</p> <p>At least one of the sequences <code class="code">xs</code> and <code class="code">ys</code> must be finite.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Constructingsequences">Constructing sequences</h2>
<p>The functions in this section are lazy: that is, they return sequences whose elements are computed only when demanded.</p> <pre id="VALempty" data-type="val empty [Module Seq]" data-language="ocaml">val empty : 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">empty</code> is the empty sequence. It has no elements. Its length is 0.</p> </div> </div> <pre id="VALreturn" data-type="val return [Module Seq]" data-language="ocaml">val return : 'a -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">return x</code> is the sequence whose sole element is <code class="code">x</code>. Its length is 1.</p> </div> </div> <pre id="VALcons" data-type="val cons [Module Seq]" data-language="ocaml">val cons : 'a -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">cons x xs</code> is the sequence that begins with the element <code class="code">x</code>, followed with the sequence <code class="code">xs</code>.</p> <p>Writing <code class="code">cons (f()) xs</code> causes the function call <code class="code">f()</code> to take place immediately. For this call to be delayed until the sequence is queried, one must instead write <code class="code">(<span class="keyword">fun</span> () <span class="keywordsign">-&gt;</span> <span class="constructor">Cons</span>(f(), xs))</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALinit" data-type="val init [Module Seq]" data-language="ocaml">val init : int -&gt; (int -&gt; 'a) -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">init n f</code> is the sequence <code class="code">f 0; f 1; ...; f (n-1)</code>.</p> <p><code class="code">n</code> must be nonnegative.</p> <p>If desired, the infinite sequence <code class="code">f 0; f 1; ...</code> can be defined as <code class="code">map f (ints 0)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul> </div> <pre id="VALunfold" data-type="val unfold [Module Seq]" data-language="ocaml">val unfold : ('b -&gt; ('a * 'b) option) -&gt; 'b -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">unfold</code> constructs a sequence out of a step function and an initial state.</p> <p>If <code class="code">f u</code> is <code class="code"><span class="constructor">None</span></code> then <code class="code">unfold f u</code> is the empty sequence. If <code class="code">f u</code> is <code class="code"><span class="constructor">Some</span> (x, u')</code> then <code class="code">unfold f u</code> is the nonempty sequence <code class="code">cons x (unfold f u')</code>.</p> <p>For example, <code class="code">unfold (<span class="keyword">function</span> [] <span class="keywordsign">-&gt;</span> <span class="constructor">None</span> <span class="keywordsign">|</span> h :: t <span class="keywordsign">-&gt;</span> <span class="constructor">Some</span> (h, t)) l</code> is equivalent to <code class="code"><span class="constructor">List</span>.to_seq l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALrepeat" data-type="val repeat [Module Seq]" data-language="ocaml">val repeat : 'a -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">repeat x</code> is the infinite sequence where the element <code class="code">x</code> is repeated indefinitely.</p> <p><code class="code">repeat x</code> is equivalent to <code class="code">cycle (return x)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALforever" data-type="val forever [Module Seq]" data-language="ocaml">val forever : (unit -&gt; 'a) -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">forever f</code> is an infinite sequence where every element is produced (on demand) by the function call <code class="code">f()</code>.</p> <p>For instance, <code class="code">forever <span class="constructor">Random</span>.bool</code> is an infinite sequence of random bits.</p> <p><code class="code">forever f</code> is equivalent to <code class="code">map f (repeat ())</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALcycle" data-type="val cycle [Module Seq]" data-language="ocaml">val cycle : 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">cycle xs</code> is the infinite sequence that consists of an infinite number of repetitions of the sequence <code class="code">xs</code>.</p> <p>If <code class="code">xs</code> is an empty sequence, then <code class="code">cycle xs</code> is empty as well.</p> <p>Consuming (a prefix of) the sequence <code class="code">cycle xs</code> once can cause the sequence <code class="code">xs</code> to be consumed more than once. Therefore, <code class="code">xs</code> must be persistent.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALiterate" data-type="val iterate [Module Seq]" data-language="ocaml">val iterate : ('a -&gt; 'a) -&gt; 'a -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iterate f x</code> is the infinite sequence whose elements are <code class="code">x</code>, <code class="code">f x</code>, <code class="code">f (f x)</code>, and so on.</p> <p>In other words, it is the orbit of the function <code class="code">f</code>, starting at <code class="code">x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Transformingsequences">Transforming sequences</h2>
<p>The functions in this section are lazy: that is, they return sequences whose elements are computed only when demanded.</p> <pre id="VALmap" data-type="val map [Module Seq]" data-language="ocaml">val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map f xs</code> is the image of the sequence <code class="code">xs</code> through the transformation <code class="code">f</code>.</p> <p>If <code class="code">xs</code> is the sequence <code class="code">x0; x1; ...</code> then <code class="code">map f xs</code> is the sequence <code class="code">f x0; f x1; ...</code>.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module Seq]" data-language="ocaml">val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mapi</code> is analogous to <code class="code">map</code>, but applies the function <code class="code">f</code> to an index and an element.</p> <p><code class="code">mapi f xs</code> is equivalent to <code class="code">map2 f (ints 0) xs</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALfilter" data-type="val filter [Module Seq]" data-language="ocaml">val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter p xs</code> is the sequence of the elements <code class="code">x</code> of <code class="code">xs</code> that satisfy <code class="code">p x</code>.</p> <p>In other words, <code class="code">filter p xs</code> is the sequence <code class="code">xs</code>, deprived of the elements <code class="code">x</code> such that <code class="code">p x</code> is false.</p> </div> </div> <pre id="VALfilter_map" data-type="val filter_map [Module Seq]" data-language="ocaml">val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter_map f xs</code> is the sequence of the elements <code class="code">y</code> such that <code class="code">f x = <span class="constructor">Some</span> y</code>, where <code class="code">x</code> ranges over <code class="code">xs</code>.</p> <p><code class="code">filter_map f xs</code> is equivalent to <code class="code">map <span class="constructor">Option</span>.get (filter <span class="constructor">Option</span>.is_some (map f xs))</code>.</p> </div> </div> <pre id="VALscan" data-type="val scan [Module Seq]" data-language="ocaml">val scan : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p>If <code class="code">xs</code> is a sequence <code class="code">[x0; x1; x2; ...]</code>, then <code class="code">scan f a0 xs</code> is a sequence of accumulators <code class="code">[a0; a1; a2; ...]</code> where <code class="code">a1</code> is <code class="code">f a0 x0</code>, <code class="code">a2</code> is <code class="code">f a1 x1</code>, and so on.</p> <p>Thus, <code class="code">scan f a0 xs</code> is conceptually related to <code class="code">fold_left f a0 xs</code>. However, instead of performing an eager iteration and immediately returning the final accumulator, it returns a sequence of accumulators.</p> <p>For instance, <code class="code">scan (+) 0</code> transforms a sequence of integers into the sequence of its partial sums.</p> <p>If <code class="code">xs</code> has length <code class="code">n</code> then <code class="code">scan f a0 xs</code> has length <code class="code">n+1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALtake" data-type="val take [Module Seq]" data-language="ocaml">val take : int -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">take n xs</code> is the sequence of the first <code class="code">n</code> elements of <code class="code">xs</code>.</p> <p>If <code class="code">xs</code> has fewer than <code class="code">n</code> elements, then <code class="code">take n xs</code> is equivalent to <code class="code">xs</code>.</p> <p><code class="code">n</code> must be nonnegative.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul> </div> <pre id="VALdrop" data-type="val drop [Module Seq]" data-language="ocaml">val drop : int -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">drop n xs</code> is the sequence <code class="code">xs</code>, deprived of its first <code class="code">n</code> elements.</p> <p>If <code class="code">xs</code> has fewer than <code class="code">n</code> elements, then <code class="code">drop n xs</code> is empty.</p> <p><code class="code">n</code> must be nonnegative.</p> <p><code class="code">drop</code> is lazy: the first <code class="code">n+1</code> elements of the sequence <code class="code">xs</code> are demanded only when the first element of <code class="code">drop n xs</code> is demanded. For this reason, <code class="code">drop 1 xs</code> is <i>not</i> equivalent to <code class="code">tail xs</code>, which queries <code class="code">xs</code> immediately.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul> </div> <pre id="VALtake_while" data-type="val take_while [Module Seq]" data-language="ocaml">val take_while : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">take_while p xs</code> is the longest prefix of the sequence <code class="code">xs</code> where every element <code class="code">x</code> satisfies <code class="code">p x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALdrop_while" data-type="val drop_while [Module Seq]" data-language="ocaml">val drop_while : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">drop_while p xs</code> is the sequence <code class="code">xs</code>, deprived of the prefix <code class="code">take_while p xs</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALgroup" data-type="val group [Module Seq]" data-language="ocaml">val group : ('a -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t t</pre>
<div class="info "> <div class="info-desc"> <p>Provided the function <code class="code">eq</code> defines an equality on elements, <code class="code">group eq xs</code> is the sequence of the maximal runs of adjacent duplicate elements of the sequence <code class="code">xs</code>.</p> <p>Every element of <code class="code">group eq xs</code> is a nonempty sequence of equal elements.</p> <p>The concatenation <code class="code">concat (group eq xs)</code> is equal to <code class="code">xs</code>.</p> <p>Consuming <code class="code">group eq xs</code>, and consuming the sequences that it contains, can cause <code class="code">xs</code> to be consumed more than once. Therefore, <code class="code">xs</code> must be persistent.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALmemoize" data-type="val memoize [Module Seq]" data-language="ocaml">val memoize : 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>The sequence <code class="code">memoize xs</code> has the same elements as the sequence <code class="code">xs</code>.</p> <p>Regardless of whether <code class="code">xs</code> is ephemeral or persistent, <code class="code">memoize xs</code> is persistent: even if it is queried several times, <code class="code">xs</code> is queried at most once.</p> <p>The construction of the sequence <code class="code">memoize xs</code> internally relies on suspensions provided by the module <a href="lazy.html"><code class="code"><span class="constructor">Lazy</span></code></a>. These suspensions are <i>not</i> thread-safe. Therefore, the sequence <code class="code">memoize xs</code> must <i>not</i> be queried by multiple threads concurrently.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="EXCEPTIONForced_twice" data-type="exception Forced_twice [Module Seq]" data-language="ocaml">exception Forced_twice</pre> <div class="info "> <div class="info-desc"> <p>This exception is raised when a sequence returned by <a href="seq.html#VALonce"><code class="code"><span class="constructor">Seq</span>.once</code></a> (or a suffix of it) is queried more than once.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALonce" data-type="val once [Module Seq]" data-language="ocaml">val once : 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>The sequence <code class="code">once xs</code> has the same elements as the sequence <code class="code">xs</code>.</p> <p>Regardless of whether <code class="code">xs</code> is ephemeral or persistent, <code class="code">once xs</code> is an ephemeral sequence: it can be queried at most once. If it (or a suffix of it) is queried more than once, then the exception <code class="code"><span class="constructor">Forced_twice</span></code> is raised. This can be useful, while debugging or testing, to ensure that a sequence is consumed at most once.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> <li>
<b>Raises</b> <code>Forced_twice</code> if <code class="code">once xs</code>, or a suffix of it, is queried more than once.</li> </ul> </div> <pre id="VALtranspose" data-type="val transpose [Module Seq]" data-language="ocaml">val transpose : 'a t t -&gt; 'a t t</pre>
<div class="info "> <div class="info-desc"> <p>If <code class="code">xss</code> is a matrix (a sequence of rows), then <code class="code">transpose xss</code> is the sequence of the columns of the matrix <code class="code">xss</code>.</p> <p>The rows of the matrix <code class="code">xss</code> are not required to have the same length.</p> <p>The matrix <code class="code">xss</code> is not required to be finite (in either direction).</p> <p>The matrix <code class="code">xss</code> must be persistent.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Combiningsequences">Combining sequences</h2> <pre id="VALappend" data-type="val append [Module Seq]" data-language="ocaml">val append : 'a t -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">append xs ys</code> is the concatenation of the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>Its elements are the elements of <code class="code">xs</code>, followed by the elements of <code class="code">ys</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALconcat" data-type="val concat [Module Seq]" data-language="ocaml">val concat : 'a t t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>If <code class="code">xss</code> is a sequence of sequences, then <code class="code">concat xss</code> is its concatenation.</p> <p>If <code class="code">xss</code> is the sequence <code class="code">xs0; xs1; ...</code> then <code class="code">concat xss</code> is the sequence <code class="code">xs0 @ xs1 @ ...</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALflat_map" data-type="val flat_map [Module Seq]" data-language="ocaml">val flat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">flat_map f xs</code> is equivalent to <code class="code">concat (map f xs)</code>.</p> </div> </div> <pre id="VALconcat_map" data-type="val concat_map [Module Seq]" data-language="ocaml">val concat_map : ('a -&gt; 'b t) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">concat_map f xs</code> is equivalent to <code class="code">concat (map f xs)</code>.</p> <p><code class="code">concat_map</code> is an alias for <code class="code">flat_map</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALzip" data-type="val zip [Module Seq]" data-language="ocaml">val zip : 'a t -&gt; 'b t -&gt; ('a * 'b) t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">zip xs ys</code> is the sequence of pairs <code class="code">(x, y)</code> drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then the sequence ends as soon as one sequence is exhausted; the excess elements in the other sequence are ignored.</p> <p><code class="code">zip xs ys</code> is equivalent to <code class="code">map2 (<span class="keyword">fun</span> a b <span class="keywordsign">-&gt;</span> (a, b)) xs ys</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALmap2" data-type="val map2 [Module Seq]" data-language="ocaml">val map2 : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map2 f xs ys</code> is the sequence of the elements <code class="code">f x y</code>, where the pairs <code class="code">(x, y)</code> are drawn synchronously from the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> have different lengths, then the sequence ends as soon as one sequence is exhausted; the excess elements in the other sequence are ignored.</p> <p><code class="code">map2 f xs ys</code> is equivalent to <code class="code">map (<span class="keyword">fun</span> (x, y) <span class="keywordsign">-&gt;</span> f x y) (zip xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALinterleave" data-type="val interleave [Module Seq]" data-language="ocaml">val interleave : 'a t -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">interleave xs ys</code> is the sequence that begins with the first element of <code class="code">xs</code>, continues with the first element of <code class="code">ys</code>, and so on.</p> <p>When one of the sequences <code class="code">xs</code> and <code class="code">ys</code> is exhausted, <code class="code">interleave xs ys</code> continues with the rest of the other sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALsorted_merge" data-type="val sorted_merge [Module Seq]" data-language="ocaml">val sorted_merge : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>If the sequences <code class="code">xs</code> and <code class="code">ys</code> are sorted according to the total preorder <code class="code">cmp</code>, then <code class="code">sorted_merge cmp xs ys</code> is the sorted sequence obtained by merging the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>For more details on comparison functions, see <a href="array.html#VALsort"><code class="code"><span class="constructor">Array</span>.sort</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALproduct" data-type="val product [Module Seq]" data-language="ocaml">val product : 'a t -&gt; 'b t -&gt; ('a * 'b) t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">product xs ys</code> is the Cartesian product of the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>For every element <code class="code">x</code> of <code class="code">xs</code> and for every element <code class="code">y</code> of <code class="code">ys</code>, the pair <code class="code">(x, y)</code> appears once as an element of <code class="code">product xs ys</code>.</p> <p>The order in which the pairs appear is unspecified.</p> <p>The sequences <code class="code">xs</code> and <code class="code">ys</code> are not required to be finite.</p> <p>The sequences <code class="code">xs</code> and <code class="code">ys</code> must be persistent.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALmap_product" data-type="val map_product [Module Seq]" data-language="ocaml">val map_product : ('a -&gt; 'b -&gt; 'c) -&gt; 'a t -&gt; 'b t -&gt; 'c t</pre>
<div class="info "> <div class="info-desc"> <p>The sequence <code class="code">map_product f xs ys</code> is the image through <code class="code">f</code> of the Cartesian product of the sequences <code class="code">xs</code> and <code class="code">ys</code>.</p> <p>For every element <code class="code">x</code> of <code class="code">xs</code> and for every element <code class="code">y</code> of <code class="code">ys</code>, the element <code class="code">f x y</code> appears once as an element of <code class="code">map_product f xs ys</code>.</p> <p>The order in which these elements appear is unspecified.</p> <p>The sequences <code class="code">xs</code> and <code class="code">ys</code> are not required to be finite.</p> <p>The sequences <code class="code">xs</code> and <code class="code">ys</code> must be persistent.</p> <p><code class="code">map_product f xs ys</code> is equivalent to <code class="code">map (<span class="keyword">fun</span> (x, y) <span class="keywordsign">-&gt;</span> f x y) (product xs ys)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Splittingasequenceintotwosequences">Splitting a sequence into two sequences</h2> <pre id="VALunzip" data-type="val unzip [Module Seq]" data-language="ocaml">val unzip : ('a * 'b) t -&gt; 'a t * 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">unzip</code> transforms a sequence of pairs into a pair of sequences.</p> <p><code class="code">unzip xs</code> is equivalent to <code class="code">(map fst xs, map snd xs)</code>.</p> <p>Querying either of the sequences returned by <code class="code">unzip xs</code> causes <code class="code">xs</code> to be queried. Therefore, querying both of them causes <code class="code">xs</code> to be queried twice. Thus, <code class="code">xs</code> must be persistent and cheap. If that is not the case, use <code class="code">unzip (memoize xs)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALsplit" data-type="val split [Module Seq]" data-language="ocaml">val split : ('a * 'b) t -&gt; 'a t * 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">split</code> is an alias for <code class="code">unzip</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALpartition_map" data-type="val partition_map [Module Seq]" data-language="ocaml">val partition_map : ('a -&gt; ('b, 'c) Either.t) -&gt; 'a t -&gt; 'b t * 'c t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition_map f xs</code> returns a pair of sequences <code class="code">(ys, zs)</code>, where:</p> <ul> <li>
<code class="code">ys</code> is the sequence of the elements <code class="code">y</code> such that <code class="code">f x = <span class="constructor">Left</span> y</code>, where <code class="code">x</code> ranges over <code class="code">xs</code>;</li> </ul> <ul> <li>
<code class="code">zs</code> is the sequence of the elements <code class="code">z</code> such that <code class="code">f x = <span class="constructor">Right</span> z</code>, where <code class="code">x</code> ranges over <code class="code">xs</code>.</li> </ul> <p><code class="code">partition_map f xs</code> is equivalent to a pair of <code class="code">filter_map <span class="constructor">Either</span>.find_left (map f xs)</code> and <code class="code">filter_map <span class="constructor">Either</span>.find_right (map f xs)</code>.</p> <p>Querying either of the sequences returned by <code class="code">partition_map f xs</code> causes <code class="code">xs</code> to be queried. Therefore, querying both of them causes <code class="code">xs</code> to be queried twice. Thus, <code class="code">xs</code> must be persistent and cheap. If that is not the case, use <code class="code">partition_map f (memoize xs)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALpartition" data-type="val partition [Module Seq]" data-language="ocaml">val partition : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition p xs</code> returns a pair of the subsequence of the elements of <code class="code">xs</code> that satisfy <code class="code">p</code> and the subsequence of the elements of <code class="code">xs</code> that do not satisfy <code class="code">p</code>.</p> <p><code class="code">partition p xs</code> is equivalent to <code class="code">filter p xs, filter (<span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> not (p x)) xs</code>.</p> <p>Consuming both of the sequences returned by <code class="code">partition p xs</code> causes <code class="code">xs</code> to be consumed twice and causes the function <code class="code">f</code> to be applied twice to each element of the list. Therefore, <code class="code">f</code> should be pure and cheap. Furthermore, <code class="code">xs</code> should be persistent and cheap. If that is not the case, use <code class="code">partition p (memoize xs)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Convertingbetweensequencesanddispensers">Converting between sequences and dispensers</h2>
<p>A dispenser is a representation of a sequence as a function of type <code class="code">unit <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a option</code>. Every time this function is invoked, it returns the next element of the sequence. When there are no more elements, it returns <code class="code"><span class="constructor">None</span></code>. A dispenser has mutable internal state, therefore is ephemeral: the sequence that it represents can be consumed at most once.</p> <pre id="VALof_dispenser" data-type="val of_dispenser [Module Seq]" data-language="ocaml">val of_dispenser : (unit -&gt; 'a option) -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_dispenser it</code> is the sequence of the elements produced by the dispenser <code class="code">it</code>. It is an ephemeral sequence: it can be consumed at most once. If a persistent sequence is needed, use <code class="code">memoize (of_dispenser it)</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <pre id="VALto_dispenser" data-type="val to_dispenser [Module Seq]" data-language="ocaml">val to_dispenser : 'a t -&gt; unit -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_dispenser xs</code> is a fresh dispenser on the sequence <code class="code">xs</code>.</p> <p>This dispenser has mutable internal state, which is not protected by a lock; so, it must not be used by several threads concurrently.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div> <h2 id="1_Sequencesofintegers">Sequences of integers</h2> <pre id="VALints" data-type="val ints [Module Seq]" data-language="ocaml">val ints : int -&gt; int t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">ints i</code> is the infinite sequence of the integers beginning at <code class="code">i</code> and counting up.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.14</li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/Seq.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/Seq.html</a>
  </p>
</div>
