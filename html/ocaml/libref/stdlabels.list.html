<h1>Module StdLabels.List</h1> <pre id="MODULEList" data-type="module List [Module StdLabels.List]" data-language="ocaml">module List: ListLabels</pre> <pre id="TYPEt" data-type="type 'a t [Module StdLabels.List]" data-language="ocaml">type 'a t = 'a list = </pre>
<table class="typetable"> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTt.[]"><span class="constructor">[]</span></span></code>
</td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTt.(::)"><span class="constructor">(::)</span></span> <span class="keyword">of</span> <code class="type">'a * 'a list</code></code>
</td> </tr>
</table> <div class="info "> <div class="info-desc"> <p>An alias for the type of lists.</p> </div> </div> <pre id="VALlength" data-type="val length [Module StdLabels.List]" data-language="ocaml">val length : 'a list -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the length (number of elements) of the given list.</p> </div> </div> <pre id="VALcompare_lengths" data-type="val compare_lengths [Module StdLabels.List]" data-language="ocaml">val compare_lengths : 'a list -&gt; 'b list -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Compare the lengths of two lists. <code class="code">compare_lengths l1 l2</code> is equivalent to <code class="code">compare (length l1) (length l2)</code>, except that the computation stops after reaching the end of the shortest list.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALcompare_length_with" data-type="val compare_length_with [Module StdLabels.List]" data-language="ocaml">val compare_length_with : 'a list -&gt; len:int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Compare the length of a list to an integer. <code class="code">compare_length_with l len</code> is equivalent to <code class="code">compare (length l) len</code>, except that the computation stops after at most <code class="code">len</code> iterations on the list.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALcons" data-type="val cons [Module StdLabels.List]" data-language="ocaml">val cons : 'a -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">cons x xs</code> is <code class="code">x :: xs</code></p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALhd" data-type="val hd [Module StdLabels.List]" data-language="ocaml">val hd : 'a list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return the first element of the given list.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Failure</code> if the list is empty.</li> </ul> </div> <pre id="VALtl" data-type="val tl [Module StdLabels.List]" data-language="ocaml">val tl : 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Return the given list without its first element.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Failure</code> if the list is empty.</li> </ul> </div> <pre id="VALnth" data-type="val nth [Module StdLabels.List]" data-language="ocaml">val nth : 'a list -&gt; int -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return the <code class="code">n</code>-th element of the given list. The first element (head of the list) is at position 0.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b><ul>
<li>
<code>Failure</code> if the list is too short.</li> <li>
<code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul>
</li> </ul> </div> <pre id="VALnth_opt" data-type="val nth_opt [Module StdLabels.List]" data-language="ocaml">val nth_opt : 'a list -&gt; int -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p>Return the <code class="code">n</code>-th element of the given list. The first element (head of the list) is at position 0. Return <code class="code"><span class="constructor">None</span></code> if the list is too short.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is negative.</li> </ul> </div> <pre id="VALrev" data-type="val rev [Module StdLabels.List]" data-language="ocaml">val rev : 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>List reversal.</p> </div> </div> <pre id="VALinit" data-type="val init [Module StdLabels.List]" data-language="ocaml">val init : len:int -&gt; f:(int -&gt; 'a) -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">init ~len ~f</code> is <code class="code">[f 0; f 1; ...; f (len-1)]</code>, evaluated left to right.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06.0</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">len &lt; 0</code>.</li> </ul> </div> <pre id="VALappend" data-type="val append [Module StdLabels.List]" data-language="ocaml">val append : 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Concatenate two lists. Same function as the infix operator <code class="code">@</code>. Not tail-recursive (length of the first argument). The <code class="code">@</code> operator is not tail-recursive either.</p> </div> </div> <pre id="VALrev_append" data-type="val rev_append [Module StdLabels.List]" data-language="ocaml">val rev_append : 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rev_append l1 l2</code> reverses <code class="code">l1</code> and concatenates it with <code class="code">l2</code>. This is equivalent to <code class="code">(</code><a href="listlabels.html#VALrev"><code class="code"><span class="constructor">ListLabels</span>.rev</code></a><code class="code"> l1) @ l2</code>, but <code class="code">rev_append</code> is tail-recursive and more efficient.</p> </div> </div> <pre id="VALconcat" data-type="val concat [Module StdLabels.List]" data-language="ocaml">val concat : 'a list list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Concatenate a list of lists. The elements of the argument are all concatenated together (in the same order) to give the result. Not tail-recursive (length of the argument + length of the longest sub-list).</p> </div> </div> <pre id="VALflatten" data-type="val flatten [Module StdLabels.List]" data-language="ocaml">val flatten : 'a list list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALconcat"><code class="code"><span class="constructor">ListLabels</span>.concat</code></a>. Not tail-recursive (length of the argument + length of the longest sub-list).</p> </div> </div> <h2 id="1_Comparison">Comparison</h2> <pre id="VALequal" data-type="val equal [Module StdLabels.List]" data-language="ocaml">val equal : eq:('a -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">equal eq [a1; ...; an] [b1; ..; bm]</code> holds when the two input lists have the same length, and for each pair of elements <code class="code">ai</code>, <code class="code">bi</code> at the same position we have <code class="code">eq ai bi</code>.</p> <p>Note: the <code class="code">eq</code> function may be called even if the lists have different length. If you know your equality function is costly, you may want to check <a href="listlabels.html#VALcompare_lengths"><code class="code"><span class="constructor">ListLabels</span>.compare_lengths</code></a> first.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.12.0</li> </ul> </div> <pre id="VALcompare" data-type="val compare [Module StdLabels.List]" data-language="ocaml">val compare : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">compare cmp [a1; ...; an] [b1; ...; bm]</code> performs a lexicographic comparison of the two input lists, using the same <code class="code"><span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> int</code> interface as <a href="stdlib.html#VALcompare"><code class="code">compare</code></a>:</p> <ul> <li>
<code class="code">a1 :: l1</code> is smaller than <code class="code">a2 :: l2</code> (negative result) if <code class="code">a1</code> is smaller than <code class="code">a2</code>, or if they are equal (0 result) and <code class="code">l1</code> is smaller than <code class="code">l2</code>
</li> <li>the empty list <code class="code">[]</code> is strictly smaller than non-empty lists</li> </ul> <p>Note: the <code class="code">cmp</code> function will be called even if the lists have different lengths.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.12.0</li> </ul> </div> <h2 id="1_Iterators">Iterators</h2> <pre id="VALiter" data-type="val iter [Module StdLabels.List]" data-language="ocaml">val iter : f:('a -&gt; unit) -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter ~f [a1; ...; an]</code> applies function <code class="code">f</code> in turn to <code class="code">[a1; ...; an]</code>. It is equivalent to <code class="code">f a1; f a2; ...; f an</code>.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module StdLabels.List]" data-language="ocaml">val iteri : f:(int -&gt; 'a -&gt; unit) -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALiter"><code class="code"><span class="constructor">ListLabels</span>.iter</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.00.0</li> </ul> </div> <pre id="VALmap" data-type="val map [Module StdLabels.List]" data-language="ocaml">val map : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map ~f [a1; ...; an]</code> applies function <code class="code">f</code> to <code class="code">a1, ..., an</code>, and builds the list <code class="code">[f a1; ...; f an]</code> with the results returned by <code class="code">f</code>. Not tail-recursive.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module StdLabels.List]" data-language="ocaml">val mapi : f:(int -&gt; 'a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALmap"><code class="code"><span class="constructor">ListLabels</span>.map</code></a>, but the function is applied to the index of the element as first argument (counting from 0), and the element itself as second argument. Not tail-recursive.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.00.0</li> </ul> </div> <pre id="VALrev_map" data-type="val rev_map [Module StdLabels.List]" data-language="ocaml">val rev_map : f:('a -&gt; 'b) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rev_map ~f l</code> gives the same result as <a href="listlabels.html#VALrev"><code class="code"><span class="constructor">ListLabels</span>.rev</code></a><code class="code"> (</code><a href="listlabels.html#VALmap"><code class="code"><span class="constructor">ListLabels</span>.map</code></a><code class="code"> f l)</code>, but is tail-recursive and more efficient.</p> </div> </div> <pre id="VALfilter_map" data-type="val filter_map [Module StdLabels.List]" data-language="ocaml">val filter_map : f:('a -&gt; 'b option) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter_map ~f l</code> applies <code class="code">f</code> to every element of <code class="code">l</code>, filters out the <code class="code"><span class="constructor">None</span></code> elements and returns the list of the arguments of the <code class="code"><span class="constructor">Some</span></code> elements.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08.0</li> </ul> </div> <pre id="VALconcat_map" data-type="val concat_map [Module StdLabels.List]" data-language="ocaml">val concat_map : f:('a -&gt; 'b list) -&gt; 'a list -&gt; 'b list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">concat_map ~f l</code> gives the same result as <a href="listlabels.html#VALconcat"><code class="code"><span class="constructor">ListLabels</span>.concat</code></a><code class="code"> (</code><a href="listlabels.html#VALmap"><code class="code"><span class="constructor">ListLabels</span>.map</code></a><code class="code"> f l)</code>. Tail-recursive.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.10.0</li> </ul> </div> <pre id="VALfold_left_map" data-type="val fold_left_map [Module StdLabels.List]" data-language="ocaml">val fold_left_map : f:('a -&gt; 'b -&gt; 'a * 'c) -&gt; init:'a -&gt; 'b list -&gt; 'a * 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left_map</code> is a combination of <code class="code">fold_left</code> and <code class="code">map</code> that threads an accumulator through calls to <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> </ul> </div> <pre id="VALfold_left" data-type="val fold_left [Module StdLabels.List]" data-language="ocaml">val fold_left : f:('a -&gt; 'b -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left ~f ~init [b1; ...; bn]</code> is <code class="code">f (... (f (f init b1) b2) ...) bn</code>.</p> </div> </div> <pre id="VALfold_right" data-type="val fold_right [Module StdLabels.List]" data-language="ocaml">val fold_right : f:('a -&gt; 'b -&gt; 'b) -&gt; 'a list -&gt; init:'b -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_right ~f [a1; ...; an] ~init</code> is <code class="code">f a1 (f a2 (... (f an init) ...))</code>. Not tail-recursive.</p> </div> </div> <h2 id="1_Iteratorsontwolists">Iterators on two lists</h2> <pre id="VALiter2" data-type="val iter2 [Module StdLabels.List]" data-language="ocaml">val iter2 : f:('a -&gt; 'b -&gt; unit) -&gt; 'a list -&gt; 'b list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter2 ~f [a1; ...; an] [b1; ...; bn]</code> calls in turn <code class="code">f a1 b1; ...; f an bn</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALmap2" data-type="val map2 [Module StdLabels.List]" data-language="ocaml">val map2 : f:('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map2 ~f [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[f a1 b1; ...; f an bn]</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</li> </ul> </div> <pre id="VALrev_map2" data-type="val rev_map2 [Module StdLabels.List]" data-language="ocaml">val rev_map2 : f:('a -&gt; 'b -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rev_map2 ~f l1 l2</code> gives the same result as <a href="listlabels.html#VALrev"><code class="code"><span class="constructor">ListLabels</span>.rev</code></a><code class="code"> (</code><a href="listlabels.html#VALmap2"><code class="code"><span class="constructor">ListLabels</span>.map2</code></a><code class="code"> f l1 l2)</code>, but is tail-recursive and more efficient.</p> </div> </div> <pre id="VALfold_left2" data-type="val fold_left2 [Module StdLabels.List]" data-language="ocaml">val fold_left2 : f:('a -&gt; 'b -&gt; 'c -&gt; 'a) -&gt; init:'a -&gt; 'b list -&gt; 'c list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left2 ~f ~init [a1; ...; an] [b1; ...; bn]</code> is <code class="code">f (... (f (f init a1 b1) a2 b2) ...) an bn</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALfold_right2" data-type="val fold_right2 [Module StdLabels.List]" data-language="ocaml">val fold_right2 : f:('a -&gt; 'b -&gt; 'c -&gt; 'c) -&gt; 'a list -&gt; 'b list -&gt; init:'c -&gt; 'c</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_right2 ~f [a1; ...; an] [b1; ...; bn] ~init</code> is <code class="code">f a1 b1 (f a2 b2 (... (f an bn init) ...))</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths. Not tail-recursive.</li> </ul> </div> <h2 id="1_Listscanning">List scanning</h2> <pre id="VALfor_all" data-type="val for_all [Module StdLabels.List]" data-language="ocaml">val for_all : f:('a -&gt; bool) -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all ~f [a1; ...; an]</code> checks if all elements of the list satisfy the predicate <code class="code">f</code>. That is, it returns <code class="code">(f a1) <span class="keywordsign">&amp;&amp;</span> (f a2) <span class="keywordsign">&amp;&amp;</span> ... <span class="keywordsign">&amp;&amp;</span> (f an)</code> for a non-empty list and <code class="code"><span class="keyword">true</span></code> if the list is empty.</p> </div> </div> <pre id="VALexists" data-type="val exists [Module StdLabels.List]" data-language="ocaml">val exists : f:('a -&gt; bool) -&gt; 'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists ~f [a1; ...; an]</code> checks if at least one element of the list satisfies the predicate <code class="code">f</code>. That is, it returns <code class="code">(f a1) <span class="keywordsign">||</span> (f a2) <span class="keywordsign">||</span> ... <span class="keywordsign">||</span> (f an)</code> for a non-empty list and <code class="code"><span class="keyword">false</span></code> if the list is empty.</p> </div> </div> <pre id="VALfor_all2" data-type="val for_all2 [Module StdLabels.List]" data-language="ocaml">val for_all2 : f:('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALfor_all"><code class="code"><span class="constructor">ListLabels</span>.for_all</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALexists2" data-type="val exists2 [Module StdLabels.List]" data-language="ocaml">val exists2 : f:('a -&gt; 'b -&gt; bool) -&gt; 'a list -&gt; 'b list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALexists"><code class="code"><span class="constructor">ListLabels</span>.exists</code></a>, but for a two-argument predicate.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists are determined to have different lengths.</li> </ul> </div> <pre id="VALmem" data-type="val mem [Module StdLabels.List]" data-language="ocaml">val mem : 'a -&gt; set:'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mem a ~set</code> is true if and only if <code class="code">a</code> is equal to an element of <code class="code">set</code>.</p> </div> </div> <pre id="VALmemq" data-type="val memq [Module StdLabels.List]" data-language="ocaml">val memq : 'a -&gt; set:'a list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALmem"><code class="code"><span class="constructor">ListLabels</span>.mem</code></a>, but uses physical equality instead of structural equality to compare list elements.</p> </div> </div> <h2 id="1_Listsearching">List searching</h2> <pre id="VALfind" data-type="val find [Module StdLabels.List]" data-language="ocaml">val find : f:('a -&gt; bool) -&gt; 'a list -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find ~f l</code> returns the first element of the list <code class="code">l</code> that satisfies the predicate <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if there is no value that satisfies <code class="code">f</code> in the list <code class="code">l</code>.</li> </ul> </div> <pre id="VALfind_opt" data-type="val find_opt [Module StdLabels.List]" data-language="ocaml">val find_opt : f:('a -&gt; bool) -&gt; 'a list -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find ~f l</code> returns the first element of the list <code class="code">l</code> that satisfies the predicate <code class="code">f</code>. Returns <code class="code"><span class="constructor">None</span></code> if there is no value that satisfies <code class="code">f</code> in the list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_map" data-type="val find_map [Module StdLabels.List]" data-language="ocaml">val find_map : f:('a -&gt; 'b option) -&gt; 'a list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_map ~f l</code> applies <code class="code">f</code> to the elements of <code class="code">l</code> in order, and returns the first result of the form <code class="code"><span class="constructor">Some</span> v</code>, or <code class="code"><span class="constructor">None</span></code> if none exist.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.10.0</li> </ul> </div> <pre id="VALfilter" data-type="val filter [Module StdLabels.List]" data-language="ocaml">val filter : f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter ~f l</code> returns all the elements of the list <code class="code">l</code> that satisfy the predicate <code class="code">f</code>. The order of the elements in the input list is preserved.</p> </div> </div> <pre id="VALfind_all" data-type="val find_all [Module StdLabels.List]" data-language="ocaml">val find_all : f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_all</code> is another name for <a href="listlabels.html#VALfilter"><code class="code"><span class="constructor">ListLabels</span>.filter</code></a>.</p> </div> </div> <pre id="VALfilteri" data-type="val filteri [Module StdLabels.List]" data-language="ocaml">val filteri : f:(int -&gt; 'a -&gt; bool) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALfilter"><code class="code"><span class="constructor">ListLabels</span>.filter</code></a>, but the predicate is applied to the index of the element as first argument (counting from 0), and the element itself as second argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11.0</li> </ul> </div> <pre id="VALpartition" data-type="val partition [Module StdLabels.List]" data-language="ocaml">val partition : f:('a -&gt; bool) -&gt; 'a list -&gt; 'a list * 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition ~f l</code> returns a pair of lists <code class="code">(l1, l2)</code>, where <code class="code">l1</code> is the list of all the elements of <code class="code">l</code> that satisfy the predicate <code class="code">f</code>, and <code class="code">l2</code> is the list of all the elements of <code class="code">l</code> that do not satisfy <code class="code">f</code>. The order of the elements in the input list is preserved.</p> </div> </div> <pre id="VALpartition_map" data-type="val partition_map [Module StdLabels.List]" data-language="ocaml">val partition_map : f:('a -&gt; ('b, 'c) Either.t) -&gt; 'a list -&gt; 'b list * 'c list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition_map f l</code> returns a pair of lists <code class="code">(l1, l2)</code> such that, for each element <code class="code">x</code> of the input list <code class="code">l</code>:</p> <ul> <li>if <code class="code">f x</code> is <code class="code"><span class="constructor">Left</span> y1</code>, then <code class="code">y1</code> is in <code class="code">l1</code>, and</li> <li>if <code class="code">f x</code> is <code class="code"><span class="constructor">Right</span> y2</code>, then <code class="code">y2</code> is in <code class="code">l2</code>.</li> </ul> <p>The output elements are included in <code class="code">l1</code> and <code class="code">l2</code> in the same relative order as the corresponding input elements in <code class="code">l</code>.</p> <p>In particular, <code class="code">partition_map (<span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> <span class="keyword">if</span> f x <span class="keyword">then</span> <span class="constructor">Left</span> x <span class="keyword">else</span> <span class="constructor">Right</span> x) l</code> is equivalent to <code class="code">partition f l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.12.0</li> </ul> </div> <h2 id="1_Associationlists">Association lists</h2> <pre id="VALassoc" data-type="val assoc [Module StdLabels.List]" data-language="ocaml">val assoc : 'a -&gt; ('a * 'b) list -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">assoc a l</code> returns the value associated with key <code class="code">a</code> in the list of pairs <code class="code">l</code>. That is, <code class="code">assoc a [ ...; (a,b); ...] = b</code> if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if there is no value associated with <code class="code">a</code> in the list <code class="code">l</code>.</li> </ul> </div> <pre id="VALassoc_opt" data-type="val assoc_opt [Module StdLabels.List]" data-language="ocaml">val assoc_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">assoc_opt a l</code> returns the value associated with key <code class="code">a</code> in the list of pairs <code class="code">l</code>. That is, <code class="code">assoc_opt a [ ...; (a,b); ...] = <span class="constructor">Some</span> b</code> if <code class="code">(a,b)</code> is the leftmost binding of <code class="code">a</code> in list <code class="code">l</code>. Returns <code class="code"><span class="constructor">None</span></code> if there is no value associated with <code class="code">a</code> in the list <code class="code">l</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALassq" data-type="val assq [Module StdLabels.List]" data-language="ocaml">val assq : 'a -&gt; ('a * 'b) list -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALassoc"><code class="code"><span class="constructor">ListLabels</span>.assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> </div> <pre id="VALassq_opt" data-type="val assq_opt [Module StdLabels.List]" data-language="ocaml">val assq_opt : 'a -&gt; ('a * 'b) list -&gt; 'b option</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALassoc_opt"><code class="code"><span class="constructor">ListLabels</span>.assoc_opt</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05.0</li> </ul> </div> <pre id="VALmem_assoc" data-type="val mem_assoc [Module StdLabels.List]" data-language="ocaml">val mem_assoc : 'a -&gt; map:('a * 'b) list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALassoc"><code class="code"><span class="constructor">ListLabels</span>.assoc</code></a>, but simply return <code class="code"><span class="keyword">true</span></code> if a binding exists, and <code class="code"><span class="keyword">false</span></code> if no bindings exist for the given key.</p> </div> </div> <pre id="VALmem_assq" data-type="val mem_assq [Module StdLabels.List]" data-language="ocaml">val mem_assq : 'a -&gt; map:('a * 'b) list -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALmem_assoc"><code class="code"><span class="constructor">ListLabels</span>.mem_assoc</code></a>, but uses physical equality instead of structural equality to compare keys.</p> </div> </div> <pre id="VALremove_assoc" data-type="val remove_assoc [Module StdLabels.List]" data-language="ocaml">val remove_assoc : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">remove_assoc a l</code> returns the list of pairs <code class="code">l</code> without the first pair with key <code class="code">a</code>, if any. Not tail-recursive.</p> </div> </div> <pre id="VALremove_assq" data-type="val remove_assq [Module StdLabels.List]" data-language="ocaml">val remove_assq : 'a -&gt; ('a * 'b) list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALremove_assoc"><code class="code"><span class="constructor">ListLabels</span>.remove_assoc</code></a>, but uses physical equality instead of structural equality to compare keys. Not tail-recursive.</p> </div> </div> <h2 id="1_Listsofpairs">Lists of pairs</h2> <pre id="VALsplit" data-type="val split [Module StdLabels.List]" data-language="ocaml">val split : ('a * 'b) list -&gt; 'a list * 'b list</pre>
<div class="info "> <div class="info-desc"> <p>Transform a list of pairs into a pair of lists: <code class="code">split [(a1,b1); ...; (an,bn)]</code> is <code class="code">([a1; ...; an], [b1; ...; bn])</code>. Not tail-recursive.</p> </div> </div> <pre id="VALcombine" data-type="val combine [Module StdLabels.List]" data-language="ocaml">val combine : 'a list -&gt; 'b list -&gt; ('a * 'b) list</pre>
<div class="info "> <div class="info-desc"> <p>Transform a pair of lists into a list of pairs: <code class="code">combine [a1; ...; an] [b1; ...; bn]</code> is <code class="code">[(a1,b1); ...; (an,bn)]</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the two lists have different lengths. Not tail-recursive.</li> </ul> </div> <h2 id="1_Sorting">Sorting</h2> <pre id="VALsort" data-type="val sort [Module StdLabels.List]" data-language="ocaml">val sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Sort a list in increasing order according to a comparison function. The comparison function must return 0 if its arguments compare as equal, a positive integer if the first is greater, and a negative integer if the first is smaller (see Array.sort for a complete specification). For example, <a href="stdlib.html#VALcompare"><code class="code">compare</code></a> is a suitable comparison function. The resulting list is sorted in increasing order. <a href="listlabels.html#VALsort"><code class="code"><span class="constructor">ListLabels</span>.sort</code></a> is guaranteed to run in constant heap space (in addition to the size of the result list) and logarithmic stack space.</p> <p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p> </div> </div> <pre id="VALstable_sort" data-type="val stable_sort [Module StdLabels.List]" data-language="ocaml">val stable_sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALsort"><code class="code"><span class="constructor">ListLabels</span>.sort</code></a>, but the sorting algorithm is guaranteed to be stable (i.e. elements that compare equal are kept in their original order).</p> <p>The current implementation uses Merge Sort. It runs in constant heap space and logarithmic stack space.</p> </div> </div> <pre id="VALfast_sort" data-type="val fast_sort [Module StdLabels.List]" data-language="ocaml">val fast_sort : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALsort"><code class="code"><span class="constructor">ListLabels</span>.sort</code></a> or <a href="listlabels.html#VALstable_sort"><code class="code"><span class="constructor">ListLabels</span>.stable_sort</code></a>, whichever is faster on typical input.</p> </div> </div> <pre id="VALsort_uniq" data-type="val sort_uniq [Module StdLabels.List]" data-language="ocaml">val sort_uniq : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="listlabels.html#VALsort"><code class="code"><span class="constructor">ListLabels</span>.sort</code></a>, but also remove duplicates.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03.0</li> </ul> </div> <pre id="VALmerge" data-type="val merge [Module StdLabels.List]" data-language="ocaml">val merge : cmp:('a -&gt; 'a -&gt; int) -&gt; 'a list -&gt; 'a list -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Merge two lists: Assuming that <code class="code">l1</code> and <code class="code">l2</code> are sorted according to the comparison function <code class="code">cmp</code>, <code class="code">merge ~cmp l1 l2</code> will return a sorted list containing all the elements of <code class="code">l1</code> and <code class="code">l2</code>. If several elements compare equal, the elements of <code class="code">l1</code> will be before the elements of <code class="code">l2</code>. Not tail-recursive (sum of the lengths of the arguments).</p> </div> </div> <h2 id="1_ListsandSequences">Lists and Sequences</h2> <pre id="VALto_seq" data-type="val to_seq [Module StdLabels.List]" data-language="ocaml">val to_seq : 'a list -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the list.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALof_seq" data-type="val of_seq [Module StdLabels.List]" data-language="ocaml">val of_seq : 'a Seq.t -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p>Create a list from a sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/libref/StdLabels.List.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/libref/StdLabels.List.html</a>
  </p>
</div>
