<h2 class="section" id="s:patterns">
<a class="section-anchor" href="#s:patterns" aria-hidden="true">﻿</a>11.6 Patterns</h2> 
<div class="syntax"><table class="display dcenter">
<tr class="c009"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c008"><a class="syntax" id="pattern"><span class="nonterminal">pattern</span></a></td>
<td class="c005">::=</td>
<td class="c007"> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">_</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="const.html#constant"><span class="nonterminal">constant</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">as</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">)</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">#</span><a class="syntax" href="names.html#typeconstr"><span class="nonterminal">typeconstr</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> { <span class="syntax-token">,</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> }<sup>+</sup> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>]{ <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a> [<span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>] [<span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>] } [<span class="syntax-token">;</span> <span class="syntax-token">_</span> ] [ <span class="syntax-token">;</span> ] <span class="syntax-token">}</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">[</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> } [ <span class="syntax-token">;</span> ] <span class="syntax-token">]</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">::</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> { <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> } [ <span class="syntax-token">;</span> ] <span class="syntax-token">|]</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="lex.html#char-literal"><span class="nonterminal">char-literal</span></a> <span class="syntax-token">..</span> <a class="syntax" href="lex.html#char-literal"><span class="nonterminal">char-literal</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">lazy</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <span class="syntax-token">exception</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">)</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.[</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">]</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|]</span> </td>
</tr> <tr>
<td class="c008"> </td>
<td class="c005">∣</td>
<td class="c007"> <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.{</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">}</span> </td>
</tr> </table></td></tr> </table></div>
<p> See also the following language extensions: <a href="firstclassmodules.html#s%3Afirst-class-modules">first-class modules</a>, <a href="attributes.html#s%3Aattributes">attributes</a> and <a href="extensionnodes.html#s%3Aextension-nodes">extension nodes</a>.</p>
<p>The table below shows the relative precedences and associativity of operators and non-closed pattern constructions. The constructions with higher precedences come first.  </p>
<div class="tableau"> <div class="center"><table class="c000 cellpadding1" border="1">
<tr>
<td class="c004"><span class="font-bold">Operator</span></td>
<td class="c004">
<span class="font-bold">Associativity</span> </td>
</tr> <tr>
<td class="c006"> <span class="machine"><span class="font-tt">..</span></span>
</td>
<td class="c006">– </td>
</tr> <tr>
<td class="c006">
<span class="machine"><span class="font-tt">lazy</span></span> (see section <a href="#sss%3Apat-lazy">11.6</a>)</td>
<td class="c006">– </td>
</tr> <tr>
<td class="c006">Constructor application, Tag application</td>
<td class="c006">right </td>
</tr> <tr>
<td class="c006"><span class="machine"><span class="font-tt">::</span></span></td>
<td class="c006">right </td>
</tr> <tr>
<td class="c006"><span class="machine"><span class="font-tt">,</span></span></td>
<td class="c006">– </td>
</tr> <tr>
<td class="c006"><span class="machine"><span class="font-tt">|</span></span></td>
<td class="c006">left </td>
</tr> <tr>
<td class="c006"><span class="machine"><span class="font-tt">as</span></span></td>
<td class="c006">– </td>
</tr> </table></div>
</div>
<p>Patterns are templates that allow selecting data structures of a given shape, and binding identifiers to components of the data structure. This selection operation is called pattern matching; its outcome is either “this value does not match this pattern”, or “this value matches this pattern, resulting in the following bindings of names to values”.</p>
<h4 class="subsubsection" id="sss:pat-variable">
<a class="section-anchor" href="#sss:pat-variable" aria-hidden="true">﻿</a>Variable patterns</h4> <p>A pattern that consists in a value name matches any value, binding the name to the value. The pattern <span class="syntax-token">_</span> also matches any value, but does not bind any name.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let is_empty = function
    | [] -&gt; true
    | _ :: _ -&gt; false;;

val is_empty : 'a list -&gt; bool = </pre> </div> </div>
<p>Patterns are <em>linear</em>: a variable cannot be bound several times by a given pattern. In particular, there is no way to test for equality between two parts of a data structure using only a pattern:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let pair_equal = function
    | x, x -&gt; true
    | x, y -&gt; false;;

Error: Variable x is bound several times in this matching</pre> </div> </div>
<p>However, we can use a <span class="syntax-token">when</span> guard for this purpose:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let pair_equal = function
    | x, y when x = y -&gt; true
    | _ -&gt; false;;

val pair_equal : 'a * 'a -&gt; bool = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-const">
<a class="section-anchor" href="#sss:pat-const" aria-hidden="true">﻿</a>Constant patterns</h4> <p>A pattern consisting in a constant matches the values that are equal to this constant.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let bool_of_string = function
    | "true" -&gt; true
    | "false" -&gt; false
    | _ -&gt; raise (Invalid_argument "bool_of_string");;

val bool_of_string : string -&gt; bool = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-alias">
<a class="section-anchor" href="#sss:pat-alias" aria-hidden="true">﻿</a>Alias patterns</h4> 
<p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">as</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> matches the same values as <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>. If the matching against <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> is successful, the name <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> is bound to the matched value, in addition to the bindings performed by the matching against <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let sort_pair ((x, y) as p) =
    if x &lt;= y then p else (y, x);;

val sort_pair : 'a * 'a -&gt; 'a * 'a = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-parenthesized">
<a class="section-anchor" href="#sss:pat-parenthesized" aria-hidden="true">﻿</a>Parenthesized patterns</h4> <p>The pattern <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">)</span> matches the same values as <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>. A type constraint can appear in a parenthesized pattern, as in <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a> <span class="syntax-token">)</span>. This constraint forces the type of <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> to be compatible with <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let int_triple_is_ordered ((a, b, c) : int * int * int) =
    a &lt;= b &amp;&amp; b &lt;= c;;

val int_triple_is_ordered : int * int * int -&gt; bool = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-or">
<a class="section-anchor" href="#sss:pat-or" aria-hidden="true">﻿</a>“Or” patterns</h4> <p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> represents the logical “or” of the two patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> and <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>. A value matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> if it matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> or <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>. The two sub-patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> and <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> must bind exactly the same identifiers to values having the same types. Matching is performed from left to right. More precisely, in case some value <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>, the bindings performed are those of <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> when <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>. Otherwise, value <span class="font-it">v</span> matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> whose bindings are performed.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type shape = Square of float | Rect of (float * float) | Circle of float

  let is_rectangular = function
    | Square _ | Rect _ -&gt; true
    | Circle _ -&gt; false;;

type shape = Square of float | Rect of (float * float) | Circle of float
val is_rectangular : shape -&gt; bool = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-variant">
<a class="section-anchor" href="#sss:pat-variant" aria-hidden="true">﻿</a>Variant patterns</h4> <p>The pattern <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">(</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">,</span> … <span class="syntax-token">,</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">)</span> matches all variants whose constructor is equal to <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a>, and whose arguments match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> … <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. It is a type error if <span class="font-it">n</span> is not the number of arguments expected by the constructor.</p>
<p>The pattern <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a> <span class="syntax-token">_</span> matches all variants whose constructor is <a class="syntax" href="names.html#constr"><span class="nonterminal">constr</span></a>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type 'a tree = Lf | Br of 'a tree * 'a * 'a tree

  let rec total = function
    | Br (l, x, r) -&gt; total l + x + total r
    | Lf -&gt; 0;;

type 'a tree = Lf | Br of 'a tree * 'a * 'a tree
val total : int tree -&gt; int = </pre> </div> </div>
<p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">::</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub> matches non-empty lists whose heads match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>, and whose tails match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>2</sub>.</p>
<p>The pattern <span class="syntax-token">[</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">]</span> matches lists of length <span class="font-it">n</span> whose elements match <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> …<a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>, respectively. This pattern behaves like <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">::</span> … <span class="syntax-token">::</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">::</span> <span class="syntax-token">[]</span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec destutter = function
    | [] -&gt; []
    | [a] -&gt; [a]
    | a :: b :: t -&gt; if a = b then destutter (b :: t) else a :: destutter (b :: t);;

val destutter : 'a list -&gt; 'a list = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-polyvar">
<a class="section-anchor" href="#sss:pat-polyvar" aria-hidden="true">﻿</a>Polymorphic variant patterns</h4> <p>The pattern <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> matches all polymorphic variants whose tag is equal to <a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a>, and whose argument matches <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec split = function
    | [] -&gt; ([], [])
    | h :: t -&gt;
        let ss, gs = split t in
          match h with
          | `Sheep _ as s -&gt; (s :: ss, gs)
          | `Goat _ as g -&gt; (ss, g :: gs);;

val split :
  [&lt; `Goat of 'a | `Sheep of 'b ] list -&gt;
  [&gt; `Sheep of 'b ] list * [&gt; `Goat of 'a ] list = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-polyvar-abbrev">
<a class="section-anchor" href="#sss:pat-polyvar-abbrev" aria-hidden="true">﻿</a>Polymorphic variant abbreviation patterns</h4> <p>If the type [<span class="syntax-token">('a,'b,</span>…<span class="syntax-token">)</span>] <a class="syntax" href="names.html#typeconstr"><span class="nonterminal">typeconstr</span></a> = <span class="syntax-token">[</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a><sub>1</sub> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a><sub><span class="font-it">n</span></sub> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">]</span> is defined, then the pattern <span class="syntax-token">#</span><a class="syntax" href="names.html#typeconstr"><span class="nonterminal">typeconstr</span></a> is a shorthand for the following or-pattern: <span class="syntax-token">(</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a><sub>1</sub><span class="syntax-token">(_</span> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub><span class="syntax-token">)</span> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">`</span><a class="syntax" href="names.html#tag-name"><span class="nonterminal">tag-name</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">(_</span> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub><span class="syntax-token">))</span>. It matches all values of type <span class="syntax-token">[&lt;</span> <a class="syntax" href="names.html#typeconstr"><span class="nonterminal">typeconstr</span></a> <span class="syntax-token">]</span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type 'a rectangle = [`Square of 'a | `Rectangle of 'a * 'a]
  type 'a shape = [`Circle of 'a | 'a rectangle]

  let try_rectangle = function
    | #rectangle as r -&gt; Some r
    | `Circle _ -&gt; None;;

type 'a rectangle = [ `Rectangle of 'a * 'a | `Square of 'a ]
type 'a shape = [ `Circle of 'a | `Rectangle of 'a * 'a | `Square of 'a ]
val try_rectangle :
  [&lt; `Circle of 'a | `Rectangle of 'b * 'b | `Square of 'b ] -&gt;
  [&gt; `Rectangle of 'b * 'b | `Square of 'b ] option = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-tuple">
<a class="section-anchor" href="#sss:pat-tuple" aria-hidden="true">﻿</a>Tuple patterns</h4> <p>The pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">,</span> … <span class="syntax-token">,</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> matches <span class="font-it">n</span>-tuples whose components match the patterns <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> through <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>. That is, the pattern matches the tuple values (<span class="font-it">v</span><sub>1</sub>, …, <span class="font-it">v</span><sub><span class="font-it">n</span></sub>) such that <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub> matches <span class="font-it">v</span><sub><span class="font-it">i</span></sub> for <span class="font-it">i</span> = 1,… , <span class="font-it">n</span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let vector (x0, y0) (x1, y1) =
    (x1 -. x0, y1 -. y0);;

val vector : float * float -&gt; float * float -&gt; float * float = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-record">
<a class="section-anchor" href="#sss:pat-record" aria-hidden="true">﻿</a>Record patterns</h4> <p>The pattern <span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> [<span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub>] <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> [<span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub>] <span class="syntax-token">}</span> matches records that define at least the fields <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> through <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>, and such that the value associated to <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">i</span></sub> matches the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>, for <span class="font-it">i</span> = 1,… , <span class="font-it">n</span>. A single identifier <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> , and a single qualified identifier <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> stands for <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> <span class="syntax-token">.</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> . The record value can define more fields than <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> …<a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub>; the values associated to these extra fields are not taken into account for matching. Optionally, a record pattern can be terminated by <span class="syntax-token">;</span> <span class="syntax-token">_</span> to convey the fact that not all fields of the record type are listed in the record pattern and that it is intentional. Optional type constraints can be added field by field with <span class="syntax-token">{</span> <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub>1</sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub>1</sub> <span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span>… <span class="syntax-token">;</span><a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">:</span> <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">=</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">}</span> to force the type of <a class="syntax" href="names.html#field"><span class="nonterminal">field</span></a><sub><span class="font-it">k</span></sub> to be compatible with <a class="syntax" href="types.html#typexpr"><span class="nonterminal">typexpr</span></a><sub><span class="font-it">k</span></sub>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let bytes_allocated
      {Gc.minor_words = minor;
       Gc.major_words = major;
       Gc.promoted_words = prom;
       _}
    =
      (Sys.word_size / 4) * int_of_float (minor +. major -. prom);;

val bytes_allocated : Gc.stat -&gt; int = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-array">
<a class="section-anchor" href="#sss:pat-array" aria-hidden="true">﻿</a>Array patterns</h4> <p>The pattern <span class="syntax-token">[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub>1</sub> <span class="syntax-token">;</span> … <span class="syntax-token">;</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">n</span></sub> <span class="syntax-token">|]</span> matches arrays of length <span class="font-it">n</span> such that the <span class="font-it">i</span>-th array element matches the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><sub><span class="font-it">i</span></sub>, for <span class="font-it">i</span> = 1,… , <span class="font-it">n</span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let matrix3_is_symmetric = function
    | [|[|_; b; c|];
        [|d; _; f|];
        [|g; h; _|]|] -&gt; b = d &amp;&amp; c = g &amp;&amp; f = h
    | _ -&gt; failwith "matrix3_is_symmetric: not a 3x3 matrix";;

val matrix3_is_symmetric : 'a array array -&gt; bool = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-range">
<a class="section-anchor" href="#sss:pat-range" aria-hidden="true">﻿</a>Range patterns</h4> <p>The pattern <span class="syntax-token">'</span> <span class="nonterminal">c</span> <span class="syntax-token">'</span> <span class="syntax-token">..</span> <span class="syntax-token">'</span> <span class="nonterminal">d</span> <span class="syntax-token">'</span> is a shorthand for the pattern </p>
<div class="center"> <span class="syntax-token">'</span> <span class="nonterminal">c</span> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>1</sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub>2</sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> … <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">c</span><sub><span class="font-it">n</span></sub> <span class="syntax-token">'</span> <span class="syntax-token">|</span> <span class="syntax-token">'</span> <span class="nonterminal">d</span> <span class="syntax-token">'</span> </div>
<p> where <span class="font-it">c</span><sub>1</sub>, <span class="font-it">c</span><sub>2</sub>, …, <span class="font-it">c</span><sub><span class="font-it">n</span></sub> are the characters that occur between <span class="font-it">c</span> and <span class="font-it">d</span> in the ASCII character set. For instance, the pattern <span class="machine"><span class="font-tt">'0'</span></span><span class="syntax-token">..</span><span class="machine"><span class="font-tt">'9'</span></span> matches all characters that are digits.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type char_class = Uppercase | Lowercase | Digit | Other

  let classify_char = function
    | 'A'..'Z' -&gt; Uppercase
    | 'a'..'z' -&gt; Lowercase
    | '0'..'9' -&gt; Digit
    | _ -&gt; Other;;

type char_class = Uppercase | Lowercase | Digit | Other
val classify_char : char -&gt; char_class = </pre> </div> </div> <h4 class="subsubsection" id="sss:pat-lazy">
<a class="section-anchor" href="#sss:pat-lazy" aria-hidden="true">﻿</a>Lazy patterns</h4> 
<p>(Introduced in Objective Caml 3.11)</p>
<div class="syntax"><table class="display dcenter">
<tr class="c009"><td class="dcell"><table class="c001 cellpading0">
<tr>
<td class="c008"><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a></td>
<td class="c005">::=</td>
<td class="c007"> ... </td>
</tr> </table></td></tr> </table></div>
<p>The pattern <span class="syntax-token">lazy</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> matches a value <span class="font-it">v</span> of type <span class="machine"><span class="font-tt">Lazy.t</span></span>, provided <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> matches the result of forcing <span class="font-it">v</span> with <span class="machine"><span class="font-tt">Lazy.force</span></span>. A successful match of a pattern containing <span class="syntax-token">lazy</span> sub-patterns forces the corresponding parts of the value being matched, even those that imply no test such as <span class="syntax-token">lazy</span> <a class="syntax" href="names.html#value-name"><span class="nonterminal">value-name</span></a> or <span class="syntax-token">lazy</span> <span class="syntax-token">_</span>. Matching a value with a <a class="syntax" href="expr.html#pattern-matching"><span class="nonterminal">pattern-matching</span></a> where some patterns contain <span class="syntax-token">lazy</span> sub-patterns may imply forcing parts of the value, even when the pattern selected in the end has no <span class="syntax-token">lazy</span> sub-pattern.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let force_opt = function
    | Some (lazy n) -&gt; n
    | None -&gt; 0;;

val force_opt : int lazy_t option -&gt; int = </pre> </div> </div>
<p>For more information, see the description of module <span class="machine"><span class="font-tt">Lazy</span></span> in the standard library (module <a href="libref/lazy.html"><span class="font-tt">Lazy</span></a>). </p>
<h4 class="subsubsection" id="sss:exception-match">
<a class="section-anchor" href="#sss:exception-match" aria-hidden="true">﻿</a>Exception patterns</h4> <p> (Introduced in OCaml 4.02)</p>
<p>A new form of exception pattern, <span class="syntax-token">exception</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> , is allowed only as a toplevel pattern or inside a toplevel or-pattern under a <span class="machine"><span class="font-tt">match</span></span>...<span class="machine"><span class="font-tt">with</span></span> pattern-matching (other occurrences are rejected by the type-checker).</p>
<p>Cases with such a toplevel pattern are called “exception cases”, as opposed to regular “value cases”. Exception cases are applied when the evaluation of the matched expression raises an exception. The exception value is then matched against all the exception cases and re-raised if none of them accept the exception (as with a <span class="machine"><span class="font-tt">try</span></span>...<span class="machine"><span class="font-tt">with</span></span> block). Since the bodies of all exception and value cases are outside the scope of the exception handler, they are all considered to be in tail-position: if the <span class="machine"><span class="font-tt">match</span></span>...<span class="machine"><span class="font-tt">with</span></span> block itself is in tail position in the current function, any function call in tail position in one of the case bodies results in an actual tail call.</p>
<p>A pattern match must contain at least one value case. It is an error if all cases are exceptions, because there would be no code to handle the return of a value.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let find_opt p l =
    match List.find p l with
    | exception Not_found -&gt; None
    | x -&gt; Some x;;

val find_opt : ('a -&gt; bool) -&gt; 'a list -&gt; 'a option = </pre> </div> </div>
<h4 class="subsubsection" id="sss:pat-open">
<a class="section-anchor" href="#sss:pat-open" aria-hidden="true">﻿</a>Local opens for patterns</h4> <p>  (Introduced in OCaml 4.04)</p>
<p>For patterns, local opens are limited to the <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.(</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">)</span> construction. This construction locally opens the module referred to by the module path <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a> in the scope of the pattern <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a>.</p>
<p>When the body of a local open pattern is delimited by <span class="syntax-token">[</span> <span class="syntax-token">]</span>, <span class="syntax-token">[|</span> <span class="syntax-token">|]</span>, or <span class="syntax-token">{</span> <span class="syntax-token">}</span>, the parentheses can be omitted. For example, <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">]</span> is equivalent to <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([</span><a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a><span class="syntax-token">])</span>, and <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.[|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|]</span> is equivalent to <a class="syntax" href="names.html#module-path"><span class="nonterminal">module-path</span></a><span class="syntax-token">.([|</span> <a class="syntax" href="#pattern"><span class="nonterminal">pattern</span></a> <span class="syntax-token">|])</span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let bytes_allocated Gc.{minor_words; major_words; promoted_words; _} =
      (Sys.word_size / 4)
    * int_of_float (minor_words +. major_words -. promoted_words);;

val bytes_allocated : Gc.stat -&gt; int = </pre> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/patterns.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/patterns.html</a>
  </p>
</div>
