<div class="api"> <h1>Module Format</h1> <pre id="MODULEFormat" data-type="module Format [Module Format]" data-language="ocaml">module Format: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Pretty-printing.</p> <p>If you are new to this module, see the <a href="format.html#examples"> examples</a> below.</p> <p>This module implements a pretty-printing facility to format values within <a href="format.html#boxes">'pretty-printing boxes'</a> and <a href="format.html#tags">'semantic tags'</a> combined with a set of <a href="format.html#fpp">printf-like functions</a>. The pretty-printer splits lines at specified <a href="format.html#breaks">break hints</a>, and indents lines according to the box structure. Similarly, <a href="format.html#tags">semantic tags</a> can be used to decouple text presentation from its contents.</p> <p>This pretty-printing facility is implemented as an overlay on top of abstract <a href="format.html#formatter">formatters</a> which provide basic output functions. Some formatters are predefined, notably:</p> <ul> <li>
<a href="format.html#VALstd_formatter"><code class="code"><span class="constructor">Format</span>.std_formatter</code></a> outputs to <a href="stdlib.html#VALstdout">stdout</a>
</li> <li>
<a href="format.html#VALerr_formatter"><code class="code"><span class="constructor">Format</span>.err_formatter</code></a> outputs to <a href="stdlib.html#VALstderr">stderr</a>
</li> </ul> <p>Most functions in the <a href="format.html"><code class="code"><span class="constructor">Format</span></code></a> module come in two variants: a short version that operates on the current domain's standard formatter as obtained using <a href="format.html#VALget_std_formatter"><code class="code"><span class="constructor">Format</span>.get_std_formatter</code></a> and the generic version prefixed by <code class="code">pp_</code> that takes a formatter as its first argument. For the version that operates on the current domain's standard formatter, the call to <a href="format.html#VALget_std_formatter"><code class="code"><span class="constructor">Format</span>.get_std_formatter</code></a> is delayed until the last argument is received.</p> <p>More formatters can be created with <a href="format.html#VALformatter_of_out_channel"><code class="code"><span class="constructor">Format</span>.formatter_of_out_channel</code></a>, <a href="format.html#VALformatter_of_buffer"><code class="code"><span class="constructor">Format</span>.formatter_of_buffer</code></a>, <a href="format.html#VALformatter_of_symbolic_output_buffer"><code class="code"><span class="constructor">Format</span>.formatter_of_symbolic_output_buffer</code></a> or using <a href="format.html#formatter">custom formatters</a>.</p> <p><b>Warning</b>: Since <a href="format.html#formatter">formatters</a> contain mutable state, it is not thread-safe to use the same formatter on multiple domains in parallel without synchronization.</p> <p>If multiple domains write to the same output channel using the predefined formatters (as obtained by <a href="format.html#VALget_std_formatter"><code class="code"><span class="constructor">Format</span>.get_std_formatter</code></a> or <a href="format.html#VALget_err_formatter"><code class="code"><span class="constructor">Format</span>.get_err_formatter</code></a>), the output from the domains will be interleaved with each other at points where the formatters are flushed, such as with <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>. This synchronization is not performed by formatters obtained from <a href="format.html#VALformatter_of_out_channel"><code class="code"><span class="constructor">Format</span>.formatter_of_out_channel</code></a> (on the standard out channels or others).</p> </div> </div>  <h2 id="1_Introduction">Introduction</h2> <p>You may consider this module as providing an extension to the <code class="code">printf</code> facility to provide automatic line splitting. The addition of pretty-printing annotations to your regular <code class="code">printf</code> format strings gives you fancy indentation and line breaks. Pretty-printing annotations are described below in the documentation of the function <a href="format.html#VALfprintf"><code class="code"><span class="constructor">Format</span>.fprintf</code></a>.</p> <p>You may also use the explicit pretty-printing box management and printing functions provided by this module. This style is more basic but more verbose than the concise <code class="code">fprintf</code> format strings.</p> <p>For instance, the sequence <code class="code">open_box 0; print_string <span class="string">"x ="</span>; print_space ();<br>
    print_int 1; close_box (); print_newline ()</code> that prints <code class="code">x = 1</code> within a pretty-printing box, can be abbreviated as <code class="code">printf <span class="string">"@[%s@ %i@]@."</span> <span class="string">"x ="</span> 1</code>, or even shorter <code class="code">printf <span class="string">"@[x =@ %i@]@."</span> 1</code>.</p> <p>Rule of thumb for casual users of this library:</p> <ul> <li>use simple pretty-printing boxes (as obtained by <code class="code">open_box 0</code>);</li> <li>use simple break hints as obtained by <code class="code">print_cut ()</code> that outputs a simple break hint, or by <code class="code">print_space ()</code> that outputs a space indicating a break hint;</li> <li>once a pretty-printing box is open, display its material with basic printing functions (e. g. <code class="code">print_int</code> and <code class="code">print_string</code>);</li> <li>when the material for a pretty-printing box has been printed, call <code class="code">close_box ()</code> to close the box;</li> <li>at the end of pretty-printing, flush the pretty-printer to display all the remaining material, e.g. evaluate <code class="code">print_newline ()</code>.</li> </ul> <p>The behavior of pretty-printing commands is unspecified if there is no open pretty-printing box. Each box opened by one of the <code class="code">open_</code> functions below must be closed using <code class="code">close_box</code> for proper formatting. Otherwise, some of the material printed in the boxes may not be output, or may be formatted incorrectly.</p> <p>In case of interactive use, each phrase is executed in the initial state of the standard pretty-printer: after each phrase execution, the interactive system closes all open pretty-printing boxes, flushes all pending text, and resets the standard pretty-printer.</p> <p>Warning: mixing calls to pretty-printing functions of this module with calls to <a href="stdlib.html"><code class="code"><span class="constructor">Stdlib</span></code></a> low level output functions is error prone.</p> <p>The pretty-printing functions output material that is delayed in the pretty-printer queue and stacks in order to compute proper line splitting. In contrast, basic I/O output functions write directly in their output device. As a consequence, the output of a basic I/O function may appear before the output of a pretty-printing function that has been called before. For instance, <code class="code"><br>
    <span class="constructor">Stdlib</span>.print_string <span class="string">"&lt;"</span>;<br>
    <span class="constructor">Format</span>.print_string <span class="string">"PRETTY"</span>;<br>
    <span class="constructor">Stdlib</span>.print_string <span class="string">"&gt;"</span>;<br>
    <span class="constructor">Format</span>.print_string <span class="string">"TEXT"</span>;<br>
   </code> leads to output <code class="code">&lt;&gt;<span class="constructor">PRETTYTEXT</span></code>.</p> <h2 id="1_Formatters">Formatters</h2> <pre id="TYPEformatter" data-type="type formatter [Module Format]" data-language="ocaml">type formatter </pre> <div class="info "> <div class="info-desc"> <p>Abstract data corresponding to a pretty-printer (also called a formatter) and all its machinery. See also <a href="format.html#formatter"><i>Defining formatters</i></a>.</p> </div> </div> <h2 id="boxes">Pretty-printing boxes</h2>
<p>The pretty-printing engine uses the concepts of pretty-printing box and break hint to drive indentation and line splitting behavior of the pretty-printer.</p> <p>Each different pretty-printing box kind introduces a specific line splitting policy:</p> <ul> <li>within an <em>horizontal</em> box, break hints never split the line (but the line may be split in a box nested deeper),</li> <li>within a <em>vertical</em> box, break hints always split the line,</li> <li>within an <em>horizontal/vertical</em> box, if the box fits on the current line then break hints never split the line, otherwise break hint always split the line,</li> <li>within a <em>compacting</em> box, a break hint never splits the line, unless there is no more room on the current line.</li> </ul> <p>Note that line splitting policy is box specific: the policy of a box does not rule the policy of inner boxes. For instance, if a vertical box is nested in an horizontal box, all break hints within the vertical box will split the line.</p> <p>Moreover, opening a box after the <a href="format.html#maxindent">maximum indentation limit</a> splits the line whether or not the box would end up fitting on the line.</p> <pre id="VALpp_open_box" data-type="val pp_open_box [Module Format]" data-language="ocaml">val pp_open_box : formatter -&gt; int -&gt; unit</pre> <pre id="VALopen_box" data-type="val open_box [Module Format]" data-language="ocaml">val open_box : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_box ppf d</code> opens a new compacting pretty-printing box with offset <code class="code">d</code> in the formatter <code class="code">ppf</code>.</p> <p>Within this box, the pretty-printer prints as much as possible material on every line.</p> <p>A break hint splits the line if there is no more room on the line to print the remainder of the box.</p> <p>Within this box, the pretty-printer emphasizes the box structure: if a structural box does not fit fully on a simple line, a break hint also splits the line if the splitting ``moves to the left'' (i.e. the new line gets an indentation smaller than the one of the current line).</p> <p>This box is the general purpose pretty-printing box.</p> <p>If the pretty-printer splits the line in the box, offset <code class="code">d</code> is added to the current indentation.</p> </div> </div> <pre id="VALpp_close_box" data-type="val pp_close_box [Module Format]" data-language="ocaml">val pp_close_box : formatter -&gt; unit -&gt; unit</pre> <pre id="VALclose_box" data-type="val close_box [Module Format]" data-language="ocaml">val close_box : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Closes the most recently open pretty-printing box.</p> </div> </div> <pre id="VALpp_open_hbox" data-type="val pp_open_hbox [Module Format]" data-language="ocaml">val pp_open_hbox : formatter -&gt; unit -&gt; unit</pre> <pre id="VALopen_hbox" data-type="val open_hbox [Module Format]" data-language="ocaml">val open_hbox : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_hbox ppf ()</code> opens a new 'horizontal' pretty-printing box.</p> <p>This box prints material on a single line.</p> <p>Break hints in a horizontal box never split the line. (Line splitting may still occur inside boxes nested deeper).</p> </div> </div> <pre id="VALpp_open_vbox" data-type="val pp_open_vbox [Module Format]" data-language="ocaml">val pp_open_vbox : formatter -&gt; int -&gt; unit</pre> <pre id="VALopen_vbox" data-type="val open_vbox [Module Format]" data-language="ocaml">val open_vbox : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_vbox ppf d</code> opens a new 'vertical' pretty-printing box with offset <code class="code">d</code>.</p> <p>This box prints material on as many lines as break hints in the box.</p> <p>Every break hint in a vertical box splits the line.</p> <p>If the pretty-printer splits the line in the box, <code class="code">d</code> is added to the current indentation.</p> </div> </div> <pre id="VALpp_open_hvbox" data-type="val pp_open_hvbox [Module Format]" data-language="ocaml">val pp_open_hvbox : formatter -&gt; int -&gt; unit</pre> <pre id="VALopen_hvbox" data-type="val open_hvbox [Module Format]" data-language="ocaml">val open_hvbox : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_hvbox ppf d</code> opens a new 'horizontal/vertical' pretty-printing box with offset <code class="code">d</code>.</p> <p>This box behaves as an horizontal box if it fits on a single line, otherwise it behaves as a vertical box.</p> <p>If the pretty-printer splits the line in the box, <code class="code">d</code> is added to the current indentation.</p> </div> </div> <pre id="VALpp_open_hovbox" data-type="val pp_open_hovbox [Module Format]" data-language="ocaml">val pp_open_hovbox : formatter -&gt; int -&gt; unit</pre> <pre id="VALopen_hovbox" data-type="val open_hovbox [Module Format]" data-language="ocaml">val open_hovbox : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_hovbox ppf d</code> opens a new 'horizontal-or-vertical' pretty-printing box with offset <code class="code">d</code>.</p> <p>This box prints material as much as possible on every line.</p> <p>A break hint splits the line if there is no more room on the line to print the remainder of the box.</p> <p>If the pretty-printer splits the line in the box, <code class="code">d</code> is added to the current indentation.</p> </div> </div> <h2 id="1_Formattingfunctions">Formatting functions</h2> <pre id="VALpp_print_string" data-type="val pp_print_string [Module Format]" data-language="ocaml">val pp_print_string : formatter -&gt; string -&gt; unit</pre> <pre id="VALprint_string" data-type="val print_string [Module Format]" data-language="ocaml">val print_string : string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_string ppf s</code> prints <code class="code">s</code> in the current pretty-printing box.</p> </div> </div> <pre id="VALpp_print_bytes" data-type="val pp_print_bytes [Module Format]" data-language="ocaml">val pp_print_bytes : formatter -&gt; bytes -&gt; unit</pre> <pre id="VALprint_bytes" data-type="val print_bytes [Module Format]" data-language="ocaml">val print_bytes : bytes -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_bytes ppf b</code> prints <code class="code">b</code> in the current pretty-printing box.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALpp_print_as" data-type="val pp_print_as [Module Format]" data-language="ocaml">val pp_print_as : formatter -&gt; int -&gt; string -&gt; unit</pre> <pre id="VALprint_as" data-type="val print_as [Module Format]" data-language="ocaml">val print_as : int -&gt; string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_as ppf len s</code> prints <code class="code">s</code> in the current pretty-printing box. The pretty-printer formats <code class="code">s</code> as if it were of length <code class="code">len</code>.</p> </div> </div> <pre id="VALpp_print_int" data-type="val pp_print_int [Module Format]" data-language="ocaml">val pp_print_int : formatter -&gt; int -&gt; unit</pre> <pre id="VALprint_int" data-type="val print_int [Module Format]" data-language="ocaml">val print_int : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Print an integer in the current pretty-printing box.</p> </div> </div> <pre id="VALpp_print_float" data-type="val pp_print_float [Module Format]" data-language="ocaml">val pp_print_float : formatter -&gt; float -&gt; unit</pre> <pre id="VALprint_float" data-type="val print_float [Module Format]" data-language="ocaml">val print_float : float -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Print a floating point number in the current pretty-printing box.</p> </div> </div> <pre id="VALpp_print_char" data-type="val pp_print_char [Module Format]" data-language="ocaml">val pp_print_char : formatter -&gt; char -&gt; unit</pre> <pre id="VALprint_char" data-type="val print_char [Module Format]" data-language="ocaml">val print_char : char -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Print a character in the current pretty-printing box.</p> </div> </div> <pre id="VALpp_print_bool" data-type="val pp_print_bool [Module Format]" data-language="ocaml">val pp_print_bool : formatter -&gt; bool -&gt; unit</pre> <pre id="VALprint_bool" data-type="val print_bool [Module Format]" data-language="ocaml">val print_bool : bool -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Print a boolean in the current pretty-printing box.</p> </div> </div> <pre id="VALpp_print_nothing" data-type="val pp_print_nothing [Module Format]" data-language="ocaml">val pp_print_nothing : formatter -&gt; unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Print nothing.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.2</li> </ul> </div> <h2 id="breaks">Break hints</h2>
<p>A 'break hint' tells the pretty-printer to output some space or split the line whichever way is more appropriate to the current pretty-printing box splitting rules.</p> <p>Break hints are used to separate printing items and are mandatory to let the pretty-printer correctly split lines and indent items.</p> <p>Simple break hints are:</p> <ul> <li>the 'space': output a space or split the line if appropriate,</li> <li>the 'cut': split the line if appropriate.</li> </ul> <p>Note: the notions of space and line splitting are abstract for the pretty-printing engine, since those notions can be completely redefined by the programmer. However, in the pretty-printer default setting, ``output a space'' simply means printing a space character (ASCII code 32) and ``split the line'' means printing a newline character (ASCII code 10).</p> <pre id="VALpp_print_space" data-type="val pp_print_space [Module Format]" data-language="ocaml">val pp_print_space : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_space" data-type="val print_space [Module Format]" data-language="ocaml">val print_space : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_space ppf ()</code> emits a 'space' break hint: the pretty-printer may split the line at this point, otherwise it prints one space.</p> <p><code class="code">pp_print_space ppf ()</code> is equivalent to <code class="code">pp_print_break ppf 1 0</code>.</p> </div> </div> <pre id="VALpp_print_cut" data-type="val pp_print_cut [Module Format]" data-language="ocaml">val pp_print_cut : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_cut" data-type="val print_cut [Module Format]" data-language="ocaml">val print_cut : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_cut ppf ()</code> emits a 'cut' break hint: the pretty-printer may split the line at this point, otherwise it prints nothing.</p> <p><code class="code">pp_print_cut ppf ()</code> is equivalent to <code class="code">pp_print_break ppf 0 0</code>.</p> </div> </div> <pre id="VALpp_print_break" data-type="val pp_print_break [Module Format]" data-language="ocaml">val pp_print_break : formatter -&gt; int -&gt; int -&gt; unit</pre> <pre id="VALprint_break" data-type="val print_break [Module Format]" data-language="ocaml">val print_break : int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_break ppf nspaces offset</code> emits a 'full' break hint: the pretty-printer may split the line at this point, otherwise it prints <code class="code">nspaces</code> spaces.</p> <p>If the pretty-printer splits the line, <code class="code">offset</code> is added to the current indentation.</p> </div> </div> <pre id="VALpp_print_custom_break" data-type="val pp_print_custom_break [Module Format]" data-language="ocaml">val pp_print_custom_break : formatter -&gt;       fits:string * int * string -&gt; breaks:string * int * string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_custom_break ppf ~fits:(s1, n, s2) ~breaks:(s3, m, s4)</code> emits a custom break hint: the pretty-printer may split the line at this point.</p> <p>If it does not split the line, then the <code class="code">s1</code> is emitted, then <code class="code">n</code> spaces, then <code class="code">s2</code>.</p> <p>If it splits the line, then it emits the <code class="code">s3</code> string, then an indent (according to the box rules), then an offset of <code class="code">m</code> spaces, then the <code class="code">s4</code> string.</p> <p>While <code class="code">n</code> and <code class="code">m</code> are handled by <code class="code">formatter_out_functions.out_indent</code>, the strings will be handled by <code class="code">formatter_out_functions.out_string</code>. This allows for a custom formatter that handles indentation distinctly, for example, outputs <code class="code">&lt;br/&gt;</code> tags or <code class="code"><span class="keywordsign">&amp;</span>nbsp;</code> entities.</p> <p>The custom break is useful if you want to change which visible (non-whitespace) characters are printed in case of break or no break. For example, when printing a list <code class="code"> [a; b; c] </code>, you might want to add a trailing semicolon when it is printed vertically:</p> <pre class="codepre" data-language="ocaml">[
  a;
  b;
  c;
]
   </pre> <p>You can do this as follows:</p> <pre class="codepre" data-language="ocaml">printf "@[&lt;v 0&gt;[@;&lt;0 2&gt;@[&lt;v 0&gt;a;@,b;@,c@]%t]@]@\n"
  (pp_print_custom_break ~fits:("", 0, "") ~breaks:(";", 0, ""))
   </pre>
</div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_force_newline" data-type="val pp_force_newline [Module Format]" data-language="ocaml">val pp_force_newline : formatter -&gt; unit -&gt; unit</pre> <pre id="VALforce_newline" data-type="val force_newline [Module Format]" data-language="ocaml">val force_newline : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Force a new line in the current pretty-printing box.</p> <p>The pretty-printer must split the line at this point,</p> <p>Not the normal way of pretty-printing, since imperative line splitting may interfere with current line counters and box size calculation. Using break hints within an enclosing vertical box is a better alternative.</p> </div> </div> <pre id="VALpp_print_if_newline" data-type="val pp_print_if_newline [Module Format]" data-language="ocaml">val pp_print_if_newline : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_if_newline" data-type="val print_if_newline [Module Format]" data-language="ocaml">val print_if_newline : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Execute the next formatting command if the preceding line has just been split. Otherwise, ignore the next formatting command.</p> </div> </div> <h2 id="1_Prettyprintingtermination">Pretty-printing termination</h2> <pre id="VALpp_print_flush" data-type="val pp_print_flush [Module Format]" data-language="ocaml">val pp_print_flush : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_flush" data-type="val print_flush [Module Format]" data-language="ocaml">val print_flush : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>End of pretty-printing: resets the pretty-printer to initial state.</p> <p>All open pretty-printing boxes are closed, all pending text is printed. In addition, the pretty-printer low level output device is flushed to ensure that all pending text is really displayed.</p> <p>Note: never use <code class="code">print_flush</code> in the normal course of a pretty-printing routine, since the pretty-printer uses a complex buffering machinery to properly indent the output; manually flushing those buffers at random would conflict with the pretty-printer strategy and result to poor rendering.</p> <p>Only consider using <code class="code">print_flush</code> when displaying all pending material is mandatory (for instance in case of interactive use when you want the user to read some text) and when resetting the pretty-printer state will not disturb further pretty-printing.</p> <p>Warning: If the output device of the pretty-printer is an output channel, repeated calls to <code class="code">print_flush</code> means repeated calls to <a href="stdlib.html#VALflush"><code class="code">flush</code></a> to flush the out channel; these explicit flush calls could foil the buffering strategy of output channels and could dramatically impact efficiency.</p> </div> </div> <pre id="VALpp_print_newline" data-type="val pp_print_newline [Module Format]" data-language="ocaml">val pp_print_newline : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_newline" data-type="val print_newline [Module Format]" data-language="ocaml">val print_newline : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>End of pretty-printing: resets the pretty-printer to initial state.</p> <p>All open pretty-printing boxes are closed, all pending text is printed.</p> <p>Equivalent to <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a> with a new line emitted on the pretty-printer low-level output device immediately before the device is flushed. See corresponding words of caution for <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>.</p> <p>Note: this is not the normal way to output a new line; the preferred method is using break hints within a vertical pretty-printing box.</p> </div> </div> <h2 id="1_Margin">Margin</h2> <pre id="VALpp_infinity" data-type="val pp_infinity [Module Format]" data-language="ocaml">val pp_infinity : int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_infinity</code> is the maximal size of the margin. Its exact value is implementation dependent but is guaranteed to be greater than 10<sup class="superscript">9</sup>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.2</li> </ul> </div> <pre id="VALpp_set_margin" data-type="val pp_set_margin [Module Format]" data-language="ocaml">val pp_set_margin : formatter -&gt; int -&gt; unit</pre> <pre id="VALset_margin" data-type="val set_margin [Module Format]" data-language="ocaml">val set_margin : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_margin ppf d</code> sets the right margin to <code class="code">d</code> (in characters): the pretty-printer splits lines that overflow the right margin according to the break hints given. Setting the margin to <code class="code">d</code> means that the formatting engine aims at printing at most <code class="code">d-1</code> characters per line. Nothing happens if <code class="code">d</code> is smaller than 2. If <code class="code">d &gt;= </code><a href="format.html#VALpp_infinity"><code class="code"><span class="constructor">Format</span>.pp_infinity</code></a>, the right margin is set to <a href="format.html#VALpp_infinity"><code class="code"><span class="constructor">Format</span>.pp_infinity</code></a><code class="code"> - 1</code>. If <code class="code">d</code> is less than the current maximum indentation limit, the maximum indentation limit is decreased while trying to preserve a minimal ratio <code class="code">max_indent/margin&gt;=50%</code> and if possible the current difference <code class="code">margin - max_indent</code>.</p> <p>See also <a href="format.html#VALpp_set_geometry"><code class="code"><span class="constructor">Format</span>.pp_set_geometry</code></a>.</p> </div> </div> <pre id="VALpp_get_margin" data-type="val pp_get_margin [Module Format]" data-language="ocaml">val pp_get_margin : formatter -&gt; unit -&gt; int</pre> <pre id="VALget_margin" data-type="val get_margin [Module Format]" data-language="ocaml">val get_margin : unit -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Returns the position of the right margin.</p> </div> </div> <h2 id="maxindent">Maximum indentation limit</h2> <pre id="VALpp_set_max_indent" data-type="val pp_set_max_indent [Module Format]" data-language="ocaml">val pp_set_max_indent : formatter -&gt; int -&gt; unit</pre> <pre id="VALset_max_indent" data-type="val set_max_indent [Module Format]" data-language="ocaml">val set_max_indent : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_max_indent ppf d</code> sets the maximum indentation limit of lines to <code class="code">d</code> (in characters): once this limit is reached, new pretty-printing boxes are rejected to the left, unless the enclosing box fully fits on the current line. As an illustration,</p> <pre class="codepre" data-language="ocaml"> set_margin 10; set_max_indent 5; printf "@[123456@[7@]89A@]@." </pre>
<p>yields</p> <pre class="codepre" data-language="ocaml">    123456
    789A
  </pre>
<p>because the nested box <code class="code"><span class="string">"@[7@]"</span></code> is opened after the maximum indentation limit (<code class="code">7&gt;5</code>) and its parent box does not fit on the current line. Either decreasing the length of the parent box to make it fit on a line:</p> <pre class="codepre" data-language="ocaml"> printf "@[123456@[7@]89@]@." </pre>
<p>or opening an intermediary box before the maximum indentation limit which fits on the current line</p> <pre class="codepre" data-language="ocaml"> printf "@[123@[456@[7@]89@]A@]@." </pre>
<p>avoids the rejection to the left of the inner boxes and print respectively <code class="code"><span class="string">"123456789"</span></code> and <code class="code"><span class="string">"123456789A"</span></code> . Note also that vertical boxes never fit on a line whereas horizontal boxes always fully fit on the current line. Opening a box may split a line whereas the contents may have fit. If this behavior is problematic, it can be curtailed by setting the maximum indentation limit to <code class="code">margin - 1</code>. Note that setting the maximum indentation limit to <code class="code">margin</code> is invalid.</p> <p>Nothing happens if <code class="code">d</code> is smaller than 2.</p> <p>If <code class="code">d</code> is greater than the current margin, it is ignored, and the current maximum indentation limit is kept.</p> <p>See also <a href="format.html#VALpp_set_geometry"><code class="code"><span class="constructor">Format</span>.pp_set_geometry</code></a>.</p> </div> </div> <pre id="VALpp_get_max_indent" data-type="val pp_get_max_indent [Module Format]" data-language="ocaml">val pp_get_max_indent : formatter -&gt; unit -&gt; int</pre> <pre id="VALget_max_indent" data-type="val get_max_indent [Module Format]" data-language="ocaml">val get_max_indent : unit -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the maximum indentation limit (in characters).</p> </div> </div> <h2 id="1_Geometry">Geometry </h2> <p>Geometric functions can be used to manipulate simultaneously the coupled variables, margin and maximum indentation limit.</p> <pre id="TYPEgeometry" data-type="type geometry [Module Format]" data-language="ocaml">type geometry = {</pre>
<table class="typetable"> <tbody>
<tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTgeometry.max_indent">max_indent</span> : <code class="type">int</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTgeometry.margin">margin</span> : <code class="type">int</code>;</code>
</td> </tr>
</tbody>
</table> <code>}</code> <div class="info "> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALcheck_geometry" data-type="val check_geometry [Module Format]" data-language="ocaml">val check_geometry : geometry -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Check if the formatter geometry is valid: <code class="code">1 &lt; max_indent &lt; margin &lt; </code><a href="format.html#VALpp_infinity"><code class="code"><span class="constructor">Format</span>.pp_infinity</code></a></p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_set_geometry" data-type="val pp_set_geometry [Module Format]" data-language="ocaml">val pp_set_geometry : formatter -&gt; max_indent:int -&gt; margin:int -&gt; unit</pre> <pre id="VALset_geometry" data-type="val set_geometry [Module Format]" data-language="ocaml">val set_geometry : max_indent:int -&gt; margin:int -&gt; unit</pre> <pre id="VALpp_safe_set_geometry" data-type="val pp_safe_set_geometry [Module Format]" data-language="ocaml">val pp_safe_set_geometry : formatter -&gt; max_indent:int -&gt; margin:int -&gt; unit</pre> <pre id="VALsafe_set_geometry" data-type="val safe_set_geometry [Module Format]" data-language="ocaml">val safe_set_geometry : max_indent:int -&gt; margin:int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_geometry ppf ~max_indent ~margin</code> sets both the margin and maximum indentation limit for <code class="code">ppf</code>.</p> <p>When <code class="code">1 &lt; max_indent &lt; margin &lt; </code><a href="format.html#VALpp_infinity"><code class="code"><span class="constructor">Format</span>.pp_infinity</code></a>, <code class="code">pp_set_geometry ppf ~max_indent ~margin</code> is equivalent to <code class="code">pp_set_margin ppf margin; pp_set_max_indent ppf max_indent</code>; and avoids the subtly incorrect <code class="code">pp_set_max_indent ppf max_indent; pp_set_margin ppf margin</code>;</p> <p>Outside of this domain, <code class="code">pp_set_geometry</code> raises an invalid argument exception whereas <code class="code">pp_safe_set_geometry</code> does nothing.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_update_geometry" data-type="val pp_update_geometry [Module Format]" data-language="ocaml">val pp_update_geometry : formatter -&gt; (geometry -&gt; geometry) -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_update_geometry ppf (<span class="keyword">fun</span> geo <span class="keywordsign">-&gt;</span> { geo <span class="keyword">with</span> ... })</code> lets you update a formatter's geometry in a way that is robust to extension of the <code class="code">geometry</code> record with new fields.</p> <p>Raises an invalid argument exception if the returned geometry does not satisfy <a href="format.html#VALcheck_geometry"><code class="code"><span class="constructor">Format</span>.check_geometry</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALupdate_geometry" data-type="val update_geometry [Module Format]" data-language="ocaml">val update_geometry : (geometry -&gt; geometry) -&gt; unit</pre> <pre id="VALpp_get_geometry" data-type="val pp_get_geometry [Module Format]" data-language="ocaml">val pp_get_geometry : formatter -&gt; unit -&gt; geometry</pre> <pre id="VALget_geometry" data-type="val get_geometry [Module Format]" data-language="ocaml">val get_geometry : unit -&gt; geometry</pre>
<div class="info "> <div class="info-desc"> <p>Return the current geometry of the formatter</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <h2 id="1_Maximumformattingdepth">Maximum formatting depth</h2>
<p>The maximum formatting depth is the maximum number of pretty-printing boxes simultaneously open.</p> <p>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by <a href="format.html#VALget_ellipsis_text"><code class="code"><span class="constructor">Format</span>.get_ellipsis_text</code></a> <code class="code">()</code>).</p> <pre id="VALpp_set_max_boxes" data-type="val pp_set_max_boxes [Module Format]" data-language="ocaml">val pp_set_max_boxes : formatter -&gt; int -&gt; unit</pre> <pre id="VALset_max_boxes" data-type="val set_max_boxes [Module Format]" data-language="ocaml">val set_max_boxes : int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_max_boxes ppf max</code> sets the maximum number of pretty-printing boxes simultaneously open.</p> <p>Material inside boxes nested deeper is printed as an ellipsis (more precisely as the text returned by <a href="format.html#VALget_ellipsis_text"><code class="code"><span class="constructor">Format</span>.get_ellipsis_text</code></a> <code class="code">()</code>).</p> <p>Nothing happens if <code class="code">max</code> is smaller than 2.</p> </div> </div> <pre id="VALpp_get_max_boxes" data-type="val pp_get_max_boxes [Module Format]" data-language="ocaml">val pp_get_max_boxes : formatter -&gt; unit -&gt; int</pre> <pre id="VALget_max_boxes" data-type="val get_max_boxes [Module Format]" data-language="ocaml">val get_max_boxes : unit -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Returns the maximum number of pretty-printing boxes allowed before ellipsis.</p> </div> </div> <pre id="VALpp_over_max_boxes" data-type="val pp_over_max_boxes [Module Format]" data-language="ocaml">val pp_over_max_boxes : formatter -&gt; unit -&gt; bool</pre> <pre id="VALover_max_boxes" data-type="val over_max_boxes [Module Format]" data-language="ocaml">val over_max_boxes : unit -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Tests if the maximum number of pretty-printing boxes allowed have already been opened.</p> </div> </div> <h2 id="1_Tabulationboxes">Tabulation boxes</h2>
<p>A <em>tabulation box</em> prints material on lines divided into cells of fixed length. A tabulation box provides a simple way to display vertical columns of left adjusted text.</p> <p>This box features command <code class="code">set_tab</code> to define cell boundaries, and command <code class="code">print_tab</code> to move from cell to cell and split the line when there is no more cells to print on the line.</p> <p>Note: printing within tabulation box is line directed, so arbitrary line splitting inside a tabulation box leads to poor rendering. Yet, controlled use of tabulation boxes allows simple printing of columns within module <a href="format.html"><code class="code"><span class="constructor">Format</span></code></a>.</p> <pre id="VALpp_open_tbox" data-type="val pp_open_tbox [Module Format]" data-language="ocaml">val pp_open_tbox : formatter -&gt; unit -&gt; unit</pre> <pre id="VALopen_tbox" data-type="val open_tbox [Module Format]" data-language="ocaml">val open_tbox : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">open_tbox ()</code> opens a new tabulation box.</p> <p>This box prints lines separated into cells of fixed width.</p> <p>Inside a tabulation box, special <em>tabulation markers</em> defines points of interest on the line (for instance to delimit cell boundaries). Function <a href="format.html#VALset_tab"><code class="code"><span class="constructor">Format</span>.set_tab</code></a> sets a tabulation marker at insertion point.</p> <p>A tabulation box features specific <em>tabulation breaks</em> to move to next tabulation marker or split the line. Function <a href="format.html#VALprint_tbreak"><code class="code"><span class="constructor">Format</span>.print_tbreak</code></a> prints a tabulation break.</p> </div> </div> <pre id="VALpp_close_tbox" data-type="val pp_close_tbox [Module Format]" data-language="ocaml">val pp_close_tbox : formatter -&gt; unit -&gt; unit</pre> <pre id="VALclose_tbox" data-type="val close_tbox [Module Format]" data-language="ocaml">val close_tbox : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Closes the most recently opened tabulation box.</p> </div> </div> <pre id="VALpp_set_tab" data-type="val pp_set_tab [Module Format]" data-language="ocaml">val pp_set_tab : formatter -&gt; unit -&gt; unit</pre> <pre id="VALset_tab" data-type="val set_tab [Module Format]" data-language="ocaml">val set_tab : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Sets a tabulation marker at current insertion point.</p> </div> </div> <pre id="VALpp_print_tab" data-type="val pp_print_tab [Module Format]" data-language="ocaml">val pp_print_tab : formatter -&gt; unit -&gt; unit</pre> <pre id="VALprint_tab" data-type="val print_tab [Module Format]" data-language="ocaml">val print_tab : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">print_tab ()</code> emits a 'next' tabulation break hint: if not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right, or the pretty-printer splits the line and insertion point moves to the leftmost tabulation marker.</p> <p>It is equivalent to <code class="code">print_tbreak 0 0</code>.</p> </div> </div> <pre id="VALpp_print_tbreak" data-type="val pp_print_tbreak [Module Format]" data-language="ocaml">val pp_print_tbreak : formatter -&gt; int -&gt; int -&gt; unit</pre> <pre id="VALprint_tbreak" data-type="val print_tbreak [Module Format]" data-language="ocaml">val print_tbreak : int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">print_tbreak nspaces offset</code> emits a 'full' tabulation break hint.</p> <p>If not already set on a tabulation marker, the insertion point moves to the first tabulation marker on the right and the pretty-printer prints <code class="code">nspaces</code> spaces.</p> <p>If there is no next tabulation marker on the right, the pretty-printer splits the line at this point, then insertion point moves to the leftmost tabulation marker of the box.</p> <p>If the pretty-printer splits the line, <code class="code">offset</code> is added to the current indentation.</p> </div> </div> <h2 id="1_Ellipsis">Ellipsis</h2> <pre id="VALpp_set_ellipsis_text" data-type="val pp_set_ellipsis_text [Module Format]" data-language="ocaml">val pp_set_ellipsis_text : formatter -&gt; string -&gt; unit</pre> <pre id="VALset_ellipsis_text" data-type="val set_ellipsis_text [Module Format]" data-language="ocaml">val set_ellipsis_text : string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Set the text of the ellipsis printed when too many pretty-printing boxes are open (a single dot, <code class="code">.</code>, by default).</p> </div> </div> <pre id="VALpp_get_ellipsis_text" data-type="val pp_get_ellipsis_text [Module Format]" data-language="ocaml">val pp_get_ellipsis_text : formatter -&gt; unit -&gt; string</pre> <pre id="VALget_ellipsis_text" data-type="val get_ellipsis_text [Module Format]" data-language="ocaml">val get_ellipsis_text : unit -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p>Return the text of the ellipsis.</p> </div> </div> <h2 id="tags">Semantic tags</h2> <pre id="TYPEstag" data-type="type stag [Module Format]" data-language="ocaml">type stag = ..</pre> <div class="info "> <div class="info-desc"> <p><i>Semantic tags</i> (or simply <em>tags</em>) are user's defined annotations to associate user's specific operations to printed entities.</p> <p>Common usage of semantic tags is text decoration to get specific font or text size rendering for a display device, or marking delimitation of entities (e.g. HTML or TeX elements or terminal escape sequences). More sophisticated usage of semantic tags could handle dynamic modification of the pretty-printer behavior to properly print the material within some specific tags. For instance, we can define an RGB tag like so:</p> <pre class="codepre" data-language="ocaml">type stag += RGB of {r:int;g:int;b:int}
</pre> <p>In order to properly delimit printed entities, a semantic tag must be opened before and closed after the entity. Semantic tags must be properly nested like parentheses using <a href="format.html#VALpp_open_stag"><code class="code"><span class="constructor">Format</span>.pp_open_stag</code></a> and <a href="format.html#VALpp_close_stag"><code class="code"><span class="constructor">Format</span>.pp_close_stag</code></a>.</p> <p>Tag specific operations occur any time a tag is opened or closed, At each occurrence, two kinds of operations are performed <em>tag-marking</em> and <em>tag-printing</em>:</p> <ul> <li>The tag-marking operation is the simpler tag specific operation: it simply writes a tag specific string into the output device of the formatter. Tag-marking does not interfere with line-splitting computation.</li> <li>The tag-printing operation is the more involved tag specific operation: it can print arbitrary material to the formatter. Tag-printing is tightly linked to the current pretty-printer operations.</li> </ul> <p>Roughly speaking, tag-marking is commonly used to get a better rendering of texts in the rendering device, while tag-printing allows fine tuning of printing routines to print the same entity differently according to the semantic tags (i.e. print additional material or even omit parts of the output).</p> <p>More precisely: when a semantic tag is opened or closed then both and successive 'tag-printing' and 'tag-marking' operations occur:</p> <ul> <li>Tag-printing a semantic tag means calling the formatter specific function <code class="code">print_open_stag</code> (resp. <code class="code">print_close_stag</code>) with the name of the tag as argument: that tag-printing function can then print any regular material to the formatter (so that this material is enqueued as usual in the formatter queue for further line splitting computation).</li> <li>Tag-marking a semantic tag means calling the formatter specific function <code class="code">mark_open_stag</code> (resp. <code class="code">mark_close_stag</code>) with the name of the tag as argument: that tag-marking function can then return the 'tag-opening marker' (resp. `tag-closing marker') for direct output into the output device of the formatter.</li> </ul> <p>Being written directly into the output device of the formatter, semantic tag marker strings are not considered as part of the printing material that drives line splitting (in other words, the length of the strings corresponding to tag markers is considered as zero for line splitting).</p> <p>Thus, semantic tag handling is in some sense transparent to pretty-printing and does not interfere with usual indentation. Hence, a single pretty-printing routine can output both simple 'verbatim' material or richer decorated output depending on the treatment of tags. By default, tags are not active, hence the output is not decorated with tag information. Once <code class="code">set_tags</code> is set to <code class="code"><span class="keyword">true</span></code>, the pretty-printer engine honors tags and decorates the output accordingly.</p> <p>Default tag-marking functions behave the HTML way: <a href="format.html#TYPEtag">string tags</a> are enclosed in "&lt;" and "&gt;" while other tags are ignored; hence, opening marker for tag string <code class="code"><span class="string">"t"</span></code> is <code class="code"><span class="string">"&lt;t&gt;"</span></code> and closing marker is <code class="code"><span class="string">"&lt;/t&gt;"</span></code>.</p> <p>Default tag-printing functions just do nothing.</p> <p>Tag-marking and tag-printing functions are user definable and can be set by calling <a href="format.html#VALset_formatter_stag_functions"><code class="code"><span class="constructor">Format</span>.set_formatter_stag_functions</code></a>.</p> <p>Semantic tag operations may be set on or off with <a href="format.html#VALset_tags"><code class="code"><span class="constructor">Format</span>.set_tags</code></a>. Tag-marking operations may be set on or off with <a href="format.html#VALset_mark_tags"><code class="code"><span class="constructor">Format</span>.set_mark_tags</code></a>. Tag-printing operations may be set on or off with <a href="format.html#VALset_print_tags"><code class="code"><span class="constructor">Format</span>.set_print_tags</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="TYPEtag" data-type="type tag [Module Format]" data-language="ocaml">type tag = string </pre> <pre data-language="ocaml">type stag += </pre>
<table class="typetable"> <tbody><tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="EXTENSIONString_tag">String_tag</span> <span class="keyword">of</span> <code class="type"><a href="format.html#TYPEtag">tag</a></code></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">String_tag</span> s</code> is a string tag <code class="code">s</code>. String tags can be inserted either by explicitly using the constructor <code class="code"><span class="constructor">String_tag</span></code> or by using the dedicated format syntax <code class="code"><span class="string">"@{&lt;s&gt; ... @}"</span></code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr></tbody>
</table> <pre id="VALpp_open_stag" data-type="val pp_open_stag [Module Format]" data-language="ocaml">val pp_open_stag : formatter -&gt; stag -&gt; unit</pre> <pre id="VALopen_stag" data-type="val open_stag [Module Format]" data-language="ocaml">val open_stag : stag -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_open_stag ppf t</code> opens the semantic tag named <code class="code">t</code>.</p> <p>The <code class="code">print_open_stag</code> tag-printing function of the formatter is called with <code class="code">t</code> as argument; then the opening tag marker for <code class="code">t</code>, as given by <code class="code">mark_open_stag t</code>, is written into the output device of the formatter.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_close_stag" data-type="val pp_close_stag [Module Format]" data-language="ocaml">val pp_close_stag : formatter -&gt; unit -&gt; unit</pre> <pre id="VALclose_stag" data-type="val close_stag [Module Format]" data-language="ocaml">val close_stag : unit -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_close_stag ppf ()</code> closes the most recently opened semantic tag <code class="code">t</code>.</p> <p>The closing tag marker, as given by <code class="code">mark_close_stag t</code>, is written into the output device of the formatter; then the <code class="code">print_close_stag</code> tag-printing function of the formatter is called with <code class="code">t</code> as argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_set_tags" data-type="val pp_set_tags [Module Format]" data-language="ocaml">val pp_set_tags : formatter -&gt; bool -&gt; unit</pre> <pre id="VALset_tags" data-type="val set_tags [Module Format]" data-language="ocaml">val set_tags : bool -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_tags ppf b</code> turns on or off the treatment of semantic tags (default is off).</p> </div> </div> <pre id="VALpp_set_print_tags" data-type="val pp_set_print_tags [Module Format]" data-language="ocaml">val pp_set_print_tags : formatter -&gt; bool -&gt; unit</pre> <pre id="VALset_print_tags" data-type="val set_print_tags [Module Format]" data-language="ocaml">val set_print_tags : bool -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_print_tags ppf b</code> turns on or off the tag-printing operations.</p> </div> </div> <pre id="VALpp_set_mark_tags" data-type="val pp_set_mark_tags [Module Format]" data-language="ocaml">val pp_set_mark_tags : formatter -&gt; bool -&gt; unit</pre> <pre id="VALset_mark_tags" data-type="val set_mark_tags [Module Format]" data-language="ocaml">val set_mark_tags : bool -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_mark_tags ppf b</code> turns on or off the tag-marking operations.</p> </div> </div> <pre id="VALpp_get_print_tags" data-type="val pp_get_print_tags [Module Format]" data-language="ocaml">val pp_get_print_tags : formatter -&gt; unit -&gt; bool</pre> <pre id="VALget_print_tags" data-type="val get_print_tags [Module Format]" data-language="ocaml">val get_print_tags : unit -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Return the current status of tag-printing operations.</p> </div> </div> <pre id="VALpp_get_mark_tags" data-type="val pp_get_mark_tags [Module Format]" data-language="ocaml">val pp_get_mark_tags : formatter -&gt; unit -&gt; bool</pre> <pre id="VALget_mark_tags" data-type="val get_mark_tags [Module Format]" data-language="ocaml">val get_mark_tags : unit -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Return the current status of tag-marking operations.</p> </div> </div> <pre id="VALpp_set_formatter_out_channel" data-type="val pp_set_formatter_out_channel [Module Format]" data-language="ocaml">val pp_set_formatter_out_channel : formatter -&gt; out_channel -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <h2 id="1_Redirectingthestandardformatteroutput">Redirecting the standard formatter output</h2>
</div> </div> <pre id="VALset_formatter_out_channel" data-type="val set_formatter_out_channel [Module Format]" data-language="ocaml">val set_formatter_out_channel : out_channel -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Redirect the standard pretty-printer output to the given channel. (All the output functions of the standard formatter are set to the default output functions printing to the given channel.)</p> <p><code class="code">set_formatter_out_channel</code> is equivalent to <a href="format.html#VALpp_set_formatter_out_channel"><code class="code"><span class="constructor">Format</span>.pp_set_formatter_out_channel</code></a> <code class="code">std_formatter</code>.</p> </div> </div> <pre id="VALpp_set_formatter_output_functions" data-type="val pp_set_formatter_output_functions [Module Format]" data-language="ocaml">val pp_set_formatter_output_functions : formatter -&gt; (string -&gt; int -&gt; int -&gt; unit) -&gt; (unit -&gt; unit) -&gt; unit</pre> <pre id="VALset_formatter_output_functions" data-type="val set_formatter_output_functions [Module Format]" data-language="ocaml">val set_formatter_output_functions : (string -&gt; int -&gt; int -&gt; unit) -&gt; (unit -&gt; unit) -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_formatter_output_functions ppf out flush</code> redirects the standard pretty-printer output functions to the functions <code class="code">out</code> and <code class="code">flush</code>.</p> <p>The <code class="code">out</code> function performs all the pretty-printer string output. It is called with a string <code class="code">s</code>, a start position <code class="code">p</code>, and a number of characters <code class="code">n</code>; it is supposed to output characters <code class="code">p</code> to <code class="code">p + n - 1</code> of <code class="code">s</code>.</p> <p>The <code class="code">flush</code> function is called whenever the pretty-printer is flushed (via conversion <code class="code">%!</code>, or pretty-printing indications <code class="code">@?</code> or <code class="code">@.</code>, or using low level functions <code class="code">print_flush</code> or <code class="code">print_newline</code>).</p> </div> </div> <pre id="VALpp_get_formatter_output_functions" data-type="val pp_get_formatter_output_functions [Module Format]" data-language="ocaml">val pp_get_formatter_output_functions : formatter -&gt; unit -&gt; (string -&gt; int -&gt; int -&gt; unit) * (unit -&gt; unit)</pre> <pre id="VALget_formatter_output_functions" data-type="val get_formatter_output_functions [Module Format]" data-language="ocaml">val get_formatter_output_functions : unit -&gt; (string -&gt; int -&gt; int -&gt; unit) * (unit -&gt; unit)</pre>
<div class="info "> <div class="info-desc"> <p>Return the current output functions of the standard pretty-printer.</p> </div> </div> <h2 id="meaning">Redefining formatter output</h2>
<p>The <code class="code"><span class="constructor">Format</span></code> module is versatile enough to let you completely redefine the meaning of pretty-printing output: you may provide your own functions to define how to handle indentation, line splitting, and even printing of all the characters that have to be printed!</p> <h3 id="2_Redefiningoutputfunctions">Redefining output functions</h3> <pre id="TYPEformatter_out_functions" data-type="type formatter_out_functions [Module Format]" data-language="ocaml">type formatter_out_functions = {</pre>
<table class="typetable"> <tbody>
<tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_out_functions.out_string">out_string</span> : <code class="type">string -&gt; int -&gt; int -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_out_functions.out_flush">out_flush</span> : <code class="type">unit -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_out_functions.out_newline">out_newline</span> : <code class="type">unit -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_out_functions.out_spaces">out_spaces</span> : <code class="type">int -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_out_functions.out_indent">out_indent</span> : <code class="type">int -&gt; unit</code>;</code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr>
</tbody>
</table> <code>}</code> <div class="info "> <div class="info-desc"> <p>The set of output functions specific to a formatter:</p> <ul> <li>the <code class="code">out_string</code> function performs all the pretty-printer string output. It is called with a string <code class="code">s</code>, a start position <code class="code">p</code>, and a number of characters <code class="code">n</code>; it is supposed to output characters <code class="code">p</code> to <code class="code">p + n - 1</code> of <code class="code">s</code>.</li> <li>the <code class="code">out_flush</code> function flushes the pretty-printer output device.</li> <li>
<code class="code">out_newline</code> is called to open a new line when the pretty-printer splits the line.</li> <li>the <code class="code">out_spaces</code> function outputs spaces when a break hint leads to spaces instead of a line split. It is called with the number of spaces to output.</li> <li>the <code class="code">out_indent</code> function performs new line indentation when the pretty-printer splits the line. It is called with the indentation value of the new line.</li> </ul> <p>By default:</p> <ul> <li>fields <code class="code">out_string</code> and <code class="code">out_flush</code> are output device specific; (e.g. <a href="stdlib.html#VALoutput_string"><code class="code">output_string</code></a> and <a href="stdlib.html#VALflush"><code class="code">flush</code></a> for a <a href="stdlib.html#TYPEout_channel"><code class="code">out_channel</code></a> device, or <code class="code"><span class="constructor">Buffer</span>.add_substring</code> and <a href="stdlib.html#VALignore"><code class="code">ignore</code></a> for a <code class="code"><span class="constructor">Buffer</span>.t</code> output device),</li> <li>field <code class="code">out_newline</code> is equivalent to <code class="code">out_string <span class="string">"\n"</span> 0 1</code>;</li> <li>fields <code class="code">out_spaces</code> and <code class="code">out_indent</code> are equivalent to <code class="code">out_string (<span class="constructor">String</span>.make n <span class="string">' '</span>) 0 n</code>.</li> </ul> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.01</li> </ul> </div> <pre id="VALpp_set_formatter_out_functions" data-type="val pp_set_formatter_out_functions [Module Format]" data-language="ocaml">val pp_set_formatter_out_functions : formatter -&gt; formatter_out_functions -&gt; unit</pre> <pre id="VALset_formatter_out_functions" data-type="val set_formatter_out_functions [Module Format]" data-language="ocaml">val set_formatter_out_functions : formatter_out_functions -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_formatter_out_functions ppf out_funs</code> Set all the pretty-printer output functions of <code class="code">ppf</code> to those of argument <code class="code">out_funs</code>,</p> <p>This way, you can change the meaning of indentation (which can be something else than just printing space characters) and the meaning of new lines opening (which can be connected to any other action needed by the application at hand).</p> <p>Reasonable defaults for functions <code class="code">out_spaces</code> and <code class="code">out_newline</code> are respectively <code class="code">out_funs.out_string (<span class="constructor">String</span>.make n <span class="string">' '</span>) 0 n</code> and <code class="code">out_funs.out_string <span class="string">"\n"</span> 0 1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.01</li> </ul> </div> <pre id="VALpp_get_formatter_out_functions" data-type="val pp_get_formatter_out_functions [Module Format]" data-language="ocaml">val pp_get_formatter_out_functions : formatter -&gt; unit -&gt; formatter_out_functions</pre> <pre id="VALget_formatter_out_functions" data-type="val get_formatter_out_functions [Module Format]" data-language="ocaml">val get_formatter_out_functions : unit -&gt; formatter_out_functions</pre>
<div class="info "> <div class="info-desc"> <p>Return the current output functions of the pretty-printer, including line splitting and indentation functions. Useful to record the current setting and restore it afterwards.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.01</li> </ul> </div> <h2 id="tagsmeaning">Redefining semantic tag operations</h2> <pre id="TYPEformatter_stag_functions" data-type="type formatter_stag_functions [Module Format]" data-language="ocaml">type formatter_stag_functions = {</pre>
<table class="typetable"> <tbody>
<tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_stag_functions.mark_open_stag">mark_open_stag</span> : <code class="type"><a href="format.html#TYPEstag">stag</a> -&gt; string</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_stag_functions.mark_close_stag">mark_close_stag</span> : <code class="type"><a href="format.html#TYPEstag">stag</a> -&gt; string</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_stag_functions.print_open_stag">print_open_stag</span> : <code class="type"><a href="format.html#TYPEstag">stag</a> -&gt; unit</code>;</code>
</td> </tr> <tr> <td align="left" valign="top"> 
</td> <td align="left" valign="top"> <code><span id="TYPEELTformatter_stag_functions.print_close_stag">print_close_stag</span> : <code class="type"><a href="format.html#TYPEstag">stag</a> -&gt; unit</code>;</code>
</td> </tr>
</tbody>
</table> <code>}</code> <div class="info "> <div class="info-desc"> <p>The semantic tag handling functions specific to a formatter: <code class="code">mark</code> versions are the 'tag-marking' functions that associate a string marker to a tag in order for the pretty-printing engine to write those markers as 0 length tokens in the output device of the formatter. <code class="code">print</code> versions are the 'tag-printing' functions that can perform regular printing when a tag is closed or opened.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_set_formatter_stag_functions" data-type="val pp_set_formatter_stag_functions [Module Format]" data-language="ocaml">val pp_set_formatter_stag_functions : formatter -&gt; formatter_stag_functions -&gt; unit</pre> <pre id="VALset_formatter_stag_functions" data-type="val set_formatter_stag_functions [Module Format]" data-language="ocaml">val set_formatter_stag_functions : formatter_stag_functions -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_set_formatter_stag_functions ppf tag_funs</code> changes the meaning of opening and closing semantic tag operations to use the functions in <code class="code">tag_funs</code> when printing on <code class="code">ppf</code>.</p> <p>When opening a semantic tag with name <code class="code">t</code>, the string <code class="code">t</code> is passed to the opening tag-marking function (the <code class="code">mark_open_stag</code> field of the record <code class="code">tag_funs</code>), that must return the opening tag marker for that name. When the next call to <code class="code">close_stag ()</code> happens, the semantic tag name <code class="code">t</code> is sent back to the closing tag-marking function (the <code class="code">mark_close_stag</code> field of record <code class="code">tag_funs</code>), that must return a closing tag marker for that name.</p> <p>The <code class="code">print_</code> field of the record contains the tag-printing functions that are called at tag opening and tag closing time, to output regular material in the pretty-printer queue.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_get_formatter_stag_functions" data-type="val pp_get_formatter_stag_functions [Module Format]" data-language="ocaml">val pp_get_formatter_stag_functions : formatter -&gt; unit -&gt; formatter_stag_functions</pre> <pre id="VALget_formatter_stag_functions" data-type="val get_formatter_stag_functions [Module Format]" data-language="ocaml">val get_formatter_stag_functions : unit -&gt; formatter_stag_functions</pre>
<div class="info "> <div class="info-desc"> <p>Return the current semantic tag operation functions of the standard pretty-printer.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <h2 id="formatter">Defining formatters</h2> <p>Defining new formatters permits unrelated output of material in parallel on several output devices. All the parameters of a formatter are local to the formatter: right margin, maximum indentation limit, maximum number of pretty-printing boxes simultaneously open, ellipsis, and so on, are specific to each formatter and may be fixed independently.</p> <p>For instance, given a <a href="buffer.html#TYPEt"><code class="code"><span class="constructor">Buffer</span>.t</code></a> buffer <code class="code">b</code>, <a href="format.html#VALformatter_of_buffer"><code class="code"><span class="constructor">Format</span>.formatter_of_buffer</code></a> <code class="code">b</code> returns a new formatter using buffer <code class="code">b</code> as its output device. Similarly, given a <a href="stdlib.html#TYPEout_channel"><code class="code">out_channel</code></a> output channel <code class="code">oc</code>, <a href="format.html#VALformatter_of_out_channel"><code class="code"><span class="constructor">Format</span>.formatter_of_out_channel</code></a> <code class="code">oc</code> returns a new formatter using channel <code class="code">oc</code> as its output device.</p> <p>Alternatively, given <code class="code">out_funs</code>, a complete set of output functions for a formatter, then <a href="format.html#VALformatter_of_out_functions"><code class="code"><span class="constructor">Format</span>.formatter_of_out_functions</code></a> <code class="code">out_funs</code> computes a new formatter using those functions for output.</p> <pre id="VALformatter_of_out_channel" data-type="val formatter_of_out_channel [Module Format]" data-language="ocaml">val formatter_of_out_channel : out_channel -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">formatter_of_out_channel oc</code> returns a new formatter writing to the corresponding output channel <code class="code">oc</code>.</p> </div> </div> <pre id="VALsynchronized_formatter_of_out_channel" data-type="val synchronized_formatter_of_out_channel [Module Format]" data-language="ocaml">val synchronized_formatter_of_out_channel : out_channel -&gt; formatter Domain.DLS.key</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">synchronized_formatter_of_out_channel oc</code> returns the key to the domain-local state that holds the domain-local formatter for writing to the corresponding output channel <code class="code">oc</code>.</p> <p>When the formatter is used with multiple domains, the output from the domains will be interleaved with each other at points where the formatter is flushed, such as with <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>.</p> </div> <ul class="info-attributes"> <li><b>Alert unstable.</b></li> </ul> </div> <pre id="VALstd_formatter" data-type="val std_formatter [Module Format]" data-language="ocaml">val std_formatter : formatter</pre>
<div class="info "> <div class="info-desc"> <p>The initial domain's standard formatter to write to standard output.</p> <p>It is defined as <a href="format.html#VALformatter_of_out_channel"><code class="code"><span class="constructor">Format</span>.formatter_of_out_channel</code></a> <a href="stdlib.html#VALstdout"><code class="code">stdout</code></a>.</p> </div> </div> <pre id="VALget_std_formatter" data-type="val get_std_formatter [Module Format]" data-language="ocaml">val get_std_formatter : unit -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_std_formatter ()</code> returns the current domain's standard formatter used to write to standard output.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.0</li> </ul> </div> <pre id="VALerr_formatter" data-type="val err_formatter [Module Format]" data-language="ocaml">val err_formatter : formatter</pre>
<div class="info "> <div class="info-desc"> <p>The initial domain's formatter to write to standard error.</p> <p>It is defined as <a href="format.html#VALformatter_of_out_channel"><code class="code"><span class="constructor">Format</span>.formatter_of_out_channel</code></a> <a href="stdlib.html#VALstderr"><code class="code">stderr</code></a>.</p> </div> </div> <pre id="VALget_err_formatter" data-type="val get_err_formatter [Module Format]" data-language="ocaml">val get_err_formatter : unit -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_err_formatter ()</code> returns the current domain's formatter used to write to standard error.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.0</li> </ul> </div> <pre id="VALformatter_of_buffer" data-type="val formatter_of_buffer [Module Format]" data-language="ocaml">val formatter_of_buffer : Buffer.t -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">formatter_of_buffer b</code> returns a new formatter writing to buffer <code class="code">b</code>. At the end of pretty-printing, the formatter must be flushed using <a href="format.html#VALpp_print_flush"><code class="code"><span class="constructor">Format</span>.pp_print_flush</code></a> or <a href="format.html#VALpp_print_newline"><code class="code"><span class="constructor">Format</span>.pp_print_newline</code></a>, to print all the pending material into the buffer.</p> </div> </div> <pre id="VALstdbuf" data-type="val stdbuf [Module Format]" data-language="ocaml">val stdbuf : Buffer.t</pre>
<div class="info "> <div class="info-desc"> <p>The initial domain's string buffer in which <code class="code">str_formatter</code> writes.</p> </div> </div> <pre id="VALget_stdbuf" data-type="val get_stdbuf [Module Format]" data-language="ocaml">val get_stdbuf : unit -&gt; Buffer.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_stdbuf ()</code> returns the current domain's string buffer in which the current domain's string formatter writes.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.0</li> </ul> </div> <pre id="VALstr_formatter" data-type="val str_formatter [Module Format]" data-language="ocaml">val str_formatter : formatter</pre>
<div class="info "> <div class="info-desc"> <p>The initial domain's formatter to output to the <a href="format.html#VALstdbuf"><code class="code"><span class="constructor">Format</span>.stdbuf</code></a> string buffer.</p> <p><code class="code">str_formatter</code> is defined as <a href="format.html#VALformatter_of_buffer"><code class="code"><span class="constructor">Format</span>.formatter_of_buffer</code></a> <a href="format.html#VALstdbuf"><code class="code"><span class="constructor">Format</span>.stdbuf</code></a>.</p> </div> </div> <pre id="VALget_str_formatter" data-type="val get_str_formatter [Module Format]" data-language="ocaml">val get_str_formatter : unit -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p>The current domain's formatter to output to the current domains string buffer.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.0</li> </ul> </div> <pre id="VALflush_str_formatter" data-type="val flush_str_formatter [Module Format]" data-language="ocaml">val flush_str_formatter : unit -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p>Returns the material printed with <code class="code">str_formatter</code> of the current domain, flushes the formatter and resets the corresponding buffer.</p> </div> </div> <pre id="VALmake_formatter" data-type="val make_formatter [Module Format]" data-language="ocaml">val make_formatter : (string -&gt; int -&gt; int -&gt; unit) -&gt; (unit -&gt; unit) -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make_formatter out flush</code> returns a new formatter that outputs with function <code class="code">out</code>, and flushes with function <code class="code">flush</code>.</p> <p>For instance,</p> <pre class="codepre" data-language="ocaml">    make_formatter
      (Stdlib.output_substring oc)
      (fun () -&gt; Stdlib.flush oc)
  </pre>
<p>returns a formatter to the <a href="stdlib.html#TYPEout_channel"><code class="code">out_channel</code></a> <code class="code">oc</code>.</p> </div> </div> <pre id="VALmake_synchronized_formatter" data-type="val make_synchronized_formatter [Module Format]" data-language="ocaml">val make_synchronized_formatter : (string -&gt; int -&gt; int -&gt; unit) -&gt;       (unit -&gt; unit) -&gt; formatter Domain.DLS.key</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make_synchronized_formatter out flush</code> returns the key to the domain-local state that holds the domain-local formatter that outputs with function <code class="code">out</code>, and flushes with function <code class="code">flush</code>.</p> <p>When the formatter is used with multiple domains, the output from the domains will be interleaved with each other at points where the formatter is flushed, such as with <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.0</li> <li><b>Alert unstable.</b></li> </ul> </div> <pre id="VALformatter_of_out_functions" data-type="val formatter_of_out_functions [Module Format]" data-language="ocaml">val formatter_of_out_functions : formatter_out_functions -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">formatter_of_out_functions out_funs</code> returns a new formatter that writes with the set of output functions <code class="code">out_funs</code>.</p> <p>See definition of type <a href="format.html#TYPEformatter_out_functions"><code class="code"><span class="constructor">Format</span>.formatter_out_functions</code></a> for the meaning of argument <code class="code">out_funs</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <h3 id="symbolic">Symbolic pretty-printing</h3>
<p>Symbolic pretty-printing is pretty-printing using a symbolic formatter, i.e. a formatter that outputs symbolic pretty-printing items.</p> <p>When using a symbolic formatter, all regular pretty-printing activities occur but output material is symbolic and stored in a buffer of output items. At the end of pretty-printing, flushing the output buffer allows post-processing of symbolic output before performing low level output operations.</p> <p>In practice, first define a symbolic output buffer <code class="code">b</code> using:</p> <ul> <li>
<code class="code"><span class="keyword">let</span> sob = make_symbolic_output_buffer ()</code>. Then define a symbolic formatter with:</li> <li><code class="code"><span class="keyword">let</span> ppf = formatter_of_symbolic_output_buffer sob</code></li> </ul> <p>Use symbolic formatter <code class="code">ppf</code> as usual, and retrieve symbolic items at end of pretty-printing by flushing symbolic output buffer <code class="code">sob</code> with:</p> <ul> <li>
<code class="code">flush_symbolic_output_buffer sob</code>.</li> </ul> <pre id="TYPEsymbolic_output_item" data-type="type symbolic_output_item [Module Format]" data-language="ocaml">type symbolic_output_item = </pre>
<table class="typetable"> <tbody>
<tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTsymbolic_output_item.Output_flush"><span class="constructor">Output_flush</span></span></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p>symbolic flush command</p> </div> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTsymbolic_output_item.Output_newline"><span class="constructor">Output_newline</span></span></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p>symbolic newline command</p> </div> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTsymbolic_output_item.Output_string"><span class="constructor">Output_string</span></span> <span class="keyword">of</span> <code class="type">string</code></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Output_string</span> s</code>: symbolic output for string <code class="code">s</code></p> </div> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTsymbolic_output_item.Output_spaces"><span class="constructor">Output_spaces</span></span> <span class="keyword">of</span> <code class="type">int</code></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Output_spaces</span> n</code>: symbolic command to output <code class="code">n</code> spaces</p> </div> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr> <tr> <td align="left" valign="top"> <code><span class="keyword">|</span></code>
</td> <td align="left" valign="top"> <code><span id="TYPEELTsymbolic_output_item.Output_indent"><span class="constructor">Output_indent</span></span> <span class="keyword">of</span> <code class="type">int</code></code>
</td> <td class="typefieldcomment" align="left" valign="top"><code>(*</code></td>
<td class="typefieldcomment" align="left" valign="top">
<div class="info "> <div class="info-desc"> <p><code class="code"><span class="constructor">Output_indent</span> i</code>: symbolic indentation of size <code class="code">i</code></p> </div> </div> </td>
<td class="typefieldcomment" align="left" valign="bottom"><code>*)</code></td> </tr>
</tbody>
</table> <div class="info "> <div class="info-desc"> <p>Items produced by symbolic pretty-printers</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="TYPEsymbolic_output_buffer" data-type="type symbolic_output_buffer [Module Format]" data-language="ocaml">type symbolic_output_buffer </pre> <div class="info "> <div class="info-desc"> <p>The output buffer of a symbolic pretty-printer.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALmake_symbolic_output_buffer" data-type="val make_symbolic_output_buffer [Module Format]" data-language="ocaml">val make_symbolic_output_buffer : unit -&gt; symbolic_output_buffer</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make_symbolic_output_buffer ()</code> returns a fresh buffer for symbolic output.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALclear_symbolic_output_buffer" data-type="val clear_symbolic_output_buffer [Module Format]" data-language="ocaml">val clear_symbolic_output_buffer : symbolic_output_buffer -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">clear_symbolic_output_buffer sob</code> resets buffer <code class="code">sob</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALget_symbolic_output_buffer" data-type="val get_symbolic_output_buffer [Module Format]" data-language="ocaml">val get_symbolic_output_buffer : symbolic_output_buffer -&gt; symbolic_output_item list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_symbolic_output_buffer sob</code> returns the contents of buffer <code class="code">sob</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALflush_symbolic_output_buffer" data-type="val flush_symbolic_output_buffer [Module Format]" data-language="ocaml">val flush_symbolic_output_buffer : symbolic_output_buffer -&gt; symbolic_output_item list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">flush_symbolic_output_buffer sob</code> returns the contents of buffer <code class="code">sob</code> and resets buffer <code class="code">sob</code>. <code class="code">flush_symbolic_output_buffer sob</code> is equivalent to <code class="code"><span class="keyword">let</span> items = get_symbolic_output_buffer sob <span class="keyword">in</span><br>
   clear_symbolic_output_buffer sob; items</code></p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALadd_symbolic_output_item" data-type="val add_symbolic_output_item [Module Format]" data-language="ocaml">val add_symbolic_output_item : symbolic_output_buffer -&gt; symbolic_output_item -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">add_symbolic_output_item sob itm</code> adds item <code class="code">itm</code> to buffer <code class="code">sob</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALformatter_of_symbolic_output_buffer" data-type="val formatter_of_symbolic_output_buffer [Module Format]" data-language="ocaml">val formatter_of_symbolic_output_buffer : symbolic_output_buffer -&gt; formatter</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">formatter_of_symbolic_output_buffer sob</code> returns a symbolic formatter that outputs to <code class="code">symbolic_output_buffer</code> <code class="code">sob</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <h2 id="1_Convenienceformattingfunctions">Convenience formatting functions.</h2> <pre id="VALpp_print_iter" data-type="val pp_print_iter [Module Format]" data-language="ocaml">val pp_print_iter : ?pp_sep:(formatter -&gt; unit -&gt; unit) -&gt;       (('a -&gt; unit) -&gt; 'b -&gt; unit) -&gt;       (formatter -&gt; 'a -&gt; unit) -&gt; formatter -&gt; 'b -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_iter ~pp_sep iter pp_v ppf v</code> formats on <code class="code">ppf</code> the iterations of <code class="code">iter</code> over a collection <code class="code">v</code> of values using <code class="code">pp_v</code>. Iterations are separated by <code class="code">pp_sep</code> (defaults to <a href="format.html#VALpp_print_cut"><code class="code"><span class="constructor">Format</span>.pp_print_cut</code></a>).</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.1</li> </ul> </div> <pre id="VALpp_print_list" data-type="val pp_print_list [Module Format]" data-language="ocaml">val pp_print_list : ?pp_sep:(formatter -&gt; unit -&gt; unit) -&gt;       (formatter -&gt; 'a -&gt; unit) -&gt; formatter -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_list ?pp_sep pp_v ppf l</code> prints items of list <code class="code">l</code>, using <code class="code">pp_v</code> to print each item, and calling <code class="code">pp_sep</code> between items (<code class="code">pp_sep</code> defaults to <a href="format.html#VALpp_print_cut"><code class="code"><span class="constructor">Format</span>.pp_print_cut</code></a>). Does nothing on empty lists.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.02</li> </ul> </div> <pre id="VALpp_print_array" data-type="val pp_print_array [Module Format]" data-language="ocaml">val pp_print_array : ?pp_sep:(formatter -&gt; unit -&gt; unit) -&gt;       (formatter -&gt; 'a -&gt; unit) -&gt; formatter -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_array ?pp_sep pp_v ppf a</code> prints items of array <code class="code">a</code>, using <code class="code">pp_v</code> to print each item, and calling <code class="code">pp_sep</code> between items (<code class="code">pp_sep</code> defaults to <a href="format.html#VALpp_print_cut"><code class="code"><span class="constructor">Format</span>.pp_print_cut</code></a>). Does nothing on empty arrays.</p> <p>If <code class="code">a</code> is mutated after <code class="code">pp_print_array</code> is called, the printed values may not be what is expected because <code class="code"><span class="constructor">Format</span></code> can delay the printing. This can be avoided by flushing <code class="code">ppf</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.1</li> </ul> </div> <pre id="VALpp_print_seq" data-type="val pp_print_seq [Module Format]" data-language="ocaml">val pp_print_seq : ?pp_sep:(formatter -&gt; unit -&gt; unit) -&gt;       (formatter -&gt; 'a -&gt; unit) -&gt;       formatter -&gt; 'a Seq.t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_seq ?pp_sep pp_v ppf s</code> prints items of sequence <code class="code">s</code>, using <code class="code">pp_v</code> to print each item, and calling <code class="code">pp_sep</code> between items (<code class="code">pp_sep</code> defaults to <a href="format.html#VALpp_print_cut"><code class="code"><span class="constructor">Format</span>.pp_print_cut</code></a>. Does nothing on empty sequences.</p> <p>This function does not terminate on infinite sequences.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.12</li> </ul> </div> <pre id="VALpp_print_text" data-type="val pp_print_text [Module Format]" data-language="ocaml">val pp_print_text : formatter -&gt; string -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_text ppf s</code> prints <code class="code">s</code> with spaces and newlines respectively printed using <a href="format.html#VALpp_print_space"><code class="code"><span class="constructor">Format</span>.pp_print_space</code></a> and <a href="format.html#VALpp_force_newline"><code class="code"><span class="constructor">Format</span>.pp_force_newline</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.02</li> </ul> </div> <pre id="VALpp_print_option" data-type="val pp_print_option [Module Format]" data-language="ocaml">val pp_print_option : ?none:(formatter -&gt; unit -&gt; unit) -&gt;       (formatter -&gt; 'a -&gt; unit) -&gt; formatter -&gt; 'a option -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_option ?none pp_v ppf o</code> prints <code class="code">o</code> on <code class="code">ppf</code> using <code class="code">pp_v</code> if <code class="code">o</code> is <code class="code"><span class="constructor">Some</span> v</code> and <code class="code">none</code> if it is <code class="code"><span class="constructor">None</span></code>. <code class="code">none</code> prints nothing by default.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_print_result" data-type="val pp_print_result [Module Format]" data-language="ocaml">val pp_print_result : ok:(formatter -&gt; 'a -&gt; unit) -&gt;       error:(formatter -&gt; 'e -&gt; unit) -&gt;       formatter -&gt; ('a, 'e) result -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_result ~ok ~error ppf r</code> prints <code class="code">r</code> on <code class="code">ppf</code> using <code class="code">ok</code> if <code class="code">r</code> is <code class="code"><span class="constructor">Ok</span> _</code> and <code class="code">error</code> if <code class="code">r</code> is <code class="code"><span class="constructor">Error</span> _</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALpp_print_either" data-type="val pp_print_either [Module Format]" data-language="ocaml">val pp_print_either : left:(formatter -&gt; 'a -&gt; unit) -&gt;       right:(formatter -&gt; 'b -&gt; unit) -&gt;       formatter -&gt; ('a, 'b) Either.t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pp_print_either ~left ~right ppf e</code> prints <code class="code">e</code> on <code class="code">ppf</code> using <code class="code">left</code> if <code class="code">e</code> is <code class="code"><span class="constructor">Either</span>.<span class="constructor">Left</span> _</code> and <code class="code">right</code> if <code class="code">e</code> is <code class="code"><span class="constructor">Either</span>.<span class="constructor">Right</span> _</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <h2 id="fpp">Formatted pretty-printing</h2>
<p>Module <code class="code"><span class="constructor">Format</span></code> provides a complete set of <code class="code">printf</code> like functions for pretty-printing using format string specifications.</p> <p>Specific annotations may be added in the format strings to give pretty-printing commands to the pretty-printing engine.</p> <p>Those annotations are introduced in the format strings using the <code class="code">@</code> character. For instance, <code class="code">@ </code> means a space break, <code class="code">@,</code> means a cut, <code class="code">@[</code> opens a new box, and <code class="code">@]</code> closes the last open box.</p> <pre id="VALfprintf" data-type="val fprintf [Module Format]" data-language="ocaml">val fprintf : formatter -&gt; ('a, formatter, unit) format -&gt; 'a</pre>
<p><code class="code">fprintf ff fmt arg1 ... argN</code> formats the arguments <code class="code">arg1</code> to <code class="code">argN</code> according to the format string <code class="code">fmt</code>, and outputs the resulting string on the formatter <code class="code">ff</code>.</p> <p>The format string <code class="code">fmt</code> is a character string which contains three types of objects: plain characters and conversion specifications as specified in the <a href="printf.html"><code class="code"><span class="constructor">Printf</span></code></a> module, and pretty-printing indications specific to the <code class="code"><span class="constructor">Format</span></code> module.</p> <p>The pretty-printing indication characters are introduced by a <code class="code">@</code> character, and their meanings are:</p> <ul> <li>
<code class="code">@[</code>: open a pretty-printing box. The type and offset of the box may be optionally specified with the following syntax: the <code class="code">&lt;</code> character, followed by an optional box type indication, then an optional integer offset, and the closing <code class="code">&gt;</code> character. Pretty-printing box type is one of <code class="code">h</code>, <code class="code">v</code>, <code class="code">hv</code>, <code class="code">b</code>, or <code class="code">hov</code>. '<code class="code">h</code>' stands for an 'horizontal' pretty-printing box, '<code class="code">v</code>' stands for a 'vertical' pretty-printing box, '<code class="code">hv</code>' stands for an 'horizontal/vertical' pretty-printing box, '<code class="code">b</code>' stands for an 'horizontal-or-vertical' pretty-printing box demonstrating indentation, '<code class="code">hov</code>' stands a simple 'horizontal-or-vertical' pretty-printing box. For instance, <code class="code">@[&lt;hov 2&gt;</code> opens an 'horizontal-or-vertical' pretty-printing box with indentation 2 as obtained with <code class="code">open_hovbox 2</code>. For more details about pretty-printing boxes, see the various box opening functions <code class="code">open_*box</code>.</li> <li>
<code class="code">@]</code>: close the most recently opened pretty-printing box.</li> <li>
<code class="code">@,</code>: output a 'cut' break hint, as with <code class="code">print_cut ()</code>.</li> <li>
<code class="code">@ </code>: output a 'space' break hint, as with <code class="code">print_space ()</code>.</li> <li>
<code class="code">@;</code>: output a 'full' break hint as with <code class="code">print_break</code>. The <code class="code">nspaces</code> and <code class="code">offset</code> parameters of the break hint may be optionally specified with the following syntax: the <code class="code">&lt;</code> character, followed by an integer <code class="code">nspaces</code> value, then an integer <code class="code">offset</code>, and a closing <code class="code">&gt;</code> character. If no parameters are provided, the full break defaults to a 'space' break hint.</li> <li>
<code class="code">@.</code>: flush the pretty-printer and split the line, as with <code class="code">print_newline ()</code>.</li> <li>
<code class="code">@&lt;n&gt;</code>: print the following item as if it were of length <code class="code">n</code>. Hence, <code class="code">printf <span class="string">"@&lt;0&gt;%s"</span> arg</code> prints <code class="code">arg</code> as a zero length string. If <code class="code">@&lt;n&gt;</code> is not followed by a conversion specification, then the following character of the format is printed as if it were of length <code class="code">n</code>.</li> <li>
<code class="code">@{</code>: open a semantic tag. The name of the tag may be optionally specified with the following syntax: the <code class="code">&lt;</code> character, followed by an optional string specification, and the closing <code class="code">&gt;</code> character. The string specification is any character string that does not contain the closing character <code class="code"><span class="string">'&gt;'</span></code>. If omitted, the tag name defaults to the empty string. For more details about semantic tags, see the functions <a href="format.html#VALopen_stag"><code class="code"><span class="constructor">Format</span>.open_stag</code></a> and <a href="format.html#VALclose_stag"><code class="code"><span class="constructor">Format</span>.close_stag</code></a>.</li> <li>
<code class="code">@}</code>: close the most recently opened semantic tag.</li> <li>
<code class="code">@?</code>: flush the pretty-printer as with <code class="code">print_flush ()</code>. This is equivalent to the conversion <code class="code">%!</code>.</li> <li>
<code class="code">@\n</code>: force a newline, as with <code class="code">force_newline ()</code>, not the normal way of pretty-printing, you should prefer using break hints inside a vertical pretty-printing box.</li> </ul> <p>Note: To prevent the interpretation of a <code class="code">@</code> character as a pretty-printing indication, escape it with a <code class="code">%</code> character. Old quotation mode <code class="code">@@</code> is deprecated since it is not compatible with formatted input interpretation of character <code class="code"><span class="string">'@'</span></code>.</p> <p>Example: <code class="code">printf <span class="string">"@[%s@ %d@]@."</span> <span class="string">"x ="</span> 1</code> is equivalent to <code class="code">open_box (); print_string <span class="string">"x ="</span>; print_space ();<br>
   print_int 1; close_box (); print_newline ()</code>. It prints <code class="code">x = 1</code> within a pretty-printing 'horizontal-or-vertical' box.</p> <pre id="VALprintf" data-type="val printf [Module Format]" data-language="ocaml">val printf : ('a, formatter, unit) format -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">fprintf</code> above, but output on <code class="code">get_std_formatter ()</code>.</p> <p>It is defined similarly to <code class="code"><span class="keyword">fun</span> fmt <span class="keywordsign">-&gt;</span> fprintf (get_std_formatter ()) fmt</code> but delays calling <code class="code">get_std_formatter</code> until after the final argument required by the <code class="code">format</code> is received. When used with multiple domains, the output from the domains will be interleaved with each other at points where the formatter is flushed, such as with <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>.</p> </div> </div> <pre id="VALeprintf" data-type="val eprintf [Module Format]" data-language="ocaml">val eprintf : ('a, formatter, unit) format -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">fprintf</code> above, but output on <code class="code">get_err_formatter ()</code>.</p> <p>It is defined similarly to <code class="code"><span class="keyword">fun</span> fmt <span class="keywordsign">-&gt;</span> fprintf (get_err_formatter ()) fmt</code> but delays calling <code class="code">get_err_formatter</code> until after the final argument required by the <code class="code">format</code> is received. When used with multiple domains, the output from the domains will be interleaved with each other at points where the formatter is flushed, such as with <a href="format.html#VALprint_flush"><code class="code"><span class="constructor">Format</span>.print_flush</code></a>.</p> </div> </div> <pre id="VALsprintf" data-type="val sprintf [Module Format]" data-language="ocaml">val sprintf : ('a, unit, string) format -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">printf</code> above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. Note that the pretty-printer queue is flushed at the end of <em>each call</em> to <code class="code">sprintf</code>. Note that if your format string contains a <code class="code">%a</code>, you should use <code class="code">asprintf</code>.</p> <p>In case of multiple and related calls to <code class="code">sprintf</code> to output material on a single string, you should consider using <code class="code">fprintf</code> with the predefined formatter <code class="code">str_formatter</code> and call <code class="code">flush_str_formatter ()</code> to get the final result.</p> <p>Alternatively, you can use <code class="code"><span class="constructor">Format</span>.fprintf</code> with a formatter writing to a buffer of your own: flushing the formatter and the buffer at the end of pretty-printing returns the desired string.</p> </div> </div> <pre id="VALasprintf" data-type="val asprintf [Module Format]" data-language="ocaml">val asprintf : ('a, formatter, unit, string) format4 -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">printf</code> above, but instead of printing on a formatter, returns a string containing the result of formatting the arguments. The type of <code class="code">asprintf</code> is general enough to interact nicely with <code class="code">%a</code> conversions.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.01</li> </ul> </div> <pre id="VALdprintf" data-type="val dprintf [Module Format]" data-language="ocaml">val dprintf : ('a, formatter, unit, formatter -&gt; unit) format4 -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="format.html#VALfprintf"><code class="code"><span class="constructor">Format</span>.fprintf</code></a>, except the formatter is the last argument. <code class="code">dprintf <span class="string">"..."</span> a b c</code> is a function of type <code class="code">formatter <span class="keywordsign">-&gt;</span> unit</code> which can be given to a format specifier <code class="code">%t</code>.</p> <p>This can be used as a replacement for <a href="format.html#VALasprintf"><code class="code"><span class="constructor">Format</span>.asprintf</code></a> to delay formatting decisions. Using the string returned by <a href="format.html#VALasprintf"><code class="code"><span class="constructor">Format</span>.asprintf</code></a> in a formatting context forces formatting decisions to be taken in isolation, and the final string may be created prematurely. <a href="format.html#VALdprintf"><code class="code"><span class="constructor">Format</span>.dprintf</code></a> allows delay of formatting decisions until the final formatting context is known. For example:</p> <pre class="codepre" data-language="ocaml">  let t = Format.dprintf "%i@ %i@ %i" 1 2 3 in
  ...
  Format.printf "@[&lt;v&gt;%t@]" t
</pre>
</div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALifprintf" data-type="val ifprintf [Module Format]" data-language="ocaml">val ifprintf : formatter -&gt; ('a, formatter, unit) format -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">fprintf</code> above, but does not print anything. Useful to ignore some material when conditionally printing.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.10</li> </ul> </div> <p>Formatted Pretty-Printing with continuations.</p> <pre id="VALkfprintf" data-type="val kfprintf [Module Format]" data-language="ocaml">val kfprintf : (formatter -&gt; 'a) -&gt;       formatter -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">fprintf</code> above, but instead of returning immediately, passes the formatter to its first argument at the end of printing.</p> </div> </div> <pre id="VALkdprintf" data-type="val kdprintf [Module Format]" data-language="ocaml">val kdprintf : ((formatter -&gt; unit) -&gt; 'a) -&gt;       ('b, formatter, unit, 'a) format4 -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="format.html#VALdprintf"><code class="code"><span class="constructor">Format</span>.dprintf</code></a> above, but instead of returning immediately, passes the suspended printer to its first argument at the end of printing.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALikfprintf" data-type="val ikfprintf [Module Format]" data-language="ocaml">val ikfprintf : (formatter -&gt; 'a) -&gt;       formatter -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">kfprintf</code> above, but does not print anything. Useful to ignore some material when conditionally printing.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALksprintf" data-type="val ksprintf [Module Format]" data-language="ocaml">val ksprintf : (string -&gt; 'a) -&gt; ('b, unit, string, 'a) format4 -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">sprintf</code> above, but instead of returning the string, passes it to the first argument.</p> </div> </div> <pre id="VALkasprintf" data-type="val kasprintf [Module Format]" data-language="ocaml">val kasprintf : (string -&gt; 'a) -&gt; ('b, formatter, unit, 'a) format4 -&gt; 'b</pre>
<div class="info "> <div class="info-desc"> <p>Same as <code class="code">asprintf</code> above, but instead of returning the string, passes it to the first argument.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03</li> </ul> </div> <h2 id="examples">Examples</h2> <p>A few warmup examples to get an idea of how Format is used.</p> <p>We have a list <code class="code">l</code> of pairs <code class="code">(int * bool)</code>, which the toplevel prints for us:</p> <pre class="codepre" data-language="ocaml"># let l = List.init 20 (fun n -&gt; n, n mod 2 = 0)
  val l : (int * bool) list =
  [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);
   (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);
   (12, true); (13, false); (14, true); (15, false); (16, true); (17, false);
   (18, true); (19, false)]
 </pre> <p>If we want to print it ourself without the toplevel magic, we can try this:</p> <pre class="codepre" data-language="ocaml">  # let pp_pair out (x,y) = Format.fprintf out "(%d, %b)" x y
  val pp_pair : Format.formatter -&gt; int * bool -&gt; unit = &lt;fun&gt;
  # Format.printf "l: [@[&lt;hov&gt;%a@]]@."
    Format.(pp_print_list ~pp_sep:(fun out () -&gt; fprintf out ";@ ") pp_pair) l
    l: [(0, true); (1, false); (2, true); (3, false); (4, true); (5, false);
        (6, true); (7, false); (8, true); (9, false); (10, true); (11, false);
        (12, true); (13, false); (14, true); (15, false); (16, true);
        (17, false); (18, true); (19, false)]

  </pre> <p>What this does, briefly, is:</p> <ul> <li>
<code class="code">pp_pair</code> prints a pair <code class="code">bool*int</code> surrounded in "(" ")". It takes a formatter (into which formatting happens), and the pair itself. When printing is done it returns <code class="code">()</code>.</li> </ul> <ul> <li>
<code class="code"><span class="constructor">Format</span>.printf <span class="string">"l = [@[&lt;hov&gt;%a@]]@."</span> ... l</code> is like <code class="code">printf</code>, but with additional formatting instructions (denoted with "@"). The pair "<code class="code">@[&lt;hov&gt;</code>" and "<code class="code">@]</code>" is a "horizontal-or-vertical box".</li> </ul> <ul> <li>"@." ends formatting with a newline. It is similar to "\n" but is also aware of the <code class="code"><span class="constructor">Format</span>.formatter</code>'s state. Do not use "\n" with <code class="code"><span class="constructor">Format</span></code>.</li> </ul> <ul> <li>"%a" is a formatting instruction, like "%d" or "%s" for <code class="code">printf</code>. However, where "%d" prints an integer and "%s" prints a string, "%a" takes a printer (of type <code class="code"><span class="constructor">Format</span>.formatter <span class="keywordsign">-&gt;</span> <span class="keywordsign">'</span>a <span class="keywordsign">-&gt;</span> unit</code>) and a value (of type <code class="code"><span class="keywordsign">'</span>a</code>) and applies the printer to the value. This is key to compositionality of printers.</li> </ul> <ul> <li>We build a list printer using <code class="code"><span class="constructor">Format</span>.pp_print_list ~pp_sep:(...) pp_pair</code>. <code class="code">pp_print_list</code> takes an element printer and returns a list printer. The <code class="code">?pp_sep</code> optional argument, if provided, is called in between each element to print a separator.</li> </ul> <ul> <li>Here, for a separator, we use <code class="code">(<span class="keyword">fun</span> out () <span class="keywordsign">-&gt;</span> <span class="constructor">Format</span>.fprintf out <span class="string">";@ "</span>)</code>. It prints ";", and then "@ " which is a breaking space (either it prints " ", or it prints a newline if the box is about to overflow). This "@ " is responsible for the list printing splitting into several lines.</li> </ul> <p>If we omit "@ ", we get an ugly single-line print:</p> <pre class="codepre" data-language="ocaml"># Format.printf "l: [@[&lt;hov&gt;%a@]]@."
      Format.(pp_print_list ~pp_sep:(fun out () -&gt; fprintf out "; ") pp_pair) l
  l: [(0, true); (1, false); (2, true); (* ... *); (18, true); (19, false)]
- : unit = ()
    </pre> <p>Generally, it is good practice to define custom printers for important types in your program. If, for example, you were to define basic geometry types like so:</p> <pre class="codepre" data-language="ocaml">  type point = {
    x: float;
    y: float;
  }

  type rectangle = {
    ll: point; (* lower left *)
    ur: point; (* upper right *)
  }
  </pre> <p>For debugging purpose, or to display information in logs, or on the console, it would be convenient to define printers for these types. Here is an example of to do it. Note that "%.3f" is a <code class="code">float</code> printer up to 3 digits of precision after the dot; "%f" would print as many digits as required, which is somewhat verbose; "%h" is an hexadecimal float printer.</p> <pre class="codepre" data-language="ocaml">  let pp_point out (p:point) =
    Format.fprintf out "{ @[x=%.3f;@ y=%.3f@] }" p.x p.y

  let pp_rectangle out (r:rectangle) =
    Format.fprintf out "{ @[ll=%a;@ ur=%a@] }"
      pp_point r.ll pp_point r.ur
  </pre> <p>In the <code class="code">.mli</code> file, we could have:</p> <pre class="codepre" data-language="ocaml">    val pp_point : Format.formatter -&gt; point -&gt; unit

    val pp_rectangle : Format.formatter -&gt; rectangle -&gt; unit
  </pre> <p>These printers can now be used with "%a" inside other printers.</p> <pre class="codepre" data-language="ocaml"> # Format.printf "some rectangle: %a@."
        (Format.pp_print_option pp_rectangle)
        (Some {ll={x=1.; y=2.}; ur={x=42.; y=500.12345}})
  some rectangle: { l={ x=1.000; y=2.000 }; ur={ x=42.000; y=500.123 } }

  # Format.printf "no rectangle: %a@."
        (Format.pp_option pp_rectangle)
        None
  no rectangle:
  </pre> <p>See how we combine <code class="code">pp_print_option</code> (option printer) and our newly defined rectangle printer, like we did with <code class="code">pp_print_list</code> earlier.</p> <p>For a more extensive tutorial, see <a href="https://caml.inria.fr/resources/doc/guides/format.en.html"> "Using the Format module"</a>.</p> <p>A final note: the <code class="code"><span class="constructor">Format</span></code> module is a starting point. The OCaml ecosystem has libraries that makes formatting easier and more expressive, with more combinators, more concise names, etc. An example of such a library is <a href="https://erratique.ch/software/fmt"> Fmt</a>.</p> <p>Automatic deriving of pretty-printers from type definitions is also possible, using <a href="ppx_deriving.show.html"> https://github.com/ocaml-ppx/ppx_deriving</a> or similar ppx derivers.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/Format.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/Format.html</a>
  </p>
</div>
