<div class="api"> <h1>Module Dynarray</h1> <pre id="MODULEDynarray" data-type="module Dynarray [Module Dynarray]" data-language="ocaml">module Dynarray: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Dynamic arrays.</p> <p>The <a href="array.html"><code class="code"><span class="constructor">Array</span></code></a> module provide arrays of fixed length. <a href="dynarray.html"><code class="code"><span class="constructor">Dynarray</span></code></a> provides arrays whose length can change over time, by adding or removing elements at the end of the array.</p> <p>This is typically used to accumulate elements whose number is not known in advance or changes during computation, while also providing fast access to elements at arbitrary positions.</p> <pre class="codepre" data-language="ocaml">    let dynarray_of_list li =
      let arr = Dynarray.create () in
      List.iter (fun v -&gt; Dynarray.add_last arr v) li;
      arr
</pre> <p>The <a href="buffer.html"><code class="code"><span class="constructor">Buffer</span></code></a> module provides similar features, but it is specialized for accumulating characters into a dynamically-resized string.</p> <p>The <a href="stack.html"><code class="code"><span class="constructor">Stack</span></code></a> module provides a last-in first-out data structure that can be easily implemented on top of dynamic arrays.</p> <p><b>Warning.</b> In their current implementation, the memory layout of dynamic arrays differs from the one of <a href="array.html"><code class="code"><span class="constructor">Array</span></code></a>s. See the <a href="dynarray.html#memory_layout"> Memory Layout</a> section for more information.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.2</li> <li>
<b>Alert unsynchronized_access.</b> Unsynchronized accesses to dynamic arrays are a programming error.</li> </ul> </div>  <p><b>Unsynchronized accesses</b></p> <p>Concurrent accesses to dynamic arrays must be synchronized (for instance with a <a href="mutex.html#TYPEt"><code class="code"><span class="constructor">Mutex</span>.t</code></a>). Unsynchronized accesses to a dynamic array are a programming error that may lead to an invalid dynamic array state, on which some operations would fail with an <code class="code"><span class="constructor">Invalid_argument</span></code> exception.</p> <h2 id="dynarrays">Dynamic arrays</h2> <pre id="TYPEt" data-type="type !'a t [Module Dynarray]" data-language="ocaml">type !'a t </pre> <div class="info "> <div class="info-desc"> <p>A dynamic array containing values of type <code class="code"><span class="keywordsign">'</span>a</code>.</p> <p>A dynamic array <code class="code">a</code> provides constant-time <code class="code">get</code> and <code class="code">set</code> operations on indices between <code class="code">0</code> and <code class="code"><span class="constructor">Dynarray</span>.length a - 1</code> included. Its <a href="dynarray.html#VALlength"><code class="code"><span class="constructor">Dynarray</span>.length</code></a> may change over time by adding or removing elements to the end of the array.</p> <p>We say that an index into a dynarray <code class="code">a</code> is valid if it is in <code class="code">0 .. length a - 1</code> and invalid otherwise.</p> </div> </div> <pre id="VALcreate" data-type="val create [Module Dynarray]" data-language="ocaml">val create : unit -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">create ()</code> is a new, empty array.</p> </div> </div> <pre id="VALmake" data-type="val make [Module Dynarray]" data-language="ocaml">val make : int -&gt; 'a -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make n x</code> is a new array of length <code class="code">n</code>, filled with <code class="code">x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; <span class="constructor">Sys</span>.max_array_length</code>.</li> </ul> </div> <pre id="VALinit" data-type="val init [Module Dynarray]" data-language="ocaml">val init : int -&gt; (int -&gt; 'a) -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">init n f</code> is a new array <code class="code">a</code> of length <code class="code">n</code>, such that <code class="code">get a i</code> is <code class="code">f i</code>. In other words, the elements of <code class="code">a</code> are <code class="code">f 0</code>, then <code class="code">f 1</code>, then <code class="code">f 2</code>... and <code class="code">f (n - 1)</code> last, evaluated in that order.</p> <p>This is similar to <a href="array.html#VALinit"><code class="code"><span class="constructor">Array</span>.init</code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; <span class="constructor">Sys</span>.max_array_length</code>.</li> </ul> </div> <pre id="VALget" data-type="val get [Module Dynarray]" data-language="ocaml">val get : 'a t -&gt; int -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get a i</code> is the <code class="code">i</code>-th element of <code class="code">a</code>, starting with index <code class="code">0</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the index is invalid</li> </ul> </div> <pre id="VALset" data-type="val set [Module Dynarray]" data-language="ocaml">val set : 'a t -&gt; int -&gt; 'a -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set a i x</code> sets the <code class="code">i</code>-th element of <code class="code">a</code> to be <code class="code">x</code>.</p> <p><code class="code">i</code> must be a valid index. <code class="code">set</code> does not add new elements to the array -- see <a href="dynarray.html#VALadd_last"><code class="code"><span class="constructor">Dynarray</span>.add_last</code></a> to add an element.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the index is invalid.</li> </ul> </div> <pre id="VALlength" data-type="val length [Module Dynarray]" data-language="ocaml">val length : 'a t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">length a</code> is the number of elements in the array.</p> </div> </div> <pre id="VALis_empty" data-type="val is_empty [Module Dynarray]" data-language="ocaml">val is_empty : 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_empty a</code> is <code class="code"><span class="keyword">true</span></code> if <code class="code">a</code> is empty, that is, if <code class="code">length a = 0</code>.</p> </div> </div> <pre id="VALget_last" data-type="val get_last [Module Dynarray]" data-language="ocaml">val get_last : 'a t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_last a</code> is the element of <code class="code">a</code> at index <code class="code">length a - 1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">a</code> is empty.</li> </ul> </div> <pre id="VALfind_last" data-type="val find_last [Module Dynarray]" data-language="ocaml">val find_last : 'a t -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_last a</code> is <code class="code"><span class="constructor">None</span></code> if <code class="code">a</code> is empty and <code class="code"><span class="constructor">Some</span> (get_last a)</code> otherwise.</p> </div> </div> <pre id="VALcopy" data-type="val copy [Module Dynarray]" data-language="ocaml">val copy : 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">copy a</code> is a shallow copy of <code class="code">a</code>, a new array containing the same elements as <code class="code">a</code>.</p> </div> </div> <h2 id="adding">Adding elements</h2> <p>Note: all operations adding elements raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the length needs to grow beyond <a href="sys.html#VALmax_array_length"><code class="code"><span class="constructor">Sys</span>.max_array_length</code></a>.</p> <pre id="VALadd_last" data-type="val add_last [Module Dynarray]" data-language="ocaml">val add_last : 'a t -&gt; 'a -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">add_last a x</code> adds the element <code class="code">x</code> at the end of the array <code class="code">a</code>.</p> </div> </div> <pre id="VALappend_array" data-type="val append_array [Module Dynarray]" data-language="ocaml">val append_array : 'a t -&gt; 'a array -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">append_array a b</code> adds all elements of <code class="code">b</code> at the end of <code class="code">a</code>, in the order they appear in <code class="code">b</code>.</p> <p>For example:</p> <pre class="codepre" data-language="ocaml">      let a = Dynarray.of_list [1;2] in
      Dynarray.append_array a [|3; 4|];
      assert (Dynarray.to_list a = [1; 2; 3; 4])
    </pre>
</div> </div> <pre id="VALappend_list" data-type="val append_list [Module Dynarray]" data-language="ocaml">val append_list : 'a t -&gt; 'a list -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Like <a href="dynarray.html#VALappend_array"><code class="code"><span class="constructor">Dynarray</span>.append_array</code></a> but with a list.</p> </div> </div> <pre id="VALappend" data-type="val append [Module Dynarray]" data-language="ocaml">val append : 'a t -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">append a b</code> is like <code class="code">append_array a b</code>, but <code class="code">b</code> is itself a dynamic array instead of a fixed-size array.</p> <p>Warning: <code class="code">append a a</code> is a programming error because it iterates on <code class="code">a</code> and adds elements to it at the same time -- see the <a href="dynarray.html#iteration"> Iteration</a> section below. It fails with <code class="code"><span class="constructor">Invalid_argument</span></code>. If you really want to append a copy of <code class="code">a</code> to itself, you can use <code class="code"><span class="constructor">Dynarray</span>.append_array a (<span class="constructor">Dynarray</span>.to_array a)</code> which copies <code class="code">a</code> into a temporary array.</p> </div> </div> <pre id="VALappend_seq" data-type="val append_seq [Module Dynarray]" data-language="ocaml">val append_seq : 'a t -&gt; 'a Seq.t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Like <a href="dynarray.html#VALappend_array"><code class="code"><span class="constructor">Dynarray</span>.append_array</code></a> but with a sequence.</p> <p>Warning: <code class="code">append_seq a (to_seq_reentrant a)</code> simultaneously traverses <code class="code">a</code> and adds element to it; the ordering of those operations is unspecified, and may result in an infinite loop -- the new elements may in turn be produced by <code class="code">to_seq_reentrant a</code> and get added again and again.</p> </div> </div> <pre id="VALappend_iter" data-type="val append_iter [Module Dynarray]" data-language="ocaml">val append_iter : 'a t -&gt; (('a -&gt; unit) -&gt; 'x -&gt; unit) -&gt; 'x -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">append_iter a iter x</code> adds each element of <code class="code">x</code> to the end of <code class="code">a</code>. This is <code class="code">iter (add_last a) x</code>.</p> <p>For example, <code class="code">append_iter a <span class="constructor">List</span>.iter [1;2;3]</code> would add elements <code class="code">1</code>, <code class="code">2</code>, and then <code class="code">3</code> at the end of <code class="code">a</code>. <code class="code">append_iter a <span class="constructor">Queue</span>.iter q</code> adds elements from the queue <code class="code">q</code>.</p> </div> </div> <h2 id="removing">Removing elements</h2> <pre id="VALpop_last_opt" data-type="val pop_last_opt [Module Dynarray]" data-language="ocaml">val pop_last_opt : 'a t -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pop_last_opt a</code> removes and returns the last element of <code class="code">a</code>, or <code class="code"><span class="constructor">None</span></code> if the array is empty.</p> </div> </div> <pre id="VALpop_last" data-type="val pop_last [Module Dynarray]" data-language="ocaml">val pop_last : 'a t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">pop_last a</code> removes and returns the last element of <code class="code">a</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> on an empty array.</li> </ul> </div> <pre id="VALremove_last" data-type="val remove_last [Module Dynarray]" data-language="ocaml">val remove_last : 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">remove_last a</code> removes the last element of <code class="code">a</code>, if any. It does nothing if <code class="code">a</code> is empty.</p> </div> </div> <pre id="VALtruncate" data-type="val truncate [Module Dynarray]" data-language="ocaml">val truncate : 'a t -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">truncate a n</code> truncates <code class="code">a</code> to have at most <code class="code">n</code> elements.</p> <p>It removes elements whose index is greater or equal to <code class="code">n</code>. It does nothing if <code class="code">n &gt;= length a</code>.</p> <p><code class="code">truncate a n</code> is equivalent to:</p> <pre class="codepre" data-language="ocaml">      if n &lt; 0 then invalid_argument "...";
      while length a &gt; n do
        remove_last a
      done
    </pre>
</div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code>.</li> </ul> </div> <pre id="VALclear" data-type="val clear [Module Dynarray]" data-language="ocaml">val clear : 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">clear a</code> is <code class="code">truncate a 0</code>, it removes all the elements of <code class="code">a</code>.</p> </div> </div> <h2 id="iteration">Iteration</h2> <p>The iteration functions traverse the elements of a dynamic array. Traversals of <code class="code">a</code> are computed in increasing index order: from the element of index <code class="code">0</code> to the element of index <code class="code">length a - 1</code>.</p> <p>It is a programming error to change the length of an array (by adding or removing elements) during an iteration on the array. Any iteration function will fail with <code class="code"><span class="constructor">Invalid_argument</span></code> if it detects such a length change.</p> <pre id="VALiter" data-type="val iter [Module Dynarray]" data-language="ocaml">val iter : ('a -&gt; unit) -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter f a</code> calls <code class="code">f</code> on each element of <code class="code">a</code>.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module Dynarray]" data-language="ocaml">val iteri : (int -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iteri f a</code> calls <code class="code">f i x</code> for each <code class="code">x</code> at index <code class="code">i</code> in <code class="code">a</code>.</p> </div> </div> <pre id="VALmap" data-type="val map [Module Dynarray]" data-language="ocaml">val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map f a</code> is a new array of elements of the form <code class="code">f x</code> for each element <code class="code">x</code> of <code class="code">a</code>.</p> <p>For example, if the elements of <code class="code">a</code> are <code class="code">x0</code>, <code class="code">x1</code>, <code class="code">x2</code>, then the elements of <code class="code">b</code> are <code class="code">f x0</code>, <code class="code">f x1</code>, <code class="code">f x2</code>.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module Dynarray]" data-language="ocaml">val mapi : (int -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mapi f a</code> is a new array of elements of the form <code class="code">f i x</code> for each element <code class="code">x</code> of <code class="code">a</code> at index <code class="code">i</code>.</p> <p>For example, if the elements of <code class="code">a</code> are <code class="code">x0</code>, <code class="code">x1</code>, <code class="code">x2</code>, then the elements of <code class="code">b</code> are <code class="code">f 0 x0</code>, <code class="code">f 1 x1</code>, <code class="code">f 2 x2</code>.</p> </div> </div> <pre id="VALfold_left" data-type="val fold_left [Module Dynarray]" data-language="ocaml">val fold_left : ('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc -&gt; 'a t -&gt; 'acc</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left f acc a</code> folds <code class="code">f</code> over <code class="code">a</code> in order, starting with accumulator <code class="code">acc</code>.</p> <p>For example, if the elements of <code class="code">a</code> are <code class="code">x0</code>, <code class="code">x1</code>, then <code class="code">fold f acc a</code> is</p> <pre class="codepre" data-language="ocaml">      let acc = f acc x0 in
      let acc = f acc x1 in
      acc
    </pre>
</div> </div> <pre id="VALfold_right" data-type="val fold_right [Module Dynarray]" data-language="ocaml">val fold_right : ('a -&gt; 'acc -&gt; 'acc) -&gt; 'a t -&gt; 'acc -&gt; 'acc</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_right f a acc</code> computes <code class="code">f x0 (f x1 (... (f xn acc) ...))</code> where <code class="code">x0</code>, <code class="code">x1</code>, ..., <code class="code">xn</code> are the elements of <code class="code">a</code>.</p> </div> </div> <pre id="VALexists" data-type="val exists [Module Dynarray]" data-language="ocaml">val exists : ('a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists f a</code> is <code class="code"><span class="keyword">true</span></code> if some element of <code class="code">a</code> satisfies <code class="code">f</code>.</p> <p>For example, if the elements of <code class="code">a</code> are <code class="code">x0</code>, <code class="code">x1</code>, <code class="code">x2</code>, then <code class="code">exists f a</code> is <code class="code">f x0 <span class="keywordsign">||</span> f x1 <span class="keywordsign">||</span> f x2</code>.</p> </div> </div> <pre id="VALfor_all" data-type="val for_all [Module Dynarray]" data-language="ocaml">val for_all : ('a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all f a</code> is <code class="code"><span class="keyword">true</span></code> if all elements of <code class="code">a</code> satisfy <code class="code">f</code>. This includes the case where <code class="code">a</code> is empty.</p> <p>For example, if the elements of <code class="code">a</code> are <code class="code">x0</code>, <code class="code">x1</code>, then <code class="code">exists f a</code> is <code class="code">f x0 <span class="keywordsign">&amp;&amp;</span> f x1 <span class="keywordsign">&amp;&amp;</span> f x2</code>.</p> </div> </div> <pre id="VALfilter" data-type="val filter [Module Dynarray]" data-language="ocaml">val filter : ('a -&gt; bool) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter f a</code> is a new array of all the elements of <code class="code">a</code> that satisfy <code class="code">f</code>. In other words, it is an array <code class="code">b</code> such that, for each element <code class="code">x</code> in <code class="code">a</code> in order, <code class="code">x</code> is added to <code class="code">b</code> if <code class="code">f x</code> is <code class="code"><span class="keyword">true</span></code>.</p> <p>For example, <code class="code">filter (<span class="keyword">fun</span> x <span class="keywordsign">-&gt;</span> x &gt;= 0) a</code> is a new array of all non-negative elements of <code class="code">a</code>, in order.</p> </div> </div> <pre id="VALfilter_map" data-type="val filter_map [Module Dynarray]" data-language="ocaml">val filter_map : ('a -&gt; 'b option) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter_map f a</code> is a new array of elements <code class="code">y</code> such that <code class="code">f x</code> is <code class="code"><span class="constructor">Some</span> y</code> for an element <code class="code">x</code> of <code class="code">a</code>. In others words, it is an array <code class="code">b</code> such that, for each element <code class="code">x</code> of <code class="code">a</code> in order:</p> <ul> <li>if <code class="code">f x = <span class="constructor">Some</span> y</code>, then <code class="code">y</code> is added to <code class="code">b</code>,</li> <li>if <code class="code">f x = <span class="constructor">None</span></code>, then no element is added to <code class="code">b</code>.</li> </ul> <p>For example, <code class="code">filter_map int_of_string_opt inputs</code> returns a new array of integers read from the strings in <code class="code">inputs</code>, ignoring strings that cannot be converted to integers.</p> </div> </div> <h2 id="conversions">Conversions to other data structures</h2> <p>Note: the <code class="code">of_*</code> functions raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the length needs to grow beyond <a href="sys.html#VALmax_array_length"><code class="code"><span class="constructor">Sys</span>.max_array_length</code></a>.</p> <p>The <code class="code">to_*</code> functions, except those specifically marked "reentrant", iterate on their dynarray argument. In particular it is a programming error if the length of the dynarray changes during their execution, and the conversion functions raise <code class="code"><span class="constructor">Invalid_argument</span></code> if they observe such a change.</p> <pre id="VALof_array" data-type="val of_array [Module Dynarray]" data-language="ocaml">val of_array : 'a array -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_array arr</code> returns a dynamic array corresponding to the fixed-sized array <code class="code">a</code>. Operates in <code class="code"><span class="constructor">O</span>(n)</code> time by making a copy.</p> </div> </div> <pre id="VALto_array" data-type="val to_array [Module Dynarray]" data-language="ocaml">val to_array : 'a t -&gt; 'a array</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_array a</code> returns a fixed-sized array corresponding to the dynamic array <code class="code">a</code>. This always allocate a new array and copies elements into it.</p> </div> </div> <pre id="VALof_list" data-type="val of_list [Module Dynarray]" data-language="ocaml">val of_list : 'a list -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_list l</code> is the array containing the elements of <code class="code">l</code> in the same order.</p> </div> </div> <pre id="VALto_list" data-type="val to_list [Module Dynarray]" data-language="ocaml">val to_list : 'a t -&gt; 'a list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_list a</code> is a list with the elements contained in the array <code class="code">a</code>.</p> </div> </div> <pre id="VALof_seq" data-type="val of_seq [Module Dynarray]" data-language="ocaml">val of_seq : 'a Seq.t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_seq seq</code> is an array containing the same elements as <code class="code">seq</code>.</p> <p>It traverses <code class="code">seq</code> once and will terminate only if <code class="code">seq</code> is finite.</p> </div> </div> <pre id="VALto_seq" data-type="val to_seq [Module Dynarray]" data-language="ocaml">val to_seq : 'a t -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_seq a</code> is the sequence of elements <code class="code">get a 0</code>, <code class="code">get a 1</code>... <code class="code">get a (length a - 1)</code>.</p> </div> </div> <pre id="VALto_seq_reentrant" data-type="val to_seq_reentrant [Module Dynarray]" data-language="ocaml">val to_seq_reentrant : 'a t -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_seq_reentrant a</code> is a reentrant variant of <a href="dynarray.html#VALto_seq"><code class="code"><span class="constructor">Dynarray</span>.to_seq</code></a>, in the sense that one may still access its elements after the length of <code class="code">a</code> has changed.</p> <p>Demanding the <code class="code">i</code>-th element of the resulting sequence (which can happen zero, one or several times) will access the <code class="code">i</code>-th element of <code class="code">a</code> at the time of the demand. The sequence stops if <code class="code">a</code> has less than <code class="code">i</code> elements at this point.</p> </div> </div> <pre id="VALto_seq_rev" data-type="val to_seq_rev [Module Dynarray]" data-language="ocaml">val to_seq_rev : 'a t -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_seq_rev a</code> is the sequence of elements <code class="code">get a (l - 1)</code>, <code class="code">get a (l - 2)</code>... <code class="code">get a 0</code>, where <code class="code">l</code> is <code class="code">length a</code> at the time <code class="code">to_seq_rev</code> is invoked.</p> </div> </div> <pre id="VALto_seq_rev_reentrant" data-type="val to_seq_rev_reentrant [Module Dynarray]" data-language="ocaml">val to_seq_rev_reentrant : 'a t -&gt; 'a Seq.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_seq_rev_reentrant a</code> is a reentrant variant of <a href="dynarray.html#VALto_seq_rev"><code class="code"><span class="constructor">Dynarray</span>.to_seq_rev</code></a>, in the sense that one may still access its elements after the length of <code class="code">a</code> has changed.</p> <p>Elements that have been removed from the array by the time they are demanded in the sequence are skipped.</p> </div> </div> <h2 id="advanced">Advanced topics for performance</h2>
<h3 id="capacity">Backing array, capacity</h3> <p>Internally, a dynamic array uses a <b>backing array</b> (a fixed-size array as provided by the <a href="array.html"><code class="code"><span class="constructor">Array</span></code></a> module) whose length is greater or equal to the length of the dynamic array. We define the <b> capacity</b> of a dynamic array as the length of its backing array.</p> <p>The capacity of a dynamic array is relevant in advanced scenarios, when reasoning about the performance of dynamic array programs:</p> <ul> <li>The memory usage of a dynamic array is proportional to its capacity, rather than its length.</li> <li>When there is no empty space left at the end of the backing array, adding elements requires allocating a new, larger backing array.</li> </ul> <p>The implementation uses a standard exponential reallocation strategy which guarantees amortized constant-time operation; in particular, the total capacity of all backing arrays allocated over the lifetime of a dynamic array is at worst proportional to the total number of elements added.</p> <p>In other words, users need not care about capacity and reallocations, and they will get reasonable behavior by default. However, in some performance-sensitive scenarios the functions below can help control memory usage or guarantee an optimal number of reallocations.</p> <pre id="VALcapacity" data-type="val capacity [Module Dynarray]" data-language="ocaml">val capacity : 'a t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">capacity a</code> is the length of <code class="code">a</code>'s backing array.</p> </div> </div> <pre id="VALensure_capacity" data-type="val ensure_capacity [Module Dynarray]" data-language="ocaml">val ensure_capacity : 'a t -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">ensure_capacity a n</code> makes sure that the capacity of <code class="code">a</code> is at least <code class="code">n</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the requested capacity is outside the range <code class="code">0 .. <span class="constructor">Sys</span>.max_array_length</code>. An example would be to reimplement <a href="dynarray.html#VALof_array"><code class="code"><span class="constructor">Dynarray</span>.of_array</code></a> without using <a href="dynarray.html#VALinit"><code class="code"><span class="constructor">Dynarray</span>.init</code></a>: <pre class="codepre" data-language="ocaml">    let of_array arr =
      let a = Dynarray.create () in
      Dynarray.ensure_capacity a (Array.length arr);
      Array.iter (fun v -&gt; add_last a v) arr
    </pre> Using <code class="code">ensure_capacity</code> guarantees that at most one reallocation will take place, instead of possibly several. Without this <code class="code">ensure_capacity</code> hint, the number of resizes would be logarithmic in the length of <code class="code">arr</code>, creating a constant-factor slowdown noticeable when <code class="code">arr</code> is large.</li> </ul> </div> <pre id="VALensure_extra_capacity" data-type="val ensure_extra_capacity [Module Dynarray]" data-language="ocaml">val ensure_extra_capacity : 'a t -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">ensure_extra_capacity a n</code> is <code class="code">ensure_capacity a (length a + n)</code>, it makes sure that <code class="code">a</code> has room for <code class="code">n</code> extra items.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the total requested capacity is outside the range <code class="code">0 .. <span class="constructor">Sys</span>.max_array_length</code>. A use case would be to implement <a href="dynarray.html#VALappend_array"><code class="code"><span class="constructor">Dynarray</span>.append_array</code></a>: <pre class="codepre" data-language="ocaml">    let append_array a arr =
      ensure_extra_capacity a (Array.length arr);
      Array.iter (fun v -&gt; add_last a v) arr
    </pre>
</li> </ul> </div> <pre id="VALfit_capacity" data-type="val fit_capacity [Module Dynarray]" data-language="ocaml">val fit_capacity : 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fit_capacity a</code> reallocates a backing array if necessary, so that the resulting capacity is exactly <code class="code">length a</code>, with no additional empty space at the end. This can be useful to make sure there is no memory wasted on a long-lived array.</p> <p>Note that calling <code class="code">fit_capacity</code> breaks the amortized complexity guarantees provided by the default reallocation strategy. Calling it repeatedly on an array may have quadratic complexity, both in time and in total number of words allocated.</p> <p>If you know that a dynamic array has reached its final length, which will remain fixed in the future, it is sufficient to call <code class="code">to_array</code> and only keep the resulting fixed-size array. <code class="code">fit_capacity</code> is useful when you need to keep a dynamic array for eventual future resizes.</p> </div> </div> <pre id="VALset_capacity" data-type="val set_capacity [Module Dynarray]" data-language="ocaml">val set_capacity : 'a t -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_capacity a n</code> reallocates a backing array if necessary, so that the resulting capacity is exactly <code class="code">n</code>. In particular, all elements of index <code class="code">n</code> or greater are removed.</p> <p>Like <a href="dynarray.html#VALfit_capacity"><code class="code"><span class="constructor">Dynarray</span>.fit_capacity</code></a>, this function breaks the amortized complexity guarantees provided by the reallocation strategy. Calling it repeatedly on an array may have quadratic complexity, both in time and in total number of words allocated.</p> <p>This is an advanced function; in particular, <a href="dynarray.html#VALensure_capacity"><code class="code"><span class="constructor">Dynarray</span>.ensure_capacity</code></a> should be preferred to increase the capacity, as it preserves those amortized guarantees.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code>.</li> </ul> </div> <pre id="VALreset" data-type="val reset [Module Dynarray]" data-language="ocaml">val reset : 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">reset a</code> clears <code class="code">a</code> and replaces its backing array by an empty array.</p> <p>It is equivalent to <code class="code">set_capacity a 0</code> or <code class="code">clear a; fit_capacity a</code>.</p> </div> </div> <h3 id="noleaks">No leaks: preservation of memory liveness</h3> <p>The user-provided values reachable from a dynamic array <code class="code">a</code> are exactly the elements in the positions <code class="code">0</code> to <code class="code">length a - 1</code>. In particular, no user-provided values are "leaked" by being present in the backing array in position <code class="code">length a</code> or later.</p> <h3 id="memory_layout">Memory layout of dynarrays</h3> <p>In the current implementation, the backing array of an <code class="code"><span class="keywordsign">'</span>a <span class="constructor">Dynarray</span>.t</code> is not an <code class="code"><span class="keywordsign">'</span>a array</code>, but something with the same representation as an <code class="code"><span class="keywordsign">'</span>a option array</code> or <code class="code"><span class="keywordsign">'</span>a ref array</code>. Each element is in a "box", allocated when the element is first added to the array -- see the implementation for more details.</p> <p>Using an <code class="code"><span class="keywordsign">'</span>a array</code> would be delicate, as there is no obvious type-correct way to represent the empty space at the end of the backing array -- using user-provided values would either complicate the API or violate the <a href="dynarray.html#noleaks">no leaks</a> guarantee. The constraint of remaining memory-safe under unsynchronized concurrent usage makes it even more difficult. Various unsafe ways to do this have been discussed, with no consensus on a standard implementation so far.</p> <p>On a realistic automated-theorem-proving program that relies heavily on dynamic arrays, we measured the overhead of this extra "boxing" as at most 25%. We believe that the overhead for most uses of dynarray is much smaller, negligible in many cases, but you may still prefer to use your own specialized implementation for performance. (If you know that you do not need the <a href="noleaks.html">no leaks</a> guarantee, you can also speed up deleting elements.)</p> <h2 id="examples">Code examples</h2> <h3 id="example_min_heap">Min-heaps for mutable priority queues</h3> <p>We can use dynamic arrays to implement a mutable priority queue. A priority queue provides a function to add elements, and a function to extract the minimum element -- according to some comparison function.</p> <pre class="codepre" data-language="ocaml">(* We present our priority queues as a functor
   parametrized on the comparison function. *)
module Heap (Elem : Map.OrderedType) : sig
  type t
  val create : unit -&gt; t
  val add : t -&gt; Elem.t -&gt; unit
  val pop_min : t -&gt; Elem.t option
end = struct

  (* Our priority queues are implemented using the standard "min heap"
     data structure, a dynamic array representing a binary tree. *)
  type t = Elem.t Dynarray.t
  let create = Dynarray.create

 (* The node of index [i] has as children the nodes of index [2 * i + 1]
    and [2 * i + 2] -- if they are valid indices in the dynarray. *)
  let left_child i = 2 * i + 1
  let right_child i = 2 * i + 2
  let parent_node i = (i - 1) / 2

  (* We use indexing operators for convenient notations. *)
  let ( .!() ) = Dynarray.get
  let ( .!()&lt;- ) = Dynarray.set

  (* Auxiliary functions to compare and swap two elements
     in the dynamic array. *)
  let order h i j =
    Elem.compare h.!(i) h.!(j)

  let swap h i j =
    let v = h.!(i) in
    h.!(i) &lt;- h.!(j);
    h.!(j) &lt;- v

  (* We say that a heap respects the "heap ordering" if the value of
     each node is smaller than the value of its children. The
     algorithm manipulates arrays that respect the heap algorithm,
     except for one node whose value may be too small or too large.

     The auxiliary functions [heap_up] and [heap_down] take
     such a misplaced value, and move it "up" (respectively: "down")
     the tree by permuting it with its parent value (respectively:
     a child value) until the heap ordering is restored. *)

  let rec heap_up h i =
    if i = 0 then () else
    let parent = parent_node i in
    if order h i parent &lt; 0 then
      (swap h i parent; heap_up h parent)

  and heap_down h ~len i =
    let left, right = left_child i, right_child i in
    if left &gt;= len then () (* no child, stop *) else
    let smallest =
      if right &gt;= len then left (* no right child *) else
      if order h left right &lt; 0 then left else right
    in
    if order h i smallest &gt; 0 then
      (swap h i smallest; heap_down h ~len smallest)

  let add h s =
    let i = Dynarray.length h in
    Dynarray.add_last h s;
    heap_up h i

  let pop_min h =
    if Dynarray.is_empty h then None
    else begin
      (* Standard trick: swap the 'best' value at index 0
         with the last value of the array. *)
      let last = Dynarray.length h - 1 in
      swap h 0 last;
      (* At this point [pop_last] returns the 'best' value,
         and leaves a heap with one misplaced element at position 0. *)
      let best = Dynarray.pop_last h in
      (* Restore the heap ordering -- does nothing if the heap is empty. *)
      heap_down h ~len:last 0;
      Some best
    end
end
</pre> <p>The production code from which this example was inspired includes logic to free the backing array when the heap becomes empty, only in the case where the capacity is above a certain threshold. This can be done by calling the following function from <code class="code">pop</code>:</p> <pre class="codepre" data-language="ocaml">let shrink h =
  if Dynarray.length h = 0 &amp;&amp; Dynarray.capacity h &gt; 1 lsl 18 then
    Dynarray.reset h
</pre> <p>The <code class="code"><span class="constructor">Heap</span></code> functor can be used to implement a sorting function, by adding all elements into a priority queue and then extracting them in order.</p> <pre class="codepre" data-language="ocaml">let heap_sort (type a) cmp li =
  let module Heap = Heap(struct type t = a let compare = cmp end) in
  let heap = Heap.create () in
  List.iter (Heap.add heap) li;
  List.map (fun _ -&gt; Heap.pop_min heap |&gt; Option.get) li
</pre> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/Dynarray.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/Dynarray.html</a>
  </p>
</div>
