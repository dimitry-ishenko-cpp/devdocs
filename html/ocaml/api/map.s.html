<div class="api"> <h1>Module type Map.S</h1> <pre id="MODULETYPES" data-type="module type S [Module type Map.S]" data-language="ocaml">module type S = sig .. end</pre>
<div class="info modtype top"> <div class="info-desc"> <p>Output signature of the functor <a href="map.make.html"><code class="code"><span class="constructor">Map</span>.<span class="constructor">Make</span></code></a>.</p> </div> </div>  <h2 id="maps">Maps</h2> <pre id="TYPEkey" data-type="type key [Module type Map.S]" data-language="ocaml">type key </pre> <div class="info "> <div class="info-desc"> <p>The type of the map keys.</p> </div> </div> <pre id="TYPEt" data-type="type !+'a t [Module type Map.S]" data-language="ocaml">type !+'a t </pre> <div class="info "> <div class="info-desc"> <p>The type of maps from type <code class="code">key</code> to type <code class="code"><span class="keywordsign">'</span>a</code>.</p> </div> </div> <pre id="VALempty" data-type="val empty [Module type Map.S]" data-language="ocaml">val empty : 'a t</pre>
<div class="info "> <div class="info-desc"> <p>The empty map.</p> </div> </div> <pre id="VALadd" data-type="val add [Module type Map.S]" data-language="ocaml">val add : key -&gt; 'a -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">add key data m</code> returns a map containing the same bindings as <code class="code">m</code>, plus a binding of <code class="code">key</code> to <code class="code">data</code>. If <code class="code">key</code> was already bound in <code class="code">m</code> to a value that is physically equal to <code class="code">data</code>, <code class="code">m</code> is returned unchanged (the result of the function is then physically equal to <code class="code">m</code>). Otherwise, the previous binding of <code class="code">key</code> in <code class="code">m</code> disappears.</p> </div> <ul class="info-attributes"> <li>
<b>Before 4.03 </b> Physical equality was not ensured.</li> </ul> </div> <pre id="VALadd_to_list" data-type="val add_to_list [Module type Map.S]" data-language="ocaml">val add_to_list : key -&gt; 'a -&gt; 'a list t -&gt; 'a list t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">add_to_list key data m</code> is <code class="code">m</code> with <code class="code">key</code> mapped to <code class="code">l</code> such that <code class="code">l</code> is <code class="code">data :: <span class="constructor">Map</span>.find key m</code> if <code class="code">key</code> was bound in <code class="code">m</code> and <code class="code">[v]</code> otherwise.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.1</li> </ul> </div> <pre id="VALupdate" data-type="val update [Module type Map.S]" data-language="ocaml">val update : key -&gt; ('a option -&gt; 'a option) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">update key f m</code> returns a map containing the same bindings as <code class="code">m</code>, except for the binding of <code class="code">key</code>. Depending on the value of <code class="code">y</code> where <code class="code">y</code> is <code class="code">f (find_opt key m)</code>, the binding of <code class="code">key</code> is added, removed or updated. If <code class="code">y</code> is <code class="code"><span class="constructor">None</span></code>, the binding is removed if it exists; otherwise, if <code class="code">y</code> is <code class="code"><span class="constructor">Some</span> z</code> then <code class="code">key</code> is associated to <code class="code">z</code> in the resulting map. If <code class="code">key</code> was already bound in <code class="code">m</code> to a value that is physically equal to <code class="code">z</code>, <code class="code">m</code> is returned unchanged (the result of the function is then physically equal to <code class="code">m</code>).</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.06</li> </ul> </div> <pre id="VALsingleton" data-type="val singleton [Module type Map.S]" data-language="ocaml">val singleton : key -&gt; 'a -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">singleton x y</code> returns the one-element map that contains a binding <code class="code">y</code> for <code class="code">x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALremove" data-type="val remove [Module type Map.S]" data-language="ocaml">val remove : key -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">remove x m</code> returns a map containing the same bindings as <code class="code">m</code>, except for <code class="code">x</code> which is unbound in the returned map. If <code class="code">x</code> was not in <code class="code">m</code>, <code class="code">m</code> is returned unchanged (the result of the function is then physically equal to <code class="code">m</code>).</p> </div> <ul class="info-attributes"> <li>
<b>Before 4.03 </b> Physical equality was not ensured.</li> </ul> </div> <pre id="VALmerge" data-type="val merge [Module type Map.S]" data-language="ocaml">val merge : (key -&gt; 'a option -&gt; 'b option -&gt; 'c option) -&gt;       'a t -&gt; 'b t -&gt; 'c t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">merge f m1 m2</code> computes a map whose keys are a subset of the keys of <code class="code">m1</code> and of <code class="code">m2</code>. The presence of each such binding, and the corresponding value, is determined with the function <code class="code">f</code>. In terms of the <code class="code">find_opt</code> operation, we have <code class="code">find_opt x (merge f m1 m2) = f x (find_opt x m1) (find_opt x m2)</code> for any key <code class="code">x</code>, provided that <code class="code">f x <span class="constructor">None</span> <span class="constructor">None</span> = <span class="constructor">None</span></code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALunion" data-type="val union [Module type Map.S]" data-language="ocaml">val union : (key -&gt; 'a -&gt; 'a -&gt; 'a option) -&gt;       'a t -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">union f m1 m2</code> computes a map whose keys are a subset of the keys of <code class="code">m1</code> and of <code class="code">m2</code>. When the same binding is defined in both arguments, the function <code class="code">f</code> is used to combine them. This is a special case of <code class="code">merge</code>: <code class="code">union f m1 m2</code> is equivalent to <code class="code">merge f' m1 m2</code>, where</p> <ul> <li><code class="code">f' _key <span class="constructor">None</span> <span class="constructor">None</span> = <span class="constructor">None</span></code></li> <li><code class="code">f' _key (<span class="constructor">Some</span> v) <span class="constructor">None</span> = <span class="constructor">Some</span> v</code></li> <li><code class="code">f' _key <span class="constructor">None</span> (<span class="constructor">Some</span> v) = <span class="constructor">Some</span> v</code></li> <li><code class="code">f' key (<span class="constructor">Some</span> v1) (<span class="constructor">Some</span> v2) = f key v1 v2</code></li> </ul> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03</li> </ul> </div> <pre id="VALcardinal" data-type="val cardinal [Module type Map.S]" data-language="ocaml">val cardinal : 'a t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the number of bindings of a map.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <h2 id="bindings">Bindings</h2> <pre id="VALbindings" data-type="val bindings [Module type Map.S]" data-language="ocaml">val bindings : 'a t -&gt; (key * 'a) list</pre>
<div class="info "> <div class="info-desc"> <p>Return the list of all bindings of the given map. The returned list is sorted in increasing order of keys with respect to the ordering <code class="code"><span class="constructor">Ord</span>.compare</code>, where <code class="code"><span class="constructor">Ord</span></code> is the argument given to <a href="map.make.html"><code class="code"><span class="constructor">Map</span>.<span class="constructor">Make</span></code></a>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALmin_binding" data-type="val min_binding [Module type Map.S]" data-language="ocaml">val min_binding : 'a t -&gt; key * 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return the binding with the smallest key in a given map (with respect to the <code class="code"><span class="constructor">Ord</span>.compare</code> ordering), or raise <code class="code"><span class="constructor">Not_found</span></code> if the map is empty.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALmin_binding_opt" data-type="val min_binding_opt [Module type Map.S]" data-language="ocaml">val min_binding_opt : 'a t -&gt; (key * 'a) option</pre>
<div class="info "> <div class="info-desc"> <p>Return the binding with the smallest key in the given map (with respect to the <code class="code"><span class="constructor">Ord</span>.compare</code> ordering), or <code class="code"><span class="constructor">None</span></code> if the map is empty.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALmax_binding" data-type="val max_binding [Module type Map.S]" data-language="ocaml">val max_binding : 'a t -&gt; key * 'a</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="map.s.html#VALmin_binding"><code class="code"><span class="constructor">Map</span>.<span class="constructor">S</span>.min_binding</code></a>, but returns the binding with the largest key in the given map.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALmax_binding_opt" data-type="val max_binding_opt [Module type Map.S]" data-language="ocaml">val max_binding_opt : 'a t -&gt; (key * 'a) option</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="map.s.html#VALmin_binding_opt"><code class="code"><span class="constructor">Map</span>.<span class="constructor">S</span>.min_binding_opt</code></a>, but returns the binding with the largest key in the given map.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALchoose" data-type="val choose [Module type Map.S]" data-language="ocaml">val choose : 'a t -&gt; key * 'a</pre>
<div class="info "> <div class="info-desc"> <p>Return one binding of the given map, or raise <code class="code"><span class="constructor">Not_found</span></code> if the map is empty. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALchoose_opt" data-type="val choose_opt [Module type Map.S]" data-language="ocaml">val choose_opt : 'a t -&gt; (key * 'a) option</pre>
<div class="info "> <div class="info-desc"> <p>Return one binding of the given map, or <code class="code"><span class="constructor">None</span></code> if the map is empty. Which binding is chosen is unspecified, but equal bindings will be chosen for equal maps.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <h2 id="searching">Searching</h2> <pre id="VALfind" data-type="val find [Module type Map.S]" data-language="ocaml">val find : key -&gt; 'a t -&gt; 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find x m</code> returns the current value of <code class="code">x</code> in <code class="code">m</code>, or raises <code class="code"><span class="constructor">Not_found</span></code> if no binding for <code class="code">x</code> exists.</p> </div> </div> <pre id="VALfind_opt" data-type="val find_opt [Module type Map.S]" data-language="ocaml">val find_opt : key -&gt; 'a t -&gt; 'a option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_opt x m</code> returns <code class="code"><span class="constructor">Some</span> v</code> if the current value of <code class="code">x</code> in <code class="code">m</code> is <code class="code">v</code>, or <code class="code"><span class="constructor">None</span></code> if no binding for <code class="code">x</code> exists.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_first" data-type="val find_first [Module type Map.S]" data-language="ocaml">val find_first : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_first f m</code>, where <code class="code">f</code> is a monotonically increasing function, returns the binding of <code class="code">m</code> with the lowest key <code class="code">k</code> such that <code class="code">f k</code>, or raises <code class="code"><span class="constructor">Not_found</span></code> if no such key exists.</p> <p>For example, <code class="code">find_first (<span class="keyword">fun</span> k <span class="keywordsign">-&gt;</span> <span class="constructor">Ord</span>.compare k x &gt;= 0) m</code> will return the first binding <code class="code">k, v</code> of <code class="code">m</code> where <code class="code"><span class="constructor">Ord</span>.compare k x &gt;= 0</code> (intuitively: <code class="code">k &gt;= x</code>), or raise <code class="code"><span class="constructor">Not_found</span></code> if <code class="code">x</code> is greater than any element of <code class="code">m</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_first_opt" data-type="val find_first_opt [Module type Map.S]" data-language="ocaml">val find_first_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_first_opt f m</code>, where <code class="code">f</code> is a monotonically increasing function, returns an option containing the binding of <code class="code">m</code> with the lowest key <code class="code">k</code> such that <code class="code">f k</code>, or <code class="code"><span class="constructor">None</span></code> if no such key exists.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_last" data-type="val find_last [Module type Map.S]" data-language="ocaml">val find_last : (key -&gt; bool) -&gt; 'a t -&gt; key * 'a</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_last f m</code>, where <code class="code">f</code> is a monotonically decreasing function, returns the binding of <code class="code">m</code> with the highest key <code class="code">k</code> such that <code class="code">f k</code>, or raises <code class="code"><span class="constructor">Not_found</span></code> if no such key exists.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALfind_last_opt" data-type="val find_last_opt [Module type Map.S]" data-language="ocaml">val find_last_opt : (key -&gt; bool) -&gt; 'a t -&gt; (key * 'a) option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_last_opt f m</code>, where <code class="code">f</code> is a monotonically decreasing function, returns an option containing the binding of <code class="code">m</code> with the highest key <code class="code">k</code> such that <code class="code">f k</code>, or <code class="code"><span class="constructor">None</span></code> if no such key exists.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <h2 id="traversing">Traversing</h2> <pre id="VALiter" data-type="val iter [Module type Map.S]" data-language="ocaml">val iter : (key -&gt; 'a -&gt; unit) -&gt; 'a t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter f m</code> applies <code class="code">f</code> to all bindings in map <code class="code">m</code>. <code class="code">f</code> receives the key as first argument, and the associated value as second argument. The bindings are passed to <code class="code">f</code> in increasing order with respect to the ordering over the type of the keys.</p> </div> </div> <pre id="VALfold" data-type="val fold [Module type Map.S]" data-language="ocaml">val fold : (key -&gt; 'a -&gt; 'acc -&gt; 'acc) -&gt; 'a t -&gt; 'acc -&gt; 'acc</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold f m init</code> computes <code class="code">(f kN dN ... (f k1 d1 init)...)</code>, where <code class="code">k1 ... kN</code> are the keys of all bindings in <code class="code">m</code> (in increasing order), and <code class="code">d1 ... dN</code> are the associated data.</p> </div> </div> <h2 id="transforming">Transforming</h2> <pre id="VALmap" data-type="val map [Module type Map.S]" data-language="ocaml">val map : ('a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map f m</code> returns a map with same domain as <code class="code">m</code>, where the associated value <code class="code">a</code> of all bindings of <code class="code">m</code> has been replaced by the result of the application of <code class="code">f</code> to <code class="code">a</code>. The bindings are passed to <code class="code">f</code> in increasing order with respect to the ordering over the type of the keys.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module type Map.S]" data-language="ocaml">val mapi : (key -&gt; 'a -&gt; 'b) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="map.s.html#VALmap"><code class="code"><span class="constructor">Map</span>.<span class="constructor">S</span>.map</code></a>, but the function receives as arguments both the key and the associated value for each binding of the map.</p> </div> </div> <pre id="VALfilter" data-type="val filter [Module type Map.S]" data-language="ocaml">val filter : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter f m</code> returns the map with all the bindings in <code class="code">m</code> that satisfy predicate <code class="code">p</code>. If every binding in <code class="code">m</code> satisfies <code class="code">f</code>, <code class="code">m</code> is returned unchanged (the result of the function is then physically equal to <code class="code">m</code>)</p> </div> <ul class="info-attributes"> <li>
<b>Before 4.03 </b> Physical equality was not ensured.</li> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALfilter_map" data-type="val filter_map [Module type Map.S]" data-language="ocaml">val filter_map : (key -&gt; 'a -&gt; 'b option) -&gt; 'a t -&gt; 'b t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">filter_map f m</code> applies the function <code class="code">f</code> to every binding of <code class="code">m</code>, and builds a map from the results. For each binding <code class="code">(k, v)</code> in the input map:</p> <ul> <li>if <code class="code">f k v</code> is <code class="code"><span class="constructor">None</span></code> then <code class="code">k</code> is not in the result,</li> <li>if <code class="code">f k v</code> is <code class="code"><span class="constructor">Some</span> v'</code> then the binding <code class="code">(k, v')</code> is in the output map.</li> </ul> <p>For example, the following function on maps whose values are lists</p> <pre class="codepre" data-language="ocaml">        filter_map
          (fun _k li -&gt; match li with [] -&gt; None | _::tl -&gt; Some tl)
          m
        </pre>
<p>drops all bindings of <code class="code">m</code> whose value is an empty list, and pops the first element of each value that is non-empty.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.11</li> </ul> </div> <pre id="VALpartition" data-type="val partition [Module type Map.S]" data-language="ocaml">val partition : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t * 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">partition f m</code> returns a pair of maps <code class="code">(m1, m2)</code>, where <code class="code">m1</code> contains all the bindings of <code class="code">m</code> that satisfy the predicate <code class="code">f</code>, and <code class="code">m2</code> is the map with all the bindings of <code class="code">m</code> that do not satisfy <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALsplit" data-type="val split [Module type Map.S]" data-language="ocaml">val split : key -&gt; 'a t -&gt; 'a t * 'a option * 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">split x m</code> returns a triple <code class="code">(l, data, r)</code>, where <code class="code">l</code> is the map with all the bindings of <code class="code">m</code> whose key is strictly less than <code class="code">x</code>; <code class="code">r</code> is the map with all the bindings of <code class="code">m</code> whose key is strictly greater than <code class="code">x</code>; <code class="code">data</code> is <code class="code"><span class="constructor">None</span></code> if <code class="code">m</code> contains no binding for <code class="code">x</code>, or <code class="code"><span class="constructor">Some</span> v</code> if <code class="code">m</code> binds <code class="code">v</code> to <code class="code">x</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <h2 id="predicates">Predicates and comparisons</h2> <pre id="VALis_empty" data-type="val is_empty [Module type Map.S]" data-language="ocaml">val is_empty : 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Test whether a map is empty or not.</p> </div> </div> <pre id="VALmem" data-type="val mem [Module type Map.S]" data-language="ocaml">val mem : key -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mem x m</code> returns <code class="code"><span class="keyword">true</span></code> if <code class="code">m</code> contains a binding for <code class="code">x</code>, and <code class="code"><span class="keyword">false</span></code> otherwise.</p> </div> </div> <pre id="VALequal" data-type="val equal [Module type Map.S]" data-language="ocaml">val equal : ('a -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">equal cmp m1 m2</code> tests whether the maps <code class="code">m1</code> and <code class="code">m2</code> are equal, that is, contain equal keys and associate them with equal data. <code class="code">cmp</code> is the equality predicate used to compare the data associated with the keys.</p> </div> </div> <pre id="VALcompare" data-type="val compare [Module type Map.S]" data-language="ocaml">val compare : ('a -&gt; 'a -&gt; int) -&gt; 'a t -&gt; 'a t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Total ordering between maps. The first argument is a total ordering used to compare data associated with equal keys in the two maps.</p> </div> </div> <pre id="VALfor_all" data-type="val for_all [Module type Map.S]" data-language="ocaml">val for_all : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all f m</code> checks if all the bindings of the map satisfy the predicate <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <pre id="VALexists" data-type="val exists [Module type Map.S]" data-language="ocaml">val exists : (key -&gt; 'a -&gt; bool) -&gt; 'a t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists f m</code> checks if at least one binding of the map satisfies the predicate <code class="code">f</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 3.12</li> </ul> </div> <h2 id="converting">Converting</h2> <pre id="VALto_list" data-type="val to_list [Module type Map.S]" data-language="ocaml">val to_list : 'a t -&gt; (key * 'a) list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_list m</code> is <a href="map.s.html#VALbindings"><code class="code"><span class="constructor">Map</span>.<span class="constructor">S</span>.bindings</code></a><code class="code"> m</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.1</li> </ul> </div> <pre id="VALof_list" data-type="val of_list [Module type Map.S]" data-language="ocaml">val of_list : (key * 'a) list -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">of_list bs</code> adds the bindings of <code class="code">bs</code> to the empty map, in list order (if a key is bound twice in <code class="code">bs</code> the last one takes over).</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 5.1</li> </ul> </div> <pre id="VALto_seq" data-type="val to_seq [Module type Map.S]" data-language="ocaml">val to_seq : 'a t -&gt; (key * 'a) Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the whole map, in ascending order of keys</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALto_rev_seq" data-type="val to_rev_seq [Module type Map.S]" data-language="ocaml">val to_rev_seq : 'a t -&gt; (key * 'a) Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the whole map, in descending order of keys</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.12</li> </ul> </div> <pre id="VALto_seq_from" data-type="val to_seq_from [Module type Map.S]" data-language="ocaml">val to_seq_from : key -&gt; 'a t -&gt; (key * 'a) Seq.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">to_seq_from k m</code> iterates on a subset of the bindings of <code class="code">m</code>, in ascending order of keys, from key <code class="code">k</code> or above.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALadd_seq" data-type="val add_seq [Module type Map.S]" data-language="ocaml">val add_seq : (key * 'a) Seq.t -&gt; 'a t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>Add the given bindings to the map, in order.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALof_seq" data-type="val of_seq [Module type Map.S]" data-language="ocaml">val of_seq : (key * 'a) Seq.t -&gt; 'a t</pre>
<div class="info "> <div class="info-desc"> <p>Build a map from the given bindings</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/Map.S.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/Map.S.html</a>
  </p>
</div>
