<div class="api"> <code class="code"><span class="keyword">sig</span><br>
  <span class="keyword">type</span> constant =<br>
      <span class="constructor">Pconst_integer</span> <span class="keyword">of</span> string * char option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pconst_char</span> <span class="keyword">of</span> char<br>
    <span class="keywordsign">|</span> <span class="constructor">Pconst_string</span> <span class="keyword">of</span> string * <span class="constructor">Location</span>.t * string option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pconst_float</span> <span class="keyword">of</span> string * char option<br>
  <span class="keyword">type</span> location_stack = <span class="constructor">Location</span>.t list<br>
  <span class="keyword">type</span> attribute = {<br>
    attr_name : string <span class="constructor">Asttypes</span>.loc;<br>
    attr_payload : <span class="constructor">Parsetree</span>.payload;<br>
    attr_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> extension = string <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.payload<br>
  <span class="keyword">and</span> attributes = <span class="constructor">Parsetree</span>.attribute list<br>
  <span class="keyword">and</span> payload =<br>
      <span class="constructor">PStr</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.structure<br>
    <span class="keywordsign">|</span> <span class="constructor">PSig</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.signature<br>
    <span class="keywordsign">|</span> <span class="constructor">PTyp</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">PPat</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern * <span class="constructor">Parsetree</span>.expression option<br>
  <span class="keyword">and</span> core_type = {<br>
    ptyp_desc : <span class="constructor">Parsetree</span>.core_type_desc;<br>
    ptyp_loc : <span class="constructor">Location</span>.t;<br>
    ptyp_loc_stack : <span class="constructor">Parsetree</span>.location_stack;<br>
    ptyp_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> core_type_desc =<br>
      <span class="constructor">Ptyp_any</span><br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_var</span> <span class="keyword">of</span> string<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_arrow</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.core_type *<br>
        <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_tuple</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_constr</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_object</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.object_field list * <span class="constructor">Asttypes</span>.closed_flag<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_class</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_alias</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type * string <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_variant</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.row_field list * <span class="constructor">Asttypes</span>.closed_flag *<br>
        <span class="constructor">Asttypes</span>.label list option<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_poly</span> <span class="keyword">of</span> string <span class="constructor">Asttypes</span>.loc list * <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_package</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.package_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_open</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptyp_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
  <span class="keyword">and</span> package_type =<br>
      <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc *<br>
      (<span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type) list<br>
  <span class="keyword">and</span> row_field = {<br>
    prf_desc : <span class="constructor">Parsetree</span>.row_field_desc;<br>
    prf_loc : <span class="constructor">Location</span>.t;<br>
    prf_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> row_field_desc =<br>
      <span class="constructor">Rtag</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * bool * <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Rinherit</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type<br>
  <span class="keyword">and</span> object_field = {<br>
    pof_desc : <span class="constructor">Parsetree</span>.object_field_desc;<br>
    pof_loc : <span class="constructor">Location</span>.t;<br>
    pof_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> object_field_desc =<br>
      <span class="constructor">Otag</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Oinherit</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type<br>
  <span class="keyword">and</span> pattern = {<br>
    ppat_desc : <span class="constructor">Parsetree</span>.pattern_desc;<br>
    ppat_loc : <span class="constructor">Location</span>.t;<br>
    ppat_loc_stack : <span class="constructor">Parsetree</span>.location_stack;<br>
    ppat_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> pattern_desc =<br>
      <span class="constructor">Ppat_any</span><br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_var</span> <span class="keyword">of</span> string <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_alias</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern * string <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_constant</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.constant<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_interval</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.constant * <span class="constructor">Parsetree</span>.constant<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_tuple</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_construct</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc *<br>
        (string <span class="constructor">Asttypes</span>.loc list * <span class="constructor">Parsetree</span>.pattern) option<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_variant</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.label * <span class="constructor">Parsetree</span>.pattern option<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_record</span> <span class="keyword">of</span> (<span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.pattern) list *<br>
        <span class="constructor">Asttypes</span>.closed_flag<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_array</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_or</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern * <span class="constructor">Parsetree</span>.pattern<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_constraint</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern * <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_type</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_lazy</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_unpack</span> <span class="keyword">of</span> string option <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_exception</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Ppat_open</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.pattern<br>
  <span class="keyword">and</span> expression = {<br>
    pexp_desc : <span class="constructor">Parsetree</span>.expression_desc;<br>
    pexp_loc : <span class="constructor">Location</span>.t;<br>
    pexp_loc_stack : <span class="constructor">Parsetree</span>.location_stack;<br>
    pexp_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> expression_desc =<br>
      <span class="constructor">Pexp_ident</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_constant</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.constant<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_let</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.rec_flag * <span class="constructor">Parsetree</span>.value_binding list *<br>
        <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_function</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.function_param list *<br>
        <span class="constructor">Parsetree</span>.type_constraint option * <span class="constructor">Parsetree</span>.function_body<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_apply</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression *<br>
        (<span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.expression) list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_match</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.case list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_try</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.case list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_tuple</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_construct</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc *<br>
        <span class="constructor">Parsetree</span>.expression option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_variant</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.label * <span class="constructor">Parsetree</span>.expression option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_record</span> <span class="keyword">of</span> (<span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.expression) list *<br>
        <span class="constructor">Parsetree</span>.expression option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_field</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_setfield</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc *<br>
        <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_array</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_ifthenelse</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.expression *<br>
        <span class="constructor">Parsetree</span>.expression option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_sequence</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_while</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_for</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.pattern * <span class="constructor">Parsetree</span>.expression *<br>
        <span class="constructor">Parsetree</span>.expression * <span class="constructor">Asttypes</span>.direction_flag * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_constraint</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_coerce</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.core_type option *<br>
        <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_send</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_new</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_setinstvar</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_override</span> <span class="keyword">of</span><br>
        (<span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.expression) list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_letmodule</span> <span class="keyword">of</span> string option <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.module_expr *<br>
        <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_letexception</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension_constructor *<br>
        <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_assert</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_lazy</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_poly</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.core_type option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_object</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_structure<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_newtype</span> <span class="keyword">of</span> string <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_pack</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_open</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.open_declaration * <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_letop</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.letop<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Pexp_unreachable</span><br>
  <span class="keyword">and</span> case = {<br>
    pc_lhs : <span class="constructor">Parsetree</span>.pattern;<br>
    pc_guard : <span class="constructor">Parsetree</span>.expression option;<br>
    pc_rhs : <span class="constructor">Parsetree</span>.expression;<br>
  }<br>
  <span class="keyword">and</span> letop = {<br>
    let_ : <span class="constructor">Parsetree</span>.binding_op;<br>
    ands : <span class="constructor">Parsetree</span>.binding_op list;<br>
    body : <span class="constructor">Parsetree</span>.expression;<br>
  }<br>
  <span class="keyword">and</span> binding_op = {<br>
    pbop_op : string <span class="constructor">Asttypes</span>.loc;<br>
    pbop_pat : <span class="constructor">Parsetree</span>.pattern;<br>
    pbop_exp : <span class="constructor">Parsetree</span>.expression;<br>
    pbop_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> function_param_desc =<br>
      <span class="constructor">Pparam_val</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.expression option *<br>
        <span class="constructor">Parsetree</span>.pattern<br>
    <span class="keywordsign">|</span> <span class="constructor">Pparam_newtype</span> <span class="keyword">of</span> string <span class="constructor">Asttypes</span>.loc<br>
  <span class="keyword">and</span> function_param = {<br>
    pparam_loc : <span class="constructor">Location</span>.t;<br>
    pparam_desc : <span class="constructor">Parsetree</span>.function_param_desc;<br>
  }<br>
  <span class="keyword">and</span> function_body =<br>
      <span class="constructor">Pfunction_body</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pfunction_cases</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.case list * <span class="constructor">Location</span>.t *<br>
        <span class="constructor">Parsetree</span>.attributes<br>
  <span class="keyword">and</span> type_constraint =<br>
      <span class="constructor">Pconstraint</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcoerce</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type option * <span class="constructor">Parsetree</span>.core_type<br>
  <span class="keyword">and</span> value_description = {<br>
    pval_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pval_type : <span class="constructor">Parsetree</span>.core_type;<br>
    pval_prim : string list;<br>
    pval_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pval_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> type_declaration = {<br>
    ptype_name : string <span class="constructor">Asttypes</span>.loc;<br>
    ptype_params :<br>
      (<span class="constructor">Parsetree</span>.core_type * (<span class="constructor">Asttypes</span>.variance * <span class="constructor">Asttypes</span>.injectivity)) list;<br>
    ptype_cstrs :<br>
      (<span class="constructor">Parsetree</span>.core_type * <span class="constructor">Parsetree</span>.core_type * <span class="constructor">Location</span>.t) list;<br>
    ptype_kind : <span class="constructor">Parsetree</span>.type_kind;<br>
    ptype_private : <span class="constructor">Asttypes</span>.private_flag;<br>
    ptype_manifest : <span class="constructor">Parsetree</span>.core_type option;<br>
    ptype_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    ptype_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> type_kind =<br>
      <span class="constructor">Ptype_abstract</span><br>
    <span class="keywordsign">|</span> <span class="constructor">Ptype_variant</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.constructor_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptype_record</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.label_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptype_open</span><br>
  <span class="keyword">and</span> label_declaration = {<br>
    pld_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pld_mutable : <span class="constructor">Asttypes</span>.mutable_flag;<br>
    pld_type : <span class="constructor">Parsetree</span>.core_type;<br>
    pld_loc : <span class="constructor">Location</span>.t;<br>
    pld_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> constructor_declaration = {<br>
    pcd_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pcd_vars : string <span class="constructor">Asttypes</span>.loc list;<br>
    pcd_args : <span class="constructor">Parsetree</span>.constructor_arguments;<br>
    pcd_res : <span class="constructor">Parsetree</span>.core_type option;<br>
    pcd_loc : <span class="constructor">Location</span>.t;<br>
    pcd_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> constructor_arguments =<br>
      <span class="constructor">Pcstr_tuple</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcstr_record</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.label_declaration list<br>
  <span class="keyword">and</span> type_extension = {<br>
    ptyext_path : <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc;<br>
    ptyext_params :<br>
      (<span class="constructor">Parsetree</span>.core_type * (<span class="constructor">Asttypes</span>.variance * <span class="constructor">Asttypes</span>.injectivity)) list;<br>
    ptyext_constructors : <span class="constructor">Parsetree</span>.extension_constructor list;<br>
    ptyext_private : <span class="constructor">Asttypes</span>.private_flag;<br>
    ptyext_loc : <span class="constructor">Location</span>.t;<br>
    ptyext_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> extension_constructor = {<br>
    pext_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pext_kind : <span class="constructor">Parsetree</span>.extension_constructor_kind;<br>
    pext_loc : <span class="constructor">Location</span>.t;<br>
    pext_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> type_exception = {<br>
    ptyexn_constructor : <span class="constructor">Parsetree</span>.extension_constructor;<br>
    ptyexn_loc : <span class="constructor">Location</span>.t;<br>
    ptyexn_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> extension_constructor_kind =<br>
      <span class="constructor">Pext_decl</span> <span class="keyword">of</span> string <span class="constructor">Asttypes</span>.loc list *<br>
        <span class="constructor">Parsetree</span>.constructor_arguments * <span class="constructor">Parsetree</span>.core_type option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pext_rebind</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
  <span class="keyword">and</span> class_type = {<br>
    pcty_desc : <span class="constructor">Parsetree</span>.class_type_desc;<br>
    pcty_loc : <span class="constructor">Location</span>.t;<br>
    pcty_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> class_type_desc =<br>
      <span class="constructor">Pcty_constr</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcty_signature</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_signature<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcty_arrow</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.core_type *<br>
        <span class="constructor">Parsetree</span>.class_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcty_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcty_open</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.open_description * <span class="constructor">Parsetree</span>.class_type<br>
  <span class="keyword">and</span> class_signature = {<br>
    pcsig_self : <span class="constructor">Parsetree</span>.core_type;<br>
    pcsig_fields : <span class="constructor">Parsetree</span>.class_type_field list;<br>
  }<br>
  <span class="keyword">and</span> class_type_field = {<br>
    pctf_desc : <span class="constructor">Parsetree</span>.class_type_field_desc;<br>
    pctf_loc : <span class="constructor">Location</span>.t;<br>
    pctf_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> class_type_field_desc =<br>
      <span class="constructor">Pctf_inherit</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pctf_val</span> <span class="keyword">of</span><br>
        (<span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Asttypes</span>.mutable_flag *<br>
         <span class="constructor">Asttypes</span>.virtual_flag * <span class="constructor">Parsetree</span>.core_type)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pctf_method</span> <span class="keyword">of</span><br>
        (<span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Asttypes</span>.private_flag *<br>
         <span class="constructor">Asttypes</span>.virtual_flag * <span class="constructor">Parsetree</span>.core_type)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pctf_constraint</span> <span class="keyword">of</span> (<span class="constructor">Parsetree</span>.core_type * <span class="constructor">Parsetree</span>.core_type)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pctf_attribute</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.attribute<br>
    <span class="keywordsign">|</span> <span class="constructor">Pctf_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
  <span class="keyword">and</span> <span class="keywordsign">'</span>a class_infos = {<br>
    pci_virt : <span class="constructor">Asttypes</span>.virtual_flag;<br>
    pci_params :<br>
      (<span class="constructor">Parsetree</span>.core_type * (<span class="constructor">Asttypes</span>.variance * <span class="constructor">Asttypes</span>.injectivity)) list;<br>
    pci_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pci_expr : <span class="keywordsign">'</span>a;<br>
    pci_loc : <span class="constructor">Location</span>.t;<br>
    pci_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> class_description = <span class="constructor">Parsetree</span>.class_type <span class="constructor">Parsetree</span>.class_infos<br>
  <span class="keyword">and</span> class_type_declaration = <span class="constructor">Parsetree</span>.class_type <span class="constructor">Parsetree</span>.class_infos<br>
  <span class="keyword">and</span> class_expr = {<br>
    pcl_desc : <span class="constructor">Parsetree</span>.class_expr_desc;<br>
    pcl_loc : <span class="constructor">Location</span>.t;<br>
    pcl_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> class_expr_desc =<br>
      <span class="constructor">Pcl_constr</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.core_type list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_structure</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_structure<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_fun</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.expression option *<br>
        <span class="constructor">Parsetree</span>.pattern * <span class="constructor">Parsetree</span>.class_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_apply</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_expr *<br>
        (<span class="constructor">Asttypes</span>.arg_label * <span class="constructor">Parsetree</span>.expression) list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_let</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.rec_flag * <span class="constructor">Parsetree</span>.value_binding list *<br>
        <span class="constructor">Parsetree</span>.class_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_constraint</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_expr * <span class="constructor">Parsetree</span>.class_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcl_open</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.open_description * <span class="constructor">Parsetree</span>.class_expr<br>
  <span class="keyword">and</span> class_structure = {<br>
    pcstr_self : <span class="constructor">Parsetree</span>.pattern;<br>
    pcstr_fields : <span class="constructor">Parsetree</span>.class_field list;<br>
  }<br>
  <span class="keyword">and</span> class_field = {<br>
    pcf_desc : <span class="constructor">Parsetree</span>.class_field_desc;<br>
    pcf_loc : <span class="constructor">Location</span>.t;<br>
    pcf_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> class_field_desc =<br>
      <span class="constructor">Pcf_inherit</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.override_flag * <span class="constructor">Parsetree</span>.class_expr *<br>
        string <span class="constructor">Asttypes</span>.loc option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_val</span> <span class="keyword">of</span><br>
        (<span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Asttypes</span>.mutable_flag *<br>
         <span class="constructor">Parsetree</span>.class_field_kind)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_method</span> <span class="keyword">of</span><br>
        (<span class="constructor">Asttypes</span>.label <span class="constructor">Asttypes</span>.loc * <span class="constructor">Asttypes</span>.private_flag *<br>
         <span class="constructor">Parsetree</span>.class_field_kind)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_constraint</span> <span class="keyword">of</span> (<span class="constructor">Parsetree</span>.core_type * <span class="constructor">Parsetree</span>.core_type)<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_initializer</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_attribute</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.attribute<br>
    <span class="keywordsign">|</span> <span class="constructor">Pcf_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
  <span class="keyword">and</span> class_field_kind =<br>
      <span class="constructor">Cfk_virtual</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.core_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Cfk_concrete</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.override_flag * <span class="constructor">Parsetree</span>.expression<br>
  <span class="keyword">and</span> class_declaration = <span class="constructor">Parsetree</span>.class_expr <span class="constructor">Parsetree</span>.class_infos<br>
  <span class="keyword">and</span> module_type = {<br>
    pmty_desc : <span class="constructor">Parsetree</span>.module_type_desc;<br>
    pmty_loc : <span class="constructor">Location</span>.t;<br>
    pmty_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> module_type_desc =<br>
      <span class="constructor">Pmty_ident</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_signature</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.signature<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_functor</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.functor_parameter * <span class="constructor">Parsetree</span>.module_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_with</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_type * <span class="constructor">Parsetree</span>.with_constraint list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_typeof</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmty_alias</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
  <span class="keyword">and</span> functor_parameter =<br>
      <span class="constructor">Unit</span><br>
    <span class="keywordsign">|</span> <span class="constructor">Named</span> <span class="keyword">of</span> string option <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.module_type<br>
  <span class="keyword">and</span> signature = <span class="constructor">Parsetree</span>.signature_item list<br>
  <span class="keyword">and</span> signature_item = {<br>
    psig_desc : <span class="constructor">Parsetree</span>.signature_item_desc;<br>
    psig_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> signature_item_desc =<br>
      <span class="constructor">Psig_value</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.value_description<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_type</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.rec_flag * <span class="constructor">Parsetree</span>.type_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_typesubst</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.type_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_typext</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.type_extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_exception</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.type_exception<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_module</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_modsubst</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_substitution<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_recmodule</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_modtype</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_type_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_modtypesubst</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_type_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_open</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.open_description<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_include</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.include_description<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_class</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_description list<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_class_type</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_type_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_attribute</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.attribute<br>
    <span class="keywordsign">|</span> <span class="constructor">Psig_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension * <span class="constructor">Parsetree</span>.attributes<br>
  <span class="keyword">and</span> module_declaration = {<br>
    pmd_name : string option <span class="constructor">Asttypes</span>.loc;<br>
    pmd_type : <span class="constructor">Parsetree</span>.module_type;<br>
    pmd_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pmd_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> module_substitution = {<br>
    pms_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pms_manifest : <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc;<br>
    pms_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pms_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> module_type_declaration = {<br>
    pmtd_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pmtd_type : <span class="constructor">Parsetree</span>.module_type option;<br>
    pmtd_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pmtd_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> <span class="keywordsign">'</span>a open_infos = {<br>
    popen_expr : <span class="keywordsign">'</span>a;<br>
    popen_override : <span class="constructor">Asttypes</span>.override_flag;<br>
    popen_loc : <span class="constructor">Location</span>.t;<br>
    popen_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> open_description = <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc <span class="constructor">Parsetree</span>.open_infos<br>
  <span class="keyword">and</span> open_declaration = <span class="constructor">Parsetree</span>.module_expr <span class="constructor">Parsetree</span>.open_infos<br>
  <span class="keyword">and</span> <span class="keywordsign">'</span>a include_infos = {<br>
    pincl_mod : <span class="keywordsign">'</span>a;<br>
    pincl_loc : <span class="constructor">Location</span>.t;<br>
    pincl_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> include_description = <span class="constructor">Parsetree</span>.module_type <span class="constructor">Parsetree</span>.include_infos<br>
  <span class="keyword">and</span> include_declaration = <span class="constructor">Parsetree</span>.module_expr <span class="constructor">Parsetree</span>.include_infos<br>
  <span class="keyword">and</span> with_constraint =<br>
      <span class="constructor">Pwith_type</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.type_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Pwith_module</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pwith_modtype</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.module_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pwith_modtypesubst</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Parsetree</span>.module_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pwith_typesubst</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc *<br>
        <span class="constructor">Parsetree</span>.type_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Pwith_modsubst</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc * <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
  <span class="keyword">and</span> module_expr = {<br>
    pmod_desc : <span class="constructor">Parsetree</span>.module_expr_desc;<br>
    pmod_loc : <span class="constructor">Location</span>.t;<br>
    pmod_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
  }<br>
  <span class="keyword">and</span> module_expr_desc =<br>
      <span class="constructor">Pmod_ident</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t <span class="constructor">Asttypes</span>.loc<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_structure</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.structure<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_functor</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.functor_parameter * <span class="constructor">Parsetree</span>.module_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_apply</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_expr * <span class="constructor">Parsetree</span>.module_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_apply_unit</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_expr<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_constraint</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_expr * <span class="constructor">Parsetree</span>.module_type<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_unpack</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression<br>
    <span class="keywordsign">|</span> <span class="constructor">Pmod_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension<br>
  <span class="keyword">and</span> structure = <span class="constructor">Parsetree</span>.structure_item list<br>
  <span class="keyword">and</span> structure_item = {<br>
    pstr_desc : <span class="constructor">Parsetree</span>.structure_item_desc;<br>
    pstr_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> structure_item_desc =<br>
      <span class="constructor">Pstr_eval</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.expression * <span class="constructor">Parsetree</span>.attributes<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_value</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.rec_flag * <span class="constructor">Parsetree</span>.value_binding list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_primitive</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.value_description<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_type</span> <span class="keyword">of</span> <span class="constructor">Asttypes</span>.rec_flag * <span class="constructor">Parsetree</span>.type_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_typext</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.type_extension<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_exception</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.type_exception<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_module</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_binding<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_recmodule</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_binding list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_modtype</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.module_type_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_open</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.open_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_class</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_class_type</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.class_type_declaration list<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_include</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.include_declaration<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_attribute</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.attribute<br>
    <span class="keywordsign">|</span> <span class="constructor">Pstr_extension</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.extension * <span class="constructor">Parsetree</span>.attributes<br>
  <span class="keyword">and</span> value_constraint =<br>
      <span class="constructor">Pvc_constraint</span> <span class="keyword">of</span> {<br>
        locally_abstract_univars : string <span class="constructor">Asttypes</span>.loc list;<br>
        typ : <span class="constructor">Parsetree</span>.core_type;<br>
      }<br>
    <span class="keywordsign">|</span> <span class="constructor">Pvc_coercion</span> <span class="keyword">of</span> { ground : <span class="constructor">Parsetree</span>.core_type option;<br>
        coercion : <span class="constructor">Parsetree</span>.core_type;<br>
      }<br>
  <span class="keyword">and</span> value_binding = {<br>
    pvb_pat : <span class="constructor">Parsetree</span>.pattern;<br>
    pvb_expr : <span class="constructor">Parsetree</span>.expression;<br>
    pvb_constraint : <span class="constructor">Parsetree</span>.value_constraint option;<br>
    pvb_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pvb_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> module_binding = {<br>
    pmb_name : string option <span class="constructor">Asttypes</span>.loc;<br>
    pmb_expr : <span class="constructor">Parsetree</span>.module_expr;<br>
    pmb_attributes : <span class="constructor">Parsetree</span>.attributes;<br>
    pmb_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">type</span> toplevel_phrase =<br>
      <span class="constructor">Ptop_def</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.structure<br>
    <span class="keywordsign">|</span> <span class="constructor">Ptop_dir</span> <span class="keyword">of</span> <span class="constructor">Parsetree</span>.toplevel_directive<br>
  <span class="keyword">and</span> toplevel_directive = {<br>
    pdir_name : string <span class="constructor">Asttypes</span>.loc;<br>
    pdir_arg : <span class="constructor">Parsetree</span>.directive_argument option;<br>
    pdir_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> directive_argument = {<br>
    pdira_desc : <span class="constructor">Parsetree</span>.directive_argument_desc;<br>
    pdira_loc : <span class="constructor">Location</span>.t;<br>
  }<br>
  <span class="keyword">and</span> directive_argument_desc =<br>
      <span class="constructor">Pdir_string</span> <span class="keyword">of</span> string<br>
    <span class="keywordsign">|</span> <span class="constructor">Pdir_int</span> <span class="keyword">of</span> string * char option<br>
    <span class="keywordsign">|</span> <span class="constructor">Pdir_ident</span> <span class="keyword">of</span> <span class="constructor">Longident</span>.t<br>
    <span class="keywordsign">|</span> <span class="constructor">Pdir_bool</span> <span class="keyword">of</span> bool<br>
<span class="keyword">end</span></code> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/compilerlibref/type_Parsetree.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/compilerlibref/type_Parsetree.html</a>
  </p>
</div>
