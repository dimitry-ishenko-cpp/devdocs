<div class="api"> <h1>Module Parse</h1> <pre id="MODULEParse" data-type="module Parse [Module Parse]" data-language="ocaml">module Parse: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Entry points in the parser</p> <p><b>Warning:</b> this module is unstable and part of <a href="compiler_libs.html">compiler-libs</a>.</p> </div> </div>  <pre id="VALimplementation" data-type="val implementation [Module Parse]" data-language="ocaml">val implementation : Lexing.lexbuf -&gt; Parsetree.structure</pre> <pre id="VALinterface" data-type="val interface [Module Parse]" data-language="ocaml">val interface : Lexing.lexbuf -&gt; Parsetree.signature</pre> <pre id="VALtoplevel_phrase" data-type="val toplevel_phrase [Module Parse]" data-language="ocaml">val toplevel_phrase : Lexing.lexbuf -&gt; Parsetree.toplevel_phrase</pre> <pre id="VALuse_file" data-type="val use_file [Module Parse]" data-language="ocaml">val use_file : Lexing.lexbuf -&gt; Parsetree.toplevel_phrase list</pre> <pre id="VALcore_type" data-type="val core_type [Module Parse]" data-language="ocaml">val core_type : Lexing.lexbuf -&gt; Parsetree.core_type</pre> <pre id="VALexpression" data-type="val expression [Module Parse]" data-language="ocaml">val expression : Lexing.lexbuf -&gt; Parsetree.expression</pre> <pre id="VALpattern" data-type="val pattern [Module Parse]" data-language="ocaml">val pattern : Lexing.lexbuf -&gt; Parsetree.pattern</pre> <pre id="VALmodule_type" data-type="val module_type [Module Parse]" data-language="ocaml">val module_type : Lexing.lexbuf -&gt; Parsetree.module_type</pre> <pre id="VALmodule_expr" data-type="val module_expr [Module Parse]" data-language="ocaml">val module_expr : Lexing.lexbuf -&gt; Parsetree.module_expr</pre>
<p>The functions below can be used to parse Longident safely.</p> <pre id="VALlongident" data-type="val longident [Module Parse]" data-language="ocaml">val longident : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>The function <code class="code">longident</code> is guaranteed to parse all subclasses of <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a> used in OCaml: values, constructors, simple or extended module paths, and types or module types.</p> <p>However, this function accepts inputs which are not accepted by the compiler, because they combine functor applications and infix operators. In valid OCaml syntax, only value-level identifiers may end with infix operators <code class="code"><span class="constructor">Foo</span>.( + )</code>. Moreover, in value-level identifiers the module path <code class="code"><span class="constructor">Foo</span></code> must be simple (<code class="code"><span class="constructor">M</span>.<span class="constructor">N</span></code> rather than <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>)</code>): functor applications may only appear in type-level identifiers. As a consequence, a path such as <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>).( + )</code> is not a valid OCaml identifier; but it is accepted by this function.</p> </div> </div> <p>The next functions are specialized to a subclass of <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a></p> <pre id="VALval_ident" data-type="val val_ident [Module Parse]" data-language="ocaml">val val_ident : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>This function parses a syntactically valid path for a value. For instance, <code class="code">x</code>, <code class="code"><span class="constructor">M</span>.x</code>, and <code class="code">(+.)</code> are valid. Contrarily, <code class="code"><span class="constructor">M</span>.<span class="constructor">A</span></code>, <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>).x</code>, and <code class="code"><span class="keyword">true</span></code> are rejected.</p> <p>Longident for OCaml's value cannot contain functor application. The last component of the <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a> is not capitalized, but can be an operator <code class="code"><span class="constructor">A</span>.<span class="constructor">Path</span>.<span class="constructor">To</span>.(.%.%.(;..)&lt;-)</code></p> </div> </div> <pre id="VALconstr_ident" data-type="val constr_ident [Module Parse]" data-language="ocaml">val constr_ident : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>This function parses a syntactically valid path for a variant constructor. For instance, <code class="code"><span class="constructor">A</span></code>, <code class="code"><span class="constructor">M</span>.<span class="constructor">A</span></code> and <code class="code"><span class="constructor">M</span>.(::)</code> are valid, but both <code class="code"><span class="constructor">M</span>.a</code> and <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>).<span class="constructor">A</span></code> are rejected.</p> <p>Longident for OCaml's variant constructors cannot contain functor application. The last component of the <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a> is capitalized, or it may be one the special constructors: <code class="code"><span class="keyword">true</span></code>,<code class="code"><span class="keyword">false</span></code>,<code class="code">()</code>,<code class="code">[]</code>,<code class="code">(::)</code>. Among those special constructors, only <code class="code">(::)</code> can be prefixed by a module path (<code class="code"><span class="constructor">A</span>.<span class="constructor">B</span>.<span class="constructor">C</span>.(::)</code>).</p> </div> </div> <pre id="VALsimple_module_path" data-type="val simple_module_path [Module Parse]" data-language="ocaml">val simple_module_path : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>This function parses a syntactically valid path for a module. For instance, <code class="code"><span class="constructor">A</span></code>, and <code class="code"><span class="constructor">M</span>.<span class="constructor">A</span></code> are valid, but both <code class="code"><span class="constructor">M</span>.a</code> and <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>).<span class="constructor">A</span></code> are rejected.</p> <p>Longident for OCaml's module cannot contain functor application. The last component of the <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a> is capitalized.</p> </div> </div> <pre id="VALextended_module_path" data-type="val extended_module_path [Module Parse]" data-language="ocaml">val extended_module_path : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>This function parse syntactically valid path for an extended module. For instance, <code class="code"><span class="constructor">A</span>.<span class="constructor">B</span></code> and <code class="code"><span class="constructor">F</span>(<span class="constructor">A</span>).<span class="constructor">B</span></code> are valid. Contrarily, <code class="code">(.%())</code> or <code class="code">[]</code> are both rejected.</p> <p>The last component of the <a href="longident.html#TYPEt"><code class="code"><span class="constructor">Longident</span>.t</code></a> is capitalized.</p> </div> </div> <pre id="VALtype_ident" data-type="val type_ident [Module Parse]" data-language="ocaml">val type_ident : Lexing.lexbuf -&gt; Longident.t</pre>
<div class="info "> <div class="info-desc"> <p>This function parse syntactically valid path for a type or a module type. For instance, <code class="code"><span class="constructor">A</span></code>, <code class="code">t</code>, <code class="code"><span class="constructor">M</span>.t</code> and <code class="code"><span class="constructor">F</span>(<span class="constructor">X</span>).t</code> are valid. Contrarily, <code class="code">(.%())</code> or <code class="code">[]</code> are both rejected.</p> <p>In path for type and module types, only operators and special constructors are rejected.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/compilerlibref/Parse.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/compilerlibref/Parse.html</a>
  </p>
</div>
