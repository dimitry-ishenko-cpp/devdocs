<div class="api"> <h1>Module Unit_info</h1> <pre id="MODULEUnit_info" data-type="module Unit_info [Module Unit_info]" data-language="ocaml">module Unit_info: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>This module centralize the handling of compilation files and their metadata.</p> <p>Maybe more importantly, this module provides functions for deriving module names from strings or filenames.</p> </div> </div>  <h2 id="modname_from_strings">Module name convention and computation</h2> <pre id="TYPEmodname" data-type="type modname [Module Unit_info]" data-language="ocaml">type modname = string </pre> <pre id="TYPEfilename" data-type="type filename [Module Unit_info]" data-language="ocaml">type filename = string </pre> <pre id="TYPEfile_prefix" data-type="type file_prefix [Module Unit_info]" data-language="ocaml">type file_prefix = string </pre> <pre id="VALmodulize" data-type="val modulize [Module Unit_info]" data-language="ocaml">val modulize : string -&gt; modname</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">modulize s</code> capitalizes the first letter of <code class="code">s</code>.</p> </div> </div> <pre id="VALnormalize" data-type="val normalize [Module Unit_info]" data-language="ocaml">val normalize : string -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">normalize s</code> uncapitalizes the first letter of <code class="code">s</code>.</p> </div> </div> <pre id="VALmodname_from_source" data-type="val modname_from_source [Module Unit_info]" data-language="ocaml">val modname_from_source : filename -&gt; modname</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">modname_from_source filename</code> is <code class="code">modulize stem</code> where <code class="code">stem</code> is the basename of the filename <code class="code">filename</code> stripped from all its extensions. For instance, <code class="code">modname_from_source <span class="string">"/pa.th/x.ml.pp"</span></code> is <code class="code"><span class="string">"X"</span></code>.</p> </div> </div> <h3 id="module_name_validation">Module name validation function</h3> <pre id="VALis_unit_name" data-type="val is_unit_name [Module Unit_info]" data-language="ocaml">val is_unit_name : modname -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_unit_name ~strict name</code> is true only if <code class="code">name</code> can be used as a valid module name.</p> </div> </div> <h2 id="unit_info">Metadata for compilation unit</h2> <pre id="TYPEt" data-type="type t [Module Unit_info]" data-language="ocaml">type t </pre> <div class="info "> <div class="info-desc"> <p>Metadata for a compilation unit:</p> <ul> <li>the module name associated to the unit</li> <li>the filename prefix (dirname + basename with all extensions stripped) for compilation artifacts</li> <li>the input source file For instance, when calling <code class="code">ocamlopt dir/x.mli -o target/y.cmi</code>,</li> <li>the input source file is <code class="code">dir/x.mli</code>
</li> <li>the module name is <code class="code"><span class="constructor">Y</span></code>
</li> <li>the prefix is <code class="code">target/y</code>
</li> </ul> </div> </div> <pre id="VALsource_file" data-type="val source_file [Module Unit_info]" data-language="ocaml">val source_file : t -&gt; filename</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">source_file u</code> is the source file of <code class="code">u</code>.</p> </div> </div> <pre id="VALprefix" data-type="val prefix [Module Unit_info]" data-language="ocaml">val prefix : t -&gt; file_prefix</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">prefix u</code> is the filename prefix of the unit.</p> </div> </div> <pre id="VALmodname" data-type="val modname [Module Unit_info]" data-language="ocaml">val modname : t -&gt; modname</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">modname u</code> or <code class="code">artifact_modname a</code> is the module name of the unit or compilation artifact.</p> </div> </div> <pre id="VALcheck_unit_name" data-type="val check_unit_name [Module Unit_info]" data-language="ocaml">val check_unit_name : t -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">check_unit_name u</code> prints a warning if the derived module name <code class="code">modname u</code> should not be used as a module name as specified by <a href="unit_info.html#VALis_unit_name"><code class="code"><span class="constructor">Unit_info</span>.is_unit_name</code></a><code class="code"> ~strict:<span class="keyword">true</span></code>.</p> </div> </div> <pre id="VALmake" data-type="val make [Module Unit_info]" data-language="ocaml">val make : ?check_modname:bool -&gt;       source_file:filename -&gt; file_prefix -&gt; t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make ~check ~source_file prefix</code> associates both the <code class="code">source_file</code> and the module name <a href="unit_info.html#VALmodname_from_source"><code class="code"><span class="constructor">Unit_info</span>.modname_from_source</code></a><code class="code"> target_prefix</code> to the prefix filesystem path <code class="code">prefix</code>.</p> <p>If <code class="code">check_modname=<span class="keyword">true</span></code>, this function emits a warning if the derived module name is not valid according to <a href="unit_info.html#VALcheck_unit_name"><code class="code"><span class="constructor">Unit_info</span>.check_unit_name</code></a>.</p> </div> </div> <pre id="MODULEArtifact" data-type="module Artifact [Module Unit_info]" data-language="ocaml">module Artifact: sig .. end</pre>
<div class="info"> <p>Build artifacts</p> </div> <h2 id="info_build_artifacts">Derived build artifact metadata</h2> <pre id="VALcmi" data-type="val cmi [Module Unit_info]" data-language="ocaml">val cmi : t -&gt; Artifact.t</pre>
<div class="info "> <div class="info-desc"> <p>Those functions derive a specific <code class="code">artifact</code> metadata from an <code class="code">unit</code> metadata.</p> </div> </div> <pre id="VALcmo" data-type="val cmo [Module Unit_info]" data-language="ocaml">val cmo : t -&gt; Artifact.t</pre> <pre id="VALcmx" data-type="val cmx [Module Unit_info]" data-language="ocaml">val cmx : t -&gt; Artifact.t</pre> <pre id="VALobj" data-type="val obj [Module Unit_info]" data-language="ocaml">val obj : t -&gt; Artifact.t</pre> <pre id="VALcmt" data-type="val cmt [Module Unit_info]" data-language="ocaml">val cmt : t -&gt; Artifact.t</pre> <pre id="VALcmti" data-type="val cmti [Module Unit_info]" data-language="ocaml">val cmti : t -&gt; Artifact.t</pre> <pre id="VALannot" data-type="val annot [Module Unit_info]" data-language="ocaml">val annot : t -&gt; Artifact.t</pre> <pre id="VALcompanion_cmi" data-type="val companion_cmi [Module Unit_info]" data-language="ocaml">val companion_cmi : Artifact.t -&gt; Artifact.t</pre>
<div class="info "> <div class="info-desc"> <p>The functions below change the type of an artifact by updating the extension of its filename. Those functions purposefully do not cover all artifact kinds because we want to track which artifacts are assumed to be bundled together.</p> </div> </div> <pre id="VALcompanion_obj" data-type="val companion_obj [Module Unit_info]" data-language="ocaml">val companion_obj : Artifact.t -&gt; Artifact.t</pre> <pre id="VALcompanion_cmt" data-type="val companion_cmt [Module Unit_info]" data-language="ocaml">val companion_cmt : Artifact.t -&gt; Artifact.t</pre>
<h2 id="ml_mli_cmi_interaction">Mli and cmi derived from implementation files </h2>
<p>The compilation of module implementation changes in presence of mli and cmi files, the function belows help to handle this.</p> <pre id="VALmli_from_source" data-type="val mli_from_source [Module Unit_info]" data-language="ocaml">val mli_from_source : t -&gt; filename</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mli_from_source u</code> is the interface source filename associated to the unit <code class="code">u</code>. The actual suffix depends on <a href="config.html#VALinterface_suffix"><code class="code"><span class="constructor">Config</span>.interface_suffix</code></a>.</p> </div> </div> <pre id="VALmli_from_artifact" data-type="val mli_from_artifact [Module Unit_info]" data-language="ocaml">val mli_from_artifact : Artifact.t -&gt; filename</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mli_from_artifact t</code> is the name of the interface source file derived from the artifact <code class="code">t</code>. This variant is necessary when handling artifacts derived from an unknown source files (e.g. packed modules).</p> </div> </div> <pre id="VALis_cmi" data-type="val is_cmi [Module Unit_info]" data-language="ocaml">val is_cmi : Artifact.t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>Check if the artifact is a cmi</p> </div> </div> <pre id="VALfind_normalized_cmi" data-type="val find_normalized_cmi [Module Unit_info]" data-language="ocaml">val find_normalized_cmi : t -&gt; Artifact.t</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">find_normalized_cmi u</code> finds in the load_path a file matching the module name <code class="code">modname u</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if no such cmi exists</li> </ul> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/compilerlibref/Unit_info.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/compilerlibref/Unit_info.html</a>
  </p>
</div>
