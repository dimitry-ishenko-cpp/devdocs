<div class="api"> <h1>Module Bytes</h1> <pre id="MODULEBytes" data-type="module Bytes [Module Bytes]" data-language="ocaml">module Bytes: sig .. end</pre>
<div class="info module top"> <div class="info-desc"> <p>Byte sequence operations.</p> <p>A byte sequence is a mutable data structure that contains a fixed-length sequence of bytes. Each byte can be indexed in constant time for reading or writing.</p> <p>Given a byte sequence <code class="code">s</code> of length <code class="code">l</code>, we can access each of the <code class="code">l</code> bytes of <code class="code">s</code> via its index in the sequence. Indexes start at <code class="code">0</code>, and we will call an index valid in <code class="code">s</code> if it falls within the range <code class="code">[0...l-1]</code> (inclusive). A position is the point between two bytes or at the beginning or end of the sequence. We call a position valid in <code class="code">s</code> if it falls within the range <code class="code">[0...l]</code> (inclusive). Note that the byte at index <code class="code">n</code> is between positions <code class="code">n</code> and <code class="code">n+1</code>.</p> <p>Two parameters <code class="code">start</code> and <code class="code">len</code> are said to designate a valid range of <code class="code">s</code> if <code class="code">len &gt;= 0</code> and <code class="code">start</code> and <code class="code">start+len</code> are valid positions in <code class="code">s</code>.</p> <p>Byte sequences can be modified in place, for instance via the <code class="code">set</code> and <code class="code">blit</code> functions described below. See also strings (module <a href="string.html"><code class="code"><span class="constructor">String</span></code></a>), which are almost the same data structure, but cannot be modified in place.</p> <p>Bytes are represented by the OCaml type <code class="code">char</code>.</p> <p>The labeled version of this module can be used as described in the <a href="stdlabels.html"><code class="code"><span class="constructor">StdLabels</span></code></a> module.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.02</li> </ul> </div>  <pre id="VALlength" data-type="val length [Module Bytes]" data-language="ocaml">val length : bytes -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>Return the length (number of bytes) of the argument.</p> </div> </div> <pre id="VALget" data-type="val get [Module Bytes]" data-language="ocaml">val get : bytes -&gt; int -&gt; char</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get s n</code> returns the byte at index <code class="code">n</code> in argument <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is not a valid index in <code class="code">s</code>.</li> </ul> </div> <pre id="VALset" data-type="val set [Module Bytes]" data-language="ocaml">val set : bytes -&gt; int -&gt; char -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set s n c</code> modifies <code class="code">s</code> in place, replacing the byte at index <code class="code">n</code> with <code class="code">c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n</code> is not a valid index in <code class="code">s</code>.</li> </ul> </div> <pre id="VALcreate" data-type="val create [Module Bytes]" data-language="ocaml">val create : int -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">create n</code> returns a new byte sequence of length <code class="code">n</code>. The sequence is uninitialized and contains arbitrary bytes.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a>.</li> </ul> </div> <pre id="VALmake" data-type="val make [Module Bytes]" data-language="ocaml">val make : int -&gt; char -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">make n c</code> returns a new byte sequence of length <code class="code">n</code>, filled with the byte <code class="code">c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a>.</li> </ul> </div> <pre id="VALinit" data-type="val init [Module Bytes]" data-language="ocaml">val init : int -&gt; (int -&gt; char) -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">init n f</code> returns a fresh byte sequence of length <code class="code">n</code>, with character <code class="code">i</code> initialized to the result of <code class="code">f i</code> (in increasing index order).</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">n &lt; 0</code> or <code class="code">n &gt; </code><a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a>.</li> </ul> </div> <pre id="VALempty" data-type="val empty [Module Bytes]" data-language="ocaml">val empty : bytes</pre>
<div class="info "> <div class="info-desc"> <p>A byte sequence of size 0.</p> </div> </div> <pre id="VALcopy" data-type="val copy [Module Bytes]" data-language="ocaml">val copy : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a new byte sequence that contains the same bytes as the argument.</p> </div> </div> <pre id="VALof_string" data-type="val of_string [Module Bytes]" data-language="ocaml">val of_string : string -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a new byte sequence that contains the same bytes as the given string.</p> </div> </div> <pre id="VALto_string" data-type="val to_string [Module Bytes]" data-language="ocaml">val to_string : bytes -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p>Return a new string that contains the same bytes as the given byte sequence.</p> </div> </div> <pre id="VALsub" data-type="val sub [Module Bytes]" data-language="ocaml">val sub : bytes -&gt; int -&gt; int -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">sub s pos len</code> returns a new byte sequence of length <code class="code">len</code>, containing the subsequence of <code class="code">s</code> that starts at position <code class="code">pos</code> and has length <code class="code">len</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">s</code>.</li> </ul> </div> <pre id="VALsub_string" data-type="val sub_string [Module Bytes]" data-language="ocaml">val sub_string : bytes -&gt; int -&gt; int -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="bytes.html#VALsub"><code class="code"><span class="constructor">Bytes</span>.sub</code></a> but return a string instead of a byte sequence.</p> </div> </div> <pre id="VALextend" data-type="val extend [Module Bytes]" data-language="ocaml">val extend : bytes -&gt; int -&gt; int -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">extend s left right</code> returns a new byte sequence that contains the bytes of <code class="code">s</code>, with <code class="code">left</code> uninitialized bytes prepended and <code class="code">right</code> uninitialized bytes appended to it. If <code class="code">left</code> or <code class="code">right</code> is negative, then bytes are removed (instead of appended) from the corresponding side of <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05 in BytesLabels</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the result length is negative or longer than <a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a> bytes.</li> </ul> </div> <pre id="VALfill" data-type="val fill [Module Bytes]" data-language="ocaml">val fill : bytes -&gt; int -&gt; int -&gt; char -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fill s pos len c</code> modifies <code class="code">s</code> in place, replacing <code class="code">len</code> characters with <code class="code">c</code>, starting at <code class="code">pos</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">s</code>.</li> </ul> </div> <pre id="VALblit" data-type="val blit [Module Bytes]" data-language="ocaml">val blit : bytes -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">blit src src_pos dst dst_pos len</code> copies <code class="code">len</code> bytes from byte sequence <code class="code">src</code>, starting at index <code class="code">src_pos</code>, to byte sequence <code class="code">dst</code>, starting at index <code class="code">dst_pos</code>. It works correctly even if <code class="code">src</code> and <code class="code">dst</code> are the same byte sequence, and the source and destination intervals overlap.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">src_pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">src</code>, or if <code class="code">dst_pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">dst</code>.</li> </ul> </div> <pre id="VALblit_string" data-type="val blit_string [Module Bytes]" data-language="ocaml">val blit_string : string -&gt; int -&gt; bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">blit_string src src_pos dst dst_pos len</code> copies <code class="code">len</code> bytes from string <code class="code">src</code>, starting at index <code class="code">src_pos</code>, to byte sequence <code class="code">dst</code>, starting at index <code class="code">dst_pos</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05 in BytesLabels</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">src_pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">src</code>, or if <code class="code">dst_pos</code> and <code class="code">len</code> do not designate a valid range of <code class="code">dst</code>.</li> </ul> </div> <pre id="VALconcat" data-type="val concat [Module Bytes]" data-language="ocaml">val concat : bytes -&gt; bytes list -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">concat sep sl</code> concatenates the list of byte sequences <code class="code">sl</code>, inserting the separator byte sequence <code class="code">sep</code> between each, and returns the result as a new byte sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the result is longer than <a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a> bytes.</li> </ul> </div> <pre id="VALcat" data-type="val cat [Module Bytes]" data-language="ocaml">val cat : bytes -&gt; bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">cat s1 s2</code> concatenates <code class="code">s1</code> and <code class="code">s2</code> and returns the result as a new byte sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05 in BytesLabels</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if the result is longer than <a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a> bytes.</li> </ul> </div> <pre id="VALiter" data-type="val iter [Module Bytes]" data-language="ocaml">val iter : (char -&gt; unit) -&gt; bytes -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">iter f s</code> applies function <code class="code">f</code> in turn to all the bytes of <code class="code">s</code>. It is equivalent to <code class="code">f (get s 0); f (get s 1); ...; f (get s<br>
    (length s - 1)); ()</code>.</p> </div> </div> <pre id="VALiteri" data-type="val iteri [Module Bytes]" data-language="ocaml">val iteri : (int -&gt; char -&gt; unit) -&gt; bytes -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p>Same as <a href="bytes.html#VALiter"><code class="code"><span class="constructor">Bytes</span>.iter</code></a>, but the function is applied to the index of the byte as first argument and the byte itself as second argument.</p> </div> </div> <pre id="VALmap" data-type="val map [Module Bytes]" data-language="ocaml">val map : (char -&gt; char) -&gt; bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">map f s</code> applies function <code class="code">f</code> in turn to all the bytes of <code class="code">s</code> (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p> </div> </div> <pre id="VALmapi" data-type="val mapi [Module Bytes]" data-language="ocaml">val mapi : (int -&gt; char -&gt; char) -&gt; bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">mapi f s</code> calls <code class="code">f</code> with each character of <code class="code">s</code> and its index (in increasing index order) and stores the resulting bytes in a new sequence that is returned as the result.</p> </div> </div> <pre id="VALfold_left" data-type="val fold_left [Module Bytes]" data-language="ocaml">val fold_left : ('acc -&gt; char -&gt; 'acc) -&gt; 'acc -&gt; bytes -&gt; 'acc</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_left f x s</code> computes <code class="code">f (... (f (f x (get s 0)) (get s 1)) ...) (get s (n-1))</code>, where <code class="code">n</code> is the length of <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALfold_right" data-type="val fold_right [Module Bytes]" data-language="ocaml">val fold_right : (char -&gt; 'acc -&gt; 'acc) -&gt; bytes -&gt; 'acc -&gt; 'acc</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">fold_right f s x</code> computes <code class="code">f (get s 0) (f (get s 1) ( ... (f (get s (n-1)) x) ...))</code>, where <code class="code">n</code> is the length of <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALfor_all" data-type="val for_all [Module Bytes]" data-language="ocaml">val for_all : (char -&gt; bool) -&gt; bytes -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">for_all p s</code> checks if all characters in <code class="code">s</code> satisfy the predicate <code class="code">p</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALexists" data-type="val exists [Module Bytes]" data-language="ocaml">val exists : (char -&gt; bool) -&gt; bytes -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">exists p s</code> checks if at least one character of <code class="code">s</code> satisfies the predicate <code class="code">p</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALtrim" data-type="val trim [Module Bytes]" data-language="ocaml">val trim : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, without leading and trailing whitespace. The bytes regarded as whitespace are the ASCII characters <code class="code"><span class="string">' '</span></code>, <code class="code"><span class="string">'\012'</span></code>, <code class="code"><span class="string">'\n'</span></code>, <code class="code"><span class="string">'\r'</span></code>, and <code class="code"><span class="string">'\t'</span></code>.</p> </div> </div> <pre id="VALescaped" data-type="val escaped [Module Bytes]" data-language="ocaml">val escaped : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, with special characters represented by escape sequences, following the lexical conventions of OCaml. All characters outside the ASCII printable range (32..126) are escaped, as well as backslash and double-quote.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if the result is longer than <a href="sys.html#VALmax_string_length"><code class="code"><span class="constructor">Sys</span>.max_string_length</code></a> bytes.</li> </ul> </div> <pre id="VALindex" data-type="val index [Module Bytes]" data-language="ocaml">val index : bytes -&gt; char -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">index s c</code> returns the index of the first occurrence of byte <code class="code">c</code> in <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code>.</li> </ul> </div> <pre id="VALindex_opt" data-type="val index_opt [Module Bytes]" data-language="ocaml">val index_opt : bytes -&gt; char -&gt; int option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">index_opt s c</code> returns the index of the first occurrence of byte <code class="code">c</code> in <code class="code">s</code> or <code class="code"><span class="constructor">None</span></code> if <code class="code">c</code> does not occur in <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALrindex" data-type="val rindex [Module Bytes]" data-language="ocaml">val rindex : bytes -&gt; char -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rindex s c</code> returns the index of the last occurrence of byte <code class="code">c</code> in <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code>.</li> </ul> </div> <pre id="VALrindex_opt" data-type="val rindex_opt [Module Bytes]" data-language="ocaml">val rindex_opt : bytes -&gt; char -&gt; int option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rindex_opt s c</code> returns the index of the last occurrence of byte <code class="code">c</code> in <code class="code">s</code> or <code class="code"><span class="constructor">None</span></code> if <code class="code">c</code> does not occur in <code class="code">s</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> </ul> </div> <pre id="VALindex_from" data-type="val index_from [Module Bytes]" data-language="ocaml">val index_from : bytes -&gt; int -&gt; char -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">index_from s i c</code> returns the index of the first occurrence of byte <code class="code">c</code> in <code class="code">s</code> after position <code class="code">i</code>. <code class="code">index s c</code> is equivalent to <code class="code">index_from s 0 c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b><ul>
<li>
<code>Invalid_argument</code> if <code class="code">i</code> is not a valid position in <code class="code">s</code>.</li> <li>
<code>Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code> after position <code class="code">i</code>.</li> </ul>
</li> </ul> </div> <pre id="VALindex_from_opt" data-type="val index_from_opt [Module Bytes]" data-language="ocaml">val index_from_opt : bytes -&gt; int -&gt; char -&gt; int option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">index_from_opt s i c</code> returns the index of the first occurrence of byte <code class="code">c</code> in <code class="code">s</code> after position <code class="code">i</code> or <code class="code"><span class="constructor">None</span></code> if <code class="code">c</code> does not occur in <code class="code">s</code> after position <code class="code">i</code>. <code class="code">index_opt s c</code> is equivalent to <code class="code">index_from_opt s 0 c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">i</code> is not a valid position in <code class="code">s</code>.</li> </ul> </div> <pre id="VALrindex_from" data-type="val rindex_from [Module Bytes]" data-language="ocaml">val rindex_from : bytes -&gt; int -&gt; char -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rindex_from s i c</code> returns the index of the last occurrence of byte <code class="code">c</code> in <code class="code">s</code> before position <code class="code">i+1</code>. <code class="code">rindex s c</code> is equivalent to <code class="code">rindex_from s (length s - 1) c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b><ul>
<li>
<code>Invalid_argument</code> if <code class="code">i+1</code> is not a valid position in <code class="code">s</code>.</li> <li>
<code>Not_found</code> if <code class="code">c</code> does not occur in <code class="code">s</code> before position <code class="code">i+1</code>.</li> </ul>
</li> </ul> </div> <pre id="VALrindex_from_opt" data-type="val rindex_from_opt [Module Bytes]" data-language="ocaml">val rindex_from_opt : bytes -&gt; int -&gt; char -&gt; int option</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rindex_from_opt s i c</code> returns the index of the last occurrence of byte <code class="code">c</code> in <code class="code">s</code> before position <code class="code">i+1</code> or <code class="code"><span class="constructor">None</span></code> if <code class="code">c</code> does not occur in <code class="code">s</code> before position <code class="code">i+1</code>. <code class="code">rindex_opt s c</code> is equivalent to <code class="code">rindex_from s (length s - 1) c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.05</li> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">i+1</code> is not a valid position in <code class="code">s</code>.</li> </ul> </div> <pre id="VALcontains" data-type="val contains [Module Bytes]" data-language="ocaml">val contains : bytes -&gt; char -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">contains s c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code>.</p> </div> </div> <pre id="VALcontains_from" data-type="val contains_from [Module Bytes]" data-language="ocaml">val contains_from : bytes -&gt; int -&gt; char -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">contains_from s start c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code> after position <code class="code">start</code>. <code class="code">contains s c</code> is equivalent to <code class="code">contains_from<br>
    s 0 c</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">start</code> is not a valid position in <code class="code">s</code>.</li> </ul> </div> <pre id="VALrcontains_from" data-type="val rcontains_from [Module Bytes]" data-language="ocaml">val rcontains_from : bytes -&gt; int -&gt; char -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">rcontains_from s stop c</code> tests if byte <code class="code">c</code> appears in <code class="code">s</code> before position <code class="code">stop+1</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Raises</b> <code>Invalid_argument</code> if <code class="code">stop &lt; 0</code> or <code class="code">stop+1</code> is not a valid position in <code class="code">s</code>.</li> </ul> </div> <pre id="VALuppercase_ascii" data-type="val uppercase_ascii [Module Bytes]" data-language="ocaml">val uppercase_ascii : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, with all lowercase letters translated to uppercase, using the US-ASCII character set.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03 (4.05 in BytesLabels)</li> </ul> </div> <pre id="VALlowercase_ascii" data-type="val lowercase_ascii [Module Bytes]" data-language="ocaml">val lowercase_ascii : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, with all uppercase letters translated to lowercase, using the US-ASCII character set.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03 (4.05 in BytesLabels)</li> </ul> </div> <pre id="VALcapitalize_ascii" data-type="val capitalize_ascii [Module Bytes]" data-language="ocaml">val capitalize_ascii : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, with the first character set to uppercase, using the US-ASCII character set.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03 (4.05 in BytesLabels)</li> </ul> </div> <pre id="VALuncapitalize_ascii" data-type="val uncapitalize_ascii [Module Bytes]" data-language="ocaml">val uncapitalize_ascii : bytes -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Return a copy of the argument, with the first character set to lowercase, using the US-ASCII character set.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03 (4.05 in BytesLabels)</li> </ul> </div> <pre id="TYPEt" data-type="type t [Module Bytes]" data-language="ocaml">type t = bytes </pre> <div class="info "> <div class="info-desc"> <p>An alias for the type of byte sequences.</p> </div> </div> <pre id="VALcompare" data-type="val compare [Module Bytes]" data-language="ocaml">val compare : t -&gt; t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p>The comparison function for byte sequences, with the same specification as <a href="stdlib.html#VALcompare"><code class="code">compare</code></a>. Along with the type <code class="code">t</code>, this function <code class="code">compare</code> allows the module <code class="code"><span class="constructor">Bytes</span></code> to be passed as argument to the functors <a href="set.make.html"><code class="code"><span class="constructor">Set</span>.<span class="constructor">Make</span></code></a> and <a href="map.make.html"><code class="code"><span class="constructor">Map</span>.<span class="constructor">Make</span></code></a>.</p> </div> </div> <pre id="VALequal" data-type="val equal [Module Bytes]" data-language="ocaml">val equal : t -&gt; t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p>The equality function for byte sequences.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.03 (4.05 in BytesLabels)</li> </ul> </div> <pre id="VALstarts_with" data-type="val starts_with [Module Bytes]" data-language="ocaml">val starts_with : prefix:bytes -&gt; bytes -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">starts_with </code><code class="code">~prefix s</code> is <code class="code"><span class="keyword">true</span></code> if and only if <code class="code">s</code> starts with <code class="code">prefix</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <pre id="VALends_with" data-type="val ends_with [Module Bytes]" data-language="ocaml">val ends_with : suffix:bytes -&gt; bytes -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">ends_with </code><code class="code">~suffix s</code> is <code class="code"><span class="keyword">true</span></code> if and only if <code class="code">s</code> ends with <code class="code">suffix</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <h2 id="unsafe">Unsafe conversions (for advanced users)</h2> <p>This section describes unsafe, low-level conversion functions between <code class="code">bytes</code> and <code class="code">string</code>. They do not copy the internal data; used improperly, they can break the immutability invariant on strings provided by the <code class="code">-safe-string</code> option. They are available for expert library authors, but for most purposes you should use the always-correct <a href="bytes.html#VALto_string"><code class="code"><span class="constructor">Bytes</span>.to_string</code></a> and <a href="bytes.html#VALof_string"><code class="code"><span class="constructor">Bytes</span>.of_string</code></a> instead.</p> <pre id="VALunsafe_to_string" data-type="val unsafe_to_string [Module Bytes]" data-language="ocaml">val unsafe_to_string : bytes -&gt; string</pre>
<div class="info "> <div class="info-desc"> <p>Unsafely convert a byte sequence into a string.</p> <p>To reason about the use of <code class="code">unsafe_to_string</code>, it is convenient to consider an "ownership" discipline. A piece of code that manipulates some data "owns" it; there are several disjoint ownership modes, including:</p> <ul> <li>Unique ownership: the data may be accessed and mutated</li> <li>Shared ownership: the data has several owners, that may only access it, not mutate it.</li> </ul> <p>Unique ownership is linear: passing the data to another piece of code means giving up ownership (we cannot write the data again). A unique owner may decide to make the data shared (giving up mutation rights on it), but shared data may not become uniquely-owned again.</p> <p><code class="code">unsafe_to_string s</code> can only be used when the caller owns the byte sequence <code class="code">s</code> -- either uniquely or as shared immutable data. The caller gives up ownership of <code class="code">s</code>, and gains ownership of the returned string.</p> <p>There are two valid use-cases that respect this ownership discipline:</p> <p>1. Creating a string by initializing and mutating a byte sequence that is never changed after initialization is performed.</p> <pre class="codepre" data-language="ocaml">let string_init len f : string =
  let s = Bytes.create len in
  for i = 0 to len - 1 do Bytes.set s i (f i) done;
  Bytes.unsafe_to_string s
   </pre> <p>This function is safe because the byte sequence <code class="code">s</code> will never be accessed or mutated after <code class="code">unsafe_to_string</code> is called. The <code class="code">string_init</code> code gives up ownership of <code class="code">s</code>, and returns the ownership of the resulting string to its caller.</p> <p>Note that it would be unsafe if <code class="code">s</code> was passed as an additional parameter to the function <code class="code">f</code> as it could escape this way and be mutated in the future -- <code class="code">string_init</code> would give up ownership of <code class="code">s</code> to pass it to <code class="code">f</code>, and could not call <code class="code">unsafe_to_string</code> safely.</p> <p>We have provided the <a href="string.html#VALinit"><code class="code"><span class="constructor">String</span>.init</code></a>, <a href="string.html#VALmap"><code class="code"><span class="constructor">String</span>.map</code></a> and <a href="string.html#VALmapi"><code class="code"><span class="constructor">String</span>.mapi</code></a> functions to cover most cases of building new strings. You should prefer those over <code class="code">to_string</code> or <code class="code">unsafe_to_string</code> whenever applicable.</p> <p>2. Temporarily giving ownership of a byte sequence to a function that expects a uniquely owned string and returns ownership back, so that we can mutate the sequence again after the call ended.</p> <pre class="codepre" data-language="ocaml">let bytes_length (s : bytes) =
  String.length (Bytes.unsafe_to_string s)
   </pre> <p>In this use-case, we do not promise that <code class="code">s</code> will never be mutated after the call to <code class="code">bytes_length s</code>. The <a href="string.html#VALlength"><code class="code"><span class="constructor">String</span>.length</code></a> function temporarily borrows unique ownership of the byte sequence (and sees it as a <code class="code">string</code>), but returns this ownership back to the caller, which may assume that <code class="code">s</code> is still a valid byte sequence after the call. Note that this is only correct because we know that <a href="string.html#VALlength"><code class="code"><span class="constructor">String</span>.length</code></a> does not capture its argument -- it could escape by a side-channel such as a memoization combinator.</p> <p>The caller may not mutate <code class="code">s</code> while the string is borrowed (it has temporarily given up ownership). This affects concurrent programs, but also higher-order functions: if <a href="string.html#VALlength"><code class="code"><span class="constructor">String</span>.length</code></a> returned a closure to be called later, <code class="code">s</code> should not be mutated until this closure is fully applied and returns ownership.</p> </div> </div> <pre id="VALunsafe_of_string" data-type="val unsafe_of_string [Module Bytes]" data-language="ocaml">val unsafe_of_string : string -&gt; bytes</pre>
<div class="info "> <div class="info-desc"> <p>Unsafely convert a shared string to a byte sequence that should not be mutated.</p> <p>The same ownership discipline that makes <code class="code">unsafe_to_string</code> correct applies to <code class="code">unsafe_of_string</code>: you may use it if you were the owner of the <code class="code">string</code> value, and you will own the return <code class="code">bytes</code> in the same mode.</p> <p>In practice, unique ownership of string values is extremely difficult to reason about correctly. You should always assume strings are shared, never uniquely owned.</p> <p>For example, string literals are implicitly shared by the compiler, so you never uniquely own them.</p> <pre class="codepre" data-language="ocaml">let incorrect = Bytes.unsafe_of_string "hello"
let s = Bytes.of_string "hello"
    </pre> <p>The first declaration is incorrect, because the string literal <code class="code"><span class="string">"hello"</span></code> could be shared by the compiler with other parts of the program, and mutating <code class="code">incorrect</code> is a bug. You must always use the second version, which performs a copy and is thus correct.</p> <p>Assuming unique ownership of strings that are not string literals, but are (partly) built from string literals, is also incorrect. For example, mutating <code class="code">unsafe_of_string (<span class="string">"foo"</span> ^ s)</code> could mutate the shared string <code class="code"><span class="string">"foo"</span></code> -- assuming a rope-like representation of strings. More generally, functions operating on strings will assume shared ownership, they do not preserve unique ownership. It is thus incorrect to assume unique ownership of the result of <code class="code">unsafe_of_string</code>.</p> <p>The only case we have reasonable confidence is safe is if the produced <code class="code">bytes</code> is shared -- used as an immutable byte sequence. This is possibly useful for incremental migration of low-level programs that manipulate immutable sequences of bytes (for example <a href="marshal.html#VALfrom_bytes"><code class="code"><span class="constructor">Marshal</span>.from_bytes</code></a>) and previously used the <code class="code">string</code> type for this purpose.</p> </div> </div> <pre id="VALsplit_on_char" data-type="val split_on_char [Module Bytes]" data-language="ocaml">val split_on_char : char -&gt; bytes -&gt; bytes list</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">split_on_char sep s</code> returns the list of all (possibly empty) subsequences of <code class="code">s</code> that are delimited by the <code class="code">sep</code> character. If <code class="code">s</code> is empty, the result is the singleton list <code class="code">[empty]</code>.</p> <p>The function's output is specified by the following invariants:</p> <ul> <li>The list is not empty.</li> <li>Concatenating its elements using <code class="code">sep</code> as a separator returns a byte sequence equal to the input (<code class="code"><span class="constructor">Bytes</span>.concat (<span class="constructor">Bytes</span>.make 1 sep)<br>
      (<span class="constructor">Bytes</span>.split_on_char sep s) = s</code>).</li> <li>No byte sequence in the result contains the <code class="code">sep</code> character.</li> </ul> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.13</li> </ul> </div> <h2 id="1_Iterators">Iterators</h2> <pre id="VALto_seq" data-type="val to_seq [Module Bytes]" data-language="ocaml">val to_seq : t -&gt; char Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the string, in increasing index order. Modifications of the string during iteration will be reflected in the sequence.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALto_seqi" data-type="val to_seqi [Module Bytes]" data-language="ocaml">val to_seqi : t -&gt; (int * char) Seq.t</pre>
<div class="info "> <div class="info-desc"> <p>Iterate on the string, in increasing order, yielding indices along chars</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <pre id="VALof_seq" data-type="val of_seq [Module Bytes]" data-language="ocaml">val of_seq : char Seq.t -&gt; t</pre>
<div class="info "> <div class="info-desc"> <p>Create a string from the generator</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.07</li> </ul> </div> <h2 id="utf">UTF codecs and validations</h2>
<h3 id="utf_8">UTF-8</h3> <pre id="VALget_utf_8_uchar" data-type="val get_utf_8_uchar [Module Bytes]" data-language="ocaml">val get_utf_8_uchar : t -&gt; int -&gt; Uchar.utf_decode</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_utf_8_uchar b i</code> decodes an UTF-8 character at index <code class="code">i</code> in <code class="code">b</code>.</p> </div> </div> <pre id="VALset_utf_8_uchar" data-type="val set_utf_8_uchar [Module Bytes]" data-language="ocaml">val set_utf_8_uchar : t -&gt; int -&gt; Uchar.t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_utf_8_uchar b i u</code> UTF-8 encodes <code class="code">u</code> at index <code class="code">i</code> in <code class="code">b</code> and returns the number of bytes <code class="code">n</code> that were written starting at <code class="code">i</code>. If <code class="code">n</code> is <code class="code">0</code> there was not enough space to encode <code class="code">u</code> at <code class="code">i</code> and <code class="code">b</code> was left untouched. Otherwise a new character can be encoded at <code class="code">i + n</code>.</p> </div> </div> <pre id="VALis_valid_utf_8" data-type="val is_valid_utf_8 [Module Bytes]" data-language="ocaml">val is_valid_utf_8 : t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_valid_utf_8 b</code> is <code class="code"><span class="keyword">true</span></code> if and only if <code class="code">b</code> contains valid UTF-8 data.</p> </div> </div> <h3 id="utf_16be">UTF-16BE</h3> <pre id="VALget_utf_16be_uchar" data-type="val get_utf_16be_uchar [Module Bytes]" data-language="ocaml">val get_utf_16be_uchar : t -&gt; int -&gt; Uchar.utf_decode</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_utf_16be_uchar b i</code> decodes an UTF-16BE character at index <code class="code">i</code> in <code class="code">b</code>.</p> </div> </div> <pre id="VALset_utf_16be_uchar" data-type="val set_utf_16be_uchar [Module Bytes]" data-language="ocaml">val set_utf_16be_uchar : t -&gt; int -&gt; Uchar.t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_utf_16be_uchar b i u</code> UTF-16BE encodes <code class="code">u</code> at index <code class="code">i</code> in <code class="code">b</code> and returns the number of bytes <code class="code">n</code> that were written starting at <code class="code">i</code>. If <code class="code">n</code> is <code class="code">0</code> there was not enough space to encode <code class="code">u</code> at <code class="code">i</code> and <code class="code">b</code> was left untouched. Otherwise a new character can be encoded at <code class="code">i + n</code>.</p> </div> </div> <pre id="VALis_valid_utf_16be" data-type="val is_valid_utf_16be [Module Bytes]" data-language="ocaml">val is_valid_utf_16be : t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_valid_utf_16be b</code> is <code class="code"><span class="keyword">true</span></code> if and only if <code class="code">b</code> contains valid UTF-16BE data.</p> </div> </div> <h3 id="utf_16le">UTF-16LE</h3> <pre id="VALget_utf_16le_uchar" data-type="val get_utf_16le_uchar [Module Bytes]" data-language="ocaml">val get_utf_16le_uchar : t -&gt; int -&gt; Uchar.utf_decode</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_utf_16le_uchar b i</code> decodes an UTF-16LE character at index <code class="code">i</code> in <code class="code">b</code>.</p> </div> </div> <pre id="VALset_utf_16le_uchar" data-type="val set_utf_16le_uchar [Module Bytes]" data-language="ocaml">val set_utf_16le_uchar : t -&gt; int -&gt; Uchar.t -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_utf_16le_uchar b i u</code> UTF-16LE encodes <code class="code">u</code> at index <code class="code">i</code> in <code class="code">b</code> and returns the number of bytes <code class="code">n</code> that were written starting at <code class="code">i</code>. If <code class="code">n</code> is <code class="code">0</code> there was not enough space to encode <code class="code">u</code> at <code class="code">i</code> and <code class="code">b</code> was left untouched. Otherwise a new character can be encoded at <code class="code">i + n</code>.</p> </div> </div> <pre id="VALis_valid_utf_16le" data-type="val is_valid_utf_16le [Module Bytes]" data-language="ocaml">val is_valid_utf_16le : t -&gt; bool</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">is_valid_utf_16le b</code> is <code class="code"><span class="keyword">true</span></code> if and only if <code class="code">b</code> contains valid UTF-16LE data.</p> </div> </div> <h2 id="1_Binaryencodingdecodingofintegers">Binary encoding/decoding of integers</h2>
<p>The functions in this section binary encode and decode integers to and from byte sequences.</p> <p>All following functions raise <code class="code"><span class="constructor">Invalid_argument</span></code> if the space needed at index <code class="code">i</code> to decode or encode the integer is not available.</p> <p>Little-endian (resp. big-endian) encoding means that least (resp. most) significant bytes are stored first. Big-endian is also known as network byte order. Native-endian encoding is either little-endian or big-endian depending on <a href="sys.html#VALbig_endian"><code class="code"><span class="constructor">Sys</span>.big_endian</code></a>.</p> <p>32-bit and 64-bit integers are represented by the <code class="code">int32</code> and <code class="code">int64</code> types, which can be interpreted either as signed or unsigned numbers.</p> <p>8-bit and 16-bit integers are represented by the <code class="code">int</code> type, which has more bits than the binary encoding. These extra bits are handled as follows:</p> <ul> <li>Functions that decode signed (resp. unsigned) 8-bit or 16-bit integers represented by <code class="code">int</code> values sign-extend (resp. zero-extend) their result.</li> <li>Functions that encode 8-bit or 16-bit integers represented by <code class="code">int</code> values truncate their input to their least significant bytes.</li> </ul> <pre id="VALget_uint8" data-type="val get_uint8 [Module Bytes]" data-language="ocaml">val get_uint8 : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_uint8 b i</code> is <code class="code">b</code>'s unsigned 8-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int8" data-type="val get_int8 [Module Bytes]" data-language="ocaml">val get_int8 : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int8 b i</code> is <code class="code">b</code>'s signed 8-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_uint16_ne" data-type="val get_uint16_ne [Module Bytes]" data-language="ocaml">val get_uint16_ne : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_uint16_ne b i</code> is <code class="code">b</code>'s native-endian unsigned 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_uint16_be" data-type="val get_uint16_be [Module Bytes]" data-language="ocaml">val get_uint16_be : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_uint16_be b i</code> is <code class="code">b</code>'s big-endian unsigned 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_uint16_le" data-type="val get_uint16_le [Module Bytes]" data-language="ocaml">val get_uint16_le : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_uint16_le b i</code> is <code class="code">b</code>'s little-endian unsigned 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int16_ne" data-type="val get_int16_ne [Module Bytes]" data-language="ocaml">val get_int16_ne : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int16_ne b i</code> is <code class="code">b</code>'s native-endian signed 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int16_be" data-type="val get_int16_be [Module Bytes]" data-language="ocaml">val get_int16_be : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int16_be b i</code> is <code class="code">b</code>'s big-endian signed 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int16_le" data-type="val get_int16_le [Module Bytes]" data-language="ocaml">val get_int16_le : bytes -&gt; int -&gt; int</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int16_le b i</code> is <code class="code">b</code>'s little-endian signed 16-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int32_ne" data-type="val get_int32_ne [Module Bytes]" data-language="ocaml">val get_int32_ne : bytes -&gt; int -&gt; int32</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int32_ne b i</code> is <code class="code">b</code>'s native-endian 32-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int32_be" data-type="val get_int32_be [Module Bytes]" data-language="ocaml">val get_int32_be : bytes -&gt; int -&gt; int32</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int32_be b i</code> is <code class="code">b</code>'s big-endian 32-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int32_le" data-type="val get_int32_le [Module Bytes]" data-language="ocaml">val get_int32_le : bytes -&gt; int -&gt; int32</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int32_le b i</code> is <code class="code">b</code>'s little-endian 32-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int64_ne" data-type="val get_int64_ne [Module Bytes]" data-language="ocaml">val get_int64_ne : bytes -&gt; int -&gt; int64</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int64_ne b i</code> is <code class="code">b</code>'s native-endian 64-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int64_be" data-type="val get_int64_be [Module Bytes]" data-language="ocaml">val get_int64_be : bytes -&gt; int -&gt; int64</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int64_be b i</code> is <code class="code">b</code>'s big-endian 64-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALget_int64_le" data-type="val get_int64_le [Module Bytes]" data-language="ocaml">val get_int64_le : bytes -&gt; int -&gt; int64</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">get_int64_le b i</code> is <code class="code">b</code>'s little-endian 64-bit integer starting at byte index <code class="code">i</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_uint8" data-type="val set_uint8 [Module Bytes]" data-language="ocaml">val set_uint8 : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_uint8 b i v</code> sets <code class="code">b</code>'s unsigned 8-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int8" data-type="val set_int8 [Module Bytes]" data-language="ocaml">val set_int8 : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int8 b i v</code> sets <code class="code">b</code>'s signed 8-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_uint16_ne" data-type="val set_uint16_ne [Module Bytes]" data-language="ocaml">val set_uint16_ne : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_uint16_ne b i v</code> sets <code class="code">b</code>'s native-endian unsigned 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_uint16_be" data-type="val set_uint16_be [Module Bytes]" data-language="ocaml">val set_uint16_be : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_uint16_be b i v</code> sets <code class="code">b</code>'s big-endian unsigned 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_uint16_le" data-type="val set_uint16_le [Module Bytes]" data-language="ocaml">val set_uint16_le : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_uint16_le b i v</code> sets <code class="code">b</code>'s little-endian unsigned 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int16_ne" data-type="val set_int16_ne [Module Bytes]" data-language="ocaml">val set_int16_ne : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int16_ne b i v</code> sets <code class="code">b</code>'s native-endian signed 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int16_be" data-type="val set_int16_be [Module Bytes]" data-language="ocaml">val set_int16_be : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int16_be b i v</code> sets <code class="code">b</code>'s big-endian signed 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int16_le" data-type="val set_int16_le [Module Bytes]" data-language="ocaml">val set_int16_le : bytes -&gt; int -&gt; int -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int16_le b i v</code> sets <code class="code">b</code>'s little-endian signed 16-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int32_ne" data-type="val set_int32_ne [Module Bytes]" data-language="ocaml">val set_int32_ne : bytes -&gt; int -&gt; int32 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int32_ne b i v</code> sets <code class="code">b</code>'s native-endian 32-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int32_be" data-type="val set_int32_be [Module Bytes]" data-language="ocaml">val set_int32_be : bytes -&gt; int -&gt; int32 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int32_be b i v</code> sets <code class="code">b</code>'s big-endian 32-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int32_le" data-type="val set_int32_le [Module Bytes]" data-language="ocaml">val set_int32_le : bytes -&gt; int -&gt; int32 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int32_le b i v</code> sets <code class="code">b</code>'s little-endian 32-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int64_ne" data-type="val set_int64_ne [Module Bytes]" data-language="ocaml">val set_int64_ne : bytes -&gt; int -&gt; int64 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int64_ne b i v</code> sets <code class="code">b</code>'s native-endian 64-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int64_be" data-type="val set_int64_be [Module Bytes]" data-language="ocaml">val set_int64_be : bytes -&gt; int -&gt; int64 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int64_be b i v</code> sets <code class="code">b</code>'s big-endian 64-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <pre id="VALset_int64_le" data-type="val set_int64_le [Module Bytes]" data-language="ocaml">val set_int64_le : bytes -&gt; int -&gt; int64 -&gt; unit</pre>
<div class="info "> <div class="info-desc"> <p><code class="code">set_int64_le b i v</code> sets <code class="code">b</code>'s little-endian 64-bit integer starting at byte index <code class="code">i</code> to <code class="code">v</code>.</p> </div> <ul class="info-attributes"> <li>
<b>Since</b> 4.08</li> </ul> </div> <h2 id="bytes_concurrency">Byte sequences and concurrency safety</h2> <p>Care must be taken when concurrently accessing byte sequences from multiple domains: accessing a byte sequence will never crash a program, but unsynchronized accesses might yield surprising (non-sequentially-consistent) results.</p> <h3 id="byte_atomicity">Atomicity</h3> <p>Every byte sequence operation that accesses more than one byte is not atomic. This includes iteration and scanning.</p> <p>For example, consider the following program:</p> <pre class="codepre" data-language="ocaml">let size = 100_000_000
let b = Bytes.make size  ' '
let update b f ()  =
  Bytes.iteri (fun i x -&gt; Bytes.set b i (Char.chr (f (Char.code x)))) b
let d1 = Domain.spawn (update b (fun x -&gt; x + 1))
let d2 = Domain.spawn (update b (fun x -&gt; 2 * x + 1))
let () = Domain.join d1; Domain.join d2
</pre>
<p>the bytes sequence <code class="code">b</code> may contain a non-deterministic mixture of <code class="code"><span class="string">'!'</span></code>, <code class="code"><span class="string">'A'</span></code>, <code class="code"><span class="string">'B'</span></code>, and <code class="code"><span class="string">'C'</span></code> values.</p> <p>After executing this code, each byte of the sequence <code class="code">b</code> is either <code class="code"><span class="string">'!'</span></code>, <code class="code"><span class="string">'A'</span></code>, <code class="code"><span class="string">'B'</span></code>, or <code class="code"><span class="string">'C'</span></code>. If atomicity is required, then the user must implement their own synchronization (for example, using <a href="mutex.html#TYPEt"><code class="code"><span class="constructor">Mutex</span>.t</code></a>).</p> <h3 id="bytes_data_race">Data races</h3> <p>If two domains only access disjoint parts of a byte sequence, then the observed behaviour is the equivalent to some sequential interleaving of the operations from the two domains.</p> <p>A data race is said to occur when two domains access the same byte without synchronization and at least one of the accesses is a write. In the absence of data races, the observed behaviour is equivalent to some sequential interleaving of the operations from different domains.</p> <p>Whenever possible, data races should be avoided by using synchronization to mediate the accesses to the elements of the sequence.</p> <p>Indeed, in the presence of data races, programs will not crash but the observed behaviour may not be equivalent to any sequential interleaving of operations from different domains. Nevertheless, even in the presence of data races, a read operation will return the value of some prior write to that location.</p> <h3 id="bytes_mixed_access">Mixed-size accesses </h3> <p>Another subtle point is that if a data race involves mixed-size writes and reads to the same location, the order in which those writes and reads are observed by domains is not specified. For instance, the following code write sequentially a 32-bit integer and a <code class="code">char</code> to the same index</p> <pre class="codepre" data-language="ocaml">let b = Bytes.make 10 '\000'
let d1 = Domain.spawn (fun () -&gt; Bytes.set_int32_ne b 0 100; b.[0] &lt;- 'd' )
</pre> <p>In this situation, a domain that observes the write of 'd' to b.<code class="code">0</code> is not guaranteed to also observe the write to indices <code class="code">1</code>, <code class="code">2</code>, or <code class="code">3</code>.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/api/Bytes.html" class="_attribution-link">https://ocaml.org/manual/5.2/api/Bytes.html</a>
  </p>
</div>
