<div class="content manual">
<nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu">
<li><a href="coreexamples.html">The core language</a></li>
<li><a href="moduleexamples.html">The module system</a></li>
<li class="active"><a href="objectexamples.html">Objects in OCaml</a></li>
<li><a href="lablexamples.html">Labeled arguments</a></li>
<li><a href="polyvariant.html">Polymorphic variants</a></li>
<li><a href="polymorphism.html">Polymorphism and its limitations</a></li>
<li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li>
<li><a href="advexamples.html">Advanced examples with classes and modules</a></li>
<li><a href="parallelism.html">Parallel programming</a></li>
<li><a href="memorymodel.html">Memory model: The hard bits</a></li>
</ul> <h1 class="chapter" id="sec26">Chapter 3 Objects in OCaml</h1>  

<p><br> <br> </p>
<p>This chapter gives an overview of the object-oriented features of OCaml.</p>
<p>Note that the relationship between object, class and type in OCaml is different than in mainstream object-oriented languages such as Java and C++, so you shouldn’t assume that similar keywords mean the same thing. Object-oriented features are used much less frequently in OCaml than in those languages. OCaml has alternatives that are often more appropriate, such as modules and functors. Indeed, many OCaml programs do not use objects at all.</p> <h2 class="section" id="s:classes-and-objects">
<span class="number">1</span> Classes and objects</h2> <p>The class <span class="machine"><span class="font-tt">point</span></span> below defines one instance variable <span class="machine"><span class="font-tt">x</span></span> and two methods <span class="machine"><span class="font-tt">get_x</span></span> and <span class="machine"><span class="font-tt">move</span></span>. The initial value of the instance variable is <span class="machine"><span class="font-tt">0</span></span>. The variable <span class="machine"><span class="font-tt">x</span></span> is declared mutable, so the method <span class="machine"><span class="font-tt">move</span></span> can change its value. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point =
    object
      val mutable x = 0
      method get_x = x
      method move d = x &lt;- x + d
    end;;

class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end</pre> </div> </div>
<p>We now create a new point <span class="machine"><span class="font-tt">p</span></span>, instance of the <span class="machine"><span class="font-tt">point</span></span> class. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let p = new point;;

val p : point = </pre> </div> </div>
<p> Note that the type of <span class="machine"><span class="font-tt">p</span></span> is <span class="machine"><span class="font-tt">point</span></span>. This is an abbreviation automatically defined by the class definition above. It stands for the object type <span class="machine"><span class="font-tt">&lt;get_x : int; move : int -&gt; unit&gt;</span></span>, listing the methods of class <span class="machine"><span class="font-tt">point</span></span> along with their types.</p>
<p>We now invoke some methods of <span class="machine"><span class="font-tt">p</span></span>: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 0</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#move 3;;

- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 3</pre> </div> </div>
<p>The evaluation of the body of a class only takes place at object creation time. Therefore, in the following example, the instance variable <span class="machine"><span class="font-tt">x</span></span> is initialized to different values for two different objects. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let x0 = ref 0;;

val x0 : int ref = {contents = 0}</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class point =
    object
      val mutable x = incr x0; !x0
      method get_x = x
      method move d = x &lt;- x + d
    end;;

class point :
  object val mutable x : int method get_x : int method move : int -&gt; unit end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># new point#get_x;;

- : int = 1</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># new point#get_x;;

- : int = 2</pre> </div> </div>
<p>The class <span class="machine"><span class="font-tt">point</span></span> can also be abstracted over the initial values of the <span class="machine"><span class="font-tt">x</span></span> coordinate. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point = fun x_init -&gt;
    object
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;

class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end</pre> </div> </div>
<p> Like in function definitions, the definition above can be abbreviated as: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;

class point :
  int -&gt;
  object val mutable x : int method get_x : int method move : int -&gt; unit end</pre> </div> </div>
<p> An instance of the class <span class="machine"><span class="font-tt">point</span></span> is now a function that expects an initial parameter to create a point object: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># new point;;

- : int -&gt; point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new point 7;;

val p : point = </pre> </div> </div>
<p> The parameter <span class="machine"><span class="font-tt">x_init</span></span> is, of course, visible in the whole body of the definition, including methods. For instance, the method <span class="machine"><span class="font-tt">get_offset</span></span> in the class below returns the position of the object relative to its initial position. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point x_init =
    object
      val mutable x = x_init
      method get_x = x
      method get_offset = x - x_init
      method move d = x &lt;- x + d
    end;;

class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p> Expressions can be evaluated and bound before defining the object body of the class. This is useful to enforce invariants. For instance, points can be automatically adjusted to the nearest point on a grid, as follows: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class adjusted_point x_init =
    let origin = (x_init / 10) * 10 in
    object
      val mutable x = origin
      method get_x = x
      method get_offset = x - origin
      method move d = x &lt;- x + d
    end;;

class adjusted_point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p> (One could also raise an exception if the <span class="machine"><span class="font-tt">x_init</span></span> coordinate is not on the grid.) In fact, the same effect could be obtained here by calling the definition of class <span class="machine"><span class="font-tt">point</span></span> with the value of the <span class="machine"><span class="font-tt">origin</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class adjusted_point x_init =  point ((x_init / 10) * 10);;

class adjusted_point : int -&gt; point</pre> </div> </div>
<p> An alternate solution would have been to define the adjustment in a special allocation function: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let new_adjusted_point x_init = new point ((x_init / 10) * 10);;

val new_adjusted_point : int -&gt; point = </pre> </div> </div>
<p> However, the former pattern is generally more appropriate, since the code for adjustment is part of the definition of the class and will be inherited.</p>
<p>This ability provides class constructors as can be found in other languages. Several constructors can be defined this way to build objects of the same class but with different initialization patterns; an alternative is to use initializers, as described below in section ‍<a href="#s%3Ainitializers">3.4</a>.</p> <h2 class="section" id="s:immediate-objects">
<a class="section-anchor" href="#s:immediate-objects" aria-hidden="true">﻿</a><span class="number">2</span> Immediate objects</h2> <p>There is another, more direct way to create an object: create it without going through a class.</p>
<p>The syntax is exactly the same as for class expressions, but the result is a single object rather than a class. All the constructs described in the rest of this section also apply to immediate objects. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let p =
    object
      val mutable x = 0
      method get_x = x
      method move d = x &lt;- x + d
    end;;

val p : &lt; get_x : int; move : int -&gt; unit &gt; = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 0</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#move 3;;

- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 3</pre> </div> </div>
<p>Unlike classes, which cannot be defined inside an expression, immediate objects can appear anywhere, using variables from their environment. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let minmax x y =
    if x &lt; y then object method min = x method max = y end
    else object method min = y method max = x end;;

val minmax : 'a -&gt; 'a -&gt; &lt; max : 'a; min : 'a &gt; = </pre> </div> </div>
<p>Immediate objects have two weaknesses compared to classes: their types are not abbreviated, and you cannot inherit from them. But these two weaknesses can be advantages in some situations, as we will see in sections ‍<a href="#s%3Areference-to-self">3.3</a> and ‍<a href="#s%3Aparameterized-classes">3.10</a>.</p> <h2 class="section" id="s:reference-to-self">
<a class="section-anchor" href="#s:reference-to-self" aria-hidden="true">﻿</a><span class="number">3</span> Reference to self</h2> <p>A method or an initializer can invoke methods on self (that is, the current object). For that, self must be explicitly bound, here to the variable <span class="machine"><span class="font-tt">s</span></span> (<span class="machine"><span class="font-tt">s</span></span> could be any identifier, even though we will often choose the name <span class="machine"><span class="font-tt">self</span></span>.) </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class printable_point x_init =
    object (s)
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
      method print = print_int s#get_x
    end;;

class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new printable_point 7;;

val p : printable_point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#print;;

7- : unit = ()</pre> </div> </div>
<p> Dynamically, the variable <span class="machine"><span class="font-tt">s</span></span> is bound at the invocation of a method. In particular, when the class <span class="machine"><span class="font-tt">printable_point</span></span> is inherited, the variable <span class="machine"><span class="font-tt">s</span></span> will be correctly bound to the object of the subclass.</p>
<p>A common problem with self is that, as its type may be extended in subclasses, you cannot fix it in advance. Here is a simple example. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let ints = ref [];;

val ints : '_weak1 list ref = {contents = []}</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class my_int =
    object (self)
      method n = 1
      method register = ints := self :: !ints
    end ;;

Error: This expression has type &lt; n : int; register : 'a; .. &gt;
       but an expression was expected of type 'weak1
       Self type cannot escape its class</pre> </div> </div>
<p> You can ignore the first two lines of the error message. What matters is the last one: putting self into an external reference would make it impossible to extend it through inheritance. We will see in section ‍<a href="#s%3Ausing-coercions">3.12</a> a workaround to this problem. Note however that, since immediate objects are not extensible, the problem does not occur with them. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let my_int =
    object (self)
      method n = 1
      method register = ints := self :: !ints
    end;;

val my_int : &lt; n : int; register : unit &gt; = </pre> </div> </div> <h2 class="section" id="s:initializers">
<a class="section-anchor" href="#s:initializers" aria-hidden="true">﻿</a><span class="number">4</span> Initializers</h2> <p>Let-bindings within class definitions are evaluated before the object is constructed. It is also possible to evaluate an expression immediately after the object has been built. Such code is written as an anonymous hidden method called an initializer. Therefore, it can access self and the instance variables. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class printable_point x_init =
    let origin = (x_init / 10) * 10 in
    object (self)
      val mutable x = origin
      method get_x = x
      method move d = x &lt;- x + d
      method print = print_int self#get_x
      initializer print_string "new point at "; self#print; print_newline ()
    end;;

class printable_point :
  int -&gt;
  object
    val mutable x : int
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new printable_point 17;;

new point at 10
val p : printable_point = </pre> </div> </div>
<p> Initializers cannot be overridden. On the contrary, all initializers are evaluated sequentially. Initializers are particularly useful to enforce invariants. Another example can be seen in section ‍<a href="advexamples.html#s%3Aextended-bank-accounts">8.1</a>.</p> <h2 class="section" id="s:virtual-methods">
<a class="section-anchor" href="#s:virtual-methods" aria-hidden="true">﻿</a><span class="number">5</span> Virtual methods</h2> <p>It is possible to declare a method without actually defining it, using the keyword <span class="machine"><span class="font-tt">virtual</span></span>. This method will be provided later in subclasses. A class containing virtual methods must be flagged <span class="machine"><span class="font-tt">virtual</span></span>, and cannot be instantiated (that is, no object of this class can be created). It still defines type abbreviations (treating virtual methods as other methods.) </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class virtual abstract_point x_init =
    object (self)
      method virtual get_x : int
      method get_offset = self#get_x - x_init
      method virtual move : int -&gt; unit
    end;;

class virtual abstract_point :
  int -&gt;
  object
    method get_offset : int
    method virtual get_x : int
    method virtual move : int -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class point x_init =
    object
      inherit abstract_point x_init
      val mutable x = x_init
      method get_x = x
      method move d = x &lt;- x + d
    end;;

class point :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p>Instance variables can also be declared as virtual, with the same effect as with methods. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class virtual abstract_point2 =
    object
      val mutable virtual x : int
      method move d = x &lt;- x + d
    end;;

class virtual abstract_point2 :
  object val mutable virtual x : int method move : int -&gt; unit end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class point2 x_init =
    object
      inherit abstract_point2
      val mutable x = x_init
      method get_offset = x - x_init
    end;;

class point2 :
  int -&gt;
  object
    val mutable x : int
    method get_offset : int
    method move : int -&gt; unit
  end</pre> </div> </div> <h2 class="section" id="s:private-methods">
<a class="section-anchor" href="#s:private-methods" aria-hidden="true">﻿</a><span class="number">6</span> Private methods</h2> <p>Private methods are methods that do not appear in object interfaces. They can only be invoked from other methods of the same object. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class restricted_point x_init =
    object (self)
      val mutable x = x_init
      method get_x = x
      method private move d = x &lt;- x + d
      method bump = self#move 1
    end;;

class restricted_point :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method private move : int -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new restricted_point 0;;

val p : restricted_point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#move 10 ;;

Error: This expression has type restricted_point
       It has no method move</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#bump;;

- : unit = ()</pre> </div> </div>
<p> Note that this is not the same thing as private and protected methods in Java or C++, which can be called from other objects of the same class. This is a direct consequence of the independence between types and classes in OCaml: two unrelated classes may produce objects of the same type, and there is no way at the type level to ensure that an object comes from a specific class. However a possible encoding of friend methods is given in section ‍<a href="#s%3Afriends">3.17</a>.</p>
<p>Private methods are inherited (they are by default visible in subclasses), unless they are hidden by signature matching, as described below.</p>
<p>Private methods can be made public in a subclass. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point_again x =
    object (self)
      inherit restricted_point x
      method virtual move : _
    end;;

class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p> The annotation <span class="machine"><span class="font-tt">virtual</span></span> here is only used to mention a method without providing its definition. Since we didn’t add the <span class="machine"><span class="font-tt">private</span></span> annotation, this makes the method public, keeping the original definition.</p>
<p>An alternative definition is </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point_again x =
    object (self : &lt; move : _; ..&gt; )
      inherit restricted_point x
    end;;

class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p> The constraint on self’s type is requiring a public <span class="machine"><span class="font-tt">move</span></span> method, and this is sufficient to override <span class="machine"><span class="font-tt">private</span></span>.</p>
<p>One could think that a private method should remain private in a subclass. However, since the method is visible in a subclass, it is always possible to pick its code and define a method of the same name that runs that code, so yet another (heavier) solution would be: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class point_again x =
    object
      inherit restricted_point x as super
      method move = super#move
    end;;

class point_again :
  int -&gt;
  object
    val mutable x : int
    method bump : unit
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> </div>
<p>Of course, private methods can also be virtual. Then, the keywords must appear in this order: <span class="machine"><span class="font-tt">method private virtual</span></span>.</p> <h2 class="section" id="s:class-interfaces">
<a class="section-anchor" href="#s:class-interfaces" aria-hidden="true">﻿</a><span class="number">7</span> Class interfaces</h2> <p>Class interfaces are inferred from class definitions. They may also be defined directly and used to restrict the type of a class. Like class declarations, they also define a new type abbreviation. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class type restricted_point_type =
    object
      method get_x : int
      method bump : unit
  end;;

class type restricted_point_type =
  object method bump : unit method get_x : int end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># fun (x : restricted_point_type) -&gt; x;;

- : restricted_point_type -&gt; restricted_point_type = </pre> </div> </div>
<p> In addition to program documentation, class interfaces can be used to constrain the type of a class. Both concrete instance variables and concrete private methods can be hidden by a class type constraint. Public methods and virtual members, however, cannot. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class restricted_point' x = (restricted_point x : restricted_point_type);;

class restricted_point' : int -&gt; restricted_point_type</pre> </div> </div>
<p> Or, equivalently: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class restricted_point' = (restricted_point : int -&gt; restricted_point_type);;

class restricted_point' : int -&gt; restricted_point_type</pre> </div> </div>
<p> The interface of a class can also be specified in a module signature, and used to restrict the inferred signature of a module. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># module type POINT = sig
    class restricted_point' : int -&gt;
      object
        method get_x : int
        method bump : unit
      end
  end;;

module type POINT =
  sig
    class restricted_point' :
      int -&gt; object method bump : unit method get_x : int end
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># module Point : POINT = struct
    class restricted_point' = restricted_point
  end;;

module Point : POINT</pre> </div> </div> <h2 class="section" id="s:inheritance">
<a class="section-anchor" href="#s:inheritance" aria-hidden="true">﻿</a><span class="number">8</span> Inheritance</h2> <p>We illustrate inheritance by defining a class of colored points that inherits from the class of points. This class has all instance variables and all methods of class <span class="machine"><span class="font-tt">point</span></span>, plus a new instance variable <span class="machine"><span class="font-tt">c</span></span> and a new method <span class="machine"><span class="font-tt">color</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class colored_point x (c : string) =
    object
      inherit point x
      val c = c
      method color = c
    end;;

class colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p' = new colored_point 5 "red";;

val p' : colored_point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p'#get_x, p'#color;;

- : int * string = (5, "red")</pre> </div> </div>
<p> A point and a colored point have incompatible types, since a point has no method <span class="machine"><span class="font-tt">color</span></span>. However, the function <span class="machine"><span class="font-tt">get_x</span></span> below is a generic function applying method <span class="machine"><span class="font-tt">get_x</span></span> to any object <span class="machine"><span class="font-tt">p</span></span> that has this method (and possibly some others, which are represented by an ellipsis in the type). Thus, it applies to both points and colored points. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let get_succ_x p = p#get_x + 1;;

val get_succ_x : &lt; get_x : int; .. &gt; -&gt; int = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># get_succ_x p + get_succ_x p';;

- : int = 8</pre> </div> </div>
<p> Methods need not be declared previously, as shown by the example: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let set_x p = p#set_x;;

val set_x : &lt; set_x : 'a; .. &gt; -&gt; 'a = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let incr p = set_x p (get_succ_x p);;

val incr : &lt; get_x : int; set_x : int -&gt; 'a; .. &gt; -&gt; 'a = </pre> </div> </div> <h2 class="section" id="s:multiple-inheritance">
<a class="section-anchor" href="#s:multiple-inheritance" aria-hidden="true">﻿</a><span class="number">9</span> Multiple inheritance</h2> <p>Multiple inheritance is allowed. Only the last definition of a method is kept: the redefinition in a subclass of a method that was visible in the parent class overrides the definition in the parent class. Previous definitions of a method can be reused by binding the related ancestor. Below, <span class="machine"><span class="font-tt">super</span></span> is bound to the ancestor <span class="machine"><span class="font-tt">printable_point</span></span>. The name <span class="machine"><span class="font-tt">super</span></span> is a pseudo value identifier that can only be used to invoke a super-class method, as in <span class="machine"><span class="font-tt">super#print</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class printable_colored_point y c =
    object (self)
      val c = c
      method color = c
      inherit printable_point y as super
      method! print =
        print_string "(";
        super#print;
        print_string ", ";
        print_string (self#color);
        print_string ")"
    end;;

class printable_colored_point :
  int -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p' = new printable_colored_point 17 "red";;

new point at (10, red)
val p' : printable_colored_point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p'#print;;

(10, red)- : unit = ()</pre> </div> </div>
<p> A private method that has been hidden in the parent class is no longer visible, and is thus not overridden. Since initializers are treated as private methods, all initializers along the class hierarchy are evaluated, in the order they are introduced.</p>
<p>Note that for clarity’s sake, the method <span class="machine"><span class="font-tt">print</span></span> is explicitly marked as overriding another definition by annotating the <span class="machine"><span class="font-tt">method</span></span> keyword with an exclamation mark <span class="machine"><span class="font-tt">!</span></span>. If the method <span class="machine"><span class="font-tt">print</span></span> were not overriding the <span class="machine"><span class="font-tt">print</span></span> method of <span class="machine"><span class="font-tt">printable_point</span></span>, the compiler would raise an error: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml">#   object
      method! m = ()
    end;;

Error: The method m has no previous definition</pre> </div> </div>
<p>This explicit overriding annotation also works for <span class="machine"><span class="font-tt">val</span></span> and <span class="machine"><span class="font-tt">inherit</span></span>: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class another_printable_colored_point y c c' =
    object (self)
    inherit printable_point y
    inherit! printable_colored_point y c
    val! c = c'
    end;;

class another_printable_colored_point :
  int -&gt;
  string -&gt;
  string -&gt;
  object
    val c : string
    val mutable x : int
    method color : string
    method get_x : int
    method move : int -&gt; unit
    method print : unit
  end</pre> </div> </div> <h2 class="section" id="s:parameterized-classes">
<a class="section-anchor" href="#s:parameterized-classes" aria-hidden="true">﻿</a><span class="number">10</span> Parameterized classes</h2> <p>Reference cells can be implemented as objects. The naive definition fails to typecheck: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class oref x_init =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end;;

Error: Some type variables are unbound in this type:
         class oref :
           'a -&gt;
           object
             val mutable x : 'a
             method get : 'a
             method set : 'a -&gt; unit
           end
       The method get has type 'a where 'a is unbound</pre> </div> </div>
<p> The reason is that at least one of the methods has a polymorphic type (here, the type of the value stored in the reference cell), thus either the class should be parametric, or the method type should be constrained to a monomorphic type. A monomorphic instance of the class could be defined by: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class oref (x_init:int) =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end;;

class oref :
  int -&gt;
  object val mutable x : int method get : int method set : int -&gt; unit end</pre> </div> </div>
<p> Note that since immediate objects do not define a class type, they have no such restriction. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let new_oref x_init =
    object
      val mutable x = x_init
      method get = x
      method set y = x &lt;- y
    end;;

val new_oref : 'a -&gt; &lt; get : 'a; set : 'a -&gt; unit &gt; = </pre> </div> </div>
<p> On the other hand, a class for polymorphic references must explicitly list the type parameters in its declaration. Class type parameters are listed between <span class="machine"><span class="font-tt">[</span></span> and <span class="machine"><span class="font-tt">]</span></span>. The type parameters must also be bound somewhere in the class body by a type constraint. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] oref x_init =
    object
      val mutable x = (x_init : 'a)
      method get = x
      method set y = x &lt;- y
    end;;

class ['a] oref :
  'a -&gt; object val mutable x : 'a method get : 'a method set : 'a -&gt; unit end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let r = new oref 1 in r#set 2; (r#get);;

- : int = 2</pre> </div> </div>
<p> The type parameter in the declaration may actually be constrained in the body of the class definition. In the class type, the actual value of the type parameter is displayed in the <span class="machine"><span class="font-tt">constraint</span></span> clause. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] oref_succ (x_init:'a) =
    object
      val mutable x = x_init + 1
      method get = x
      method set y = x &lt;- y
    end;;

class ['a] oref_succ :
  'a -&gt;
  object
    constraint 'a = int
    val mutable x : int
    method get : int
    method set : int -&gt; unit
  end</pre> </div> </div>
<p> Let us consider a more complex example: define a circle, whose center may be any kind of point. We put an additional type constraint in method <span class="machine"><span class="font-tt">move</span></span>, since no free variables must remain unaccounted for by the class type parameters. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] circle (c : 'a) =
    object
      val mutable center = c
      method center = center
      method set_center c = center &lt;- c
      method move = (center#move : int -&gt; unit)
    end;;

class ['a] circle :
  'a -&gt;
  object
    constraint 'a = &lt; move : int -&gt; unit; .. &gt;
    val mutable center : 'a
    method center : 'a
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end</pre> </div> </div>
<p> An alternate definition of <span class="machine"><span class="font-tt">circle</span></span>, using a <span class="machine"><span class="font-tt">constraint</span></span> clause in the class definition, is shown below. The type <span class="machine"><span class="font-tt">#point</span></span> used below in the <span class="machine"><span class="font-tt">constraint</span></span> clause is an abbreviation produced by the definition of class <span class="machine"><span class="font-tt">point</span></span>. This abbreviation unifies with the type of any object belonging to a subclass of class <span class="machine"><span class="font-tt">point</span></span>. It actually expands to <span class="machine"><span class="font-tt">&lt; get_x : int; move : int -&gt; unit; .. &gt;</span></span>. This leads to the following alternate definition of <span class="machine"><span class="font-tt">circle</span></span>, which has slightly stronger constraints on its argument, as we now expect <span class="machine"><span class="font-tt">center</span></span> to have a method <span class="machine"><span class="font-tt">get_x</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] circle (c : 'a) =
    object
      constraint 'a = #point
      val mutable center = c
      method center = center
      method set_center c = center &lt;- c
      method move = center#move
    end;;

class ['a] circle :
  'a -&gt;
  object
    constraint 'a = #point
    val mutable center : 'a
    method center : 'a
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end</pre> </div> </div>
<p> The class <span class="machine"><span class="font-tt">colored_circle</span></span> is a specialized version of class <span class="machine"><span class="font-tt">circle</span></span> that requires the type of the center to unify with <span class="machine"><span class="font-tt">#colored_point</span></span>, and adds a method <span class="machine"><span class="font-tt">color</span></span>. Note that when specializing a parameterized class, the instance of type parameter must always be explicitly given. It is again written between <span class="machine"><span class="font-tt">[</span></span> and <span class="machine"><span class="font-tt">]</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] colored_circle c =
    object
      constraint 'a = #colored_point
      inherit ['a] circle c
      method color = center#color
    end;;

class ['a] colored_circle :
  'a -&gt;
  object
    constraint 'a = #colored_point
    val mutable center : 'a
    method center : 'a
    method color : string
    method move : int -&gt; unit
    method set_center : 'a -&gt; unit
  end</pre> </div> </div> <h2 class="section" id="s:polymorphic-methods">
<a class="section-anchor" href="#s:polymorphic-methods" aria-hidden="true">﻿</a><span class="number">11</span> Polymorphic methods</h2> <p>While parameterized classes may be polymorphic in their contents, they are not enough to allow polymorphism of method use.</p>
<p>A classical example is defining an iterator. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># List.fold_left;;

- : ('acc -&gt; 'a -&gt; 'acc) -&gt; 'acc -&gt; 'a list -&gt; 'acc = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class ['a] intlist (l : int list) =
    object
      method empty = (l = [])
      method fold f (accu : 'a) = List.fold_left f accu l
    end;;

class ['a] intlist :
  int list -&gt;
  object method empty : bool method fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a end</pre> </div> </div>
<p> At first look, we seem to have a polymorphic iterator, however this does not work in practice. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let l = new intlist [1; 2; 3];;

val l : '_weak2 intlist = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># l#fold (fun x y -&gt; x+y) 0;;

- : int = 6</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># l;;

- : int intlist = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># l#fold (fun s x -&gt; s ^ Int.to_string x ^ " ") "" ;;

Error: This expression has type int but an expression was expected of type
         string</pre> </div> </div>
<p> Our iterator works, as shows its first use for summation. However, since objects themselves are not polymorphic (only their constructors are), using the <span class="machine"><span class="font-tt">fold</span></span> method fixes its type for this individual object. Our next attempt to use it as a string iterator fails.</p>
<p>The problem here is that quantification was wrongly located: it is not the class we want to be polymorphic, but the <span class="machine"><span class="font-tt">fold</span></span> method. This can be achieved by giving an explicitly polymorphic type in the method definition. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class intlist (l : int list) =
    object
      method empty = (l = [])
      method fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a =
        fun f accu -&gt; List.fold_left f accu l
    end;;

class intlist :
  int list -&gt;
  object method empty : bool method fold : ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let l = new intlist [1; 2; 3];;

val l : intlist = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># l#fold (fun x y -&gt; x+y) 0;;

- : int = 6</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># l#fold (fun s x -&gt; s ^ Int.to_string x ^ " ") "";;

- : string = "1 2 3 "</pre> </div> </div>
<p> As you can see in the class type shown by the compiler, while polymorphic method types must be fully explicit in class definitions (appearing immediately after the method name), quantified type variables can be left implicit in class descriptions. Why require types to be explicit? The problem is that <span class="machine"><span class="font-tt">(int -&gt; int -&gt; int) -&gt; int -&gt; int</span></span> would also be a valid type for <span class="machine"><span class="font-tt">fold</span></span>, and it happens to be incompatible with the polymorphic type we gave (automatic instantiation only works for toplevel types variables, not for inner quantifiers, where it becomes an undecidable problem.) So the compiler cannot choose between those two types, and must be helped.</p>
<p>However, the type can be completely omitted in the class definition if it is already known, through inheritance or type constraints on self. Here is an example of method overriding. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># class intlist_rev l =
    object
      inherit intlist l
      method! fold f accu = List.fold_left f accu (List.rev l)
    end;;</pre>
</div> </div>
<p> The following idiom separates description and definition. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># class type ['a] iterator =
    object method fold : ('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'b end;;</pre>
</div> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># class intlist' l =
    object (self : int #iterator)
      method empty = (l = [])
      method fold f accu = List.fold_left f accu l
    end;;</pre>
</div> </div>
<p> Note here the <span class="machine"><span class="font-tt">(self : int #iterator)</span></span> idiom, which ensures that this object implements the interface <span class="machine"><span class="font-tt">iterator</span></span>.</p>
<p>Polymorphic methods are called in exactly the same way as normal methods, but you should be aware of some limitations of type inference. Namely, a polymorphic method can only be called if its type is known at the call site. Otherwise, the method will be assumed to be monomorphic, and given an incompatible type. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let sum lst = lst#fold (fun x y -&gt; x+y) 0;;

val sum : &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'a; .. &gt; -&gt; 'a = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># sum l ;;

Error: This expression has type intlist
       but an expression was expected of type
         &lt; fold : (int -&gt; int -&gt; int) -&gt; int -&gt; 'b; .. &gt;
       The method fold has type 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a,
       but the expected method type was (int -&gt; int -&gt; int) -&gt; int -&gt; 'b</pre> </div> </div>
<p> The workaround is easy: you should put a type constraint on the parameter. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let sum (lst : _ #iterator) = lst#fold (fun x y -&gt; x+y) 0;;

val sum : int #iterator -&gt; int = </pre> </div> </div>
<p> Of course the constraint may also be an explicit method type. Only occurrences of quantified variables are required. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let sum lst =
    (lst : &lt; fold : 'a. ('a -&gt; _ -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt;)#fold (+) 0;;

val sum : &lt; fold : 'a. ('a -&gt; int -&gt; 'a) -&gt; 'a -&gt; 'a; .. &gt; -&gt; int = </pre> </div> </div>
<p>Another use of polymorphic methods is to allow some form of implicit subtyping in method arguments. We have already seen in section ‍<a href="#s%3Ainheritance">3.8</a> how some functions may be polymorphic in the class of their argument. This can be extended to methods. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class type point0 = object method get_x : int end;;

class type point0 = object method get_x : int end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class distance_point x =
    object
      inherit point x
      method distance : 'a. (#point0 as 'a) -&gt; int =
        fun other -&gt; abs (other#get_x - x)
    end;;

class distance_point :
  int -&gt;
  object
    val mutable x : int
    method distance : #point0 -&gt; int
    method get_offset : int
    method get_x : int
    method move : int -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new distance_point 3 in
  (p#distance (new point 8), p#distance (new colored_point 1 "blue"));;

- : int * int = (5, 2)</pre> </div> </div>
<p> Note here the special syntax <span class="machine"><span class="font-tt">(#point0 as 'a)</span></span> we have to use to quantify the extensible part of <span class="machine"><span class="font-tt">#point0</span></span>. As for the variable binder, it can be omitted in class specifications. If you want polymorphism inside object field it must be quantified independently. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class multi_poly =
    object
      method m1 : 'a. (&lt; n1 : 'b. 'b -&gt; 'b; .. &gt; as 'a) -&gt; _ =
        fun o -&gt; o#n1 true, o#n1 "hello"
      method m2 : 'a 'b. (&lt; n2 : 'b -&gt; bool; .. &gt; as 'a) -&gt; 'b -&gt; _ =
        fun o x -&gt; o#n2 x
    end;;

class multi_poly :
  object
    method m1 : &lt; n1 : 'b. 'b -&gt; 'b; .. &gt; -&gt; bool * string
    method m2 : &lt; n2 : 'b -&gt; bool; .. &gt; -&gt; 'b -&gt; bool
  end</pre> </div> </div>
<p> In method <span class="machine"><span class="font-tt">m1</span></span>, <span class="machine"><span class="font-tt">o</span></span> must be an object with at least a method <span class="machine"><span class="font-tt">n1</span></span>, itself polymorphic. In method <span class="machine"><span class="font-tt">m2</span></span>, the argument of <span class="machine"><span class="font-tt">n2</span></span> and <span class="machine"><span class="font-tt">x</span></span> must have the same type, which is quantified at the same level as <span class="machine"><span class="font-tt">'a</span></span>.</p> <h2 class="section" id="s:using-coercions">
<a class="section-anchor" href="#s:using-coercions" aria-hidden="true">﻿</a><span class="number">12</span> Using coercions</h2> <p>Subtyping is never implicit. There are, however, two ways to perform subtyping. The most general construction is fully explicit: both the domain and the codomain of the type coercion must be given.</p>
<p>We have seen that points and colored points have incompatible types. For instance, they cannot be mixed in the same list. However, a colored point can be coerced to a point, hiding its <span class="machine"><span class="font-tt">color</span></span> method: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let colored_point_to_point cp = (cp : colored_point :&gt; point);;

val colored_point_to_point : colored_point -&gt; point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new point 3 and q = new colored_point 4 "blue";;

val p : point = <obj>
val q : colored_point = </obj></pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let l = [p; (colored_point_to_point q)];;

val l : point list = [<obj>; <obj>]</obj></obj></pre> </div> </div>
<p> An object of type <span class="machine"><span class="font-tt">t</span></span> can be seen as an object of type <span class="machine"><span class="font-tt">t'</span></span> only if <span class="machine"><span class="font-tt">t</span></span> is a subtype of <span class="machine"><span class="font-tt">t'</span></span>. For instance, a point cannot be seen as a colored point. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># (p : point :&gt; colored_point);;

Error: Type point = &lt; get_offset : int; get_x : int; move : int -&gt; unit &gt;
       is not a subtype of
         colored_point =
           &lt; color : string; get_offset : int; get_x : int;
             move : int -&gt; unit &gt;
       The first object type has no method color</pre> </div> </div>
<p> Indeed, narrowing coercions without runtime checks would be unsafe. Runtime type checks might raise exceptions, and they would require the presence of type information at runtime, which is not the case in the OCaml system. For these reasons, there is no such operation available in the language.</p>
<p>Be aware that subtyping and inheritance are not related. Inheritance is a syntactic relation between classes while subtyping is a semantic relation between types. For instance, the class of colored points could have been defined directly, without inheriting from the class of points; the type of colored points would remain unchanged and thus still be a subtype of points. </p>
<p>The domain of a coercion can often be omitted. For instance, one can define: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let to_point cp = (cp :&gt; point);;

val to_point : #point -&gt; point = </pre> </div> </div>
<p> In this case, the function <span class="machine"><span class="font-tt">colored_point_to_point</span></span> is an instance of the function <span class="machine"><span class="font-tt">to_point</span></span>. This is not always true, however. The fully explicit coercion is more precise and is sometimes unavoidable. Consider, for example, the following class: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class c0 = object method m = {&lt; &gt;} method n = 0 end;;

class c0 : object ('a) method m : 'a method n : int end</pre> </div> </div>
<p> The object type <span class="machine"><span class="font-tt">c0</span></span> is an abbreviation for <span class="machine"><span class="font-tt">&lt;m : 'a; n : int&gt; as 'a</span></span>. Consider now the type declaration: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class type c1 =  object method m : c1 end;;

class type c1 = object method m : c1 end</pre> </div> </div>
<p> The object type <span class="machine"><span class="font-tt">c1</span></span> is an abbreviation for the type <span class="machine"><span class="font-tt">&lt;m : 'a&gt; as 'a</span></span>. The coercion from an object of type <span class="machine"><span class="font-tt">c0</span></span> to an object of type <span class="machine"><span class="font-tt">c1</span></span> is correct: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># fun (x:c0) -&gt; (x : c0 :&gt; c1);;

- : c0 -&gt; c1 = </pre> </div> </div>
<p> However, the domain of the coercion cannot always be omitted. In that case, the solution is to use the explicit form. Sometimes, a change in the class-type definition can also solve the problem </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class type c2 = object ('a) method m : 'a end;;

class type c2 = object ('a) method m : 'a end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># fun (x:c0) -&gt; (x :&gt; c2);;

- : c0 -&gt; c2 = </pre> </div> </div>
<p> While class types <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> are different, both object types <span class="machine"><span class="font-tt">c1</span></span> and <span class="machine"><span class="font-tt">c2</span></span> expand to the same object type (same method names and types). Yet, when the domain of a coercion is left implicit and its co-domain is an abbreviation of a known class type, then the class type, rather than the object type, is used to derive the coercion function. This allows leaving the domain implicit in most cases when coercing from a subclass to its superclass. The type of a coercion can always be seen as below: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let to_c1 x = (x :&gt; c1);;

val to_c1 : &lt; m : #c1; .. &gt; -&gt; c1 = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let to_c2 x = (x :&gt; c2);;

val to_c2 : #c2 -&gt; c2 = </pre> </div> </div>
<p> Note the difference between these two coercions: in the case of <span class="machine"><span class="font-tt">to_c2</span></span>, the type <span class="machine"><span class="font-tt">#c2 = &lt; m : 'a; .. &gt; as 'a</span></span> is polymorphically recursive (according to the explicit recursion in the class type of <span class="machine"><span class="font-tt">c2</span></span>); hence the success of applying this coercion to an object of class <span class="machine"><span class="font-tt">c0</span></span>. On the other hand, in the first case, <span class="machine"><span class="font-tt">c1</span></span> was only expanded and unrolled twice to obtain <span class="machine"><span class="font-tt">&lt; m : &lt; m : c1; .. &gt;; .. &gt;</span></span> (remember <span class="machine"><span class="font-tt">#c1 = &lt; m : c1; .. &gt;</span></span>), without introducing recursion. You may also note that the type of <span class="machine"><span class="font-tt">to_c2</span></span> is <span class="machine"><span class="font-tt">#c2 -&gt; c2</span></span> while the type of <span class="machine"><span class="font-tt">to_c1</span></span> is more general than <span class="machine"><span class="font-tt">#c1 -&gt; c1</span></span>. This is not always true, since there are class types for which some instances of <span class="machine"><span class="font-tt">#c</span></span> are not subtypes of <span class="machine"><span class="font-tt">c</span></span>, as explained in section ‍<a href="#s%3Abinary-methods">3.16</a>. Yet, for parameterless classes the coercion <span class="machine"><span class="font-tt">(_ :&gt; c)</span></span> is always more general than <span class="machine"><span class="font-tt">(_ : #c :&gt; c)</span></span>. </p>
<p>A common problem may occur when one tries to define a coercion to a class <span class="machine"><span class="font-tt">c</span></span> while defining class <span class="machine"><span class="font-tt">c</span></span>. The problem is due to the type abbreviation not being completely defined yet, and so its subtypes are not clearly known. Then, a coercion <span class="machine"><span class="font-tt">(_ :&gt; c)</span></span> or <span class="machine"><span class="font-tt">(_ : #c :&gt; c)</span></span> is taken to be the identity function, as in </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># fun x -&gt; (x :&gt; 'a);;

- : 'a -&gt; 'a = </pre> </div> </div>
<p> As a consequence, if the coercion is applied to <span class="machine"><span class="font-tt">self</span></span>, as in the following example, the type of <span class="machine"><span class="font-tt">self</span></span> is unified with the closed type <span class="machine"><span class="font-tt">c</span></span> (a closed object type is an object type without ellipsis). This would constrain the type of self be closed and is thus rejected. Indeed, the type of self cannot be closed: this would prevent any further extension of the class. Therefore, a type error is generated when the unification of this type with another type would result in a closed object type. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class c = object method m = 1 end
  and d = object (self)
    inherit c
    method n = 2
    method as_c = (self :&gt; c)
  end;;

Error: This expression cannot be coerced to type c = &lt; m : int &gt;; it has type
         &lt; as_c : c; m : int; n : int; .. &gt;
       but is here used with type c
       Self type cannot escape its class</pre> </div> </div>
<p> However, the most common instance of this problem, coercing self to its current class, is detected as a special case by the type checker, and properly typed. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class c = object (self) method m = (self :&gt; c) end;;

class c : object method m : c end</pre> </div> </div>
<p> This allows the following idiom, keeping a list of all objects belonging to a class or its subclasses: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let all_c = ref [];;

val all_c : '_weak3 list ref = {contents = []}</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class c (m : int) =
    object (self)
      method m = m
      initializer all_c := (self :&gt; c) :: !all_c
    end;;

class c : int -&gt; object method m : int end</pre> </div> </div>
<p> This idiom can in turn be used to retrieve an object whose type has been weakened: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec lookup_obj obj = function [] -&gt; raise Not_found
    | obj' :: l -&gt;
       if (obj :&gt; &lt; &gt;) = (obj' :&gt; &lt; &gt;) then obj' else lookup_obj obj l ;;

val lookup_obj : &lt; .. &gt; -&gt; (&lt; .. &gt; as 'a) list -&gt; 'a = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let lookup_c obj = lookup_obj obj !all_c;;

val lookup_c : &lt; .. &gt; -&gt; &lt; m : int &gt; = </pre> </div> </div>
<p> The type <span class="machine"><span class="font-tt">&lt; m : int &gt;</span></span> we see here is just the expansion of <span class="machine"><span class="font-tt">c</span></span>, due to the use of a reference; we have succeeded in getting back an object of type <span class="machine"><span class="font-tt">c</span></span>.</p>
<p><br> The previous coercion problem can often be avoided by first defining the abbreviation, using a class type: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class type c' = object method m : int end;;

class type c' = object method m : int end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class c : c' = object method m = 1 end
  and d = object (self)
    inherit c
    method n = 2
    method as_c = (self :&gt; c')
  end;;

class c : c'
and d : object method as_c : c' method m : int method n : int end</pre> </div> </div>
<p> It is also possible to use a virtual class. Inheriting from this class simultaneously forces all methods of <span class="machine"><span class="font-tt">c</span></span> to have the same type as the methods of <span class="machine"><span class="font-tt">c'</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class virtual c' = object method virtual m : int end;;

class virtual c' : object method virtual m : int end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class c = object (self) inherit c' method m = 1 end;;

class c : object method m : int end</pre> </div> </div>
<p> One could think of defining the type abbreviation directly: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># type c' = &lt;m : int&gt;;;</pre>
</div> </div>
<p> However, the abbreviation <span class="machine"><span class="font-tt">#c'</span></span> cannot be defined directly in a similar way. It can only be defined by a class or a class-type definition. This is because a <span class="machine"><span class="font-tt">#</span></span>-abbreviation carries an implicit anonymous variable <span class="machine"><span class="font-tt">..</span></span> that cannot be explicitly named. The closer you get to it is: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># type 'a c'_class = 'a constraint 'a = &lt; m : int; .. &gt;;;</pre>
</div> </div>
<p> with an extra type variable capturing the open object type.</p> <h2 class="section" id="s:functional-objects">
<a class="section-anchor" href="#s:functional-objects" aria-hidden="true">﻿</a><span class="number">13</span> Functional objects</h2> <p>It is possible to write a version of class <span class="machine"><span class="font-tt">point</span></span> without assignments on the instance variables. The override construct <span class="machine"><span class="font-tt">{&lt; ... &gt;}</span></span> returns a copy of “self” (that is, the current object), possibly changing the value of some instance variables. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class functional_point y =
    object
      val x = y
      method get_x = x
      method move d = {&lt; x = x + d &gt;}
      method move_to x = {&lt; x &gt;}
    end;;

class functional_point :
  int -&gt;
  object ('a)
    val x : int
    method get_x : int
    method move : int -&gt; 'a
    method move_to : int -&gt; 'a
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new functional_point 7;;

val p : functional_point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 7</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># (p#move 3)#get_x;;

- : int = 10</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># (p#move_to 15)#get_x;;

- : int = 15</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p#get_x;;

- : int = 7</pre> </div> </div>
<p> As with records, the form <span class="machine"><span class="font-tt">{&lt; x &gt;}</span></span> is an elided version of <span class="machine"><span class="font-tt">{&lt; x = x &gt;}</span></span> which avoids the repetition of the instance variable name. Note that the type abbreviation <span class="machine"><span class="font-tt">functional_point</span></span> is recursive, which can be seen in the class type of <span class="machine"><span class="font-tt">functional_point</span></span>: the type of self is <span class="machine"><span class="font-tt">'a</span></span> and <span class="machine"><span class="font-tt">'a</span></span> appears inside the type of the method <span class="machine"><span class="font-tt">move</span></span>.</p>
<p>The above definition of <span class="machine"><span class="font-tt">functional_point</span></span> is not equivalent to the following: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class bad_functional_point y =
    object
      val x = y
      method get_x = x
      method move d = new bad_functional_point (x+d)
      method move_to x = new bad_functional_point x
    end;;

class bad_functional_point :
  int -&gt;
  object
    val x : int
    method get_x : int
    method move : int -&gt; bad_functional_point
    method move_to : int -&gt; bad_functional_point
  end</pre> </div> </div>
<p> While objects of either class will behave the same, objects of their subclasses will be different. In a subclass of <span class="machine"><span class="font-tt">bad_functional_point</span></span>, the method <span class="machine"><span class="font-tt">move</span></span> will keep returning an object of the parent class. On the contrary, in a subclass of <span class="machine"><span class="font-tt">functional_point</span></span>, the method <span class="machine"><span class="font-tt">move</span></span> will return an object of the subclass.</p>
<p>Functional update is often used in conjunction with binary methods as illustrated in section ‍<a href="advexamples.html#ss%3Astring-as-class">8.2.1</a>.</p> <h2 class="section" id="s:cloning-objects">
<a class="section-anchor" href="#s:cloning-objects" aria-hidden="true">﻿</a><span class="number">14</span> Cloning objects</h2> <p>Objects can also be cloned, whether they are functional or imperative. The library function <span class="machine"><span class="font-tt">Oo.copy</span></span> makes a shallow copy of an object. That is, it returns a new object that has the same methods and instance variables as its argument. The instance variables are copied but their contents are shared. Assigning a new value to an instance variable of the copy (using a method call) will not affect instance variables of the original, and conversely. A deeper assignment (for example if the instance variable is a reference cell) will of course affect both the original and the copy.</p>
<p>The type of <span class="machine"><span class="font-tt">Oo.copy</span></span> is the following: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Oo.copy;;

- : (&lt; .. &gt; as 'a) -&gt; 'a = </pre> </div> </div>
<p> The keyword <span class="machine"><span class="font-tt">as</span></span> in that type binds the type variable <span class="machine"><span class="font-tt">'a</span></span> to the object type <span class="machine"><span class="font-tt">&lt; .. &gt;</span></span>. Therefore, <span class="machine"><span class="font-tt">Oo.copy</span></span> takes an object with any methods (represented by the ellipsis), and returns an object of the same type. The type of <span class="machine"><span class="font-tt">Oo.copy</span></span> is different from type <span class="machine"><span class="font-tt">&lt; .. &gt; -&gt; &lt; .. &gt;</span></span> as each ellipsis represents a different set of methods. Ellipsis actually behaves as a type variable. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let p = new point 5;;

val p : point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let q = Oo.copy p;;

val q : point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># q#move 7; (p#get_x, q#get_x);;

- : int * int = (5, 12)</pre> </div> </div>
<p> In fact, <span class="machine"><span class="font-tt">Oo.copy p</span></span> will behave as <span class="machine"><span class="font-tt">p#copy</span></span> assuming that a public method <span class="machine"><span class="font-tt">copy</span></span> with body <span class="machine"><span class="font-tt">{&lt; &gt;}</span></span> has been defined in the class of <span class="machine"><span class="font-tt">p</span></span>.</p>
<p>Objects can be compared using the generic comparison functions <span class="machine"><span class="font-tt">=</span></span> and <span class="machine"><span class="font-tt">&lt;&gt;</span></span>. Two objects are equal if and only if they are physically equal. In particular, an object and its copy are not equal. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let q = Oo.copy p;;

val q : point = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># p = q, p = p;;

- : bool * bool = (false, true)</pre> </div> </div>
<p> Other generic comparisons such as (<span class="machine"><span class="font-tt">&lt;</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, ...) can also be used on objects. The relation <span class="machine"><span class="font-tt">&lt;</span></span> defines an unspecified but strict ordering on objects. The ordering relationship between two objects is fixed permanently once the two objects have been created, and it is not affected by mutation of fields.</p>
<p>Cloning and override have a non empty intersection. They are interchangeable when used within an object and without overriding any field: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class copy =
    object
      method copy = {&lt; &gt;}
    end;;

class copy : object ('a) method copy : 'a end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># class copy =
    object (self)
      method copy = Oo.copy self
    end;;

class copy : object ('a) method copy : 'a end</pre> </div> </div>
<p> Only the override can be used to actually override fields, and only the <span class="machine"><span class="font-tt">Oo.copy</span></span> primitive can be used externally.</p>
<p>Cloning can also be used to provide facilities for saving and restoring the state of objects. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class backup =
    object (self : 'mytype)
      val mutable copy = None
      method save = copy &lt;- Some {&lt; copy = None &gt;}
      method restore = match copy with Some x -&gt; x | None -&gt; self
    end;;

class backup :
  object ('a)
    val mutable copy : 'a option
    method restore : 'a
    method save : unit
  end</pre> </div> </div>
<p> The above definition will only backup one level. The backup facility can be added to any class by using multiple inheritance. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;

class ['a] backup_ref :
  'a -&gt;
  object ('b)
    val mutable copy : 'b option
    val mutable x : 'a
    method get : 'a
    method restore : 'b
    method save : unit
    method set : 'a -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let rec get p n = if n = 0 then p # get else get (p # restore) (n-1);;

val get : (&lt; get : 'b; restore : 'a; .. &gt; as 'a) -&gt; int -&gt; 'b = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new backup_ref 0  in
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;

- : int list = [2; 1; 1; 1; 1]</pre> </div> </div>
<p> We can define a variant of backup that retains all copies. (We also add a method <span class="machine"><span class="font-tt">clear</span></span> to manually erase all copies.) </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class backup =
    object (self : 'mytype)
      val mutable copy = None
      method save = copy &lt;- Some {&lt; &gt;}
      method restore = match copy with Some x -&gt; x | None -&gt; self
      method clear = copy &lt;- None
    end;;

class backup :
  object ('a)
    val mutable copy : 'a option
    method clear : unit
    method restore : 'a
    method save : unit
  end</pre> </div> </div>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class ['a] backup_ref x = object inherit ['a] oref x inherit backup end;;

class ['a] backup_ref :
  'a -&gt;
  object ('b)
    val mutable copy : 'b option
    val mutable x : 'a
    method clear : unit
    method get : 'a
    method restore : 'b
    method save : unit
    method set : 'a -&gt; unit
  end</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let p = new backup_ref 0  in
  p # save; p # set 1; p # save; p # set 2;
  [get p 0; get p 1; get p 2; get p 3; get p 4];;

- : int list = [2; 1; 0; 0; 0]</pre> </div> </div> <h2 class="section" id="s:recursive-classes">
<a class="section-anchor" href="#s:recursive-classes" aria-hidden="true">﻿</a><span class="number">15</span> Recursive classes</h2> <p>Recursive classes can be used to define objects whose types are mutually recursive. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class window =
    object
      val mutable top_widget = (None : widget option)
      method top_widget = top_widget
    end
  and widget (w : window) =
    object
      val window = w
      method window = window
    end;;

class window :
  object
    val mutable top_widget : widget option
    method top_widget : widget option
  end
and widget : window -&gt; object val window : window method window : window end</pre> </div> </div>
<p> Although their types are mutually recursive, the classes <span class="machine"><span class="font-tt">widget</span></span> and <span class="machine"><span class="font-tt">window</span></span> are themselves independent.</p> <h2 class="section" id="s:binary-methods">
<a class="section-anchor" href="#s:binary-methods" aria-hidden="true">﻿</a><span class="number">16</span> Binary methods</h2> <p>A binary method is a method which takes an argument of the same type as self. The class <span class="machine"><span class="font-tt">comparable</span></span> below is a template for classes with a binary method <span class="machine"><span class="font-tt">leq</span></span> of type <span class="machine"><span class="font-tt">'a -&gt; bool</span></span> where the type variable <span class="machine"><span class="font-tt">'a</span></span> is bound to the type of self. Therefore, <span class="machine"><span class="font-tt">#comparable</span></span> expands to <span class="machine"><span class="font-tt">&lt; leq : 'a -&gt; bool; .. &gt; as 'a</span></span>. We see here that the binder <span class="machine"><span class="font-tt">as</span></span> also allows writing recursive types. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class virtual comparable =
    object (_ : 'a)
      method virtual leq : 'a -&gt; bool
    end;;

class virtual comparable : object ('a) method virtual leq : 'a -&gt; bool end</pre> </div> </div>
<p> We then define a subclass <span class="machine"><span class="font-tt">money</span></span> of <span class="machine"><span class="font-tt">comparable</span></span>. The class <span class="machine"><span class="font-tt">money</span></span> simply wraps floats as comparable objects.<sup><a id="text1" href="#note1">1</a></sup> We will extend <span class="machine"><span class="font-tt">money</span></span> below with more operations. We have to use a type constraint on the class parameter <span class="machine"><span class="font-tt">x</span></span> because the primitive <span class="machine"><span class="font-tt">&lt;=</span></span> is a polymorphic function in OCaml. The <span class="machine"><span class="font-tt">inherit</span></span> clause ensures that the type of objects of this class is an instance of <span class="machine"><span class="font-tt">#comparable</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class money (x : float) =
    object
      inherit comparable
      val repr = x
      method value = repr
      method leq p = repr &lt;= p#value
    end;;

class money :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method value : float
  end</pre> </div> </div>
<p> Note that the type <span class="machine"><span class="font-tt">money</span></span> is not a subtype of type <span class="machine"><span class="font-tt">comparable</span></span>, as the self type appears in contravariant position in the type of method <span class="machine"><span class="font-tt">leq</span></span>. Indeed, an object <span class="machine"><span class="font-tt">m</span></span> of class <span class="machine"><span class="font-tt">money</span></span> has a method <span class="machine"><span class="font-tt">leq</span></span> that expects an argument of type <span class="machine"><span class="font-tt">money</span></span> since it accesses its <span class="machine"><span class="font-tt">value</span></span> method. Considering <span class="machine"><span class="font-tt">m</span></span> of type <span class="machine"><span class="font-tt">comparable</span></span> would allow a call to method <span class="machine"><span class="font-tt">leq</span></span> on <span class="machine"><span class="font-tt">m</span></span> with an argument that does not have a method <span class="machine"><span class="font-tt">value</span></span>, which would be an error.</p>
<p>Similarly, the type <span class="machine"><span class="font-tt">money2</span></span> below is not a subtype of type <span class="machine"><span class="font-tt">money</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class money2 x =
    object
      inherit money x
      method times k = {&lt; repr = k *. repr &gt;}
    end;;

class money2 :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method times : float -&gt; 'a
    method value : float
  end</pre> </div> </div>
<p> It is however possible to define functions that manipulate objects of type either <span class="machine"><span class="font-tt">money</span></span> or <span class="machine"><span class="font-tt">money2</span></span>: the function <span class="machine"><span class="font-tt">min</span></span> will return the minimum of any two objects whose type unifies with <span class="machine"><span class="font-tt">#comparable</span></span>. The type of <span class="machine"><span class="font-tt">min</span></span> is not the same as <span class="machine"><span class="font-tt">#comparable -&gt; #comparable -&gt; #comparable</span></span>, as the abbreviation <span class="machine"><span class="font-tt">#comparable</span></span> hides a type variable (an ellipsis). Each occurrence of this abbreviation generates a new variable. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let min (x : #comparable) y =
    if x#leq y then x else y;;

val min : (#comparable as 'a) -&gt; 'a -&gt; 'a = </pre> </div> </div>
<p> This function can be applied to objects of type <span class="machine"><span class="font-tt">money</span></span> or <span class="machine"><span class="font-tt">money2</span></span>. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># (min (new money  1.3) (new money 3.1))#value;;

- : float = 1.3</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># (min (new money2 5.0) (new money2 3.14))#value;;

- : float = 3.14</pre> </div> </div>
<p>More examples of binary methods can be found in sections ‍<a href="advexamples.html#ss%3Astring-as-class">8.2.1</a> and ‍<a href="advexamples.html#ss%3Aset-as-class">8.2.3</a>.</p>
<p>Note the use of override for method <span class="machine"><span class="font-tt">times</span></span>. Writing <span class="machine"><span class="font-tt">new money2 (k *. repr)</span></span> instead of <span class="machine"><span class="font-tt">{&lt; repr = k *. repr &gt;}</span></span> would not behave well with inheritance: in a subclass <span class="machine"><span class="font-tt">money3</span></span> of <span class="machine"><span class="font-tt">money2</span></span> the <span class="machine"><span class="font-tt">times</span></span> method would return an object of class <span class="machine"><span class="font-tt">money2</span></span> but not of class <span class="machine"><span class="font-tt">money3</span></span> as would be expected.</p>
<p>The class <span class="machine"><span class="font-tt">money</span></span> could naturally carry another binary method. Here is a direct definition: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class money x =
    object (self : 'a)
      val repr = x
      method value = repr
      method print = print_float repr
      method times k = {&lt; repr = k *. x &gt;}
      method leq (p : 'a) = repr &lt;= p#value
      method plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
    end;;

class money :
  float -&gt;
  object ('a)
    val repr : float
    method leq : 'a -&gt; bool
    method plus : 'a -&gt; 'a
    method print : unit
    method times : float -&gt; 'a
    method value : float
  end</pre> </div> </div> <h2 class="section" id="s:friends">
<a class="section-anchor" href="#s:friends" aria-hidden="true">﻿</a><span class="number">17</span> Friends</h2> <p>The above class <span class="machine"><span class="font-tt">money</span></span> reveals a problem that often occurs with binary methods. In order to interact with other objects of the same class, the representation of <span class="machine"><span class="font-tt">money</span></span> objects must be revealed, using a method such as <span class="machine"><span class="font-tt">value</span></span>. If we remove all binary methods (here <span class="machine"><span class="font-tt">plus</span></span> and <span class="machine"><span class="font-tt">leq</span></span>), the representation can easily be hidden inside objects by removing the method <span class="machine"><span class="font-tt">value</span></span> as well. However, this is not possible as soon as some binary method requires access to the representation of objects of the same class (other than self). </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># class safe_money x =
    object (self : 'a)
      val repr = x
      method print = print_float repr
      method times k = {&lt; repr = k *. x &gt;}
    end;;

class safe_money :
  float -&gt;
  object ('a)
    val repr : float
    method print : unit
    method times : float -&gt; 'a
  end</pre> </div> </div>
<p> Here, the representation of the object is known only to a particular object. To make it available to other objects of the same class, we are forced to make it available to the whole world. However we can easily restrict the visibility of the representation using the module system. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># module type MONEY =
    sig
      type t
      class c : float -&gt;
        object ('a)
          val repr : t
          method value : t
          method print : unit
          method times : float -&gt; 'a
          method leq : 'a -&gt; bool
          method plus : 'a -&gt; 'a
        end
    end;;</pre>
</div> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># module Euro : MONEY =
    struct
      type t = float
      class c x =
        object (self : 'a)
          val repr = x
          method value = repr
          method print = print_float repr
          method times k = {&lt; repr = k *. x &gt;}
          method leq (p : 'a) = repr &lt;= p#value
          method plus (p : 'a) = {&lt; repr = x +. p#value &gt;}
        end
    end;;</pre>
</div> </div>
<p> Another example of friend functions may be found in section ‍<a href="advexamples.html#ss%3Aset-as-class">8.2.3</a>. These examples occur when a group of objects (here objects of the same class) and functions should see each others internal representation, while their representation should be hidden from the outside. The solution is always to define all friends in the same module, give access to the representation and use a signature constraint to make the representation abstract outside the module.</p> <dl class="thefootnotes">
<dt class="dt-thefootnotes"> <a id="note1" href="#text1">1</a>
</dt>
<dd class="dd-thefootnotes"><div class="footnotetext">floats are an approximation of decimal numbers, they are unsuitable for use in most monetary calculations as they may introduce errors.</div></dd>
</dl>  <div class="bottom-navigation">
<a class="previous" href="moduleexamples.html">« The module system</a><a class="next" href="lablexamples.html">Labeled arguments »</a>
</div> <span class="authors font-it">(Chapter written by Jérôme Vouillon, Didier Rémy and Jacques Garrigue)</span><div class="copyright">Copyright © 2024 Institut National de Recherche en Informatique et en Automatique</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/objectexamples.html" class="_attribution-link">https://ocaml.org/manual/5.2/objectexamples.html</a>
  </p>
</div>
