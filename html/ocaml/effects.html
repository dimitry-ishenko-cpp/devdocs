<h2 class="section" id="s:effect-handlers">
<a class="section-anchor" href="#s:effect-handlers" aria-hidden="true">﻿</a>12.24 Effect handlers</h2> <ul> <li>
<a href="effects.html#s%3Aeffects-basics">12.24.1 Basics</a> </li>
<li>
<a href="effects.html#s%3Aeffects-concurrency">12.24.2 Concurrency</a> </li>
<li>
<a href="effects.html#s%3Aeffects-user-threads">12.24.3 User-level threads</a> </li>
<li>
<a href="effects.html#s%3Aeffects-sequence">12.24.4 Control inversion</a> </li>
<li>
<a href="effects.html#s%3Aeffects-semantics">12.24.5 Semantics</a> </li>
<li>
<a href="effects.html#s%3Aeffects-shallow">12.24.6 Shallow handlers</a> </li>
</ul> <p>(Introduced in 5.0)</p>
<p><span class="font-it">Note: Effect handlers in OCaml 5.0 should be considered experimental. Effect handlers are exposed in the standard library as a thin wrapper around their implementations in the runtime. They are not supported as a language feature with new syntax. You can rely on them to build non-local control-flow abstractions such as user-level threading that do not expose the effect handler primitives to the user. Expect breaking changes in the future.</span></p>
<p>Effect handlers are a mechanism for modular programming with user-defined effects. Effect handlers allow the programmers to describe <span class="font-it">computations</span> that <span class="font-it">perform</span> effectful <span class="font-it">operations</span>, whose meaning is described by <span class="font-it">handlers</span> that enclose the computations. Effect handlers are a generalization of exception handlers and enable non-local control-flow mechanisms such as resumable exceptions, lightweight threads, coroutines, generators and asynchronous I/O to be composably expressed. In this tutorial, we shall see how some of these mechanisms can be built using effect handlers.</p> <h3 class="subsection" id="s:effects-basics">
<a class="section-anchor" href="#s:effects-basics" aria-hidden="true">﻿</a>12.24.1 Basics</h3> <p>To understand the basics, let us define an effect (that is, an operation) that takes an integer argument and returns an integer result. We name this effect <span class="machine"><span class="font-tt">Xchg</span></span>.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">open Effect
open Effect.Deep

type _ Effect.t += Xchg: int -&gt; int t
let comp1 () = perform (Xchg 0) + perform (Xchg 1)</pre>
</div> </div>
<p>We declare the exchange effect <span class="machine"><span class="font-tt">Xchg</span></span> by extending the pre-defined extensible variant type <span class="machine"><span class="font-tt">Effect.t</span></span> with a new constructor <span class="machine"><span class="font-tt">Xchg: int -&gt; int t</span></span>. The declaration may be intuitively read as “the <span class="machine"><span class="font-tt">Xchg</span></span> effect takes an integer parameter, and when this effect is performed, it returns an integer”. The computation <span class="machine"><span class="font-tt">comp1</span></span> performs the effect twice using the <span class="machine"><span class="font-tt">perform</span></span> primitive and returns their sum.</p>
<p>We can handle the <span class="machine"><span class="font-tt">Xchg</span></span> effect by implementing a handler that always returns the successor of the offered value:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">try_with comp1 ()
{ effc = fun (type a) (eff: a t) -&gt;
    match eff with
    | Xchg n -&gt; Some (fun (k: (a, _) continuation) -&gt;
        continue k (n+1))
    | _ -&gt; None }

- : int = 3</pre> </div> </div>
<p><span class="machine"><span class="font-tt">try_with</span></span> runs the computation <span class="machine"><span class="font-tt">comp1 ()</span></span> under an effect handler that handles the <span class="machine"><span class="font-tt">Xchg</span></span> effect. As mentioned earlier, effect handlers are a generalization of exception handlers. Similar to exception handlers, when the computation performs the <span class="machine"><span class="font-tt">Xchg</span></span> effect, the control jumps to the corresponding handler. However, unlike exception handlers, the handler is also provided with the delimited continuation <span class="machine"><span class="font-tt">k</span></span>, which represents the suspended computation between the point of <span class="machine"><span class="font-tt">perform</span></span> and this handler.</p>
<p>The handler uses the <span class="machine"><span class="font-tt">continue</span></span> primitive to resume the suspended computation with the successor of the offered value. In this example, the computation <span class="machine"><span class="font-tt">comp1</span></span> performs <span class="machine"><span class="font-tt">Xchg 0</span></span> and <span class="machine"><span class="font-tt">Xchg 1</span></span> and receives the values <span class="machine"><span class="font-tt">1</span></span> and <span class="machine"><span class="font-tt">2</span></span> from the handler respectively. Hence, the whole expression evaluates to <span class="machine"><span class="font-tt">3</span></span>.</p>
<p>It is useful to note that the we must use locally abstract type <span class="machine"><span class="font-tt">(type a)</span></span> in the effect handler. The type <span class="machine"><span class="font-tt">Effect.t</span></span> is a GADT, and the effect declarations may have different type parameters for different effects. The type parameter <span class="machine"><span class="font-tt">a</span></span> in the type <span class="machine"><span class="font-tt">a Effect.t</span></span> represents the type of the value returned when performing the effect. From the fact that <span class="machine"><span class="font-tt">eff</span></span> has type <span class="machine"><span class="font-tt">a Effect.t</span></span> and from the fact that <span class="machine"><span class="font-tt">Xchg n</span></span> has type <span class="machine"><span class="font-tt">int Effect.t</span></span>, the type-checker deduces that <span class="machine"><span class="font-tt">a</span></span> must be <span class="machine"><span class="font-tt">int</span></span>, which is why we are allowed to pass the integer value <span class="machine"><span class="font-tt">n+1</span></span> as an argument to <span class="machine"><span class="font-tt">continue k</span></span>.</p>
<p>Another point to note is that the catch-all case “<span class="machine"><span class="font-tt">| _ -&gt; None</span></span>” is necessary when handling effects. This case may be intuitively read as “forward the unhandled effects to the outer handler”.</p>
<p>In this example, we use the <em>deep</em> version of the effect handlers here as opposed to the <em>shallow</em> version. A deep handler monitors a computation until the computation terminates (either normally or via an exception), and handles all of the effects performed (in sequence) by the computation. In contrast, a shallow handler monitors a computation until either the computation terminates or the computation performs one effect, and it handles this single effect only. In situations where they are applicable, deep handlers are usually preferred. An example that utilises shallow handlers is discussed later in <a href="#s%3Aeffects-shallow">12.24.6</a>.</p> <h3 class="subsection" id="s:effects-concurrency">
<a class="section-anchor" href="#s:effects-concurrency" aria-hidden="true">﻿</a>12.24.2 Concurrency</h3> <p>The expressive power of effect handlers comes from the delimited continuation. While the previous example immediately resumed the computation, the computation may be resumed later, running some other computation in the interim. Let us extend the previous example and implement message-passing concurrency between two concurrent computations using the <span class="machine"><span class="font-tt">Xchg</span></span> effect. We call these concurrent computations <span class="font-it">tasks</span>.</p>
<p>A task either is in a suspended state or is completed. We represent the task status as follows:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">type 'a status =
  Complete of 'a
| Suspended of {msg: int; cont: (int, 'a status) continuation}</pre>
</div> </div>
<p>A task either is complete, with a result of type <span class="machine"><span class="font-tt">'a</span></span>, or is suspended with the message <span class="machine"><span class="font-tt">msg</span></span> to send and the continuation <span class="machine"><span class="font-tt">cont</span></span>. The type <span class="machine"><span class="font-tt">(int,'a status) continuation</span></span> says that the suspended computation expects an <span class="machine"><span class="font-tt">int</span></span> value to resume and returns a <span class="machine"><span class="font-tt">'a status</span></span> value when resumed.</p>
<p>Next, we define a <span class="machine"><span class="font-tt">step</span></span> function that executes one step of computation until it completes or suspends:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let step (f : unit -&gt; 'a) () : 'a status =
  match_with f ()
  { retc = (fun v -&gt; Complete v);
    exnc = raise;
    effc = fun (type a) (eff: a t) -&gt;
      match eff with
      | Xchg msg -&gt; Some (fun (cont: (a, _) continuation) -&gt;
          Suspended {msg; cont})
      | _ -&gt; None }</pre>
</div> </div>
<p>The argument to the <span class="machine"><span class="font-tt">step</span></span> function, <span class="machine"><span class="font-tt">f</span></span>, is a computation that can perform an <span class="machine"><span class="font-tt">Xchg</span></span> effect and returns a result of type <span class="machine"><span class="font-tt">'a</span></span>. The <span class="machine"><span class="font-tt">step</span></span> function itself returns a <span class="machine"><span class="font-tt">'a status</span></span> value.</p>
<p>In the <span class="machine"><span class="font-tt">step</span></span> function, we use the <span class="machine"><span class="font-tt">match_with</span></span> primitive. Like <span class="machine"><span class="font-tt">try_with</span></span>, <span class="machine"><span class="font-tt">match_with</span></span> primitive installs an effect handler. However, unlike <span class="machine"><span class="font-tt">try_with</span></span>, where only the effect case <span class="machine"><span class="font-tt">effc</span></span> is provided, <span class="machine"><span class="font-tt">match_with</span></span> expects the handlers for the value (<span class="machine"><span class="font-tt">retc</span></span>) and exceptional (<span class="machine"><span class="font-tt">exnc</span></span>) return cases. In fact, <span class="machine"><span class="font-tt">try_with</span></span> can be defined using <span class="machine"><span class="font-tt">match_with</span></span> as follows: <span class="machine"><span class="font-tt">let try_with f v {effc} = match_with f v {retc = Fun.id; exnc = raise; effc}</span></span>.</p>
<p>In the <span class="machine"><span class="font-tt">step</span></span> function,</p>
<ul class="itemize">
<li class="li-itemize">Case <span class="machine"><span class="font-tt">retc</span></span>: If the computation returns with a value <span class="machine"><span class="font-tt">v</span></span>, we return <span class="machine"><span class="font-tt">Complete v</span></span>. </li>
<li class="li-itemize">Case <span class="machine"><span class="font-tt">exnc</span></span>: If the computation raises an exception, then the handler raises the same exception. </li>
<li class="li-itemize">Case <span class="machine"><span class="font-tt">effc</span></span>: If the computation performs the effect <span class="machine"><span class="font-tt">Xchg msg</span></span> with the continuation <span class="machine"><span class="font-tt">cont</span></span>, then we return <span class="machine"><span class="font-tt">Suspended{msg;cont}</span></span>. Thus, in this case, the continuation cont is not immediately invoked by the handler; instead, it is stored in a data structure for later use. </li>
</ul>
<p>Since the <span class="machine"><span class="font-tt">step</span></span> function handles the <span class="machine"><span class="font-tt">Xchg</span></span> effect, <span class="machine"><span class="font-tt">step f</span></span> is a computation that does not perform the <span class="machine"><span class="font-tt">Xchg</span></span> effect. It may however perform other effects. Moreover, since we are using deep handlers, the continuation <span class="machine"><span class="font-tt">cont</span></span> stored in the status does not perform the <span class="machine"><span class="font-tt">Xchg</span></span> effect.</p>
<p>We can now write a simple scheduler that runs a pair of tasks to completion:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let rec run_both a b =
  match a (), b () with
  | Complete va, Complete vb -&gt; (va, vb)
  | Suspended {msg = m1; cont = k1},
    Suspended {msg = m2; cont = k2} -&gt;
      run_both (fun () -&gt; continue k1 m2)
               (fun () -&gt; continue k2 m1)
  | _ -&gt; failwith "Improper synchronization"</pre>
</div> </div>
<p>Both of the tasks may run to completion, or both may offer to exchange a message. In the latter case, each computation receives the value offered by the other computation. The situation where one computation offers an exchange while the other computation terminates is regarded as a programmer error, and causes the handler to raise an exception</p>
<p>We can now define a second computation that also exchanges two messages:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let comp2 () = perform (Xchg 21) * perform (Xchg 21)</pre>
</div> </div>
<p>Finally, we can run the two computations together:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">run_both (step comp1) (step comp2)

- : int * int = (42, 0)</pre> </div> </div>
<p>The computation <span class="machine"><span class="font-tt">comp1</span></span> offers the values <span class="machine"><span class="font-tt">0</span></span> and <span class="machine"><span class="font-tt">1</span></span> and in exchange receives the values <span class="machine"><span class="font-tt">21</span></span> and <span class="machine"><span class="font-tt">21</span></span>, which it adds, producing <span class="machine"><span class="font-tt">42</span></span>. The computation <span class="machine"><span class="font-tt">comp2</span></span> offers the values <span class="machine"><span class="font-tt">21</span></span> and <span class="machine"><span class="font-tt">21</span></span> and in exchange receives the values <span class="machine"><span class="font-tt">0</span></span> and <span class="machine"><span class="font-tt">1</span></span>, which it multiplies, producing <span class="machine"><span class="font-tt">0</span></span>. The communication between the two computations is programmed entirely inside <span class="machine"><span class="font-tt">run_both</span></span>. Indeed, the definitions of <span class="machine"><span class="font-tt">comp1</span></span> and <span class="machine"><span class="font-tt">comp2</span></span>, alone, do not assign any meaning to the <span class="machine"><span class="font-tt">Xchg</span></span> effect.</p> <h3 class="subsection" id="s:effects-user-threads">
<a class="section-anchor" href="#s:effects-user-threads" aria-hidden="true">﻿</a>12.24.3 User-level threads</h3> <p>Let us extend the previous example for an arbitrary number of tasks. Many languages such as GHC Haskell and Go provide user-level threads as a primitive feature implemented in the runtime system. With effect handlers, user-level threads and their schedulers can be implemented in OCaml itself. Typically, user-level threading systems provide a <span class="machine"><span class="font-tt">fork</span></span> primitive to spawn off a new concurrent task and a <span class="machine"><span class="font-tt">yield</span></span> primitive to yield control to some other task. Correspondingly, we shall declare two effects as follows:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">type _ Effect.t += Fork : (unit -&gt; unit) -&gt; unit t
                 | Yield : unit t</pre>
</div> </div>
<p>The <span class="machine"><span class="font-tt">Fork</span></span> effect takes a thunk (a suspended computation, represented as a function of type <span class="machine"><span class="font-tt">unit -&gt; unit</span></span>) and returns a unit to the performer. The <span class="machine"><span class="font-tt">Yield</span></span> effect is unparameterized and returns a unit when performed. Let us consider that a task performing an <span class="machine"><span class="font-tt">Xchg</span></span> effect may match with any other task also offering to exchange a value.</p>
<p>We shall also define helper functions that simply perform these effects:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let fork f = perform (Fork f)
let yield () = perform Yield
let xchg v = perform (Xchg v)</pre>
</div> </div>
<p>A top-level <span class="machine"><span class="font-tt">run</span></span> function defines the scheduler:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">(* A concurrent round-robin scheduler *)
let run (main : unit -&gt; unit) : unit =
  let exchanger = ref None in (* waiting exchanger *)
  let run_q = Queue.create () in (* scheduler queue *)
  let enqueue k v =
    let task () = continue k v in
    Queue.push task run_q
  in
  let dequeue () =
    if Queue.is_empty run_q then () (* done *)
    else begin
      let task = Queue.pop run_q in
      task ()
    end
  in
  let rec spawn (f : unit -&gt; unit) : unit =
    match_with f () {
      retc = dequeue;
      exnc = (fun e -&gt;
        print_endline (Printexc.to_string e);
        dequeue ());
      effc = fun (type a) (eff : a t) -&gt;
        match eff with
        | Yield -&gt; Some (fun (k : (a, unit) continuation) -&gt;
            enqueue k (); dequeue ())
        | Fork f -&gt; Some (fun (k : (a, unit) continuation) -&gt;
            enqueue k (); spawn f)
        | Xchg n -&gt; Some (fun (k : (int, unit) continuation) -&gt;
            begin match !exchanger with
            | Some (n', k') -&gt;
                exchanger := None; enqueue k' n; continue k n'
            | None -&gt; exchanger := Some (n, k); dequeue ()
            end)
        | _ -&gt; None
    }
  in
  spawn main</pre>
</div> </div>
<p>We use a mutable queue <span class="machine"><span class="font-tt">run_q</span></span> to hold the scheduler queue. The FIFO queue enables round-robin scheduling of tasks in the scheduler. <span class="machine"><span class="font-tt">enqueue</span></span> inserts tasks into the queue, and <span class="machine"><span class="font-tt">dequeue</span></span> extracts tasks from the queue and runs them. The reference cell <span class="machine"><span class="font-tt">exchanger</span></span> holds a (suspended) task offering to exchange a value. At any time, there is either zero or one suspended task that is offering an exchange.</p>
<p>The heavy lifting is done by the <span class="machine"><span class="font-tt">spawn</span></span> function. The <span class="machine"><span class="font-tt">spawn</span></span> function runs the given computation <span class="machine"><span class="font-tt">f</span></span> in an effect handler. If <span class="machine"><span class="font-tt">f</span></span> returns with a value (case <span class="machine"><span class="font-tt">retc</span></span>), we dequeue and run the next task from the scheduler queue. If the computation <span class="machine"><span class="font-tt">f</span></span> raises an exception (case <span class="machine"><span class="font-tt">exnc</span></span>), we print the exception and run the next task from the scheduler.</p>
<p>The computation <span class="machine"><span class="font-tt">f</span></span> may also perform effects. If <span class="machine"><span class="font-tt">f</span></span> performs the <span class="machine"><span class="font-tt">Yield</span></span> effect, the current task is suspended (inserted into the queue of ready tasks), and the next task from the scheduler queue is run. If the effect is <span class="machine"><span class="font-tt">Fork f</span></span>, then the current task is suspended, and the new task <span class="machine"><span class="font-tt">f</span></span> is executed immediately via a tail call to <span class="machine"><span class="font-tt">spawn f</span></span>. Note that this choice to run the new task first is arbitrary. We could very well have chosen instead to insert the task for <span class="machine"><span class="font-tt">f</span></span> into the ready queue and resumed <span class="machine"><span class="font-tt">k</span></span> immediately.</p>
<p>If the effect is <span class="machine"><span class="font-tt">Xchg</span></span>, then we first check whether there is a task waiting to exchange. If so, we enqueue the waiting task with the current value being offered and immediately resume the current task with the value being offered. If not, we make the current task the waiting exchanger, and run the next task from the scheduler queue.</p>
<p>Note that this scheduler code is not perfect – it can leak resources. We shall explain and fix this in the next section <a href="#s%3Aeffects-discontinue">12.24.3</a>.</p>
<p>Now we can write a concurrent program that utilises the newly defined operations:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">open Printf

let _ = run (fun _ -&gt;
  fork (fun _ -&gt;
    printf "[t1] Sending 0\n";
    let v = xchg 0 in
    printf "[t1] received %d\n" v);
  fork (fun _ -&gt;
    printf "[t2] Sending 1\n";
    let v = xchg 1 in
    printf "[t2] received %d\n" v))

[t1] Sending 0
[t2] Sending 1
[t2] received 0
[t1] received 1</pre> </div> </div>
<p>Observe that the messages from the two tasks are interleaved. Notice also that the snippet above makes no reference to the effect handlers and is in direct style (no monadic operations). This example illustrates that, with effect handlers, the user code in a concurrent program can remain in simple direct style, and the use of effect handlers can be fully contained within the concurrency library implementation.</p> <h4 class="subsubsection" id="s:effects-discontinue">
<a class="section-anchor" href="#s:effects-discontinue" aria-hidden="true">﻿</a>Resuming with an exception</h4> <p>In addition to resuming a continuation with a value, effect handlers also permit resuming by raising an effect at the point of perform. This is done with the help of the <span class="machine"><span class="font-tt">discontinue</span></span> primitive. The <span class="machine"><span class="font-tt">discontinue</span></span> primitive helps ensure that resources are always eventually deallocated, even in the presence of effects.</p>
<p>For example, consider the dequeue operation in the previous example reproduced below:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">…
let dequeue () =
  if Queue.is_empty run_q then () (* done *)
  else (Queue.pop run_q) ()</pre>
</div> </div>
<p>If the scheduler queue is empty, dequeue considers that the scheduler is done and returns to the caller. However, there may still be a task waiting to exchange a value (stored in the reference cell <span class="machine"><span class="font-tt">exchanger</span></span>), which remains blocked forever! If the blocked task holds onto resources, these resources are leaked. For example, consider the following task:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let leaky_task () =
  fork (fun _ -&gt;
    let oc = open_out "secret.txt" in
    Fun.protect ~finally:(fun _ -&gt; close_out oc) (fun _ -&gt;
      output_value oc (xchg 0)))</pre>
</div> </div>
<p>The task writes the received message to the file <span class="machine"><span class="font-tt">secret.txt</span></span>. It uses <span class="machine"><span class="font-tt">Fun.protect</span></span> to ensure that the output channel <span class="machine"><span class="font-tt">oc</span></span> is closed on both normal and exceptional return cases. Unfortunately, this is not sufficient. If the exchange effect <span class="machine"><span class="font-tt">xchg 0</span></span> cannot be matched with an exchange effect performed by some other thread, then this task remains blocked forever. Thus, the output channel <span class="machine"><span class="font-tt">oc</span></span> is never closed.</p>
<p>To avoid this problem, one must adhere to a simple discipline: <em><span class="font-bold">every continuation must be eventually either continued or discontinued</span></em>. Here, we use <span class="machine"><span class="font-tt">discontinue</span></span> to ensure that the blocked task does not remain blocked forever. By discontinuing this task, we force it to terminate (with an exception):</p>
<div class="ocaml"> <pre class=" caml-input" data-language="ocaml">exception Improper_synchronization

let dequeue () =
  if Queue.is_empty run_q then begin
    match !exchanger with
    | None -&gt; () (* done *)
    | Some (n, k) -&gt;
        exchanger := None;
        discontinue k Improper_synchronization
  end else (Queue.pop run_q) ()</pre>
</div>
<p>When the scheduler queue is empty and there is a blocked exchanger thread, the dequeue function discontinues the blocked thread with an <span class="machine"><span class="font-tt">Improper_synchronization</span></span> exception. This exception is raised at the blocked <span class="machine"><span class="font-tt">xchg</span></span> function call, which causes the <span class="machine"><span class="font-tt">finally</span></span> block to be run and closes the output channel <span class="machine"><span class="font-tt">oc</span></span>. From the point of view of the user, it seems as though the function call <span class="machine"><span class="font-tt">xchg 0</span></span> raises the exception <span class="machine"><span class="font-tt">Improper_synchronization</span></span>.</p> <h3 class="subsection" id="s:effects-sequence">
<a class="section-anchor" href="#s:effects-sequence" aria-hidden="true">﻿</a>12.24.4 Control inversion</h3> <p>When it comes to performing traversals on a data structure, there are two fundamental ways depending on whether the producer or the consumer has the control over the traversal. For example, in <span class="machine"><span class="font-tt">List.iter f l</span></span>, the producer <span class="machine"><span class="font-tt">List.iter</span></span> has the control and pushes the element to the consumer <span class="machine"><span class="font-tt">f</span></span> who processes them. On the other hand, the <a href="libref/seq.html"><span class="font-tt">Seq</span></a> module provides a mechanism similar to delayed lists where the consumer controls the traversal. For example, <span class="machine"><span class="font-tt">Seq.forever Random.bool</span></span> returns an infinite sequence of random bits where every bit is produced (on demand) when queried by the consumer.</p>
<p>Naturally, producers such as <span class="machine"><span class="font-tt">List.iter</span></span> are easier to write in the former style. The latter style is ergonomically better for the consumer since it is preferable and more natural to be in control. To have the best of both worlds, we would like to write a producer in the former style and automatically convert it to the latter style. The conversion can be written <em>once and for all</em> as a library function, thanks to effect handlers. Let us name this function <span class="machine"><span class="font-tt">invert</span></span>. We will first look at how to use the <span class="machine"><span class="font-tt">invert</span></span> function before looking at its implementation details. The type of this function is given below:</p>
<div class="caml-example signature"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">val invert : iter:(('a -&gt; unit) -&gt; unit) -&gt; 'a Seq.t</pre>
</div> </div>
<p>The <span class="machine"><span class="font-tt">invert</span></span> function takes an <span class="machine"><span class="font-tt">iter</span></span> function (a producer that pushes elements to the consumer) and returns a sequence (where the consumer has the control). For example,</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">let lst_iter = Fun.flip List.iter [1;2;3]

val lst_iter : (int -&gt; unit) -&gt; unit = </pre> </div> </div>
<p>is an <span class="machine"><span class="font-tt">iter</span></span> function with type <span class="machine"><span class="font-tt">(int -&gt; unit) -&gt; unit</span></span>. The expression <span class="machine"><span class="font-tt">lst_iter f</span></span> pushes the elements 1, 2 and 3 to the consumer <span class="machine"><span class="font-tt">f</span></span>. For example,</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">lst_iter (fun i -&gt; Printf.printf "%d\n" i)

1
2
3
- : unit = ()</pre> </div> </div>
<p>The expression <span class="machine"><span class="font-tt">invert lst_iter</span></span> returns a sequence that allows the consumer to traverse the list on demand. For example,</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">let s = invert ~iter:lst_iter
let next = Seq.to_dispenser s;;

val s : int Seq.t = <fun>
val next : unit -&gt; int option = </fun></pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : int option = Some 1</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : int option = Some 2</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : int option = Some 3</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : int option = None</pre> </div> </div>
<p>We can use the same <span class="machine"><span class="font-tt">invert</span></span> function on any <span class="machine"><span class="font-tt">iter</span></span> function. For example,</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">let s = invert ~iter:(Fun.flip String.iter "OCaml")
let next = Seq.to_dispenser s;;

val s : char Seq.t = <fun>
val next : unit -&gt; char option = </fun></pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = Some 'O'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = Some 'C'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = Some 'a'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = Some 'm'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = Some 'l'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">next();;

- : char option = None</pre> </div> </div> <h4 class="subsubsection" id="s:effects-sequence-implementation">
<a class="section-anchor" href="#s:effects-sequence-implementation" aria-hidden="true">﻿</a>Implementing control inversion</h4> <p>The implementation of the <span class="machine"><span class="font-tt">invert</span></span> function is given below:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">let invert (type a) ~(iter : (a -&gt; unit) -&gt; unit) : a Seq.t =
  let module M = struct
    type _ Effect.t += Yield : a -&gt; unit t
  end in
  let yield v = perform (M.Yield v) in
  fun () -&gt; match_with iter yield
  { retc = (fun _ -&gt; Seq.Nil);
    exnc = raise;
    effc = fun (type b) (eff : b Effect.t) -&gt;
      match eff with
      | M.Yield v -&gt; Some (fun (k: (b,_) continuation) -&gt;
          Seq.Cons (v, continue k))
      | _ -&gt; None }</pre>
</div> </div>
<p>The <span class="machine"><span class="font-tt">invert</span></span> function declares an effect <span class="machine"><span class="font-tt">Yield</span></span> that takes the element to be yielded as a parameter. The <span class="machine"><span class="font-tt">yield</span></span> function performs the <span class="machine"><span class="font-tt">Yield</span></span> effect. The lambda abstraction <span class="machine"><span class="font-tt">fun () -&gt; ...</span></span> delays all action until the first element of the sequence is demanded. Once this happens, the computation <span class="machine"><span class="font-tt">iter yield</span></span> is executed under an effect handler. Every time the <span class="machine"><span class="font-tt">iter</span></span> function pushes an element to the <span class="machine"><span class="font-tt">yield</span></span> function, the computation is interrupted by the <span class="machine"><span class="font-tt">Yield</span></span> effect. The <span class="machine"><span class="font-tt">Yield</span></span> effect is handled by returning the value <span class="machine"><span class="font-tt">Seq.Cons(v,continue k)</span></span> to the consumer. The consumer gets the element <span class="machine"><span class="font-tt">v</span></span> as well as the suspended computation, which in the consumer’s eyes is just the tail of sequence.</p>
<p>When the consumer demands the next element from the sequence (by applying it to <span class="machine"><span class="font-tt">()</span></span>), the continuation <span class="machine"><span class="font-tt">k</span></span> is resumed. This allows the computation <span class="machine"><span class="font-tt">iter yield</span></span> to make progress, until it either yields another element or terminates normally. In the latter case, the value <span class="machine"><span class="font-tt">Seq.Nil</span></span> is returned, indicating to the consumer that the iteration is over.</p>
<p>It is important to note that the sequence returned by the <span class="machine"><span class="font-tt">invert</span></span> function is <em>ephemeral</em> (as defined by the <a href="libref/seq.html"><span class="font-tt">Seq</span></a> module) i.e., the sequence must be used at most once. Additionally, the sequence must be fully consumed (i.e., used at least once) so as to ensure that the captured continuation is used linearly.</p> <h3 class="subsection" id="s:effects-semantics">
<a class="section-anchor" href="#s:effects-semantics" aria-hidden="true">﻿</a>12.24.5 Semantics</h3> <p>In this section, we shall see the semantics of effect handlers with the help of examples.</p> <h4 class="subsubsection" id="s:effects-nesting">
<a class="section-anchor" href="#s:effects-nesting" aria-hidden="true">﻿</a>Nesting handlers</h4> <p>Like exception handlers, effect handlers can be nested.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">type _ Effect.t += E : int t
                 | F : string t

let foo () = perform F

let bar () =
  try_with foo ()
  { effc = fun (type a) (eff: a t) -&gt;
      match eff with
      | E -&gt; Some (fun (k: (a,_) continuation) -&gt;
          failwith "impossible")
      | _ -&gt; None }

let baz () =
  try_with bar ()
  { effc = fun (type a) (eff: a t) -&gt;
      match eff with
      | F -&gt; Some (fun (k: (a,_) continuation) -&gt;
          continue k "Hello, world!")
      | _ -&gt; None }</pre>
</div> </div>
<p>In this example, the computation <span class="machine"><span class="font-tt">foo</span></span> performs <span class="machine"><span class="font-tt">F</span></span>, the inner handler handles only <span class="machine"><span class="font-tt">E</span></span> and the outer handler handles <span class="machine"><span class="font-tt">F</span></span>. The call to <span class="machine"><span class="font-tt">baz</span></span> returns <span class="machine"><span class="font-tt">Hello, world!</span></span>.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">baz ()

- : string = "Hello, world!"</pre> </div> </div> <h4 class="subsubsection" id="s:effects-fibers">
<a class="section-anchor" href="#s:effects-fibers" aria-hidden="true">﻿</a>Fibers</h4> <p>It is useful to know a little bit about the implementation of effect handlers to appreciate the design choices and their performance characteristics. Effect handlers are implemented with the help of runtime-managed, dynamically growing segments of stack called <span class="font-it">fibers</span>. The program stack in OCaml is a linked list of such fibers.</p>
<p>A new fiber is allocated for evaluating the computation enclosed by an effect handler. The fiber is freed when the computation returns to the caller either normally by returning a value or by raising an exception.</p>
<p>At the point of <span class="machine"><span class="font-tt">perform</span></span> in <span class="machine"><span class="font-tt">foo</span></span> in the previous example, the program stack looks like this:</p>
<div class="ocaml"> <pre class=" caml-input" data-language="ocaml">+-----+   +-----+   +-----+
|     |   |     |   |     |
| baz |&lt;--| bar |&lt;--| foo |
|     |   |     |   |     |
|     |   |     |   |     |
+-----+   +-----+   +-----+ &lt;- stack_pointer</pre>
</div>
<p>The two links correspond to the two effect handlers in the program. When the effect <span class="machine"><span class="font-tt">F</span></span> is handled in <span class="machine"><span class="font-tt">baz</span></span>, the program state looks as follows:</p>
<div class="ocaml"> <pre class=" caml-input" data-language="ocaml">+-----+                   +-----+   +-----+
|     |                   |     |   |     |   +-+
| baz |                   | bar |&lt;--| foo |&lt;--|k|
|     |                   |     |   |     |   +-+
+-----+ &lt;- stack_pointer  +-----+   +-----+</pre>
</div>
<p>The delimited continuation <span class="machine"><span class="font-tt">k</span></span> is an object on the heap that refers to the segment of the stack that corresponds to the suspended computation. Capturing a continuation does not involve copying stack frames. When the continuation is resumed, the stack is restored to the previous state by linking together the segment pointed to by <span class="machine"><span class="font-tt">k</span></span> to the current stack. Since neither continuation capture nor resumption requires copying stack frames, suspending the execution using <span class="machine"><span class="font-tt">perform</span></span> and resuming it using either <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> are fast.</p> <h4 class="subsubsection" id="s:effects-unhandled">
<a class="section-anchor" href="#s:effects-unhandled" aria-hidden="true">﻿</a>Unhandled effects</h4> <p>Unlike languages such as Eff and Koka, effect handlers in OCaml do not provide <span class="font-it">effect safety</span>; the compiler does not statically ensure that all the effects performed by the program are handled. If effects do not have a matching handler, then an <span class="machine"><span class="font-tt">Effect.Unhandled</span></span> exception is raised at the point of the corresponding <span class="machine"><span class="font-tt">perform</span></span>. For example, in the previous example, <span class="machine"><span class="font-tt">bar</span></span> does not handle the effect <span class="machine"><span class="font-tt">F</span></span>. Hence, we will get an <span class="machine"><span class="font-tt">Effect.Unhandled F</span></span> exception when we run <span class="machine"><span class="font-tt">bar</span></span>.</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">try bar () with Effect.Unhandled F -&gt; "Saw Effect.Unhandled exception"

- : string = "Saw Effect.Unhandled exception"</pre> </div> </div> <h4 class="subsubsection" id="s:effects-linearity">
<a class="section-anchor" href="#s:effects-linearity" aria-hidden="true">﻿</a>Linear continuations</h4> <p>As discussed earlier <a href="#s%3Aeffects-discontinue">12.24.3</a>, the delimited continuations in OCaml must be used linearly – <em><span class="font-bold">every captured continuation must be resumed either with a <span class="machine"><span class="font-tt">continue</span></span> or <span class="machine"><span class="font-tt">discontinue</span></span> exactly once</span></em>. Attempting to use a continuation more than once raises a <span class="machine"><span class="font-tt">Continuation_already_resumed</span></span> exception. For example:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">try_with perform (Xchg 0)
{ effc = fun (type a) (eff : a t) -&gt;
    match eff with
    | Xchg n -&gt; Some (fun (k: (a, _) continuation) -&gt;
        continue k 21 + continue k 21)
    | _ -&gt; None }

Exception: Stdlib.Effect.Continuation_already_resumed.</pre> </div> </div>
<p>The primary motivation for adding effect handlers to OCaml is to enable concurrent programming. One-shot continuations are sufficient for almost all concurrent programming needs. They are also much cheaper to implement compared to multi-shot continuations since they do not require stack frames to be copied. Moreover, OCaml programs may also manipulate linear resources such as sockets and file descriptors. The linearity discipline is easily broken if the continuations are allowed to resume more than once. It would be quite hard to debug such linearity violations on resources due to the lack of static checks for linearity and the non-local nature of control flow. Hence, OCaml does not support multi-shot continuations.</p>
<p>While the “at most once resumption” property of continuations is ensured with a dynamic check, there is no check to ensure that the continuations are resumed “at least once”. It is left to the user to ensure that the captured continuations are resumed at least once. Not resuming continuations will leak the memory allocated for the fibers as well as any resources that the suspended computation may hold.</p>
<p>One may install a finaliser on the captured continuation to ensure that the resources are freed:</p>
<div class="ocaml"> <pre class=" caml-input" data-language="ocaml">exception Unwind
Gc.finalise (fun k -&gt;
  try ignore (discontinue k Unwind) with _ -&gt; ()) k</pre>
</div>
<p>In this case, if <span class="machine"><span class="font-tt">k</span></span> becomes unreachable, then the finaliser ensures that the continuation stack is unwound by discontinuing with an <span class="machine"><span class="font-tt">Unwind</span></span> exception, allowing the computation to free up resources. However, the runtime cost of finalisers is much more than the cost of capturing a continuation. Hence, it is recommended that the user take care of resuming the continuation exactly once rather than relying on the finaliser.</p> <h3 class="subsection" id="s:effects-shallow">
<a class="section-anchor" href="#s:effects-shallow" aria-hidden="true">﻿</a>12.24.6 Shallow handlers</h3> <p>The examples that we have seen so far have used <span class="font-it">deep</span> handlers. A deep handler handles all the effects performed (in sequence) by the computation. Whenever a continuation is captured in a deep handler, the captured continuation also includes the handler. This means that, when the continuation is resumed, the effect handler is automatically re-installed, and will handle the effect(s) that the computation may perform in the future.</p>
<p>OCaml also provides <span class="font-it">shallow</span> handlers. Compared to deep handlers, a shallow handler handles only the first effect performed by the computation. The continuation captured in a shallow handler does not include the handler. This means that, when the continuation is resumed, the handler is no longer present. For this reason, when the continuation is resumed, the user is expected to provide a new effect handler (possibly a different one) to handle the next effect that the computation may perform.</p>
<p>Shallow handlers make it easier to express certain kinds of programs. Let us implement a shallow handler that enforces a particular sequence of effects (a protocol) on a computation. For this example, let us consider that the computation may perform the following effects:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">type _ Effect.t += Send : int -&gt; unit Effect.t
                 | Recv : int Effect.t</pre>
</div> </div>
<p>Let us assume that we want to enforce a protocol that only permits an alternating sequence of <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span> effects that conform to the regular expression <span class="machine"><span class="font-tt">(Send;Recv)*;Send?</span></span>. Hence, the sequence of effects <span class="machine"><span class="font-tt">[]</span></span> (the empty sequence), <span class="machine"><span class="font-tt">[Send]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv;Send]</span></span>, etc., are allowed, but not <span class="machine"><span class="font-tt">[Recv]</span></span>, <span class="machine"><span class="font-tt">[Send;Send]</span></span>, <span class="machine"><span class="font-tt">[Send;Recv;Recv]</span></span>, etc. The key observation here is that the set of effects handled evolves over time. We can enforce this protocol quite naturally using shallow handlers as shown below:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml">open Effect.Shallow

let run (comp: unit -&gt; unit) : unit =
  let rec loop_send : type a. (a,unit) continuation -&gt; a -&gt; unit = fun k v -&gt;
    continue_with k v
      { retc = Fun.id;
        exnc = raise;
        effc = fun (type b) (eff : b Effect.t) -&gt;
          match eff with
          | Send n -&gt; Some (fun (k: (b,_) continuation) -&gt;
              loop_recv n k ())
          | Recv -&gt; failwith "protocol violation"
          | _ -&gt; None }
  and loop_recv : type a. int -&gt; (a,unit) continuation -&gt; a -&gt; unit = fun n k v -&gt;
    continue_with k v
      { retc = Fun.id;
        exnc = raise;
        effc = fun (type b) (eff : b Effect.t) -&gt;
          match eff with
          | Recv -&gt; Some (fun (k: (b,_) continuation) -&gt;
              loop_send k n)
          | Send v -&gt; failwith "protocol violation"
          | _ -&gt; None }
  in
  loop_send (fiber comp) ()</pre>
</div> </div>
<p>The <span class="machine"><span class="font-tt">run</span></span> function executes the computation <span class="machine"><span class="font-tt">comp</span></span> ensuring that it can only perform an alternating sequence of <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span> effects. The shallow handler uses a different set of primitives compared to the deep handler. The primitive <span class="machine"><span class="font-tt">fiber</span></span> (on the last line) takes an <span class="machine"><span class="font-tt">'a -&gt; 'b</span></span> function and returns a <span class="machine"><span class="font-tt">('a,'b) Effects.Shallow.continuation</span></span>. The expression <span class="machine"><span class="font-tt">continue_with k v h</span></span> resumes the continuation <span class="machine"><span class="font-tt">k</span></span> with value <span class="machine"><span class="font-tt">v</span></span> under the handler <span class="machine"><span class="font-tt">h</span></span>.</p>
<p>The mutually recursive functions <span class="machine"><span class="font-tt">loop_send</span></span> and <span class="machine"><span class="font-tt">loop_recv</span></span> resume the given continuation <span class="machine"><span class="font-tt">k</span></span> with value <span class="machine"><span class="font-tt">v</span></span> under different handlers. The <span class="machine"><span class="font-tt">loop_send</span></span> function handles the <span class="machine"><span class="font-tt">Send</span></span> effect and tail calls the <span class="machine"><span class="font-tt">loop_recv</span></span> function. If the computation performs the <span class="machine"><span class="font-tt">Recv</span></span> effect, then <span class="machine"><span class="font-tt">loop_send</span></span> aborts the computation by raising an exception. Similarly, the <span class="machine"><span class="font-tt">loop_recv</span></span> function handles the <span class="machine"><span class="font-tt">Recv</span></span> effect and tail calls the <span class="machine"><span class="font-tt">loop_send</span></span> function. If the computation performs the <span class="machine"><span class="font-tt">Send</span></span> effect, then <span class="machine"><span class="font-tt">loop_recv</span></span> aborts the computation. Given that the continuation captured in the shallow handler do not include the handler, there is only ever one handler installed in the dynamic scope of the computation <span class="machine"><span class="font-tt">comp</span></span>.</p>
<p>The computation is initially executed by the <span class="machine"><span class="font-tt">loop_send</span></span> function (see last line in the code above) which ensures that the first effect that the computation is allowed to perform is the <span class="machine"><span class="font-tt">Send</span></span> effect. Note that the computation is free to perform effects other than <span class="machine"><span class="font-tt">Send</span></span> and <span class="machine"><span class="font-tt">Recv</span></span>, which may be handled by an outer handler.</p>
<p>We can see that the <span class="machine"><span class="font-tt">run</span></span> function will permit a computation that follows the protocol:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">run (fun () -&gt;
  printf "Send 42\n";
  perform (Send 42);
  printf "Recv: %d\n" (perform Recv);
  printf "Send 43\n";
  perform (Send 43);
  printf "Recv: %d\n" (perform Recv))

Send 42
Recv: 42
Send 43
Recv: 43
- : unit = ()</pre> </div> </div>
<p>and aborts those that do not:</p>
<div class="caml-example verbatim"> <div class="ocaml"> <pre data-language="ocaml">run (fun () -&gt;
  Printf.printf "Send 0\n";
  perform (Send 0);
  Printf.printf "Send 1\n";
  perform (Send 1) (* protocol violation *))

Send 0
Send 1
Exception: Failure "protocol violation".</pre> </div> </div>
<p>We may implement the same example using deep handlers using reference cells (easy, but unsatisfying) or without them (harder). We leave this as an exercise to the reader. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2022 INRIA.<br>
    <a href="https://v2.ocaml.org/releases/5.0/htmlman/effects.html" class="_attribution-link">https://v2.ocaml.org/releases/5.0/htmlman/effects.html</a>
  </p>
</div>
