<div class="content manual">
<nav id="part-title"><span>☰</span>The OCaml tools</nav><ul id="part-menu">
<li><a href="comp.html">Batch compilation (ocamlc)</a></li>
<li><a href="toplevel.html">The toplevel system or REPL (ocaml)</a></li>
<li><a href="runtime.html">The runtime system (ocamlrun)</a></li>
<li><a href="native.html">Native-code compilation (ocamlopt)</a></li>
<li><a href="lexyacc.html">Lexer and parser generators (ocamllex, ocamlyacc)</a></li>
<li><a href="depend.html">Dependency generator (ocamldep)</a></li>
<li><a href="ocamldoc.html">The documentation generator (ocamldoc)</a></li>
<li><a href="debugger.html">The debugger (ocamldebug)</a></li>
<li><a href="profil.html">Profiling (ocamlprof)</a></li>
<li><a href="intfc.html">Interfacing C with OCaml</a></li>
<li><a href="flambda.html">Optimisation with Flambda</a></li>
<li class="active"><a href="afl-fuzz.html">Fuzzing with afl-fuzz</a></li>
<li><a href="runtime-tracing.html">Runtime tracing with runtime events</a></li>
<li><a href="tail_mod_cons.html">The “Tail Modulo Constructor” program transformation</a></li>
<li><a href="tsan.html">Runtime detection of data races with ThreadSanitizer</a></li>
</ul> <h1 class="chapter" id="sec601">Chapter 24 Fuzzing with afl-fuzz</h1>  <h2 class="section" id="s:afl-overview">
<span class="number">1</span> Overview</h2> <p>American fuzzy lop (“afl-fuzz”) is a <em>fuzzer</em>, a tool for testing software by providing randomly-generated inputs, searching for those inputs which cause the program to crash.</p>
<p>Unlike most fuzzers, afl-fuzz observes the internal behaviour of the program being tested, and adjusts the test cases it generates to trigger unexplored execution paths. As a result, test cases generated by afl-fuzz cover more of the possible behaviours of the tested program than other fuzzers.</p>
<p>This requires that programs to be tested are instrumented to communicate with afl-fuzz. The native-code compiler “ocamlopt” can generate such instrumentation, allowing afl-fuzz to be used against programs written in OCaml.</p>
<p>For more information on afl-fuzz, see the website at <a href="http://lcamtuf.coredump.cx/afl/">http://lcamtuf.coredump.cx/afl/</a>. </p> <h2 class="section" id="s:afl-generate">
<a class="section-anchor" href="#s:afl-generate" aria-hidden="true">﻿</a><span class="number">2</span> Generating instrumentation</h2> <p>The instrumentation that afl-fuzz requires is not generated by default, and must be explicitly enabled, by passing the <span class="font-tt">-afl-instrument</span> option to <span class="font-tt">ocamlopt</span>.</p>
<p>To fuzz a large system without modifying build tools, OCaml’s <span class="font-tt">configure</span> script also accepts the <span class="font-tt">afl-instrument</span> option. If OCaml is configured with <span class="font-tt">afl-instrument</span>, then all programs compiled by <span class="font-tt">ocamlopt</span> will be instrumented.</p> <h3 class="subsection" id="ss:afl-advanced">
<a class="section-anchor" href="#ss:afl-advanced" aria-hidden="true">﻿</a><span class="number">2.1</span> Advanced options</h3> <p>In rare cases, it is useful to control the amount of instrumentation generated. By passing the <span class="font-tt">-afl-inst-ratio N</span> argument to <span class="font-tt">ocamlopt</span> with <span class="font-tt">N</span> less than 100, instrumentation can be generated for only N% of branches. (See the afl-fuzz documentation on the parameter <span class="font-tt">AFL_INST_RATIO</span> for the precise effect of this).</p> <h2 class="section" id="s:afl-example">
<a class="section-anchor" href="#s:afl-example" aria-hidden="true">﻿</a><span class="number">3</span> Example</h2> <p>As an example, we fuzz-test the following program, <span class="font-tt">readline.ml</span>:</p>
<pre data-language="ocaml">let _ =
  let s = read_line () in
  match Array.to_list (Array.init (String.length s) (String.get s)) with
    ['s'; 'e'; 'c'; 'r'; 'e'; 't'; ' '; 'c'; 'o'; 'd'; 'e'] -&gt; failwith "uh oh"
  | _ -&gt; ()
</pre>
<p> There is a single input (the string “secret code”) which causes this program to crash, but finding it by blind random search is infeasible.</p>
<p>Instead, we compile with afl-fuzz instrumentation enabled: </p>
<pre data-language="ocaml">ocamlopt -afl-instrument readline.ml -o readline
</pre>
<p>Next, we run the program under afl-fuzz: </p>
<pre data-language="ocaml">mkdir input
echo asdf &gt; input/testcase
mkdir output
afl-fuzz -m none -i input -o output ./readline
</pre>
<p>By inspecting instrumentation output, the fuzzer finds the crashing input quickly.</p>
<p>Note: To fuzz-test an OCaml program with afl-fuzz, passing the option <span class="font-tt">-m none</span> is required to disable afl-fuzz’s default 50MB virtual memory limit. </p>  <div class="bottom-navigation">
<a class="previous" href="flambda.html">« Optimisation with Flambda</a><a class="next" href="runtime-tracing.html">Runtime tracing with runtime events »</a>
</div> <div class="copyright">Copyright © 2024 Institut National de Recherche en Informatique et en Automatique</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/afl-fuzz.html" class="_attribution-link">https://ocaml.org/manual/5.2/afl-fuzz.html</a>
  </p>
</div>
