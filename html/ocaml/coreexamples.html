<div class="content manual">
<nav id="part-title"><span>☰</span>An introduction to OCaml</nav><ul id="part-menu">
<li class="active"><a href="coreexamples.html">The core language</a></li>
<li><a href="moduleexamples.html">The module system</a></li>
<li><a href="objectexamples.html">Objects in OCaml</a></li>
<li><a href="lablexamples.html">Labeled arguments</a></li>
<li><a href="polyvariant.html">Polymorphic variants</a></li>
<li><a href="polymorphism.html">Polymorphism and its limitations</a></li>
<li><a href="gadts-tutorial.html">Generalized algebraic datatypes</a></li>
<li><a href="advexamples.html">Advanced examples with classes and modules</a></li>
<li><a href="parallelism.html">Parallel programming</a></li>
<li><a href="memorymodel.html">Memory model: The hard bits</a></li>
</ul> <h1 class="chapter" id="sec7">Chapter 1 The core language</h1>  
<p>This part of the manual is a tutorial introduction to the OCaml language. A good familiarity with programming in a conventional languages (say, C or Java) is assumed, but no prior exposure to functional languages is required. The present chapter introduces the core language. Chapter ‍<a href="moduleexamples.html#c%3Amoduleexamples">2</a> deals with the module system, chapter ‍<a href="objectexamples.html#c%3Aobjectexamples">3</a> with the object-oriented features, chapter ‍<a href="lablexamples.html#c%3Alabl-examples">4</a> with labeled arguments, chapter ‍<a href="polyvariant.html#c%3Apoly-variant">5</a> with polymorphic variants, chapter ‍<a href="polymorphism.html#c%3Apolymorphism">6</a> with the limitations of polymorphism, and chapter ‍<a href="advexamples.html#c%3Aadvexamples">8</a> gives some advanced examples.</p> <h2 class="section" id="s:basics">
<span class="number">1</span> Basics</h2> <p>For this overview of OCaml, we use the interactive system, which is started by running <span class="machine"><span class="font-tt">ocaml</span></span> from the Unix shell or Windows command prompt. This tutorial is presented as the transcript of a session with the interactive system: lines starting with <span class="machine"><span class="font-tt">#</span></span> represent user input; the system responses are printed below, without a leading <span class="machine"><span class="font-tt">#</span></span>.</p>
<p>Under the interactive system, the user types OCaml phrases terminated by <span class="machine"><span class="font-tt">;;</span></span> in response to the <span class="machine"><span class="font-tt">#</span></span> prompt, and the system compiles them on the fly, executes them, and prints the outcome of evaluation. Phrases are either simple expressions, or <span class="machine"><span class="font-tt">let</span></span> definitions of identifiers (either values or functions). </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># 1 + 2 * 3;;

- : int = 7</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let pi = 4.0 *. atan 1.0;;

val pi : float = 3.14159265358979312</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let square x = x *. x;;

val square : float -&gt; float = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># square (sin pi) +. square (cos pi);;

- : float = 1.</pre> </div> </div>
<p> The OCaml system computes both the value and the type for each phrase. Even function parameters need no explicit type declaration: the system infers their types from their usage in the function. Notice also that integers and floating-point numbers are distinct types, with distinct operators: <span class="machine"><span class="font-tt">+</span></span> and <span class="machine"><span class="font-tt">*</span></span> operate on integers, but <span class="machine"><span class="font-tt">+.</span></span> and <span class="machine"><span class="font-tt">*.</span></span> operate on floats. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># 1.0 * 2;;

Error: This expression has type float but an expression was expected of type
         int</pre> </div> </div>
<p>Recursive functions are defined with the <span class="machine"><span class="font-tt">let rec</span></span> binding: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec fib n =
    if n &lt; 2 then n else fib (n - 1) + fib (n - 2);;

val fib : int -&gt; int = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># fib 10;;

- : int = 55</pre> </div> </div> <h2 class="section" id="s:datatypes">
<a class="section-anchor" href="#s:datatypes" aria-hidden="true">﻿</a><span class="number">2</span> Data types</h2> <p>In addition to integers and floating-point numbers, OCaml offers the usual basic data types: </p>
<ul class="itemize">
<li class="li-itemize">booleans <div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># (1 &lt; 2) = false;;

- : bool = false</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let one = if true then 1 else 2;;

val one : int = 1</pre> </div> </div> </li>
<li class="li-itemize">characters <div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml">#  'a';;

- : char = 'a'</pre> </div> <div class="ocaml"> <pre data-language="ocaml">#  int_of_char '\n';;

- : int = 10</pre> </div> </div> </li>
<li class="li-itemize">immutable character strings <div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># "Hello" ^ " " ^ "world";;

- : string = "Hello world"</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># {|This is a quoted string, here, neither \ nor " are special characters|};;

- : string =
"This is a quoted string, here, neither \\ nor \" are special characters"</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># {|"\\"|}="\"\\\\\"";;

- : bool = true</pre> </div> <div class="ocaml"> <pre data-language="ocaml">#   {delimiter|the end of this|}quoted string is here|delimiter}
  =           "the end of this|}quoted string is here";;

- : bool = true</pre> </div> </div> </li>
</ul>
<p>Predefined data structures include tuples, arrays, and lists. There are also general mechanisms for defining your own data structures, such as records and variants, which will be covered in more detail later; for now, we concentrate on lists. Lists are either given in extension as a bracketed list of semicolon-separated elements, or built from the empty list <span class="machine"><span class="font-tt">[]</span></span> (pronounce “nil”) by adding elements in front using the <span class="machine"><span class="font-tt">::</span></span> (“cons”) operator. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let l = ["is"; "a"; "tale"; "told"; "etc."];;

val l : string list = ["is"; "a"; "tale"; "told"; "etc."]</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># "Life" :: l;;

- : string list = ["Life"; "is"; "a"; "tale"; "told"; "etc."]</pre> </div> </div>
<p> As with all other OCaml data structures, lists do not need to be explicitly allocated and deallocated from memory: all memory management is entirely automatic in OCaml. Similarly, there is no explicit handling of pointers: the OCaml compiler silently introduces pointers where necessary.</p>
<p>As with most OCaml data structures, inspecting and destructuring lists is performed by pattern-matching. List patterns have exactly the same form as list expressions, with identifiers representing unspecified parts of the list. As an example, here is insertion sort on a list: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec sort lst =
    match lst with
      [] -&gt; []
    | head :: tail -&gt; insert head (sort tail)
  and insert elt lst =
    match lst with
      [] -&gt; [elt]
    | head :: tail -&gt; if elt &lt;= head then elt :: lst else head :: insert elt tail
  ;;

val sort : 'a list -&gt; 'a list = <fun>
val insert : 'a -&gt; 'a list -&gt; 'a list = </fun></pre> </div> <div class="ocaml"> <pre data-language="ocaml"># sort l;;

- : string list = ["a"; "etc."; "is"; "tale"; "told"]</pre> </div> </div>
<p>The type inferred for <span class="machine"><span class="font-tt">sort</span></span>, <span class="machine"><span class="font-tt">'a list -&gt; 'a list</span></span>, means that <span class="machine"><span class="font-tt">sort</span></span> can actually apply to lists of any type, and returns a list of the same type. The type <span class="machine"><span class="font-tt">'a</span></span> is a <em>type variable</em>, and stands for any given type. The reason why <span class="machine"><span class="font-tt">sort</span></span> can apply to lists of any type is that the comparisons (<span class="machine"><span class="font-tt">=</span></span>, <span class="machine"><span class="font-tt">&lt;=</span></span>, etc.) are <em>polymorphic</em> in OCaml: they operate between any two values of the same type. This makes <span class="machine"><span class="font-tt">sort</span></span> itself polymorphic over all list types. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># sort [6; 2; 5; 3];;

- : int list = [2; 3; 5; 6]</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># sort [3.14; 2.718];;

- : float list = [2.718; 3.14]</pre> </div> </div>
<p>The <span class="machine"><span class="font-tt">sort</span></span> function above does not modify its input list: it builds and returns a new list containing the same elements as the input list, in ascending order. There is actually no way in OCaml to modify a list in-place once it is built: we say that lists are <em>immutable</em> data structures. Most OCaml data structures are immutable, but a few (most notably arrays) are <em>mutable</em>, meaning that they can be modified in-place at any time.</p>
<p>The OCaml notation for the type of a function with multiple arguments is <br> <span class="machine"><span class="font-tt">arg1_type -&gt; arg2_type -&gt; ... -&gt; return_type</span></span>. For example, the type inferred for <span class="machine"><span class="font-tt">insert</span></span>, <span class="machine"><span class="font-tt">'a -&gt; 'a list -&gt; 'a list</span></span>, means that <span class="machine"><span class="font-tt">insert</span></span> takes two arguments, an element of any type <span class="machine"><span class="font-tt">'a</span></span> and a list with elements of the same type <span class="machine"><span class="font-tt">'a</span></span> and returns a list of the same type. </p> <h2 class="section" id="s:functions-as-values">
<a class="section-anchor" href="#s:functions-as-values" aria-hidden="true">﻿</a><span class="number">3</span> Functions as values</h2> <p>OCaml is a functional language: functions in the full mathematical sense are supported and can be passed around freely just as any other piece of data. For instance, here is a <span class="machine"><span class="font-tt">deriv</span></span> function that takes any float function as argument and returns an approximation of its derivative function: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let deriv f dx = fun x -&gt; (f (x +. dx) -. f x) /. dx;;

val deriv : (float -&gt; float) -&gt; float -&gt; float -&gt; float = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let sin' = deriv sin 1e-6;;

val sin' : float -&gt; float = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># sin' pi;;

- : float = -1.00000000013961143</pre> </div> </div>
<p> Even function composition is definable: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let compose f g = fun x -&gt; f (g x);;

val compose : ('a -&gt; 'b) -&gt; ('c -&gt; 'a) -&gt; 'c -&gt; 'b = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let cos2 = compose square cos;;

val cos2 : float -&gt; float = </pre> </div> </div>
<p>Functions that take other functions as arguments are called “functionals”, or “higher-order functions”. Functionals are especially useful to provide iterators or similar generic operations over a data structure. For instance, the standard OCaml library provides a <span class="machine"><span class="font-tt">List.map</span></span> functional that applies a given function to each element of a list, and returns the list of the results: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># List.map (fun n -&gt; n * 2 + 1) [0;1;2;3;4];;

- : int list = [1; 3; 5; 7; 9]</pre> </div> </div>
<p> This functional, along with a number of other list and array functionals, is predefined because it is often useful, but there is nothing magic with it: it can easily be defined as follows. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec map f l =
    match l with
      [] -&gt; []
    | hd :: tl -&gt; f hd :: map f tl;;

val map : ('a -&gt; 'b) -&gt; 'a list -&gt; 'b list = </pre> </div> </div> <h2 class="section" id="s:tut-recvariants">
<a class="section-anchor" href="#s:tut-recvariants" aria-hidden="true">﻿</a><span class="number">4</span> Records and variants</h2> <p>User-defined data structures include records and variants. Both are defined with the <span class="machine"><span class="font-tt">type</span></span> declaration. Here, we declare a record type to represent rational numbers. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type ratio = {num: int; denom: int};;

type ratio = { num : int; denom : int; }</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let add_ratio r1 r2 =
    {num = r1.num * r2.denom + r2.num * r1.denom;
     denom = r1.denom * r2.denom};;

val add_ratio : ratio -&gt; ratio -&gt; ratio = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># add_ratio {num=1; denom=3} {num=2; denom=5};;

- : ratio = {num = 11; denom = 15}</pre> </div> </div>
<p> Record fields can also be accessed through pattern-matching: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let integer_part r =
    match r with
      {num=num; denom=denom} -&gt; num / denom;;

val integer_part : ratio -&gt; int = </pre> </div> </div>
<p> Since there is only one case in this pattern matching, it is safe to expand directly the argument <span class="machine"><span class="font-tt">r</span></span> in a record pattern: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let integer_part {num=num; denom=denom} = num / denom;;

val integer_part : ratio -&gt; int = </pre> </div> </div>
<p> Unneeded fields can be omitted: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let get_denom {denom=denom} = denom;;

val get_denom : ratio -&gt; int = </pre> </div> </div>
<p> Optionally, missing fields can be made explicit by ending the list of fields with a trailing wildcard <span class="machine"><span class="font-tt">_</span></span>:: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let get_num {num=num; _ } = num;;

val get_num : ratio -&gt; int = </pre> </div> </div>
<p> When both sides of the <span class="machine"><span class="font-tt">=</span></span> sign are the same, it is possible to avoid repeating the field name by eliding the <span class="machine"><span class="font-tt">=field</span></span> part: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let integer_part {num; denom} = num / denom;;

val integer_part : ratio -&gt; int = </pre> </div> </div>
<p> This short notation for fields also works when constructing records: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let ratio num denom = {num; denom};;

val ratio : int -&gt; int -&gt; ratio = </pre> </div> </div>
<p> At last, it is possible to update few fields of a record at once: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let integer_product integer ratio = { ratio with num = integer * ratio.num };;

val integer_product : int -&gt; ratio -&gt; ratio = </pre> </div> </div>
<p> With this functional update notation, the record on the left-hand side of <span class="machine"><span class="font-tt">with</span></span> is copied except for the fields on the right-hand side which are updated.</p>
<p>The declaration of a variant type lists all possible forms for values of that type. Each case is identified by a name, called a constructor, which serves both for constructing values of the variant type and inspecting them by pattern-matching. Constructor names are capitalized to distinguish them from variable names (which must start with a lowercase letter). For instance, here is a variant type for doing mixed arithmetic (integers and floats): </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type number = Int of int | Float of float | Error;;

type number = Int of int | Float of float | Error</pre> </div> </div>
<p> This declaration expresses that a value of type <span class="machine"><span class="font-tt">number</span></span> is either an integer, a floating-point number, or the constant <span class="machine"><span class="font-tt">Error</span></span> representing the result of an invalid operation (e.g. a division by zero).</p>
<p>Enumerated types are a special case of variant types, where all alternatives are constants: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type sign = Positive | Negative;;

type sign = Positive | Negative</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let sign_int n = if n &gt;= 0 then Positive else Negative;;

val sign_int : int -&gt; sign = </pre> </div> </div>
<p>To define arithmetic operations for the <span class="machine"><span class="font-tt">number</span></span> type, we use pattern-matching on the two numbers involved: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let add_num n1 n2 =
    match (n1, n2) with
      (Int i1, Int i2) -&gt;
        (* Check for overflow of integer addition *)
        if sign_int i1 = sign_int i2 &amp;&amp; sign_int (i1 + i2) &lt;&gt; sign_int i1
        then Float(float i1 +. float i2)
        else Int(i1 + i2)
    | (Int i1, Float f2) -&gt; Float(float i1 +. f2)
    | (Float f1, Int i2) -&gt; Float(f1 +. float i2)
    | (Float f1, Float f2) -&gt; Float(f1 +. f2)
    | (Error, _) -&gt; Error
    | (_, Error) -&gt; Error;;

val add_num : number -&gt; number -&gt; number = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># add_num (Int 123) (Float 3.14159);;

- : number = Float 126.14159</pre> </div> </div>
<p>Another interesting example of variant type is the built-in <span class="machine"><span class="font-tt">'a option</span></span> type which represents either a value of type <span class="machine"><span class="font-tt">'a</span></span> or an absence of value: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type 'a option = Some of 'a | None;;

type 'a option = Some of 'a | None</pre> </div> </div>
<p> This type is particularly useful when defining function that can fail in common situations, for instance </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let safe_square_root x = if x &gt;= 0. then Some(sqrt x) else None;;

val safe_square_root : float -&gt; float option = </pre> </div> </div>
<p>The most common usage of variant types is to describe recursive data structures. Consider for example the type of binary trees: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type 'a btree = Empty | Node of 'a * 'a btree * 'a btree;;

type 'a btree = Empty | Node of 'a * 'a btree * 'a btree</pre> </div> </div>
<p> This definition reads as follows: a binary tree containing values of type <span class="machine"><span class="font-tt">'a</span></span> (an arbitrary type) is either empty, or is a node containing one value of type <span class="machine"><span class="font-tt">'a</span></span> and two subtrees also containing values of type <span class="machine"><span class="font-tt">'a</span></span>, that is, two <span class="machine"><span class="font-tt">'a btree</span></span>.</p>
<p>Operations on binary trees are naturally expressed as recursive functions following the same structure as the type definition itself. For instance, here are functions performing lookup and insertion in ordered binary trees (elements increase from left to right): </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec member x btree =
    match btree with
      Empty -&gt; false
    | Node(y, left, right) -&gt;
        if x = y then true else
        if x &lt; y then member x left else member x right;;

val member : 'a -&gt; 'a btree -&gt; bool = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let rec insert x btree =
    match btree with
      Empty -&gt; Node(x, Empty, Empty)
    | Node(y, left, right) -&gt;
        if x &lt;= y then Node(y, insert x left, right)
                  else Node(y, left, insert x right);;

val insert : 'a -&gt; 'a btree -&gt; 'a btree = </pre> </div> </div> <h3 class="subsection" id="ss:record-and-variant-disambiguation">
<a class="section-anchor" href="#ss:record-and-variant-disambiguation" aria-hidden="true">﻿</a><span class="number">4.1</span> Record and variant disambiguation</h3> <p> ( This subsection can be skipped on the first reading )</p>
<p>Astute readers may have wondered what happens when two or more record fields or constructors share the same name</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># type first_record  = { x:int; y:int; z:int }
  type middle_record = { x:int; z:int }
  type last_record   = { x:int };;</pre>
</div> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># type first_variant = A | B | C
  type last_variant  = A;;</pre>
</div> </div>
<p>The answer is that when confronted with multiple options, OCaml tries to use locally available information to disambiguate between the various fields and constructors. First, if the type of the record or variant is known, OCaml can pick unambiguously the corresponding field or constructor. For instance:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let look_at_x_then_z (r:first_record) =
    let x = r.x in
    x + r.z;;

val look_at_x_then_z : first_record -&gt; int = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let permute (x:first_variant) = match x with
    | A -&gt; (B:first_variant)
    | B -&gt; A
    | C -&gt; C;;

val permute : first_variant -&gt; first_variant = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># type wrapped = First of first_record
  let f (First r) = r, r.x;;

type wrapped = First of first_record
val f : wrapped -&gt; first_record * int = </pre> </div> </div>
<p>In the first example, <span class="machine"><span class="font-tt">(r:first_record)</span></span> is an explicit annotation telling OCaml that the type of <span class="machine"><span class="font-tt">r</span></span> is <span class="machine"><span class="font-tt">first_record</span></span>. With this annotation, Ocaml knows that <span class="machine"><span class="font-tt">r.x</span></span> refers to the <span class="machine"><span class="font-tt">x</span></span> field of the first record type. Similarly, the type annotation in the second example makes it clear to OCaml that the constructors <span class="machine"><span class="font-tt">A</span></span>, <span class="machine"><span class="font-tt">B</span></span> and <span class="machine"><span class="font-tt">C</span></span> come from the first variant type. Contrarily, in the last example, OCaml has inferred by itself that the type of <span class="machine"><span class="font-tt">r</span></span> can only be <span class="machine"><span class="font-tt">first_record</span></span> and there are no needs for explicit type annotations.</p>
<p>Those explicit type annotations can in fact be used anywhere. Most of the time they are unnecessary, but they are useful to guide disambiguation, to debug unexpected type errors, or combined with some of the more advanced features of OCaml described in later chapters.</p>
<p>Secondly, for records, OCaml can also deduce the right record type by looking at the whole set of fields used in a expression or pattern: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let project_and_rotate {x; y; _} = { x= - y; y = x; z = 0} ;;

val project_and_rotate : first_record -&gt; first_record = </pre> </div> </div>
<p> Since the fields <span class="machine"><span class="font-tt">x</span></span> and <span class="machine"><span class="font-tt">y</span></span> can only appear simultaneously in the first record type, OCaml infers that the type of <span class="machine"><span class="font-tt">project_and_rotate</span></span> is <span class="machine"><span class="font-tt">first_record -&gt; first_record</span></span>.</p>
<p>In last resort, if there is not enough information to disambiguate between different fields or constructors, Ocaml picks the last defined type amongst all locally valid choices:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let look_at_xz {x; z} = x;;

val look_at_xz : middle_record -&gt; int = </pre> </div> </div>
<p>Here, OCaml has inferred that the possible choices for the type of <span class="machine"><span class="font-tt">{x;z}</span></span> are <span class="machine"><span class="font-tt">first_record</span></span> and <span class="machine"><span class="font-tt">middle_record</span></span>, since the type <span class="machine"><span class="font-tt">last_record</span></span> has no field <span class="machine"><span class="font-tt">z</span></span>. Ocaml then picks the type <span class="machine"><span class="font-tt">middle_record</span></span> as the last defined type between the two possibilities.</p>
<p>Beware that this last resort disambiguation is local: once Ocaml has chosen a disambiguation, it sticks to this choice, even if it leads to an ulterior type error:</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let look_at_x_then_y r =
    let x = r.x in (* Ocaml deduces [r: last_record] *)
    x + r.y;;

Error: This expression has type last_record
       There is no field y within type last_record</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let is_a_or_b x = match x with
    | A -&gt; true (* OCaml infers [x: last_variant] *)
    | B -&gt; true;;

Error: This variant pattern is expected to have type last_variant
       There is no constructor B within type last_variant</pre> </div> </div>
<p>Moreover, being the last defined type is a quite unstable position that may change surreptitiously after adding or moving around a type definition, or after opening a module (see chapter <a href="moduleexamples.html#c%3Amoduleexamples">2</a>). Consequently, adding explicit type annotations to guide disambiguation is more robust than relying on the last defined type disambiguation.</p> <h2 class="section" id="s:imperative-features">
<a class="section-anchor" href="#s:imperative-features" aria-hidden="true">﻿</a><span class="number">5</span> Imperative features</h2> <p>Though all examples so far were written in purely applicative style, OCaml is also equipped with full imperative features. This includes the usual <span class="machine"><span class="font-tt">while</span></span> and <span class="machine"><span class="font-tt">for</span></span> loops, as well as mutable data structures such as arrays. Arrays are either created by listing semicolon-separated element values between <span class="machine"><span class="font-tt">[|</span></span> and <span class="machine"><span class="font-tt">|]</span></span> brackets, or allocated and initialized with the <span class="machine"><span class="font-tt">Array.make</span></span> function, then filled up later by assignments. For instance, the function below sums two vectors (represented as float arrays) componentwise. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let add_vect v1 v2 =
    let len = min (Array.length v1) (Array.length v2) in
    let res = Array.make len 0.0 in
    for i = 0 to len - 1 do
      res.(i) &lt;- v1.(i) +. v2.(i)
    done;
    res;;

val add_vect : float array -&gt; float array -&gt; float array = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># add_vect [| 1.0; 2.0 |] [| 3.0; 4.0 |];;

- : float array = [|4.; 6.|]</pre> </div> </div>
<p>Record fields can also be modified by assignment, provided they are declared <span class="machine"><span class="font-tt">mutable</span></span> in the definition of the record type: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type mutable_point = { mutable x: float; mutable y: float };;

type mutable_point = { mutable x : float; mutable y : float; }</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let translate p dx dy =
    p.x &lt;- p.x +. dx; p.y &lt;- p.y +. dy;;

val translate : mutable_point -&gt; float -&gt; float -&gt; unit = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let mypoint = { x = 0.0; y = 0.0 };;

val mypoint : mutable_point = {x = 0.; y = 0.}</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># translate mypoint 1.0 2.0;;

- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># mypoint;;

- : mutable_point = {x = 1.; y = 2.}</pre> </div> </div>
<p>OCaml has no built-in notion of variable – identifiers whose current value can be changed by assignment. (The <span class="machine"><span class="font-tt">let</span></span> binding is not an assignment, it introduces a new identifier with a new scope.) However, the standard library provides references, which are mutable indirection cells, with operators <span class="machine"><span class="font-tt">!</span></span> to fetch the current contents of the reference and <span class="machine"><span class="font-tt">:=</span></span> to assign the contents. Variables can then be emulated by <span class="machine"><span class="font-tt">let</span></span>-binding a reference. For instance, here is an in-place insertion sort over arrays: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let insertion_sort a =
    for i = 1 to Array.length a - 1 do
      let val_i = a.(i) in
      let j = ref i in
      while !j &gt; 0 &amp;&amp; val_i &lt; a.(!j - 1) do
        a.(!j) &lt;- a.(!j - 1);
        j := !j - 1
      done;
      a.(!j) &lt;- val_i
    done;;

val insertion_sort : 'a array -&gt; unit = </pre> </div> </div>
<p>References are also useful to write functions that maintain a current state between two calls to the function. For instance, the following pseudo-random number generator keeps the last returned number in a reference: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let current_rand = ref 0;;

val current_rand : int ref = {contents = 0}</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let random () =
    current_rand := !current_rand * 25713 + 1345;
    !current_rand;;

val random : unit -&gt; int = </pre> </div> </div>
<p>Again, there is nothing magical with references: they are implemented as a single-field mutable record, as follows. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type 'a ref = { mutable contents: 'a };;

type 'a ref = { mutable contents : 'a; }</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let ( ! ) r = r.contents;;

val ( ! ) : 'a ref -&gt; 'a = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let ( := ) r newval = r.contents &lt;- newval;;

val ( := ) : 'a ref -&gt; 'a -&gt; unit = </pre> </div> </div>
<p>In some special cases, you may need to store a polymorphic function in a data structure, keeping its polymorphism. Doing this requires user-provided type annotations, since polymorphism is only introduced automatically for global definitions. However, you can explicitly give polymorphic types to record fields. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type idref = { mutable id: 'a. 'a -&gt; 'a };;

type idref = { mutable id : 'a. 'a -&gt; 'a; }</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let r = {id = fun x -&gt; x};;

val r : idref = {id = <fun>}</fun></pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let g s = (s.id 1, s.id true);;

val g : idref -&gt; int * bool = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># r.id &lt;- (fun x -&gt; print_string "called id\n"; x);;

- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># g r;;

called id
called id
- : int * bool = (1, true)</pre> </div> </div> <h2 class="section" id="s:exceptions">
<a class="section-anchor" href="#s:exceptions" aria-hidden="true">﻿</a><span class="number">6</span> Exceptions</h2> <p>OCaml provides exceptions for signalling and handling exceptional conditions. Exceptions can also be used as a general-purpose non-local control structure, although this should not be overused since it can make the code harder to understand. Exceptions are declared with the <span class="machine"><span class="font-tt">exception</span></span> construct, and signalled with the <span class="machine"><span class="font-tt">raise</span></span> operator. For instance, the function below for taking the head of a list uses an exception to signal the case where an empty list is given. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># exception Empty_list;;

exception Empty_list</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let head l =
    match l with
      [] -&gt; raise Empty_list
    | hd :: tl -&gt; hd;;

val head : 'a list -&gt; 'a = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># head [1; 2];;

- : int = 1</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># head [];;

Exception: Empty_list.</pre> </div> </div>
<p>Exceptions are used throughout the standard library to signal cases where the library functions cannot complete normally. For instance, the <span class="machine"><span class="font-tt">List.assoc</span></span> function, which returns the data associated with a given key in a list of (key, data) pairs, raises the predefined exception <span class="machine"><span class="font-tt">Not_found</span></span> when the key does not appear in the list: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># List.assoc 1 [(0, "zero"); (1, "one")];;

- : string = "one"</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># List.assoc 2 [(0, "zero"); (1, "one")];;

Exception: Not_found.</pre> </div> </div>
<p>Exceptions can be trapped with the <span class="machine"><span class="font-tt">try</span></span>…<span class="machine"><span class="font-tt">with</span></span> construct: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let name_of_binary_digit digit =
    try
      List.assoc digit [0, "zero"; 1, "one"]
    with Not_found -&gt;
      "not a binary digit";;

val name_of_binary_digit : int -&gt; string = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># name_of_binary_digit 0;;

- : string = "zero"</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># name_of_binary_digit (-1);;

- : string = "not a binary digit"</pre> </div> </div>
<p>The <span class="machine"><span class="font-tt">with</span></span> part does pattern matching on the exception value with the same syntax and behavior as <span class="machine"><span class="font-tt">match</span></span>. Thus, several exceptions can be caught by one <span class="machine"><span class="font-tt">try</span></span>…<span class="machine"><span class="font-tt">with</span></span> construct: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec first_named_value values names =
    try
      List.assoc (head values) names
    with
    | Empty_list -&gt; "no named value"
    | Not_found -&gt; first_named_value (List.tl values) names;;

val first_named_value : 'a list -&gt; ('a * string) list -&gt; string = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># first_named_value [0; 10] [1, "one"; 10, "ten"];;

- : string = "ten"</pre> </div> </div>
<p>Also, finalization can be performed by trapping all exceptions, performing the finalization, then re-raising the exception: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let temporarily_set_reference ref newval funct =
    let oldval = !ref in
    try
      ref := newval;
      let res = funct () in
      ref := oldval;
      res
    with x -&gt;
      ref := oldval;
      raise x;;

val temporarily_set_reference : 'a ref -&gt; 'a -&gt; (unit -&gt; 'b) -&gt; 'b = </pre> </div> </div>
<p>An alternative to <span class="machine"><span class="font-tt">try</span></span>…<span class="machine"><span class="font-tt">with</span></span> is to catch the exception while pattern matching: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let assoc_may_map f x l =
    match List.assoc x l with
    | exception Not_found -&gt; None
    | y -&gt; f y;;

val assoc_may_map : ('a -&gt; 'b option) -&gt; 'c -&gt; ('c * 'a) list -&gt; 'b option =
  </pre> </div> </div>
<p> Note that this construction is only useful if the exception is raised between <span class="machine"><span class="font-tt">match</span></span>…<span class="machine"><span class="font-tt">with</span></span>. Exception patterns can be combined with ordinary patterns at the toplevel, </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let flat_assoc_opt x l =
    match List.assoc x l with
    | None | exception Not_found -&gt; None
    | Some _ as v -&gt; v;;

val flat_assoc_opt : 'a -&gt; ('a * 'b option) list -&gt; 'b option = </pre> </div> </div>
<p> but they cannot be nested inside other patterns. For instance, the pattern <span class="machine"><span class="font-tt">Some (exception A)</span></span> is invalid.</p>
<p>When exceptions are used as a control structure, it can be useful to make them as local as possible by using a locally defined exception. For instance, with </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let fixpoint f x =
    let exception Done in
    let x = ref x in
    try while true do
        let y = f !x in
        if !x = y then raise Done else x := y
      done
    with Done -&gt; !x;;

val fixpoint : ('a -&gt; 'a) -&gt; 'a -&gt; 'a = </pre> </div> </div>
<p> the function <span class="machine"><span class="font-tt">f</span></span> cannot raise a <span class="machine"><span class="font-tt">Done</span></span> exception, which removes an entire class of misbehaving functions.</p> <h2 class="section" id="s:lazy-expr">
<a class="section-anchor" href="#s:lazy-expr" aria-hidden="true">﻿</a><span class="number">7</span> Lazy expressions</h2> <p>OCaml allows us to defer some computation until later when we need the result of that computation. </p>
<p>We use <span class="machine"><span class="font-tt">lazy (expr)</span></span> to delay the evaluation of some expression <span class="machine"><span class="font-tt">expr</span></span>. For example, we can defer the computation of <span class="machine"><span class="font-tt">1+1</span></span> until we need the result of that expression, <span class="machine"><span class="font-tt">2</span></span>. Let us see how we initialize a lazy expression. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let lazy_two = lazy (print_endline "lazy_two evaluation"; 1 + 1);;

val lazy_two : int lazy_t = </pre> </div> </div>
<p>We added <span class="machine"><span class="font-tt">print_endline "lazy_two evaluation"</span></span> to see when the lazy expression is being evaluated.</p>
<p>The value of <span class="machine"><span class="font-tt">lazy_two</span></span> is displayed as <span class="machine"><span class="font-tt">&lt;lazy&gt;</span></span>, which means the expression has not been evaluated yet, and its final value is unknown.</p>
<p>Note that <span class="machine"><span class="font-tt">lazy_two</span></span> has type <span class="machine"><span class="font-tt">int lazy_t</span></span>. However, the type <span class="machine"><span class="font-tt">'a lazy_t</span></span> is an internal type name, so the type <span class="machine"><span class="font-tt">'a Lazy.t</span></span> should be preferred when possible.</p>
<p>When we finally need the result of a lazy expression, we can call <span class="machine"><span class="font-tt">Lazy.force</span></span> on that expression to force its evaluation. The function <span class="machine"><span class="font-tt">force</span></span> comes from standard-library module <a href="api/lazy.html"><span class="font-tt">Lazy</span></a>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Lazy.force lazy_two;;

lazy_two evaluation
- : int = 2</pre> </div> </div>
<p>Notice that our function call above prints “lazy_two evaluation” and then returns the plain value of the computation. </p>
<p>Now if we look at the value of <span class="machine"><span class="font-tt">lazy_two</span></span>, we see that it is not displayed as <span class="machine"><span class="font-tt">&lt;lazy&gt;</span></span> anymore but as <span class="machine"><span class="font-tt">lazy 2</span></span>.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># lazy_two;;

- : int lazy_t = lazy 2</pre> </div> </div>
<p>This is because <span class="machine"><span class="font-tt">Lazy.force</span></span> memoizes the result of the forced expression. In other words, every subsequent call of <span class="machine"><span class="font-tt">Lazy.force</span></span> on that expression returns the result of the first computation without recomputing the lazy expression. Let us force <span class="machine"><span class="font-tt">lazy_two</span></span> once again. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Lazy.force lazy_two;;

- : int = 2</pre> </div> </div>
<p>The expression is not evaluated this time; notice that “lazy_two evaluation” is not printed. The result of the initial computation is simply returned. </p>
<p>Lazy patterns provide another way to force a lazy expression. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let lazy_l = lazy ([1; 2] @ [3; 4]);;

val lazy_l : int list lazy_t = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let lazy l = lazy_l;;

val l : int list = [1; 2; 3; 4]</pre> </div> </div>
<p>We can also use lazy patterns in pattern matching.</p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let maybe_eval lazy_guard lazy_expr =
    match lazy_guard, lazy_expr with
    | lazy false, _ -&gt; "matches if (Lazy.force lazy_guard = false); lazy_expr not forced"
    | lazy true, lazy _ -&gt; "matches if (Lazy.force lazy_guard = true); lazy_expr forced";;

val maybe_eval : bool lazy_t -&gt; 'a lazy_t -&gt; string = </pre> </div> </div>
<p>The lazy expression <span class="machine"><span class="font-tt">lazy_expr</span></span> is forced only if the <span class="machine"><span class="font-tt">lazy_guard</span></span> value yields <span class="machine"><span class="font-tt">true</span></span> once computed. Indeed, a simple wildcard pattern (not lazy) never forces the lazy expression’s evaluation. However, a pattern with keyword <span class="machine"><span class="font-tt">lazy</span></span>, even if it is wildcard, always forces the evaluation of the deferred computation.</p> <h2 class="section" id="s:symb-expr">
<a class="section-anchor" href="#s:symb-expr" aria-hidden="true">﻿</a><span class="number">8</span> Symbolic processing of expressions</h2> <p>We finish this introduction with a more complete example representative of the use of OCaml for symbolic processing: formal manipulations of arithmetic expressions containing variables. The following variant type describes the expressions we shall manipulate: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># type expression =
      Const of float
    | Var of string
    | Sum of expression * expression    (* e1 + e2 *)
    | Diff of expression * expression   (* e1 - e2 *)
    | Prod of expression * expression   (* e1 * e2 *)
    | Quot of expression * expression   (* e1 / e2 *)
  ;;

type expression =
    Const of float
  | Var of string
  | Sum of expression * expression
  | Diff of expression * expression
  | Prod of expression * expression
  | Quot of expression * expression</pre> </div> </div>
<p>We first define a function to evaluate an expression given an environment that maps variable names to their values. For simplicity, the environment is represented as an association list. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># exception Unbound_variable of string;;

exception Unbound_variable of string</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let rec eval env exp =
    match exp with
      Const c -&gt; c
    | Var v -&gt;
        (try List.assoc v env with Not_found -&gt; raise (Unbound_variable v))
    | Sum(f, g) -&gt; eval env f +. eval env g
    | Diff(f, g) -&gt; eval env f -. eval env g
    | Prod(f, g) -&gt; eval env f *. eval env g
    | Quot(f, g) -&gt; eval env f /. eval env g;;

val eval : (string * float) list -&gt; expression -&gt; float = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># eval [("x", 1.0); ("y", 3.14)] (Prod(Sum(Var "x", Const 2.0), Var "y"));;

- : float = 9.42</pre> </div> </div>
<p>Now for a real symbolic processing, we define the derivative of an expression with respect to a variable <span class="machine"><span class="font-tt">dv</span></span>: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let rec deriv exp dv =
    match exp with
      Const c -&gt; Const 0.0
    | Var v -&gt; if v = dv then Const 1.0 else Const 0.0
    | Sum(f, g) -&gt; Sum(deriv f dv, deriv g dv)
    | Diff(f, g) -&gt; Diff(deriv f dv, deriv g dv)
    | Prod(f, g) -&gt; Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
    | Quot(f, g) -&gt; Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                         Prod(g, g))
  ;;

val deriv : expression -&gt; string -&gt; expression = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># deriv (Quot(Const 1.0, Var "x")) "x";;

- : expression =
Quot (Diff (Prod (Const 0., Var "x"), Prod (Const 1., Const 1.)),
 Prod (Var "x", Var "x"))</pre> </div> </div> <h2 class="section" id="s:pretty-printing">
<a class="section-anchor" href="#s:pretty-printing" aria-hidden="true">﻿</a><span class="number">9</span> Pretty-printing</h2> <p>As shown in the examples above, the internal representation (also called <em>abstract syntax</em>) of expressions quickly becomes hard to read and write as the expressions get larger. We need a printer and a parser to go back and forth between the abstract syntax and the <em>concrete syntax</em>, which in the case of expressions is the familiar algebraic notation (e.g. <span class="machine"><span class="font-tt">2*x+1</span></span>).</p>
<p>For the printing function, we take into account the usual precedence rules (i.e. <span class="machine"><span class="font-tt">*</span></span> binds tighter than <span class="machine"><span class="font-tt">+</span></span>) to avoid printing unnecessary parentheses. To this end, we maintain the current operator precedence and print parentheses around an operator only if its precedence is less than the current precedence. </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let print_expr exp =
    (* Local function definitions *)
    let open_paren prec op_prec =
      if prec &gt; op_prec then print_string "(" in
    let close_paren prec op_prec =
      if prec &gt; op_prec then print_string ")" in
    let rec print prec exp =     (* prec is the current precedence *)
      match exp with
        Const c -&gt; print_float c
      | Var v -&gt; print_string v
      | Sum(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string " + "; print 0 g;
          close_paren prec 0
      | Diff(f, g) -&gt;
          open_paren prec 0;
          print 0 f; print_string " - "; print 1 g;
          close_paren prec 0
      | Prod(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string " * "; print 2 g;
          close_paren prec 2
      | Quot(f, g) -&gt;
          open_paren prec 2;
          print 2 f; print_string " / "; print 3 g;
          close_paren prec 2
    in print 0 exp;;

val print_expr : expression -&gt; unit = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># let e = Sum(Prod(Const 2.0, Var "x"), Const 1.0);;

val e : expression = Sum (Prod (Const 2., Var "x"), Const 1.)</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># print_expr e; print_newline ();;

2. * x + 1.
- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># print_expr (deriv e "x"); print_newline ();;

2. * 1. + 0. * x + 0.
- : unit = ()</pre> </div> </div> <h2 class="section" id="s:printf">
<a class="section-anchor" href="#s:printf" aria-hidden="true">﻿</a><span class="number">10</span> Printf formats</h2> <p>There is a <span class="machine"><span class="font-tt">printf</span></span> function in the <a href="api/printf.html"><span class="font-tt">Printf</span></a> module (see chapter ‍<a href="moduleexamples.html#c%3Amoduleexamples">2</a>) that allows you to make formatted output more concisely. It follows the behavior of the <span class="machine"><span class="font-tt">printf</span></span> function from the C standard library. The <span class="machine"><span class="font-tt">printf</span></span> function takes a format string that describes the desired output as a text interspersed with specifiers (for instance <span class="machine"><span class="font-tt">%d</span></span>, <span class="machine"><span class="font-tt">%f</span></span>). Next, the specifiers are substituted by the following arguments in their order of apparition in the format string: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Printf.printf "%i + %i is an integer value, %F * %F is a float, %S\n"
  3 2 4.5 1. "this is a string";;

3 + 2 is an integer value, 4.5 * 1. is a float, "this is a string"
- : unit = ()</pre> </div> </div>
<p> The OCaml type system checks that the type of the arguments and the specifiers are compatible. If you pass it an argument of a type that does not correspond to the format specifier, the compiler will display an error message: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Printf.printf "Float value: %F" 42;;

Error: This expression has type int but an expression was expected of type
         float
  Hint: Did you mean 42.?</pre> </div> </div>
<p> The <span class="machine"><span class="font-tt">fprintf</span></span> function is like <span class="machine"><span class="font-tt">printf</span></span> except that it takes an output channel as the first argument. The <span class="machine"><span class="font-tt">%a</span></span> specifier can be useful to define custom printers (for custom types). For instance, we can create a printing template that converts an integer argument to signed decimal: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let pp_int ppf n = Printf.fprintf ppf "%d" n;;

val pp_int : out_channel -&gt; int -&gt; unit = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># Printf.printf "Outputting an integer using a custom printer: %a " pp_int 42;;

Outputting an integer using a custom printer: 42 - : unit = ()</pre> </div> </div>
<p> The advantage of those printers based on the <span class="machine"><span class="font-tt">%a</span></span> specifier is that they can be composed together to create more complex printers step by step. We can define a combinator that can turn a printer for <span class="machine"><span class="font-tt">'a</span></span> type into a printer for <span class="machine"><span class="font-tt">'a optional</span></span>: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let pp_option printer ppf = function
    | None -&gt; Printf.fprintf ppf "None"
    | Some v -&gt; Printf.fprintf ppf "Some(%a)" printer v;;

val pp_option :
  (out_channel -&gt; 'a -&gt; unit) -&gt; out_channel -&gt; 'a option -&gt; unit = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># Printf.fprintf stdout
    "The current setting is %a. \nThere is only %a\n"
    (pp_option pp_int) (Some 3)
    (pp_option pp_int) None
  ;;

The current setting is Some(3).
There is only None
- : unit = ()</pre> </div> </div>
<p> If the value of its argument its <span class="machine"><span class="font-tt">None</span></span>, the printer returned by pp_option printer prints <span class="machine"><span class="font-tt">None</span></span> otherwise it uses the provided printer to print <span class="machine"><span class="font-tt">Some </span></span>.</p>
<p>Here is how to rewrite the pretty-printer using <span class="machine"><span class="font-tt">fprintf</span></span>: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># let pp_expr ppf expr =
    let open_paren prec op_prec output =
      if prec &gt; op_prec then Printf.fprintf output "%s" "(" in
    let close_paren prec op_prec output =
      if prec &gt; op_prec then Printf.fprintf output "%s" ")" in
    let rec print prec ppf expr =
        match expr with
        | Const c -&gt; Printf.fprintf ppf "%F" c
        | Var v -&gt; Printf.fprintf ppf "%s" v
        | Sum(f, g) -&gt;
            open_paren prec 0 ppf;
            Printf.fprintf ppf "%a + %a" (print 0) f (print 0) g;
            close_paren prec 0 ppf
        | Diff(f, g) -&gt;
            open_paren prec 0 ppf;
            Printf.fprintf ppf "%a - %a" (print 0) f (print 1) g;
            close_paren prec 0 ppf
        | Prod(f, g) -&gt;
            open_paren prec 2 ppf;
            Printf.fprintf ppf "%a * %a" (print 2) f (print 2) g;
            close_paren prec 2 ppf
        | Quot(f, g) -&gt;
            open_paren prec 2 ppf;
            Printf.fprintf ppf "%a / %a" (print 2) f (print 3) g;
            close_paren prec 2 ppf
    in print 0 ppf expr;;

val pp_expr : out_channel -&gt; expression -&gt; unit = </pre> </div> <div class="ocaml"> <pre data-language="ocaml"># pp_expr stdout e; print_newline ();;

2. * x + 1.
- : unit = ()</pre> </div> <div class="ocaml"> <pre data-language="ocaml"># pp_expr stdout (deriv e "x"); print_newline ();;

2. * 1. + 0. * x + 0.
- : unit = ()</pre> </div> </div>
<p>Due to the way that format strings are built, storing a format string requires an explicit type annotation: </p>
<div class="caml-example toplevel"> <div class="ocaml"> <pre class=" caml-input" data-language="ocaml"># let str : _ format =
      "%i is an integer value, %F is a float, %S\n";;</pre>
</div> </div>
<div class="caml-example toplevel"> <div class="ocaml"> <pre data-language="ocaml"># Printf.printf str 3 4.5 "string value";;

3 is an integer value, 4.5 is a float, "string value"
- : unit = ()</pre> </div> </div> <h2 class="section" id="s:standalone-programs">
<a class="section-anchor" href="#s:standalone-programs" aria-hidden="true">﻿</a><span class="number">11</span> Standalone OCaml programs</h2> <p>All examples given so far were executed under the interactive system. OCaml code can also be compiled separately and executed non-interactively using the batch compilers <span class="machine"><span class="font-tt">ocamlc</span></span> and <span class="machine"><span class="font-tt">ocamlopt</span></span>. The source code must be put in a file with extension <span class="machine"><span class="font-tt">.ml</span></span>. It consists of a sequence of phrases, which will be evaluated at runtime in their order of appearance in the source file. Unlike in interactive mode, types and values are not printed automatically; the program must call printing functions explicitly to produce some output. The <span class="machine"><span class="font-tt">;;</span></span> used in the interactive examples is not required in source files created for use with OCaml compilers, but can be helpful to mark the end of a top-level expression unambiguously even when there are syntax errors. Here is a sample standalone program to print the greatest common divisor (gcd) of two numbers: </p>
<pre data-language="ocaml">(* File gcd.ml *)
let rec gcd a b =
  if b = 0 then a
  else gcd b (a mod b);;

let main () =
  let a = int_of_string Sys.argv.(1) in
  let b = int_of_string Sys.argv.(2) in
  Printf.printf "%d\n" (gcd a b);
  exit 0;;
main ();;
</pre>
<p><span class="machine"><span class="font-tt">Sys.argv</span></span> is an array of strings containing the command-line parameters. <span class="machine"><span class="font-tt">Sys.argv.(1)</span></span> is thus the first command-line parameter. The program above is compiled and executed with the following shell commands: </p>
<pre data-language="ocaml">$ ocamlc -o gcd gcd.ml
$ ./gcd 6 9
3
$ ./gcd 7 11
1
</pre>
<p> More complex standalone OCaml programs are typically composed of multiple source files, and can link with precompiled libraries. Chapters ‍<a href="comp.html#c%3Acamlc">13</a> and ‍<a href="native.html#c%3Anativecomp">16</a> explain how to use the batch compilers <span class="machine"><span class="font-tt">ocamlc</span></span> and <span class="machine"><span class="font-tt">ocamlopt</span></span>. Recompilation of multi-file OCaml projects can be automated using third-party build systems, such as <a href="https://github.com/ocaml/dune">dune</a>. </p>  <div class="bottom-navigation">
<a class="previous" href="foreword.html">« Foreword</a><a class="next" href="moduleexamples.html">The module system »</a>
</div> <div class="copyright">Copyright © 2024 Institut National de Recherche en Informatique et en Automatique</div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1995-2024 INRIA.<br>
    <a href="https://ocaml.org/manual/5.2/coreexamples.html" class="_attribution-link">https://ocaml.org/manual/5.2/coreexamples.html</a>
  </p>
</div>
