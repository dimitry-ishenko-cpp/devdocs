<div class="section-level-extent" id="Restricted-Pointers"> <div class="nav-panel"> <p> Next: <a href="vague-linkage.html" accesskey="n" rel="next">Vague Linkage</a>, Previous: <a href="c_002b_002b-volatiles.html" accesskey="p" rel="prev">When is a Volatile C++ Object Accessed?</a>, Up: <a href="c_002b_002b-extensions.html" accesskey="u" rel="up">Extensions to the C++ Language</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Restricting-Pointer-Aliasing"><span>7.2 Restricting Pointer Aliasing<a class="copiable-link" href="#Restricting-Pointer-Aliasing"> ¶</a></span></h1>    <p>As with the C front end, G++ understands the C99 feature of restricted pointers, specified with the <code class="code">__restrict__</code>, or <code class="code">__restrict</code> type qualifier. Because you cannot compile C++ by specifying the <samp class="option">-std=c99</samp> language flag, <code class="code">restrict</code> is not a keyword in C++. </p> <p>In addition to allowing restricted pointers, you can specify restricted references, which indicate that the reference is not aliased in the local context. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void fn (int *__restrict__ rptr, int &amp;__restrict__ rref)
{
  /* <span class="r">…</span> */
}</pre>
</div> <p>In the body of <code class="code">fn</code>, <var class="var">rptr</var> points to an unaliased integer and <var class="var">rref</var> refers to a (different) unaliased integer. </p> <p>You may also specify whether a member function’s <var class="var">this</var> pointer is unaliased by using <code class="code">__restrict__</code> as a member function qualifier. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void T::fn () __restrict__
{
  /* <span class="r">…</span> */
}</pre>
</div> <p>Within the body of <code class="code">T::fn</code>, <var class="var">this</var> has the effective definition <code class="code">T *__restrict__ const this</code>. Notice that the interpretation of a <code class="code">__restrict__</code> member function qualifier is different to that of <code class="code">const</code> or <code class="code">volatile</code> qualifier, in that it is applied to the pointer rather than the object. This is consistent with other compilers that implement restricted pointers. </p> <p>As with all outermost parameter qualifiers, <code class="code">__restrict__</code> is ignored in function definition matching. This means you only need to specify <code class="code">__restrict__</code> in a function definition, rather than in a function prototype as well. </p> </div>  <div class="nav-panel"> <p> Next: <a href="vague-linkage.html">Vague Linkage</a>, Previous: <a href="c_002b_002b-volatiles.html">When is a Volatile C++ Object Accessed?</a>, Up: <a href="c_002b_002b-extensions.html">Extensions to the C++ Language</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Restricted-Pointers.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Restricted-Pointers.html</a>
  </p>
</div>
