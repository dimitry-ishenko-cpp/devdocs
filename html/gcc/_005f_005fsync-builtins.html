<div class="section-level-extent" id="g_t_005f_005fsync-Builtins"> <div class="nav-panel"> <p> Next: <a href="_005f_005fatomic-builtins.html" accesskey="n" rel="next">Built-in Functions for Memory Model Aware Atomic Operations</a>, Previous: <a href="offsetof.html" accesskey="p" rel="prev">Support for <code class="code">offsetof</code></a>, Up: <a href="c-extensions.html" accesskey="u" rel="up">Extensions to the C Language Family</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Legacy-_005f_005fsync-Built-in-Functions-for-Atomic-Memory-Access"><span>6.54 Legacy __sync Built-in Functions for Atomic Memory Access<a class="copiable-link" href="#Legacy-_005f_005fsync-Built-in-Functions-for-Atomic-Memory-Access"> ¶</a></span></h1> <p>The following built-in functions are intended to be compatible with those described in the Intel Itanium Processor-specific Application Binary Interface, section 7.4. As such, they depart from normal GCC practice by not using the ‘<samp class="samp">__builtin_</samp>’ prefix and also by being overloaded so that they work on multiple types. </p> <p>The definition given in the Intel documentation allows only for the use of the types <code class="code">int</code>, <code class="code">long</code>, <code class="code">long long</code> or their unsigned counterparts. GCC allows any scalar type that is 1, 2, 4 or 8 bytes in size other than the C type <code class="code">_Bool</code> or the C++ type <code class="code">bool</code>. Operations on pointer arguments are performed as if the operands were of the <code class="code">uintptr_t</code> type. That is, they are not scaled by the size of the type to which the pointer points. </p> <p>These functions are implemented in terms of the ‘<samp class="samp">__atomic</samp>’ builtins (see <a class="pxref" href="_005f_005fatomic-builtins.html">Built-in Functions for Memory Model Aware Atomic Operations</a>). They should not be used for new code which should use the ‘<samp class="samp">__atomic</samp>’ builtins instead. </p> <p>Not all operations are supported by all target processors. If a particular operation cannot be implemented on the target processor, a warning is generated and a call to an external function is generated. The external function carries the same name as the built-in version, with an additional suffix ‘<samp class="samp">_<var class="var">n</var></samp>’ where <var class="var">n</var> is the size of the data type. </p> <p>In most cases, these built-in functions are considered a <em class="dfn">full barrier</em>. That is, no memory operand is moved across the operation, either forward or backward. Further, instructions are issued as necessary to prevent the processor from speculating loads across the operation and from queuing stores after the operation. </p> <p>All of the routines are described in the Intel documentation to take “an optional list of variables protected by the memory barrier”. It’s not clear what is meant by that; it could mean that <em class="emph">only</em> the listed variables are protected, or it could mean a list of additional variables to be protected. The list is ignored by GCC which treats it as empty. GCC interprets an empty list as meaning that all globally accessible variables should be protected. </p> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005fadd">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_add</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005fadd"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005fsub">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_sub</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005fsub"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005for">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_or</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005for"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005fand">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_and</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005fand"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005fxor">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_xor</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005fxor"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005ffetch_005fand_005fnand">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_fetch_and_nand</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005ffetch_005fand_005fnand"> ¶</a></span>
</dt> <dd>
<p>These built-in functions perform the operation suggested by the name, and returns the value that had previously been in memory. That is, operations on integer operands have the following semantics. Operations on pointer arguments are performed as if the operands were of the <code class="code">uintptr_t</code> type. That is, they are not scaled by the size of the type to which the pointer points. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">{ tmp = *ptr; *ptr <var class="var">op</var>= value; return tmp; }
{ tmp = *ptr; *ptr = ~(tmp &amp; value); return tmp; }   // nand</pre>
</div> <p>The object pointed to by the first argument must be of integer or pointer type. It must not be a boolean type. </p> <p><em class="emph">Note:</em> GCC 4.4 and later implement <code class="code">__sync_fetch_and_nand</code> as <code class="code">*ptr = ~(tmp &amp; value)</code> instead of <code class="code">*ptr = ~tmp &amp; value</code>. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005fadd_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_add_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr,                                              <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fadd_005fand_005ffetch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005fsub_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_sub_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fsub_005fand_005ffetch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005for_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_or_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005for_005fand_005ffetch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005fand_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_and_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fand_005fand_005ffetch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005fxor_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_xor_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fxor_005fand_005ffetch"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005fnand_005fand_005ffetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_nand_and_fetch</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fnand_005fand_005ffetch"> ¶</a></span>
</dt> <dd>
<p>These built-in functions perform the operation suggested by the name, and return the new value. That is, operations on integer operands have the following semantics. Operations on pointer operands are performed as if the operand’s type were <code class="code">uintptr_t</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">{ *ptr <var class="var">op</var>= value; return *ptr; }
{ *ptr = ~(*ptr &amp; value); return *ptr; }   // nand</pre>
</div> <p>The same constraints on arguments apply as for the corresponding <code class="code">__sync_op_and_fetch</code> built-in functions. </p> <p><em class="emph">Note:</em> GCC 4.4 and later implement <code class="code">__sync_nand_and_fetch</code> as <code class="code">*ptr = ~(*ptr &amp; value)</code> instead of <code class="code">*ptr = ~*ptr &amp; value</code>. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005fbool_005fcompare_005fand_005fswap">
<span class="category-def">Built-in Function: </span><span><code class="def-type">bool</code> <strong class="def-name">__sync_bool_compare_and_swap</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> oldval, <var class="var">type</var> newval, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fbool_005fcompare_005fand_005fswap"> ¶</a></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fsync_005fval_005fcompare_005fand_005fswap">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_val_compare_and_swap</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> oldval, <var class="var">type</var> newval, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fval_005fcompare_005fand_005fswap"> ¶</a></span>
</dt> <dd>
<p>These built-in functions perform an atomic compare and swap. That is, if the current value of <code class="code">*<var class="var">ptr</var></code> is <var class="var">oldval</var>, then write <var class="var">newval</var> into <code class="code">*<var class="var">ptr</var></code>. </p> <p>The “bool” version returns <code class="code">true</code> if the comparison is successful and <var class="var">newval</var> is written. The “val” version returns the contents of <code class="code">*<var class="var">ptr</var></code> before the operation. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005fsynchronize">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__sync_synchronize</strong> <code class="def-code-arguments">(...)</code><a class="copiable-link" href="#index-_005f_005fsync_005fsynchronize"> ¶</a></span>
</dt> <dd><p>This built-in function issues a full memory barrier. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005flock_005ftest_005fand_005fset">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__sync_lock_test_and_set</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, <var class="var">type</var> value, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005flock_005ftest_005fand_005fset"> ¶</a></span>
</dt> <dd>
<p>This built-in function, as described by Intel, is not a traditional test-and-set operation, but rather an atomic exchange operation. It writes <var class="var">value</var> into <code class="code">*<var class="var">ptr</var></code>, and returns the previous contents of <code class="code">*<var class="var">ptr</var></code>. </p> <p>Many targets have only minimal support for such locks, and do not support a full exchange operation. In this case, a target may support reduced functionality here by which the <em class="emph">only</em> valid value to store is the immediate constant 1. The exact value actually stored in <code class="code">*<var class="var">ptr</var></code> is implementation defined. </p> <p>This built-in function is not a full barrier, but rather an <em class="dfn">acquire barrier</em>. This means that references after the operation cannot move to (or be speculated to) before the operation, but previous memory stores may not be globally visible yet, and previous memory loads may not yet be satisfied. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fsync_005flock_005frelease">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__sync_lock_release</strong> <code class="def-code-arguments">(<var class="var">type</var> *ptr, ...)</code><a class="copiable-link" href="#index-_005f_005fsync_005flock_005frelease"> ¶</a></span>
</dt> <dd>
<p>This built-in function releases the lock acquired by <code class="code">__sync_lock_test_and_set</code>. Normally this means writing the constant 0 to <code class="code">*<var class="var">ptr</var></code>. </p> <p>This built-in function is not a full barrier, but rather a <em class="dfn">release barrier</em>. This means that all previous memory stores are globally visible, and all previous memory loads have been satisfied, but following memory reads are not prevented from being speculated to before the barrier. </p>
</dd>
</dl> </div>  <div class="nav-panel"> <p> Next: <a href="_005f_005fatomic-builtins.html">Built-in Functions for Memory Model Aware Atomic Operations</a>, Previous: <a href="offsetof.html">Support for <code class="code">offsetof</code></a>, Up: <a href="c-extensions.html">Extensions to the C Language Family</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/_005f_005fsync-Builtins.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/_005f_005fsync-Builtins.html</a>
  </p>
</div>
