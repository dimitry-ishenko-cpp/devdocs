<h1 class="subsubsection" id="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1-1">6.62.26.5 PowerPC AltiVec Built-in Functions Available on ISA 3.1</h1> <div class="subsubsection-level-extent" id="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1">    <p>The following additional built-in functions are also available for the PowerPC family of processors, starting with ISA 3.1 (<samp class="option">-mcpu=power10</samp>): </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_cfuge (vector unsigned long long int, vector unsigned long long int);</pre>
</div> <p>Perform a vector centrifuge operation, as if implemented by the <code class="code">vcfuged</code> instruction.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_cntlzm (vector unsigned long long int, vector unsigned long long int);</pre>
</div> <p>Perform a vector count leading zeros under bit mask operation, as if implemented by the <code class="code">vclzdm</code> instruction.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_cnttzm (vector unsigned long long int, vector unsigned long long int);</pre>
</div> <p>Perform a vector count trailing zeros under bit mask operation, as if implemented by the <code class="code">vctzdm</code> instruction.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char</pre>
<pre class="exdent" data-language="cpp">vec_clrl (vector signed char <var class="var">a</var>, unsigned int <var class="var">n</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_clrl (vector unsigned char <var class="var">a</var>, unsigned int <var class="var">n</var>);</pre>
</div> <p>Clear the left-most <code class="code">(16 - n)</code> bytes of vector argument <code class="code">a</code>, as if implemented by the <code class="code">vclrlb</code> instruction on a big-endian target and by the <code class="code">vclrrb</code> instruction on a little-endian target. A value of <code class="code">n</code> that is greater than 16 is treated as if it equaled 16.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char</pre>
<pre class="exdent" data-language="cpp">vec_clrr (vector signed char <var class="var">a</var>, unsigned int <var class="var">n</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_clrr (vector unsigned char <var class="var">a</var>, unsigned int <var class="var">n</var>);</pre>
</div> <p>Clear the right-most <code class="code">(16 - n)</code> bytes of vector argument <code class="code">a</code>, as if implemented by the <code class="code">vclrrb</code> instruction on a big-endian target and by the <code class="code">vclrlb</code> instruction on a little-endian target. A value of <code class="code">n</code> that is greater than 16 is treated as if it equaled 16.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_gnb (vector unsigned __int128, const unsigned char);</pre>
</div> <p>Perform a 128-bit vector gather operation, as if implemented by the <code class="code">vgnb</code> instruction. The second argument must be a literal integer value between 2 and 7 inclusive.  </p> <p>Vector Extract </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extractl (vector unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extractl (vector unsigned short, vector unsigned short, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extractl (vector unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extractl (vector unsigned long long, vector unsigned long long, unsigned int);</pre>
</div> <p>Extract an element from two concatenated vectors starting at the given byte index in natural-endian order, and place it zero-extended in doubleword 1 of the result according to natural element order. If the byte index is out of range for the data type, the intrinsic will be rejected. For little-endian, this output will match the placement by the hardware instruction, i.e., dword[0] in RTL notation. For big-endian, an additional instruction is needed to move it from the "left" doubleword to the "right" one. For little-endian, semantics matching the <code class="code">vextdubvrx</code>, <code class="code">vextduhvrx</code>, <code class="code">vextduwvrx</code> instruction will be generated, while for big-endian, semantics matching the <code class="code">vextdubvlx</code>, <code class="code">vextduhvlx</code>, <code class="code">vextduwvlx</code> instructions will be generated. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the element being extracted. This is a limitation of the bi-endian vector programming model is consistent with the limitation on <code class="code">vec_perm</code>.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extracth (vector unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extracth (vector unsigned short, vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extracth (vector unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_extracth (vector unsigned long long, vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
</div> <p>Extract an element from two concatenated vectors starting at the given byte index. The index is based on big endian order for a little endian system. Similarly, the index is based on little endian order for a big endian system. The extraced elements are zero-extended and put in doubleword 1 according to natural element order. If the byte index is out of range for the data type, the intrinsic will be rejected. For little-endian, this output will match the placement by the hardware instruction (vextdubvrx, vextduhvrx, vextduwvrx, vextddvrx) i.e., dword[0] in RTL notation. For big-endian, an additional instruction is needed to move it from the "left" doubleword to the "right" one. For little-endian, semantics matching the <code class="code">vextdubvlx</code>, <code class="code">vextduhvlx</code>, <code class="code">vextduwvlx</code> instructions will be generated, while for big-endian, semantics matching the <code class="code">vextdubvrx</code>, <code class="code">vextduhvrx</code>, <code class="code">vextduwvrx</code> instructions will be generated. Note that some fairly anomalous results can be generated if the byte index is not aligned on the element boundary for the element being extracted. This is a limitation of the bi-endian vector programming model consistent with the limitation on <code class="code">vec_perm</code>.  </p>
<div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_pdep (vector unsigned long long int, vector unsigned long long int);</pre>
</div> <p>Perform a vector parallel bits deposit operation, as if implemented by the <code class="code">vpdepd</code> instruction.  </p> <p>Vector Insert </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_insertl (unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short</pre>
<pre class="exdent" data-language="cpp">vec_insertl (unsigned short, vector unsigned short, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_insertl (unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_insertl (unsigned long long, vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_insertl (vector unsigned char, vector unsigned char, unsigned int;</pre>
<pre class="exdent" data-language="cpp">vector unsigned short</pre>
<pre class="exdent" data-language="cpp">vec_insertl (vector unsigned short, vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_insertl (vector unsigned int, vector unsigned int, unsigned int);</pre>
</div> <p>Let src be the first argument, when the first argument is a scalar, or the rightmost element of the left doubleword of the first argument, when the first argument is a vector. Insert the source into the destination at the position given by the third argument, using natural element order in the second argument. The rest of the second argument is unchanged. If the byte index is greater than 14 for halfwords, greater than 12 for words, or greater than 8 for doublewords the result is undefined. For little-endian, the generated code will be semantically equivalent to <code class="code">vins[bhwd]rx</code> instructions. Similarly for big-endian it will be semantically equivalent to <code class="code">vins[bhwd]lx</code>. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the type of element being inserted.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_inserth (unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short</pre>
<pre class="exdent" data-language="cpp">vec_inserth (unsigned short, vector unsigned short, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_inserth (unsigned int, vector unsigned int, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_inserth (unsigned long long, vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_inserth (vector unsigned char, vector unsigned char, unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short</pre>
<pre class="exdent" data-language="cpp">vec_inserth (vector unsigned short, vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_inserth (vector unsigned int, vector unsigned int, unsigned int);</pre>
</div> <p>Let src be the first argument, when the first argument is a scalar, or the rightmost element of the first argument, when the first argument is a vector. Insert src into the second argument at the position identified by the third argument, using opposite element order in the second argument, and leaving the rest of the second argument unchanged. If the byte index is greater than 14 for halfwords, 12 for words, or 8 for doublewords, the intrinsic will be rejected. Note that the underlying hardware instruction uses the same register for the second argument and the result. For little-endian, the code generation will be semantically equivalent to <code class="code">vins[bhwd]lx</code>, while for big-endian it will be semantically equivalent to <code class="code">vins[bhwd]rx</code>. Note that some fairly anomalous results can be generated if the byte index is not aligned on an element boundary for the sort of element being inserted.  </p> <p>Vector Replace Element </p>
<div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int vec_replace_elt (vector signed int, signed int,</pre>
<pre class="example-preformatted" data-language="cpp">const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_replace_elt (vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int, const int);</pre>
<pre class="exdent" data-language="cpp">vector float vec_replace_elt (vector float, float, const int);</pre>
<pre class="exdent" data-language="cpp">vector signed long long vec_replace_elt (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">signed long long, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long vec_replace_elt (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned long long, const int);</pre>
<pre class="exdent" data-language="cpp">vector double rec_replace_elt (vector double, double, const int);</pre>
</div> <p>The third argument (constrained to [0,3]) identifies the natural-endian element number of the first argument that will be replaced by the second argument to produce the result. The other elements of the first argument will remain unchanged in the result. </p> <p>If it’s desirable to insert a word at an unaligned position, use vec_replace_unaligned instead. </p>  <p>Vector Replace Unaligned </p>
<div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">signed int, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned int, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">float, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">signed long long, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">unsigned long long, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_replace_unaligned (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">double, const int);</pre>
</div> <p>The second argument replaces a portion of the first argument to produce the result, with the rest of the first argument unchanged in the result. The third argument identifies the byte index (using left-to-right, or big-endian order) where the high-order byte of the second argument will be placed, with the remaining bytes of the second argument placed naturally "to the right" of the high-order byte. </p> <p>The programmer is responsible for understanding the endianness issues involved with the first argument and the result.  </p> <p>Vector Shift Left Double Bit Immediate </p>
<div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char vec_sldb (vector signed char, vector signed char,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_sldb (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_sldb (vector signed short, vector signed short,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_sldb (vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned short, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed int vec_sldb (vector signed int, vector signed int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_sldb (vector unsigned int, vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed long long vec_sldb (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long vec_sldb (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long, const unsigned int);</pre>
</div> <p>Shift the combined input vectors left by the amount specified by the low-order three bits of the third argument, and return the leftmost remaining 128 bits. Code using this instruction must be endian-aware. </p>  <p>Vector Shift Right Double Bit Immediate </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char vec_srdb (vector signed char, vector signed char,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_srdb (vector unsigned char, vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_srdb (vector signed short, vector signed short,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_srdb (vector unsigned short, vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed int vec_srdb (vector signed int, vector signed int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_srdb (vector unsigned int, vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed long long vec_srdb (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long vec_srdb (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long, const unsigned int);</pre>
</div> <p>Shift the combined input vectors right by the amount specified by the low-order three bits of the third argument, and return the remaining 128 bits. Code using this built-in must be endian-aware. </p>  <p>Vector Splat </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int vec_splati (const signed int);</pre>
<pre class="exdent" data-language="cpp">vector float vec_splati (const float);</pre>
</div> <p>Splat a 32-bit immediate into a vector of words. </p>  <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector double vec_splatid (const float);</pre>
</div> <p>Convert a single precision floating-point value to double-precision and splat the result to a vector of double-precision floats. </p>  <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int vec_splati_ins (vector signed int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int, const signed int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_splati_ins (vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">const unsigned int, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector float vec_splati_ins (vector float, const unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">const float);</pre>
</div> <p>Argument 2 must be either 0 or 1. Splat the value of argument 3 into the word identified by argument 2 of each doubleword of argument 1 and return the result. The other words of argument 1 are unchanged. </p>  <p>Vector Blend Variable </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char vec_blendv (vector signed char, vector signed char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_blendv (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_blendv (vector signed short,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed short, vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_blendv (vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned short, vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">vector signed int vec_blendv (vector signed int, vector signed int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_blendv (vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned int, vector unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector signed long long vec_blendv (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long, vector unsigned long long);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long vec_blendv (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long, vector unsigned long long);</pre>
<pre class="exdent" data-language="cpp">vector float vec_blendv (vector float, vector float,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector double vec_blendv (vector double, vector double,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long);</pre>
</div> <p>Blend the first and second argument vectors according to the sign bits of the corresponding elements of the third argument vector. This is similar to the <code class="code">vsel</code> and <code class="code">xxsel</code> instructions but for bigger elements. </p>  <p>Vector Permute Extended </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed char vec_permx (vector signed char, vector signed char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned char vec_permx (vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_permx (vector signed short,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed short, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_permx (vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned short, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector signed int vec_permx (vector signed int, vector signed int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_permx (vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned int, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector signed long long vec_permx (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long vec_permx (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long, vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector float (vector float, vector float, vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">const int);</pre>
<pre class="exdent" data-language="cpp">vector double (vector double, vector double, vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">const int);</pre>
</div> <p>Perform a partial permute of the first two arguments, which form a 32-byte section of an emulated vector up to 256 bytes wide, using the partial permute control vector in the third argument. The fourth argument (constrained to values of 0-7) identifies which 32-byte section of the emulated vector is contained in the first two arguments.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_pext (vector unsigned long long int, vector unsigned long long int);</pre>
</div> <p>Perform a vector parallel bit extract operation, as if implemented by the <code class="code">vpextd</code> instruction.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char vec_stril (vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">vector signed char vec_stril (vector signed char);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_stril (vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_stril (vector signed short);</pre>
</div> <p>Isolate the left-most non-zero elements of the incoming vector argument, replacing all elements to the right of the left-most zero element found within the argument with zero. The typical implementation uses the <code class="code">vstribl</code> or <code class="code">vstrihl</code> instruction on big-endian targets and uses the <code class="code">vstribr</code> or <code class="code">vstrihr</code> instruction on little-endian targets.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">int vec_stril_p (vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">int vec_stril_p (vector signed char);</pre>
<pre class="exdent" data-language="cpp">int short vec_stril_p (vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">int vec_stril_p (vector signed short);</pre>
</div> <p>Return a non-zero value if and only if the argument contains a zero element. The typical implementation uses the <code class="code">vstribl.</code> or <code class="code">vstrihl.</code> instruction on big-endian targets and uses the <code class="code">vstribr.</code> or <code class="code">vstrihr.</code> instruction on little-endian targets. Choose this built-in to check for presence of zero element if the same argument is also passed to <code class="code">vec_stril</code>.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char vec_strir (vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">vector signed char vec_strir (vector signed char);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_strir (vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">vector signed short vec_strir (vector signed short);</pre>
</div> <p>Isolate the right-most non-zero elements of the incoming vector argument, replacing all elements to the left of the right-most zero element found within the argument with zero. The typical implementation uses the <code class="code">vstribr</code> or <code class="code">vstrihr</code> instruction on big-endian targets and uses the <code class="code">vstribl</code> or <code class="code">vstrihl</code> instruction on little-endian targets.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">int vec_strir_p (vector unsigned char);</pre>
<pre class="exdent" data-language="cpp">int vec_strir_p (vector signed char);</pre>
<pre class="exdent" data-language="cpp">int short vec_strir_p (vector unsigned short);</pre>
<pre class="exdent" data-language="cpp">int vec_strir_p (vector signed short);</pre>
</div> <p>Return a non-zero value if and only if the argument contains a zero element. The typical implementation uses the <code class="code">vstribr.</code> or <code class="code">vstrihr.</code> instruction on big-endian targets and uses the <code class="code">vstribl.</code> or <code class="code">vstrihl.</code> instruction on little-endian targets. Choose this built-in to check for presence of zero element if the same argument is also passed to <code class="code">vec_strir</code>.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char</pre>
<pre class="exdent" data-language="cpp">vec_ternarylogic (vector unsigned char, vector unsigned char,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned char, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short</pre>
<pre class="exdent" data-language="cpp">vec_ternarylogic (vector unsigned short, vector unsigned short,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned short, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_ternarylogic (vector unsigned int, vector unsigned int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned int, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long int</pre>
<pre class="exdent" data-language="cpp">vec_ternarylogic (vector unsigned long long int, vector unsigned long long int,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long int, const unsigned int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned __int128</pre>
<pre class="exdent" data-language="cpp">vec_ternarylogic (vector unsigned __int128, vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128, const unsigned int);</pre>
</div> <p>Perform a 128-bit vector evaluate operation, as if implemented by the <code class="code">xxeval</code> instruction. The fourth argument must be a literal integer value between 0 and 255 inclusive.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned char vec_genpcvm (vector unsigned char, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned short vec_genpcvm (vector unsigned short, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_genpcvm (vector unsigned int, const int);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int vec_genpcvm (vector unsigned long long int,</pre>
<pre class="example-preformatted" data-language="cpp">const int);</pre>
</div> <p>Vector Integer Multiply/Divide/Modulo </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int</pre>
<pre class="exdent" data-language="cpp">vec_mulh (vector signed int <var class="var">a</var>, vector signed int <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_mulh (vector unsigned int <var class="var">a</var>, vector unsigned int <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 3, do the following. The integer value in word element <code class="code">i</code> of a is multiplied by the integer value in word element <code class="code">i</code> of b. The high-order 32 bits of the 64-bit product are placed into word element <code class="code">i</code> of the vector returned. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed long long</pre>
<pre class="exdent" data-language="cpp">vec_mulh (vector signed long long <var class="var">a</var>, vector signed long long <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_mulh (vector unsigned long long <var class="var">a</var>, vector unsigned long long <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 1, do the following. The integer value in doubleword element <code class="code">i</code> of a is multiplied by the integer value in doubleword element <code class="code">i</code> of b. The high-order 64 bits of the 128-bit product are placed into doubleword element <code class="code">i</code> of the vector returned. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_mul (vector unsigned long long <var class="var">a</var>, vector unsigned long long <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector signed long long</pre>
<pre class="exdent" data-language="cpp">vec_mul (vector signed long long <var class="var">a</var>, vector signed long long <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 1, do the following. The integer value in doubleword element <code class="code">i</code> of a is multiplied by the integer value in doubleword element <code class="code">i</code> of b. The low-order 64 bits of the 128-bit product are placed into doubleword element <code class="code">i</code> of the vector returned. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int</pre>
<pre class="exdent" data-language="cpp">vec_div (vector signed int <var class="var">a</var>, vector signed int <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_div (vector unsigned int <var class="var">a</var>, vector unsigned int <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 3, do the following. The integer in word element <code class="code">i</code> of a is divided by the integer in word element <code class="code">i</code> of b. The unique integer quotient is placed into the word element <code class="code">i</code> of the vector returned. If an attempt is made to perform any of the divisions &lt;anything&gt; ÷ 0 then the quotient is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed long long</pre>
<pre class="exdent" data-language="cpp">vec_div (vector signed long long <var class="var">a</var>, vector signed long long <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_div (vector unsigned long long <var class="var">a</var>, vector unsigned long long <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 1, do the following. The integer in doubleword element <code class="code">i</code> of a is divided by the integer in doubleword element <code class="code">i</code> of b. The unique integer quotient is placed into the doubleword element <code class="code">i</code> of the vector returned. If an attempt is made to perform any of the divisions 0x8000_0000_0000_0000 ÷ -1 or &lt;anything&gt; ÷ 0 then the quotient is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int</pre>
<pre class="exdent" data-language="cpp">vec_dive (vector signed int <var class="var">a</var>, vector signed int <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_dive (vector unsigned int <var class="var">a</var>, vector unsigned int <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 3, do the following. The integer in word element <code class="code">i</code> of a is shifted left by 32 bits, then divided by the integer in word element <code class="code">i</code> of b. The unique integer quotient is placed into the word element <code class="code">i</code> of the vector returned. If the quotient cannot be represented in 32 bits, or if an attempt is made to perform any of the divisions &lt;anything&gt; ÷ 0 then the quotient is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed long long</pre>
<pre class="exdent" data-language="cpp">vec_dive (vector signed long long <var class="var">a</var>, vector signed long long <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_dive (vector unsigned long long <var class="var">a</var>, vector unsigned long long <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 1, do the following. The integer in doubleword element <code class="code">i</code> of a is shifted left by 64 bits, then divided by the integer in doubleword element <code class="code">i</code> of b. The unique integer quotient is placed into the doubleword element <code class="code">i</code> of the vector returned. If the quotient cannot be represented in 64 bits, or if an attempt is made to perform &lt;anything&gt; ÷ 0 then the quotient is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed int</pre>
<pre class="exdent" data-language="cpp">vec_mod (vector signed int <var class="var">a</var>, vector signed int <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned int</pre>
<pre class="exdent" data-language="cpp">vec_mod (vector unsigned int <var class="var">a</var>, vector unsigned int <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 3, do the following. The integer in word element <code class="code">i</code> of a is divided by the integer in word element <code class="code">i</code> of b. The unique integer remainder is placed into the word element <code class="code">i</code> of the vector returned. If an attempt is made to perform any of the divisions 0x8000_0000 ÷ -1 or &lt;anything&gt; ÷ 0 then the remainder is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector signed long long</pre>
<pre class="exdent" data-language="cpp">vec_mod (vector signed long long <var class="var">a</var>, vector signed long long <var class="var">b</var>);</pre>
<pre class="exdent" data-language="cpp">vector unsigned long long</pre>
<pre class="exdent" data-language="cpp">vec_mod (vector unsigned long long <var class="var">a</var>, vector unsigned long long <var class="var">b</var>);</pre>
</div> <p>For each integer value <code class="code">i</code> from 0 to 1, do the following. The integer in doubleword element <code class="code">i</code> of a is divided by the integer in doubleword element <code class="code">i</code> of b. The unique integer remainder is placed into the doubleword element <code class="code">i</code> of the vector returned. If an attempt is made to perform &lt;anything&gt; ÷ 0 then the remainder is undefined. </p> <p>Generate PCV from specified Mask size, as if implemented by the <code class="code">xxgenpcvbm</code>, <code class="code">xxgenpcvhm</code>, <code class="code">xxgenpcvwm</code> instructions, where immediate value is either 0, 1, 2 or 3.  </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_rl (vector unsigned __int128 <var class="var">A</var>,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128 <var class="var">B</var>);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_rl (vector signed __int128 <var class="var">A</var>,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128 <var class="var">B</var>);</pre>
</div> <p>Result value: Each element of <var class="var">R</var> is obtained by rotating the corresponding element of <var class="var">A</var> left by the number of bits specified by the corresponding element of <var class="var">B</var>. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_rlmi (vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128,
vector unsigned __int128);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_rlmi (vector signed __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed __int128,
vector unsigned __int128);</pre>
</div> <p>Returns the result of rotating the first input and inserting it under mask into the second input. The first bit in the mask, the last bit in the mask are obtained from the two 7-bit fields bits [108:115] and bits [117:123] respectively of the second input. The shift is obtained from the third input in the 7-bit field [125:131] where all bits counted from zero at the left. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_rlnm (vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128,
vector unsigned __int128);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_rlnm (vector signed __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128,
vector unsigned __int128);</pre>
</div> <p>Returns the result of rotating the first input and ANDing it with a mask. The first bit in the mask and the last bit in the mask are obtained from the two 7-bit fields bits [117:123] and bits [125:131] respectively of the second input. The shift is obtained from the third input in the 7-bit field bits [125:131] where all bits counted from zero at the left. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_sl(vector unsigned __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_sl(vector signed __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
</div> <p>Result value: Each element of <var class="var">R</var> is obtained by shifting the corresponding element of <var class="var">A</var> left by the number of bits specified by the corresponding element of <var class="var">B</var>. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_sr(vector unsigned __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_sr(vector signed __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
</div> <p>Result value: Each element of <var class="var">R</var> is obtained by shifting the corresponding element of <var class="var">A</var> right by the number of bits specified by the corresponding element of <var class="var">B</var>. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_sra(vector unsigned __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_sra(vector signed __int128 <var class="var">A</var>, vector unsigned __int128 <var class="var">B</var>);</pre>
</div> <p>Result value: Each element of <var class="var">R</var> is obtained by arithmetic shifting the corresponding element of <var class="var">A</var> right by the number of bits specified by the corresponding element of <var class="var">B</var>. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_mule (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_mule (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long);</pre>
</div> <p>Returns a vector containing a 128-bit integer result of multiplying the even doubleword elements of the two inputs. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_mulo (vector unsigned long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned long long);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_mulo (vector signed long long,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed long long);</pre>
</div> <p>Returns a vector containing a 128-bit integer result of multiplying the odd doubleword elements of the two inputs. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_div (vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_div (vector signed __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed __int128);</pre>
</div> <p>Returns the result of dividing the first operand by the second operand. An attempt to divide any value by zero or to divide the most negative signed 128-bit integer by negative one results in an undefined value. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_dive (vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_dive (vector signed __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed __int128);</pre>
</div> <p>The result is produced by shifting the first input left by 128 bits and dividing by the second. If an attempt is made to divide by zero or the result is larger than 128 bits, the result is undefined. </p> <div class="example smallexample"> <pre class="exdent" data-language="cpp">vector unsigned __int128 vec_mod (vector unsigned __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector unsigned __int128);</pre>
<pre class="exdent" data-language="cpp">vector signed __int128 vec_mod (vector signed __int128,</pre>
<pre class="example-preformatted" data-language="cpp">vector signed __int128);</pre>
</div> <p>The result is the modulo result of dividing the first input by the second input. </p> <p>The following builtins perform 128-bit vector comparisons. The <code class="code">vec_all_xx</code>, <code class="code">vec_any_xx</code>, and <code class="code">vec_cmpxx</code>, where <code class="code">xx</code> is one of the operations <code class="code">eq, ne, gt, lt, ge, le</code> perform pairwise comparisons between the elements at the same positions within their two vector arguments. The <code class="code">vec_all_xx</code>function returns a non-zero value if and only if all pairwise comparisons are true. The <code class="code">vec_any_xx</code> function returns a non-zero value if and only if at least one pairwise comparison is true. The <code class="code">vec_cmpxx</code>function returns a vector of the same type as its two arguments, within which each element consists of all ones to denote that specified logical comparison of the corresponding elements was true. Otherwise, the element of the returned vector contains all zeros. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">vector bool __int128 vec_cmpeq (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpeq (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpne (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpne (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpgt (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpgt (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmplt (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmplt (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmpge (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmpge (vector unsigned __int128, vector unsigned __int128);
vector bool __int128 vec_cmple (vector signed __int128, vector signed __int128);
vector bool __int128 vec_cmple (vector unsigned __int128, vector unsigned __int128);

int vec_all_eq (vector signed __int128, vector signed __int128);
int vec_all_eq (vector unsigned __int128, vector unsigned __int128);
int vec_all_ne (vector signed __int128, vector signed __int128);
int vec_all_ne (vector unsigned __int128, vector unsigned __int128);
int vec_all_gt (vector signed __int128, vector signed __int128);
int vec_all_gt (vector unsigned __int128, vector unsigned __int128);
int vec_all_lt (vector signed __int128, vector signed __int128);
int vec_all_lt (vector unsigned __int128, vector unsigned __int128);
int vec_all_ge (vector signed __int128, vector signed __int128);
int vec_all_ge (vector unsigned __int128, vector unsigned __int128);
int vec_all_le (vector signed __int128, vector signed __int128);
int vec_all_le (vector unsigned __int128, vector unsigned __int128);

int vec_any_eq (vector signed __int128, vector signed __int128);
int vec_any_eq (vector unsigned __int128, vector unsigned __int128);
int vec_any_ne (vector signed __int128, vector signed __int128);
int vec_any_ne (vector unsigned __int128, vector unsigned __int128);
int vec_any_gt (vector signed __int128, vector signed __int128);
int vec_any_gt (vector unsigned __int128, vector unsigned __int128);
int vec_any_lt (vector signed __int128, vector signed __int128);
int vec_any_lt (vector unsigned __int128, vector unsigned __int128);
int vec_any_ge (vector signed __int128, vector signed __int128);
int vec_any_ge (vector unsigned __int128, vector unsigned __int128);
int vec_any_le (vector signed __int128, vector signed __int128);
int vec_any_le (vector unsigned __int128, vector unsigned __int128);</pre>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1.html</a>
  </p>
</div>
