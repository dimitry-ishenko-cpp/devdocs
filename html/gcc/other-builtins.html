<h1 class="section" id="Other-Built_002din-Functions-Provided-by-GCC">6.61 Other Built-in Functions Provided by GCC</h1> <div class="section-level-extent" id="Other-Builtins">                                                                                                                                                                                                                                                                                                                                                                                                             <p>GCC provides a large number of built-in functions other than the ones mentioned above. Some of these are for internal use in the processing of exceptions or variable-length argument lists and are not documented here because they may change from time to time; we do not recommend general use of these functions. </p> <p>The remaining functions are provided for optimization purposes. </p> <p>With the exception of built-ins that have library equivalents such as the standard C library functions discussed below, or that expand to library calls, GCC built-in functions are always expanded inline and thus do not have corresponding entry points and their address cannot be obtained. Attempting to use them in an expression other than a function call results in a compile-time error. </p>  <p>GCC includes built-in versions of many of the functions in the standard C library. These functions come in two forms: one whose names start with the <code class="code">__builtin_</code> prefix, and the other without. Both forms have the same type (including prototype), the same address (when their address is taken), and the same meaning as the C library functions even if you specify the <samp class="option">-fno-builtin</samp> option see <a class="pxref" href="c-dialect-options.html">Options Controlling C Dialect</a>). Many of these functions are only optimized in certain cases; if they are not optimized in a particular case, a call to the library function is emitted. </p>   <p>Outside strict ISO C mode (<samp class="option">-ansi</samp>, <samp class="option">-std=c90</samp>, <samp class="option">-std=c99</samp> or <samp class="option">-std=c11</samp>), the functions <code class="code">_exit</code>, <code class="code">alloca</code>, <code class="code">bcmp</code>, <code class="code">bzero</code>, <code class="code">dcgettext</code>, <code class="code">dgettext</code>, <code class="code">dremf</code>, <code class="code">dreml</code>, <code class="code">drem</code>, <code class="code">exp10f</code>, <code class="code">exp10l</code>, <code class="code">exp10</code>, <code class="code">ffsll</code>, <code class="code">ffsl</code>, <code class="code">ffs</code>, <code class="code">fprintf_unlocked</code>, <code class="code">fputs_unlocked</code>, <code class="code">gammaf</code>, <code class="code">gammal</code>, <code class="code">gamma</code>, <code class="code">gammaf_r</code>, <code class="code">gammal_r</code>, <code class="code">gamma_r</code>, <code class="code">gettext</code>, <code class="code">index</code>, <code class="code">isascii</code>, <code class="code">j0f</code>, <code class="code">j0l</code>, <code class="code">j0</code>, <code class="code">j1f</code>, <code class="code">j1l</code>, <code class="code">j1</code>, <code class="code">jnf</code>, <code class="code">jnl</code>, <code class="code">jn</code>, <code class="code">lgammaf_r</code>, <code class="code">lgammal_r</code>, <code class="code">lgamma_r</code>, <code class="code">mempcpy</code>, <code class="code">pow10f</code>, <code class="code">pow10l</code>, <code class="code">pow10</code>, <code class="code">printf_unlocked</code>, <code class="code">rindex</code>, <code class="code">roundeven</code>, <code class="code">roundevenf</code>, <code class="code">roundevenl</code>, <code class="code">scalbf</code>, <code class="code">scalbl</code>, <code class="code">scalb</code>, <code class="code">signbit</code>, <code class="code">signbitf</code>, <code class="code">signbitl</code>, <code class="code">signbitd32</code>, <code class="code">signbitd64</code>, <code class="code">signbitd128</code>, <code class="code">significandf</code>, <code class="code">significandl</code>, <code class="code">significand</code>, <code class="code">sincosf</code>, <code class="code">sincosl</code>, <code class="code">sincos</code>, <code class="code">stpcpy</code>, <code class="code">stpncpy</code>, <code class="code">strcasecmp</code>, <code class="code">strdup</code>, <code class="code">strfmon</code>, <code class="code">strncasecmp</code>, <code class="code">strndup</code>, <code class="code">strnlen</code>, <code class="code">toascii</code>, <code class="code">y0f</code>, <code class="code">y0l</code>, <code class="code">y0</code>, <code class="code">y1f</code>, <code class="code">y1l</code>, <code class="code">y1</code>, <code class="code">ynf</code>, <code class="code">ynl</code> and <code class="code">yn</code> may be handled as built-in functions. All these functions have corresponding versions prefixed with <code class="code">__builtin_</code>, which may be used even in strict C90 mode. </p> <p>The ISO C99 functions <code class="code">_Exit</code>, <code class="code">acoshf</code>, <code class="code">acoshl</code>, <code class="code">acosh</code>, <code class="code">asinhf</code>, <code class="code">asinhl</code>, <code class="code">asinh</code>, <code class="code">atanhf</code>, <code class="code">atanhl</code>, <code class="code">atanh</code>, <code class="code">cabsf</code>, <code class="code">cabsl</code>, <code class="code">cabs</code>, <code class="code">cacosf</code>, <code class="code">cacoshf</code>, <code class="code">cacoshl</code>, <code class="code">cacosh</code>, <code class="code">cacosl</code>, <code class="code">cacos</code>, <code class="code">cargf</code>, <code class="code">cargl</code>, <code class="code">carg</code>, <code class="code">casinf</code>, <code class="code">casinhf</code>, <code class="code">casinhl</code>, <code class="code">casinh</code>, <code class="code">casinl</code>, <code class="code">casin</code>, <code class="code">catanf</code>, <code class="code">catanhf</code>, <code class="code">catanhl</code>, <code class="code">catanh</code>, <code class="code">catanl</code>, <code class="code">catan</code>, <code class="code">cbrtf</code>, <code class="code">cbrtl</code>, <code class="code">cbrt</code>, <code class="code">ccosf</code>, <code class="code">ccoshf</code>, <code class="code">ccoshl</code>, <code class="code">ccosh</code>, <code class="code">ccosl</code>, <code class="code">ccos</code>, <code class="code">cexpf</code>, <code class="code">cexpl</code>, <code class="code">cexp</code>, <code class="code">cimagf</code>, <code class="code">cimagl</code>, <code class="code">cimag</code>, <code class="code">clogf</code>, <code class="code">clogl</code>, <code class="code">clog</code>, <code class="code">conjf</code>, <code class="code">conjl</code>, <code class="code">conj</code>, <code class="code">copysignf</code>, <code class="code">copysignl</code>, <code class="code">copysign</code>, <code class="code">cpowf</code>, <code class="code">cpowl</code>, <code class="code">cpow</code>, <code class="code">cprojf</code>, <code class="code">cprojl</code>, <code class="code">cproj</code>, <code class="code">crealf</code>, <code class="code">creall</code>, <code class="code">creal</code>, <code class="code">csinf</code>, <code class="code">csinhf</code>, <code class="code">csinhl</code>, <code class="code">csinh</code>, <code class="code">csinl</code>, <code class="code">csin</code>, <code class="code">csqrtf</code>, <code class="code">csqrtl</code>, <code class="code">csqrt</code>, <code class="code">ctanf</code>, <code class="code">ctanhf</code>, <code class="code">ctanhl</code>, <code class="code">ctanh</code>, <code class="code">ctanl</code>, <code class="code">ctan</code>, <code class="code">erfcf</code>, <code class="code">erfcl</code>, <code class="code">erfc</code>, <code class="code">erff</code>, <code class="code">erfl</code>, <code class="code">erf</code>, <code class="code">exp2f</code>, <code class="code">exp2l</code>, <code class="code">exp2</code>, <code class="code">expm1f</code>, <code class="code">expm1l</code>, <code class="code">expm1</code>, <code class="code">fdimf</code>, <code class="code">fdiml</code>, <code class="code">fdim</code>, <code class="code">fmaf</code>, <code class="code">fmal</code>, <code class="code">fmaxf</code>, <code class="code">fmaxl</code>, <code class="code">fmax</code>, <code class="code">fma</code>, <code class="code">fminf</code>, <code class="code">fminl</code>, <code class="code">fmin</code>, <code class="code">hypotf</code>, <code class="code">hypotl</code>, <code class="code">hypot</code>, <code class="code">ilogbf</code>, <code class="code">ilogbl</code>, <code class="code">ilogb</code>, <code class="code">imaxabs</code>, <code class="code">isblank</code>, <code class="code">iswblank</code>, <code class="code">lgammaf</code>, <code class="code">lgammal</code>, <code class="code">lgamma</code>, <code class="code">llabs</code>, <code class="code">llrintf</code>, <code class="code">llrintl</code>, <code class="code">llrint</code>, <code class="code">llroundf</code>, <code class="code">llroundl</code>, <code class="code">llround</code>, <code class="code">log1pf</code>, <code class="code">log1pl</code>, <code class="code">log1p</code>, <code class="code">log2f</code>, <code class="code">log2l</code>, <code class="code">log2</code>, <code class="code">logbf</code>, <code class="code">logbl</code>, <code class="code">logb</code>, <code class="code">lrintf</code>, <code class="code">lrintl</code>, <code class="code">lrint</code>, <code class="code">lroundf</code>, <code class="code">lroundl</code>, <code class="code">lround</code>, <code class="code">nearbyintf</code>, <code class="code">nearbyintl</code>, <code class="code">nearbyint</code>, <code class="code">nextafterf</code>, <code class="code">nextafterl</code>, <code class="code">nextafter</code>, <code class="code">nexttowardf</code>, <code class="code">nexttowardl</code>, <code class="code">nexttoward</code>, <code class="code">remainderf</code>, <code class="code">remainderl</code>, <code class="code">remainder</code>, <code class="code">remquof</code>, <code class="code">remquol</code>, <code class="code">remquo</code>, <code class="code">rintf</code>, <code class="code">rintl</code>, <code class="code">rint</code>, <code class="code">roundf</code>, <code class="code">roundl</code>, <code class="code">round</code>, <code class="code">scalblnf</code>, <code class="code">scalblnl</code>, <code class="code">scalbln</code>, <code class="code">scalbnf</code>, <code class="code">scalbnl</code>, <code class="code">scalbn</code>, <code class="code">snprintf</code>, <code class="code">tgammaf</code>, <code class="code">tgammal</code>, <code class="code">tgamma</code>, <code class="code">truncf</code>, <code class="code">truncl</code>, <code class="code">trunc</code>, <code class="code">vfscanf</code>, <code class="code">vscanf</code>, <code class="code">vsnprintf</code> and <code class="code">vsscanf</code> are handled as built-in functions except in strict ISO C90 mode (<samp class="option">-ansi</samp> or <samp class="option">-std=c90</samp>). </p> <p>There are also built-in versions of the ISO C99 functions <code class="code">acosf</code>, <code class="code">acosl</code>, <code class="code">asinf</code>, <code class="code">asinl</code>, <code class="code">atan2f</code>, <code class="code">atan2l</code>, <code class="code">atanf</code>, <code class="code">atanl</code>, <code class="code">ceilf</code>, <code class="code">ceill</code>, <code class="code">cosf</code>, <code class="code">coshf</code>, <code class="code">coshl</code>, <code class="code">cosl</code>, <code class="code">expf</code>, <code class="code">expl</code>, <code class="code">fabsf</code>, <code class="code">fabsl</code>, <code class="code">floorf</code>, <code class="code">floorl</code>, <code class="code">fmodf</code>, <code class="code">fmodl</code>, <code class="code">frexpf</code>, <code class="code">frexpl</code>, <code class="code">ldexpf</code>, <code class="code">ldexpl</code>, <code class="code">log10f</code>, <code class="code">log10l</code>, <code class="code">logf</code>, <code class="code">logl</code>, <code class="code">modfl</code>, <code class="code">modff</code>, <code class="code">powf</code>, <code class="code">powl</code>, <code class="code">sinf</code>, <code class="code">sinhf</code>, <code class="code">sinhl</code>, <code class="code">sinl</code>, <code class="code">sqrtf</code>, <code class="code">sqrtl</code>, <code class="code">tanf</code>, <code class="code">tanhf</code>, <code class="code">tanhl</code> and <code class="code">tanl</code> that are recognized in any mode since ISO C90 reserves these names for the purpose to which ISO C99 puts them. All these functions have corresponding versions prefixed with <code class="code">__builtin_</code>. </p> <p>There are also built-in functions <code class="code">__builtin_fabsf<var class="var">n</var></code>, <code class="code">__builtin_fabsf<var class="var">n</var>x</code>, <code class="code">__builtin_copysignf<var class="var">n</var></code> and <code class="code">__builtin_copysignf<var class="var">n</var>x</code>, corresponding to the TS 18661-3 functions <code class="code">fabsf<var class="var">n</var></code>, <code class="code">fabsf<var class="var">n</var>x</code>, <code class="code">copysignf<var class="var">n</var></code> and <code class="code">copysignf<var class="var">n</var>x</code>, for supported types <code class="code">_Float<var class="var">n</var></code> and <code class="code">_Float<var class="var">n</var>x</code>. </p> <p>There are also GNU extension functions <code class="code">clog10</code>, <code class="code">clog10f</code> and <code class="code">clog10l</code> which names are reserved by ISO C99 for future use. All these functions have versions prefixed with <code class="code">__builtin_</code>. </p> <p>The ISO C94 functions <code class="code">iswalnum</code>, <code class="code">iswalpha</code>, <code class="code">iswcntrl</code>, <code class="code">iswdigit</code>, <code class="code">iswgraph</code>, <code class="code">iswlower</code>, <code class="code">iswprint</code>, <code class="code">iswpunct</code>, <code class="code">iswspace</code>, <code class="code">iswupper</code>, <code class="code">iswxdigit</code>, <code class="code">towlower</code> and <code class="code">towupper</code> are handled as built-in functions except in strict ISO C90 mode (<samp class="option">-ansi</samp> or <samp class="option">-std=c90</samp>). </p> <p>The ISO C90 functions <code class="code">abort</code>, <code class="code">abs</code>, <code class="code">acos</code>, <code class="code">asin</code>, <code class="code">atan2</code>, <code class="code">atan</code>, <code class="code">calloc</code>, <code class="code">ceil</code>, <code class="code">cosh</code>, <code class="code">cos</code>, <code class="code">exit</code>, <code class="code">exp</code>, <code class="code">fabs</code>, <code class="code">floor</code>, <code class="code">fmod</code>, <code class="code">fprintf</code>, <code class="code">fputs</code>, <code class="code">free</code>, <code class="code">frexp</code>, <code class="code">fscanf</code>, <code class="code">isalnum</code>, <code class="code">isalpha</code>, <code class="code">iscntrl</code>, <code class="code">isdigit</code>, <code class="code">isgraph</code>, <code class="code">islower</code>, <code class="code">isprint</code>, <code class="code">ispunct</code>, <code class="code">isspace</code>, <code class="code">isupper</code>, <code class="code">isxdigit</code>, <code class="code">tolower</code>, <code class="code">toupper</code>, <code class="code">labs</code>, <code class="code">ldexp</code>, <code class="code">log10</code>, <code class="code">log</code>, <code class="code">malloc</code>, <code class="code">memchr</code>, <code class="code">memcmp</code>, <code class="code">memcpy</code>, <code class="code">memset</code>, <code class="code">modf</code>, <code class="code">pow</code>, <code class="code">printf</code>, <code class="code">putchar</code>, <code class="code">puts</code>, <code class="code">realloc</code>, <code class="code">scanf</code>, <code class="code">sinh</code>, <code class="code">sin</code>, <code class="code">snprintf</code>, <code class="code">sprintf</code>, <code class="code">sqrt</code>, <code class="code">sscanf</code>, <code class="code">strcat</code>, <code class="code">strchr</code>, <code class="code">strcmp</code>, <code class="code">strcpy</code>, <code class="code">strcspn</code>, <code class="code">strlen</code>, <code class="code">strncat</code>, <code class="code">strncmp</code>, <code class="code">strncpy</code>, <code class="code">strpbrk</code>, <code class="code">strrchr</code>, <code class="code">strspn</code>, <code class="code">strstr</code>, <code class="code">tanh</code>, <code class="code">tan</code>, <code class="code">vfprintf</code>, <code class="code">vprintf</code> and <code class="code">vsprintf</code> are all recognized as built-in functions unless <samp class="option">-fno-builtin</samp> is specified (or <samp class="option">-fno-builtin-<var class="var">function</var></samp> is specified for an individual function). All of these functions have corresponding versions prefixed with <code class="code">__builtin_</code>. </p> <p>GCC provides built-in versions of the ISO C99 floating-point comparison macros that avoid raising exceptions for unordered operands. They have the same names as the standard macros ( <code class="code">isgreater</code>, <code class="code">isgreaterequal</code>, <code class="code">isless</code>, <code class="code">islessequal</code>, <code class="code">islessgreater</code>, and <code class="code">isunordered</code>) , with <code class="code">__builtin_</code> prefixed. We intend for a library implementor to be able to simply <code class="code">#define</code> each standard macro to its built-in equivalent. In the same fashion, GCC provides <code class="code">fpclassify</code>, <code class="code">iseqsig</code>, <code class="code">isfinite</code>, <code class="code">isinf_sign</code>, <code class="code">isnormal</code> and <code class="code">signbit</code> built-ins used with <code class="code">__builtin_</code> prefixed. The <code class="code">isinf</code> and <code class="code">isnan</code> built-in functions appear both with and without the <code class="code">__builtin_</code> prefix. With <code class="code">-ffinite-math-only</code> option the <code class="code">isinf</code> and <code class="code">isnan</code> built-in functions will always return 0. </p> <p>GCC provides built-in versions of the ISO C99 floating-point rounding and exceptions handling functions <code class="code">fegetround</code>, <code class="code">feclearexcept</code> and <code class="code">feraiseexcept</code>. They may not be available for all targets, and because they need close interaction with libc internal values, they may not be available for all target libcs, but in all cases they will gracefully fallback to libc calls. These built-in functions appear both with and without the <code class="code">__builtin_</code> prefix. </p> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005falloca">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void *</code> <strong class="def-name">__builtin_alloca</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_alloca</code> function must be called at block scope. The function allocates an object <var class="var">size</var> bytes large on the stack of the calling function. The object is aligned on the default stack alignment boundary for the target determined by the <code class="code">__BIGGEST_ALIGNMENT__</code> macro. The <code class="code">__builtin_alloca</code> function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends just before the calling function returns to its caller. This is so even when <code class="code">__builtin_alloca</code> is called within a nested block. </p> <p>For example, the following function allocates eight objects of <code class="code">n</code> bytes each on the stack, storing a pointer to each in consecutive elements of the array <code class="code">a</code>. It then passes the array to function <code class="code">g</code> which can safely use the storage pointed to by each of the array elements. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (unsigned n)
{
  void *a [8];
  for (int i = 0; i != 8; ++i)
    a [i] = __builtin_alloca (n);

  g (a, n);   // <span class="r">safe</span>
}</pre>
</div> <p>Since the <code class="code">__builtin_alloca</code> function doesn’t validate its argument it is the responsibility of its caller to make sure the argument doesn’t cause it to exceed the stack size limit. The <code class="code">__builtin_alloca</code> function is provided to make it possible to allocate on the stack arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer similar functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See <a class="xref" href="variable-length.html">Arrays of Variable Length</a>, for details. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005falloca_005fwith_005falign">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void *</code> <strong class="def-name">__builtin_alloca_with_align</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>, size_t <var class="var">alignment</var>)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_alloca_with_align</code> function must be called at block scope. The function allocates an object <var class="var">size</var> bytes large on the stack of the calling function. The allocated object is aligned on the boundary specified by the argument <var class="var">alignment</var> whose unit is given in bits (not bytes). The <var class="var">size</var> argument must be positive and not exceed the stack size limit. The <var class="var">alignment</var> argument must be a constant integer expression that evaluates to a power of 2 greater than or equal to <code class="code">CHAR_BIT</code> and less than some unspecified maximum. Invocations with other values are rejected with an error indicating the valid bounds. The function returns a pointer to the first byte of the allocated object. The lifetime of the allocated object ends at the end of the block in which the function was called. The allocated storage is released no later than just before the calling function returns to its caller, but may be released at the end of the block in which the function was called. </p> <p>For example, in the following function the call to <code class="code">g</code> is unsafe because when <code class="code">overalign</code> is non-zero, the space allocated by <code class="code">__builtin_alloca_with_align</code> may have been released at the end of the <code class="code">if</code> statement in which it was called. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (unsigned n, bool overalign)
{
  void *p;
  if (overalign)
    p = __builtin_alloca_with_align (n, 64 /* bits */);
  else
    p = __builtin_alloc (n);

  g (p, n);   // <span class="r">unsafe</span>
}</pre>
</div> <p>Since the <code class="code">__builtin_alloca_with_align</code> function doesn’t validate its <var class="var">size</var> argument it is the responsibility of its caller to make sure the argument doesn’t cause it to exceed the stack size limit. The <code class="code">__builtin_alloca_with_align</code> function is provided to make it possible to allocate on the stack overaligned arrays of bytes with an upper bound that may be computed at run time. Since C99 Variable Length Arrays offer the same functionality under a portable, more convenient, and safer interface they are recommended instead, in both C99 and C++ programs where GCC provides them as an extension. See <a class="xref" href="variable-length.html">Arrays of Variable Length</a>, for details. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005falloca_005fwith_005falign_005fand_005fmax">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void *</code> <strong class="def-name">__builtin_alloca_with_align_and_max</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>, size_t <var class="var">alignment</var>, size_t <var class="var">max_size</var>)</code></span>
</dt> <dd>
<p>Similar to <code class="code">__builtin_alloca_with_align</code> but takes an extra argument specifying an upper bound for <var class="var">size</var> in case its value cannot be computed at compile time, for use by <samp class="option">-fstack-usage</samp>, <samp class="option">-Wstack-usage</samp> and <samp class="option">-Walloca-larger-than</samp>. <var class="var">max_size</var> must be a constant integer expression, it has no effect on code generation and no attempt is made to check its compatibility with <var class="var">size</var>. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhas_005fattribute">
<span class="category-def">Built-in Function: </span><span><code class="def-type">bool</code> <strong class="def-name">__builtin_has_attribute</strong> <code class="def-code-arguments">(<var class="var">type-or-expression</var>, <var class="var">attribute</var>)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_has_attribute</code> function evaluates to an integer constant expression equal to <code class="code">true</code> if the symbol or type referenced by the <var class="var">type-or-expression</var> argument has been declared with the <var class="var">attribute</var> referenced by the second argument. For an <var class="var">type-or-expression</var> argument that does not reference a symbol, since attributes do not apply to expressions the built-in consider the type of the argument. Neither argument is evaluated. The <var class="var">type-or-expression</var> argument is subject to the same restrictions as the argument to <code class="code">typeof</code> (see <a class="pxref" href="typeof.html">Referring to a Type with <code class="code">typeof</code></a>). The <var class="var">attribute</var> argument is an attribute name optionally followed by a comma-separated list of arguments enclosed in parentheses. Both forms of attribute names—with and without double leading and trailing underscores—are recognized. See <a class="xref" href="attribute-syntax.html">Attribute Syntax</a>, for details. When no attribute arguments are specified for an attribute that expects one or more arguments the function returns <code class="code">true</code> if <var class="var">type-or-expression</var> has been declared with the attribute regardless of the attribute argument values. Arguments provided for an attribute that expects some are validated and matched up to the provided number. The function returns <code class="code">true</code> if all provided arguments match. For example, the first call to the function below evaluates to <code class="code">true</code> because <code class="code">x</code> is declared with the <code class="code">aligned</code> attribute but the second call evaluates to <code class="code">false</code> because <code class="code">x</code> is declared <code class="code">aligned (8)</code> and not <code class="code">aligned (4)</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">__attribute__ ((aligned (8))) int x;
_Static_assert (__builtin_has_attribute (x, aligned), "aligned");
_Static_assert (!__builtin_has_attribute (x, aligned (4)), "aligned (4)");</pre>
</div> <p>Due to a limitation the <code class="code">__builtin_has_attribute</code> function returns <code class="code">false</code> for the <code class="code">mode</code> attribute even if the type or variable referenced by the <var class="var">type-or-expression</var> argument was declared with one. The function is also not supported with labels, and in C with enumerators. </p> <p>Note that unlike the <code class="code">__has_attribute</code> preprocessor operator which is suitable for use in <code class="code">#if</code> preprocessing directives <code class="code">__builtin_has_attribute</code> is an intrinsic function that is not recognized in such contexts. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fspeculation_005fsafe_005fvalue-1">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_speculation_safe_value</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">val</var>, <var class="var">type</var> <var class="var">failval</var>)</code></span>
</dt> <dd> <p>This built-in function can be used to help mitigate against unsafe speculative execution. <var class="var">type</var> may be any integral type or any pointer type. </p> <ol class="enumerate"> <li> If the CPU is not speculatively executing the code, then <var class="var">val</var> is returned. </li>
<li> If the CPU is executing speculatively then either: <ul class="itemize mark-bullet"> <li>The function may cause execution to pause until it is known that the code is no-longer being executed speculatively (in which case <var class="var">val</var> can be returned, as above); or </li>
<li>The function may use target-dependent speculation tracking state to cause <var class="var">failval</var> to be returned when it is known that speculative execution has incorrectly predicted a conditional branch operation. </li>
</ul> </li>
</ol> <p>The second argument, <var class="var">failval</var>, is optional and defaults to zero if omitted. </p> <p>GCC defines the preprocessor macro <code class="code">__HAVE_BUILTIN_SPECULATION_SAFE_VALUE</code> for targets that have been updated to support this builtin. </p> <p>The built-in function can be used where a variable appears to be used in a safe way, but the CPU, due to speculative execution may temporarily ignore the bounds checks. Consider, for example, the following function: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int array[500];
int f (unsigned untrusted_index)
{
  if (untrusted_index &lt; 500)
    return array[untrusted_index];
  return 0;
}</pre>
</div> <p>If the function is called repeatedly with <code class="code">untrusted_index</code> less than the limit of 500, then a branch predictor will learn that the block of code that returns a value stored in <code class="code">array</code> will be executed. If the function is subsequently called with an out-of-range value it will still try to execute that block of code first until the CPU determines that the prediction was incorrect (the CPU will unwind any incorrect operations at that point). However, depending on how the result of the function is used, it might be possible to leave traces in the cache that can reveal what was stored at the out-of-bounds location. The built-in function can be used to provide some protection against leaking data in this way by changing the code to: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int array[500];
int f (unsigned untrusted_index)
{
  if (untrusted_index &lt; 500)
    return array[__builtin_speculation_safe_value (untrusted_index)];
  return 0;
}</pre>
</div> <p>The built-in function will either cause execution to stall until the conditional branch has been fully resolved, or it may permit speculative execution to continue, but using 0 instead of <code class="code">untrusted_value</code> if that exceeds the limit. </p> <p>If accessing any memory location is potentially unsafe when speculative execution is incorrect, then the code can be rewritten as </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int array[500];
int f (unsigned untrusted_index)
{
  if (untrusted_index &lt; 500)
    return *__builtin_speculation_safe_value (&amp;array[untrusted_index], NULL);
  return 0;
}</pre>
</div> <p>which will cause a <code class="code">NULL</code> pointer to be used for the unsafe case. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005ftypes_005fcompatible_005fp">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_types_compatible_p</strong> <code class="def-code-arguments">(<var class="var">type1</var>, <var class="var">type2</var>)</code></span>
</dt> <dd> <p>You can use the built-in function <code class="code">__builtin_types_compatible_p</code> to determine whether two types are the same. </p> <p>This built-in function returns 1 if the unqualified versions of the types <var class="var">type1</var> and <var class="var">type2</var> (which are types, not expressions) are compatible, 0 otherwise. The result of this built-in function can be used in integer constant expressions. </p> <p>This built-in function ignores top level qualifiers (e.g., <code class="code">const</code>, <code class="code">volatile</code>). For example, <code class="code">int</code> is equivalent to <code class="code">const
int</code>. </p> <p>The type <code class="code">int[]</code> and <code class="code">int[5]</code> are compatible. On the other hand, <code class="code">int</code> and <code class="code">char *</code> are not compatible, even if the size of their types, on the particular architecture are the same. Also, the amount of pointer indirection is taken into account when determining similarity. Consequently, <code class="code">short *</code> is not similar to <code class="code">short **</code>. Furthermore, two types that are typedefed are considered compatible if their underlying types are compatible. </p> <p>An <code class="code">enum</code> type is not considered to be compatible with another <code class="code">enum</code> type even if both are compatible with the same integer type; this is what the C standard specifies. For example, <code class="code">enum {foo, bar}</code> is not similar to <code class="code">enum {hot, dog}</code>. </p> <p>You typically use this function in code whose execution varies depending on the arguments’ types. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define foo(x)                                                  \
  ({                                                           \
    typeof (x) tmp = (x);                                       \
    if (__builtin_types_compatible_p (typeof (x), long double)) \
      tmp = foo_long_double (tmp);                              \
    else if (__builtin_types_compatible_p (typeof (x), double)) \
      tmp = foo_double (tmp);                                   \
    else if (__builtin_types_compatible_p (typeof (x), float))  \
      tmp = foo_float (tmp);                                    \
    else                                                        \
      abort ();                                                 \
    tmp;                                                        \
  })</pre>
</div> <p><em class="emph">Note:</em> This construct is only available for C. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fcall_005fwith_005fstatic_005fchain">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_call_with_static_chain</strong> <code class="def-code-arguments">(<var class="var">call_exp</var>, <var class="var">pointer_exp</var>)</code></span>
</dt> <dd> <p>The <var class="var">call_exp</var> expression must be a function call, and the <var class="var">pointer_exp</var> expression must be a pointer. The <var class="var">pointer_exp</var> is passed to the function call in the target’s static chain location. The result of builtin is the result of the function call. </p> <p><em class="emph">Note:</em> This builtin is only available for C. This builtin can be used to call Go closures from C. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fchoose_005fexpr">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_choose_expr</strong> <code class="def-code-arguments">(<var class="var">const_exp</var>, <var class="var">exp1</var>, <var class="var">exp2</var>)</code></span>
</dt> <dd> <p>You can use the built-in function <code class="code">__builtin_choose_expr</code> to evaluate code depending on the value of a constant expression. This built-in function returns <var class="var">exp1</var> if <var class="var">const_exp</var>, which is an integer constant expression, is nonzero. Otherwise it returns <var class="var">exp2</var>. </p> <p>This built-in function is analogous to the ‘<samp class="samp">? :</samp>’ operator in C, except that the expression returned has its type unaltered by promotion rules. Also, the built-in function does not evaluate the expression that is not chosen. For example, if <var class="var">const_exp</var> evaluates to <code class="code">true</code>, <var class="var">exp2</var> is not evaluated even if it has side effects. </p> <p>This built-in function can return an lvalue if the chosen argument is an lvalue. </p> <p>If <var class="var">exp1</var> is returned, the return type is the same as <var class="var">exp1</var>’s type. Similarly, if <var class="var">exp2</var> is returned, its return type is the same as <var class="var">exp2</var>. </p> <p>Example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define foo(x)                                                    \
  __builtin_choose_expr (                                         \
    __builtin_types_compatible_p (typeof (x), double),            \
    foo_double (x),                                               \
    __builtin_choose_expr (                                       \
      __builtin_types_compatible_p (typeof (x), float),           \
      foo_float (x),                                              \
      /* <span class="r">The void expression results in a compile-time error</span>  \
         <span class="r">when assigning the result to something.</span>  */          \
      (void)0))</pre>
</div> <p><em class="emph">Note:</em> This construct is only available for C. Furthermore, the unused expression (<var class="var">exp1</var> or <var class="var">exp2</var> depending on the value of <var class="var">const_exp</var>) may still generate syntax errors. This may change in future revisions. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005ftgmath">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_tgmath</strong> <code class="def-code-arguments">(<var class="var">functions</var>, <var class="var">arguments</var>)</code></span>
</dt> <dd> <p>The built-in function <code class="code">__builtin_tgmath</code>, available only for C and Objective-C, calls a function determined according to the rules of <code class="code">&lt;tgmath.h&gt;</code> macros. It is intended to be used in implementations of that header, so that expansions of macros from that header only expand each of their arguments once, to avoid problems when calls to such macros are nested inside the arguments of other calls to such macros; in addition, it results in better diagnostics for invalid calls to <code class="code">&lt;tgmath.h&gt;</code> macros than implementations using other GNU C language features. For example, the <code class="code">pow</code> type-generic macro might be defined as: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define pow(a, b) __builtin_tgmath (powf, pow, powl, \
                                    cpowf, cpow, cpowl, a, b)</pre>
</div> <p>The arguments to <code class="code">__builtin_tgmath</code> are at least two pointers to functions, followed by the arguments to the type-generic macro (which will be passed as arguments to the selected function). All the pointers to functions must be pointers to prototyped functions, none of which may have variable arguments, and all of which must have the same number of parameters; the number of parameters of the first function determines how many arguments to <code class="code">__builtin_tgmath</code> are interpreted as function pointers, and how many as the arguments to the called function. </p> <p>The types of the specified functions must all be different, but related to each other in the same way as a set of functions that may be selected between by a macro in <code class="code">&lt;tgmath.h&gt;</code>. This means that the functions are parameterized by a floating-point type <var class="var">t</var>, different for each such function. The function return types may all be the same type, or they may be <var class="var">t</var> for each function, or they may be the real type corresponding to <var class="var">t</var> for each function (if some of the types <var class="var">t</var> are complex). Likewise, for each parameter position, the type of the parameter in that position may always be the same type, or may be <var class="var">t</var> for each function (this case must apply for at least one parameter position), or may be the real type corresponding to <var class="var">t</var> for each function. </p> <p>The standard rules for <code class="code">&lt;tgmath.h&gt;</code> macros are used to find a common type <var class="var">u</var> from the types of the arguments for parameters whose types vary between the functions; complex integer types (a GNU extension) are treated like the complex type corresponding to the real floating type that would be chosen for the corresponding real integer type. If the function return types vary, or are all the same integer type, the function called is the one for which <var class="var">t</var> is <var class="var">u</var>, and it is an error if there is no such function. If the function return types are all the same floating-point type, the type-generic macro is taken to be one of those from TS 18661 that rounds the result to a narrower type; if there is a function for which <var class="var">t</var> is <var class="var">u</var>, it is called, and otherwise the first function, if any, for which <var class="var">t</var> has at least the range and precision of <var class="var">u</var> is called, and it is an error if there is no such function. </p> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fconstant_005fp">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_constant_p</strong> <code class="def-code-arguments">(<var class="var">exp</var>)</code></span>
</dt> <dd>
<p>You can use the built-in function <code class="code">__builtin_constant_p</code> to determine if the expression <var class="var">exp</var> is known to be constant at compile time and hence that GCC can perform constant-folding on expressions involving that value. The argument of the function is the expression to test. The expression is not evaluated, side-effects are discarded. The function returns the integer 1 if the argument is known to be a compile-time constant and 0 if it is not known to be a compile-time constant. Any expression that has side-effects makes the function return 0. A return of 0 does not indicate that the expression is <em class="emph">not</em> a constant, but merely that GCC cannot prove it is a constant within the constraints of the active set of optimization options. </p> <p>You typically use this function in an embedded application where memory is a critical resource. If you have some complex calculation, you may want it to be folded if it involves constants, but need to call a function if it does not. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define Scale_Value(X)      \
  (__builtin_constant_p (X) \
  ? ((X) * SCALE + OFFSET) : Scale (X))</pre>
</div> <p>You may use this built-in function in either a macro or an inline function. However, if you use it in an inlined function and pass an argument of the function as the argument to the built-in, GCC never returns 1 when you call the inline function with a string constant or compound literal (see <a class="pxref" href="compound-literals.html">Compound Literals</a>) and does not return 1 when you pass a constant numeric value to the inline function unless you specify the <samp class="option">-O</samp> option. </p> <p>You may also use <code class="code">__builtin_constant_p</code> in initializers for static data. For instance, you can write </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">static const int table[] = {
   __builtin_constant_p (EXPRESSION) ? (EXPRESSION) : -1,
   /* <span class="r">…</span> */
};</pre>
</div> <p>This is an acceptable initializer even if <var class="var">EXPRESSION</var> is not a constant expression, including the case where <code class="code">__builtin_constant_p</code> returns 1 because <var class="var">EXPRESSION</var> can be folded to a constant but <var class="var">EXPRESSION</var> contains operands that are not otherwise permitted in a static initializer (for example, <code class="code">0 &amp;&amp; foo ()</code>). GCC must be more conservative about evaluating the built-in in this case, because it has no opportunity to perform optimization. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fis_005fconstant_005fevaluated">
<span class="category-def">Built-in Function: </span><span><code class="def-type">bool</code> <strong class="def-name">__builtin_is_constant_evaluated</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_is_constant_evaluated</code> function is available only in C++. The built-in is intended to be used by implementations of the <code class="code">std::is_constant_evaluated</code> C++ function. Programs should make use of the latter function rather than invoking the built-in directly. </p> <p>The main use case of the built-in is to determine whether a <code class="code">constexpr</code> function is being called in a <code class="code">constexpr</code> context. A call to the function evaluates to a core constant expression with the value <code class="code">true</code> if and only if it occurs within the evaluation of an expression or conversion that is manifestly constant-evaluated as defined in the C++ standard. Manifestly constant-evaluated contexts include constant-expressions, the conditions of <code class="code">constexpr if</code> statements, constraint-expressions, and initializers of variables usable in constant expressions. For more details refer to the latest revision of the C++ standard. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclear_005fpadding">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_clear_padding</strong> <code class="def-code-arguments">(<var class="var">ptr</var>)</code></span>
</dt> <dd>
<p>The built-in function <code class="code">__builtin_clear_padding</code> function clears padding bits inside of the object representation of object pointed by <var class="var">ptr</var>, which has to be a pointer. The value representation of the object is not affected. The type of the object is assumed to be the type the pointer points to. Inside of a union, the only cleared bits are bits that are padding bits for all the union members. </p> <p>This built-in-function is useful if the padding bits of an object might have intederminate values and the object representation needs to be bitwise compared to some other object, for example for atomic operations. </p> <p>For C++, <var class="var">ptr</var> argument type should be pointer to trivially-copyable type, unless the argument is address of a variable or parameter, because otherwise it isn’t known if the type isn’t just a base class whose padding bits are reused or laid out differently in a derived class. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fbit_005fcast">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_bit_cast</strong> <code class="def-code-arguments">(<var class="var">type</var>, <var class="var">arg</var>)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_bit_cast</code> function is available only in C++. The built-in is intended to be used by implementations of the <code class="code">std::bit_cast</code> C++ template function. Programs should make use of the latter function rather than invoking the built-in directly. </p> <p>This built-in function allows reinterpreting the bits of the <var class="var">arg</var> argument as if it had type <var class="var">type</var>. <var class="var">type</var> and the type of the <var class="var">arg</var> argument need to be trivially copyable types with the same size. When manifestly constant-evaluated, it performs extra diagnostics required for <code class="code">std::bit_cast</code> and returns a constant expression if <var class="var">arg</var> is a constant expression. For more details refer to the latest revision of the C++ standard. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fexpect">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long</code> <strong class="def-name">__builtin_expect</strong> <code class="def-code-arguments">(long <var class="var">exp</var>, long <var class="var">c</var>)</code></span>
</dt> <dd>
 <p>You may use <code class="code">__builtin_expect</code> to provide the compiler with branch prediction information. In general, you should prefer to use actual profile feedback for this (<samp class="option">-fprofile-arcs</samp>), as programmers are notoriously bad at predicting how their programs actually perform. However, there are applications in which this data is hard to collect. </p> <p>The return value is the value of <var class="var">exp</var>, which should be an integral expression. The semantics of the built-in are that it is expected that <var class="var">exp</var> == <var class="var">c</var>. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (__builtin_expect (x, 0))
  foo ();</pre>
</div> <p>indicates that we do not expect to call <code class="code">foo</code>, since we expect <code class="code">x</code> to be zero. Since you are limited to integral expressions for <var class="var">exp</var>, you should use constructions such as </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (__builtin_expect (ptr != NULL, 1))
  foo (*ptr);</pre>
</div> <p>when testing pointer or floating-point values. </p> <p>For the purposes of branch prediction optimizations, the probability that a <code class="code">__builtin_expect</code> expression is <code class="code">true</code> is controlled by GCC’s <code class="code">builtin-expect-probability</code> parameter, which defaults to 90%. </p> <p>You can also use <code class="code">__builtin_expect_with_probability</code> to explicitly assign a probability value to individual expressions. If the built-in is used in a loop construct, the provided probability will influence the expected number of iterations made by loop optimizations. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fexpect_005fwith_005fprobability">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long</code> <strong class="def-name">__builtin_expect_with_probability</strong></span>
</dt> <dd>
<p>(long <var class="var">exp</var>, long <var class="var">c</var>, double <var class="var">probability</var>) </p> <p>This function has the same semantics as <code class="code">__builtin_expect</code>, but the caller provides the expected probability that <var class="var">exp</var> == <var class="var">c</var>. The last argument, <var class="var">probability</var>, is a floating-point value in the range 0.0 to 1.0, inclusive. The <var class="var">probability</var> argument must be constant floating-point expression. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005ftrap">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_trap</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>This function causes the program to exit abnormally. GCC implements this function by using a target-dependent mechanism (such as intentionally executing an illegal instruction) or by calling <code class="code">abort</code>. The mechanism used may vary from release to release so you should not rely on any particular implementation. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005funreachable">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_unreachable</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd>
<p>If control flow reaches the point of the <code class="code">__builtin_unreachable</code>, the program is undefined. It is useful in situations where the compiler cannot deduce the unreachability of the code. </p> <p>One such case is immediately following an <code class="code">asm</code> statement that either never terminates, or one that transfers control elsewhere and never returns. In this example, without the <code class="code">__builtin_unreachable</code>, GCC issues a warning that control reaches the end of a non-void function. It also generates code to return after the <code class="code">asm</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int f (int c, int v)
{
  if (c)
    {
      return v;
    }
  else
    {
      asm("jmp error_handler");
      __builtin_unreachable ();
    }
}</pre>
</div> <p>Because the <code class="code">asm</code> statement unconditionally transfers control out of the function, control never reaches the end of the function body. The <code class="code">__builtin_unreachable</code> is in fact unreachable and communicates this fact to the compiler. </p> <p>Another use for <code class="code">__builtin_unreachable</code> is following a call a function that never returns but that is not declared <code class="code">__attribute__((noreturn))</code>, as in this example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void function_that_never_returns (void);

int g (int c)
{
  if (c)
    {
      return 1;
    }
  else
    {
      function_that_never_returns ();
      __builtin_unreachable ();
    }
}</pre>
</div> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fassoc_005fbarrier">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_assoc_barrier</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">expr</var>)</code></span>
</dt> <dd>
<p>This built-in inhibits re-association of the floating-point expression <var class="var">expr</var> with expressions consuming the return value of the built-in. The expression <var class="var">expr</var> itself can be reordered, and the whole expression <var class="var">expr</var> can be reordered with operands after the barrier. The barrier is only relevant when <code class="code">-fassociative-math</code> is active, since otherwise floating-point is not treated as associative. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">float x0 = a + b - b;
float x1 = __builtin_assoc_barrier(a + b) - b;</pre>
</div> <p>means that, with <code class="code">-fassociative-math</code>, <code class="code">x0</code> can be optimized to <code class="code">x0 = a</code> but <code class="code">x1</code> cannot. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fassume_005faligned">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void *</code> <strong class="def-name">__builtin_assume_aligned</strong> <code class="def-code-arguments">(const void *<var class="var">exp</var>, size_t <var class="var">align</var>, ...)</code></span>
</dt> <dd>
<p>This function returns its first argument, and allows the compiler to assume that the returned pointer is at least <var class="var">align</var> bytes aligned. This built-in can have either two or three arguments, if it has three, the third argument should have integer type, and if it is nonzero means misalignment offset. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void *x = __builtin_assume_aligned (arg, 16);</pre>
</div> <p>means that the compiler can assume <code class="code">x</code>, set to <code class="code">arg</code>, is at least 16-byte aligned, while: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void *x = __builtin_assume_aligned (arg, 32, 8);</pre>
</div> <p>means that the compiler can assume for <code class="code">x</code>, set to <code class="code">arg</code>, that <code class="code">(char *) x - 8</code> is 32-byte aligned. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fLINE">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_LINE</strong> <code class="def-code-arguments">()</code></span>
</dt> <dd><p>This function is the equivalent of the preprocessor <code class="code">__LINE__</code> macro and returns a constant integer expression that evaluates to the line number of the invocation of the built-in. When used as a C++ default argument for a function <var class="var">F</var>, it returns the line number of the call to <var class="var">F</var>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fFUNCTION">
<span class="category-def">Built-in Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">__builtin_FUNCTION</strong> <code class="def-code-arguments">()</code></span>
</dt> <dd><p>This function is the equivalent of the <code class="code">__FUNCTION__</code> symbol and returns an address constant pointing to the name of the function from which the built-in was invoked, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function <var class="var">F</var>, it returns the name of <var class="var">F</var>’s caller or the empty string if the call was not made at function scope. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fFILE">
<span class="category-def">Built-in Function: </span><span><code class="def-type">const char *</code> <strong class="def-name">__builtin_FILE</strong> <code class="def-code-arguments">()</code></span>
</dt> <dd>
<p>This function is the equivalent of the preprocessor <code class="code">__FILE__</code> macro and returns an address constant pointing to the file name containing the invocation of the built-in, or the empty string if the invocation is not at function scope. When used as a C++ default argument for a function <var class="var">F</var>, it returns the file name of the call to <var class="var">F</var> or the empty string if the call was not made at function scope. </p> <p>For example, in the following, each call to function <code class="code">foo</code> will print a line similar to <code class="code">"file.c:123: foo: message"</code> with the name of the file and the line number of the <code class="code">printf</code> call, the name of the function <code class="code">foo</code>, followed by the word <code class="code">message</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">const char*
function (const char *func = __builtin_FUNCTION ())
{
  return func;
}

void foo (void)
{
  printf ("%s:%i: %s: message\n", file (), line (), function ());
}</pre>
</div> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005f_005f_005fclear_005fcache">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin___clear_cache</strong> <code class="def-code-arguments">(void *<var class="var">begin</var>, void *<var class="var">end</var>)</code></span>
</dt> <dd>
<p>This function is used to flush the processor’s instruction cache for the region of memory between <var class="var">begin</var> inclusive and <var class="var">end</var> exclusive. Some targets require that the instruction cache be flushed, after modifying memory containing code, in order to obtain deterministic behavior. </p> <p>If the target does not require instruction cache flushes, <code class="code">__builtin___clear_cache</code> has no effect. Otherwise either instructions are emitted in-line to clear the instruction cache or a call to the <code class="code">__clear_cache</code> function in libgcc is made. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fprefetch">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_prefetch</strong> <code class="def-code-arguments">(const void *<var class="var">addr</var>, ...)</code></span>
</dt> <dd>
<p>This function is used to minimize cache-miss latency by moving data into a cache before it is accessed. You can insert calls to <code class="code">__builtin_prefetch</code> into code for which you know addresses of data in memory that is likely to be accessed soon. If the target supports them, data prefetch instructions are generated. If the prefetch is done early enough before the access then the data will be in the cache by the time it is accessed. </p> <p>The value of <var class="var">addr</var> is the address of the memory to prefetch. There are two optional arguments, <var class="var">rw</var> and <var class="var">locality</var>. The value of <var class="var">rw</var> is a compile-time constant one or zero; one means that the prefetch is preparing for a write to the memory address and zero, the default, means that the prefetch is preparing for a read. The value <var class="var">locality</var> must be a compile-time constant integer between zero and three. A value of zero means that the data has no temporal locality, so it need not be left in the cache after the access. A value of three means that the data has a high degree of temporal locality and should be left in all levels of cache possible. Values of one and two mean, respectively, a low or moderate degree of temporal locality. The default is three. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">for (i = 0; i &lt; n; i++)
  {
    a[i] = a[i] + b[i];
    __builtin_prefetch (&amp;a[i+j], 1, 1);
    __builtin_prefetch (&amp;b[i+j], 0, 1);
    /* <span class="r">…</span> */
  }</pre>
</div> <p>Data prefetch does not generate faults if <var class="var">addr</var> is invalid, but the address expression itself must be valid. For example, a prefetch of <code class="code">p-&gt;next</code> does not fault if <code class="code">p-&gt;next</code> is not a valid address, but evaluation faults if <code class="code">p</code> is not a valid address. </p> <p>If the target does not support data prefetch, the address expression is evaluated if it includes side effects but no other code is generated and GCC does not issue a warning. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fobject_005fsize-1">
<span class="category-def">Built-in Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">__builtin_object_size</strong> <code class="def-code-arguments">(const void * <var class="var">ptr</var>, int <var class="var">type</var>)</code></span>
</dt> <dd><p>Returns a constant size estimate of an object pointed to by <var class="var">ptr</var>. See <a class="xref" href="object-size-checking.html">Object Size Checking</a>, for a detailed description of the function. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fdynamic_005fobject_005fsize-1">
<span class="category-def">Built-in Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">__builtin_dynamic_object_size</strong> <code class="def-code-arguments">(const void * <var class="var">ptr</var>, int <var class="var">type</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_object_size</code> except that the return value need not be a constant. See <a class="xref" href="object-size-checking.html">Object Size Checking</a>, for a detailed description of the function. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclassify_005ftype">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_classify_type</strong> <code class="def-code-arguments">(<var class="var">arg</var>)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005fclassify_005ftype-1">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_classify_type</strong> <code class="def-code-arguments">(<var class="var">type</var>)</code></span>
</dt> <dd>
<p>The <code class="code">__builtin_classify_type</code> returns a small integer with a category of <var class="var">arg</var> argument’s type, like void type, integer type, enumeral type, boolean type, pointer type, reference type, offset type, real type, complex type, function type, method type, record type, union type, array type, string type, bit-precise integer type, vector type, etc. When the argument is an expression, for backwards compatibility reason the argument is promoted like arguments passed to <code class="code">...</code> in varargs function, so some classes are never returned in certain languages. Alternatively, the argument of the built-in function can be a typename, such as the <code class="code">typeof</code> specifier. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int a[2];
__builtin_classify_type (a) == __builtin_classify_type (int[5]);
__builtin_classify_type (a) == __builtin_classify_type (void*);
__builtin_classify_type (typeof (a)) == __builtin_classify_type (int[5]);</pre>
</div> <p>The first comparison will never be true, as <var class="var">a</var> is implicitly converted to pointer. The last two comparisons will be true as they classify pointers in the second case and arrays in the last case. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhuge_005fval">
<span class="category-def">Built-in Function: </span><span><code class="def-type">double</code> <strong class="def-name">__builtin_huge_val</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Returns a positive infinity, if supported by the floating-point format, else <code class="code">DBL_MAX</code>. This function is suitable for implementing the ISO C macro <code class="code">HUGE_VAL</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhuge_005fvalf">
<span class="category-def">Built-in Function: </span><span><code class="def-type">float</code> <strong class="def-name">__builtin_huge_valf</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_huge_val</code>, except the return type is <code class="code">float</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhuge_005fvall">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long double</code> <strong class="def-name">__builtin_huge_vall</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_huge_val</code>, except the return type is <code class="code">long double</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhuge_005fvalfn">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var></code> <strong class="def-name">__builtin_huge_valf<var class="var">n</var></strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_huge_val</code>, except the return type is <code class="code">_Float<var class="var">n</var></code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fhuge_005fvalfnx">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var>x</code> <strong class="def-name">__builtin_huge_valf<var class="var">n</var>x</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_huge_val</code>, except the return type is <code class="code">_Float<var class="var">n</var>x</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005ffpclassify">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_fpclassify</strong> <code class="def-code-arguments">(int, int, int, int, int, ...)</code></span>
</dt> <dd><p>This built-in implements the C99 fpclassify functionality. The first five int arguments should be the target library’s notion of the possible FP classes and are used for return values. They must be constant values and they must appear in this order: <code class="code">FP_NAN</code>, <code class="code">FP_INFINITE</code>, <code class="code">FP_NORMAL</code>, <code class="code">FP_SUBNORMAL</code> and <code class="code">FP_ZERO</code>. The ellipsis is for exactly one floating-point value to classify. GCC treats the last argument as type-generic, which means it does not do default promotion from float to double. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finf">
<span class="category-def">Built-in Function: </span><span><code class="def-type">double</code> <strong class="def-name">__builtin_inf</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_huge_val</code>, except a warning is generated if the target floating-point format does not support infinities. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finfd32">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal32</code> <strong class="def-name">__builtin_infd32</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">_Decimal32</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finfd64">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal64</code> <strong class="def-name">__builtin_infd64</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">_Decimal64</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finfd128">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal128</code> <strong class="def-name">__builtin_infd128</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">_Decimal128</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finff">
<span class="category-def">Built-in Function: </span><span><code class="def-type">float</code> <strong class="def-name">__builtin_inff</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">float</code>. This function is suitable for implementing the ISO C99 macro <code class="code">INFINITY</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finfl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long double</code> <strong class="def-name">__builtin_infl</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">long double</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finffn">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var></code> <strong class="def-name">__builtin_inff<var class="var">n</var></strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">_Float<var class="var">n</var></code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005finffnx">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var></code> <strong class="def-name">__builtin_inff<var class="var">n</var>x</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_inf</code>, except the return type is <code class="code">_Float<var class="var">n</var>x</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fisinf_005fsign">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_isinf_sign</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">isinf</code>, except the return value is -1 for an argument of <code class="code">-Inf</code> and 1 for an argument of <code class="code">+Inf</code>. Note while the parameter list is an ellipsis, this function only accepts exactly one floating-point argument. GCC treats this parameter as type-generic, which means it does not do default promotion from float to double. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnan">
<span class="category-def">Built-in Function: </span><span><code class="def-type">double</code> <strong class="def-name">__builtin_nan</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd>
<p>This is an implementation of the ISO C99 function <code class="code">nan</code>. </p> <p>Since ISO C99 defines this function in terms of <code class="code">strtod</code>, which we do not implement, a description of the parsing is in order. The string is parsed as by <code class="code">strtol</code>; that is, the base is recognized by leading ‘<samp class="samp">0</samp>’ or ‘<samp class="samp">0x</samp>’ prefixes. The number parsed is placed in the significand such that the least significant bit of the number is at the least significant bit of the significand. The number is truncated to fit the significand field provided. The significand is forced to be a quiet NaN. </p> <p>This function, if given a string literal all of which would have been consumed by <code class="code">strtol</code>, is evaluated early enough that it is considered a compile-time constant. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnand32">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal32</code> <strong class="def-name">__builtin_nand32</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">_Decimal32</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnand64">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal64</code> <strong class="def-name">__builtin_nand64</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">_Decimal64</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnand128">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal128</code> <strong class="def-name">__builtin_nand128</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">_Decimal128</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnanf">
<span class="category-def">Built-in Function: </span><span><code class="def-type">float</code> <strong class="def-name">__builtin_nanf</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">float</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnanl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long double</code> <strong class="def-name">__builtin_nanl</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">long double</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnanfn">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var></code> <strong class="def-name">__builtin_nanf<var class="var">n</var></strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">_Float<var class="var">n</var></code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnanfnx">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var>x</code> <strong class="def-name">__builtin_nanf<var class="var">n</var>x</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the return type is <code class="code">_Float<var class="var">n</var>x</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnans">
<span class="category-def">Built-in Function: </span><span><code class="def-type">double</code> <strong class="def-name">__builtin_nans</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nan</code>, except the significand is forced to be a signaling NaN. The <code class="code">nans</code> function is proposed by <a class="uref" href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n965.htm">WG14 N965</a>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansd32">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal32</code> <strong class="def-name">__builtin_nansd32</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">_Decimal32</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansd64">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal64</code> <strong class="def-name">__builtin_nansd64</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">_Decimal64</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansd128">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Decimal128</code> <strong class="def-name">__builtin_nansd128</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">_Decimal128</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansf">
<span class="category-def">Built-in Function: </span><span><code class="def-type">float</code> <strong class="def-name">__builtin_nansf</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">float</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long double</code> <strong class="def-name">__builtin_nansl</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">long double</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansfn">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var></code> <strong class="def-name">__builtin_nansf<var class="var">n</var></strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">_Float<var class="var">n</var></code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fnansfnx">
<span class="category-def">Built-in Function: </span><span><code class="def-type">_Float<var class="var">n</var>x</code> <strong class="def-name">__builtin_nansf<var class="var">n</var>x</strong> <code class="def-code-arguments">(const char *<var class="var">str</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_nans</code>, except the return type is <code class="code">_Float<var class="var">n</var>x</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fissignaling">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_issignaling</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Return non-zero if the argument is a signaling NaN and zero otherwise. Note while the parameter list is an ellipsis, this function only accepts exactly one floating-point argument. GCC treats this parameter as type-generic, which means it does not do default promotion from float to double. This built-in function can work even without the non-default <code class="code">-fsignaling-nans</code> option, although if a signaling NaN is computed, stored or passed as argument to some function other than this built-in in the current translation unit, it is safer to use <code class="code">-fsignaling-nans</code>. With <code class="code">-ffinite-math-only</code> option this built-in function will always return 0. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fffs">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ffs</strong> <code class="def-code-arguments">(int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns one plus the index of the least significant 1-bit of <var class="var">x</var>, or if <var class="var">x</var> is zero, returns zero. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclz">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clz</strong> <code class="def-code-arguments">(unsigned int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the number of leading 0-bits in <var class="var">x</var>, starting at the most significant bit position. If <var class="var">x</var> is 0, the result is undefined. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fctz">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ctz</strong> <code class="def-code-arguments">(unsigned int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the number of trailing 0-bits in <var class="var">x</var>, starting at the least significant bit position. If <var class="var">x</var> is 0, the result is undefined. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclrsb">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clrsb</strong> <code class="def-code-arguments">(int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the number of leading redundant sign bits in <var class="var">x</var>, i.e. the number of bits following the most significant bit that are identical to it. There are no special cases for 0 or other values. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fpopcount">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_popcount</strong> <code class="def-code-arguments">(unsigned int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the number of 1-bits in <var class="var">x</var>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fparity">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_parity</strong> <code class="def-code-arguments">(unsigned int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the parity of <var class="var">x</var>, i.e. the number of 1-bits in <var class="var">x</var> modulo 2. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fffsl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ffsl</strong> <code class="def-code-arguments">(long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ffs</code>, except the argument type is <code class="code">long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclzl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clzl</strong> <code class="def-code-arguments">(unsigned long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clz</code>, except the argument type is <code class="code">unsigned long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fctzl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ctzl</strong> <code class="def-code-arguments">(unsigned long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ctz</code>, except the argument type is <code class="code">unsigned long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclrsbl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clrsbl</strong> <code class="def-code-arguments">(long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clrsb</code>, except the argument type is <code class="code">long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fpopcountl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_popcountl</strong> <code class="def-code-arguments">(unsigned long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_popcount</code>, except the argument type is <code class="code">unsigned long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fparityl">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_parityl</strong> <code class="def-code-arguments">(unsigned long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_parity</code>, except the argument type is <code class="code">unsigned long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fffsll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ffsll</strong> <code class="def-code-arguments">(long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ffs</code>, except the argument type is <code class="code">long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclzll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clzll</strong> <code class="def-code-arguments">(unsigned long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clz</code>, except the argument type is <code class="code">unsigned long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fctzll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ctzll</strong> <code class="def-code-arguments">(unsigned long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ctz</code>, except the argument type is <code class="code">unsigned long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclrsbll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clrsbll</strong> <code class="def-code-arguments">(long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clrsb</code>, except the argument type is <code class="code">long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fpopcountll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_popcountll</strong> <code class="def-code-arguments">(unsigned long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_popcount</code>, except the argument type is <code class="code">unsigned long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fparityll">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_parityll</strong> <code class="def-code-arguments">(unsigned long long)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_parity</code>, except the argument type is <code class="code">unsigned long long</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fffsg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ffsg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ffs</code>, except the argument is type-generic signed integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclzg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clzg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clz</code>, except the argument is type-generic unsigned integer (standard, extended or bit-precise) and there is optional second argument with int type. No integral argument promotions are performed on the first argument. If two arguments are specified, and first argument is 0, the result is the second argument. If only one argument is specified and it is 0, the result is undefined. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fctzg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_ctzg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_ctz</code>, except the argument is type-generic unsigned integer (standard, extended or bit-precise) and there is optional second argument with int type. No integral argument promotions are performed on the first argument. If two arguments are specified, and first argument is 0, the result is the second argument. If only one argument is specified and it is 0, the result is undefined. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fclrsbg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_clrsbg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_clrsb</code>, except the argument is type-generic signed integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fpopcountg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_popcountg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_popcount</code>, except the argument is type-generic unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fparityg">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_parityg</strong> <code class="def-code-arguments">(...)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_parity</code>, except the argument is type-generic unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fbit_005fceil">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_stdc_bit_ceil</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_bit_ceil</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code"><var class="var">arg</var> &lt;= 1 ? (<var class="var">type</var>) 1
: (<var class="var">type</var>) 2 &lt;&lt; (<var class="var">prec</var> - 1 - __builtin_clzg ((<var class="var">type</var>) (<var class="var">arg</var> - 1)))</code> where <var class="var">prec</var> is bit width of <var class="var">type</var>, except that side-effects in <var class="var">arg</var> are evaluated just once. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fbit_005ffloor">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_stdc_bit_floor</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_bit_floor</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code"><var class="var">arg</var> == 0 ? (<var class="var">type</var>) 0
: (<var class="var">type</var>) 1 &lt;&lt; (<var class="var">prec</var> - 1 - __builtin_clzg (<var class="var">arg</var>))</code> where <var class="var">prec</var> is bit width of <var class="var">type</var>, except that side-effects in <var class="var">arg</var> are evaluated just once. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fbit_005fwidth">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_bit_width</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_bit_width</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) (<var class="var">prec</var> - __builtin_clzg (<var class="var">arg</var>, <var class="var">prec</var>))</code> where <var class="var">prec</var> is bit width of <var class="var">type</var>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fcount_005fones">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_count_ones</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_count_ones</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_popcountg (<var class="var">arg</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fcount_005fzeros">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_count_zeros</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_count_zeros</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_popcountg ((<var class="var">type</var>) ~<var class="var">arg</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ffirst_005fleading_005fone">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_first_leading_one</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_first_leading_one</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">__builtin_clzg (<var class="var">arg</var>, -1) + 1U</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ffirst_005fleading_005fzero">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_first_leading_zero</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_first_leading_zero</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">__builtin_clzg ((<var class="var">type</var>) ~<var class="var">arg</var>, -1) + 1U</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ffirst_005ftrailing_005fone">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_first_trailing_one</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_first_trailing_one</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">__builtin_ctzg (<var class="var">arg</var>, -1) + 1U</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ffirst_005ftrailing_005fzero">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_first_trailing_zero</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_first_trailing_zero</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">__builtin_ctzg ((<var class="var">type</var>) ~<var class="var">arg</var>, -1) + 1U</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fhas_005fsingle_005fbit">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_has_single_bit</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_has_single_bit</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(_Bool) (__builtin_popcountg (<var class="var">arg</var>) == 1)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fleading_005fones">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_leading_ones</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_leading_ones</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_clzg ((<var class="var">type</var>) ~<var class="var">arg</var>, <var class="var">prec</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005fleading_005fzeros">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_leading_zeros</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_leading_zeros</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_clzg (<var class="var">arg</var>, <var class="var">prec</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ftrailing_005fones">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_trailing_ones</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_trailing_ones</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_ctzg ((<var class="var">type</var>) ~<var class="var">arg</var>, <var class="var">prec</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fstdc_005ftrailing_005fzeros">
<span class="category-def">Built-in Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">__builtin_stdc_trailing_zeros</strong> <code class="def-code-arguments">(<var class="var">type</var> <var class="var">arg</var>)</code></span>
</dt> <dd><p>The <code class="code">__builtin_stdc_trailing_zeros</code> function is available only in C. It is type-generic, the argument can be any unsigned integer (standard, extended or bit-precise). No integral argument promotions are performed on the argument. It is equivalent to <code class="code">(unsigned int) __builtin_ctzg (<var class="var">arg</var>, <var class="var">prec</var>)</code> </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fpowi">
<span class="category-def">Built-in Function: </span><span><code class="def-type">double</code> <strong class="def-name">__builtin_powi</strong> <code class="def-code-arguments">(double, int)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005fpowif">
<span class="category-def">Built-in Function: </span><span><code class="def-type">float</code> <strong class="def-name">__builtin_powif</strong> <code class="def-code-arguments">(float, int)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005fpowil">
<span class="category-def">Built-in Function: </span><span><code class="def-type">long double</code> <strong class="def-name">__builtin_powil</strong> <code class="def-code-arguments">(long double, int)</code></span>
</dt> <dd><p>Returns the first argument raised to the power of the second. Unlike the <code class="code">pow</code> function no guarantees about precision and rounding are made. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fbswap16">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint16_t</code> <strong class="def-name">__builtin_bswap16</strong> <code class="def-code-arguments">(uint16_t <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns <var class="var">x</var> with the order of the bytes reversed; for example, <code class="code">0xaabb</code> becomes <code class="code">0xbbaa</code>. Byte here always means exactly 8 bits. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fbswap32">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint32_t</code> <strong class="def-name">__builtin_bswap32</strong> <code class="def-code-arguments">(uint32_t <var class="var">x</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_bswap16</code>, except the argument and return types are 32-bit. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fbswap64">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint64_t</code> <strong class="def-name">__builtin_bswap64</strong> <code class="def-code-arguments">(uint64_t <var class="var">x</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_bswap32</code>, except the argument and return types are 64-bit. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fbswap128">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint128_t</code> <strong class="def-name">__builtin_bswap128</strong> <code class="def-code-arguments">(uint128_t <var class="var">x</var>)</code></span>
</dt> <dd><p>Similar to <code class="code">__builtin_bswap64</code>, except the argument and return types are 128-bit. Only supported on targets when 128-bit types are supported. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fextend_005fpointer">
<span class="category-def">Built-in Function: </span><span><code class="def-type">Pmode</code> <strong class="def-name">__builtin_extend_pointer</strong> <code class="def-code-arguments">(void * <var class="var">x</var>)</code></span>
</dt> <dd><p>On targets where the user visible pointer size is smaller than the size of an actual hardware address this function returns the extended user pointer. Targets where this is true included ILP32 mode on x86_64 or Aarch64. This function is mainly useful when writing inline assembly code. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fid">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_goacc_parlevel_id</strong> <code class="def-code-arguments">(int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the openacc gang, worker or vector id depending on whether <var class="var">x</var> is 0, 1 or 2. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fgoacc_005fparlevel_005fsize">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int</code> <strong class="def-name">__builtin_goacc_parlevel_size</strong> <code class="def-code-arguments">(int <var class="var">x</var>)</code></span>
</dt> <dd><p>Returns the openacc gang, worker or vector size depending on whether <var class="var">x</var> is 0, 1 or 2. </p></dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Other-Builtins.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Other-Builtins.html</a>
  </p>
</div>
