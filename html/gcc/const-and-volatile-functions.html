<h1 class="section" id="Const-and-Volatile-Functions-1">6.46 Const and Volatile Functions</h1> <div class="section-level-extent" id="Const-and-Volatile-Functions">      <p>The C standard explicitly leaves the behavior of the <code class="code">const</code> and <code class="code">volatile</code> type qualifiers applied to functions undefined; these constructs can only arise through the use of <code class="code">typedef</code>. As an extension, GCC defines this use of the <code class="code">const</code> qualifier to have the same meaning as the GCC <code class="code">const</code> function attribute, and the <code class="code">volatile</code> qualifier to be equivalent to the <code class="code">noreturn</code> attribute. See <a class="xref" href="common-function-attributes.html">Common Function Attributes</a>, for more information. </p> <p>As examples of this usage, </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">/* <span class="r">Equivalent to:</span>
   void fatal () __attribute__ ((noreturn));  */
typedef void voidfn ();
volatile voidfn fatal;

/* <span class="r">Equivalent to:</span>
   extern int square (int) __attribute__ ((const));  */
typedef int intfn (int);
extern const intfn square;</pre>
</div> <p>In general, using function attributes instead is preferred, since the attributes make both the intent of the code and its reliance on a GNU extension explicit. Additionally, using <code class="code">const</code> and <code class="code">volatile</code> in this way is specific to GNU C and does not work in GNU C++. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Const-and-Volatile-Functions.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Const-and-Volatile-Functions.html</a>
  </p>
</div>
