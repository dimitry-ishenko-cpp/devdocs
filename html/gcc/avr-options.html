<h1 class="subsection" id="AVR-Options-1">3.19.6 AVR Options</h1> <div class="subsection-level-extent" id="AVR-Options">     <p>These options are defined for AVR implementations: </p> <dl class="table"> <dt>
<span><code class="code">-mmcu=<var class="var">mcu</var></code></span>
</dt> <dd>
<p>Specify the AVR instruction set architecture (ISA) or device type. The default for this option is <code class="code">avr2</code>. </p> <p>The following AVR devices and ISAs are supported. <em class="emph">Note:</em> A complete device support consists of startup code <code class="code">crt<var class="var">mcu</var>.o</code>, a device header <code class="code">avr/io*.h</code>, a device library <code class="code">lib<var class="var">mcu</var>.a</code> and a <a class="uref" href="https://gcc.gnu.org/wiki/avr-gcc#spec-files">device-specs</a> file <code class="code">specs-<var class="var">mcu</var></code>. Only the latter is provided by the compiler according the supported <code class="code"><var class="var">mcu</var></code>s below. The rest is supported by <a class="uref" href="https://www.nongnu.org/avr-libc/">AVR-LibC</a>, or by means of <a class="uref" href="https://gcc.gnu.org/wiki/avr-gcc#atpack"><code class="code">atpack</code></a> files from the hardware manufacturer. </p> <dl class="table"> <dt><code class="code">avr2</code></dt> <dd>
<p>“Classic” devices with up to 8 KiB of program memory. <var class="var">mcu</var> = <code class="code">attiny22</code>, <code class="code">attiny26</code>, <code class="code">at90s2313</code>, <code class="code">at90s2323</code>, <code class="code">at90s2333</code>, <code class="code">at90s2343</code>, <code class="code">at90s4414</code>, <code class="code">at90s4433</code>, <code class="code">at90s4434</code>, <code class="code">at90c8534</code>, <code class="code">at90s8515</code>, <code class="code">at90s8535</code>. </p> </dd> <dt><code class="code">avr25</code></dt> <dd>
<p>“Classic” devices with up to 8 KiB of program memory and with the <code class="code">MOVW</code> instruction. <var class="var">mcu</var> = <code class="code">attiny13</code>, <code class="code">attiny13a</code>, <code class="code">attiny24</code>, <code class="code">attiny24a</code>, <code class="code">attiny25</code>, <code class="code">attiny261</code>, <code class="code">attiny261a</code>, <code class="code">attiny2313</code>, <code class="code">attiny2313a</code>, <code class="code">attiny43u</code>, <code class="code">attiny44</code>, <code class="code">attiny44a</code>, <code class="code">attiny45</code>, <code class="code">attiny48</code>, <code class="code">attiny441</code>, <code class="code">attiny461</code>, <code class="code">attiny461a</code>, <code class="code">attiny4313</code>, <code class="code">attiny84</code>, <code class="code">attiny84a</code>, <code class="code">attiny85</code>, <code class="code">attiny87</code>, <code class="code">attiny88</code>, <code class="code">attiny828</code>, <code class="code">attiny841</code>, <code class="code">attiny861</code>, <code class="code">attiny861a</code>, <code class="code">ata5272</code>, <code class="code">ata6616c</code>, <code class="code">at86rf401</code>. </p> </dd> <dt><code class="code">avr3</code></dt> <dd>
<p>“Classic” devices with 16 KiB up to 64 KiB of program memory. <var class="var">mcu</var> = <code class="code">at76c711</code>, <code class="code">at43usb355</code>. </p> </dd> <dt><code class="code">avr31</code></dt> <dd>
<p>“Classic” devices with 128 KiB of program memory. <var class="var">mcu</var> = <code class="code">atmega103</code>, <code class="code">at43usb320</code>. </p> </dd> <dt><code class="code">avr35</code></dt> <dd>
<p>“Classic” devices with 16 KiB up to 64 KiB of program memory and with the <code class="code">MOVW</code> instruction. <var class="var">mcu</var> = <code class="code">attiny167</code>, <code class="code">attiny1634</code>, <code class="code">atmega8u2</code>, <code class="code">atmega16u2</code>, <code class="code">atmega32u2</code>, <code class="code">ata5505</code>, <code class="code">ata6617c</code>, <code class="code">ata664251</code>, <code class="code">at90usb82</code>, <code class="code">at90usb162</code>. </p> </dd> <dt><code class="code">avr4</code></dt> <dd>
<p>“Enhanced” devices with up to 8 KiB of program memory. <var class="var">mcu</var> = <code class="code">atmega48</code>, <code class="code">atmega48a</code>, <code class="code">atmega48p</code>, <code class="code">atmega48pa</code>, <code class="code">atmega48pb</code>, <code class="code">atmega8</code>, <code class="code">atmega8a</code>, <code class="code">atmega8hva</code>, <code class="code">atmega88</code>, <code class="code">atmega88a</code>, <code class="code">atmega88p</code>, <code class="code">atmega88pa</code>, <code class="code">atmega88pb</code>, <code class="code">atmega8515</code>, <code class="code">atmega8535</code>, <code class="code">ata5795</code>, <code class="code">ata6285</code>, <code class="code">ata6286</code>, <code class="code">ata6289</code>, <code class="code">ata6612c</code>, <code class="code">at90pwm1</code>, <code class="code">at90pwm2</code>, <code class="code">at90pwm2b</code>, <code class="code">at90pwm3</code>, <code class="code">at90pwm3b</code>, <code class="code">at90pwm81</code>. </p> </dd> <dt><code class="code">avr5</code></dt> <dd>
<p>“Enhanced” devices with 16 KiB up to 64 KiB of program memory. <var class="var">mcu</var> = <code class="code">atmega16</code>, <code class="code">atmega16a</code>, <code class="code">atmega16hva</code>, <code class="code">atmega16hva2</code>, <code class="code">atmega16hvb</code>, <code class="code">atmega16hvbrevb</code>, <code class="code">atmega16m1</code>, <code class="code">atmega16u4</code>, <code class="code">atmega161</code>, <code class="code">atmega162</code>, <code class="code">atmega163</code>, <code class="code">atmega164a</code>, <code class="code">atmega164p</code>, <code class="code">atmega164pa</code>, <code class="code">atmega165</code>, <code class="code">atmega165a</code>, <code class="code">atmega165p</code>, <code class="code">atmega165pa</code>, <code class="code">atmega168</code>, <code class="code">atmega168a</code>, <code class="code">atmega168p</code>, <code class="code">atmega168pa</code>, <code class="code">atmega168pb</code>, <code class="code">atmega169</code>, <code class="code">atmega169a</code>, <code class="code">atmega169p</code>, <code class="code">atmega169pa</code>, <code class="code">atmega32</code>, <code class="code">atmega32a</code>, <code class="code">atmega32c1</code>, <code class="code">atmega32hvb</code>, <code class="code">atmega32hvbrevb</code>, <code class="code">atmega32m1</code>, <code class="code">atmega32u4</code>, <code class="code">atmega32u6</code>, <code class="code">atmega323</code>, <code class="code">atmega324a</code>, <code class="code">atmega324p</code>, <code class="code">atmega324pa</code>, <code class="code">atmega324pb</code>, <code class="code">atmega325</code>, <code class="code">atmega325a</code>, <code class="code">atmega325p</code>, <code class="code">atmega325pa</code>, <code class="code">atmega328</code>, <code class="code">atmega328p</code>, <code class="code">atmega328pb</code>, <code class="code">atmega329</code>, <code class="code">atmega329a</code>, <code class="code">atmega329p</code>, <code class="code">atmega329pa</code>, <code class="code">atmega3250</code>, <code class="code">atmega3250a</code>, <code class="code">atmega3250p</code>, <code class="code">atmega3250pa</code>, <code class="code">atmega3290</code>, <code class="code">atmega3290a</code>, <code class="code">atmega3290p</code>, <code class="code">atmega3290pa</code>, <code class="code">atmega406</code>, <code class="code">atmega64</code>, <code class="code">atmega64a</code>, <code class="code">atmega64c1</code>, <code class="code">atmega64hve</code>, <code class="code">atmega64hve2</code>, <code class="code">atmega64m1</code>, <code class="code">atmega64rfr2</code>, <code class="code">atmega640</code>, <code class="code">atmega644</code>, <code class="code">atmega644a</code>, <code class="code">atmega644p</code>, <code class="code">atmega644pa</code>, <code class="code">atmega644rfr2</code>, <code class="code">atmega645</code>, <code class="code">atmega645a</code>, <code class="code">atmega645p</code>, <code class="code">atmega649</code>, <code class="code">atmega649a</code>, <code class="code">atmega649p</code>, <code class="code">atmega6450</code>, <code class="code">atmega6450a</code>, <code class="code">atmega6450p</code>, <code class="code">atmega6490</code>, <code class="code">atmega6490a</code>, <code class="code">atmega6490p</code>, <code class="code">ata5790</code>, <code class="code">ata5790n</code>, <code class="code">ata5791</code>, <code class="code">ata6613c</code>, <code class="code">ata6614q</code>, <code class="code">ata5782</code>, <code class="code">ata5831</code>, <code class="code">ata8210</code>, <code class="code">ata8510</code>, <code class="code">ata5787</code>, <code class="code">ata5835</code>, <code class="code">ata5700m322</code>, <code class="code">ata5702m322</code>, <code class="code">at90pwm161</code>, <code class="code">at90pwm216</code>, <code class="code">at90pwm316</code>, <code class="code">at90can32</code>, <code class="code">at90can64</code>, <code class="code">at90scr100</code>, <code class="code">at90usb646</code>, <code class="code">at90usb647</code>, <code class="code">at94k</code>, <code class="code">m3000</code>. </p> </dd> <dt><code class="code">avr51</code></dt> <dd>
<p>“Enhanced” devices with 128 KiB of program memory. <var class="var">mcu</var> = <code class="code">atmega128</code>, <code class="code">atmega128a</code>, <code class="code">atmega128rfa1</code>, <code class="code">atmega128rfr2</code>, <code class="code">atmega1280</code>, <code class="code">atmega1281</code>, <code class="code">atmega1284</code>, <code class="code">atmega1284p</code>, <code class="code">atmega1284rfr2</code>, <code class="code">at90can128</code>, <code class="code">at90usb1286</code>, <code class="code">at90usb1287</code>. </p> </dd> <dt><code class="code">avr6</code></dt> <dd>
<p>“Enhanced” devices with 3-byte PC, i.e. with more than 128 KiB of program memory. <var class="var">mcu</var> = <code class="code">atmega256rfr2</code>, <code class="code">atmega2560</code>, <code class="code">atmega2561</code>, <code class="code">atmega2564rfr2</code>. </p> </dd> <dt><code class="code">avrxmega2</code></dt> <dd>
<p>“XMEGA” devices with more than 8 KiB and up to 64 KiB of program memory. <var class="var">mcu</var> = <code class="code">atxmega8e5</code>, <code class="code">atxmega16a4</code>, <code class="code">atxmega16a4u</code>, <code class="code">atxmega16c4</code>, <code class="code">atxmega16d4</code>, <code class="code">atxmega16e5</code>, <code class="code">atxmega32a4</code>, <code class="code">atxmega32a4u</code>, <code class="code">atxmega32c3</code>, <code class="code">atxmega32c4</code>, <code class="code">atxmega32d3</code>, <code class="code">atxmega32d4</code>, <code class="code">atxmega32e5</code>, <code class="code">avr64da28</code>, <code class="code">avr64da32</code>, <code class="code">avr64da48</code>, <code class="code">avr64da64</code>, <code class="code">avr64db28</code>, <code class="code">avr64db32</code>, <code class="code">avr64db48</code>, <code class="code">avr64db64</code>, <code class="code">avr64dd14</code>, <code class="code">avr64dd20</code>, <code class="code">avr64dd28</code>, <code class="code">avr64dd32</code>, <code class="code">avr64du28</code>, <code class="code">avr64du32</code>, <code class="code">avr64ea28</code>, <code class="code">avr64ea32</code>, <code class="code">avr64ea48</code>. </p> </dd> <dt><code class="code">avrxmega3</code></dt> <dd>
<p>“XMEGA” devices with up to 64 KiB of combined program memory and RAM, and with program memory visible in the RAM address space. <var class="var">mcu</var> = <code class="code">attiny202</code>, <code class="code">attiny204</code>, <code class="code">attiny212</code>, <code class="code">attiny214</code>, <code class="code">attiny402</code>, <code class="code">attiny404</code>, <code class="code">attiny406</code>, <code class="code">attiny412</code>, <code class="code">attiny414</code>, <code class="code">attiny416</code>, <code class="code">attiny416auto</code>, <code class="code">attiny417</code>, <code class="code">attiny424</code>, <code class="code">attiny426</code>, <code class="code">attiny427</code>, <code class="code">attiny804</code>, <code class="code">attiny806</code>, <code class="code">attiny807</code>, <code class="code">attiny814</code>, <code class="code">attiny816</code>, <code class="code">attiny817</code>, <code class="code">attiny824</code>, <code class="code">attiny826</code>, <code class="code">attiny827</code>, <code class="code">attiny1604</code>, <code class="code">attiny1606</code>, <code class="code">attiny1607</code>, <code class="code">attiny1614</code>, <code class="code">attiny1616</code>, <code class="code">attiny1617</code>, <code class="code">attiny1624</code>, <code class="code">attiny1626</code>, <code class="code">attiny1627</code>, <code class="code">attiny3214</code>, <code class="code">attiny3216</code>, <code class="code">attiny3217</code>, <code class="code">attiny3224</code>, <code class="code">attiny3226</code>, <code class="code">attiny3227</code>, <code class="code">atmega808</code>, <code class="code">atmega809</code>, <code class="code">atmega1608</code>, <code class="code">atmega1609</code>, <code class="code">atmega3208</code>, <code class="code">atmega3209</code>, <code class="code">atmega4808</code>, <code class="code">atmega4809</code>, <code class="code">avr16dd14</code>, <code class="code">avr16dd20</code>, <code class="code">avr16dd28</code>, <code class="code">avr16dd32</code>, <code class="code">avr16du14</code>, <code class="code">avr16du20</code>, <code class="code">avr16du28</code>, <code class="code">avr16du32</code>, <code class="code">avr16ea28</code>, <code class="code">avr16ea32</code>, <code class="code">avr16ea48</code>, <code class="code">avr16eb14</code>, <code class="code">avr16eb20</code>, <code class="code">avr16eb28</code>, <code class="code">avr16eb32</code>, <code class="code">avr32da28</code>, <code class="code">avr32da32</code>, <code class="code">avr32da48</code>, <code class="code">avr32db28</code>, <code class="code">avr32db32</code>, <code class="code">avr32db48</code>, <code class="code">avr32dd14</code>, <code class="code">avr32dd20</code>, <code class="code">avr32dd28</code>, <code class="code">avr32dd32</code>, <code class="code">avr32du14</code>, <code class="code">avr32du20</code>, <code class="code">avr32du28</code>, <code class="code">avr32du32</code>, <code class="code">avr32ea28</code>, <code class="code">avr32ea32</code>, <code class="code">avr32ea48</code>. </p> </dd> <dt><code class="code">avrxmega4</code></dt> <dd>
<p>“XMEGA” devices with more than 64 KiB and up to 128 KiB of program memory. <var class="var">mcu</var> = <code class="code">atxmega64a3</code>, <code class="code">atxmega64a3u</code>, <code class="code">atxmega64a4u</code>, <code class="code">atxmega64b1</code>, <code class="code">atxmega64b3</code>, <code class="code">atxmega64c3</code>, <code class="code">atxmega64d3</code>, <code class="code">atxmega64d4</code>, <code class="code">avr128da28</code>, <code class="code">avr128da32</code>, <code class="code">avr128da48</code>, <code class="code">avr128da64</code>, <code class="code">avr128db28</code>, <code class="code">avr128db32</code>, <code class="code">avr128db48</code>, <code class="code">avr128db64</code>. </p> </dd> <dt><code class="code">avrxmega5</code></dt> <dd>
<p>“XMEGA” devices with more than 64 KiB and up to 128 KiB of program memory and more than 64 KiB of RAM. <var class="var">mcu</var> = <code class="code">atxmega64a1</code>, <code class="code">atxmega64a1u</code>. </p> </dd> <dt><code class="code">avrxmega6</code></dt> <dd>
<p>“XMEGA” devices with more than 128 KiB of program memory. <var class="var">mcu</var> = <code class="code">atxmega128a3</code>, <code class="code">atxmega128a3u</code>, <code class="code">atxmega128b1</code>, <code class="code">atxmega128b3</code>, <code class="code">atxmega128c3</code>, <code class="code">atxmega128d3</code>, <code class="code">atxmega128d4</code>, <code class="code">atxmega192a3</code>, <code class="code">atxmega192a3u</code>, <code class="code">atxmega192c3</code>, <code class="code">atxmega192d3</code>, <code class="code">atxmega256a3</code>, <code class="code">atxmega256a3b</code>, <code class="code">atxmega256a3bu</code>, <code class="code">atxmega256a3u</code>, <code class="code">atxmega256c3</code>, <code class="code">atxmega256d3</code>, <code class="code">atxmega384c3</code>, <code class="code">atxmega384d3</code>. </p> </dd> <dt><code class="code">avrxmega7</code></dt> <dd>
<p>“XMEGA” devices with more than 128 KiB of program memory and more than 64 KiB of RAM. <var class="var">mcu</var> = <code class="code">atxmega128a1</code>, <code class="code">atxmega128a1u</code>, <code class="code">atxmega128a4u</code>. </p> </dd> <dt><code class="code">avrtiny</code></dt> <dd>
<p>“Reduced Tiny” Tiny core devices with only 16 general purpose registers and 512 B up to 4 KiB of program memory. <var class="var">mcu</var> = <code class="code">attiny4</code>, <code class="code">attiny5</code>, <code class="code">attiny9</code>, <code class="code">attiny10</code>, <code class="code">attiny102</code>, <code class="code">attiny104</code>, <code class="code">attiny20</code>, <code class="code">attiny40</code>. </p> </dd> <dt><code class="code">avr1</code></dt> <dd>
<p>This ISA is implemented by the minimal AVR core and supported for assembler only. <var class="var">mcu</var> = <code class="code">attiny11</code>, <code class="code">attiny12</code>, <code class="code">attiny15</code>, <code class="code">attiny28</code>, <code class="code">at90s1200</code>. </p> </dd> </dl> </dd> <dt>
<span><code class="code">-mabsdata</code></span>
</dt> <dd> <p>Assume that all data in static storage can be accessed by LDS / STS instructions. This option has only an effect on reduced Tiny devices like ATtiny40. See also the <code class="code">absdata</code> <a class="ref" href="variable-attributes.html">variable attribute</a>. </p> </dd> <dt>
<span><code class="code">-maccumulate-args</code></span>
</dt> <dd>
<p>Accumulate outgoing function arguments and acquire/release the needed stack space for outgoing function arguments once in function prologue/epilogue. Without this option, outgoing arguments are pushed before calling a function and popped afterwards. </p> <p>Popping the arguments after the function call can be expensive on AVR so that accumulating the stack space might lead to smaller executables because arguments need not be removed from the stack after such a function call. </p> <p>This option can lead to reduced code size for functions that perform several calls to functions that get their arguments on the stack like calls to printf-like functions. </p> </dd> <dt>
<span><code class="code">-mbranch-cost=<var class="var">cost</var></code></span>
</dt> <dd>
<p>Set the branch costs for conditional branch instructions to <var class="var">cost</var>. Reasonable values for <var class="var">cost</var> are small, non-negative integers. The default branch cost is 0. </p> </dd> <dt>
<span><code class="code">-mcall-prologues</code></span>
</dt> <dd>
<p>Functions prologues/epilogues are expanded as calls to appropriate subroutines. Code size is smaller. </p> </dd> <dt>
<span><code class="code">-mfuse-add</code></span>
</dt> <dt><code class="code">-mno-fuse-add</code></dt> <dt><code class="code">-mfuse-add=<var class="var">level</var></code></dt> <dd>
<p>Optimize indirect memory accesses on reduced Tiny devices. The default uses <code class="code"><var class="var">level</var>=1</code> for optimizations <samp class="option">-Og</samp> and <samp class="option">-O1</samp>, and <code class="code"><var class="var">level</var>=2</code> for higher optimizations. Valid values for <var class="var">level</var> are <code class="code">0</code>, <code class="code">1</code> and <code class="code">2</code>. </p> </dd> <dt>
 <span><code class="code">-mdouble=<var class="var">bits</var></code></span>
</dt> <dt><code class="code">-mlong-double=<var class="var">bits</var></code></dt> <dd>
<p>Set the size (in bits) of the <code class="code">double</code> or <code class="code">long double</code> type, respectively. Possible values for <var class="var">bits</var> are 32 and 64. Whether or not a specific value for <var class="var">bits</var> is allowed depends on the <code class="code">--with-double=</code> and <code class="code">--with-long-double=</code> <a class="uref" href="https://gcc.gnu.org/install/configure.html#avr">configure options</a>, and the same applies for the default values of the options. </p> </dd> <dt>
<span><code class="code">-mgas-isr-prologues</code></span>
</dt> <dd>
<p>Interrupt service routines (ISRs) may use the <code class="code">__gcc_isr</code> pseudo instruction supported by GNU Binutils. If this option is on, the feature can still be disabled for individual ISRs by means of the <a class="ref" href="avr-function-attributes.html"><code class="code">no_gccisr</code></a> function attribute. This feature is activated per default if optimization is on (but not with <samp class="option">-Og</samp>, see <a class="pxref" href="optimize-options.html">Options That Control Optimization</a>), and if GNU Binutils support <a class="uref" href="https://sourceware.org/PR21683">PR21683</a>. </p> </dd> <dt>
<span><code class="code">-mint8</code></span>
</dt> <dd>
<p>Assume <code class="code">int</code> to be 8-bit integer. This affects the sizes of all types: a <code class="code">char</code> is 1 byte, an <code class="code">int</code> is 1 byte, a <code class="code">long</code> is 2 bytes, and <code class="code">long long</code> is 4 bytes. Please note that this option does not conform to the C standards, but it results in smaller code size. </p> </dd> <dt>
<span><code class="code">-mmain-is-OS_task</code></span>
</dt> <dd>
<p>Do not save registers in <code class="code">main</code>. The effect is the same like attaching attribute <a class="ref" href="avr-function-attributes.html"><code class="code">OS_task</code></a> to <code class="code">main</code>. It is activated per default if optimization is on. </p> </dd> <dt>
<span><code class="code">-mno-interrupts</code></span>
</dt> <dd>
<p>Generated code is not compatible with hardware interrupts. Code size is smaller. </p> </dd> <dt>
<span><code class="code">-mrelax</code></span>
</dt> <dd>
<p>Try to replace <code class="code">CALL</code> resp. <code class="code">JMP</code> instruction by the shorter <code class="code">RCALL</code> resp. <code class="code">RJMP</code> instruction if applicable. Setting <samp class="option">-mrelax</samp> just adds the <samp class="option">--mlink-relax</samp> option to the assembler’s command line and the <samp class="option">--relax</samp> option to the linker’s command line. </p> <p>Jump relaxing is performed by the linker because jump offsets are not known before code is located. Therefore, the assembler code generated by the compiler is the same, but the instructions in the executable may differ from instructions in the assembler code. </p> <p>Relaxing must be turned on if linker stubs are needed, see the section on <code class="code">EIND</code> and linker stubs below. </p> </dd> <dt>
<span><code class="code">-mrodata-in-ram</code></span>
</dt> <dt><code class="code">-mno-rodata-in-ram</code></dt> <dd>
<p>Locate the <code class="code">.rodata</code> sections for read-only data in RAM resp. in program memory. For most devices, there is no choice and this option acts rather like an assertion. </p> <p>Since v14 and for the AVR64* and AVR128* devices, <code class="code">.rodata</code> is located in flash memory per default, provided the required GNU Binutils support (<a class="uref" href="https://sourceware.org/PR31124">PR31124</a>) is available. In that case, <samp class="option">-mrodata-in-ram</samp> can be used to return to the old layout with <code class="code">.rodata</code> in RAM. </p> </dd> <dt>
<span><code class="code">-mstrict-X</code></span>
</dt> <dd>
<p>Use address register <code class="code">X</code> in a way proposed by the hardware. This means that <code class="code">X</code> is only used in indirect, post-increment or pre-decrement addressing. </p> <p>Without this option, the <code class="code">X</code> register may be used in the same way as <code class="code">Y</code> or <code class="code">Z</code> which then is emulated by additional instructions. For example, loading a value with <code class="code">X+const</code> addressing with a small non-negative <code class="code">const &lt; 64</code> to a register <var class="var">Rn</var> is performed as </p> <div class="example"> <pre class="example-preformatted" data-language="cpp">adiw r26, const   ; X += const
ld   <var class="var">Rn</var>, X        ; <var class="var">Rn</var> = *X
sbiw r26, const   ; X -= const</pre>
</div> </dd> <dt>
<span><code class="code">-mtiny-stack</code></span>
</dt> <dd>
<p>Only change the lower 8 bits of the stack pointer. </p> </dd> <dt>
<span><code class="code">-mfract-convert-truncate</code></span>
</dt> <dd>
<p>Allow to use truncation instead of rounding towards zero for fractional fixed-point types. </p> </dd> <dt>
<span><code class="code">-nodevicelib</code></span>
</dt> <dd>
<p>Don’t link against AVR-LibC’s device specific library <code class="code">lib&lt;mcu&gt;.a</code>. </p> </dd> <dt>
<span><code class="code">-nodevicespecs</code></span>
</dt> <dd>
<p>Don’t add <samp class="option">-specs=device-specs/specs-<var class="var">mcu</var></samp> to the compiler driver’s command line. The user takes responsibility for supplying the sub-processes like compiler proper, assembler and linker with appropriate command line options. This means that the user has to supply her private device specs file by means of <samp class="option">-specs=<var class="var">path-to-specs-file</var></samp>. There is no more need for option <samp class="option">-mmcu=<var class="var">mcu</var></samp>. </p> <p>This option can also serve as a replacement for the older way of specifying custom device-specs files that needed <samp class="option">-B <var class="var">some-path</var></samp> to point to a directory which contains a folder named <code class="code">device-specs</code> which contains a specs file named <code class="code">specs-<var class="var">mcu</var></code>, where <var class="var">mcu</var> was specified by <samp class="option">-mmcu=<var class="var">mcu</var></samp>. </p> </dd> <dt>
 <span><code class="code">-Waddr-space-convert</code></span>
</dt> <dd>
<p>Warn about conversions between address spaces in the case where the resulting address space is not contained in the incoming address space. </p> </dd> <dt>
 <span><code class="code">-Wmisspelled-isr</code></span>
</dt> <dd><p>Warn if the ISR is misspelled, i.e. without __vector prefix. Enabled by default. </p></dd> </dl> <ul class="mini-toc"> <li><a href="#EIND-and-Devices-with-More-Than-128-Ki-Bytes-of-Flash" accesskey="1"><code class="code">EIND</code> and Devices with More Than 128 Ki Bytes of Flash</a></li> <li><a href="#Handling-of-the-RAMPD_002c-RAMPX_002c-RAMPY-and-RAMPZ-Special-Function-Registers" accesskey="2">Handling of the <code class="code">RAMPD</code>, <code class="code">RAMPX</code>, <code class="code">RAMPY</code> and <code class="code">RAMPZ</code> Special Function Registers</a></li> <li><a href="#AVR-Built_002din-Macros" accesskey="3">AVR Built-in Macros</a></li> <li><a href="#AVR-Internal-Options" accesskey="4">AVR Internal Options</a></li> </ul> <div class="subsubsection-level-extent" id="EIND-and-Devices-with-More-Than-128-Ki-Bytes-of-Flash"> <h1 class="subsubsection"><span>3.19.6.1 EIND and Devices with More Than 128 Ki Bytes of Flash</span></h1>  <p>Pointers in the implementation are 16 bits wide. The address of a function or label is represented as word address so that indirect jumps and calls can target any code address in the range of 64 Ki words. </p> <p>In order to facilitate indirect jump on devices with more than 128 Ki bytes of program memory space, there is a special function register called <code class="code">EIND</code> that serves as most significant part of the target address when <code class="code">EICALL</code> or <code class="code">EIJMP</code> instructions are used. </p> <p>Indirect jumps and calls on these devices are handled as follows by the compiler and are subject to some limitations: </p> <ul class="itemize mark-bullet"> <li>The compiler never sets <code class="code">EIND</code>. </li>
<li>The compiler uses <code class="code">EIND</code> implicitly in <code class="code">EICALL</code>/<code class="code">EIJMP</code> instructions or might read <code class="code">EIND</code> directly in order to emulate an indirect call/jump by means of a <code class="code">RET</code> instruction. </li>
<li>The compiler assumes that <code class="code">EIND</code> never changes during the startup code or during the application. In particular, <code class="code">EIND</code> is not saved/restored in function or interrupt service routine prologue/epilogue. </li>
<li>For indirect calls to functions and computed goto, the linker generates <em class="emph">stubs</em>. Stubs are jump pads sometimes also called <em class="emph">trampolines</em>. Thus, the indirect call/jump jumps to such a stub. The stub contains a direct jump to the desired address. </li>
<li>Linker relaxation must be turned on so that the linker generates the stubs correctly in all situations. See the compiler option <samp class="option">-mrelax</samp> and the linker option <samp class="option">--relax</samp>. There are corner cases where the linker is supposed to generate stubs but aborts without relaxation and without a helpful error message. </li>
<li>The default linker script is arranged for code with <code class="code">EIND = 0</code>. If code is supposed to work for a setup with <code class="code">EIND != 0</code>, a custom linker script has to be used in order to place the sections whose name start with <code class="code">.trampolines</code> into the segment where <code class="code">EIND</code> points to. </li>
<li>The startup code from libgcc never sets <code class="code">EIND</code>. Notice that startup code is a blend of code from libgcc and AVR-LibC. For the impact of AVR-LibC on <code class="code">EIND</code>, see the <a class="uref" href="https://www.nongnu.org/avr-libc/user-manual/">AVR-LibC user manual</a>. </li>
<li>It is legitimate for user-specific startup code to set up <code class="code">EIND</code> early, for example by means of initialization code located in section <code class="code">.init3</code>. Such code runs prior to general startup code that initializes RAM and calls constructors, but after the bit of startup code from AVR-LibC that sets <code class="code">EIND</code> to the segment where the vector table is located. <div class="example"> <pre class="example-preformatted" data-language="cpp">#include &lt;avr/io.h&gt;

static void
__attribute__((section(".init3"),naked,used,no_instrument_function))
init3_set_eind (void)
{
  __asm volatile ("ldi r24,pm_hh8(__trampolines_start)\n\t"
                  "out %i0,r24" :: "n" (&amp;EIND) : "r24","memory");
}</pre>
</div> <p>The <code class="code">__trampolines_start</code> symbol is defined in the linker script. </p> </li>
<li>Stubs are generated automatically by the linker if the following two conditions are met: <ul class="itemize mark-minus"> <li>The address of a label is taken by means of the <code class="code">gs</code> modifier (short for <em class="emph">generate stubs</em>) like so: <div class="example"> <pre class="example-preformatted" data-language="cpp">LDI r24, lo8(gs(<var class="var">func</var>))
LDI r25, hi8(gs(<var class="var">func</var>))</pre>
</div> </li>
<li>The final location of that label is in a code segment <em class="emph">outside</em> the segment where the stubs are located. </li>
</ul> </li>
<li>The compiler emits such <code class="code">gs</code> modifiers for code labels in the following situations: <ul class="itemize mark-minus"> <li>Taking address of a function or code label. </li>
<li>Computed goto. </li>
<li>If prologue-save function is used, see <samp class="option">-mcall-prologues</samp> command-line option. </li>
<li>Switch/case dispatch tables. If you do not want such dispatch tables you can specify the <samp class="option">-fno-jump-tables</samp> command-line option. </li>
<li>C and C++ constructors/destructors called during startup/shutdown. </li>
<li>If the tools hit a <code class="code">gs()</code> modifier explained above. </li>
</ul> </li>
<li>Jumping to non-symbolic addresses like so is <em class="emph">not</em> supported: <div class="example"> <pre class="example-preformatted" data-language="cpp">int main (void)
{
    /* Call function at word address 0x2 */
    return ((int(*)(void)) 0x2)();
}</pre>
</div> <p>Instead, a stub has to be set up, i.e. the function has to be called through a symbol (<code class="code">func_4</code> in the example): </p> <div class="example"> <pre class="example-preformatted" data-language="cpp">int main (void)
{
    extern int func_4 (void);

    /* Call function at byte address 0x4 */
    return func_4();
}</pre>
</div> <p>and the application be linked with <samp class="option">-Wl,--defsym,func_4=0x4</samp>. Alternatively, <code class="code">func_4</code> can be defined in the linker script. </p>
</li>
</ul> 
</div> <div class="subsubsection-level-extent" id="Handling-of-the-RAMPD_002c-RAMPX_002c-RAMPY-and-RAMPZ-Special-Function-Registers"> <h1 class="subsubsection"><span>3.19.6.2 Handling of the RAMPD, RAMPX, RAMPY and RAMPZ Special Function Registers</span></h1>     <p>Some AVR devices support memories larger than the 64 KiB range that can be accessed with 16-bit pointers. To access memory locations outside this 64 KiB range, the content of a <code class="code">RAMP</code> register is used as high part of the address: The <code class="code">X</code>, <code class="code">Y</code>, <code class="code">Z</code> address register is concatenated with the <code class="code">RAMPX</code>, <code class="code">RAMPY</code>, <code class="code">RAMPZ</code> special function register, respectively, to get a wide address. Similarly, <code class="code">RAMPD</code> is used together with direct addressing. </p> <ul class="itemize mark-bullet"> <li>The startup code initializes the <code class="code">RAMP</code> special function registers with zero. </li>
<li>If a <a class="ref" href="named-address-spaces.html#AVR-Named-Address-Spaces">named address space</a> other than generic or <code class="code">__flash</code> is used, then <code class="code">RAMPZ</code> is set as needed before the operation. </li>
<li>If the device supports RAM larger than 64 KiB and the compiler needs to change <code class="code">RAMPZ</code> to accomplish an operation, <code class="code">RAMPZ</code> is reset to zero after the operation. </li>
<li>If the device comes with a specific <code class="code">RAMP</code> register, the ISR prologue/epilogue saves/restores that SFR and initializes it with zero in case the ISR code might (implicitly) use it. </li>
<li>RAM larger than 64 KiB is not supported by GCC for AVR targets. If you use inline assembler to read from locations outside the 16-bit address range and change one of the <code class="code">RAMP</code> registers, you must reset it to zero after the access. </li>
</ul> 
</div> <div class="subsubsection-level-extent" id="AVR-Built_002din-Macros"> <h1 class="subsubsection"><span>3.19.6.3 AVR Built-in Macros</span></h1> <p>GCC defines several built-in macros so that the user code can test for the presence or absence of features. Almost any of the following built-in macros are deduced from device capabilities and thus triggered by the <samp class="option">-mmcu=</samp> command-line option. </p> <p>For even more AVR-specific built-in macros see <a class="ref" href="named-address-spaces.html#AVR-Named-Address-Spaces">AVR Named Address Spaces</a> and <a class="ref" href="avr-built_002din-functions.html">AVR Built-in Functions</a>. </p> <dl class="table"> <dt><code class="code">__AVR_ARCH__</code></dt> <dd>
<p>Build-in macro that resolves to a decimal number that identifies the architecture and depends on the <samp class="option">-mmcu=<var class="var">mcu</var></samp> option. Possible values are: </p> <p><code class="code">2</code>, <code class="code">25</code>, <code class="code">3</code>, <code class="code">31</code>, <code class="code">35</code>, <code class="code">4</code>, <code class="code">5</code>, <code class="code">51</code>, <code class="code">6</code> </p> <p>for <var class="var">mcu</var>=<code class="code">avr2</code>, <code class="code">avr25</code>, <code class="code">avr3</code>, <code class="code">avr31</code>, <code class="code">avr35</code>, <code class="code">avr4</code>, <code class="code">avr5</code>, <code class="code">avr51</code>, <code class="code">avr6</code>, </p> <p>respectively and </p> <p><code class="code">100</code>, <code class="code">102</code>, <code class="code">103</code>, <code class="code">104</code>, <code class="code">105</code>, <code class="code">106</code>, <code class="code">107</code> </p> <p>for <var class="var">mcu</var>=<code class="code">avrtiny</code>, <code class="code">avrxmega2</code>, <code class="code">avrxmega3</code>, <code class="code">avrxmega4</code>, <code class="code">avrxmega5</code>, <code class="code">avrxmega6</code>, <code class="code">avrxmega7</code>, respectively. If <var class="var">mcu</var> specifies a device, this built-in macro is set accordingly. For example, with <samp class="option">-mmcu=atmega8</samp> the macro is defined to <code class="code">4</code>. </p> </dd> <dt><code class="code">__AVR_<var class="var">Device</var>__</code></dt> <dd>
<p>Setting <samp class="option">-mmcu=<var class="var">device</var></samp> defines this built-in macro which reflects the device’s name. For example, <samp class="option">-mmcu=atmega8</samp> defines the built-in macro <code class="code">__AVR_ATmega8__</code>, <samp class="option">-mmcu=attiny261a</samp> defines <code class="code">__AVR_ATtiny261A__</code>, etc. </p> <p>The built-in macros’ names follow the scheme <code class="code">__AVR_<var class="var">Device</var>__</code> where <var class="var">Device</var> is the device name as from the AVR user manual. The difference between <var class="var">Device</var> in the built-in macro and <var class="var">device</var> in <samp class="option">-mmcu=<var class="var">device</var></samp> is that the latter is always lowercase. </p> <p>If <var class="var">device</var> is not a device but only a core architecture like ‘<samp class="samp">avr51</samp>’, this macro is not defined. </p> </dd> <dt><code class="code">__AVR_DEVICE_NAME__</code></dt> <dd>
<p>Setting <samp class="option">-mmcu=<var class="var">device</var></samp> defines this built-in macro to the device’s name. For example, with <samp class="option">-mmcu=atmega8</samp> the macro is defined to <code class="code">atmega8</code>. </p> <p>If <var class="var">device</var> is not a device but only a core architecture like ‘<samp class="samp">avr51</samp>’, this macro is not defined. </p> </dd> <dt><code class="code">__AVR_XMEGA__</code></dt> <dd>
<p>The device / architecture belongs to the XMEGA family of devices. </p> </dd> <dt><code class="code">__AVR_HAVE_ADIW__</code></dt> <dd>
<p>The device has the <code class="code">ADIW</code> and <code class="code">SBIW</code> instructions. </p> </dd> <dt><code class="code">__AVR_HAVE_ELPM__</code></dt> <dd>
<p>The device has the <code class="code">ELPM</code> instruction. </p> </dd> <dt><code class="code">__AVR_HAVE_ELPMX__</code></dt> <dd>
<p>The device has the <code class="code">ELPM R<var class="var">n</var>,Z</code> and <code class="code">ELPM
R<var class="var">n</var>,Z+</code> instructions. </p> </dd> <dt><code class="code">__AVR_HAVE_LPMX__</code></dt> <dd>
<p>The device has the <code class="code">LPM R<var class="var">n</var>,Z</code> and <code class="code">LPM R<var class="var">n</var>,Z+</code> instructions. </p> </dd> <dt><code class="code">__AVR_HAVE_MOVW__</code></dt> <dd>
<p>The device has the <code class="code">MOVW</code> instruction to perform 16-bit register-register moves. </p> </dd> <dt><code class="code">__AVR_HAVE_MUL__</code></dt> <dd>
<p>The device has a hardware multiplier. </p> </dd> <dt><code class="code">__AVR_HAVE_JMP_CALL__</code></dt> <dd>
<p>The device has the <code class="code">JMP</code> and <code class="code">CALL</code> instructions. This is the case for devices with more than 8 KiB of program memory. </p> </dd> <dt><code class="code">__AVR_HAVE_EIJMP_EICALL__</code></dt> <dt><code class="code">__AVR_3_BYTE_PC__</code></dt> <dd>
<p>The device has the <code class="code">EIJMP</code> and <code class="code">EICALL</code> instructions. This is the case for devices with more than 128 KiB of program memory. This also means that the program counter (PC) is 3 bytes wide. </p> </dd> <dt><code class="code">__AVR_2_BYTE_PC__</code></dt> <dd>
<p>The program counter (PC) is 2 bytes wide. This is the case for devices with up to 128 KiB of program memory. </p> </dd> <dt><code class="code">__AVR_HAVE_8BIT_SP__</code></dt> <dt><code class="code">__AVR_HAVE_16BIT_SP__</code></dt> <dd>
<p>The stack pointer (SP) register is treated as 8-bit respectively 16-bit register by the compiler. The definition of these macros is affected by <samp class="option">-mtiny-stack</samp>. </p> </dd> <dt><code class="code">__AVR_HAVE_SPH__</code></dt> <dt><code class="code">__AVR_SP8__</code></dt> <dd>
<p>The device has the SPH (high part of stack pointer) special function register or has an 8-bit stack pointer, respectively. The definition of these macros is affected by <samp class="option">-mmcu=</samp> and in the cases of <samp class="option">-mmcu=avr2</samp> and <samp class="option">-mmcu=avr25</samp> also by <samp class="option">-msp8</samp>. </p> </dd> <dt><code class="code">__AVR_HAVE_RAMPD__</code></dt> <dt><code class="code">__AVR_HAVE_RAMPX__</code></dt> <dt><code class="code">__AVR_HAVE_RAMPY__</code></dt> <dt><code class="code">__AVR_HAVE_RAMPZ__</code></dt> <dd>
<p>The device has the <code class="code">RAMPD</code>, <code class="code">RAMPX</code>, <code class="code">RAMPY</code>, <code class="code">RAMPZ</code> special function register, respectively. </p> </dd> <dt><code class="code">__NO_INTERRUPTS__</code></dt> <dd>
<p>This macro reflects the <samp class="option">-mno-interrupts</samp> command-line option. </p> </dd> <dt><code class="code">__AVR_ERRATA_SKIP__</code></dt> <dt><code class="code">__AVR_ERRATA_SKIP_JMP_CALL__</code></dt> <dd>
<p>Some AVR devices (AT90S8515, ATmega103) must not skip 32-bit instructions because of a hardware erratum. Skip instructions are <code class="code">SBRS</code>, <code class="code">SBRC</code>, <code class="code">SBIS</code>, <code class="code">SBIC</code> and <code class="code">CPSE</code>. The second macro is only defined if <code class="code">__AVR_HAVE_JMP_CALL__</code> is also set. </p> </dd> <dt><code class="code">__AVR_ISA_RMW__</code></dt> <dd>
<p>The device has Read-Modify-Write instructions (XCH, LAC, LAS and LAT). </p> </dd> <dt><code class="code">__AVR_SFR_OFFSET__=<var class="var">offset</var></code></dt> <dd>
<p>Instructions that can address I/O special function registers directly like <code class="code">IN</code>, <code class="code">OUT</code>, <code class="code">SBI</code>, etc. may use a different address as if addressed by an instruction to access RAM like <code class="code">LD</code> or <code class="code">STS</code>. This offset depends on the device architecture and has to be subtracted from the RAM address in order to get the respective I/O address. </p> </dd> <dt><code class="code">__AVR_SHORT_CALLS__</code></dt> <dd>
<p>The <samp class="option">-mshort-calls</samp> command line option is set. </p> </dd> <dt><code class="code">__AVR_PM_BASE_ADDRESS__=<var class="var">addr</var></code></dt> <dd>
<p>Some devices support reading from flash memory by means of <code class="code">LD*</code> instructions. The flash memory is seen in the data address space at an offset of <code class="code">__AVR_PM_BASE_ADDRESS__</code>. If this macro is not defined, this feature is not available. If defined, the address space is linear and there is no need to put <code class="code">.rodata</code> into RAM. This is handled by the default linker description file, and is currently available for <code class="code">avrtiny</code> and <code class="code">avrxmega3</code>. Even more convenient, there is no need to use address spaces like <code class="code">__flash</code> or features like attribute <code class="code">progmem</code> and <code class="code">pgm_read_*</code>. </p> </dd> <dt><code class="code">__AVR_HAVE_FLMAP__</code></dt> <dd>
<p>This macro is defined provided the following conditions are met: </p>
<ul class="itemize mark-bullet"> <li>The device has the <code class="code">NVMCTRL_CTRLB.FLMAP</code> bitfield. This applies to the AVR64* and AVR128* devices. </li>
<li>It’s not known at assembler-time which emulation will be used. </li>
</ul> <p>This implies the compiler was configured with GNU Binutils that implement <a class="uref" href="https://sourceware.org/PR31124">PR31124</a>. </p> </dd> <dt><code class="code">__AVR_RODATA_IN_RAM__</code></dt> <dd>
<p>This macro is undefined when the code is compiled for a core architecture. </p> <p>When the code is compiled for a device, the macro is defined to 1 when the <code class="code">.rodata</code> sections for read-only data is located in RAM; and defined to 0, otherwise. </p> </dd> <dt><code class="code">__WITH_AVRLIBC__</code></dt> <dd>
<p>The compiler is configured to be used together with AVR-Libc. See the <samp class="option">--with-avrlibc</samp> configure option. </p> </dd> <dt><code class="code">__HAVE_DOUBLE_MULTILIB__</code></dt> <dd>
<p>Defined if <samp class="option">-mdouble=</samp> acts as a multilib option. </p> </dd> <dt><code class="code">__HAVE_DOUBLE32__</code></dt> <dt><code class="code">__HAVE_DOUBLE64__</code></dt> <dd>
<p>Defined if the compiler supports 32-bit double resp. 64-bit double. The actual layout is specified by option <samp class="option">-mdouble=</samp>. </p> </dd> <dt><code class="code">__DEFAULT_DOUBLE__</code></dt> <dd>
<p>The size in bits of <code class="code">double</code> if <samp class="option">-mdouble=</samp> is not set. To test the layout of <code class="code">double</code> in a program, use the built-in macro <code class="code">__SIZEOF_DOUBLE__</code>. </p> </dd> <dt><code class="code">__HAVE_LONG_DOUBLE32__</code></dt> <dt><code class="code">__HAVE_LONG_DOUBLE64__</code></dt> <dt><code class="code">__HAVE_LONG_DOUBLE_MULTILIB__</code></dt> <dt><code class="code">__DEFAULT_LONG_DOUBLE__</code></dt> <dd>
<p>Same as above, but for <code class="code">long double</code> instead of <code class="code">double</code>. </p> </dd> <dt><code class="code">__WITH_DOUBLE_COMPARISON__</code></dt> <dd>
<p>Reflects the <code class="code">--with-double-comparison={tristate|bool|libf7}</code> <a class="uref" href="https://gcc.gnu.org/install/configure.html#avr">configure option</a> and is defined to <code class="code">2</code> or <code class="code">3</code>. </p> </dd> <dt><code class="code">__WITH_LIBF7_LIBGCC__</code></dt> <dt><code class="code">__WITH_LIBF7_MATH__</code></dt> <dt><code class="code">__WITH_LIBF7_MATH_SYMBOLS__</code></dt> <dd>
<p>Reflects the <code class="code">--with-libf7={libgcc|math|math-symbols}</code> <a class="uref" href="https://gcc.gnu.org/install/configure.html#avr">configure option</a>. </p> </dd> </dl> </div> <div class="subsubsection-level-extent" id="AVR-Internal-Options"> <h1 class="subsubsection"><span>3.19.6.4 AVR Internal Options</span></h1> <p>The following options are used internally by the compiler and to communicate between device specs files and the compiler proper. You don’t need to set these options by hand, in particular they are not optimization options. Using these options in the wrong way may lead to sub-optimal or wrong code. They are documented for completeness, and in order to get a better understanding of <a class="uref" href="https://gcc.gnu.org/wiki/avr-gcc#spec-files">device specs</a> files. </p> <dl class="table"> <dt>
<span><code class="code">-mn-flash=<var class="var">num</var></code></span>
</dt> <dd>
<p>Assume that the flash memory has a size of <var class="var">num</var> times 64 KiB. This determines which <code class="code">__flash<var class="var">N</var></code> address spaces are available. </p> </dd> <dt>
<span><code class="code">-mflmap</code></span>
</dt> <dd>
<p>The device has the <code class="code">FLMAP</code> bit field located in special function register <code class="code">NVMCTRL_CTRLB</code>. </p> </dd> <dt>
<span><code class="code">-mrmw</code></span>
</dt> <dd>
<p>Assume that the device supports the Read-Modify-Write instructions <code class="code">XCH</code>, <code class="code">LAC</code>, <code class="code">LAS</code> and <code class="code">LAT</code>. </p> </dd> <dt>
<span><code class="code">-mshort-calls</code></span>
</dt> <dd> <p>Assume that <code class="code">RJMP</code> and <code class="code">RCALL</code> can target the whole program memory. This option is used for multilib generation and selection for the devices from architecture <code class="code">avrxmega3</code>. </p> </dd> <dt>
<span><code class="code">-mskip-bug</code></span>
</dt> <dd> <p>Generate code without skips (<code class="code">CPSE</code>, <code class="code">SBRS</code>, <code class="code">SBRC</code>, <code class="code">SBIS</code>, <code class="code">SBIC</code>) over 32-bit instructions. </p> </dd> <dt>
<span><code class="code">-msp8</code></span>
</dt> <dd>
<p>Treat the stack pointer register as an 8-bit register, i.e. assume the high byte of the stack pointer is zero. This option is used by the compiler to select and build multilibs for architectures <code class="code">avr2</code> and <code class="code">avr25</code>. These architectures mix devices with and without <code class="code">SPH</code>. </p> </dd> </dl> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/AVR-Options.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/AVR-Options.html</a>
  </p>
</div>
