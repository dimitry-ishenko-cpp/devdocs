<h1 class="subsection" id="Microsoft-Windows-Function-Attributes-1">6.33.18 Microsoft Windows Function Attributes</h1> <div class="subsection-level-extent" id="Microsoft-Windows-Function-Attributes">    <p>The following attributes are available on Microsoft Windows and Symbian OS targets. </p> <dl class="table"> <dt>
 <span><code class="code">dllexport</code></span>
</dt> <dd>
<p>On Microsoft Windows targets and Symbian OS targets the <code class="code">dllexport</code> attribute causes the compiler to provide a global pointer to a pointer in a DLL, so that it can be referenced with the <code class="code">dllimport</code> attribute. On Microsoft Windows targets, the pointer name is formed by combining <code class="code">_imp__</code> and the function or variable name. </p> <p>You can use <code class="code">__declspec(dllexport)</code> as a synonym for <code class="code">__attribute__ ((dllexport))</code> for compatibility with other compilers. </p> <p>On systems that support the <code class="code">visibility</code> attribute, this attribute also implies “default” visibility. It is an error to explicitly specify any other visibility. </p> <p>GCC’s default behavior is to emit all inline functions with the <code class="code">dllexport</code> attribute. Since this can cause object file-size bloat, you can use <samp class="option">-fno-keep-inline-dllexport</samp>, which tells GCC to ignore the attribute for inlined functions unless the <samp class="option">-fkeep-inline-functions</samp> flag is used instead. </p> <p>The attribute is ignored for undefined symbols. </p> <p>When applied to C++ classes, the attribute marks defined non-inlined member functions and static data members as exports. Static consts initialized in-class are not marked unless they are also defined out-of-class. </p> <p>For Microsoft Windows targets there are alternative methods for including the symbol in the DLL’s export table such as using a <samp class="file">.def</samp> file with an <code class="code">EXPORTS</code> section or, with GNU ld, using the <samp class="option">--export-all</samp> linker flag. </p> </dd> <dt>
 <span><code class="code">dllimport</code></span>
</dt> <dd>
<p>On Microsoft Windows and Symbian OS targets, the <code class="code">dllimport</code> attribute causes the compiler to reference a function or variable via a global pointer to a pointer that is set up by the DLL exporting the symbol. The attribute implies <code class="code">extern</code>. On Microsoft Windows targets, the pointer name is formed by combining <code class="code">_imp__</code> and the function or variable name. </p> <p>You can use <code class="code">__declspec(dllimport)</code> as a synonym for <code class="code">__attribute__ ((dllimport))</code> for compatibility with other compilers. </p> <p>On systems that support the <code class="code">visibility</code> attribute, this attribute also implies “default” visibility. It is an error to explicitly specify any other visibility. </p> <p>Currently, the attribute is ignored for inlined functions. If the attribute is applied to a symbol <em class="emph">definition</em>, an error is reported. If a symbol previously declared <code class="code">dllimport</code> is later defined, the attribute is ignored in subsequent references, and a warning is emitted. The attribute is also overridden by a subsequent declaration as <code class="code">dllexport</code>. </p> <p>When applied to C++ classes, the attribute marks non-inlined member functions and static data members as imports. However, the attribute is ignored for virtual methods to allow creation of vtables using thunks. </p> <p>On the SH Symbian OS target the <code class="code">dllimport</code> attribute also has another affect—it can cause the vtable and run-time type information for a class to be exported. This happens when the class has a dllimported constructor or a non-inline, non-pure virtual function and, for either of those two conditions, the class also has an inline constructor or destructor and has a key function that is defined in the current translation unit. </p> <p>For Microsoft Windows targets the use of the <code class="code">dllimport</code> attribute on functions is not necessary, but provides a small performance benefit by eliminating a thunk in the DLL. The use of the <code class="code">dllimport</code> attribute on imported variables can be avoided by passing the <samp class="option">--enable-auto-import</samp> switch to the GNU linker. As with functions, using the attribute for a variable eliminates a thunk in the DLL. </p> <p>One drawback to using this attribute is that a pointer to a <em class="emph">variable</em> marked as <code class="code">dllimport</code> cannot be used as a constant address. However, a pointer to a <em class="emph">function</em> with the <code class="code">dllimport</code> attribute can be used as a constant initializer; in this case, the address of a stub function in the import lib is referenced. On Microsoft Windows targets, the attribute can be disabled for functions by setting the <samp class="option">-mnop-fun-dllimport</samp> flag. </p>
</dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Microsoft-Windows-Function-Attributes.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Microsoft-Windows-Function-Attributes.html</a>
  </p>
</div>
