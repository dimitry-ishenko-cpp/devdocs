<div class="subsection-level-extent" id="C_002b_002b-Compiled-Module-Interface"> <div class="nav-panel"> <p> Previous: <a href="c_002b_002b-module-preprocessing.html" accesskey="p" rel="prev">Module Preprocessing</a>, Up: <a href="c_002b_002b-modules.html" accesskey="u" rel="up">C++ Modules</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Compiled-Module-Interface"><span>3.23.3 Compiled Module Interface<a class="copiable-link" href="#Compiled-Module-Interface"> ¶</a></span></h1>  <p>CMIs are an additional artifact when compiling named module interfaces, partitions or header units. These are read when importing. CMI contents are implementation-specific, and in GCC’s case tied to the compiler version. Consider them a rebuildable cache artifact, not a distributable object. </p> <p>When creating an output CMI, any missing directory components are created in a manner that is safe for concurrent builds creating multiple, different, CMIs within a common subdirectory tree. </p> <p>CMI contents are written to a temporary file, which is then atomically renamed. Observers either see old contents (if there is an existing file), or complete new contents. They do not observe the CMI during its creation. This is unlike object file writing, which may be observed by an external process. </p> <p>CMIs are read in lazily, if the host OS provides <code class="code">mmap</code> functionality. Generally blocks are read when name lookup or template instantiation occurs. To inhibit this, the <samp class="option">-fno-module-lazy</samp> option may be used. </p> <p>The <samp class="option">--param lazy-modules=<var class="var">n</var></samp> parameter controls the limit on the number of concurrently open module files during lazy loading. Should more modules be imported, an LRU algorithm is used to determine which files to close—until that file is needed again. This limit may be exceeded with deep module dependency hierarchies. With large code bases there may be more imports than the process limit of file descriptors. By default, the limit is a few less than the per-process file descriptor hard limit, if that is determinable.<a class="footnote" id="DOCF3" href="#FOOT3"><sup>3</sup></a> </p> <p>GCC CMIs use ELF32 as an architecture-neutral encapsulation mechanism. You may use <code class="command">readelf</code> to inspect them, although section contents are largely undecipherable. There is a section named <code class="code">.gnu.c++.README</code>, which contains human-readable text. Other than the first line, each line consists of <code class="code"><var class="var">tag</var>: <code class="code">value</code></code> tuples. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">&gt; <code class="command">readelf -p.gnu.c++.README gcm.cache/foo.gcm</code>

String dump of section '.gnu.c++.README':
  [     0]  GNU C++ primary module interface
  [    21]  compiler: 11.0.0 20201116 (experimental) [c++-modules revision 20201116-0454]
  [    6f]  version: 2020/11/16-04:54
  [    89]  module: foo
  [    95]  source: c_b.ii
  [    a4]  dialect: C++20/coroutines
  [    be]  cwd: /data/users/nathans/modules/obj/x86_64/gcc
  [    ee]  repository: gcm.cache
  [   104]  buildtime: 2020/11/16 15:03:21 UTC
  [   127]  localtime: 2020/11/16 07:03:21 PST
  [   14a]  export: foo:part1 foo-part1.gcm</pre>
</div> <p>Amongst other things, this lists the source that was built, C++ dialect used and imports of the module.<a class="footnote" id="DOCF4" href="#FOOT4"><sup>4</sup></a> The timestamp is the same value as that provided by the <code class="code">__DATE__</code> &amp; <code class="code">__TIME__</code> macros, and may be explicitly specified with the environment variable <code class="code">SOURCE_DATE_EPOCH</code>. For further details see <a class="pxref" href="environment-variables.html">Environment Variables Affecting GCC</a>. </p> <p>A set of related CMIs may be copied, provided the relative pathnames are preserved. </p> <p>The <code class="code">.gnu.c++.README</code> contents do not affect CMI integrity, and it may be removed or altered. The section numbering of the sections whose names do not begin with <code class="code">.gnu.c++.</code>, or are not the string section is significant and must not be altered. </p> </div> <div class="footnotes-segment">  <h1 class="footnotes-heading">Footnotes</h1> <h2 class="footnote-body-heading"><a id="FOOT3" href="#DOCF3">(3)</a></h2> <p>Where applicable the soft limit is incremented as needed towards the hard limit.</p> <h2 class="footnote-body-heading"><a id="FOOT4" href="#DOCF4">(4)</a></h2> <p>The precise contents of this output may change.</p> </div>  <div class="nav-panel"> <p> Previous: <a href="c_002b_002b-module-preprocessing.html">Module Preprocessing</a>, Up: <a href="c_002b_002b-modules.html">C++ Modules</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/C_002b_002b-Compiled-Module-Interface.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/C_002b_002b-Compiled-Module-Interface.html</a>
  </p>
</div>
