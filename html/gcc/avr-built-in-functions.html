<div class="subsection-level-extent" id="AVR-Built-in-Functions"> <div class="nav-panel"> <p> Next: <a href="blackfin-built-in-functions.html" accesskey="n" rel="next">Blackfin Built-in Functions</a>, Previous: <a href="arm-armv8-m-security-extensions.html" accesskey="p" rel="prev">ARM ARMv8-M Security Extensions</a>, Up: <a href="target-builtins.html" accesskey="u" rel="up">Built-in Functions Specific to Particular Target Machines</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="AVR-Built-in-Functions-1"><span>6.60.10 AVR Built-in Functions<a class="copiable-link" href="#AVR-Built-in-Functions-1"> ¶</a></span></h1> <p>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if <code class="code">__builtin_avr_nop</code> is available the macro <code class="code">__BUILTIN_AVR_NOP</code> is defined to <code class="code">1</code> and undefined otherwise. </p> <dl class="table"> <dt><code class="code">void __builtin_avr_nop (void)</code></dt> <dt><code class="code">void __builtin_avr_sei (void)</code></dt> <dt><code class="code">void __builtin_avr_cli (void)</code></dt> <dt><code class="code">void __builtin_avr_sleep (void)</code></dt> <dt><code class="code">void __builtin_avr_wdr (void)</code></dt> <dt><code class="code">unsigned char __builtin_avr_swap (unsigned char)</code></dt> <dt><code class="code">unsigned int __builtin_avr_fmul (unsigned char, unsigned char)</code></dt> <dt><code class="code">int __builtin_avr_fmuls (char, char)</code></dt> <dt><code class="code">int __builtin_avr_fmulsu (char, unsigned char)</code></dt> <dd>
<p>These built-in functions map to the respective machine instruction, i.e. <code class="code">nop</code>, <code class="code">sei</code>, <code class="code">cli</code>, <code class="code">sleep</code>, <code class="code">wdr</code>, <code class="code">swap</code>, <code class="code">fmul</code>, <code class="code">fmuls</code> resp. <code class="code">fmulsu</code>. The three <code class="code">fmul*</code> built-ins are implemented as library call if no hardware multiplier is available. </p> </dd> <dt><code class="code">void __builtin_avr_delay_cycles (unsigned long ticks)</code></dt> <dd>
<p>Delay execution for <var class="var">ticks</var> cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. <var class="var">ticks</var> must be a compile-time integer constant; delays with a variable number of cycles are not supported. </p> </dd> <dt><code class="code">char __builtin_avr_flash_segment (const __memx void*)</code></dt> <dd>
<p>This built-in takes a byte address to the 24-bit <a class="ref" href="named-address-spaces.html#AVR-Named-Address-Spaces">address space</a> <code class="code">__memx</code> and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at <code class="code">0</code>. If the address does not point to flash memory, return <code class="code">-1</code>. </p> </dd> <dt><code class="code">uint8_t __builtin_avr_insert_bits (uint32_t map, uint8_t bits, uint8_t val)</code></dt> <dd>
<p>Insert bits from <var class="var">bits</var> into <var class="var">val</var> and return the resulting value. The nibbles of <var class="var">map</var> determine how the insertion is performed: Let <var class="var">X</var> be the <var class="var">n</var>-th nibble of <var class="var">map</var> </p>
<ol class="enumerate"> <li> If <var class="var">X</var> is <code class="code">0xf</code>, then the <var class="var">n</var>-th bit of <var class="var">val</var> is returned unaltered. </li>
<li> If X is in the range 0…7, then the <var class="var">n</var>-th result bit is set to the <var class="var">X</var>-th bit of <var class="var">bits</var> </li>
<li> If X is in the range 8…<code class="code">0xe</code>, then the <var class="var">n</var>-th result bit is undefined. </li>
</ol> <p>One typical use case for this built-in is adjusting input and output values to non-contiguous port layouts. Some examples: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as val, bits is unused
__builtin_avr_insert_bits (0xffffffff, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as bits, val is unused
__builtin_avr_insert_bits (0x76543210, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as rotating bits by 4
__builtin_avr_insert_bits (0x32107654, bits, 0);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// high nibble of result is the high nibble of val
// low nibble of result is the low nibble of bits
__builtin_avr_insert_bits (0xffff3210, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// reverse the bit order of bits
__builtin_avr_insert_bits (0x01234567, bits, 0);</pre>
</div> </dd> <dt><code class="code">void __builtin_avr_nops (unsigned count)</code></dt> <dd>
<p>Insert <var class="var">count</var> <code class="code">NOP</code> instructions. The number of instructions must be a compile-time integer constant. </p> </dd> </dl> <p>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 “Embedded C” fixed-point functions of section 7.18a.6. You don’t need to use these built-ins directly. Instead, use the declarations as supplied by the <code class="code">stdfix.h</code> header with GNU-C99: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#include &lt;stdfix.h&gt;

// Re-interpret the bit representation of unsigned 16-bit
// integer <var class="var">uval</var> as Q-format 0.16 value.
unsigned fract get_bits (uint_ur_t uval)
{
    return urbits (uval);
}</pre>
</div> </div>  <div class="nav-panel"> <p> Next: <a href="blackfin-built-in-functions.html">Blackfin Built-in Functions</a>, Previous: <a href="arm-armv8-m-security-extensions.html">ARM ARMv8-M Security Extensions</a>, Up: <a href="target-builtins.html">Built-in Functions Specific to Particular Target Machines</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/AVR-Built-in-Functions.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/AVR-Built-in-Functions.html</a>
  </p>
</div>
