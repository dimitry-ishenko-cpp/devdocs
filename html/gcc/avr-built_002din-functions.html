<h1 class="subsection" id="AVR-Built_002din-Functions-1">6.62.10 AVR Built-in Functions</h1> <div class="subsection-level-extent" id="AVR-Built_002din-Functions">    <p>For each built-in function for AVR, there is an equally named, uppercase built-in macro defined. That way users can easily query if or if not a specific built-in is implemented or not. For example, if <code class="code">__builtin_avr_nop</code> is available the macro <code class="code">__BUILTIN_AVR_NOP</code> is defined to <code class="code">1</code> and undefined otherwise. </p> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005favr_005fnop">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_nop</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005fsei">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_sei</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005fcli">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_cli</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005fsleep">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_sleep</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005fwdr">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_wdr</strong> <code class="def-code-arguments">(void)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005fswap">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint8_t</code> <strong class="def-name">__builtin_avr_swap</strong> <code class="def-code-arguments">(uint8_t)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005ffmul">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint16_t</code> <strong class="def-name">__builtin_avr_fmul</strong> <code class="def-code-arguments">(uint8_t, uint8_t)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005ffmuls">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int16_t</code> <strong class="def-name">__builtin_avr_fmuls</strong> <code class="def-code-arguments">(int8_t, int8_t)</code></span>
</dt> <dt class="deftypefnx def-cmd-deftypefn" id="index-_005f_005fbuiltin_005favr_005ffmulsu">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int16_t</code> <strong class="def-name">__builtin_avr_fmulsu</strong> <code class="def-code-arguments">(int8_t, uint8_t)</code></span>
</dt> <dd> <p>These built-in functions map to the respective machine instruction, i.e. <code class="code">nop</code>, <code class="code">sei</code>, <code class="code">cli</code>, <code class="code">sleep</code>, <code class="code">wdr</code>, <code class="code">swap</code>, <code class="code">fmul</code>, <code class="code">fmuls</code> resp. <code class="code">fmulsu</code>. The three <code class="code">fmul*</code> built-ins are implemented as library call if no hardware multiplier is available. </p>
</dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005favr_005fdelay_005fcycles">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_delay_cycles</strong> <code class="def-code-arguments">(uint32_t <var class="var">ticks</var>)</code></span>
</dt> <dd><p>Delay execution for <var class="var">ticks</var> cycles. Note that this built-in does not take into account the effect of interrupts that might increase delay time. <var class="var">ticks</var> must be a compile-time integer constant; delays with a variable number of cycles are not supported. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005favr_005fflash_005fsegment">
<span class="category-def">Built-in Function: </span><span><code class="def-type">int8_t</code> <strong class="def-name">__builtin_avr_flash_segment</strong> <code class="def-code-arguments">(const __memx void*)</code></span>
</dt> <dd><p>This built-in takes a byte address to the 24-bit <a class="ref" href="named-address-spaces.html#AVR-Named-Address-Spaces">address space</a> <code class="code">__memx</code> and returns the number of the flash segment (the 64 KiB chunk) where the address points to. Counting starts at <code class="code">0</code>. If the address does not point to flash memory, return <code class="code">-1</code>. </p></dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005favr_005finsert_005fbits">
<span class="category-def">Built-in Function: </span><span><code class="def-type">uint8_t</code> <strong class="def-name">__builtin_avr_insert_bits</strong> <code class="def-code-arguments">(uint32_t <var class="var">map</var>, uint8_t <var class="var">bits</var>, uint8_t <var class="var">val</var>)</code></span>
</dt> <dd>
<p>Insert bits from <var class="var">bits</var> into <var class="var">val</var> and return the resulting value. The nibbles of <var class="var">map</var> determine how the insertion is performed: Let <var class="var">X</var> be the <var class="var">n</var>-th nibble of <var class="var">map</var> </p>
<ol class="enumerate"> <li> If <var class="var">X</var> is <code class="code">0xf</code>, then the <var class="var">n</var>-th bit of <var class="var">val</var> is returned unaltered. </li>
<li> If X is in the range 0…7, then the <var class="var">n</var>-th result bit is set to the <var class="var">X</var>-th bit of <var class="var">bits</var> </li>
<li> If X is in the range 8…<code class="code">0xe</code>, then the <var class="var">n</var>-th result bit is undefined. </li>
</ol> <p>One typical use case for this built-in is adjusting input and output values to non-contiguous port layouts. Some examples: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as val, bits is unused
__builtin_avr_insert_bits (0xffffffff, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as bits, val is unused
__builtin_avr_insert_bits (0x76543210, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// same as rotating bits by 4
__builtin_avr_insert_bits (0x32107654, bits, 0);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// high nibble of result is the high nibble of val
// low nibble of result is the low nibble of bits
__builtin_avr_insert_bits (0xffff3210, bits, val);</pre>
</div> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">// reverse the bit order of bits
__builtin_avr_insert_bits (0x01234567, bits, 0);</pre>
</div> </dd>
</dl> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005favr_005fnops">
<span class="category-def">Built-in Function: </span><span><code class="def-type">void</code> <strong class="def-name">__builtin_avr_nops</strong> <code class="def-code-arguments">(uint16_t <var class="var">count</var>)</code></span>
</dt> <dd><p>Insert <var class="var">count</var> <code class="code">NOP</code> instructions. The number of instructions must be a compile-time integer constant. </p></dd>
</dl> <p>There are many more AVR-specific built-in functions that are used to implement the ISO/IEC TR 18037 “Embedded C” fixed-point functions of section 7.18a.6. You don’t need to use these built-ins directly. Instead, use the declarations as supplied by the <code class="code">stdfix.h</code> header with GNU-C99: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#include &lt;stdfix.h&gt;

// Re-interpret the bit representation of unsigned 16-bit
// integer <var class="var">uval</var> as Q-format 0.16 value.
unsigned fract get_bits (uint_ur_t uval)
{
    return urbits (uval);
}</pre>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/AVR-Built_002din-Functions.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/AVR-Built_002din-Functions.html</a>
  </p>
</div>
