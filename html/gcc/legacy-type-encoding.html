<h1 class="subsection" id="Legacy-Type-Encoding">8.3.1 Legacy Type Encoding</h1> <div class="subsection-level-extent" id="Legacy-type-encoding">    <p>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings: </p> <ul class="itemize mark-bullet"> <li>the read-only qualifier of the pointee gets emitted before the ’^’. The read-only qualifier of the pointer itself gets ignored, unless it is a typedef. Also, the ’r’ is only emitted for the outermost type. </li>
<li>32-bit longs are encoded as ’l’ or ’L’, but not always. For typedefs, the compiler uses ’i’ or ’I’ instead if encoding a struct field or a pointer. </li>
<li>
<code class="code">enum</code>s are always encoded as ’i’ (int) even if they are actually unsigned or long. </li>
</ul> <p>In addition to that, the NeXT runtime uses a different encoding for bitfields. It encodes them as <code class="code">b</code> followed by the size, without a bit offset or the underlying field type. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Legacy-type-encoding.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Legacy-type-encoding.html</a>
  </p>
</div>
