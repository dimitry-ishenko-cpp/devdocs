<div class="subsection-level-extent" id="Legacy-type-encoding"> <div class="nav-panel"> <p> Next: <a href="_0040encode.html" accesskey="n" rel="next"><code class="code">@encode</code></a>, Up: <a href="type-encoding.html" accesskey="u" rel="up">Type Encoding</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Legacy-Type-Encoding"><span>8.3.1 Legacy Type Encoding<a class="copiable-link" href="#Legacy-Type-Encoding"> ¶</a></span></h1> <p>Unfortunately, historically GCC used to have a number of bugs in its encoding code. The NeXT runtime expects GCC to emit type encodings in this historical format (compatible with GCC-3.3), so when using the NeXT runtime, GCC will introduce on purpose a number of incorrect encodings: </p> <ul class="itemize mark-bullet"> <li>the read-only qualifier of the pointee gets emitted before the ’^’. The read-only qualifier of the pointer itself gets ignored, unless it is a typedef. Also, the ’r’ is only emitted for the outermost type. </li>
<li>32-bit longs are encoded as ’l’ or ’L’, but not always. For typedefs, the compiler uses ’i’ or ’I’ instead if encoding a struct field or a pointer. </li>
<li>
<code class="code">enum</code>s are always encoded as ’i’ (int) even if they are actually unsigned or long. </li>
</ul> <p>In addition to that, the NeXT runtime uses a different encoding for bitfields. It encodes them as <code class="code">b</code> followed by the size, without a bit offset or the underlying field type. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Legacy-type-encoding.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Legacy-type-encoding.html</a>
  </p>
</div>
