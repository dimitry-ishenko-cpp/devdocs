<div class="section-level-extent" id="Warning-Options"> <div class="nav-panel"> <p> Next: <a href="static-analyzer-options.html" accesskey="n" rel="next">Options That Control Static Analysis</a>, Previous: <a href="diagnostic-message-formatting-options.html" accesskey="p" rel="prev">Options to Control Diagnostic Messages Formatting</a>, Up: <a href="invoking-gcc.html" accesskey="u" rel="up">GCC Command Options</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="section" id="Options-to-Request-or-Suppress-Warnings"><span>3.8 Options to Request or Suppress Warnings<a class="copiable-link" href="#Options-to-Request-or-Suppress-Warnings"> ¶</a></span></h1>     <p>Warnings are diagnostic messages that report constructions that are not inherently erroneous but that are risky or suggest there may have been an error. </p> <p>The following language-independent options do not enable specific warnings but control the kinds of diagnostics produced by GCC. </p> <dl class="table"> <dt>
 <span><code class="code">-fsyntax-only</code><a class="copiable-link" href="#index-syntax-checking"> ¶</a></span>
</dt> <dd>
<p>Check the code for syntax errors, but don’t do anything beyond that. </p> </dd> <dt>
<span><code class="code">-fmax-errors=<var class="var">n</var></code><a class="copiable-link" href="#index-fmax-errors"> ¶</a></span>
</dt> <dd>
<p>Limits the maximum number of error messages to <var class="var">n</var>, at which point GCC bails out rather than attempting to continue processing the source code. If <var class="var">n</var> is 0 (the default), there is no limit on the number of error messages produced. If <samp class="option">-Wfatal-errors</samp> is also specified, then <samp class="option">-Wfatal-errors</samp> takes precedence over this option. </p> </dd> <dt>
<span><code class="code">-w</code><a class="copiable-link" href="#index-w"> ¶</a></span>
</dt> <dd>
<p>Inhibit all warning messages. </p> </dd> <dt>
 <span><code class="code">-Werror</code><a class="copiable-link" href="#index-Werror"> ¶</a></span>
</dt> <dd>
<p>Make all warnings into errors. </p> </dd> <dt>
 <span><code class="code">-Werror=</code><a class="copiable-link" href="#index-Werror_003d"> ¶</a></span>
</dt> <dd>
<p>Make the specified warning into an error. The specifier for a warning is appended; for example <samp class="option">-Werror=switch</samp> turns the warnings controlled by <samp class="option">-Wswitch</samp> into errors. This switch takes a negative form, to be used to negate <samp class="option">-Werror</samp> for specific warnings; for example <samp class="option">-Wno-error=switch</samp> makes <samp class="option">-Wswitch</samp> warnings not be errors, even when <samp class="option">-Werror</samp> is in effect. </p> <p>The warning message for each controllable warning includes the option that controls the warning. That option can then be used with <samp class="option">-Werror=</samp> and <samp class="option">-Wno-error=</samp> as described above. (Printing of the option in the warning message can be disabled using the <samp class="option">-fno-diagnostics-show-option</samp> flag.) </p> <p>Note that specifying <samp class="option">-Werror=</samp><var class="var">foo</var> automatically implies <samp class="option">-W</samp><var class="var">foo</var>. However, <samp class="option">-Wno-error=</samp><var class="var">foo</var> does not imply anything. </p> </dd> <dt>
 <span><code class="code">-Wfatal-errors</code><a class="copiable-link" href="#index-Wfatal-errors"> ¶</a></span>
</dt> <dd>
<p>This option causes the compiler to abort compilation on the first error occurred rather than trying to keep going and printing further error messages. </p> </dd> </dl> <p>You can request many specific warnings with options beginning with ‘<samp class="samp">-W</samp>’, for example <samp class="option">-Wimplicit</samp> to request warnings on implicit declarations. Each of these specific warning options also has a negative form beginning ‘<samp class="samp">-Wno-</samp>’ to turn off warnings; for example, <samp class="option">-Wno-implicit</samp>. This manual lists only one of the two forms, whichever is not the default. For further language-specific options also refer to <a class="ref" href="c_002b_002b-dialect-options.html">Options Controlling C++ Dialect</a> and <a class="ref" href="objective-c-and-objective-c_002b_002b-dialect-options.html">Options Controlling Objective-C and Objective-C++ Dialects</a>. Additional warnings can be produced by enabling the static analyzer; See <a class="xref" href="static-analyzer-options.html">Options That Control Static Analysis</a>. </p> <p>Some options, such as <samp class="option">-Wall</samp> and <samp class="option">-Wextra</samp>, turn on other options, such as <samp class="option">-Wunused</samp>, which may turn on further options, such as <samp class="option">-Wunused-value</samp>. The combined effect of positive and negative forms is that more specific options have priority over less specific ones, independently of their position in the command-line. For options of the same specificity, the last one takes effect. Options enabled or disabled via pragmas (see <a class="pxref" href="diagnostic-pragmas.html">Diagnostic Pragmas</a>) take effect as if they appeared at the end of the command-line. </p> <p>When an unrecognized warning option is requested (e.g., <samp class="option">-Wunknown-warning</samp>), GCC emits a diagnostic stating that the option is not recognized. However, if the <samp class="option">-Wno-</samp> form is used, the behavior is slightly different: no diagnostic is produced for <samp class="option">-Wno-unknown-warning</samp> unless other diagnostics are being produced. This allows the use of new <samp class="option">-Wno-</samp> options with old compilers, but if something goes wrong, the compiler warns that an unrecognized option is present. </p> <p>The effectiveness of some warnings depends on optimizations also being enabled. For example <samp class="option">-Wsuggest-final-types</samp> is more effective with link-time optimization and some instances of other warnings may not be issued at all unless optimization is enabled. While optimization in general improves the efficacy of control and data flow sensitive warnings, in some cases it may also cause false positives. </p> <dl class="table"> <dt>
  <span><code class="code">-Wpedantic</code><a class="copiable-link" href="#index-pedantic-1"> ¶</a></span>
</dt> <dt><code class="code">-pedantic</code></dt> <dd>
<p>Issue all the warnings demanded by strict ISO C and ISO C++; reject all programs that use forbidden extensions, and some other programs that do not follow ISO C and ISO C++. For ISO C, follows the version of the ISO C standard specified by any <samp class="option">-std</samp> option used. </p> <p>Valid ISO C and ISO C++ programs should compile properly with or without this option (though a rare few require <samp class="option">-ansi</samp> or a <samp class="option">-std</samp> option specifying the required version of ISO C). However, without this option, certain GNU extensions and traditional C and C++ features are supported as well. With this option, they are rejected. </p> <p><samp class="option">-Wpedantic</samp> does not cause warning messages for use of the alternate keywords whose names begin and end with ‘<samp class="samp">__</samp>’. This alternate format can also be used to disable warnings for non-ISO ‘<samp class="samp">__intN</samp>’ types, i.e. ‘<samp class="samp">__intN__</samp>’. Pedantic warnings are also disabled in the expression that follows <code class="code">__extension__</code>. However, only system header files should use these escape routes; application programs should avoid them. See <a class="xref" href="alternate-keywords.html">Alternate Keywords</a>. </p> <p>Some users try to use <samp class="option">-Wpedantic</samp> to check programs for strict ISO C conformance. They soon find that it does not do quite what they want: it finds some non-ISO practices, but not all—only those for which ISO C <em class="emph">requires</em> a diagnostic, and some others for which diagnostics have been added. </p> <p>A feature to report any failure to conform to ISO C might be useful in some instances, but would require considerable additional work and would be quite different from <samp class="option">-Wpedantic</samp>. We don’t have plans to support such a feature in the near future. </p> <p>Where the standard specified with <samp class="option">-std</samp> represents a GNU extended dialect of C, such as ‘<samp class="samp">gnu90</samp>’ or ‘<samp class="samp">gnu99</samp>’, there is a corresponding <em class="dfn">base standard</em>, the version of ISO C on which the GNU extended dialect is based. Warnings from <samp class="option">-Wpedantic</samp> are given where they are required by the base standard. (It does not make sense for such warnings to be given only for features not in the specified GNU C dialect, since by definition the GNU dialects of C include all features the compiler supports with the given option, and there would be nothing to warn about.) </p> </dd> <dt>
<span><code class="code">-pedantic-errors</code><a class="copiable-link" href="#index-pedantic-errors-1"> ¶</a></span>
</dt> <dd>
<p>Give an error whenever the <em class="dfn">base standard</em> (see <samp class="option">-Wpedantic</samp>) requires a diagnostic, in some cases where there is undefined behavior at compile-time and in some other cases that do not prevent compilation of programs that are valid according to the standard. This is not equivalent to <samp class="option">-Werror=pedantic</samp>, since there are errors enabled by this option and not enabled by the latter and vice versa. </p> </dd> <dt>
 <span><code class="code">-Wall</code><a class="copiable-link" href="#index-Wall"> ¶</a></span>
</dt> <dd>
<p>This enables all the warnings about constructions that some users consider questionable, and that are easy to avoid (or modify to prevent the warning), even in conjunction with macros. This also enables some language-specific warnings described in <a class="ref" href="c_002b_002b-dialect-options.html">Options Controlling C++ Dialect</a> and <a class="ref" href="objective-c-and-objective-c_002b_002b-dialect-options.html">Options Controlling Objective-C and Objective-C++ Dialects</a>. </p> <p><samp class="option">-Wall</samp> turns on the following warning flags: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">-Waddress
-Warray-bounds=1 <span class="r">(only with</span> <samp class="option">-O2</samp><span class="r">)</span>
-Warray-compare
-Warray-parameter=2 <span class="r">(C and Objective-C only)</span>
-Wbool-compare
-Wbool-operation
-Wc++11-compat  -Wc++14-compat
-Wcatch-value <span class="r">(C++ and Objective-C++ only)</span>
-Wchar-subscripts
-Wcomment
-Wdangling-pointer=2
-Wduplicate-decl-specifier <span class="r">(C and Objective-C only)</span>
-Wenum-compare <span class="r">(in C/ObjC; this is on by default in C++)</span>
-Wenum-int-mismatch <span class="r">(C and Objective-C only)</span>
-Wformat
-Wformat-overflow
-Wformat-truncation
-Wint-in-bool-context
-Wimplicit <span class="r">(C and Objective-C only)</span>
-Wimplicit-int <span class="r">(C and Objective-C only)</span>
-Wimplicit-function-declaration <span class="r">(C and Objective-C only)</span>
-Winit-self <span class="r">(only for C++)</span>
-Wlogical-not-parentheses
-Wmain <span class="r">(only for C/ObjC and unless</span> <samp class="option">-ffreestanding</samp><span class="r">)</span>
-Wmaybe-uninitialized
-Wmemset-elt-size
-Wmemset-transposed-args
-Wmisleading-indentation <span class="r">(only for C/C++)</span>
-Wmismatched-dealloc
-Wmismatched-new-delete <span class="r">(only for C/C++)</span>
-Wmissing-attributes
-Wmissing-braces <span class="r">(only for C/ObjC)</span>
-Wmultistatement-macros
-Wnarrowing <span class="r">(only for C++)</span>
-Wnonnull
-Wnonnull-compare
-Wopenmp-simd
-Wparentheses
-Wpessimizing-move <span class="r">(only for C++)</span>
-Wpointer-sign
-Wrange-loop-construct <span class="r">(only for C++)</span>
-Wreorder
-Wrestrict
-Wreturn-type
-Wself-move <span class="r">(only for C++)</span>
-Wsequence-point
-Wsign-compare <span class="r">(only in C++)</span>
-Wsizeof-array-div
-Wsizeof-pointer-div
-Wsizeof-pointer-memaccess
-Wstrict-aliasing
-Wstrict-overflow=1
-Wswitch
-Wtautological-compare
-Wtrigraphs
-Wuninitialized
-Wunknown-pragmas
-Wunused-function
-Wunused-label
-Wunused-value
-Wunused-variable
-Wuse-after-free=2
-Wvla-parameter <span class="r">(C and Objective-C only)</span>
-Wvolatile-register-var
-Wzero-length-bounds</pre>
</div> <p>Note that some warning flags are not implied by <samp class="option">-Wall</samp>. Some of them warn about constructions that users generally do not consider questionable, but which occasionally you might wish to check for; others warn about constructions that are necessary or hard to avoid in some cases, and there is no simple way to modify the code to suppress the warning. Some of them are enabled by <samp class="option">-Wextra</samp> but many of them must be enabled individually. </p> </dd> <dt>
  <span><code class="code">-Wextra</code><a class="copiable-link" href="#index-W"> ¶</a></span>
</dt> <dd>
<p>This enables some extra warning flags that are not enabled by <samp class="option">-Wall</samp>. (This option used to be called <samp class="option">-W</samp>. The older name is still supported, but the newer name is more descriptive.) </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">-Wclobbered
-Wcast-function-type
-Wdeprecated-copy <span class="r">(C++ only)</span>
-Wempty-body
-Wenum-conversion <span class="r">(C only)</span>
-Wignored-qualifiers
-Wimplicit-fallthrough=3
-Wmissing-field-initializers
-Wmissing-parameter-type <span class="r">(C only)</span>
-Wold-style-declaration <span class="r">(C only)</span>
-Woverride-init
-Wsign-compare <span class="r">(C only)</span>
-Wstring-compare
-Wredundant-move <span class="r">(only for C++)</span>
-Wtype-limits
-Wuninitialized
-Wshift-negative-value <span class="r">(in C++11 to C++17 and in C99 and newer)</span>
-Wunused-parameter <span class="r">(only with</span> <samp class="option">-Wunused</samp> <span class="r">or</span> <samp class="option">-Wall</samp><span class="r">)</span>
-Wunused-but-set-parameter <span class="r">(only with</span> <samp class="option">-Wunused</samp> <span class="r">or</span> <samp class="option">-Wall</samp><span class="r">)</span></pre>
</div> <p>The option <samp class="option">-Wextra</samp> also prints warning messages for the following cases: </p> <ul class="itemize mark-bullet"> <li>A pointer is compared against integer zero with <code class="code">&lt;</code>, <code class="code">&lt;=</code>, <code class="code">&gt;</code>, or <code class="code">&gt;=</code>. </li>
<li>(C++ only) An enumerator and a non-enumerator both appear in a conditional expression. </li>
<li>(C++ only) Ambiguous virtual bases. </li>
<li>(C++ only) Subscripting an array that has been declared <code class="code">register</code>. </li>
<li>(C++ only) Taking the address of a variable that has been declared <code class="code">register</code>. </li>
<li>(C++ only) A base class is not initialized in the copy constructor of a derived class. </li>
</ul> </dd> <dt>
 <span><code class="code">-Wabi <span class="r">(C, Objective-C, C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wabi"> ¶</a></span>
</dt> <dd> <p>Warn about code affected by ABI changes. This includes code that may not be compatible with the vendor-neutral C++ ABI as well as the psABI for the particular target. </p> <p>Since G++ now defaults to updating the ABI with each major release, normally <samp class="option">-Wabi</samp> warns only about C++ ABI compatibility problems if there is a check added later in a release series for an ABI issue discovered since the initial release. <samp class="option">-Wabi</samp> warns about more things if an older ABI version is selected (with <samp class="option">-fabi-version=<var class="var">n</var></samp>). </p> <p><samp class="option">-Wabi</samp> can also be used with an explicit version number to warn about C++ ABI compatibility with a particular <samp class="option">-fabi-version</samp> level, e.g. <samp class="option">-Wabi=2</samp> to warn about changes relative to <samp class="option">-fabi-version=2</samp>. </p> <p>If an explicit version number is provided and <samp class="option">-fabi-compat-version</samp> is not specified, the version number from this option is used for compatibility aliases. If no explicit version number is provided with this option, but <samp class="option">-fabi-compat-version</samp> is specified, that version number is used for C++ ABI warnings. </p> <p>Although an effort has been made to warn about all such cases, there are probably some cases that are not warned about, even though G++ is generating incompatible code. There may also be cases where warnings are emitted even though the code that is generated is compatible. </p> <p>You should rewrite your code to avoid these warnings if you are concerned about the fact that code generated by G++ may not be binary compatible with code generated by other compilers. </p> <p>Known incompatibilities in <samp class="option">-fabi-version=2</samp> (which was the default from GCC 3.4 to 4.9) include: </p> <ul class="itemize mark-bullet"> <li>A template with a non-type template parameter of reference type was mangled incorrectly: <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">extern int N;
template &lt;int &amp;&gt; struct S {};
void n (S&lt;N&gt;) {2}</pre>
</div> <p>This was fixed in <samp class="option">-fabi-version=3</samp>. </p> </li>
<li>SIMD vector types declared using <code class="code">__attribute ((vector_size))</code> were mangled in a non-standard way that does not allow for overloading of functions taking vectors of different sizes. <p>The mangling was changed in <samp class="option">-fabi-version=4</samp>. </p> </li>
<li>
<code class="code">__attribute ((const))</code> and <code class="code">noreturn</code> were mangled as type qualifiers, and <code class="code">decltype</code> of a plain declaration was folded away. <p>These mangling issues were fixed in <samp class="option">-fabi-version=5</samp>. </p> </li>
<li>Scoped enumerators passed as arguments to a variadic function are promoted like unscoped enumerators, causing <code class="code">va_arg</code> to complain. On most targets this does not actually affect the parameter passing ABI, as there is no way to pass an argument smaller than <code class="code">int</code>. <p>Also, the ABI changed the mangling of template argument packs, <code class="code">const_cast</code>, <code class="code">static_cast</code>, prefix increment/decrement, and a class scope function used as a template argument. </p> <p>These issues were corrected in <samp class="option">-fabi-version=6</samp>. </p> </li>
<li>Lambdas in default argument scope were mangled incorrectly, and the ABI changed the mangling of <code class="code">nullptr_t</code>. <p>These issues were corrected in <samp class="option">-fabi-version=7</samp>. </p> </li>
<li>When mangling a function type with function-cv-qualifiers, the un-qualified function type was incorrectly treated as a substitution candidate. <p>This was fixed in <samp class="option">-fabi-version=8</samp>, the default for GCC 5.1. </p> </li>
<li>
<code class="code">decltype(nullptr)</code> incorrectly had an alignment of 1, leading to unaligned accesses. Note that this did not affect the ABI of a function with a <code class="code">nullptr_t</code> parameter, as parameters have a minimum alignment. <p>This was fixed in <samp class="option">-fabi-version=9</samp>, the default for GCC 5.2. </p> </li>
<li>Target-specific attributes that affect the identity of a type, such as ia32 calling conventions on a function type (stdcall, regparm, etc.), did not affect the mangled name, leading to name collisions when function pointers were used as template arguments. <p>This was fixed in <samp class="option">-fabi-version=10</samp>, the default for GCC 6.1. </p> </li>
</ul> <p>This option also enables warnings about psABI-related changes. The known psABI changes at this point include: </p> <ul class="itemize mark-bullet"> <li>For SysV/x86-64, unions with <code class="code">long double</code> members are passed in memory as specified in psABI. Prior to GCC 4.4, this was not the case. For example: <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">union U {
  long double ld;
  int i;
};</pre>
</div> <p><code class="code">union U</code> is now always passed in memory. </p> </li>
</ul> </dd> <dt><code class="code">-Wno-changes-meaning <span class="r">(C++ and Objective-C++ only)</span></code></dt> <dd>
<p>C++ requires that unqualified uses of a name within a class have the same meaning in the complete scope of the class, so declaring the name after using it is ill-formed: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct A;
struct B1 { A a; typedef A A; }; // warning, 'A' changes meaning
struct B2 { A a; struct A { }; }; // error, 'A' changes meaning</pre>
</div> <p>By default, the B1 case is only a warning because the two declarations have the same type, while the B2 case is an error. Both diagnostics can be disabled with <samp class="option">-Wno-changes-meaning</samp>. Alternately, the error case can be reduced to a warning with <samp class="option">-Wno-error=changes-meaning</samp> or <samp class="option">-fpermissive</samp>. </p> <p>Both diagnostics are also suppressed by <samp class="option">-fms-extensions</samp>. </p> </dd> <dt>
 <span><code class="code">-Wchar-subscripts</code><a class="copiable-link" href="#index-Wchar-subscripts"> ¶</a></span>
</dt> <dd>
<p>Warn if an array subscript has type <code class="code">char</code>. This is a common cause of error, as programmers often forget that this type is signed on some machines. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-coverage-mismatch</code><a class="copiable-link" href="#index-Wno-coverage-mismatch"> ¶</a></span>
</dt> <dd>
<p>Warn if feedback profiles do not match when using the <samp class="option">-fprofile-use</samp> option. If a source file is changed between compiling with <samp class="option">-fprofile-generate</samp> and with <samp class="option">-fprofile-use</samp>, the files with the profile feedback can fail to match the source file and GCC cannot use the profile feedback information. By default, this warning is enabled and is treated as an error. <samp class="option">-Wno-coverage-mismatch</samp> can be used to disable the warning or <samp class="option">-Wno-error=coverage-mismatch</samp> can be used to disable the error. Disabling the error for this warning can result in poorly optimized code and is useful only in the case of very minor changes such as bug fixes to an existing code-base. Completely disabling the warning is not recommended. </p> </dd> <dt>
 <span><code class="code">-Wno-coverage-invalid-line-number</code><a class="copiable-link" href="#index-Wno-coverage-invalid-line-number"> ¶</a></span>
</dt> <dd>
<p>Warn in case a function ends earlier than it begins due to an invalid linenum macros. The warning is emitted only with <samp class="option">--coverage</samp> enabled. </p> <p>By default, this warning is enabled and is treated as an error. <samp class="option">-Wno-coverage-invalid-line-number</samp> can be used to disable the warning or <samp class="option">-Wno-error=coverage-invalid-line-number</samp> can be used to disable the error. </p> </dd> <dt>
 <span><code class="code">-Wno-cpp <span class="r">(C, Objective-C, C++, Objective-C++ and Fortran only)</span></code><a class="copiable-link" href="#index-Wno-cpp"> ¶</a></span>
</dt> <dd>
<p>Suppress warning messages emitted by <code class="code">#warning</code> directives. </p> </dd> <dt>
 <span><code class="code">-Wdouble-promotion <span class="r">(C, C++, Objective-C and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wdouble-promotion"> ¶</a></span>
</dt> <dd>
<p>Give a warning when a value of type <code class="code">float</code> is implicitly promoted to <code class="code">double</code>. CPUs with a 32-bit “single-precision” floating-point unit implement <code class="code">float</code> in hardware, but emulate <code class="code">double</code> in software. On such a machine, doing computations using <code class="code">double</code> values is much more expensive because of the overhead required for software emulation. </p> <p>It is easy to accidentally do computations with <code class="code">double</code> because floating-point literals are implicitly of type <code class="code">double</code>. For example, in: </p>
<div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">float area(float radius)
{
   return 3.14159 * radius * radius;
}</pre></div>
</div> <p>the compiler performs the entire computation with <code class="code">double</code> because the floating-point literal is a <code class="code">double</code>. </p> </dd> <dt>
 <span><code class="code">-Wduplicate-decl-specifier <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wduplicate-decl-specifier"> ¶</a></span>
</dt> <dd>
<p>Warn if a declaration has duplicate <code class="code">const</code>, <code class="code">volatile</code>, <code class="code">restrict</code> or <code class="code">_Atomic</code> specifier. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
    <span><code class="code">-Wformat</code><a class="copiable-link" href="#index-Wformat"> ¶</a></span>
</dt> <dt><code class="code">-Wformat=<var class="var">n</var></code></dt> <dd>
<p>Check calls to <code class="code">printf</code> and <code class="code">scanf</code>, etc., to make sure that the arguments supplied have types appropriate to the format string specified, and that the conversions specified in the format string make sense. This includes standard functions, and others specified by format attributes (see <a class="pxref" href="function-attributes.html">Declaring Attributes of Functions</a>), in the <code class="code">printf</code>, <code class="code">scanf</code>, <code class="code">strftime</code> and <code class="code">strfmon</code> (an X/Open extension, not in the C standard) families (or other target-specific families). Which functions are checked without format attributes having been specified depends on the standard version selected, and such checks of functions without the attribute specified are disabled by <samp class="option">-ffreestanding</samp> or <samp class="option">-fno-builtin</samp>. </p> <p>The formats are checked against the format features supported by GNU libc version 2.2. These include all ISO C90 and C99 features, as well as features from the Single Unix Specification and some BSD and GNU extensions. Other library implementations may not support all these features; GCC does not support warning about features that go beyond a particular library’s limitations. However, if <samp class="option">-Wpedantic</samp> is used with <samp class="option">-Wformat</samp>, warnings are given about format features not in the selected standard version (but not for <code class="code">strfmon</code> formats, since those are not in any version of the C standard). See <a class="xref" href="c-dialect-options.html">Options Controlling C Dialect</a>. </p> <dl class="table"> <dt>
 <span><code class="code">-Wformat=1</code><a class="copiable-link" href="#index-Wformat-1"> ¶</a></span>
</dt> <dt><code class="code">-Wformat</code></dt> <dd>
<p>Option <samp class="option">-Wformat</samp> is equivalent to <samp class="option">-Wformat=1</samp>, and <samp class="option">-Wno-format</samp> is equivalent to <samp class="option">-Wformat=0</samp>. Since <samp class="option">-Wformat</samp> also checks for null format arguments for several functions, <samp class="option">-Wformat</samp> also implies <samp class="option">-Wnonnull</samp>. Some aspects of this level of format checking can be disabled by the options: <samp class="option">-Wno-format-contains-nul</samp>, <samp class="option">-Wno-format-extra-args</samp>, and <samp class="option">-Wno-format-zero-length</samp>. <samp class="option">-Wformat</samp> is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
<span><code class="code">-Wformat=2</code><a class="copiable-link" href="#index-Wformat_003d2"> ¶</a></span>
</dt> <dd><p>Enable <samp class="option">-Wformat</samp> plus additional format checks. Currently equivalent to <samp class="option">-Wformat -Wformat-nonliteral -Wformat-security -Wformat-y2k</samp>. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wno-format-contains-nul</code><a class="copiable-link" href="#index-Wno-format-contains-nul"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, do not warn about format strings that contain NUL bytes. </p> </dd> <dt>
 <span><code class="code">-Wno-format-extra-args</code><a class="copiable-link" href="#index-Wno-format-extra-args"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, do not warn about excess arguments to a <code class="code">printf</code> or <code class="code">scanf</code> format function. The C standard specifies that such arguments are ignored. </p> <p>Where the unused arguments lie between used arguments that are specified with ‘<samp class="samp">$</samp>’ operand number specifications, normally warnings are still given, since the implementation could not know what type to pass to <code class="code">va_arg</code> to skip the unused arguments. However, in the case of <code class="code">scanf</code> formats, this option suppresses the warning if the unused arguments are all pointers, since the Single Unix Specification says that such unused arguments are allowed. </p> </dd> <dt>
 <span><code class="code">-Wformat-overflow</code><a class="copiable-link" href="#index-Wformat-overflow"> ¶</a></span>
</dt> <dt><code class="code">-Wformat-overflow=<var class="var">level</var></code></dt> <dd>
<p>Warn about calls to formatted input/output functions such as <code class="code">sprintf</code> and <code class="code">vsprintf</code> that might overflow the destination buffer. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the <var class="var">level</var> argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. </p> <dl class="table"> <dt>
 <span><code class="code">-Wformat-overflow</code><a class="copiable-link" href="#index-Wformat-overflow-1"> ¶</a></span>
</dt> <dt><code class="code">-Wformat-overflow=1</code></dt> <dd>
<p>Level <var class="var">1</var> of <samp class="option">-Wformat-overflow</samp> enabled by <samp class="option">-Wformat</samp> employs a conservative approach that warns only about calls that most likely overflow the buffer. At this level, numeric arguments to format directives with unknown values are assumed to have the value of one, and strings of unknown length to be empty. Numeric arguments that are known to be bounded to a subrange of their type, or string arguments whose output is bounded either by their directive’s precision or by a finite set of string literals, are assumed to take on the value within the range that results in the most bytes on output. For example, the call to <code class="code">sprintf</code> below is diagnosed because even with both <var class="var">a</var> and <var class="var">b</var> equal to zero, the terminating NUL character (<code class="code">'\0'</code>) appended by the function to the destination buffer will be written past its end. Increasing the size of the buffer by a single byte is sufficient to avoid the warning, though it may not be sufficient to avoid the overflow. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (int a, int b)
{
  char buf [13];
  sprintf (buf, "a = %i, b = %i\n", a, b);
}</pre>
</div> </dd> <dt><code class="code">-Wformat-overflow=2</code></dt> <dd>
<p>Level <var class="var">2</var> warns also about calls that might overflow the destination buffer given an argument of sufficient length or magnitude. At level <var class="var">2</var>, unknown numeric arguments are assumed to have the minimum representable value for signed types with a precision greater than 1, and the maximum representable value otherwise. Unknown string arguments whose length cannot be assumed to be bounded either by the directive’s precision, or by a finite set of string literals they may evaluate to, or the character array they may point to, are assumed to be 1 character long. </p> <p>At level <var class="var">2</var>, the call in the example above is again diagnosed, but this time because with <var class="var">a</var> equal to a 32-bit <code class="code">INT_MIN</code> the first <code class="code">%i</code> directive will write some of its digits beyond the end of the destination buffer. To make the call safe regardless of the values of the two variables, the size of the destination buffer must be increased to at least 34 bytes. GCC includes the minimum size of the buffer in an informational note following the warning. </p> <p>An alternative to increasing the size of the destination buffer is to constrain the range of formatted values. The maximum length of string arguments can be bounded by specifying the precision in the format directive. When numeric arguments of format directives can be assumed to be bounded by less than the precision of their type, choosing an appropriate length modifier to the format specifier will reduce the required buffer size. For example, if <var class="var">a</var> and <var class="var">b</var> in the example above can be assumed to be within the precision of the <code class="code">short int</code> type then using either the <code class="code">%hi</code> format directive or casting the argument to <code class="code">short</code> reduces the maximum required size of the buffer to 24 bytes. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (int a, int b)
{
  char buf [23];
  sprintf (buf, "a = %hi, b = %i\n", a, (short)b);
}</pre>
</div> </dd> </dl> </dd> <dt>
 <span><code class="code">-Wno-format-zero-length</code><a class="copiable-link" href="#index-Wno-format-zero-length"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, do not warn about zero-length formats. The C standard specifies that zero-length formats are allowed. </p> </dd> <dt>
 <span><code class="code">-Wformat-nonliteral</code><a class="copiable-link" href="#index-Wformat-nonliteral"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, also warn if the format string is not a string literal and so cannot be checked, unless the format function takes its format arguments as a <code class="code">va_list</code>. </p> </dd> <dt>
 <span><code class="code">-Wformat-security</code><a class="copiable-link" href="#index-Wformat-security"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, also warn about uses of format functions that represent possible security problems. At present, this warns about calls to <code class="code">printf</code> and <code class="code">scanf</code> functions where the format string is not a string literal and there are no format arguments, as in <code class="code">printf (foo);</code>. This may be a security hole if the format string came from untrusted input and contains ‘<samp class="samp">%n</samp>’. (This is currently a subset of what <samp class="option">-Wformat-nonliteral</samp> warns about, but in future warnings may be added to <samp class="option">-Wformat-security</samp> that are not included in <samp class="option">-Wformat-nonliteral</samp>.) </p> </dd> <dt>
 <span><code class="code">-Wformat-signedness</code><a class="copiable-link" href="#index-Wformat-signedness"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, also warn if the format string requires an unsigned argument and the argument is signed and vice versa. </p> </dd> <dt>
 <span><code class="code">-Wformat-truncation</code><a class="copiable-link" href="#index-Wformat-truncation"> ¶</a></span>
</dt> <dt><code class="code">-Wformat-truncation=<var class="var">level</var></code></dt> <dd>
<p>Warn about calls to formatted input/output functions such as <code class="code">snprintf</code> and <code class="code">vsnprintf</code> that might result in output truncation. When the exact number of bytes written by a format directive cannot be determined at compile-time it is estimated based on heuristics that depend on the <var class="var">level</var> argument and on optimization. While enabling optimization will in most cases improve the accuracy of the warning, it may also result in false positives. Except as noted otherwise, the option uses the same logic <samp class="option">-Wformat-overflow</samp>. </p> <dl class="table"> <dt>
 <span><code class="code">-Wformat-truncation</code><a class="copiable-link" href="#index-Wformat-truncation-1"> ¶</a></span>
</dt> <dt><code class="code">-Wformat-truncation=1</code></dt> <dd>
<p>Level <var class="var">1</var> of <samp class="option">-Wformat-truncation</samp> enabled by <samp class="option">-Wformat</samp> employs a conservative approach that warns only about calls to bounded functions whose return value is unused and that will most likely result in output truncation. </p> </dd> <dt><code class="code">-Wformat-truncation=2</code></dt> <dd><p>Level <var class="var">2</var> warns also about calls to bounded functions whose return value is used and that might result in truncation given an argument of sufficient length or magnitude. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wformat-y2k</code><a class="copiable-link" href="#index-Wformat-y2k"> ¶</a></span>
</dt> <dd>
<p>If <samp class="option">-Wformat</samp> is specified, also warn about <code class="code">strftime</code> formats that may yield only a two-digit year. </p> </dd> <dt>
 <span><code class="code">-Wnonnull</code><a class="copiable-link" href="#index-Wnonnull"> ¶</a></span>
</dt> <dd>
<p>Warn about passing a null pointer for arguments marked as requiring a non-null value by the <code class="code">nonnull</code> function attribute. </p> <p><samp class="option">-Wnonnull</samp> is included in <samp class="option">-Wall</samp> and <samp class="option">-Wformat</samp>. It can be disabled with the <samp class="option">-Wno-nonnull</samp> option. </p> </dd> <dt>
 <span><code class="code">-Wnonnull-compare</code><a class="copiable-link" href="#index-Wnonnull-compare"> ¶</a></span>
</dt> <dd>
<p>Warn when comparing an argument marked with the <code class="code">nonnull</code> function attribute against null inside the function. </p> <p><samp class="option">-Wnonnull-compare</samp> is included in <samp class="option">-Wall</samp>. It can be disabled with the <samp class="option">-Wno-nonnull-compare</samp> option. </p> </dd> <dt>
 <span><code class="code">-Wnull-dereference</code><a class="copiable-link" href="#index-Wnull-dereference"> ¶</a></span>
</dt> <dd>
<p>Warn if the compiler detects paths that trigger erroneous or undefined behavior due to dereferencing a null pointer. This option is only active when <samp class="option">-fdelete-null-pointer-checks</samp> is active, which is enabled by optimizations in most targets. The precision of the warnings depends on the optimization options used. </p> </dd> <dt>
 <span><code class="code">-Winfinite-recursion</code><a class="copiable-link" href="#index-Winfinite-recursion"> ¶</a></span>
</dt> <dd>
<p>Warn about infinitely recursive calls. The warning is effective at all optimization levels but requires optimization in order to detect infinite recursion in calls between two or more functions. <samp class="option">-Winfinite-recursion</samp> is included in <samp class="option">-Wall</samp>. </p> <p>Compare with <samp class="option">-Wanalyzer-infinite-recursion</samp> which provides a similar diagnostic, but is implemented in a different way (as part of <samp class="option">-fanalyzer</samp>). </p> </dd> <dt>
 <span><code class="code">-Winit-self <span class="r">(C, C++, Objective-C and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Winit-self"> ¶</a></span>
</dt> <dd>
<p>Warn about uninitialized variables that are initialized with themselves. Note this option can only be used with the <samp class="option">-Wuninitialized</samp> option. </p> <p>For example, GCC warns about <code class="code">i</code> being uninitialized in the following snippet only when <samp class="option">-Winit-self</samp> has been specified: </p>
<div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">int f()
{
  int i = i;
  return i;
}</pre></div>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp> in C++. </p> </dd> <dt>
 <span><code class="code">-Wno-implicit-int <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wimplicit-int"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings when a declaration does not specify a type. This warning is enabled by default in C99 and later dialects of C, and also by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-implicit-function-declaration <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wimplicit-function-declaration"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings when a function is used before being declared. This warning is enabled by default in C99 and later dialects of C, and also by <samp class="option">-Wall</samp>. The warning is made into an error by <samp class="option">-pedantic-errors</samp>. </p> </dd> <dt>
 <span><code class="code">-Wimplicit <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wimplicit"> ¶</a></span>
</dt> <dd>
<p>Same as <samp class="option">-Wimplicit-int</samp> and <samp class="option">-Wimplicit-function-declaration</samp>. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wimplicit-fallthrough</code><a class="copiable-link" href="#index-Wimplicit-fallthrough"> ¶</a></span>
</dt> <dd>
<p><samp class="option">-Wimplicit-fallthrough</samp> is the same as <samp class="option">-Wimplicit-fallthrough=3</samp> and <samp class="option">-Wno-implicit-fallthrough</samp> is the same as <samp class="option">-Wimplicit-fallthrough=0</samp>. </p> </dd> <dt>
<span><code class="code">-Wimplicit-fallthrough=<var class="var">n</var></code><a class="copiable-link" href="#index-Wimplicit-fallthrough_003d"> ¶</a></span>
</dt> <dd>
<p>Warn when a switch case falls through. For example: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
  case 1:
    a = 1;
    break;
  case 2:
    a = 2;
  case 3:
    a = 3;
    break;
  }</pre></div>
</div> <p>This warning does not warn when the last statement of a case cannot fall through, e.g. when there is a return statement or a call to function declared with the noreturn attribute. <samp class="option">-Wimplicit-fallthrough=</samp> also takes into account control flow statements, such as ifs, and only warns when appropriate. E.g. </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
  case 1:
    if (i &gt; 3) {
      bar (5);
      break;
    } else if (i &lt; 1) {
      bar (0);
    } else
      return;
  default:
    …
  }</pre></div>
</div> <p>Since there are occasions where a switch case fall through is desirable, GCC provides an attribute, <code class="code">__attribute__ ((fallthrough))</code>, that is to be used along with a null statement to suppress this warning that would normally occur: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
  case 1:
    bar (0);
    __attribute__ ((fallthrough));
  default:
    …
  }</pre></div>
</div> <p>C++17 provides a standard way to suppress the <samp class="option">-Wimplicit-fallthrough</samp> warning using <code class="code">[[fallthrough]];</code> instead of the GNU attribute. In C++11 or C++14 users can use <code class="code">[[gnu::fallthrough]];</code>, which is a GNU extension. Instead of these attributes, it is also possible to add a fallthrough comment to silence the warning. The whole body of the C or C++ style comment should match the given regular expressions listed below. The option argument <var class="var">n</var> specifies what kind of comments are accepted: </p> <ul class="itemize mark-bullet"> <li>
<samp class="option">-Wimplicit-fallthrough=0</samp> disables the warning altogether. </li>
<li>
<samp class="option">-Wimplicit-fallthrough=1</samp> matches <code class="code">.*</code> regular expression, any comment is used as fallthrough comment. </li>
<li>
<samp class="option">-Wimplicit-fallthrough=2</samp> case insensitively matches <code class="code">.*falls?[ \t-]*thr(ough|u).*</code> regular expression. </li>
<li>
<samp class="option">-Wimplicit-fallthrough=3</samp> case sensitively matches one of the following regular expressions: <ul class="itemize mark-bullet"> <li>
<code class="code">-fallthrough</code> </li>
<li>
<code class="code">@fallthrough@</code> </li>
<li>
<code class="code">lint -fallthrough[ \t]*</code> </li>
<li>
<code class="code">[ \t.!]*(ELSE,? |INTENTIONAL(LY)? )?FALL(S | |-)?THR(OUGH|U)[ \t.!]*(-[^\n\r]*)?</code> </li>
<li>
<code class="code">[ \t.!]*(Else,? |Intentional(ly)? )?Fall((s | |-)[Tt]|t)hr(ough|u)[ \t.!]*(-[^\n\r]*)?</code> </li>
<li>
<code class="code">[ \t.!]*([Ee]lse,? |[Ii]ntentional(ly)? )?fall(s | |-)?thr(ough|u)[ \t.!]*(-[^\n\r]*)?</code> </li>
</ul> </li>
<li>
<samp class="option">-Wimplicit-fallthrough=4</samp> case sensitively matches one of the following regular expressions: <ul class="itemize mark-bullet"> <li>
<code class="code">-fallthrough</code> </li>
<li>
<code class="code">@fallthrough@</code> </li>
<li>
<code class="code">lint -fallthrough[ \t]*</code> </li>
<li>
<code class="code">[ \t]*FALLTHR(OUGH|U)[ \t]*</code> </li>
</ul> </li>
<li>
<samp class="option">-Wimplicit-fallthrough=5</samp> doesn’t recognize any comments as fallthrough comments, only attributes disable the warning. </li>
</ul> <p>The comment needs to be followed after optional whitespace and other comments by <code class="code">case</code> or <code class="code">default</code> keywords or by a user label that precedes some <code class="code">case</code> or <code class="code">default</code> label. </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
  case 1:
    bar (0);
    /* FALLTHRU */
  default:
    …
  }</pre></div>
</div> <p>The <samp class="option">-Wimplicit-fallthrough=3</samp> warning is enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-if-not-aligned <span class="r">(C, C++, Objective-C and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wif-not-aligned"> ¶</a></span>
</dt> <dd>
<p>Control if warnings triggered by the <code class="code">warn_if_not_aligned</code> attribute should be issued. These warnings are enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wignored-qualifiers <span class="r">(C and C++ only)</span></code><a class="copiable-link" href="#index-Wignored-qualifiers"> ¶</a></span>
</dt> <dd>
<p>Warn if the return type of a function has a type qualifier such as <code class="code">const</code>. For ISO C such a type qualifier has no effect, since the value returned by a function is not an lvalue. For C++, the warning is only emitted for scalar types or <code class="code">void</code>. ISO C prohibits qualified <code class="code">void</code> return types on function definitions, so such return types always receive a warning even without this option. </p> <p>This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-ignored-attributes <span class="r">(C and C++ only)</span></code><a class="copiable-link" href="#index-Wignored-attributes"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings when an attribute is ignored. This is different from the <samp class="option">-Wattributes</samp> option in that it warns whenever the compiler decides to drop an attribute, not that the attribute is either unknown, used in a wrong place, etc. This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wmain</code><a class="copiable-link" href="#index-Wmain"> ¶</a></span>
</dt> <dd>
<p>Warn if the type of <code class="code">main</code> is suspicious. <code class="code">main</code> should be a function with external linkage, returning int, taking either zero arguments, two, or three arguments of appropriate types. This warning is enabled by default in C++ and is enabled by either <samp class="option">-Wall</samp> or <samp class="option">-Wpedantic</samp>. </p> </dd> <dt>
 <span><code class="code">-Wmisleading-indentation <span class="r">(C and C++ only)</span></code><a class="copiable-link" href="#index-Wmisleading-indentation"> ¶</a></span>
</dt> <dd>
<p>Warn when the indentation of the code does not reflect the block structure. Specifically, a warning is issued for <code class="code">if</code>, <code class="code">else</code>, <code class="code">while</code>, and <code class="code">for</code> clauses with a guarded statement that does not use braces, followed by an unguarded statement with the same indentation. </p> <p>In the following example, the call to “bar” is misleadingly indented as if it were guarded by the “if” conditional. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (some_condition ())
  foo ();
  bar ();  /* Gotcha: this is not guarded by the "if".  */</pre>
</div> <p>In the case of mixed tabs and spaces, the warning uses the <samp class="option">-ftabstop=</samp> option to determine if the statements line up (defaulting to 8). </p> <p>The warning is not issued for code involving multiline preprocessor logic such as the following example. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (flagA)
    foo (0);
#if SOME_CONDITION_THAT_DOES_NOT_HOLD
  if (flagB)
#endif
    foo (1);</pre>
</div> <p>The warning is not issued after a <code class="code">#line</code> directive, since this typically indicates autogenerated code, and no assumptions can be made about the layout of the file that the directive references. </p> <p>This warning is enabled by <samp class="option">-Wall</samp> in C and C++. </p> </dd> <dt>
 <span><code class="code">-Wmissing-attributes</code><a class="copiable-link" href="#index-Wmissing-attributes"> ¶</a></span>
</dt> <dd>
<p>Warn when a declaration of a function is missing one or more attributes that a related function is declared with and whose absence may adversely affect the correctness or efficiency of generated code. For example, the warning is issued for declarations of aliases that use attributes to specify less restrictive requirements than those of their targets. This typically represents a potential optimization opportunity. By contrast, the <samp class="option">-Wattribute-alias=2</samp> option controls warnings issued when the alias is more restrictive than the target, which could lead to incorrect code generation. Attributes considered include <code class="code">alloc_align</code>, <code class="code">alloc_size</code>, <code class="code">cold</code>, <code class="code">const</code>, <code class="code">hot</code>, <code class="code">leaf</code>, <code class="code">malloc</code>, <code class="code">nonnull</code>, <code class="code">noreturn</code>, <code class="code">nothrow</code>, <code class="code">pure</code>, <code class="code">returns_nonnull</code>, and <code class="code">returns_twice</code>. </p> <p>In C++, the warning is issued when an explicit specialization of a primary template declared with attribute <code class="code">alloc_align</code>, <code class="code">alloc_size</code>, <code class="code">assume_aligned</code>, <code class="code">format</code>, <code class="code">format_arg</code>, <code class="code">malloc</code>, or <code class="code">nonnull</code> is declared without it. Attributes <code class="code">deprecated</code>, <code class="code">error</code>, and <code class="code">warning</code> suppress the warning. (see <a class="pxref" href="function-attributes.html">Declaring Attributes of Functions</a>). </p> <p>You can use the <code class="code">copy</code> attribute to apply the same set of attributes to a declaration as that on another declaration without explicitly enumerating the attributes. This attribute can be applied to declarations of functions (see <a class="pxref" href="common-function-attributes.html">Common Function Attributes</a>), variables (see <a class="pxref" href="common-variable-attributes.html">Common Variable Attributes</a>), or types (see <a class="pxref" href="common-type-attributes.html">Common Type Attributes</a>). </p> <p><samp class="option">-Wmissing-attributes</samp> is enabled by <samp class="option">-Wall</samp>. </p> <p>For example, since the declaration of the primary function template below makes use of both attribute <code class="code">malloc</code> and <code class="code">alloc_size</code> the declaration of the explicit specialization of the template is diagnosed because it is missing one of the attributes. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">template &lt;class T&gt;
T* __attribute__ ((malloc, alloc_size (1)))
allocate (size_t);

template &lt;&gt;
void* __attribute__ ((malloc))   // missing alloc_size
allocate&lt;void&gt; (size_t);</pre>
</div> </dd> <dt>
 <span><code class="code">-Wmissing-braces</code><a class="copiable-link" href="#index-Wmissing-braces"> ¶</a></span>
</dt> <dd>
<p>Warn if an aggregate or union initializer is not fully bracketed. In the following example, the initializer for <code class="code">a</code> is not fully bracketed, but that for <code class="code">b</code> is fully bracketed. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int a[2][2] = { 0, 1, 2, 3 };
int b[2][2] = { { 0, 1 }, { 2, 3 } };</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wmissing-include-dirs <span class="r">(C, C++, Objective-C, Objective-C++ and Fortran only)</span></code><a class="copiable-link" href="#index-Wmissing-include-dirs"> ¶</a></span>
</dt> <dd>
<p>Warn if a user-supplied include directory does not exist. This opions is disabled by default for C, C++, Objective-C and Objective-C++. For Fortran, it is partially enabled by default by warning for -I and -J, only. </p> </dd> <dt>
 <span><code class="code">-Wno-missing-profile</code><a class="copiable-link" href="#index-Wmissing-profile"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings if feedback profiles are missing when using the <samp class="option">-fprofile-use</samp> option. This option diagnoses those cases where a new function or a new file is added between compiling with <samp class="option">-fprofile-generate</samp> and with <samp class="option">-fprofile-use</samp>, without regenerating the profiles. In these cases, the profile feedback data files do not contain any profile feedback information for the newly added function or file respectively. Also, in the case when profile count data (.gcda) files are removed, GCC cannot use any profile feedback information. In all these cases, warnings are issued to inform you that a profile generation step is due. Ignoring the warning can result in poorly optimized code. <samp class="option">-Wno-missing-profile</samp> can be used to disable the warning, but this is not recommended and should be done only when non-existent profile data is justified. </p> </dd> <dt>
 <span><code class="code">-Wmismatched-dealloc</code><a class="copiable-link" href="#index-Wmismatched-dealloc"> ¶</a></span>
</dt> <dd> <p>Warn for calls to deallocation functions with pointer arguments returned from from allocations functions for which the former isn’t a suitable deallocator. A pair of functions can be associated as matching allocators and deallocators by use of attribute <code class="code">malloc</code>. Unless disabled by the <samp class="option">-fno-builtin</samp> option the standard functions <code class="code">calloc</code>, <code class="code">malloc</code>, <code class="code">realloc</code>, and <code class="code">free</code>, as well as the corresponding forms of C++ <code class="code">operator new</code> and <code class="code">operator delete</code> are implicitly associated as matching allocators and deallocators. In the following example <code class="code">mydealloc</code> is the deallocator for pointers returned from <code class="code">myalloc</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void mydealloc (void*);

__attribute__ ((malloc (mydealloc, 1))) void*
myalloc (size_t);

void f (void)
{
  void *p = myalloc (32);
  // …use p…
  free (p);   // warning: not a matching deallocator for myalloc
  mydealloc (p);   // ok
}</pre>
</div> <p>In C++, the related option <samp class="option">-Wmismatched-new-delete</samp> diagnoses mismatches involving either <code class="code">operator new</code> or <code class="code">operator delete</code>. </p> <p>Option <samp class="option">-Wmismatched-dealloc</samp> is included in <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wmultistatement-macros</code><a class="copiable-link" href="#index-Wmultistatement-macros"> ¶</a></span>
</dt> <dd>
<p>Warn about unsafe multiple statement macros that appear to be guarded by a clause such as <code class="code">if</code>, <code class="code">else</code>, <code class="code">for</code>, <code class="code">switch</code>, or <code class="code">while</code>, in which only the first statement is actually guarded after the macro is expanded. </p> <p>For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define DOIT x++; y++
if (c)
  DOIT;</pre>
</div> <p>will increment <code class="code">y</code> unconditionally, not just when <code class="code">c</code> holds. The can usually be fixed by wrapping the macro in a do-while loop: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define DOIT do { x++; y++; } while (0)
if (c)
  DOIT;</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp> in C and C++. </p> </dd> <dt>
 <span><code class="code">-Wparentheses</code><a class="copiable-link" href="#index-Wparentheses"> ¶</a></span>
</dt> <dd>
<p>Warn if parentheses are omitted in certain contexts, such as when there is an assignment in a context where a truth value is expected, or when operators are nested whose precedence people often get confused about. </p> <p>Also warn if a comparison like <code class="code">x&lt;=y&lt;=z</code> appears; this is equivalent to <code class="code">(x&lt;=y ? 1 : 0) &lt;= z</code>, which is a different interpretation from that of ordinary mathematical notation. </p> <p>Also warn for dangerous uses of the GNU extension to <code class="code">?:</code> with omitted middle operand. When the condition in the <code class="code">?</code>: operator is a boolean expression, the omitted value is always 1. Often programmers expect it to be a value computed inside the conditional expression instead. </p> <p>For C++ this also warns for some cases of unnecessary parentheses in declarations, which can indicate an attempt at a function call instead of a declaration: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">{
  // Declares a local variable called mymutex.
  std::unique_lock&lt;std::mutex&gt; (mymutex);
  // User meant std::unique_lock&lt;std::mutex&gt; lock (mymutex);
}</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-self-move <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wself-move"> ¶</a></span>
</dt> <dd>
<p>This warning warns when a value is moved to itself with <code class="code">std::move</code>. Such a <code class="code">std::move</code> typically has no effect. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct T {
…
};
void fn()
{
  T t;
  …
  t = std::move (t);
}</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wsequence-point</code><a class="copiable-link" href="#index-Wsequence-point"> ¶</a></span>
</dt> <dd>
<p>Warn about code that may have undefined semantics because of violations of sequence point rules in the C and C++ standards. </p> <p>The C and C++ standards define the order in which expressions in a C/C++ program are evaluated in terms of <em class="dfn">sequence points</em>, which represent a partial ordering between the execution of parts of the program: those executed before the sequence point, and those executed after it. These occur after the evaluation of a full expression (one which is not part of a larger expression), after the evaluation of the first operand of a <code class="code">&amp;&amp;</code>, <code class="code">||</code>, <code class="code">? :</code> or <code class="code">,</code> (comma) operator, before a function is called (but after the evaluation of its arguments and the expression denoting the called function), and in certain other places. Other than as expressed by the sequence point rules, the order of evaluation of subexpressions of an expression is not specified. All these rules describe only a partial order rather than a total order, since, for example, if two functions are called within one expression with no sequence point between them, the order in which the functions are called is not specified. However, the standards committee have ruled that function calls do not overlap. </p> <p>It is not specified when between sequence points modifications to the values of objects take effect. Programs whose behavior depends on this have undefined behavior; the C and C++ standards specify that “Between the previous and next sequence point an object shall have its stored value modified at most once by the evaluation of an expression. Furthermore, the prior value shall be read only to determine the value to be stored.”. If a program breaks these rules, the results on any particular implementation are entirely unpredictable. </p> <p>Examples of code with undefined behavior are <code class="code">a = a++;</code>, <code class="code">a[n]
= b[n++]</code> and <code class="code">a[i++] = i;</code>. Some more complicated cases are not diagnosed by this option, and it may give an occasional false positive result, but in general it has been found fairly effective at detecting this sort of problem in programs. </p> <p>The C++17 standard will define the order of evaluation of operands in more cases: in particular it requires that the right-hand side of an assignment be evaluated before the left-hand side, so the above examples are no longer undefined. But this option will still warn about them, to help people avoid writing code that is undefined in C and earlier revisions of C++. </p> <p>The standard is worded confusingly, therefore there is some debate over the precise meaning of the sequence point rules in subtle cases. Links to discussions of the problem, including proposed formal definitions, may be found on the GCC readings page, at <a class="uref" href="https://gcc.gnu.org/readings.html">https://gcc.gnu.org/readings.html</a>. </p> <p>This warning is enabled by <samp class="option">-Wall</samp> for C and C++. </p> </dd> <dt>
 <span><code class="code">-Wno-return-local-addr</code><a class="copiable-link" href="#index-Wno-return-local-addr"> ¶</a></span>
</dt> <dd>
<p>Do not warn about returning a pointer (or in C++, a reference) to a variable that goes out of scope after the function returns. </p> </dd> <dt>
 <span><code class="code">-Wreturn-type</code><a class="copiable-link" href="#index-Wreturn-type"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a function is defined with a return type that defaults to <code class="code">int</code>. Also warn about any <code class="code">return</code> statement with no return value in a function whose return type is not <code class="code">void</code> (falling off the end of the function body is considered returning without a value). </p> <p>For C only, warn about a <code class="code">return</code> statement with an expression in a function whose return type is <code class="code">void</code>, unless the expression type is also <code class="code">void</code>. As a GNU extension, the latter case is accepted without a warning unless <samp class="option">-Wpedantic</samp> is used. Attempting to use the return value of a non-<code class="code">void</code> function other than <code class="code">main</code> that flows off the end by reaching the closing curly brace that terminates the function is undefined. </p> <p>Unlike in C, in C++, flowing off the end of a non-<code class="code">void</code> function other than <code class="code">main</code> results in undefined behavior even when the value of the function is not used. </p> <p>This warning is enabled by default in C++ and by <samp class="option">-Wall</samp> otherwise. </p> </dd> <dt>
 <span><code class="code">-Wno-shift-count-negative</code><a class="copiable-link" href="#index-Wshift-count-negative"> ¶</a></span>
</dt> <dd>
<p>Controls warnings if a shift count is negative. This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wno-shift-count-overflow</code><a class="copiable-link" href="#index-Wshift-count-overflow"> ¶</a></span>
</dt> <dd>
<p>Controls warnings if a shift count is greater than or equal to the bit width of the type. This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wshift-negative-value</code><a class="copiable-link" href="#index-Wshift-negative-value"> ¶</a></span>
</dt> <dd>
<p>Warn if left shifting a negative value. This warning is enabled by <samp class="option">-Wextra</samp> in C99 (and newer) and C++11 to C++17 modes. </p> </dd> <dt>
 <span><code class="code">-Wno-shift-overflow</code><a class="copiable-link" href="#index-Wshift-overflow"> ¶</a></span>
</dt> <dt><code class="code">-Wshift-overflow=<var class="var">n</var></code></dt> <dd>
<p>These options control warnings about left shift overflows. </p> <dl class="table"> <dt><code class="code">-Wshift-overflow=1</code></dt> <dd>
<p>This is the warning level of <samp class="option">-Wshift-overflow</samp> and is enabled by default in C99 and C++11 modes (and newer). This warning level does not warn about left-shifting 1 into the sign bit. (However, in C, such an overflow is still rejected in contexts where an integer constant expression is required.) No warning is emitted in C++20 mode (and newer), as signed left shifts always wrap. </p> </dd> <dt><code class="code">-Wshift-overflow=2</code></dt> <dd><p>This warning level also warns about left-shifting 1 into the sign bit, unless C++14 mode (or newer) is active. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wswitch</code><a class="copiable-link" href="#index-Wswitch"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a <code class="code">switch</code> statement has an index of enumerated type and lacks a <code class="code">case</code> for one or more of the named codes of that enumeration. (The presence of a <code class="code">default</code> label prevents this warning.) <code class="code">case</code> labels outside the enumeration range also provoke warnings when this option is used (even if there is a <code class="code">default</code> label). This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wswitch-default</code><a class="copiable-link" href="#index-Wswitch-default"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a <code class="code">switch</code> statement does not have a <code class="code">default</code> case. </p> </dd> <dt>
 <span><code class="code">-Wswitch-enum</code><a class="copiable-link" href="#index-Wswitch-enum"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a <code class="code">switch</code> statement has an index of enumerated type and lacks a <code class="code">case</code> for one or more of the named codes of that enumeration. <code class="code">case</code> labels outside the enumeration range also provoke warnings when this option is used. The only difference between <samp class="option">-Wswitch</samp> and this option is that this option gives a warning about an omitted enumeration code even if there is a <code class="code">default</code> label. </p> </dd> <dt>
 <span><code class="code">-Wno-switch-bool</code><a class="copiable-link" href="#index-Wswitch-bool"> ¶</a></span>
</dt> <dd>
<p>Do not warn when a <code class="code">switch</code> statement has an index of boolean type and the case values are outside the range of a boolean type. It is possible to suppress this warning by casting the controlling expression to a type other than <code class="code">bool</code>. For example: </p>
<div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch ((int) (a == 4))
  {
  …
  }</pre></div>
</div> <p>This warning is enabled by default for C and C++ programs. </p> </dd> <dt>
 <span><code class="code">-Wno-switch-outside-range</code><a class="copiable-link" href="#index-Wswitch-outside-range"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings when a <code class="code">switch</code> case has a value that is outside of its respective type range. This warning is enabled by default for C and C++ programs. </p> </dd> <dt>
 <span><code class="code">-Wno-switch-unreachable</code><a class="copiable-link" href="#index-Wswitch-unreachable"> ¶</a></span>
</dt> <dd>
<p>Do not warn when a <code class="code">switch</code> statement contains statements between the controlling expression and the first case label, which will never be executed. For example: </p>
<div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
   i = 15;
  …
   case 5:
  …
  }</pre></div>
</div> <p><samp class="option">-Wswitch-unreachable</samp> does not warn if the statement between the controlling expression and the first case label is just a declaration: </p>
<div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">switch (cond)
  {
   int i;
  …
   case 5:
   i = 5;
  …
  }</pre></div>
</div> <p>This warning is enabled by default for C and C++ programs. </p> </dd> <dt>
 <span><code class="code">-Wsync-nand <span class="r">(C and C++ only)</span></code><a class="copiable-link" href="#index-Wsync-nand"> ¶</a></span>
</dt> <dd>
<p>Warn when <code class="code">__sync_fetch_and_nand</code> and <code class="code">__sync_nand_and_fetch</code> built-in functions are used. These functions changed semantics in GCC 4.4. </p> </dd> <dt>
 <span><code class="code">-Wtrivial-auto-var-init</code><a class="copiable-link" href="#index-Wtrivial-auto-var-init"> ¶</a></span>
</dt> <dd>
<p>Warn when <code class="code">-ftrivial-auto-var-init</code> cannot initialize the automatic variable. A common situation is an automatic variable that is declared between the controlling expression and the first case label of a <code class="code">switch</code> statement. </p> </dd> <dt>
 <span><code class="code">-Wunused-but-set-parameter</code><a class="copiable-link" href="#index-Wunused-but-set-parameter"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a function parameter is assigned to, but otherwise unused (aside from its declaration). </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> <p>This warning is also enabled by <samp class="option">-Wunused</samp> together with <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused-but-set-variable</code><a class="copiable-link" href="#index-Wunused-but-set-variable"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a local variable is assigned to, but otherwise unused (aside from its declaration). This warning is enabled by <samp class="option">-Wall</samp>. </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> <p>This warning is also enabled by <samp class="option">-Wunused</samp>, which is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused-function</code><a class="copiable-link" href="#index-Wunused-function"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a static function is declared but not defined or a non-inline static function is unused. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused-label</code><a class="copiable-link" href="#index-Wunused-label"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a label is declared but not used. This warning is enabled by <samp class="option">-Wall</samp>. </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> </dd> <dt>
 <span><code class="code">-Wunused-local-typedefs <span class="r">(C, Objective-C, C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wunused-local-typedefs"> ¶</a></span>
</dt> <dd>
<p>Warn when a typedef locally defined in a function is not used. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused-parameter</code><a class="copiable-link" href="#index-Wunused-parameter"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a function parameter is unused aside from its declaration. </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> </dd> <dt>
 <span><code class="code">-Wno-unused-result</code><a class="copiable-link" href="#index-Wunused-result"> ¶</a></span>
</dt> <dd>
<p>Do not warn if a caller of a function marked with attribute <code class="code">warn_unused_result</code> (see <a class="pxref" href="function-attributes.html">Declaring Attributes of Functions</a>) does not use its return value. The default is <samp class="option">-Wunused-result</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused-variable</code><a class="copiable-link" href="#index-Wunused-variable"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a local or static variable is unused aside from its declaration. This option implies <samp class="option">-Wunused-const-variable=1</samp> for C, but not for C++. This warning is enabled by <samp class="option">-Wall</samp>. </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> </dd> <dt>
 <span><code class="code">-Wunused-const-variable</code><a class="copiable-link" href="#index-Wunused-const-variable"> ¶</a></span>
</dt> <dt><code class="code">-Wunused-const-variable=<var class="var">n</var></code></dt> <dd>
<p>Warn whenever a constant static variable is unused aside from its declaration. <samp class="option">-Wunused-const-variable=1</samp> is enabled by <samp class="option">-Wunused-variable</samp> for C, but not for C++. In C this declares variable storage, but in C++ this is not an error since const variables take the place of <code class="code">#define</code>s. </p> <p>To suppress this warning use the <code class="code">unused</code> attribute (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>). </p> <dl class="table"> <dt><code class="code">-Wunused-const-variable=1</code></dt> <dd>
<p>This is the warning level that is enabled by <samp class="option">-Wunused-variable</samp> for C. It warns only about unused static const variables defined in the main compilation unit, but not about static const variables declared in any header included. </p> </dd> <dt><code class="code">-Wunused-const-variable=2</code></dt> <dd><p>This warning level also warns for unused constant static variables in headers (excluding system headers). This is the warning level of <samp class="option">-Wunused-const-variable</samp> and must be explicitly requested since in C++ this isn’t an error and in C it might be harder to clean up all headers included. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wunused-value</code><a class="copiable-link" href="#index-Wunused-value"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a statement computes a result that is explicitly not used. To suppress this warning cast the unused expression to <code class="code">void</code>. This includes an expression-statement or the left-hand side of a comma expression that contains no side effects. For example, an expression such as <code class="code">x[i,j]</code> causes a warning, while <code class="code">x[(void)i,j]</code> does not. </p> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunused</code><a class="copiable-link" href="#index-Wunused"> ¶</a></span>
</dt> <dd>
<p>All the above <samp class="option">-Wunused</samp> options combined. </p> <p>In order to get a warning about an unused function parameter, you must either specify <samp class="option">-Wextra -Wunused</samp> (note that <samp class="option">-Wall</samp> implies <samp class="option">-Wunused</samp>), or separately specify <samp class="option">-Wunused-parameter</samp>. </p> </dd> <dt>
 <span><code class="code">-Wuninitialized</code><a class="copiable-link" href="#index-Wuninitialized"> ¶</a></span>
</dt> <dd>
<p>Warn if an object with automatic or allocated storage duration is used without having been initialized. In C++, also warn if a non-static reference or non-static <code class="code">const</code> member appears in a class without constructors. </p> <p>In addition, passing a pointer (or in C++, a reference) to an uninitialized object to a <code class="code">const</code>-qualified argument of a built-in function known to read the object is also diagnosed by this warning. (<samp class="option">-Wmaybe-uninitialized</samp> is issued for ordinary functions.) </p> <p>If you want to warn about code that uses the uninitialized value of the variable in its own initializer, use the <samp class="option">-Winit-self</samp> option. </p> <p>These warnings occur for individual uninitialized elements of structure, union or array variables as well as for variables that are uninitialized as a whole. They do not occur for variables or elements declared <code class="code">volatile</code>. Because these warnings depend on optimization, the exact variables or elements for which there are warnings depend on the precise optimization options and version of GCC used. </p> <p>Note that there may be no warning about a variable that is used only to compute a value that itself is never used, because such computations may be deleted by data flow analysis before the warnings are printed. </p> <p>In C++, this warning also warns about using uninitialized objects in member-initializer-lists. For example, GCC warns about <code class="code">b</code> being uninitialized in the following snippet: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct A {
  int a;
  int b;
  A() : a(b) { }
};</pre>
</div> </dd> <dt>
 <span><code class="code">-Wno-invalid-memory-model</code><a class="copiable-link" href="#index-Winvalid-memory-model"> ¶</a></span>
</dt> <dd>
<p>This option controls warnings for invocations of <a class="ref" href="_005f_005fatomic-builtins.html">Built-in Functions for Memory Model Aware Atomic Operations</a>, <a class="ref" href="_005f_005fsync-builtins.html">Legacy <code class="code">__sync</code> Built-in Functions for Atomic Memory Access</a>, and the C11 atomic generic functions with a memory consistency argument that is either invalid for the operation or outside the range of values of the <code class="code">memory_order</code> enumeration. For example, since the <code class="code">__atomic_store</code> and <code class="code">__atomic_store_n</code> built-ins are only defined for the relaxed, release, and sequentially consistent memory orders the following code is diagnosed: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void store (int *i)
{
  __atomic_store_n (i, 0, memory_order_consume);
}</pre>
</div> <p><samp class="option">-Winvalid-memory-model</samp> is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wmaybe-uninitialized</code><a class="copiable-link" href="#index-Wmaybe-uninitialized"> ¶</a></span>
</dt> <dd>
<p>For an object with automatic or allocated storage duration, if there exists a path from the function entry to a use of the object that is initialized, but there exist some other paths for which the object is not initialized, the compiler emits a warning if it cannot prove the uninitialized paths are not executed at run time. </p> <p>In addition, passing a pointer (or in C++, a reference) to an uninitialized object to a <code class="code">const</code>-qualified function argument is also diagnosed by this warning. (<samp class="option">-Wuninitialized</samp> is issued for built-in functions known to read the object.) Annotating the function with attribute <code class="code">access (none)</code> indicates that the argument isn’t used to access the object and avoids the warning (see <a class="pxref" href="common-function-attributes.html">Common Function Attributes</a>). </p> <p>These warnings are only possible in optimizing compilation, because otherwise GCC does not keep track of the state of variables. </p> <p>These warnings are made optional because GCC may not be able to determine when the code is correct in spite of appearing to have an error. Here is one example of how this can happen: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">{
  int x;
  switch (y)
    {
    case 1: x = 1;
      break;
    case 2: x = 4;
      break;
    case 3: x = 5;
    }
  foo (x);
}</pre></div>
</div> <p>If the value of <code class="code">y</code> is always 1, 2 or 3, then <code class="code">x</code> is always initialized, but GCC doesn’t know this. To suppress the warning, you need to provide a default case with assert(0) or similar code. </p>  <p>This option also warns when a non-volatile automatic variable might be changed by a call to <code class="code">longjmp</code>. The compiler sees only the calls to <code class="code">setjmp</code>. It cannot know where <code class="code">longjmp</code> will be called; in fact, a signal handler could call it at any point in the code. As a result, you may get a warning even when there is in fact no problem because <code class="code">longjmp</code> cannot in fact be called at the place that would cause a problem. </p> <p>Some spurious warnings can be avoided if you declare all the functions you use that never return as <code class="code">noreturn</code>. See <a class="xref" href="function-attributes.html">Declaring Attributes of Functions</a>. </p> <p>This warning is enabled by <samp class="option">-Wall</samp> or <samp class="option">-Wextra</samp>. </p> </dd> <dt>
    <span><code class="code">-Wunknown-pragmas</code><a class="copiable-link" href="#index-Wunknown-pragmas"> ¶</a></span>
</dt> <dd>
<p>Warn when a <code class="code">#pragma</code> directive is encountered that is not understood by GCC. If this command-line option is used, warnings are even issued for unknown pragmas in system header files. This is not the case if the warnings are only enabled by the <samp class="option">-Wall</samp> command-line option. </p> </dd> <dt>
 <span><code class="code">-Wno-pragmas</code><a class="copiable-link" href="#index-Wno-pragmas"> ¶</a></span>
</dt> <dd>
<p>Do not warn about misuses of pragmas, such as incorrect parameters, invalid syntax, or conflicts between pragmas. See also <samp class="option">-Wunknown-pragmas</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-prio-ctor-dtor</code><a class="copiable-link" href="#index-Wno-prio-ctor-dtor"> ¶</a></span>
</dt> <dd>
<p>Do not warn if a priority from 0 to 100 is used for constructor or destructor. The use of constructor and destructor attributes allow you to assign a priority to the constructor/destructor to control its order of execution before <code class="code">main</code> is called or after it returns. The priority values must be greater than 100 as the compiler reserves priority values between 0–100 for the implementation. </p> </dd> <dt>
 <span><code class="code">-Wstrict-aliasing</code><a class="copiable-link" href="#index-Wstrict-aliasing"> ¶</a></span>
</dt> <dd>
<p>This option is only active when <samp class="option">-fstrict-aliasing</samp> is active. It warns about code that might break the strict aliasing rules that the compiler is using for optimization. The warning does not catch all cases, but does attempt to catch the more common pitfalls. It is included in <samp class="option">-Wall</samp>. It is equivalent to <samp class="option">-Wstrict-aliasing=3</samp> </p> </dd> <dt>
<span><code class="code">-Wstrict-aliasing=n</code><a class="copiable-link" href="#index-Wstrict-aliasing_003dn"> ¶</a></span>
</dt> <dd>
<p>This option is only active when <samp class="option">-fstrict-aliasing</samp> is active. It warns about code that might break the strict aliasing rules that the compiler is using for optimization. Higher levels correspond to higher accuracy (fewer false positives). Higher levels also correspond to more effort, similar to the way <samp class="option">-O</samp> works. <samp class="option">-Wstrict-aliasing</samp> is equivalent to <samp class="option">-Wstrict-aliasing=3</samp>. </p> <p>Level 1: Most aggressive, quick, least accurate. Possibly useful when higher levels do not warn but <samp class="option">-fstrict-aliasing</samp> still breaks the code, as it has very few false negatives. However, it has many false positives. Warns for all pointer conversions between possibly incompatible types, even if never dereferenced. Runs in the front end only. </p> <p>Level 2: Aggressive, quick, not too precise. May still have many false positives (not as many as level 1 though), and few false negatives (but possibly more than level 1). Unlike level 1, it only warns when an address is taken. Warns about incomplete types. Runs in the front end only. </p> <p>Level 3 (default for <samp class="option">-Wstrict-aliasing</samp>): Should have very few false positives and few false negatives. Slightly slower than levels 1 or 2 when optimization is enabled. Takes care of the common pun+dereference pattern in the front end: <code class="code">*(int*)&amp;some_float</code>. If optimization is enabled, it also runs in the back end, where it deals with multiple statement cases using flow-sensitive points-to information. Only warns when the converted pointer is dereferenced. Does not warn about incomplete types. </p> </dd> <dt>
 <span><code class="code">-Wstrict-overflow</code><a class="copiable-link" href="#index-Wstrict-overflow"> ¶</a></span>
</dt> <dt><code class="code">-Wstrict-overflow=<var class="var">n</var></code></dt> <dd>
<p>This option is only active when signed overflow is undefined. It warns about cases where the compiler optimizes based on the assumption that signed overflow does not occur. Note that it does not warn about all cases where the code might overflow: it only warns about cases where the compiler implements some optimization. Thus this warning depends on the optimization level. </p> <p>An optimization that assumes that signed overflow does not occur is perfectly safe if the values of the variables involved are such that overflow never does, in fact, occur. Therefore this warning can easily give a false positive: a warning about code that is not actually a problem. To help focus on important issues, several warning levels are defined. No warnings are issued for the use of undefined signed overflow when estimating how many iterations a loop requires, in particular when determining whether a loop will be executed at all. </p> <dl class="table"> <dt><code class="code">-Wstrict-overflow=1</code></dt> <dd>
<p>Warn about cases that are both questionable and easy to avoid. For example the compiler simplifies <code class="code">x + 1 &gt; x</code> to <code class="code">1</code>. This level of <samp class="option">-Wstrict-overflow</samp> is enabled by <samp class="option">-Wall</samp>; higher levels are not, and must be explicitly requested. </p> </dd> <dt><code class="code">-Wstrict-overflow=2</code></dt> <dd>
<p>Also warn about other cases where a comparison is simplified to a constant. For example: <code class="code">abs (x) &gt;= 0</code>. This can only be simplified when signed integer overflow is undefined, because <code class="code">abs (INT_MIN)</code> overflows to <code class="code">INT_MIN</code>, which is less than zero. <samp class="option">-Wstrict-overflow</samp> (with no level) is the same as <samp class="option">-Wstrict-overflow=2</samp>. </p> </dd> <dt><code class="code">-Wstrict-overflow=3</code></dt> <dd>
<p>Also warn about other cases where a comparison is simplified. For example: <code class="code">x + 1 &gt; 1</code> is simplified to <code class="code">x &gt; 0</code>. </p> </dd> <dt><code class="code">-Wstrict-overflow=4</code></dt> <dd>
<p>Also warn about other simplifications not covered by the above cases. For example: <code class="code">(x * 10) / 5</code> is simplified to <code class="code">x * 2</code>. </p> </dd> <dt><code class="code">-Wstrict-overflow=5</code></dt> <dd><p>Also warn about cases where the compiler reduces the magnitude of a constant involved in a comparison. For example: <code class="code">x + 2 &gt; y</code> is simplified to <code class="code">x + 1 &gt;= y</code>. This is reported only at the highest warning level because this simplification applies to many comparisons, so this warning level gives a very large number of false positives. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wstring-compare</code><a class="copiable-link" href="#index-Wstring-compare"> ¶</a></span>
</dt> <dd>
<p>Warn for calls to <code class="code">strcmp</code> and <code class="code">strncmp</code> whose result is determined to be either zero or non-zero in tests for such equality owing to the length of one argument being greater than the size of the array the other argument is stored in (or the bound in the case of <code class="code">strncmp</code>). Such calls could be mistakes. For example, the call to <code class="code">strcmp</code> below is diagnosed because its result is necessarily non-zero irrespective of the contents of the array <code class="code">a</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">extern char a[4];
void f (char *d)
{
  strcpy (d, "string");
  …
  if (0 == strcmp (a, d))   // cannot be true
    puts ("a and d are the same");
}</pre>
</div> <p><samp class="option">-Wstring-compare</samp> is enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-stringop-overflow</code><a class="copiable-link" href="#index-Wstringop-overflow"> ¶</a></span>
</dt> <dt><code class="code">-Wstringop-overflow</code></dt> <dt><code class="code">-Wstringop-overflow=<var class="var">type</var></code></dt> <dd>
<p>Warn for calls to string manipulation functions such as <code class="code">memcpy</code> and <code class="code">strcpy</code> that are determined to overflow the destination buffer. The optional argument is one greater than the type of Object Size Checking to perform to determine the size of the destination. See <a class="xref" href="object-size-checking.html">Object Size Checking</a>. The argument is meaningful only for functions that operate on character arrays but not for raw memory functions like <code class="code">memcpy</code> which always make use of Object Size type-0. The option also warns for calls that specify a size in excess of the largest possible object or at most <code class="code">SIZE_MAX / 2</code> bytes. The option produces the best results with optimization enabled but can detect a small subset of simple buffer overflows even without optimization in calls to the GCC built-in functions like <code class="code">__builtin_memcpy</code> that correspond to the standard functions. In any case, the option warns about just a subset of buffer overflows detected by the corresponding overflow checking built-ins. For example, the option issues a warning for the <code class="code">strcpy</code> call below because it copies at least 5 characters (the string <code class="code">"blue"</code> including the terminating NUL) into the buffer of size 4. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">enum Color { blue, purple, yellow };
const char* f (enum Color clr)
{
  static char buf [4];
  const char *str;
  switch (clr)
    {
      case blue: str = "blue"; break;
      case purple: str = "purple"; break;
      case yellow: str = "yellow"; break;
    }

  return strcpy (buf, str);   // warning here
}</pre>
</div> <p>Option <samp class="option">-Wstringop-overflow=2</samp> is enabled by default. </p> <dl class="table"> <dt>
 <span><code class="code">-Wstringop-overflow</code><a class="copiable-link" href="#index-Wstringop-overflow-1"> ¶</a></span>
</dt> <dt><code class="code">-Wstringop-overflow=1</code></dt> <dd>
<p>The <samp class="option">-Wstringop-overflow=1</samp> option uses type-zero Object Size Checking to determine the sizes of destination objects. At this setting the option does not warn for writes past the end of subobjects of larger objects accessed by pointers unless the size of the largest surrounding object is known. When the destination may be one of several objects it is assumed to be the largest one of them. On Linux systems, when optimization is enabled at this setting the option warns for the same code as when the <code class="code">_FORTIFY_SOURCE</code> macro is defined to a non-zero value. </p> </dd> <dt><code class="code">-Wstringop-overflow=2</code></dt> <dd>
<p>The <samp class="option">-Wstringop-overflow=2</samp> option uses type-one Object Size Checking to determine the sizes of destination objects. At this setting the option warns about overflows when writing to members of the largest complete objects whose exact size is known. However, it does not warn for excessive writes to the same members of unknown objects referenced by pointers since they may point to arrays containing unknown numbers of elements. This is the default setting of the option. </p> </dd> <dt><code class="code">-Wstringop-overflow=3</code></dt> <dd>
<p>The <samp class="option">-Wstringop-overflow=3</samp> option uses type-two Object Size Checking to determine the sizes of destination objects. At this setting the option warns about overflowing the smallest object or data member. This is the most restrictive setting of the option that may result in warnings for safe code. </p> </dd> <dt><code class="code">-Wstringop-overflow=4</code></dt> <dd><p>The <samp class="option">-Wstringop-overflow=4</samp> option uses type-three Object Size Checking to determine the sizes of destination objects. At this setting the option warns about overflowing any data members, and when the destination is one of several objects it uses the size of the largest of them to decide whether to issue a warning. Similarly to <samp class="option">-Wstringop-overflow=3</samp> this setting of the option may result in warnings for benign code. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Wno-stringop-overread</code><a class="copiable-link" href="#index-Wstringop-overread"> ¶</a></span>
</dt> <dd>
<p>Warn for calls to string manipulation functions such as <code class="code">memchr</code>, or <code class="code">strcpy</code> that are determined to read past the end of the source sequence. </p> <p>Option <samp class="option">-Wstringop-overread</samp> is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wno-stringop-truncation</code><a class="copiable-link" href="#index-Wstringop-truncation"> ¶</a></span>
</dt> <dd>
<p>Do not warn for calls to bounded string manipulation functions such as <code class="code">strncat</code>, <code class="code">strncpy</code>, and <code class="code">stpncpy</code> that may either truncate the copied string or leave the destination unchanged. </p> <p>In the following example, the call to <code class="code">strncat</code> specifies a bound that is less than the length of the source string. As a result, the copy of the source will be truncated and so the call is diagnosed. To avoid the warning use <code class="code">bufsize - strlen (buf) - 1)</code> as the bound. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void append (char *buf, size_t bufsize)
{
  strncat (buf, ".txt", 3);
}</pre>
</div> <p>As another example, the following call to <code class="code">strncpy</code> results in copying to <code class="code">d</code> just the characters preceding the terminating NUL, without appending the NUL to the end. Assuming the result of <code class="code">strncpy</code> is necessarily a NUL-terminated string is a common mistake, and so the call is diagnosed. To avoid the warning when the result is not expected to be NUL-terminated, call <code class="code">memcpy</code> instead. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void copy (char *d, const char *s)
{
  strncpy (d, s, strlen (s));
}</pre>
</div> <p>In the following example, the call to <code class="code">strncpy</code> specifies the size of the destination buffer as the bound. If the length of the source string is equal to or greater than this size the result of the copy will not be NUL-terminated. Therefore, the call is also diagnosed. To avoid the warning, specify <code class="code">sizeof buf - 1</code> as the bound and set the last element of the buffer to <code class="code">NUL</code>. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void copy (const char *s)
{
  char buf[80];
  strncpy (buf, s, sizeof buf);
  …
}</pre>
</div> <p>In situations where a character array is intended to store a sequence of bytes with no terminating <code class="code">NUL</code> such an array may be annotated with attribute <code class="code">nonstring</code> to avoid this warning. Such arrays, however, are not suitable arguments to functions that expect <code class="code">NUL</code>-terminated strings. To help detect accidental misuses of such arrays GCC issues warnings unless it can prove that the use is safe. See <a class="xref" href="common-variable-attributes.html">Common Variable Attributes</a>. </p> </dd> <dt>
 <span><code class="code">-Wstrict-flex-arrays</code><a class="copiable-link" href="#index-Wstrict-flex-arrays"> ¶</a></span>
</dt> <dd>
<p>Warn about inproper usages of flexible array members according to the <var class="var">level</var> of the <code class="code">strict_flex_array (<var class="var">level</var>)</code> attribute attached to the trailing array field of a structure if it’s available, otherwise according to the <var class="var">level</var> of the option <samp class="option">-fstrict-flex-arrays=<var class="var">level</var></samp>. </p> <p>This option is effective only when <var class="var">level</var> is bigger than 0. Otherwise, it will be ignored with a warning. </p> <p>when <var class="var">level</var>=1, warnings will be issued for a trailing array reference of a structure that have 2 or more elements if the trailing array is referenced as a flexible array member. </p> <p>when <var class="var">level</var>=2, in addition to <var class="var">level</var>=1, additional warnings will be issued for a trailing one-element array reference of a structure if the array is referenced as a flexible array member. </p> <p>when <var class="var">level</var>=3, in addition to <var class="var">level</var>=2, additional warnings will be issued for a trailing zero-length array reference of a structure if the array is referenced as a flexible array member. </p> </dd> <dt>
 <span><code class="code">-Wsuggest-attribute=<span class="r">[</span>pure<span class="r">|</span>const<span class="r">|</span>noreturn<span class="r">|</span>format<span class="r">|</span>cold<span class="r">|</span>malloc<span class="r">]</span></code><a class="copiable-link" href="#index-Wsuggest-attribute_003d"> ¶</a></span>
</dt> <dd>
<p>Warn for cases where adding an attribute may be beneficial. The attributes currently supported are listed below. </p> <dl class="table"> <dt>
         <span><code class="code">-Wsuggest-attribute=pure</code><a class="copiable-link" href="#index-Wsuggest-attribute_003dpure"> ¶</a></span>
</dt> <dt><code class="code">-Wsuggest-attribute=const</code></dt> <dt><code class="code">-Wsuggest-attribute=noreturn</code></dt> <dt><code class="code">-Wmissing-noreturn</code></dt> <dt><code class="code">-Wsuggest-attribute=malloc</code></dt> <dd> <p>Warn about functions that might be candidates for attributes <code class="code">pure</code>, <code class="code">const</code> or <code class="code">noreturn</code> or <code class="code">malloc</code>. The compiler only warns for functions visible in other compilation units or (in the case of <code class="code">pure</code> and <code class="code">const</code>) if it cannot prove that the function returns normally. A function returns normally if it doesn’t contain an infinite loop or return abnormally by throwing, calling <code class="code">abort</code> or trapping. This analysis requires option <samp class="option">-fipa-pure-const</samp>, which is enabled by default at <samp class="option">-O</samp> and higher. Higher optimization levels improve the accuracy of the analysis. </p> </dd> <dt>
     <span><code class="code">-Wsuggest-attribute=format</code><a class="copiable-link" href="#index-Wsuggest-attribute_003dformat"> ¶</a></span>
</dt> <dt><code class="code">-Wmissing-format-attribute</code></dt> <dd> <p>Warn about function pointers that might be candidates for <code class="code">format</code> attributes. Note these are only possible candidates, not absolute ones. GCC guesses that function pointers with <code class="code">format</code> attributes that are used in assignment, initialization, parameter passing or return statements should have a corresponding <code class="code">format</code> attribute in the resulting type. I.e. the left-hand side of the assignment or initialization, the type of the parameter variable, or the return type of the containing function respectively should also have a <code class="code">format</code> attribute to avoid the warning. </p> <p>GCC also warns about function definitions that might be candidates for <code class="code">format</code> attributes. Again, these are only possible candidates. GCC guesses that <code class="code">format</code> attributes might be appropriate for any function that calls a function like <code class="code">vprintf</code> or <code class="code">vscanf</code>, but this might not always be the case, and some functions for which <code class="code">format</code> attributes are appropriate may not be detected. </p> </dd> <dt>
 <span><code class="code">-Wsuggest-attribute=cold</code><a class="copiable-link" href="#index-Wsuggest-attribute_003dcold"> ¶</a></span>
</dt> <dd> <p>Warn about functions that might be candidates for <code class="code">cold</code> attribute. This is based on static detection and generally only warns about functions which always leads to a call to another <code class="code">cold</code> function such as wrappers of C++ <code class="code">throw</code> or fatal error reporting functions leading to <code class="code">abort</code>. </p>
</dd> </dl> </dd> <dt>
 <span><code class="code">-Walloc-zero</code><a class="copiable-link" href="#index-Wno-alloc-zero"> ¶</a></span>
</dt> <dd>
<p>Warn about calls to allocation functions decorated with attribute <code class="code">alloc_size</code> that specify zero bytes, including those to the built-in forms of the functions <code class="code">aligned_alloc</code>, <code class="code">alloca</code>, <code class="code">calloc</code>, <code class="code">malloc</code>, and <code class="code">realloc</code>. Because the behavior of these functions when called with a zero size differs among implementations (and in the case of <code class="code">realloc</code> has been deprecated) relying on it may result in subtle portability bugs and should be avoided. </p> </dd> <dt>
 <span><code class="code">-Walloc-size-larger-than=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Walloc-size-larger-than_003d"> ¶</a></span>
</dt> <dd>
<p>Warn about calls to functions decorated with attribute <code class="code">alloc_size</code> that attempt to allocate objects larger than the specified number of bytes, or where the result of the size computation in an integer type with infinite precision would exceed the value of ‘<samp class="samp">PTRDIFF_MAX</samp>’ on the target. <samp class="option">-Walloc-size-larger-than=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default. Warnings controlled by the option can be disabled either by specifying <var class="var">byte-size</var> of ‘<samp class="samp">SIZE_MAX</samp>’ or more or by <samp class="option">-Wno-alloc-size-larger-than</samp>. See <a class="xref" href="function-attributes.html">Declaring Attributes of Functions</a>. </p> </dd> <dt>
<span><code class="code">-Wno-alloc-size-larger-than</code><a class="copiable-link" href="#index-Wno-alloc-size-larger-than-1"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Walloc-size-larger-than=</samp> warnings. The option is equivalent to <samp class="option">-Walloc-size-larger-than=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
 <span><code class="code">-Walloca</code><a class="copiable-link" href="#index-Wno-alloca"> ¶</a></span>
</dt> <dd>
<p>This option warns on all uses of <code class="code">alloca</code> in the source. </p> </dd> <dt>
 <span><code class="code">-Walloca-larger-than=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Walloca-larger-than_003d"> ¶</a></span>
</dt> <dd>
<p>This option warns on calls to <code class="code">alloca</code> with an integer argument whose value is either zero, or that is not bounded by a controlling predicate that limits its value to at most <var class="var">byte-size</var>. It also warns for calls to <code class="code">alloca</code> where the bound value is unknown. Arguments of non-integer types are considered unbounded even if they appear to be constrained to the expected range. </p> <p>For example, a bounded case of <code class="code">alloca</code> could be: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void func (size_t n)
{
  void *p;
  if (n &lt;= 1000)
    p = alloca (n);
  else
    p = malloc (n);
  f (p);
}</pre>
</div> <p>In the above example, passing <code class="code">-Walloca-larger-than=1000</code> would not issue a warning because the call to <code class="code">alloca</code> is known to be at most 1000 bytes. However, if <code class="code">-Walloca-larger-than=500</code> were passed, the compiler would emit a warning. </p> <p>Unbounded uses, on the other hand, are uses of <code class="code">alloca</code> with no controlling predicate constraining its integer argument. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void func ()
{
  void *p = alloca (n);
  f (p);
}</pre>
</div> <p>If <code class="code">-Walloca-larger-than=500</code> were passed, the above would trigger a warning, but this time because of the lack of bounds checking. </p> <p>Note, that even seemingly correct code involving signed integers could cause a warning: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void func (signed int n)
{
  if (n &lt; 500)
    {
      p = alloca (n);
      f (p);
    }
}</pre>
</div> <p>In the above example, <var class="var">n</var> could be negative, causing a larger than expected argument to be implicitly cast into the <code class="code">alloca</code> call. </p> <p>This option also warns when <code class="code">alloca</code> is used in a loop. </p> <p><samp class="option">-Walloca-larger-than=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default but is usually only effective when <samp class="option">-ftree-vrp</samp> is active (default for <samp class="option">-O2</samp> and above). </p> <p>See also <samp class="option">-Wvla-larger-than=</samp>‘<samp class="samp">byte-size</samp>’. </p> </dd> <dt>
<span><code class="code">-Wno-alloca-larger-than</code><a class="copiable-link" href="#index-Wno-alloca-larger-than-1"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Walloca-larger-than=</samp> warnings. The option is equivalent to <samp class="option">-Walloca-larger-than=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
 <span><code class="code">-Warith-conversion</code><a class="copiable-link" href="#index-Warith-conversion"> ¶</a></span>
</dt> <dd>
<p>Do warn about implicit conversions from arithmetic operations even when conversion of the operands to the same type cannot change their values. This affects warnings from <samp class="option">-Wconversion</samp>, <samp class="option">-Wfloat-conversion</samp>, and <samp class="option">-Wsign-conversion</samp>. </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">void f (char c, int i)
{
  c = c + i; // warns with <samp class="option">-Wconversion</samp>
  c = c + 1; // only warns with <samp class="option">-Warith-conversion</samp>
}</pre></div>
</div> </dd> <dt>
 <span><code class="code">-Warray-bounds</code><a class="copiable-link" href="#index-Wno-array-bounds"> ¶</a></span>
</dt> <dt><code class="code">-Warray-bounds=<var class="var">n</var></code></dt> <dd>
<p>Warn about out of bounds subscripts or offsets into arrays. This warning is enabled by <samp class="option">-Wall</samp>. It is more effective when <samp class="option">-ftree-vrp</samp> is active (the default for <samp class="option">-O2</samp> and above) but a subset of instances are issued even without optimization. </p> <p>By default, the trailing array of a structure will be treated as a flexible array member by <samp class="option">-Warray-bounds</samp> or <samp class="option">-Warray-bounds=<var class="var">n</var></samp> if it is declared as either a flexible array member per C99 standard onwards (‘<samp class="samp">[]</samp>’), a GCC zero-length array extension (‘<samp class="samp">[0]</samp>’), or an one-element array (‘<samp class="samp">[1]</samp>’). As a result, out of bounds subscripts or offsets into zero-length arrays or one-element arrays are not warned by default. </p> <p>You can add the option <samp class="option">-fstrict-flex-arrays</samp> or <samp class="option">-fstrict-flex-arrays=<var class="var">level</var></samp> to control how this option treat trailing array of a structure as a flexible array member: </p> <p>when <var class="var">level</var>&lt;=1, no change to the default behavior. </p> <p>when <var class="var">level</var>=2, additional warnings will be issued for out of bounds subscripts or offsets into one-element arrays; </p> <p>when <var class="var">level</var>=3, in addition to <var class="var">level</var>=2, additional warnings will be issued for out of bounds subscripts or offsets into zero-length arrays. </p> <dl class="table"> <dt><code class="code">-Warray-bounds=1</code></dt> <dd>
<p>This is the default warning level of <samp class="option">-Warray-bounds</samp> and is enabled by <samp class="option">-Wall</samp>; higher levels are not, and must be explicitly requested. </p> </dd> <dt><code class="code">-Warray-bounds=2</code></dt> <dd><p>This warning level also warns about the intermediate results of pointer arithmetic that may yield out of bounds values. This warning level may give a larger number of false positives and is deactivated by default. </p></dd> </dl> </dd> <dt>
 <span><code class="code">-Warray-compare</code><a class="copiable-link" href="#index-Warray-compare"> ¶</a></span>
</dt> <dd>
<p>Warn about equality and relational comparisons between two operands of array type. This comparison was deprecated in C++20. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int arr1[5];
int arr2[5];
bool same = arr1 == arr2;</pre>
</div> <p><samp class="option">-Warray-compare</samp> is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
<span><code class="code">-Warray-parameter</code><a class="copiable-link" href="#index-Wno-array-parameter"> ¶</a></span>
</dt> <dt><code class="code">-Warray-parameter=<var class="var">n</var></code></dt> <dd>
<p>Warn about redeclarations of functions involving arguments of array or pointer types of inconsistent kinds or forms, and enable the detection of out-of-bounds accesses to such parameters by warnings such as <samp class="option">-Warray-bounds</samp>. </p> <p>If the first function declaration uses the array form the bound specified in the array is assumed to be the minimum number of elements expected to be provided in calls to the function and the maximum number of elements accessed by it. Failing to provide arguments of sufficient size or accessing more than the maximum number of elements may be diagnosed by warnings such as <samp class="option">-Warray-bounds</samp>. At level 1 the warning diagnoses inconsistencies involving array parameters declared using the <code class="code">T[static N]</code> form. </p> <p>For example, the warning triggers for the following redeclarations because the first one allows an array of any size to be passed to <code class="code">f</code> while the second one with the keyword <code class="code">static</code> specifies that the array argument must have at least four elements. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (int[static 4]);
void f (int[]);           // warning (inconsistent array form)

void g (void)
{
  int *p = (int *)malloc (4);
  f (p);                  // warning (array too small)
  …
}</pre>
</div> <p>At level 2 the warning also triggers for redeclarations involving any other inconsistency in array or pointer argument forms denoting array sizes. Pointers and arrays of unspecified bound are considered equivalent and do not trigger a warning. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void g (int*);
void g (int[]);     // no warning
void g (int[8]);    // warning (inconsistent array bound)</pre>
</div> <p><samp class="option">-Warray-parameter=2</samp> is included in <samp class="option">-Wall</samp>. The <samp class="option">-Wvla-parameter</samp> option triggers warnings for similar inconsistencies involving Variable Length Array arguments. </p> </dd> <dt>
 <span><code class="code">-Wattribute-alias=<var class="var">n</var></code><a class="copiable-link" href="#index-Wattribute-alias"> ¶</a></span>
</dt> <dt><code class="code">-Wno-attribute-alias</code></dt> <dd>
<p>Warn about declarations using the <code class="code">alias</code> and similar attributes whose target is incompatible with the type of the alias. See <a class="xref" href="function-attributes.html">Declaring Attributes of Functions</a>. </p> <dl class="table"> <dt><code class="code">-Wattribute-alias=1</code></dt> <dd>
<p>The default warning level of the <samp class="option">-Wattribute-alias</samp> option diagnoses incompatibilities between the type of the alias declaration and that of its target. Such incompatibilities are typically indicative of bugs. </p> </dd> <dt><code class="code">-Wattribute-alias=2</code></dt> <dd> <p>At this level <samp class="option">-Wattribute-alias</samp> also diagnoses cases where the attributes of the alias declaration are more restrictive than the attributes applied to its target. These mismatches can potentially result in incorrect code generation. In other cases they may be benign and could be resolved simply by adding the missing attribute to the target. For comparison, see the <samp class="option">-Wmissing-attributes</samp> option, which controls diagnostics when the alias declaration is less restrictive than the target, rather than more restrictive. </p> <p>Attributes considered include <code class="code">alloc_align</code>, <code class="code">alloc_size</code>, <code class="code">cold</code>, <code class="code">const</code>, <code class="code">hot</code>, <code class="code">leaf</code>, <code class="code">malloc</code>, <code class="code">nonnull</code>, <code class="code">noreturn</code>, <code class="code">nothrow</code>, <code class="code">pure</code>, <code class="code">returns_nonnull</code>, and <code class="code">returns_twice</code>. </p>
</dd> </dl> <p><samp class="option">-Wattribute-alias</samp> is equivalent to <samp class="option">-Wattribute-alias=1</samp>. This is the default. You can disable these warnings with either <samp class="option">-Wno-attribute-alias</samp> or <samp class="option">-Wattribute-alias=0</samp>. </p> </dd> <dt>
  <span><code class="code">-Wbidi-chars=<span class="r">[</span>none<span class="r">|</span>unpaired<span class="r">|</span>any<span class="r">|</span>ucn<span class="r">]</span></code><a class="copiable-link" href="#index-Wbidi-chars_003d"> ¶</a></span>
</dt> <dd>
<p>Warn about possibly misleading UTF-8 bidirectional control characters in comments, string literals, character constants, and identifiers. Such characters can change left-to-right writing direction into right-to-left (and vice versa), which can cause confusion between the logical order and visual order. This may be dangerous; for instance, it may seem that a piece of code is not commented out, whereas it in fact is. </p> <p>There are three levels of warning supported by GCC. The default is <samp class="option">-Wbidi-chars=unpaired</samp>, which warns about improperly terminated bidi contexts. <samp class="option">-Wbidi-chars=none</samp> turns the warning off. <samp class="option">-Wbidi-chars=any</samp> warns about any use of bidirectional control characters. </p> <p>By default, this warning does not warn about UCNs. It is, however, possible to turn on such checking by using <samp class="option">-Wbidi-chars=unpaired,ucn</samp> or <samp class="option">-Wbidi-chars=any,ucn</samp>. Using <samp class="option">-Wbidi-chars=ucn</samp> is valid, and is equivalent to <samp class="option">-Wbidi-chars=unpaired,ucn</samp>, if no previous <samp class="option">-Wbidi-chars=any</samp> was specified. </p> </dd> <dt>
 <span><code class="code">-Wbool-compare</code><a class="copiable-link" href="#index-Wno-bool-compare"> ¶</a></span>
</dt> <dd>
<p>Warn about boolean expression compared with an integer value different from <code class="code">true</code>/<code class="code">false</code>. For instance, the following comparison is always false: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int n = 5;
…
if ((n &gt; 1) == 2) { … }</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wbool-operation</code><a class="copiable-link" href="#index-Wno-bool-operation"> ¶</a></span>
</dt> <dd>
<p>Warn about suspicious operations on expressions of a boolean type. For instance, bitwise negation of a boolean is very likely a bug in the program. For C, this warning also warns about incrementing or decrementing a boolean, which rarely makes sense. (In C++, decrementing a boolean is always invalid. Incrementing a boolean is invalid in C++17, and deprecated otherwise.) </p> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wduplicated-branches</code><a class="copiable-link" href="#index-Wno-duplicated-branches"> ¶</a></span>
</dt> <dd>
<p>Warn when an if-else has identical branches. This warning detects cases like </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (p != NULL)
  return 0;
else
  return 0;</pre>
</div> <p>It doesn’t warn when both branches contain just a null statement. This warning also warn for conditional operators: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int i = x ? *p : *p;</pre>
</div> </dd> <dt>
 <span><code class="code">-Wduplicated-cond</code><a class="copiable-link" href="#index-Wno-duplicated-cond"> ¶</a></span>
</dt> <dd>
<p>Warn about duplicated conditions in an if-else-if chain. For instance, warn for the following code: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if (p-&gt;q != NULL) { … }
else if (p-&gt;q != NULL) { … }</pre>
</div> </dd> <dt>
 <span><code class="code">-Wframe-address</code><a class="copiable-link" href="#index-Wno-frame-address"> ¶</a></span>
</dt> <dd>
<p>Warn when the ‘<samp class="samp">__builtin_frame_address</samp>’ or ‘<samp class="samp">__builtin_return_address</samp>’ is called with an argument greater than 0. Such calls may return indeterminate values or crash the program. The warning is included in <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-discarded-qualifiers <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-discarded-qualifiers"> ¶</a></span>
</dt> <dd>
<p>Do not warn if type qualifiers on pointers are being discarded. Typically, the compiler warns if a <code class="code">const char *</code> variable is passed to a function that takes a <code class="code">char *</code> parameter. This option can be used to suppress such a warning. </p> </dd> <dt>
 <span><code class="code">-Wno-discarded-array-qualifiers <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-discarded-array-qualifiers"> ¶</a></span>
</dt> <dd>
<p>Do not warn if type qualifiers on arrays which are pointer targets are being discarded. Typically, the compiler warns if a <code class="code">const int (*)[]</code> variable is passed to a function that takes a <code class="code">int (*)[]</code> parameter. This option can be used to suppress such a warning. </p> </dd> <dt>
 <span><code class="code">-Wno-incompatible-pointer-types <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-incompatible-pointer-types"> ¶</a></span>
</dt> <dd>
<p>Do not warn when there is a conversion between pointers that have incompatible types. This warning is for cases not covered by <samp class="option">-Wno-pointer-sign</samp>, which warns for pointer argument passing or assignment with different signedness. </p> </dd> <dt>
 <span><code class="code">-Wno-int-conversion <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-int-conversion"> ¶</a></span>
</dt> <dd>
<p>Do not warn about incompatible integer to pointer and pointer to integer conversions. This warning is about implicit conversions; for explicit conversions the warnings <samp class="option">-Wno-int-to-pointer-cast</samp> and <samp class="option">-Wno-pointer-to-int-cast</samp> may be used. </p> </dd> <dt>
 <span><code class="code">-Wzero-length-bounds</code><a class="copiable-link" href="#index-Wzero-length-bounds"> ¶</a></span>
</dt> <dd>
<p>Warn about accesses to elements of zero-length array members that might overlap other members of the same object. Declaring interior zero-length arrays is discouraged because accesses to them are undefined. See <a class="xref" href="zero-length.html">Arrays of Length Zero</a>. </p> <p>For example, the first two stores in function <code class="code">bad</code> are diagnosed because the array elements overlap the subsequent members <code class="code">b</code> and <code class="code">c</code>. The third store is diagnosed by <samp class="option">-Warray-bounds</samp> because it is beyond the bounds of the enclosing object. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct X { int a[0]; int b, c; };
struct X x;

void bad (void)
{
  x.a[0] = 0;   // -Wzero-length-bounds
  x.a[1] = 1;   // -Wzero-length-bounds
  x.a[2] = 2;   // -Warray-bounds
}</pre>
</div> <p>Option <samp class="option">-Wzero-length-bounds</samp> is enabled by <samp class="option">-Warray-bounds</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-div-by-zero</code><a class="copiable-link" href="#index-Wno-div-by-zero"> ¶</a></span>
</dt> <dd>
<p>Do not warn about compile-time integer division by zero. Floating-point division by zero is not warned about, as it can be a legitimate way of obtaining infinities and NaNs. </p> </dd> <dt>
   <span><code class="code">-Wsystem-headers</code><a class="copiable-link" href="#index-Wsystem-headers"> ¶</a></span>
</dt> <dd>
<p>Print warning messages for constructs found in system header files. Warnings from system headers are normally suppressed, on the assumption that they usually do not indicate real problems and would only make the compiler output harder to read. Using this command-line option tells GCC to emit warnings from system headers as if they occurred in user code. However, note that using <samp class="option">-Wall</samp> in conjunction with this option does <em class="emph">not</em> warn about unknown pragmas in system headers—for that, <samp class="option">-Wunknown-pragmas</samp> must also be used. </p> </dd> <dt>
 <span><code class="code">-Wtautological-compare</code><a class="copiable-link" href="#index-Wtautological-compare"> ¶</a></span>
</dt> <dd>
<p>Warn if a self-comparison always evaluates to true or false. This warning detects various mistakes such as: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int i = 1;
…
if (i &gt; i) { … }</pre>
</div> <p>This warning also warns about bitwise comparisons that always evaluate to true or false, for instance: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if ((a &amp; 16) == 10) { … }</pre>
</div> <p>will always be false. </p> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wtrampolines</code><a class="copiable-link" href="#index-Wtrampolines"> ¶</a></span>
</dt> <dd>
<p>Warn about trampolines generated for pointers to nested functions. A trampoline is a small piece of data or code that is created at run time on the stack when the address of a nested function is taken, and is used to call the nested function indirectly. For some targets, it is made up of data only and thus requires no special treatment. But, for most targets, it is made up of code and thus requires the stack to be made executable in order for the program to work properly. </p> </dd> <dt>
 <span><code class="code">-Wfloat-equal</code><a class="copiable-link" href="#index-Wfloat-equal"> ¶</a></span>
</dt> <dd>
<p>Warn if floating-point values are used in equality comparisons. </p> <p>The idea behind this is that sometimes it is convenient (for the programmer) to consider floating-point values as approximations to infinitely precise real numbers. If you are doing this, then you need to compute (by analyzing the code, or in some other way) the maximum or likely maximum error that the computation introduces, and allow for it when performing comparisons (and when producing output, but that’s a different problem). In particular, instead of testing for equality, you should check to see whether the two values have ranges that overlap; and this is done with the relational operators, so equality comparisons are probably mistaken. </p> </dd> <dt>
 <span><code class="code">-Wtraditional <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wtraditional"> ¶</a></span>
</dt> <dd>
<p>Warn about certain constructs that behave differently in traditional and ISO C. Also warn about ISO C constructs that have no traditional C equivalent, and/or problematic constructs that should be avoided. </p> <ul class="itemize mark-bullet"> <li>Macro parameters that appear within string literals in the macro body. In traditional C macro replacement takes place within string literals, but in ISO C it does not. </li>
<li>In traditional C, some preprocessor directives did not exist. Traditional preprocessors only considered a line to be a directive if the ‘<samp class="samp">#</samp>’ appeared in column 1 on the line. Therefore <samp class="option">-Wtraditional</samp> warns about directives that traditional C understands but ignores because the ‘<samp class="samp">#</samp>’ does not appear as the first character on the line. It also suggests you hide directives like <code class="code">#pragma</code> not understood by traditional C by indenting them. Some traditional implementations do not recognize <code class="code">#elif</code>, so this option suggests avoiding it altogether. </li>
<li>A function-like macro that appears without arguments. </li>
<li>The unary plus operator. </li>
<li>The ‘<samp class="samp">U</samp>’ integer constant suffix, or the ‘<samp class="samp">F</samp>’ or ‘<samp class="samp">L</samp>’ floating-point constant suffixes. (Traditional C does support the ‘<samp class="samp">L</samp>’ suffix on integer constants.) Note, these suffixes appear in macros defined in the system headers of most modern systems, e.g. the ‘<samp class="samp">_MIN</samp>’/‘<samp class="samp">_MAX</samp>’ macros in <code class="code">&lt;limits.h&gt;</code>. Use of these macros in user code might normally lead to spurious warnings, however GCC’s integrated preprocessor has enough context to avoid warning in these cases. </li>
<li>A function declared external in one block and then used after the end of the block. </li>
<li>A <code class="code">switch</code> statement has an operand of type <code class="code">long</code>. </li>
<li>A non-<code class="code">static</code> function declaration follows a <code class="code">static</code> one. This construct is not accepted by some traditional C compilers. </li>
<li>The ISO type of an integer constant has a different width or signedness from its traditional type. This warning is only issued if the base of the constant is ten. I.e. hexadecimal or octal values, which typically represent bit patterns, are not warned about. </li>
<li>Usage of ISO string concatenation is detected. </li>
<li>Initialization of automatic aggregates. </li>
<li>Identifier conflicts with labels. Traditional C lacks a separate namespace for labels. </li>
<li>Initialization of unions. If the initializer is zero, the warning is omitted. This is done under the assumption that the zero initializer in user code appears conditioned on e.g. <code class="code">__STDC__</code> to avoid missing initializer warnings and relies on default initialization to zero in the traditional C case. </li>
<li>Conversions by prototypes between fixed/floating-point values and vice versa. The absence of these prototypes when compiling with traditional C causes serious problems. This is a subset of the possible conversion warnings; for the full set use <samp class="option">-Wtraditional-conversion</samp>. </li>
<li>Use of ISO C style function definitions. This warning intentionally is <em class="emph">not</em> issued for prototype declarations or variadic functions because these ISO C features appear in your code when using libiberty’s traditional C compatibility macros, <code class="code">PARAMS</code> and <code class="code">VPARAMS</code>. This warning is also bypassed for nested functions because that feature is already a GCC extension and thus not relevant to traditional C compatibility. </li>
</ul> </dd> <dt>
 <span><code class="code">-Wtraditional-conversion <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wtraditional-conversion"> ¶</a></span>
</dt> <dd>
<p>Warn if a prototype causes a type conversion that is different from what would happen to the same argument in the absence of a prototype. This includes conversions of fixed point to floating and vice versa, and conversions changing the width or signedness of a fixed-point argument except when the same as the default promotion. </p> </dd> <dt>
 <span><code class="code">-Wdeclaration-after-statement <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wdeclaration-after-statement"> ¶</a></span>
</dt> <dd>
<p>Warn when a declaration is found after a statement in a block. This construct, known from C++, was introduced with ISO C99 and is by default allowed in GCC. It is not supported by ISO C90. See <a class="xref" href="mixed-labels-and-declarations.html">Mixed Declarations, Labels and Code</a>. </p> </dd> <dt>
 <span><code class="code">-Wshadow</code><a class="copiable-link" href="#index-Wshadow"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a local variable or type declaration shadows another variable, parameter, type, class member (in C++), or instance variable (in Objective-C) or whenever a built-in function is shadowed. Note that in C++, the compiler warns if a local variable shadows an explicit typedef, but not if it shadows a struct/class/enum. If this warning is enabled, it includes also all instances of local shadowing. This means that <samp class="option">-Wno-shadow=local</samp> and <samp class="option">-Wno-shadow=compatible-local</samp> are ignored when <samp class="option">-Wshadow</samp> is used. Same as <samp class="option">-Wshadow=global</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-shadow-ivar <span class="r">(Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-shadow-ivar"> ¶</a></span>
</dt> <dd>
<p>Do not warn whenever a local variable shadows an instance variable in an Objective-C method. </p> </dd> <dt>
<span><code class="code">-Wshadow=global</code><a class="copiable-link" href="#index-Wshadow_003dglobal"> ¶</a></span>
</dt> <dd>
<p>Warn for any shadowing. Same as <samp class="option">-Wshadow</samp>. </p> </dd> <dt>
<span><code class="code">-Wshadow=local</code><a class="copiable-link" href="#index-Wshadow_003dlocal"> ¶</a></span>
</dt> <dd>
<p>Warn when a local variable shadows another local variable or parameter. </p> </dd> <dt>
<span><code class="code">-Wshadow=compatible-local</code><a class="copiable-link" href="#index-Wshadow_003dcompatible-local"> ¶</a></span>
</dt> <dd>
<p>Warn when a local variable shadows another local variable or parameter whose type is compatible with that of the shadowing variable. In C++, type compatibility here means the type of the shadowing variable can be converted to that of the shadowed variable. The creation of this flag (in addition to <samp class="option">-Wshadow=local</samp>) is based on the idea that when a local variable shadows another one of incompatible type, it is most likely intentional, not a bug or typo, as shown in the following example: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">for (SomeIterator i = SomeObj.begin(); i != SomeObj.end(); ++i)
{
  for (int i = 0; i &lt; N; ++i)
  {
    ...
  }
  ...
}</pre></div>
</div> <p>Since the two variable <code class="code">i</code> in the example above have incompatible types, enabling only <samp class="option">-Wshadow=compatible-local</samp> does not emit a warning. Because their types are incompatible, if a programmer accidentally uses one in place of the other, type checking is expected to catch that and emit an error or warning. Use of this flag instead of <samp class="option">-Wshadow=local</samp> can possibly reduce the number of warnings triggered by intentional shadowing. Note that this also means that shadowing <code class="code">const char *i</code> by <code class="code">char *i</code> does not emit a warning. </p> <p>This warning is also enabled by <samp class="option">-Wshadow=local</samp>. </p> </dd> <dt>
 <span><code class="code">-Wlarger-than=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Wlarger-than_003d"> ¶</a></span>
</dt> <dd>
<p>Warn whenever an object is defined whose size exceeds <var class="var">byte-size</var>. <samp class="option">-Wlarger-than=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default. Warnings controlled by the option can be disabled either by specifying <var class="var">byte-size</var> of ‘<samp class="samp">SIZE_MAX</samp>’ or more or by <samp class="option">-Wno-larger-than</samp>. </p> <p>Also warn for calls to bounded functions such as <code class="code">memchr</code> or <code class="code">strnlen</code> that specify a bound greater than the largest possible object, which is ‘<samp class="samp">PTRDIFF_MAX</samp>’ bytes by default. These warnings can only be disabled by <samp class="option">-Wno-larger-than</samp>. </p> </dd> <dt>
<span><code class="code">-Wno-larger-than</code><a class="copiable-link" href="#index-Wno-larger-than"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Wlarger-than=</samp> warnings. The option is equivalent to <samp class="option">-Wlarger-than=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
 <span><code class="code">-Wframe-larger-than=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Wframe-larger-than_003d"> ¶</a></span>
</dt> <dd>
<p>Warn if the size of a function frame exceeds <var class="var">byte-size</var>. The computation done to determine the stack frame size is approximate and not conservative. The actual requirements may be somewhat greater than <var class="var">byte-size</var> even if you do not get a warning. In addition, any space allocated via <code class="code">alloca</code>, variable-length arrays, or related constructs is not included by the compiler when determining whether or not to issue a warning. <samp class="option">-Wframe-larger-than=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default. Warnings controlled by the option can be disabled either by specifying <var class="var">byte-size</var> of ‘<samp class="samp">SIZE_MAX</samp>’ or more or by <samp class="option">-Wno-frame-larger-than</samp>. </p> </dd> <dt>
<span><code class="code">-Wno-frame-larger-than</code><a class="copiable-link" href="#index-Wno-frame-larger-than-1"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Wframe-larger-than=</samp> warnings. The option is equivalent to <samp class="option">-Wframe-larger-than=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
 <span><code class="code">-Wfree-nonheap-object</code><a class="copiable-link" href="#index-Wfree-nonheap-object"> ¶</a></span>
</dt> <dd>
<p>Warn when attempting to deallocate an object that was either not allocated on the heap, or by using a pointer that was not returned from a prior call to the corresponding allocation function. For example, because the call to <code class="code">stpcpy</code> returns a pointer to the terminating nul character and not to the beginning of the object, the call to <code class="code">free</code> below is diagnosed. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (char *p)
{
  p = stpcpy (p, "abc");
  // ...
  free (p);   // warning
}</pre>
</div> <p><samp class="option">-Wfree-nonheap-object</samp> is included in <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wstack-usage=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Wstack-usage"> ¶</a></span>
</dt> <dd>
<p>Warn if the stack usage of a function might exceed <var class="var">byte-size</var>. The computation done to determine the stack usage is conservative. Any space allocated via <code class="code">alloca</code>, variable-length arrays, or related constructs is included by the compiler when determining whether or not to issue a warning. </p> <p>The message is in keeping with the output of <samp class="option">-fstack-usage</samp>. </p> <ul class="itemize mark-bullet"> <li>If the stack usage is fully static but exceeds the specified amount, it’s: <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">warning: stack usage is 1120 bytes</pre>
</div> </li>
<li>If the stack usage is (partly) dynamic but bounded, it’s: <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">warning: stack usage might be 1648 bytes</pre>
</div> </li>
<li>If the stack usage is (partly) dynamic and not bounded, it’s: <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">warning: stack usage might be unbounded</pre>
</div> </li>
</ul> <p><samp class="option">-Wstack-usage=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default. Warnings controlled by the option can be disabled either by specifying <var class="var">byte-size</var> of ‘<samp class="samp">SIZE_MAX</samp>’ or more or by <samp class="option">-Wno-stack-usage</samp>. </p> </dd> <dt>
<span><code class="code">-Wno-stack-usage</code><a class="copiable-link" href="#index-Wno-stack-usage-1"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Wstack-usage=</samp> warnings. The option is equivalent to <samp class="option">-Wstack-usage=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
 <span><code class="code">-Wunsafe-loop-optimizations</code><a class="copiable-link" href="#index-Wunsafe-loop-optimizations"> ¶</a></span>
</dt> <dd>
<p>Warn if the loop cannot be optimized because the compiler cannot assume anything on the bounds of the loop indices. With <samp class="option">-funsafe-loop-optimizations</samp> warn if the compiler makes such assumptions. </p> </dd> <dt>
 <span><code class="code">-Wno-pedantic-ms-format <span class="r">(MinGW targets only)</span></code><a class="copiable-link" href="#index-Wno-pedantic-ms-format"> ¶</a></span>
</dt> <dd>
<p>When used in combination with <samp class="option">-Wformat</samp> and <samp class="option">-pedantic</samp> without GNU extensions, this option disables the warnings about non-ISO <code class="code">printf</code> / <code class="code">scanf</code> format width specifiers <code class="code">I32</code>, <code class="code">I64</code>, and <code class="code">I</code> used on Windows targets, which depend on the MS runtime. </p> </dd> <dt>
 <span><code class="code">-Wpointer-arith</code><a class="copiable-link" href="#index-Wpointer-arith"> ¶</a></span>
</dt> <dd>
<p>Warn about anything that depends on the “size of” a function type or of <code class="code">void</code>. GNU C assigns these types a size of 1, for convenience in calculations with <code class="code">void *</code> pointers and pointers to functions. In C++, warn also when an arithmetic operation involves <code class="code">NULL</code>. This warning is also enabled by <samp class="option">-Wpedantic</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-pointer-compare</code><a class="copiable-link" href="#index-Wpointer-compare"> ¶</a></span>
</dt> <dd>
<p>Do not warn if a pointer is compared with a zero character constant. This usually means that the pointer was meant to be dereferenced. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">const char *p = foo ();
if (p == '\0')
  return 42;</pre>
</div> <p>Note that the code above is invalid in C++11. </p> <p>This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wtsan</code><a class="copiable-link" href="#index-Wtsan"> ¶</a></span>
</dt> <dd>
<p>Warn about unsupported features in ThreadSanitizer. </p> <p>ThreadSanitizer does not support <code class="code">std::atomic_thread_fence</code> and can report false positives. </p> <p>This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wtype-limits</code><a class="copiable-link" href="#index-Wtype-limits"> ¶</a></span>
</dt> <dd>
<p>Warn if a comparison is always true or always false due to the limited range of the data type, but do not warn for constant expressions. For example, warn if an unsigned variable is compared against zero with <code class="code">&lt;</code> or <code class="code">&gt;=</code>. This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wabsolute-value <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wabsolute-value"> ¶</a></span>
</dt> <dd>
<p>Warn for calls to standard functions that compute the absolute value of an argument when a more appropriate standard function is available. For example, calling <code class="code">abs(3.14)</code> triggers the warning because the appropriate function to call to compute the absolute value of a double argument is <code class="code">fabs</code>. The option also triggers warnings when the argument in a call to such a function has an unsigned type. This warning can be suppressed with an explicit type cast and it is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wcomment</code><a class="copiable-link" href="#index-Wcomment"> ¶</a></span>
</dt> <dt><code class="code">-Wcomments</code></dt> <dd>
<p>Warn whenever a comment-start sequence ‘<samp class="samp">/*</samp>’ appears in a ‘<samp class="samp">/*</samp>’ comment, or whenever a backslash-newline appears in a ‘<samp class="samp">//</samp>’ comment. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
<span><code class="code">-Wtrigraphs</code><a class="copiable-link" href="#index-Wtrigraphs"> ¶</a></span>
</dt> <dd>
<p>Warn if any trigraphs are encountered that might change the meaning of the program. Trigraphs within comments are not warned about, except those that would form escaped newlines. </p> <p>This option is implied by <samp class="option">-Wall</samp>. If <samp class="option">-Wall</samp> is not given, this option is still enabled unless trigraphs are enabled. To get trigraph conversion without warnings, but get the other <samp class="option">-Wall</samp> warnings, use ‘<samp class="samp">-trigraphs -Wall -Wno-trigraphs</samp>’. </p> </dd> <dt>
 <span><code class="code">-Wundef</code><a class="copiable-link" href="#index-Wundef"> ¶</a></span>
</dt> <dd>
<p>Warn if an undefined identifier is evaluated in an <code class="code">#if</code> directive. Such identifiers are replaced with zero. </p> </dd> <dt>
<span><code class="code">-Wexpansion-to-defined</code><a class="copiable-link" href="#index-Wexpansion-to-defined"> ¶</a></span>
</dt> <dd>
<p>Warn whenever ‘<samp class="samp">defined</samp>’ is encountered in the expansion of a macro (including the case where the macro is expanded by an ‘<samp class="samp">#if</samp>’ directive). Such usage is not portable. This warning is also enabled by <samp class="option">-Wpedantic</samp> and <samp class="option">-Wextra</samp>. </p> </dd> <dt>
<span><code class="code">-Wunused-macros</code><a class="copiable-link" href="#index-Wunused-macros"> ¶</a></span>
</dt> <dd>
<p>Warn about macros defined in the main file that are unused. A macro is <em class="dfn">used</em> if it is expanded or tested for existence at least once. The preprocessor also warns if the macro has not been used at the time it is redefined or undefined. </p> <p>Built-in macros, macros defined on the command line, and macros defined in include files are not warned about. </p> <p><em class="emph">Note:</em> If a macro is actually used, but only used in skipped conditional blocks, then the preprocessor reports it as unused. To avoid the warning in such a case, you might improve the scope of the macro’s definition by, for example, moving it into the first skipped block. Alternatively, you could provide a dummy use with something like: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#if defined the_macro_causing_the_warning
#endif</pre>
</div> </dd> <dt>
 <span><code class="code">-Wno-endif-labels</code><a class="copiable-link" href="#index-Wno-endif-labels"> ¶</a></span>
</dt> <dd>
<p>Do not warn whenever an <code class="code">#else</code> or an <code class="code">#endif</code> are followed by text. This sometimes happens in older programs with code of the form </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#if FOO
…
#else FOO
…
#endif FOO</pre>
</div> <p>The second and third <code class="code">FOO</code> should be in comments. This warning is on by default. </p> </dd> <dt>
 <span><code class="code">-Wbad-function-cast <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wbad-function-cast"> ¶</a></span>
</dt> <dd>
<p>Warn when a function call is cast to a non-matching type. For example, warn if a call to a function returning an integer type is cast to a pointer type. </p> </dd> <dt>
 <span><code class="code">-Wc90-c99-compat <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wc90-c99-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about features not present in ISO C90, but present in ISO C99. For instance, warn about use of variable length arrays, <code class="code">long long</code> type, <code class="code">bool</code> type, compound literals, designated initializers, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows <code class="code">__extension__</code>. </p> </dd> <dt>
 <span><code class="code">-Wc99-c11-compat <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wc99-c11-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about features not present in ISO C99, but present in ISO C11. For instance, warn about use of anonymous structures and unions, <code class="code">_Atomic</code> type qualifier, <code class="code">_Thread_local</code> storage-class specifier, <code class="code">_Alignas</code> specifier, <code class="code">Alignof</code> operator, <code class="code">_Generic</code> keyword, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows <code class="code">__extension__</code>. </p> </dd> <dt>
 <span><code class="code">-Wc11-c2x-compat <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wc11-c2x-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about features not present in ISO C11, but present in ISO C2X. For instance, warn about omitting the string in <code class="code">_Static_assert</code>, use of ‘<samp class="samp">[[]]</samp>’ syntax for attributes, use of decimal floating-point types, and so on. This option is independent of the standards mode. Warnings are disabled in the expression that follows <code class="code">__extension__</code>. </p> </dd> <dt>
 <span><code class="code">-Wc++-compat <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about ISO C constructs that are outside of the common subset of ISO C and ISO C++, e.g. request for implicit conversion from <code class="code">void *</code> to a pointer to non-<code class="code">void</code> type. </p> </dd> <dt>
 <span><code class="code">-Wc++11-compat <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b11-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about C++ constructs whose meaning differs between ISO C++ 1998 and ISO C++ 2011, e.g., identifiers in ISO C++ 1998 that are keywords in ISO C++ 2011. This warning turns on <samp class="option">-Wnarrowing</samp> and is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wc++14-compat <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b14-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about C++ constructs whose meaning differs between ISO C++ 2011 and ISO C++ 2014. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wc++17-compat <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b17-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about C++ constructs whose meaning differs between ISO C++ 2014 and ISO C++ 2017. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wc++20-compat <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b20-compat"> ¶</a></span>
</dt> <dd>
<p>Warn about C++ constructs whose meaning differs between ISO C++ 2017 and ISO C++ 2020. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-c++11-extensions <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b11-extensions"> ¶</a></span>
</dt> <dd>
<p>Do not warn about C++11 constructs in code being compiled using an older C++ standard. Even without this option, some C++11 constructs will only be diagnosed if <samp class="option">-Wpedantic</samp> is used. </p> </dd> <dt>
 <span><code class="code">-Wno-c++14-extensions <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b14-extensions"> ¶</a></span>
</dt> <dd>
<p>Do not warn about C++14 constructs in code being compiled using an older C++ standard. Even without this option, some C++14 constructs will only be diagnosed if <samp class="option">-Wpedantic</samp> is used. </p> </dd> <dt>
 <span><code class="code">-Wno-c++17-extensions <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b17-extensions"> ¶</a></span>
</dt> <dd>
<p>Do not warn about C++17 constructs in code being compiled using an older C++ standard. Even without this option, some C++17 constructs will only be diagnosed if <samp class="option">-Wpedantic</samp> is used. </p> </dd> <dt>
 <span><code class="code">-Wno-c++20-extensions <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b20-extensions"> ¶</a></span>
</dt> <dd>
<p>Do not warn about C++20 constructs in code being compiled using an older C++ standard. Even without this option, some C++20 constructs will only be diagnosed if <samp class="option">-Wpedantic</samp> is used. </p> </dd> <dt>
 <span><code class="code">-Wno-c++23-extensions <span class="r">(C++ and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wc_002b_002b23-extensions"> ¶</a></span>
</dt> <dd>
<p>Do not warn about C++23 constructs in code being compiled using an older C++ standard. Even without this option, some C++23 constructs will only be diagnosed if <samp class="option">-Wpedantic</samp> is used. </p> </dd> <dt>
 <span><code class="code">-Wcast-qual</code><a class="copiable-link" href="#index-Wcast-qual"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a pointer is cast so as to remove a type qualifier from the target type. For example, warn if a <code class="code">const char *</code> is cast to an ordinary <code class="code">char *</code>. </p> <p>Also warn when making a cast that introduces a type qualifier in an unsafe way. For example, casting <code class="code">char **</code> to <code class="code">const char **</code> is unsafe, as in this example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">/* p is char ** value.  */
const char **q = (const char **) p;
/* Assignment of readonly string to const char * is OK.  */
*q = "string";
/* Now char** pointer points to read-only memory.  */
**p = 'b';</pre>
</div> </dd> <dt>
 <span><code class="code">-Wcast-align</code><a class="copiable-link" href="#index-Wcast-align"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a <code class="code">char *</code> is cast to an <code class="code">int *</code> on machines where integers can only be accessed at two- or four-byte boundaries. </p> </dd> <dt>
<span><code class="code">-Wcast-align=strict</code><a class="copiable-link" href="#index-Wcast-align_003dstrict"> ¶</a></span>
</dt> <dd>
<p>Warn whenever a pointer is cast such that the required alignment of the target is increased. For example, warn if a <code class="code">char *</code> is cast to an <code class="code">int *</code> regardless of the target machine. </p> </dd> <dt>
 <span><code class="code">-Wcast-function-type</code><a class="copiable-link" href="#index-Wcast-function-type"> ¶</a></span>
</dt> <dd>
<p>Warn when a function pointer is cast to an incompatible function pointer. In a cast involving function types with a variable argument list only the types of initial arguments that are provided are considered. Any parameter of pointer-type matches any other pointer-type. Any benign differences in integral types are ignored, like <code class="code">int</code> vs. <code class="code">long</code> on ILP32 targets. Likewise type qualifiers are ignored. The function type <code class="code">void (*) (void)</code> is special and matches everything, which can be used to suppress this warning. In a cast involving pointer to member types this warning warns whenever the type cast is changing the pointer to member type. This warning is enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wwrite-strings</code><a class="copiable-link" href="#index-Wwrite-strings"> ¶</a></span>
</dt> <dd>
<p>When compiling C, give string constants the type <code class="code">const
char[<var class="var">length</var>]</code> so that copying the address of one into a non-<code class="code">const</code> <code class="code">char *</code> pointer produces a warning. These warnings help you find at compile time code that can try to write into a string constant, but only if you have been very careful about using <code class="code">const</code> in declarations and prototypes. Otherwise, it is just a nuisance. This is why we did not make <samp class="option">-Wall</samp> request these warnings. </p> <p>When compiling C++, warn about the deprecated conversion from string literals to <code class="code">char *</code>. This warning is enabled by default for C++ programs. </p> </dd> <dt>
 <span><code class="code">-Wclobbered</code><a class="copiable-link" href="#index-Wclobbered"> ¶</a></span>
</dt> <dd>
<p>Warn for variables that might be changed by <code class="code">longjmp</code> or <code class="code">vfork</code>. This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-complain-wrong-lang</code><a class="copiable-link" href="#index-Wcomplain-wrong-lang"> ¶</a></span>
</dt> <dd>
<p>By default, language front ends complain when a command-line option is valid, but not applicable to that front end. This may be disabled with <samp class="option">-Wno-complain-wrong-lang</samp>, which is mostly useful when invoking a single compiler driver for multiple source files written in different languages, for example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">$ g++ -fno-rtti a.cc b.f90</pre>
</div> <p>The driver <samp class="file">g++</samp> invokes the C++ front end to compile <samp class="file">a.cc</samp> and the Fortran front end to compile <samp class="file">b.f90</samp>. The latter front end diagnoses ‘<samp class="samp">f951: Warning: command-line option '-fno-rtti' is valid for C++/D/ObjC++ but not for Fortran</samp>’, which may be disabled with <samp class="option">-Wno-complain-wrong-lang</samp>. </p> </dd> <dt>
 <span><code class="code">-Wconversion</code><a class="copiable-link" href="#index-Wconversion"> ¶</a></span>
</dt> <dd>
<p>Warn for implicit conversions that may alter a value. This includes conversions between real and integer, like <code class="code">abs (x)</code> when <code class="code">x</code> is <code class="code">double</code>; conversions between signed and unsigned, like <code class="code">unsigned ui = -1</code>; and conversions to smaller types, like <code class="code">sqrtf (M_PI)</code>. Do not warn for explicit casts like <code class="code">abs
((int) x)</code> and <code class="code">ui = (unsigned) -1</code>, or if the value is not changed by the conversion like in <code class="code">abs (2.0)</code>. Warnings about conversions between signed and unsigned integers can be disabled by using <samp class="option">-Wno-sign-conversion</samp>. </p> <p>For C++, also warn for confusing overload resolution for user-defined conversions; and conversions that never use a type conversion operator: conversions to <code class="code">void</code>, the same type, a base class or a reference to them. Warnings about conversions between signed and unsigned integers are disabled by default in C++ unless <samp class="option">-Wsign-conversion</samp> is explicitly enabled. </p> <p>Warnings about conversion from arithmetic on a small type back to that type are only given with <samp class="option">-Warith-conversion</samp>. </p> </dd> <dt>
 <span><code class="code">-Wdangling-else</code><a class="copiable-link" href="#index-Wdangling-else"> ¶</a></span>
</dt> <dd>
<p>Warn about constructions where there may be confusion to which <code class="code">if</code> statement an <code class="code">else</code> branch belongs. Here is an example of such a case: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">{
  if (a)
    if (b)
      foo ();
  else
    bar ();
}</pre></div>
</div> <p>In C/C++, every <code class="code">else</code> branch belongs to the innermost possible <code class="code">if</code> statement, which in this example is <code class="code">if (b)</code>. This is often not what the programmer expected, as illustrated in the above example by indentation the programmer chose. When there is the potential for this confusion, GCC issues a warning when this flag is specified. To eliminate the warning, add explicit braces around the innermost <code class="code">if</code> statement so there is no way the <code class="code">else</code> can belong to the enclosing <code class="code">if</code>. The resulting code looks like this: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">{
  if (a)
    {
      if (b)
        foo ();
      else
        bar ();
    }
}</pre></div>
</div> <p>This warning is enabled by <samp class="option">-Wparentheses</samp>. </p> </dd> <dt>
 <span><code class="code">-Wdangling-pointer</code><a class="copiable-link" href="#index-Wdangling-pointer"> ¶</a></span>
</dt> <dt><code class="code">-Wdangling-pointer=<var class="var">n</var></code></dt> <dd>
<p>Warn about uses of pointers (or C++ references) to objects with automatic storage duration after their lifetime has ended. This includes local variables declared in nested blocks, compound literals and other unnamed temporary objects. In addition, warn about storing the address of such objects in escaped pointers. The warning is enabled at all optimization levels but may yield different results with optimization than without. </p> <dl class="table"> <dt><code class="code">-Wdangling-pointer=1</code></dt> <dd>
<p>At level 1 the warning diagnoses only unconditional uses of dangling pointers. For example </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int f (int c1, int c2, x)
{
  char *p = strchr ((char[]){ c1, c2 }, c3);
  // warning: dangling pointer to a compound literal
  return p ? *p : 'x';
}</pre>
</div> <p>In the following function the store of the address of the local variable <code class="code">x</code> in the escaped pointer <code class="code">*p</code> also triggers the warning. </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void g (int **p)
{
  int x = 7;
  // warning: storing the address of a local variable in *p
  *p = &amp;x;
}</pre>
</div> </dd> <dt><code class="code">-Wdangling-pointer=2</code></dt> <dd>
<p>At level 2, in addition to unconditional uses the warning also diagnoses conditional uses of dangling pointers. </p> <p>For example, because the array <var class="var">a</var> in the following function is out of scope when the pointer <var class="var">s</var> that was set to point is used, the warning triggers at this level. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (char *s)
{
  if (!s)
    {
      char a[12] = "tmpname";
      s = a;
    }
  // warning: dangling pointer to a may be used
  strcat (s, ".tmp");
  ...
}</pre>
</div> </dd> </dl> <p><samp class="option">-Wdangling-pointer=2</samp> is included in <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wdate-time</code><a class="copiable-link" href="#index-Wdate-time"> ¶</a></span>
</dt> <dd>
<p>Warn when macros <code class="code">__TIME__</code>, <code class="code">__DATE__</code> or <code class="code">__TIMESTAMP__</code> are encountered as they might prevent bit-wise-identical reproducible compilations. </p> </dd> <dt>
 <span><code class="code">-Wempty-body</code><a class="copiable-link" href="#index-Wempty-body"> ¶</a></span>
</dt> <dd>
<p>Warn if an empty body occurs in an <code class="code">if</code>, <code class="code">else</code> or <code class="code">do
while</code> statement. This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-endif-labels</code><a class="copiable-link" href="#index-Wendif-labels-1"> ¶</a></span>
</dt> <dd>
<p>Do not warn about stray tokens after <code class="code">#else</code> and <code class="code">#endif</code>. </p> </dd> <dt>
 <span><code class="code">-Wenum-compare</code><a class="copiable-link" href="#index-Wenum-compare"> ¶</a></span>
</dt> <dd>
<p>Warn about a comparison between values of different enumerated types. In C++ enumerated type mismatches in conditional expressions are also diagnosed and the warning is enabled by default. In C this warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wenum-conversion</code><a class="copiable-link" href="#index-Wenum-conversion"> ¶</a></span>
</dt> <dd>
<p>Warn when a value of enumerated type is implicitly converted to a different enumerated type. This warning is enabled by <samp class="option">-Wextra</samp> in C. </p> </dd> <dt>
 <span><code class="code">-Wenum-int-mismatch <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wenum-int-mismatch"> ¶</a></span>
</dt> <dd>
<p>Warn about mismatches between an enumerated type and an integer type in declarations. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">enum E { l = -1, z = 0, g = 1 };
int foo(void);
enum E foo(void);</pre>
</div> <p>In C, an enumerated type is compatible with <code class="code">char</code>, a signed integer type, or an unsigned integer type. However, since the choice of the underlying type of an enumerated type is implementation-defined, such mismatches may cause portability issues. In C++, such mismatches are an error. In C, this warning is enabled by <samp class="option">-Wall</samp> and <samp class="option">-Wc++-compat</samp>. </p> </dd> <dt>
 <span><code class="code">-Wjump-misses-init <span class="r">(C, Objective-C only)</span></code><a class="copiable-link" href="#index-Wjump-misses-init"> ¶</a></span>
</dt> <dd>
<p>Warn if a <code class="code">goto</code> statement or a <code class="code">switch</code> statement jumps forward across the initialization of a variable, or jumps backward to a label after the variable has been initialized. This only warns about variables that are initialized when they are declared. This warning is only supported for C and Objective-C; in C++ this sort of branch is an error in any case. </p> <p><samp class="option">-Wjump-misses-init</samp> is included in <samp class="option">-Wc++-compat</samp>. It can be disabled with the <samp class="option">-Wno-jump-misses-init</samp> option. </p> </dd> <dt>
    <span><code class="code">-Wsign-compare</code><a class="copiable-link" href="#index-Wsign-compare"> ¶</a></span>
</dt> <dd>
<p>Warn when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned. In C++, this warning is also enabled by <samp class="option">-Wall</samp>. In C, it is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wsign-conversion</code><a class="copiable-link" href="#index-Wsign-conversion"> ¶</a></span>
</dt> <dd>
<p>Warn for implicit conversions that may change the sign of an integer value, like assigning a signed integer expression to an unsigned integer variable. An explicit cast silences the warning. In C, this option is enabled also by <samp class="option">-Wconversion</samp>. </p> </dd> <dt>
 <span><code class="code">-Wfloat-conversion</code><a class="copiable-link" href="#index-Wfloat-conversion"> ¶</a></span>
</dt> <dd>
<p>Warn for implicit conversions that reduce the precision of a real value. This includes conversions from real to integer, and from higher precision real to lower precision real values. This option is also enabled by <samp class="option">-Wconversion</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-scalar-storage-order</code><a class="copiable-link" href="#index-Wno-scalar-storage-order"> ¶</a></span>
</dt> <dd>
<p>Do not warn on suspicious constructs involving reverse scalar storage order. </p> </dd> <dt>
 <span><code class="code">-Wsizeof-array-div</code><a class="copiable-link" href="#index-Wsizeof-array-div"> ¶</a></span>
</dt> <dd>
<p>Warn about divisions of two sizeof operators when the first one is applied to an array and the divisor does not equal the size of the array element. In such a case, the computation will not yield the number of elements in the array, which is likely what the user intended. This warning warns e.g. about </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int fn ()
{
  int arr[10];
  return sizeof (arr) / sizeof (short);
}</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wsizeof-pointer-div</code><a class="copiable-link" href="#index-Wsizeof-pointer-div"> ¶</a></span>
</dt> <dd>
<p>Warn for suspicious divisions of two sizeof expressions that divide the pointer size by the element size, which is the usual way to compute the array size but won’t work out correctly with pointers. This warning warns e.g. about <code class="code">sizeof (ptr) / sizeof (ptr[0])</code> if <code class="code">ptr</code> is not an array, but a pointer. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wsizeof-pointer-memaccess</code><a class="copiable-link" href="#index-Wsizeof-pointer-memaccess"> ¶</a></span>
</dt> <dd>
<p>Warn for suspicious length parameters to certain string and memory built-in functions if the argument uses <code class="code">sizeof</code>. This warning triggers for example for <code class="code">memset (ptr, 0, sizeof (ptr));</code> if <code class="code">ptr</code> is not an array, but a pointer, and suggests a possible fix, or about <code class="code">memcpy (&amp;foo, ptr, sizeof (&amp;foo));</code>. <samp class="option">-Wsizeof-pointer-memaccess</samp> also warns about calls to bounded string copy functions like <code class="code">strncat</code> or <code class="code">strncpy</code> that specify as the bound a <code class="code">sizeof</code> expression of the source array. For example, in the following function the call to <code class="code">strncat</code> specifies the size of the source string as the bound. That is almost certainly a mistake and so the call is diagnosed. </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void make_file (const char *name)
{
  char path[PATH_MAX];
  strncpy (path, name, sizeof path - 1);
  strncat (path, ".text", sizeof ".text");
  …
}</pre>
</div> <p>The <samp class="option">-Wsizeof-pointer-memaccess</samp> option is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-sizeof-array-argument</code><a class="copiable-link" href="#index-Wsizeof-array-argument"> ¶</a></span>
</dt> <dd>
<p>Do not warn when the <code class="code">sizeof</code> operator is applied to a parameter that is declared as an array in a function definition. This warning is enabled by default for C and C++ programs. </p> </dd> <dt>
 <span><code class="code">-Wmemset-elt-size</code><a class="copiable-link" href="#index-Wmemset-elt-size"> ¶</a></span>
</dt> <dd>
<p>Warn for suspicious calls to the <code class="code">memset</code> built-in function, if the first argument references an array, and the third argument is a number equal to the number of elements, but not equal to the size of the array in memory. This indicates that the user has omitted a multiplication by the element size. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wmemset-transposed-args</code><a class="copiable-link" href="#index-Wmemset-transposed-args"> ¶</a></span>
</dt> <dd>
<p>Warn for suspicious calls to the <code class="code">memset</code> built-in function where the second argument is not zero and the third argument is zero. For example, the call <code class="code">memset (buf, sizeof buf, 0)</code> is diagnosed because <code class="code">memset (buf, 0, sizeof buf)</code> was meant instead. The diagnostic is only emitted if the third argument is a literal zero. Otherwise, if it is an expression that is folded to zero, or a cast of zero to some type, it is far less likely that the arguments have been mistakenly transposed and no warning is emitted. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Waddress</code><a class="copiable-link" href="#index-Waddress"> ¶</a></span>
</dt> <dd>
<p>Warn about suspicious uses of address expressions. These include comparing the address of a function or a declared object to the null pointer constant such as in </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (void);
void g (void)
{
  if (!f)   // warning: expression evaluates to false
    abort ();
}</pre>
</div> <p>comparisons of a pointer to a string literal, such as in </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (const char *x)
{
  if (x == "abc")   // warning: expression evaluates to false
    puts ("equal");
}</pre>
</div> <p>and tests of the results of pointer addition or subtraction for equality to null, such as in </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (const int *p, int i)
{
  return p + i == NULL;
}</pre>
</div> <p>Such uses typically indicate a programmer error: the address of most functions and objects necessarily evaluates to true (the exception are weak symbols), so their use in a conditional might indicate missing parentheses in a function call or a missing dereference in an array expression. The subset of the warning for object pointers can be suppressed by casting the pointer operand to an integer type such as <code class="code">intptr_t</code> or <code class="code">uintptr_t</code>. Comparisons against string literals result in unspecified behavior and are not portable, and suggest the intent was to call <code class="code">strcmp</code>. The warning is suppressed if the suspicious expression is the result of macro expansion. <samp class="option">-Waddress</samp> warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-address-of-packed-member</code><a class="copiable-link" href="#index-Waddress-of-packed-member"> ¶</a></span>
</dt> <dd>
<p>Do not warn when the address of packed member of struct or union is taken, which usually results in an unaligned pointer value. This is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wlogical-op</code><a class="copiable-link" href="#index-Wlogical-op"> ¶</a></span>
</dt> <dd>
<p>Warn about suspicious uses of logical operators in expressions. This includes using logical operators in contexts where a bit-wise operator is likely to be expected. Also warns when the operands of a logical operator are the same: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">extern int a;
if (a &lt; 0 &amp;&amp; a &lt; 0) { … }</pre>
</div> </dd> <dt>
 <span><code class="code">-Wlogical-not-parentheses</code><a class="copiable-link" href="#index-Wlogical-not-parentheses"> ¶</a></span>
</dt> <dd>
<p>Warn about logical not used on the left hand side operand of a comparison. This option does not warn if the right operand is considered to be a boolean expression. Its purpose is to detect suspicious code like the following: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">int a;
…
if (!a &gt; 1) { … }</pre>
</div> <p>It is possible to suppress the warning by wrapping the LHS into parentheses: </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">if ((!a) &gt; 1) { … }</pre>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Waggregate-return</code><a class="copiable-link" href="#index-Waggregate-return"> ¶</a></span>
</dt> <dd>
<p>Warn if any functions that return structures or unions are defined or called. (In languages where you can return an array, this also elicits a warning.) </p> </dd> <dt>
 <span><code class="code">-Wno-aggressive-loop-optimizations</code><a class="copiable-link" href="#index-Wno-aggressive-loop-optimizations"> ¶</a></span>
</dt> <dd>
<p>Warn if in a loop with constant number of iterations the compiler detects undefined behavior in some statement during one or more of the iterations. </p> </dd> <dt>
 <span><code class="code">-Wno-attributes</code><a class="copiable-link" href="#index-Wno-attributes"> ¶</a></span>
</dt> <dd>
<p>Do not warn if an unexpected <code class="code">__attribute__</code> is used, such as unrecognized attributes, function attributes applied to variables, etc. This does not stop errors for incorrect use of supported attributes. </p> <p>Additionally, using <samp class="option">-Wno-attributes=</samp>, it is possible to suppress warnings about unknown scoped attributes (in C++11 and C2X). For example, <samp class="option">-Wno-attributes=vendor::attr</samp> disables warning about the following declaration: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">[[vendor::attr]] void f();</pre>
</div> <p>It is also possible to disable warning about all attributes in a namespace using <samp class="option">-Wno-attributes=vendor::</samp> which prevents warning about both of these declarations: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">[[vendor::safe]] void f();
[[vendor::unsafe]] void f2();</pre>
</div> <p>Note that <samp class="option">-Wno-attributes=</samp> does not imply <samp class="option">-Wno-attributes</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-builtin-declaration-mismatch</code><a class="copiable-link" href="#index-Wno-builtin-declaration-mismatch"> ¶</a></span>
</dt> <dd>
<p>Warn if a built-in function is declared with an incompatible signature or as a non-function, or when a built-in function declared with a type that does not include a prototype is called with arguments whose promoted types do not match those expected by the function. When <samp class="option">-Wextra</samp> is specified, also warn when a built-in function that takes arguments is declared without a prototype. The <samp class="option">-Wbuiltin-declaration-mismatch</samp> warning is enabled by default. To avoid the warning include the appropriate header to bring the prototypes of built-in functions into scope. </p> <p>For example, the call to <code class="code">memset</code> below is diagnosed by the warning because the function expects a value of type <code class="code">size_t</code> as its argument but the type of <code class="code">32</code> is <code class="code">int</code>. With <samp class="option">-Wextra</samp>, the declaration of the function is diagnosed as well. </p>
<div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">extern void* memset ();
void f (void *d)
{
  memset (d, '\0', 32);
}</pre>
</div> </dd> <dt>
 <span><code class="code">-Wno-builtin-macro-redefined</code><a class="copiable-link" href="#index-Wno-builtin-macro-redefined"> ¶</a></span>
</dt> <dd>
<p>Do not warn if certain built-in macros are redefined. This suppresses warnings for redefinition of <code class="code">__TIMESTAMP__</code>, <code class="code">__TIME__</code>, <code class="code">__DATE__</code>, <code class="code">__FILE__</code>, and <code class="code">__BASE_FILE__</code>. </p> </dd> <dt>
 <span><code class="code">-Wstrict-prototypes <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wstrict-prototypes"> ¶</a></span>
</dt> <dd>
<p>Warn if a function is declared or defined without specifying the argument types. (An old-style function definition is permitted without a warning if preceded by a declaration that specifies the argument types.) </p> </dd> <dt>
 <span><code class="code">-Wold-style-declaration <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wold-style-declaration"> ¶</a></span>
</dt> <dd>
<p>Warn for obsolescent usages, according to the C Standard, in a declaration. For example, warn if storage-class specifiers like <code class="code">static</code> are not the first things in a declaration. This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wold-style-definition <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wold-style-definition"> ¶</a></span>
</dt> <dd>
<p>Warn if an old-style function definition is used. A warning is given even if there is a previous prototype. A definition using ‘<samp class="samp">()</samp>’ is not considered an old-style definition in C2X mode, because it is equivalent to ‘<samp class="samp">(void)</samp>’ in that case, but is considered an old-style definition for older standards. </p> </dd> <dt>
 <span><code class="code">-Wmissing-parameter-type <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wmissing-parameter-type"> ¶</a></span>
</dt> <dd>
<p>A function parameter is declared without a type specifier in K&amp;R-style functions: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void foo(bar) { }</pre>
</div> <p>This warning is also enabled by <samp class="option">-Wextra</samp>. </p> </dd> <dt>
 <span><code class="code">-Wmissing-prototypes <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wmissing-prototypes"> ¶</a></span>
</dt> <dd>
<p>Warn if a global function is defined without a previous prototype declaration. This warning is issued even if the definition itself provides a prototype. Use this option to detect global functions that do not have a matching prototype declaration in a header file. This option is not valid for C++ because all function declarations provide prototypes and a non-matching declaration declares an overload rather than conflict with an earlier declaration. Use <samp class="option">-Wmissing-declarations</samp> to detect missing declarations in C++. </p> </dd> <dt>
 <span><code class="code">-Wmissing-declarations</code><a class="copiable-link" href="#index-Wmissing-declarations"> ¶</a></span>
</dt> <dd>
<p>Warn if a global function is defined without a previous declaration. Do so even if the definition itself provides a prototype. Use this option to detect global functions that are not declared in header files. In C, no warnings are issued for functions with previous non-prototype declarations; use <samp class="option">-Wmissing-prototypes</samp> to detect missing prototypes. In C++, no warnings are issued for function templates, or for inline functions, or for functions in anonymous namespaces. </p> </dd> <dt>
    <span><code class="code">-Wmissing-field-initializers</code><a class="copiable-link" href="#index-Wmissing-field-initializers"> ¶</a></span>
</dt> <dd>
<p>Warn if a structure’s initializer has some fields missing. For example, the following code causes such a warning, because <code class="code">x.h</code> is implicitly zero: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct s { int f, g, h; };
struct s x = { 3, 4 };</pre>
</div> <p>This option does not warn about designated initializers, so the following modification does not trigger a warning: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct s { int f, g, h; };
struct s x = { .f = 3, .g = 4 };</pre>
</div> <p>In C this option does not warn about the universal zero initializer ‘<samp class="samp">{ 0 }</samp>’: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct s { int f, g, h; };
struct s x = { 0 };</pre>
</div> <p>Likewise, in C++ this option does not warn about the empty { } initializer, for example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct s { int f, g, h; };
s x = { };</pre>
</div> <p>This warning is included in <samp class="option">-Wextra</samp>. To get other <samp class="option">-Wextra</samp> warnings without this one, use <samp class="option">-Wextra -Wno-missing-field-initializers</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-missing-requires</code><a class="copiable-link" href="#index-Wmissing-requires"> ¶</a></span>
</dt> <dd> <p>By default, the compiler warns about a concept-id appearing as a C++20 simple-requirement: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">bool satisfied = requires { C&lt;T&gt; };</pre>
</div> <p>Here ‘<samp class="samp">satisfied</samp>’ will be true if ‘<samp class="samp">C&lt;T&gt;</samp>’ is a valid expression, which it is for all T. Presumably the user meant to write </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">bool satisfied = requires { requires C&lt;T&gt; };</pre>
</div> <p>so ‘<samp class="samp">satisfied</samp>’ is only true if concept ‘<samp class="samp">C</samp>’ is satisfied for type ‘<samp class="samp">T</samp>’. </p> <p>This warning can be disabled with <samp class="option">-Wno-missing-requires</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-missing-template-keyword</code><a class="copiable-link" href="#index-Wmissing-template-keyword"> ¶</a></span>
</dt> <dd> <p>The member access tokens ., -&gt; and :: must be followed by the <code class="code">template</code> keyword if the parent object is dependent and the member being named is a template. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">template &lt;class X&gt;
void DoStuff (X x)
{
  x.template DoSomeOtherStuff&lt;X&gt;(); // Good.
  x.DoMoreStuff&lt;X&gt;(); // Warning, x is dependent.
}</pre>
</div> <p>In rare cases it is possible to get false positives. To silence this, wrap the expression in parentheses. For example, the following is treated as a template, even where m and N are integers: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void NotATemplate (my_class t)
{
  int N = 5;

  bool test = t.m &lt; N &gt; (0); // Treated as a template.
  test = (t.m &lt; N) &gt; (0); // Same meaning, but not treated as a template.
}</pre>
</div> <p>This warning can be disabled with <samp class="option">-Wno-missing-template-keyword</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-multichar</code><a class="copiable-link" href="#index-Wno-multichar"> ¶</a></span>
</dt> <dd>
<p>Do not warn if a multicharacter constant (‘<samp class="samp">'FOOF'</samp>’) is used. Usually they indicate a typo in the user’s code, as they have implementation-defined values, and should not be used in portable code. </p> </dd> <dt>
     <span><code class="code">-Wnormalized=<span class="r">[</span>none<span class="r">|</span>id<span class="r">|</span>nfc<span class="r">|</span>nfkc<span class="r">]</span></code><a class="copiable-link" href="#index-Wnormalized_003d"> ¶</a></span>
</dt> <dd>
<p>In ISO C and ISO C++, two identifiers are different if they are different sequences of characters. However, sometimes when characters outside the basic ASCII character set are used, you can have two different character sequences that look the same. To avoid confusion, the ISO 10646 standard sets out some <em class="dfn">normalization rules</em> which when applied ensure that two sequences that look the same are turned into the same sequence. GCC can warn you if you are using identifiers that have not been normalized; this option controls that warning. </p> <p>There are four levels of warning supported by GCC. The default is <samp class="option">-Wnormalized=nfc</samp>, which warns about any identifier that is not in the ISO 10646 “C” normalized form, <em class="dfn">NFC</em>. NFC is the recommended form for most uses. It is equivalent to <samp class="option">-Wnormalized</samp>. </p> <p>Unfortunately, there are some characters allowed in identifiers by ISO C and ISO C++ that, when turned into NFC, are not allowed in identifiers. That is, there’s no way to use these symbols in portable ISO C or C++ and have all your identifiers in NFC. <samp class="option">-Wnormalized=id</samp> suppresses the warning for these characters. It is hoped that future versions of the standards involved will correct this, which is why this option is not the default. </p> <p>You can switch the warning off for all characters by writing <samp class="option">-Wnormalized=none</samp> or <samp class="option">-Wno-normalized</samp>. You should only do this if you are using some other normalization scheme (like “D”), because otherwise you can easily create bugs that are literally impossible to see. </p> <p>Some characters in ISO 10646 have distinct meanings but look identical in some fonts or display methodologies, especially once formatting has been applied. For instance <code class="code">\u207F</code>, “SUPERSCRIPT LATIN SMALL LETTER N”, displays just like a regular <code class="code">n</code> that has been placed in a superscript. ISO 10646 defines the <em class="dfn">NFKC</em> normalization scheme to convert all these into a standard form as well, and GCC warns if your code is not in NFKC if you use <samp class="option">-Wnormalized=nfkc</samp>. This warning is comparable to warning about every identifier that contains the letter O because it might be confused with the digit 0, and so is not the default, but may be useful as a local coding convention if the programming environment cannot be fixed to display these characters distinctly. </p> </dd> <dt>
 <span><code class="code">-Wno-attribute-warning</code><a class="copiable-link" href="#index-Wno-attribute-warning"> ¶</a></span>
</dt> <dd>
<p>Do not warn about usage of functions (see <a class="pxref" href="function-attributes.html">Declaring Attributes of Functions</a>) declared with <code class="code">warning</code> attribute. By default, this warning is enabled. <samp class="option">-Wno-attribute-warning</samp> can be used to disable the warning or <samp class="option">-Wno-error=attribute-warning</samp> can be used to disable the error when compiled with <samp class="option">-Werror</samp> flag. </p> </dd> <dt>
 <span><code class="code">-Wno-deprecated</code><a class="copiable-link" href="#index-Wno-deprecated"> ¶</a></span>
</dt> <dd>
<p>Do not warn about usage of deprecated features. See <a class="xref" href="deprecated-features.html">Deprecated Features</a>. </p> </dd> <dt>
 <span><code class="code">-Wno-deprecated-declarations</code><a class="copiable-link" href="#index-Wno-deprecated-declarations"> ¶</a></span>
</dt> <dd>
<p>Do not warn about uses of functions (see <a class="pxref" href="function-attributes.html">Declaring Attributes of Functions</a>), variables (see <a class="pxref" href="variable-attributes.html">Specifying Attributes of Variables</a>), and types (see <a class="pxref" href="type-attributes.html">Specifying Attributes of Types</a>) marked as deprecated by using the <code class="code">deprecated</code> attribute. </p> </dd> <dt>
 <span><code class="code">-Wno-overflow</code><a class="copiable-link" href="#index-Wno-overflow"> ¶</a></span>
</dt> <dd>
<p>Do not warn about compile-time overflow in constant expressions. </p> </dd> <dt>
 <span><code class="code">-Wno-odr</code><a class="copiable-link" href="#index-Wno-odr"> ¶</a></span>
</dt> <dd>
<p>Warn about One Definition Rule violations during link-time optimization. Enabled by default. </p> </dd> <dt>
  <span><code class="code">-Wopenacc-parallelism</code><a class="copiable-link" href="#index-Wopenacc-parallelism"> ¶</a></span>
</dt> <dd>
<p>Warn about potentially suboptimal choices related to OpenACC parallelism. </p> </dd> <dt>
 <span><code class="code">-Wopenmp-simd</code><a class="copiable-link" href="#index-Wopenmp-simd"> ¶</a></span>
</dt> <dd>
<p>Warn if the vectorizer cost model overrides the OpenMP simd directive set by user. The <samp class="option">-fsimd-cost-model=unlimited</samp> option can be used to relax the cost model. </p> </dd> <dt>
    <span><code class="code">-Woverride-init <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Woverride-init"> ¶</a></span>
</dt> <dd>
<p>Warn if an initialized field without side effects is overridden when using designated initializers (see <a class="pxref" href="designated-inits.html">Designated Initializers</a>). </p> <p>This warning is included in <samp class="option">-Wextra</samp>. To get other <samp class="option">-Wextra</samp> warnings without this one, use <samp class="option">-Wextra -Wno-override-init</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-override-init-side-effects <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Woverride-init-side-effects"> ¶</a></span>
</dt> <dd>
<p>Do not warn if an initialized field with side effects is overridden when using designated initializers (see <a class="pxref" href="designated-inits.html">Designated Initializers</a>). This warning is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wpacked</code><a class="copiable-link" href="#index-Wpacked"> ¶</a></span>
</dt> <dd>
<p>Warn if a structure is given the packed attribute, but the packed attribute has no effect on the layout or size of the structure. Such structures may be mis-aligned for little benefit. For instance, in this code, the variable <code class="code">f.x</code> in <code class="code">struct bar</code> is misaligned even though <code class="code">struct bar</code> does not itself have the packed attribute: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">struct foo {
  int x;
  char a, b, c, d;
} __attribute__((packed));
struct bar {
  char z;
  struct foo f;
};</pre></div>
</div> </dd> <dt>
 <span><code class="code">-Wnopacked-bitfield-compat</code><a class="copiable-link" href="#index-Wpacked-bitfield-compat"> ¶</a></span>
</dt> <dd>
<p>The 4.1, 4.2 and 4.3 series of GCC ignore the <code class="code">packed</code> attribute on bit-fields of type <code class="code">char</code>. This was fixed in GCC 4.4 but the change can lead to differences in the structure layout. GCC informs you when the offset of such a field has changed in GCC 4.4. For example there is no longer a 4-bit padding between field <code class="code">a</code> and <code class="code">b</code> in this structure: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct foo
{
  char a:4;
  char b:8;
} __attribute__ ((packed));</pre>
</div> <p>This warning is enabled by default. Use <samp class="option">-Wno-packed-bitfield-compat</samp> to disable this warning. </p> </dd> <dt>
 <span><code class="code">-Wpacked-not-aligned <span class="r">(C, C++, Objective-C and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wpacked-not-aligned"> ¶</a></span>
</dt> <dd>
<p>Warn if a structure field with explicitly specified alignment in a packed struct or union is misaligned. For example, a warning will be issued on <code class="code">struct S</code>, like, <code class="code">warning: alignment 1 of
'struct S' is less than 8</code>, in this code: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">struct __attribute__ ((aligned (8))) S8 { char a[8]; };
struct __attribute__ ((packed)) S {
  struct S8 s8;
};</pre></div>
</div> <p>This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wpadded</code><a class="copiable-link" href="#index-Wpadded"> ¶</a></span>
</dt> <dd>
<p>Warn if padding is included in a structure, either to align an element of the structure or to align the whole structure. Sometimes when this happens it is possible to rearrange the fields of the structure to reduce the padding and so make the structure smaller. </p> </dd> <dt>
 <span><code class="code">-Wredundant-decls</code><a class="copiable-link" href="#index-Wredundant-decls"> ¶</a></span>
</dt> <dd>
<p>Warn if anything is declared more than once in the same scope, even in cases where multiple declaration is valid and changes nothing. </p> </dd> <dt>
 <span><code class="code">-Wrestrict</code><a class="copiable-link" href="#index-Wrestrict"> ¶</a></span>
</dt> <dd>
<p>Warn when an object referenced by a <code class="code">restrict</code>-qualified parameter (or, in C++, a <code class="code">__restrict</code>-qualified parameter) is aliased by another argument, or when copies between such objects overlap. For example, the call to the <code class="code">strcpy</code> function below attempts to truncate the string by replacing its initial characters with the last four. However, because the call writes the terminating NUL into <code class="code">a[4]</code>, the copies overlap and the call is diagnosed. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void foo (void)
{
  char a[] = "abcd1234";
  strcpy (a, a + 4);
  …
}</pre>
</div> <p>The <samp class="option">-Wrestrict</samp> option detects some instances of simple overlap even without optimization but works best at <samp class="option">-O2</samp> and above. It is included in <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wnested-externs <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wnested-externs"> ¶</a></span>
</dt> <dd>
<p>Warn if an <code class="code">extern</code> declaration is encountered within a function. </p> </dd> <dt>
 <span><code class="code">-Winline</code><a class="copiable-link" href="#index-Winline"> ¶</a></span>
</dt> <dd>
<p>Warn if a function that is declared as inline cannot be inlined. Even with this option, the compiler does not warn about failures to inline functions declared in system headers. </p> <p>The compiler uses a variety of heuristics to determine whether or not to inline a function. For example, the compiler takes into account the size of the function being inlined and the amount of inlining that has already been done in the current function. Therefore, seemingly insignificant changes in the source program can cause the warnings produced by <samp class="option">-Winline</samp> to appear or disappear. </p> </dd> <dt>
<span><code class="code">-Winterference-size</code><a class="copiable-link" href="#index-Winterference-size"> ¶</a></span>
</dt> <dd>
<p>Warn about use of C++17 <code class="code">std::hardware_destructive_interference_size</code> without specifying its value with <samp class="option">--param destructive-interference-size</samp>. Also warn about questionable values for that option. </p> <p>This variable is intended to be used for controlling class layout, to avoid false sharing in concurrent code: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">struct independent_fields {
  alignas(std::hardware_destructive_interference_size)
    std::atomic&lt;int&gt; one;
  alignas(std::hardware_destructive_interference_size)
    std::atomic&lt;int&gt; two;
};</pre>
</div> <p>Here ‘<samp class="samp">one</samp>’ and ‘<samp class="samp">two</samp>’ are intended to be far enough apart that stores to one won’t require accesses to the other to reload the cache line. </p> <p>By default, <samp class="option">--param destructive-interference-size</samp> and <samp class="option">--param constructive-interference-size</samp> are set based on the current <samp class="option">-mtune</samp> option, typically to the L1 cache line size for the particular target CPU, sometimes to a range if tuning for a generic target. So all translation units that depend on ABI compatibility for the use of these variables must be compiled with the same <samp class="option">-mtune</samp> (or <samp class="option">-mcpu</samp>). </p> <p>If ABI stability is important, such as if the use is in a header for a library, you should probably not use the hardware interference size variables at all. Alternatively, you can force a particular value with <samp class="option">--param</samp>. </p> <p>If you are confident that your use of the variable does not affect ABI outside a single build of your project, you can turn off the warning with <samp class="option">-Wno-interference-size</samp>. </p> </dd> <dt>
 <span><code class="code">-Wint-in-bool-context</code><a class="copiable-link" href="#index-Wint-in-bool-context"> ¶</a></span>
</dt> <dd>
<p>Warn for suspicious use of integer values where boolean values are expected, such as conditional expressions (?:) using non-boolean integer constants in boolean context, like <code class="code">if (a &lt;= b ? 2 : 3)</code>. Or left shifting of signed integers in boolean context, like <code class="code">for (a = 0; 1 &lt;&lt; a; a++);</code>. Likewise for all kinds of multiplications regardless of the data type. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-int-to-pointer-cast</code><a class="copiable-link" href="#index-Wno-int-to-pointer-cast"> ¶</a></span>
</dt> <dd>
<p>Suppress warnings from casts to pointer type of an integer of a different size. In C++, casting to a pointer type of smaller size is an error. <samp class="option">Wint-to-pointer-cast</samp> is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wno-pointer-to-int-cast <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wno-pointer-to-int-cast"> ¶</a></span>
</dt> <dd>
<p>Suppress warnings from casts from a pointer to an integer type of a different size. </p> </dd> <dt>
 <span><code class="code">-Winvalid-pch</code><a class="copiable-link" href="#index-Winvalid-pch"> ¶</a></span>
</dt> <dd>
<p>Warn if a precompiled header (see <a class="pxref" href="precompiled-headers.html">Using Precompiled Headers</a>) is found in the search path but cannot be used. </p> </dd> <dt>
 <span><code class="code">-Winvalid-utf8</code><a class="copiable-link" href="#index-Winvalid-utf8"> ¶</a></span>
</dt> <dd>
<p>Warn if an invalid UTF-8 character is found. This warning is on by default for C++23 if <samp class="option">-finput-charset=UTF-8</samp> is used and turned into error with <samp class="option">-pedantic-errors</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-unicode</code><a class="copiable-link" href="#index-Wunicode"> ¶</a></span>
</dt> <dd>
<p>Don’t diagnose invalid forms of delimited or named escape sequences which are treated as separate tokens. <samp class="option">Wunicode</samp> is enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wlong-long</code><a class="copiable-link" href="#index-Wlong-long"> ¶</a></span>
</dt> <dd>
<p>Warn if <code class="code">long long</code> type is used. This is enabled by either <samp class="option">-Wpedantic</samp> or <samp class="option">-Wtraditional</samp> in ISO C90 and C++98 modes. To inhibit the warning messages, use <samp class="option">-Wno-long-long</samp>. </p> </dd> <dt>
 <span><code class="code">-Wvariadic-macros</code><a class="copiable-link" href="#index-Wvariadic-macros"> ¶</a></span>
</dt> <dd>
<p>Warn if variadic macros are used in ISO C90 mode, or if the GNU alternate syntax is used in ISO C99 mode. This is enabled by either <samp class="option">-Wpedantic</samp> or <samp class="option">-Wtraditional</samp>. To inhibit the warning messages, use <samp class="option">-Wno-variadic-macros</samp>. </p> </dd> <dt>
 <span><code class="code">-Wno-varargs</code><a class="copiable-link" href="#index-Wvarargs"> ¶</a></span>
</dt> <dd>
<p>Do not warn upon questionable usage of the macros used to handle variable arguments like <code class="code">va_start</code>. These warnings are enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wvector-operation-performance</code><a class="copiable-link" href="#index-Wvector-operation-performance"> ¶</a></span>
</dt> <dd>
<p>Warn if vector operation is not implemented via SIMD capabilities of the architecture. Mainly useful for the performance tuning. Vector operation can be implemented <code class="code">piecewise</code>, which means that the scalar operation is performed on every vector element; <code class="code">in parallel</code>, which means that the vector operation is implemented using scalars of wider type, which normally is more performance efficient; and <code class="code">as a single scalar</code>, which means that vector fits into a scalar type. </p> </dd> <dt>
 <span><code class="code">-Wvla</code><a class="copiable-link" href="#index-Wvla"> ¶</a></span>
</dt> <dd>
<p>Warn if a variable-length array is used in the code. <samp class="option">-Wno-vla</samp> prevents the <samp class="option">-Wpedantic</samp> warning of the variable-length array. </p> </dd> <dt>
 <span><code class="code">-Wvla-larger-than=<var class="var">byte-size</var></code><a class="copiable-link" href="#index-Wvla-larger-than_003d"> ¶</a></span>
</dt> <dd>
<p>If this option is used, the compiler warns for declarations of variable-length arrays whose size is either unbounded, or bounded by an argument that allows the array size to exceed <var class="var">byte-size</var> bytes. This is similar to how <samp class="option">-Walloca-larger-than=</samp><var class="var">byte-size</var> works, but with variable-length arrays. </p> <p>Note that GCC may optimize small variable-length arrays of a known value into plain arrays, so this warning may not get triggered for such arrays. </p> <p><samp class="option">-Wvla-larger-than=</samp>‘<samp class="samp">PTRDIFF_MAX</samp>’ is enabled by default but is typically only effective when <samp class="option">-ftree-vrp</samp> is active (default for <samp class="option">-O2</samp> and above). </p> <p>See also <samp class="option">-Walloca-larger-than=<var class="var">byte-size</var></samp>. </p> </dd> <dt>
<span><code class="code">-Wno-vla-larger-than</code><a class="copiable-link" href="#index-Wno-vla-larger-than-1"> ¶</a></span>
</dt> <dd>
<p>Disable <samp class="option">-Wvla-larger-than=</samp> warnings. The option is equivalent to <samp class="option">-Wvla-larger-than=</samp>‘<samp class="samp">SIZE_MAX</samp>’ or larger. </p> </dd> <dt>
<span><code class="code">-Wvla-parameter</code><a class="copiable-link" href="#index-Wno-vla-parameter"> ¶</a></span>
</dt> <dd>
<p>Warn about redeclarations of functions involving arguments of Variable Length Array types of inconsistent kinds or forms, and enable the detection of out-of-bounds accesses to such parameters by warnings such as <samp class="option">-Warray-bounds</samp>. </p> <p>If the first function declaration uses the VLA form the bound specified in the array is assumed to be the minimum number of elements expected to be provided in calls to the function and the maximum number of elements accessed by it. Failing to provide arguments of sufficient size or accessing more than the maximum number of elements may be diagnosed. </p> <p>For example, the warning triggers for the following redeclarations because the first one allows an array of any size to be passed to <code class="code">f</code> while the second one specifies that the array argument must have at least <code class="code">n</code> elements. In addition, calling <code class="code">f</code> with the associated VLA bound parameter in excess of the actual VLA bound triggers a warning as well. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">void f (int n, int[n]);
// warning: argument 2 previously declared as a VLA
void f (int, int[]);

void g (int n)
{
    if (n &gt; 4)
      return;
    int a[n];
    // warning: access to a by f may be out of bounds
    f (sizeof a, a);
  …
}</pre>
</div> <p><samp class="option">-Wvla-parameter</samp> is included in <samp class="option">-Wall</samp>. The <samp class="option">-Warray-parameter</samp> option triggers warnings for similar problems involving ordinary array arguments. </p> </dd> <dt>
 <span><code class="code">-Wvolatile-register-var</code><a class="copiable-link" href="#index-Wvolatile-register-var"> ¶</a></span>
</dt> <dd>
<p>Warn if a register variable is declared volatile. The volatile modifier does not inhibit all optimizations that may eliminate reads and/or writes to register variables. This warning is enabled by <samp class="option">-Wall</samp>. </p> </dd> <dt>
 <span><code class="code">-Wxor-used-as-pow <span class="r">(C, C++, Objective-C and Objective-C++ only)</span></code><a class="copiable-link" href="#index-Wxor-used-as-pow"> ¶</a></span>
</dt> <dd>
<p>Warn about uses of <code class="code">^</code>, the exclusive or operator, where it appears the user meant exponentiation. Specifically, the warning occurs when the left-hand side is the decimal constant 2 or 10 and the right-hand side is also a decimal constant. </p> <p>In C and C++, <code class="code">^</code> means exclusive or, whereas in some other languages (e.g. TeX and some versions of BASIC) it means exponentiation. </p> <p>This warning is enabled by default. It can be silenced by converting one of the operands to hexadecimal. </p> </dd> <dt>
 <span><code class="code">-Wdisabled-optimization</code><a class="copiable-link" href="#index-Wdisabled-optimization"> ¶</a></span>
</dt> <dd>
<p>Warn if a requested optimization pass is disabled. This warning does not generally indicate that there is anything wrong with your code; it merely indicates that GCC’s optimizers are unable to handle the code effectively. Often, the problem is that your code is too big or too complex; GCC refuses to optimize programs when the optimization itself is likely to take inordinate amounts of time. </p> </dd> <dt>
 <span><code class="code">-Wpointer-sign <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wpointer-sign"> ¶</a></span>
</dt> <dd>
<p>Warn for pointer argument passing or assignment with different signedness. This option is only supported for C and Objective-C. It is implied by <samp class="option">-Wall</samp> and by <samp class="option">-Wpedantic</samp>, which can be disabled with <samp class="option">-Wno-pointer-sign</samp>. </p> </dd> <dt>
 <span><code class="code">-Wstack-protector</code><a class="copiable-link" href="#index-Wstack-protector"> ¶</a></span>
</dt> <dd>
<p>This option is only active when <samp class="option">-fstack-protector</samp> is active. It warns about functions that are not protected against stack smashing. </p> </dd> <dt>
 <span><code class="code">-Woverlength-strings</code><a class="copiable-link" href="#index-Woverlength-strings"> ¶</a></span>
</dt> <dd>
<p>Warn about string constants that are longer than the “minimum maximum” length specified in the C standard. Modern compilers generally allow string constants that are much longer than the standard’s minimum limit, but very portable programs should avoid using longer strings. </p> <p>The limit applies <em class="emph">after</em> string constant concatenation, and does not count the trailing NUL. In C90, the limit was 509 characters; in C99, it was raised to 4095. C++98 does not specify a normative minimum maximum, so we do not diagnose overlength strings in C++. </p> <p>This option is implied by <samp class="option">-Wpedantic</samp>, and can be disabled with <samp class="option">-Wno-overlength-strings</samp>. </p> </dd> <dt>
 <span><code class="code">-Wunsuffixed-float-constants <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wunsuffixed-float-constants"> ¶</a></span>
</dt> <dd> <p>Issue a warning for any floating constant that does not have a suffix. When used together with <samp class="option">-Wsystem-headers</samp> it warns about such constants in system header files. This can be useful when preparing code to use with the <code class="code">FLOAT_CONST_DECIMAL64</code> pragma from the decimal floating-point extension to C99. </p> </dd> <dt>
 <span><code class="code">-Wno-lto-type-mismatch</code><a class="copiable-link" href="#index-Wlto-type-mismatch"> ¶</a></span>
</dt> <dd> <p>During the link-time optimization, do not warn about type mismatches in global declarations from different compilation units. Requires <samp class="option">-flto</samp> to be enabled. Enabled by default. </p> </dd> <dt>
 <span><code class="code">-Wno-designated-init <span class="r">(C and Objective-C only)</span></code><a class="copiable-link" href="#index-Wdesignated-init"> ¶</a></span>
</dt> <dd>
<p>Suppress warnings when a positional initializer is used to initialize a structure that has been marked with the <code class="code">designated_init</code> attribute. </p> </dd> </dl> </div>  <div class="nav-panel"> <p> Next: <a href="static-analyzer-options.html">Options That Control Static Analysis</a>, Previous: <a href="diagnostic-message-formatting-options.html">Options to Control Diagnostic Messages Formatting</a>, Up: <a href="invoking-gcc.html">GCC Command Options</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Warning-Options.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Warning-Options.html</a>
  </p>
</div>
