<h1 class="section" id="C_002b_002b-Modules-1">3.23 C++ Modules</h1> <div class="section-level-extent" id="C_002b_002b-Modules">     <p>Modules are a C++20 language feature. As the name suggests, they provides a modular compilation system, intending to provide both faster builds and better library isolation. The “Merging Modules” paper <a class="uref" href="https://wg21.link/p1103">https://wg21.link/p1103</a>, provides the easiest to read set of changes to the standard, although it does not capture later changes. </p> <p><em class="emph">G++’s modules support is not complete.</em> Other than bugs, the known missing pieces are: </p> <dl class="table"> <dt>Private Module Fragment</dt> <dd>
<p>The Private Module Fragment is recognized, but an error is emitted. </p> </dd> <dt>Partition definition visibility rules</dt> <dd>
<p>Entities may be defined in implementation partitions, and those definitions are not available outside of the module. This is not implemented, and the definitions are available to extra-module use. </p> </dd> <dt>Textual merging of reachable GM entities</dt> <dd>
<p>Entities may be multiply defined across different header-units. These must be de-duplicated, and this is implemented across imports, or when an import redefines a textually-defined entity. However the reverse is not implemented—textually redefining an entity that has been defined in an imported header-unit. A redefinition error is emitted. </p> </dd> <dt>Translation-Unit local referencing rules</dt> <dd>
<p>Papers p1815 (<a class="uref" href="https://wg21.link/p1815">https://wg21.link/p1815</a>) and p2003 (<a class="uref" href="https://wg21.link/p2003">https://wg21.link/p2003</a>) add limitations on which entities an exported region may reference (for instance, the entities an exported template definition may reference). These are not fully implemented. </p> </dd> <dt>Standard Library Header Units</dt> <dd>
<p>The Standard Library is not provided as importable header units. If you want to import such units, you must explicitly build them first. If you do not do this with care, you may have multiple declarations, which the module machinery must merge—compiler resource usage can be affected by how you partition header files into header units. </p> </dd> </dl> <p>Modular compilation is <em class="emph">not</em> enabled with just the <samp class="option">-std=c++20</samp> option. You must explicitly enable it with the <samp class="option">-fmodules-ts</samp> option. It is independent of the language version selected, although in pre-C++20 versions, it is of course an extension. </p> <p>No new source file suffixes are required or supported. If you wish to use a non-standard suffix (see <a class="pxref" href="overall-options.html">Options Controlling the Kind of Output</a>), you also need to provide a <samp class="option">-x c++</samp> option too.<a class="footnote" id="DOCF2" href="#FOOT2"><sup>2</sup></a> </p> <p>Compiling a module interface unit produces an additional output (to the assembly or object file), called a Compiled Module Interface (CMI). This encodes the exported declarations of the module. Importing a module reads in the CMI. The import graph is a Directed Acyclic Graph (DAG). You must build imports before the importer. </p> <p>Header files may themselves be compiled to header units, which are a transitional ability aiming at faster compilation. The <samp class="option">-fmodule-header</samp> option is used to enable this, and implies the <samp class="option">-fmodules-ts</samp> option. These CMIs are named by the fully resolved underlying header file, and thus may be a complete pathname containing subdirectories. If the header file is found at an absolute pathname, the CMI location is still relative to a CMI root directory. </p> <p>As header files often have no suffix, you commonly have to specify a <samp class="option">-x</samp> option to tell the compiler the source is a header file. You may use <samp class="option">-x c++-header</samp>, <samp class="option">-x c++-user-header</samp> or <samp class="option">-x c++-system-header</samp>. When used in conjunction with <samp class="option">-fmodules-ts</samp>, these all imply an appropriate <samp class="option">-fmodule-header</samp> option. The latter two variants use the user or system include path to search for the file specified. This allows you to, for instance, compile standard library header files as header units, without needing to know exactly where they are installed. Specifying the language as one of these variants also inhibits output of the object file, as header files have no associated object file. </p> <p>The <samp class="option">-fmodule-only</samp> option disables generation of the associated object file for compiling a module interface. Only the CMI is generated. This option is implied when using the <samp class="option">-fmodule-header</samp> option. </p> <p>The <samp class="option">-flang-info-include-translate</samp> and <samp class="option">-flang-info-include-translate-not</samp> options notes whether include translation occurs or not. With no argument, the first will note all include translation. The second will note all non-translations of include files not known to intentionally be textual. With an argument, queries about include translation of a header files with that particular trailing pathname are noted. You may repeat this form to cover several different header files. This option may be helpful in determining whether include translation is happening—if it is working correctly, it behaves as if it isn’t there at all. </p> <p>The <samp class="option">-flang-info-module-cmi</samp> option can be used to determine where the compiler is reading a CMI from. Without the option, the compiler is silent when such a read is successful. This option has an optional argument, which will restrict the notification to just the set of named modules or header units specified. </p> <p>The <samp class="option">-Winvalid-imported-macros</samp> option causes all imported macros to be resolved at the end of compilation. Without this, imported macros are only resolved when expanded or (re)defined. This option detects conflicting import definitions for all macros. </p> <p>For details of the <samp class="option">-fmodule-mapper</samp> family of options, see <a class="pxref" href="c_002b_002b-module-mapper.html">Module Mapper</a>. </p> <ul class="mini-toc"> <li><a href="c_002b_002b-module-mapper.html" accesskey="1">Module Mapper</a></li> <li><a href="c_002b_002b-module-preprocessing.html" accesskey="2">Module Preprocessing</a></li> <li><a href="c_002b_002b-compiled-module-interface.html" accesskey="3">Compiled Module Interface</a></li> </ul> </div> <div class="footnotes-segment">  <h2 class="footnotes-heading">Footnotes</h2> <h3 class="footnote-body-heading"><a id="FOOT2" href="#DOCF2">(2)</a></h3> <p>Some users like to distinguish module interface files with a new suffix, such as naming the source <code class="code">module.cppm</code>, which involves teaching all tools about the new suffix. A different scheme, such as naming <code class="code">module-m.cpp</code> would be less invasive.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/C_002b_002b-Modules.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/C_002b_002b-Modules.html</a>
  </p>
</div>
