<h1 class="section" id="Additional-Floating-Types">6.12 Additional Floating Types</h1> <div class="section-level-extent" id="Floating-Types">              <p>ISO/IEC TS 18661-3:2015 defines C support for additional floating types <code class="code">_Float<var class="var">n</var></code> and <code class="code">_Float<var class="var">n</var>x</code>, and GCC supports these type names; the set of types supported depends on the target architecture. Constants with these types use suffixes <code class="code">f<var class="var">n</var></code> or <code class="code">F<var class="var">n</var></code> and <code class="code">f<var class="var">n</var>x</code> or <code class="code">F<var class="var">n</var>x</code>. These type names can be used together with <code class="code">_Complex</code> to declare complex types. </p> <p>As an extension, GNU C and GNU C++ support additional floating types, which are not supported by all targets. </p>
<ul class="itemize mark-bullet"> <li>
<code class="code">__float128</code> is available on i386, x86_64, IA-64, LoongArch and hppa HP-UX, as well as on PowerPC GNU/Linux targets that enable the vector scalar (VSX) instruction set. <code class="code">__float128</code> supports the 128-bit floating type. On i386, x86_64, PowerPC, LoongArch and IA-64, other than HP-UX, <code class="code">__float128</code> is an alias for <code class="code">_Float128</code>. On hppa and IA-64 HP-UX, <code class="code">__float128</code> is an alias for <code class="code">long
double</code>. </li>
<li>
<code class="code">__float80</code> is available on the i386, x86_64, and IA-64 targets, and supports the 80-bit (<code class="code">XFmode</code>) floating type. It is an alias for the type name <code class="code">_Float64x</code> on these targets. </li>
<li>
<code class="code">__ibm128</code> is available on PowerPC targets, and provides access to the IBM extended double format which is the current format used for <code class="code">long double</code>. When <code class="code">long double</code> transitions to <code class="code">__float128</code> on PowerPC in the future, <code class="code">__ibm128</code> will remain for use in conversions between the two types. </li>
</ul> <p>Support for these additional types includes the arithmetic operators: add, subtract, multiply, divide; unary arithmetic operators; relational operators; equality operators; and conversions to and from integer and other floating types. Use a suffix ‘<samp class="samp">w</samp>’ or ‘<samp class="samp">W</samp>’ in a literal constant of type <code class="code">__float80</code> or type <code class="code">__ibm128</code>. Use a suffix ‘<samp class="samp">q</samp>’ or ‘<samp class="samp">Q</samp>’ for <code class="code">__float128</code>. </p> <p>In order to use <code class="code">_Float128</code>, <code class="code">__float128</code>, and <code class="code">__ibm128</code> on PowerPC Linux systems, you must use the <samp class="option">-mfloat128</samp> option. It is expected in future versions of GCC that <code class="code">_Float128</code> and <code class="code">__float128</code> will be enabled automatically. </p> <p>The <code class="code">_Float128</code> type is supported on all systems where <code class="code">__float128</code> is supported or where <code class="code">long double</code> has the IEEE binary128 format. The <code class="code">_Float64x</code> type is supported on all systems where <code class="code">__float128</code> is supported. The <code class="code">_Float32</code> type is supported on all systems supporting IEEE binary32; the <code class="code">_Float64</code> and <code class="code">_Float32x</code> types are supported on all systems supporting IEEE binary64. The <code class="code">_Float16</code> type is supported on AArch64 systems by default, on ARM systems when the IEEE format for 16-bit floating-point types is selected with <samp class="option">-mfp16-format=ieee</samp> and, for both C and C++, on x86 systems with SSE2 enabled. GCC does not currently support <code class="code">_Float128x</code> on any systems. </p> <p>On the i386, x86_64, IA-64, and HP-UX targets, you can declare complex types using the corresponding internal complex type, <code class="code">XCmode</code> for <code class="code">__float80</code> type and <code class="code">TCmode</code> for <code class="code">__float128</code> type: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">typedef _Complex float __attribute__((mode(TC))) _Complex128;
typedef _Complex float __attribute__((mode(XC))) _Complex80;</pre>
</div> <p>On the PowerPC Linux VSX targets, you can declare complex types using the corresponding internal complex type, <code class="code">KCmode</code> for <code class="code">__float128</code> type and <code class="code">ICmode</code> for <code class="code">__ibm128</code> type: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">typedef _Complex float __attribute__((mode(KC))) _Complex_float128;
typedef _Complex float __attribute__((mode(IC))) _Complex_ibm128;</pre>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Floating-Types.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Floating-Types.html</a>
  </p>
</div>
