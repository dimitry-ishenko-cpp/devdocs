<div class="subsection-level-extent" id="Dynamically-registering-methods"> <div class="nav-panel"> <p> Next: <a href="forwarding-hook.html" accesskey="n" rel="next">Forwarding Hook</a>, Up: <a href="messaging-with-the-gnu-objective-c-runtime.html" accesskey="u" rel="up">Messaging with the GNU Objective-C Runtime</a> [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="indices.html" title="Index" rel="index">Index</a>]</p> </div>  <h1 class="subsection" id="Dynamically-Registering-Methods"><span>8.10.1 Dynamically Registering Methods<a class="copiable-link" href="#Dynamically-Registering-Methods"> Â¶</a></span></h1> <p>If <code class="code">objc_msg_lookup()</code> does not find a suitable method implementation, because the receiver does not implement the required method, it tries to see if the class can dynamically register the method. </p> <p>To do so, the runtime checks if the class of the receiver implements the method </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">+ (BOOL) resolveInstanceMethod: (SEL)selector;</pre>
</div> <p>in the case of an instance method, or </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">+ (BOOL) resolveClassMethod: (SEL)selector;</pre>
</div> <p>in the case of a class method. If the class implements it, the runtime invokes it, passing as argument the selector of the original method, and if it returns <code class="code">YES</code>, the runtime tries the lookup again, which could now succeed if a matching method was added dynamically by <code class="code">+resolveInstanceMethod:</code> or <code class="code">+resolveClassMethod:</code>. </p> <p>This allows classes to dynamically register methods (by adding them to the class using <code class="code">class_addMethod</code>) when they are first called. To do so, a class should implement <code class="code">+resolveInstanceMethod:</code> (or, depending on the case, <code class="code">+resolveClassMethod:</code>) and have it recognize the selectors of methods that can be registered dynamically at runtime, register them, and return <code class="code">YES</code>. It should return <code class="code">NO</code> for methods that it does not dynamically registered at runtime. </p> <p>If <code class="code">+resolveInstanceMethod:</code> (or <code class="code">+resolveClassMethod:</code>) is not implemented or returns <code class="code">NO</code>, the runtime then tries the forwarding hook. </p> <p>Support for <code class="code">+resolveInstanceMethod:</code> and <code class="code">resolveClassMethod:</code> was added to the GNU Objective-C runtime in GCC version 4.6. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Dynamically-registering-methods.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-13.1.0/gcc/Dynamically-registering-methods.html</a>
  </p>
</div>
