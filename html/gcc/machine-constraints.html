<h1 class="subsubsection subsection-level-set-subsubsection" id="Constraints-for-Particular-Machines">6.48.3.4 Constraints for Particular Machines</h1> <div class="subsubsection-level-extent" id="Machine-Constraints">      <p>Whenever possible, you should use the general-purpose constraint letters in <code class="code">asm</code> arguments, since they will convey meaning more readily to people reading your code. Failing that, use the constraint letters that usually have very similar meanings across architectures. The most commonly used constraints are ‘<samp class="samp">m</samp>’ and ‘<samp class="samp">r</samp>’ (for memory and general-purpose registers respectively; see <a class="pxref" href="simple-constraints.html">Simple Constraints</a>), and ‘<samp class="samp">I</samp>’, usually the letter indicating the most common immediate-constant format. </p> <p>Each architecture defines additional constraints. These constraints are used by the compiler itself for instruction generation, as well as for <code class="code">asm</code> statements; therefore, some of the constraints are not particularly useful for <code class="code">asm</code>. Here is a summary of some of the machine-dependent constraints available on some particular machines; it includes both constraints that are useful for <code class="code">asm</code> and constraints that aren’t. The compiler source file mentioned in the table heading for each architecture is the definitive reference for the meanings of that architecture’s constraints. </p> <dl class="table"> <dt>AArch64 family—<samp class="file">config/aarch64/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">k</code></dt> <dd>
<p>The stack pointer register (<code class="code">SP</code>) </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>Floating point register, Advanced SIMD vector register or SVE vector register </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Like <code class="code">w</code>, but restricted to registers 0 to 15 inclusive. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Like <code class="code">w</code>, but restricted to registers 0 to 7 inclusive. </p> </dd> <dt><code class="code">Upl</code></dt> <dd>
<p>One of the low eight SVE predicate registers (<code class="code">P0</code> to <code class="code">P7</code>) </p> </dd> <dt><code class="code">Upa</code></dt> <dd>
<p>Any of the SVE predicate registers (<code class="code">P0</code> to <code class="code">P15</code>) </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Integer constant that is valid as an immediate operand in an <code class="code">ADD</code> instruction </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer constant that is valid as an immediate operand in a <code class="code">SUB</code> instruction (once negated) </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer constant that can be used with a 32-bit logical instruction </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer constant that can be used with a 64-bit logical instruction </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer constant that is valid as an immediate operand in a 32-bit <code class="code">MOV</code> pseudo instruction. The <code class="code">MOV</code> may be assembled to one of several different machine instructions depending on the value </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Integer constant that is valid as an immediate operand in a 64-bit <code class="code">MOV</code> pseudo instruction </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>An absolute symbolic address or a label reference </p> </dd> <dt><code class="code">Y</code></dt> <dd>
<p>Floating point constant zero </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>Integer constant zero </p> </dd> <dt><code class="code">Ush</code></dt> <dd>
<p>The high part (bits 12 and upwards) of the pc-relative address of a symbol within 4GB of the instruction </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory address which uses a single base register with no offset </p> </dd> <dt><code class="code">Ump</code></dt> <dd>
<p>A memory address suitable for a load/store pair instruction in SI, DI, SF and DF modes </p> </dd> </dl> </dd> <dt>AMD GCN —<samp class="file">config/gcn/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">I</code></dt> <dd>
<p>Immediate integer in the range −16 to 64 </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Immediate 16-bit signed integer </p> </dd> <dt><code class="code">Kf</code></dt> <dd>
<p>Immediate constant −1 </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Immediate 15-bit unsigned integer </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>Immediate constant that can be inlined in an instruction encoding: integer −16..64, or float 0.0, +/−0.5, +/−1.0, +/−2.0, +/−4.0, 1.0/(2.0*PI) </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>Immediate 32-bit signed integer that can be attached to an instruction encoding </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>Immediate 32-bit integer in range −16..4294967295 (i.e. 32-bit unsigned integer or ‘<samp class="samp">A</samp>’ constraint) </p> </dd> <dt><code class="code">DA</code></dt> <dd>
<p>Immediate 64-bit constant that can be split into two ‘<samp class="samp">A</samp>’ constants </p> </dd> <dt><code class="code">DB</code></dt> <dd>
<p>Immediate 64-bit constant that can be split into two ‘<samp class="samp">B</samp>’ constants </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Any <code class="code">unspec</code> </p> </dd> <dt><code class="code">Y</code></dt> <dd>
<p>Any <code class="code">symbol_ref</code> or <code class="code">label_ref</code> </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>VGPR register </p> </dd> <dt><code class="code">a</code></dt> <dd>
<p>Accelerator VGPR register (CDNA1 onwards) </p> </dd> <dt><code class="code">Sg</code></dt> <dd>
<p>SGPR register </p> </dd> <dt><code class="code">SD</code></dt> <dd>
<p>SGPR registers valid for instruction destinations, including VCC, M0 and EXEC </p> </dd> <dt><code class="code">SS</code></dt> <dd>
<p>SGPR registers valid for instruction sources, including VCC, M0, EXEC and SCC </p> </dd> <dt><code class="code">Sm</code></dt> <dd>
<p>SGPR registers valid as a source for scalar memory instructions (excludes M0 and EXEC) </p> </dd> <dt><code class="code">Sv</code></dt> <dd>
<p>SGPR registers valid as a source or destination for vector instructions (excludes EXEC) </p> </dd> <dt><code class="code">ca</code></dt> <dd>
<p>All condition registers: SCC, VCCZ, EXECZ </p> </dd> <dt><code class="code">cs</code></dt> <dd>
<p>Scalar condition register: SCC </p> </dd> <dt><code class="code">cV</code></dt> <dd>
<p>Vector condition register: VCC, VCC_LO, VCC_HI </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>EXEC register (EXEC_LO and EXEC_HI) </p> </dd> <dt><code class="code">RB</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">buffer_*</code> instructions </p> </dd> <dt><code class="code">RF</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">flat_*</code> instructions </p> </dd> <dt><code class="code">RS</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">s_*</code> instructions </p> </dd> <dt><code class="code">RL</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">ds_*</code> LDS instructions </p> </dd> <dt><code class="code">RG</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">ds_*</code> GDS instructions </p> </dd> <dt><code class="code">RD</code></dt> <dd>
<p>Memory operand with address space suitable for any <code class="code">ds_*</code> instructions </p> </dd> <dt><code class="code">RM</code></dt> <dd>
<p>Memory operand with address space suitable for <code class="code">global_*</code> instructions </p> </dd> </dl> </dd> <dt>ARC —<samp class="file">config/arc/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">q</code></dt> <dd>
<p>Registers usable in ARCompact 16-bit instructions: <code class="code">r0</code>-<code class="code">r3</code>, <code class="code">r12</code>-<code class="code">r15</code>. This constraint can only match when the <samp class="option">-mq</samp> option is in effect. </p> </dd> <dt><code class="code">e</code></dt> <dd><p>Registers usable as base-regs of memory addresses in ARCompact 16-bit memory instructions: <code class="code">r0</code>-<code class="code">r3</code>, <code class="code">r12</code>-<code class="code">r15</code>, <code class="code">sp</code>. This constraint can only match when the <samp class="option">-mq</samp> option is in effect. </p></dd> <dt><code class="code">D</code></dt> <dd>
<p>ARC FPX (dpfp) 64-bit registers. <code class="code">D0</code>, <code class="code">D1</code>. </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A signed 12-bit integer constant. </p> </dd> <dt><code class="code">Cal</code></dt> <dd>
<p>constant for arithmetic/logical operations. This might be any constant that can be put into a long immediate by the assmbler or linker without involving a PIC relocation. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>A 3-bit unsigned integer constant. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A 6-bit unsigned integer constant. </p> </dd> <dt><code class="code">CnL</code></dt> <dd>
<p>One’s complement of a 6-bit unsigned integer constant. </p> </dd> <dt><code class="code">CmL</code></dt> <dd>
<p>Two’s complement of a 6-bit unsigned integer constant. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>A 5-bit unsigned integer constant. </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>A 7-bit unsigned integer constant. </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>A 8-bit unsigned integer constant. </p> </dd> <dt><code class="code">H</code></dt> <dd><p>Any const_double value. </p></dd> </dl> </dd> <dt>ARM family—<samp class="file">config/arm/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">h</code></dt> <dd>
<p>In Thumb state, the core registers <code class="code">r8</code>-<code class="code">r15</code>. </p> </dd> <dt><code class="code">k</code></dt> <dd>
<p>The stack pointer register. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>In Thumb State the core registers <code class="code">r0</code>-<code class="code">r7</code>. In ARM state this is an alias for the <code class="code">r</code> constraint. </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>VFP floating-point registers <code class="code">s0</code>-<code class="code">s31</code>. Used for 32 bit values. </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>VFP floating-point registers <code class="code">d0</code>-<code class="code">d31</code> and the appropriate subset <code class="code">d0</code>-<code class="code">d15</code> based on command line options. Used for 64 bit values only. Not valid for Thumb1. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>The iWMMX co-processor registers. </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>The iWMMX GR registers. </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>The floating-point constant 0.0 </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Integer that is valid as an immediate operand in a data processing instruction. That is, an integer in the range 0 to 255 rotated by a multiple of 2 </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer in the range −4095 to 4095 </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer that satisfies constraint ‘<samp class="samp">I</samp>’ when inverted (ones complement) </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer that satisfies constraint ‘<samp class="samp">I</samp>’ when negated (twos complement) </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer in the range 0 to 32 </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory reference where the exact address is in a single register (‘‘<samp class="samp">m</samp>’’ is preferable for <code class="code">asm</code> statements) </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>An item in the constant pool </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>A symbol in the text segment of the current file </p> </dd> <dt><code class="code">Uv</code></dt> <dd>
<p>A memory reference suitable for VFP load/store insns (reg+constant offset) </p> </dd> <dt><code class="code">Uy</code></dt> <dd>
<p>A memory reference suitable for iWMMXt load/store instructions. </p> </dd> <dt><code class="code">Uq</code></dt> <dd><p>A memory reference suitable for the ARMv4 ldrsb instruction. </p></dd> </dl> </dd> <dt>AVR family—<samp class="file">config/avr/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">l</code></dt> <dd>
<p>Registers from r0 to r15 </p> </dd> <dt><code class="code">a</code></dt> <dd>
<p>Registers from r16 to r23 </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Registers from r16 to r31 </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>Registers from r24 to r31. These registers can be used in ‘<samp class="samp">adiw</samp>’ command </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Pointer register (r26–r31) </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Base pointer register (r28–r31) </p> </dd> <dt><code class="code">q</code></dt> <dd>
<p>Stack pointer register (SPH:SPL) </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>Temporary register r0 </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Register pair X (r27:r26) </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Register pair Y (r29:r28) </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>Register pair Z (r31:r30) </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Constant greater than −1, less than 64 </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Constant greater than −64, less than 1 </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Constant integer 2 </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Constant integer 0 </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Constant that fits in 8 bits </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Constant integer −1 </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Constant integer 8, 16, or 24 </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>Constant integer 1 </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>A floating point constant 0.0 </p> </dd> <dt><code class="code">Q</code></dt> <dd><p>A memory address based on Y or Z pointer with displacement. </p></dd> </dl> </dd> <dt>Blackfin family—<samp class="file">config/bfin/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>P register </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>D register </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>A call clobbered P register. </p> </dd> <dt><code class="code">q<var class="var">n</var></code></dt> <dd>
<p>A single register. If <var class="var">n</var> is in the range 0 to 7, the corresponding D register. If it is <code class="code">A</code>, then the register P0. </p> </dd> <dt><code class="code">D</code></dt> <dd>
<p>Even-numbered D register </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>Odd-numbered D register </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Accumulator register. </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>Even-numbered accumulator register. </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>Odd-numbered accumulator register. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>I register </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>B register </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>M register </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Registers used for circular buffering, i.e. I, B, or L registers. </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>The CC register. </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>LT0 or LT1. </p> </dd> <dt><code class="code">k</code></dt> <dd>
<p>LC0 or LC1. </p> </dd> <dt><code class="code">u</code></dt> <dd>
<p>LB0 or LB1. </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Any D, P, B, M, I or L register. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Additional registers typically used only in prologues and epilogues: RETS, RETN, RETI, RETX, RETE, ASTAT, SEQSTAT and USP. </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>Any register except accumulators or CC. </p> </dd> <dt><code class="code">Ksh</code></dt> <dd>
<p>Signed 16 bit integer (in the range −32768 to 32767) </p> </dd> <dt><code class="code">Kuh</code></dt> <dd>
<p>Unsigned 16 bit integer (in the range 0 to 65535) </p> </dd> <dt><code class="code">Ks7</code></dt> <dd>
<p>Signed 7 bit integer (in the range −64 to 63) </p> </dd> <dt><code class="code">Ku7</code></dt> <dd>
<p>Unsigned 7 bit integer (in the range 0 to 127) </p> </dd> <dt><code class="code">Ku5</code></dt> <dd>
<p>Unsigned 5 bit integer (in the range 0 to 31) </p> </dd> <dt><code class="code">Ks4</code></dt> <dd>
<p>Signed 4 bit integer (in the range −8 to 7) </p> </dd> <dt><code class="code">Ks3</code></dt> <dd>
<p>Signed 3 bit integer (in the range −3 to 4) </p> </dd> <dt><code class="code">Ku3</code></dt> <dd>
<p>Unsigned 3 bit integer (in the range 0 to 7) </p> </dd> <dt><code class="code">P<var class="var">n</var></code></dt> <dd>
<p>Constant <var class="var">n</var>, where <var class="var">n</var> is a single-digit constant in the range 0 to 4. </p> </dd> <dt><code class="code">PA</code></dt> <dd>
<p>An integer equal to one of the MACFLAG_XXX constants that is suitable for use with either accumulator. </p> </dd> <dt><code class="code">PB</code></dt> <dd>
<p>An integer equal to one of the MACFLAG_XXX constants that is suitable for use only with accumulator A1. </p> </dd> <dt><code class="code">M1</code></dt> <dd>
<p>Constant 255. </p> </dd> <dt><code class="code">M2</code></dt> <dd>
<p>Constant 65535. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>An integer constant with exactly a single bit set. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>An integer constant with all bits set except exactly one. </p> </dd> <dt><code class="code">H</code></dt> <dt><code class="code">Q</code></dt> <dd><p>Any SYMBOL_REF. </p></dd> </dl> </dd> <dt>C-SKY—<samp class="file">config/csky/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>The mini registers r0 - r7. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>The low registers r0 - r15. </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>C register. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>HI and LO registers. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>LO register. </p> </dd> <dt><code class="code">h</code></dt> <dd>
<p>HI register. </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>Vector registers. </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>Stack pointer register (SP). </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory address which uses a base register with a short offset or with a index register with its scale. </p> </dd> <dt><code class="code">W</code></dt> <dd><p>A memory address which uses a base register with a index register with its scale. </p></dd> </dl> </dd> <dt>Epiphany—<samp class="file">config/epiphany/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">U16</code></dt> <dd>
<p>An unsigned 16-bit constant. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>An unsigned 5-bit constant. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A signed 11-bit constant. </p> </dd> <dt><code class="code">Cm1</code></dt> <dd>
<p>A signed 11-bit constant added to −1. Can only match when the <samp class="option">-m1reg-<var class="var">reg</var></samp> option is active. </p> </dd> <dt><code class="code">Cl1</code></dt> <dd>
<p>Left-shift of −1, i.e., a bit mask with a block of leading ones, the rest being a block of trailing zeroes. Can only match when the <samp class="option">-m1reg-<var class="var">reg</var></samp> option is active. </p> </dd> <dt><code class="code">Cr1</code></dt> <dd>
<p>Right-shift of −1, i.e., a bit mask with a trailing block of ones, the rest being zeroes. Or to put it another way, one less than a power of two. Can only match when the <samp class="option">-m1reg-<var class="var">reg</var></samp> option is active. </p> </dd> <dt><code class="code">Cal</code></dt> <dd>
<p>Constant for arithmetic/logical operations. This is like <code class="code">i</code>, except that for position independent code, no symbols / expressions needing relocations are allowed. </p> </dd> <dt><code class="code">Csy</code></dt> <dd>
<p>Symbolic constant for call/jump instruction. </p> </dd> <dt><code class="code">Rcs</code></dt> <dd>
<p>The register class usable in short insns. This is a register class constraint, and can thus drive register allocation. This constraint won’t match unless <samp class="option">-mprefer-short-insn-regs</samp> is in effect. </p> </dd> <dt><code class="code">Rsc</code></dt> <dd>
<p>The register class of registers that can be used to hold a sibcall call address. I.e., a caller-saved register. </p> </dd> <dt><code class="code">Rct</code></dt> <dd>
<p>Core control register class. </p> </dd> <dt><code class="code">Rgs</code></dt> <dd>
<p>The register group usable in short insns. This constraint does not use a register class, so that it only passively matches suitable registers, and doesn’t drive register allocation. </p> </dd> <dt><code class="code">Rra</code></dt> <dd>
<p>Matches the return address if it can be replaced with the link register. </p> </dd> <dt><code class="code">Rcc</code></dt> <dd>
<p>Matches the integer condition code register. </p> </dd> <dt><code class="code">Sra</code></dt> <dd>
<p>Matches the return address if it is in a stack slot. </p> </dd> <dt><code class="code">Cfm</code></dt> <dd><p>Matches control register values to switch fp mode, which are encapsulated in <code class="code">UNSPEC_FP_MODE</code>. </p></dd> </dl> </dd> <dt>FRV—<samp class="file">config/frv/frv.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Register in the class <code class="code">ACC_REGS</code> (<code class="code">acc0</code> to <code class="code">acc7</code>). </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Register in the class <code class="code">EVEN_ACC_REGS</code> (<code class="code">acc0</code> to <code class="code">acc7</code>). </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Register in the class <code class="code">CC_REGS</code> (<code class="code">fcc0</code> to <code class="code">fcc3</code> and <code class="code">icc0</code> to <code class="code">icc3</code>). </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Register in the class <code class="code">GPR_REGS</code> (<code class="code">gr0</code> to <code class="code">gr63</code>). </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Register in the class <code class="code">EVEN_REGS</code> (<code class="code">gr0</code> to <code class="code">gr63</code>). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Register in the class <code class="code">FPR_REGS</code> (<code class="code">fr0</code> to <code class="code">fr63</code>). </p> </dd> <dt><code class="code">h</code></dt> <dd>
<p>Register in the class <code class="code">FEVEN_REGS</code> (<code class="code">fr0</code> to <code class="code">fr63</code>). Odd registers are excluded not in the class but through the use of a machine mode larger than 4 bytes. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>Register in the class <code class="code">LR_REG</code> (the <code class="code">lr</code> register). </p> </dd> <dt><code class="code">q</code></dt> <dd>
<p>Register in the class <code class="code">QUAD_REGS</code> (<code class="code">gr2</code> to <code class="code">gr63</code>). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes. </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>Register in the class <code class="code">ICC_REGS</code> (<code class="code">icc0</code> to <code class="code">icc3</code>). </p> </dd> <dt><code class="code">u</code></dt> <dd>
<p>Register in the class <code class="code">FCC_REGS</code> (<code class="code">fcc0</code> to <code class="code">fcc3</code>). </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>Register in the class <code class="code">ICR_REGS</code> (<code class="code">cc4</code> to <code class="code">cc7</code>). </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>Register in the class <code class="code">FCR_REGS</code> (<code class="code">cc0</code> to <code class="code">cc3</code>). </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Register in the class <code class="code">QUAD_FPR_REGS</code> (<code class="code">fr0</code> to <code class="code">fr63</code>). Register numbers not divisible by 4 are excluded not in the class but through the use of a machine mode larger than 8 bytes. </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>Register in the class <code class="code">SPR_REGS</code> (<code class="code">lcr</code> and <code class="code">lr</code>). </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>Register in the class <code class="code">QUAD_ACC_REGS</code> (<code class="code">acc0</code> to <code class="code">acc7</code>). </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>Register in the class <code class="code">ACCG_REGS</code> (<code class="code">accg0</code> to <code class="code">accg7</code>). </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>Register in the class <code class="code">CR_REGS</code> (<code class="code">cc0</code> to <code class="code">cc7</code>). </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating point constant zero </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>6-bit signed integer constant </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>10-bit signed integer constant </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>16-bit signed integer constant </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>16-bit unsigned integer constant </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>12-bit signed integer constant that is negative—i.e. in the range of −2048 to −1 </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Constant zero </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>12-bit signed integer constant that is greater than zero—i.e. in the range of 1 to 2047. </p> </dd> </dl> </dd> <dt>FT32—<samp class="file">config/ft32/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">A</code></dt> <dd>
<p>An absolute address </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>An offset address </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>A register indirect memory operand </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>An offset address. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>An offset address. </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>The constant zero or one </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A 16-bit signed constant (−32768 … 32767) </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>A bitfield mask suitable for bext or bins </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>An inverted bitfield mask suitable for bext or bins </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A 16-bit unsigned constant, multiple of 4 (0 … 65532) </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>A 20-bit signed constant (−524288 … 524287) </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>A constant for a bitfield width (1 … 16) </p> </dd> <dt><code class="code">KA</code></dt> <dd>
<p>A 10-bit signed constant (−512 … 511) </p> </dd> </dl> </dd> <dt>Hewlett-Packard PA-RISC—<samp class="file">config/pa/pa.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>General register 1 </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Floating point register </p> </dd> <dt><code class="code">q</code></dt> <dd>
<p>Shift amount register </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Floating point register (deprecated) </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Upper floating point register (32-bit), floating point register (64-bit) </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>Any register </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Signed 11-bit integer constant </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Signed 14-bit integer constant </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer constant that can be deposited with a <code class="code">zdepi</code> instruction </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Signed 5-bit integer constant </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer constant 0 </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Integer constant that can be loaded with a <code class="code">ldil</code> instruction </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Integer constant whose value plus one is a power of 2 </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>Integer constant that can be used for <code class="code">and</code> operations in <code class="code">depi</code> and <code class="code">extru</code> instructions </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>Integer constant 31 </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Integer constant 63 </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating-point constant 0.0 </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>A <code class="code">lo_sum</code> data-linkage-table memory operand </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory operand that can be used as the destination operand of an integer store instruction </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>A scaled or unscaled indexed memory operand </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>A memory operand for floating-point loads and stores </p> </dd> <dt><code class="code">W</code></dt> <dd><p>A register indirect memory operand </p></dd> </dl> </dd> <dt>Intel IA-64—<samp class="file">config/ia64/ia64.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>General register <code class="code">r0</code> to <code class="code">r3</code> for <code class="code">addl</code> instruction </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Branch register </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Predicate register (‘<samp class="samp">c</samp>’ as in “conditional”) </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Application register residing in M-unit </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Application register residing in I-unit </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Floating-point register </p> </dd> <dt><code class="code">m</code></dt> <dd>
<p>Memory operand. If used together with ‘<samp class="samp">&lt;</samp>’ or ‘<samp class="samp">&gt;</samp>’, the operand can have postincrement and postdecrement which require printing with ‘<samp class="samp">%Pn</samp>’ on IA-64. </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating-point constant 0.0 or 1.0 </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>14-bit signed integer constant </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>22-bit signed integer constant </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>8-bit signed integer constant for logical instructions </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>8-bit adjusted signed integer constant for compare pseudo-ops </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>6-bit unsigned integer constant for shift counts </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>9-bit signed integer constant for load and store postincrements </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>The constant zero </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>0 or −1 for <code class="code">dep</code> instruction </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Non-volatile memory for floating-point loads and stores </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>Integer constant in the range 1 to 4 for <code class="code">shladd</code> instruction </p> </dd> <dt><code class="code">S</code></dt> <dd><p>Memory operand except postincrement and postdecrement. This is now roughly the same as ‘<samp class="samp">m</samp>’ when not used together with ‘<samp class="samp">&lt;</samp>’ or ‘<samp class="samp">&gt;</samp>’. </p></dd> </dl> </dd> <dt>M32C—<samp class="file">config/m32c/m32c.cc</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">Rsp</code></dt> <dt><code class="code">Rfb</code></dt> <dt><code class="code">Rsb</code></dt> <dd>
<p>‘<samp class="samp">$sp</samp>’, ‘<samp class="samp">$fb</samp>’, ‘<samp class="samp">$sb</samp>’. </p> </dd> <dt><code class="code">Rcr</code></dt> <dd>
<p>Any control register, when they’re 16 bits wide (nothing if control registers are 24 bits wide) </p> </dd> <dt><code class="code">Rcl</code></dt> <dd>
<p>Any control register, when they’re 24 bits wide. </p> </dd> <dt><code class="code">R0w</code></dt> <dt><code class="code">R1w</code></dt> <dt><code class="code">R2w</code></dt> <dt><code class="code">R3w</code></dt> <dd>
<p>$r0, $r1, $r2, $r3. </p> </dd> <dt><code class="code">R02</code></dt> <dd>
<p>$r0 or $r2, or $r2r0 for 32 bit values. </p> </dd> <dt><code class="code">R13</code></dt> <dd>
<p>$r1 or $r3, or $r3r1 for 32 bit values. </p> </dd> <dt><code class="code">Rdi</code></dt> <dd>
<p>A register that can hold a 64 bit value. </p> </dd> <dt><code class="code">Rhl</code></dt> <dd>
<p>$r0 or $r1 (registers with addressable high/low bytes) </p> </dd> <dt><code class="code">R23</code></dt> <dd>
<p>$r2 or $r3 </p> </dd> <dt><code class="code">Raa</code></dt> <dd>
<p>Address registers </p> </dd> <dt><code class="code">Raw</code></dt> <dd>
<p>Address registers when they’re 16 bits wide. </p> </dd> <dt><code class="code">Ral</code></dt> <dd>
<p>Address registers when they’re 24 bits wide. </p> </dd> <dt><code class="code">Rqi</code></dt> <dd>
<p>Registers that can hold QI values. </p> </dd> <dt><code class="code">Rad</code></dt> <dd>
<p>Registers that can be used with displacements ($a0, $a1, $sb). </p> </dd> <dt><code class="code">Rsi</code></dt> <dd>
<p>Registers that can hold 32 bit values. </p> </dd> <dt><code class="code">Rhi</code></dt> <dd>
<p>Registers that can hold 16 bit values. </p> </dd> <dt><code class="code">Rhc</code></dt> <dd>
<p>Registers chat can hold 16 bit values, including all control registers. </p> </dd> <dt><code class="code">Rra</code></dt> <dd>
<p>$r0 through R1, plus $a0 and $a1. </p> </dd> <dt><code class="code">Rfl</code></dt> <dd>
<p>The flags register. </p> </dd> <dt><code class="code">Rmm</code></dt> <dd>
<p>The memory-based pseudo-registers $mem0 through $mem15. </p> </dd> <dt><code class="code">Rpi</code></dt> <dd>
<p>Registers that can hold pointers (16 bit registers for r8c, m16c; 24 bit registers for m32cm, m32c). </p> </dd> <dt><code class="code">Rpa</code></dt> <dd>
<p>Matches multiple registers in a PARALLEL to form a larger register. Used to match function return values. </p> </dd> <dt><code class="code">Is3</code></dt> <dd>
<p>−8 … 7 </p> </dd> <dt><code class="code">IS1</code></dt> <dd>
<p>−128 … 127 </p> </dd> <dt><code class="code">IS2</code></dt> <dd>
<p>−32768 … 32767 </p> </dd> <dt><code class="code">IU2</code></dt> <dd>
<p>0 … 65535 </p> </dd> <dt><code class="code">In4</code></dt> <dd>
<p>−8 … −1 or 1 … 8 </p> </dd> <dt><code class="code">In5</code></dt> <dd>
<p>−16 … −1 or 1 … 16 </p> </dd> <dt><code class="code">In6</code></dt> <dd>
<p>−32 … −1 or 1 … 32 </p> </dd> <dt><code class="code">IM2</code></dt> <dd>
<p>−65536 … −1 </p> </dd> <dt><code class="code">Ilb</code></dt> <dd>
<p>An 8 bit value with exactly one bit set. </p> </dd> <dt><code class="code">Ilw</code></dt> <dd>
<p>A 16 bit value with exactly one bit set. </p> </dd> <dt><code class="code">Sd</code></dt> <dd>
<p>The common src/dest memory addressing modes. </p> </dd> <dt><code class="code">Sa</code></dt> <dd>
<p>Memory addressed using $a0 or $a1. </p> </dd> <dt><code class="code">Si</code></dt> <dd>
<p>Memory addressed with immediate addresses. </p> </dd> <dt><code class="code">Ss</code></dt> <dd>
<p>Memory addressed using the stack pointer ($sp). </p> </dd> <dt><code class="code">Sf</code></dt> <dd>
<p>Memory addressed using the frame base register ($fb). </p> </dd> <dt><code class="code">Ss</code></dt> <dd>
<p>Memory addressed using the small base register ($sb). </p> </dd> <dt><code class="code">S1</code></dt> <dd><p>$r1h </p></dd> </dl> </dd> <dt>LoongArch—<samp class="file">config/loongarch/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">f</code></dt> <dd><p>A floating-point or vector register (if available). </p></dd> <dt><code class="code">k</code></dt> <dd><p>A memory operand whose address is formed by a base register and (optionally scaled) index register. </p></dd> <dt><code class="code">l</code></dt> <dd><p>A signed 16-bit constant. </p></dd> <dt><code class="code">m</code></dt> <dd><p>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as <code class="code">st.w</code> and <code class="code">ld.w</code>. </p></dd> <dt><code class="code">I</code></dt> <dd><p>A signed 12-bit constant (for arithmetic instructions). </p></dd> <dt><code class="code">K</code></dt> <dd><p>An unsigned 12-bit constant (for logic instructions). </p></dd> <dt><code class="code">M</code></dt> <dd><p>A constant that cannot be loaded using <code class="code">lui</code>, <code class="code">addiu</code> or <code class="code">ori</code>. </p></dd> <dt><code class="code">N</code></dt> <dd><p>A constant in the range -65535 to -1 (inclusive). </p></dd> <dt><code class="code">O</code></dt> <dd><p>A signed 15-bit constant. </p></dd> <dt><code class="code">P</code></dt> <dd><p>A constant in the range 1 to 65535 (inclusive). </p></dd> <dt><code class="code">R</code></dt> <dd><p>An address that can be used in a non-macro load or store. </p></dd> <dt><code class="code">ZB</code></dt> <dd><p>An address that is held in a general-purpose register. The offset is zero. </p></dd> <dt><code class="code">ZC</code></dt> <dd><p>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as <code class="code">ll.w</code> and <code class="code">sc.w</code>. </p></dd> </dl> </dd> <dt>MicroBlaze—<samp class="file">config/microblaze/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">d</code></dt> <dd>
<p>A general register (<code class="code">r0</code> to <code class="code">r31</code>). </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>A status register (<code class="code">rmsr</code>, <code class="code">$fcc1</code> to <code class="code">$fcc7</code>). </p> </dd> </dl> </dd> <dt>MIPS—<samp class="file">config/mips/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">d</code></dt> <dd>
<p>A general-purpose register. This is equivalent to <code class="code">r</code> unless generating MIPS16 code, in which case the MIPS16 register set is used. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>A floating-point register (if available). </p> </dd> <dt><code class="code">h</code></dt> <dd>
<p>Formerly the <code class="code">hi</code> register. This constraint is no longer supported. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>The <code class="code">lo</code> register. Use this register to store values that are no bigger than a word. </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>The concatenated <code class="code">hi</code> and <code class="code">lo</code> registers. Use this register to store doubleword values. </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>A register suitable for use in an indirect jump. This will always be <code class="code">$25</code> for <samp class="option">-mabicalls</samp>. </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>Register <code class="code">$3</code>. Do not use this constraint in new code; it is retained only for compatibility with glibc. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Equivalent to <code class="code">r</code>; retained for backwards compatibility. </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>A floating-point condition code register. </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A signed 16-bit constant (for arithmetic instructions). </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer zero. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>An unsigned 16-bit constant (for logic instructions). </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A signed 32-bit constant in which the lower 16 bits are zero. Such constants can be loaded using <code class="code">lui</code>. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>A constant that cannot be loaded using <code class="code">lui</code>, <code class="code">addiu</code> or <code class="code">ori</code>. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>A constant in the range −65535 to −1 (inclusive). </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>A signed 15-bit constant. </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>A constant in the range 1 to 65535 (inclusive). </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating-point zero. </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>An address that can be used in a non-macro load or store. </p> </dd> <dt><code class="code">ZC</code></dt> <dd>
<p>A memory operand whose address is formed by a base register and offset that is suitable for use in instructions with the same addressing mode as <code class="code">ll</code> and <code class="code">sc</code>. </p> </dd> <dt><code class="code">ZD</code></dt> <dd><p>An address suitable for a <code class="code">prefetch</code> instruction, or for any other instruction with the same addressing mode as <code class="code">prefetch</code>. </p></dd> </dl> </dd> <dt>Motorola 680x0—<samp class="file">config/m68k/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Address register </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Data register </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>68881 floating-point register, if available </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Integer in the range 1 to 8 </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>16-bit signed number </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Signed number whose magnitude is greater than 0x80 </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer in the range −8 to −1 </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Signed number whose magnitude is greater than 0x100 </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Range 24 to 31, rotatert:SI 8 to 1 expressed as rotate </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>16 (for rotate using swap) </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>Range 8 to 15, rotatert:HI 8 to 1 expressed as rotate </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>Numbers that mov3q can handle </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating point constant that is not a 68881 constant </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>Operands that satisfy ’m’ when -mpcrel is in effect </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>Operands that satisfy ’s’ when -mpcrel is not in effect </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Address register indirect addressing mode </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Register offset addressing </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>const_call_operand </p> </dd> <dt><code class="code">Cs</code></dt> <dd>
<p>symbol_ref or const </p> </dd> <dt><code class="code">Ci</code></dt> <dd>
<p>const_int </p> </dd> <dt><code class="code">C0</code></dt> <dd>
<p>const_int 0 </p> </dd> <dt><code class="code">Cj</code></dt> <dd>
<p>Range of signed numbers that don’t fit in 16 bits </p> </dd> <dt><code class="code">Cmvq</code></dt> <dd>
<p>Integers valid for mvq </p> </dd> <dt><code class="code">Capsw</code></dt> <dd>
<p>Integers valid for a moveq followed by a swap </p> </dd> <dt><code class="code">Cmvz</code></dt> <dd>
<p>Integers valid for mvz </p> </dd> <dt><code class="code">Cmvs</code></dt> <dd>
<p>Integers valid for mvs </p> </dd> <dt><code class="code">Ap</code></dt> <dd>
<p>push_operand </p> </dd> <dt><code class="code">Ac</code></dt> <dd>
<p>Non-register operands allowed in clr </p> </dd> </dl> </dd> <dt>Moxie—<samp class="file">config/moxie/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">A</code></dt> <dd>
<p>An absolute address </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>An offset address </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>A register indirect memory operand </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A constant in the range of 0 to 255. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>A constant in the range of 0 to −255. </p> </dd> </dl> </dd> <dt>MSP430–<samp class="file">config/msp430/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">R12</code></dt> <dd>
<p>Register R12. </p> </dd> <dt><code class="code">R13</code></dt> <dd>
<p>Register R13. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer constant 1. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer constant -1^20..1^19. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer constant 1-4. </p> </dd> <dt><code class="code">Ya</code></dt> <dd>
<p>Memory references which do not require an extended MOVX instruction. </p> </dd> <dt><code class="code">Yl</code></dt> <dd>
<p>Memory reference, labels only. </p> </dd> <dt><code class="code">Ys</code></dt> <dd>
<p>Memory reference, stack only. </p> </dd> </dl> </dd> <dt>NDS32—<samp class="file">config/nds32/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">w</code></dt> <dd><p>LOW register class $r0 to $r7 constraint for V3/V3M ISA. </p></dd> <dt><code class="code">l</code></dt> <dd><p>LOW register class $r0 to $r7. </p></dd> <dt><code class="code">d</code></dt> <dd><p>MIDDLE register class $r0 to $r11, $r16 to $r19. </p></dd> <dt><code class="code">h</code></dt> <dd><p>HIGH register class $r12 to $r14, $r20 to $r31. </p></dd> <dt><code class="code">t</code></dt> <dd><p>Temporary assist register $ta (i.e. $r15). </p></dd> <dt><code class="code">k</code></dt> <dd><p>Stack register $sp. </p></dd> <dt><code class="code">Iu03</code></dt> <dd><p>Unsigned immediate 3-bit value. </p></dd> <dt><code class="code">In03</code></dt> <dd><p>Negative immediate 3-bit value in the range of −7–0. </p></dd> <dt><code class="code">Iu04</code></dt> <dd><p>Unsigned immediate 4-bit value. </p></dd> <dt><code class="code">Is05</code></dt> <dd><p>Signed immediate 5-bit value. </p></dd> <dt><code class="code">Iu05</code></dt> <dd><p>Unsigned immediate 5-bit value. </p></dd> <dt><code class="code">In05</code></dt> <dd><p>Negative immediate 5-bit value in the range of −31–0. </p></dd> <dt><code class="code">Ip05</code></dt> <dd><p>Unsigned immediate 5-bit value for movpi45 instruction with range 16–47. </p></dd> <dt><code class="code">Iu06</code></dt> <dd><p>Unsigned immediate 6-bit value constraint for addri36.sp instruction. </p></dd> <dt><code class="code">Iu08</code></dt> <dd><p>Unsigned immediate 8-bit value. </p></dd> <dt><code class="code">Iu09</code></dt> <dd><p>Unsigned immediate 9-bit value. </p></dd> <dt><code class="code">Is10</code></dt> <dd><p>Signed immediate 10-bit value. </p></dd> <dt><code class="code">Is11</code></dt> <dd><p>Signed immediate 11-bit value. </p></dd> <dt><code class="code">Is15</code></dt> <dd><p>Signed immediate 15-bit value. </p></dd> <dt><code class="code">Iu15</code></dt> <dd><p>Unsigned immediate 15-bit value. </p></dd> <dt><code class="code">Ic15</code></dt> <dd><p>A constant which is not in the range of imm15u but ok for bclr instruction. </p></dd> <dt><code class="code">Ie15</code></dt> <dd><p>A constant which is not in the range of imm15u but ok for bset instruction. </p></dd> <dt><code class="code">It15</code></dt> <dd><p>A constant which is not in the range of imm15u but ok for btgl instruction. </p></dd> <dt><code class="code">Ii15</code></dt> <dd><p>A constant whose compliment value is in the range of imm15u and ok for bitci instruction. </p></dd> <dt><code class="code">Is16</code></dt> <dd><p>Signed immediate 16-bit value. </p></dd> <dt><code class="code">Is17</code></dt> <dd><p>Signed immediate 17-bit value. </p></dd> <dt><code class="code">Is19</code></dt> <dd><p>Signed immediate 19-bit value. </p></dd> <dt><code class="code">Is20</code></dt> <dd><p>Signed immediate 20-bit value. </p></dd> <dt><code class="code">Ihig</code></dt> <dd><p>The immediate value that can be simply set high 20-bit. </p></dd> <dt><code class="code">Izeb</code></dt> <dd><p>The immediate value 0xff. </p></dd> <dt><code class="code">Izeh</code></dt> <dd><p>The immediate value 0xffff. </p></dd> <dt><code class="code">Ixls</code></dt> <dd><p>The immediate value 0x01. </p></dd> <dt><code class="code">Ix11</code></dt> <dd><p>The immediate value 0x7ff. </p></dd> <dt><code class="code">Ibms</code></dt> <dd><p>The immediate value with power of 2. </p></dd> <dt><code class="code">Ifex</code></dt> <dd><p>The immediate value with power of 2 minus 1. </p></dd> <dt><code class="code">U33</code></dt> <dd><p>Memory constraint for 333 format. </p></dd> <dt><code class="code">U45</code></dt> <dd><p>Memory constraint for 45 format. </p></dd> <dt><code class="code">U37</code></dt> <dd><p>Memory constraint for 37 format. </p></dd> </dl> </dd> <dt>Nios II family—<samp class="file">config/nios2/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">I</code></dt> <dd>
<p>Integer that is valid as an immediate operand in an instruction taking a signed 16-bit number. Range −32768 to 32767. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer that is valid as an immediate operand in an instruction taking an unsigned 16-bit number. Range 0 to 65535. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer that is valid as an immediate operand in an instruction taking only the upper 16-bits of a 32-bit number. Range 32-bit numbers with the lower 16-bits being 0. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer that is valid as an immediate operand for a shift instruction. Range 0 to 31. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer that is valid as an immediate operand for only the value 0. Can be used in conjunction with the format modifier <code class="code">z</code> to use <code class="code">r0</code> instead of <code class="code">0</code> in the assembly output. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Integer that is valid as an immediate operand for a custom instruction opcode. Range 0 to 255. </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>An immediate operand for R2 andchi/andci instructions. </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>Matches immediates which are addresses in the small data section and therefore can be added to <code class="code">gp</code> as a 16-bit immediate to re-create their 32-bit value. </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Matches constants suitable as an operand for the rdprs and cache instructions. </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>A memory operand suitable for Nios II R2 load/store exclusive instructions. </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>A memory operand suitable for load/store IO and cache instructions. </p> </dd> </dl> </dd> <dt>OpenRISC—<samp class="file">config/or1k/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">I</code></dt> <dd>
<p>Integer that is valid as an immediate operand in an instruction taking a signed 16-bit number. Range −32768 to 32767. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer that is valid as an immediate operand in an instruction taking an unsigned 16-bit number. Range 0 to 65535. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Signed 16-bit constant shifted left 16 bits. (Used with <code class="code">l.movhi</code>) </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Zero </p> </dd> </dl> </dd> <dt>PDP-11—<samp class="file">config/pdp11/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Floating point registers AC0 through AC3. These can be loaded from/to memory with a single instruction. </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Odd numbered general registers (R1, R3, R5). These are used for 16-bit multiply operations. </p> </dd> <dt><code class="code">D</code></dt> <dd>
<p>A memory reference that is encoded within the opcode, but not auto-increment or auto-decrement. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Any of the floating point registers (AC0 through AC5). </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating point constant 0. </p> </dd> <dt><code class="code">h</code></dt> <dd>
<p>Floating point registers AC4 and AC5. These cannot be loaded from/to memory with a single instruction. </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>An integer constant that fits in 16 bits. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>An integer constant whose low order 16 bits are zero. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>An integer constant that does not meet the constraints for codes ‘<samp class="samp">I</samp>’ or ‘<samp class="samp">J</samp>’. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>The integer constant 1. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>The integer constant −1. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>The integer constant 0. </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Integer constants 0 through 3; shifts by these amounts are handled as multiple single-bit shifts rather than a single variable-length shift. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory reference which requires an additional word (address or offset) after the opcode. </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>A memory reference that is encoded within the opcode. </p> </dd> </dl> </dd> <dt>PowerPC and IBM RS6000—<samp class="file">config/rs6000/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">r</code></dt> <dd>
<p>A general purpose register (GPR), <code class="code">r0</code>…<code class="code">r31</code>. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>A base register. Like <code class="code">r</code>, but <code class="code">r0</code> is not allowed, so <code class="code">r1</code>…<code class="code">r31</code>. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>A floating point register (FPR), <code class="code">f0</code>…<code class="code">f31</code>. </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>A floating point register. This is the same as <code class="code">f</code> nowadays; historically <code class="code">f</code> was for single-precision and <code class="code">d</code> was for double-precision floating point. </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>An Altivec vector register (VR), <code class="code">v0</code>…<code class="code">v31</code>. </p> </dd> <dt><code class="code">wa</code></dt> <dd>
<p>A VSX register (VSR), <code class="code">vs0</code>…<code class="code">vs63</code>. This is either an FPR (<code class="code">vs0</code>…<code class="code">vs31</code> are <code class="code">f0</code>…<code class="code">f31</code>) or a VR (<code class="code">vs32</code>…<code class="code">vs63</code> are <code class="code">v0</code>…<code class="code">v31</code>). </p> <p>When using <code class="code">wa</code>, you should use the <code class="code">%x</code> output modifier, so that the correct register number is printed. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">asm ("xvadddp %x0,%x1,%x2"
     : "=wa" (v1)
     : "wa" (v2), "wa" (v3));</pre>
</div> <p>You should not use <code class="code">%x</code> for <code class="code">v</code> operands: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">asm ("xsaddqp %0,%1,%2"
     : "=v" (v1)
     : "v" (v2), "v" (v3));</pre>
</div> </dd> <dt><code class="code">c</code></dt> <dd>
<p>The count register, <code class="code">ctr</code>. </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>The link register, <code class="code">lr</code>. </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Condition register field 0, <code class="code">cr0</code>. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Any condition register field, <code class="code">cr0</code>…<code class="code">cr7</code>. </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A signed 16-bit constant. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>An unsigned 16-bit constant shifted left 16 bits (use <code class="code">L</code> instead for <code class="code">SImode</code> constants). </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>An unsigned 16-bit constant. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A signed 16-bit constant shifted left 16 bits. </p> </dd> <dt><code class="code">eI</code></dt> <dd>
<p>A signed 34-bit integer constant if prefixed instructions are supported. </p> </dd> <dt><code class="code">eP</code></dt> <dd>
<p>A scalar floating point constant or a vector constant that can be loaded to a VSX register with one prefixed instruction. </p> </dd> <dt><code class="code">eQ</code></dt> <dd>
<p>An IEEE 128-bit constant that can be loaded into a VSX register with the <code class="code">lxvkq</code> instruction. </p> </dd> <dt><code class="code">m</code></dt> <dd>
<p>A memory operand. Normally, <code class="code">m</code> does not allow addresses that update the base register. If the <code class="code">&lt;</code> or <code class="code">&gt;</code> constraint is also used, they are allowed and therefore on PowerPC targets in that case it is only safe to use <code class="code">m&lt;&gt;</code> in an <code class="code">asm</code> statement if that <code class="code">asm</code> statement accesses the operand exactly once. The <code class="code">asm</code> statement must also use <code class="code">%U<var class="var">&lt;opno&gt;</var></code> as a placeholder for the “update” flag in the corresponding load or store instruction. For example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">asm ("st%U0 %1,%0" : "=m&lt;&gt;" (mem) : "r" (val));</pre>
</div> <p>is correct but: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">asm ("st %1,%0" : "=m&lt;&gt;" (mem) : "r" (val));</pre>
</div> <p>is not. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory operand addressed by just a base register. </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>A memory operand accessed with indexed or indirect addressing. </p> </dd> <dt><code class="code">a</code></dt> <dd>
<p>An indexed or indirect address. </p> </dd> </dl> </dd> <dt>PRU—<samp class="file">config/pru/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">I</code></dt> <dd>
<p>An unsigned 8-bit integer constant. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>An unsigned 16-bit integer constant. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>An unsigned 5-bit integer constant (for shift counts). </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>A text segment (program memory) constant label. </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>Integer constant zero. </p> </dd> </dl> </dd> <dt>RL78—<samp class="file">config/rl78/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">Int3</code></dt> <dd><p>An integer constant in the range 1 … 7. </p></dd> <dt><code class="code">Int8</code></dt> <dd><p>An integer constant in the range 0 … 255. </p></dd> <dt><code class="code">J</code></dt> <dd><p>An integer constant in the range −255 … 0 </p></dd> <dt><code class="code">K</code></dt> <dd><p>The integer constant 1. </p></dd> <dt><code class="code">L</code></dt> <dd><p>The integer constant -1. </p></dd> <dt><code class="code">M</code></dt> <dd><p>The integer constant 0. </p></dd> <dt><code class="code">N</code></dt> <dd><p>The integer constant 2. </p></dd> <dt><code class="code">O</code></dt> <dd><p>The integer constant -2. </p></dd> <dt><code class="code">P</code></dt> <dd><p>An integer constant in the range 1 … 15. </p></dd> <dt><code class="code">Qbi</code></dt> <dd><p>The built-in compare types–eq, ne, gtu, ltu, geu, and leu. </p></dd> <dt><code class="code">Qsc</code></dt> <dd><p>The synthetic compare types–gt, lt, ge, and le. </p></dd> <dt><code class="code">Wab</code></dt> <dd><p>A memory reference with an absolute address. </p></dd> <dt><code class="code">Wbc</code></dt> <dd><p>A memory reference using <code class="code">BC</code> as a base register, with an optional offset. </p></dd> <dt><code class="code">Wca</code></dt> <dd><p>A memory reference using <code class="code">AX</code>, <code class="code">BC</code>, <code class="code">DE</code>, or <code class="code">HL</code> for the address, for calls. </p></dd> <dt><code class="code">Wcv</code></dt> <dd><p>A memory reference using any 16-bit register pair for the address, for calls. </p></dd> <dt><code class="code">Wd2</code></dt> <dd><p>A memory reference using <code class="code">DE</code> as a base register, with an optional offset. </p></dd> <dt><code class="code">Wde</code></dt> <dd><p>A memory reference using <code class="code">DE</code> as a base register, without any offset. </p></dd> <dt><code class="code">Wfr</code></dt> <dd><p>Any memory reference to an address in the far address space. </p></dd> <dt><code class="code">Wh1</code></dt> <dd><p>A memory reference using <code class="code">HL</code> as a base register, with an optional one-byte offset. </p></dd> <dt><code class="code">Whb</code></dt> <dd><p>A memory reference using <code class="code">HL</code> as a base register, with <code class="code">B</code> or <code class="code">C</code> as the index register. </p></dd> <dt><code class="code">Whl</code></dt> <dd><p>A memory reference using <code class="code">HL</code> as a base register, without any offset. </p></dd> <dt><code class="code">Ws1</code></dt> <dd><p>A memory reference using <code class="code">SP</code> as a base register, with an optional one-byte offset. </p></dd> <dt><code class="code">Y</code></dt> <dd><p>Any memory reference to an address in the near address space. </p></dd> <dt><code class="code">A</code></dt> <dd><p>The <code class="code">AX</code> register. </p></dd> <dt><code class="code">B</code></dt> <dd><p>The <code class="code">BC</code> register. </p></dd> <dt><code class="code">D</code></dt> <dd><p>The <code class="code">DE</code> register. </p></dd> <dt><code class="code">R</code></dt> <dd><p><code class="code">A</code> through <code class="code">L</code> registers. </p></dd> <dt><code class="code">S</code></dt> <dd><p>The <code class="code">SP</code> register. </p></dd> <dt><code class="code">T</code></dt> <dd><p>The <code class="code">HL</code> register. </p></dd> <dt><code class="code">Z08W</code></dt> <dd><p>The 16-bit <code class="code">R8</code> register. </p></dd> <dt><code class="code">Z10W</code></dt> <dd><p>The 16-bit <code class="code">R10</code> register. </p></dd> <dt><code class="code">Zint</code></dt> <dd><p>The registers reserved for interrupts (<code class="code">R24</code> to <code class="code">R31</code>). </p></dd> <dt><code class="code">a</code></dt> <dd><p>The <code class="code">A</code> register. </p></dd> <dt><code class="code">b</code></dt> <dd><p>The <code class="code">B</code> register. </p></dd> <dt><code class="code">c</code></dt> <dd><p>The <code class="code">C</code> register. </p></dd> <dt><code class="code">d</code></dt> <dd><p>The <code class="code">D</code> register. </p></dd> <dt><code class="code">e</code></dt> <dd><p>The <code class="code">E</code> register. </p></dd> <dt><code class="code">h</code></dt> <dd><p>The <code class="code">H</code> register. </p></dd> <dt><code class="code">l</code></dt> <dd><p>The <code class="code">L</code> register. </p></dd> <dt><code class="code">v</code></dt> <dd><p>The virtual registers. </p></dd> <dt><code class="code">w</code></dt> <dd><p>The <code class="code">PSW</code> register. </p></dd> <dt><code class="code">x</code></dt> <dd>
<p>The <code class="code">X</code> register. </p> </dd> </dl> </dd> <dt>RISC-V—<samp class="file">config/riscv/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">f</code></dt> <dd>
<p>A floating-point register (if available). </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>An I-type 12-bit signed immediate. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer zero. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>A 5-bit unsigned immediate for CSR access instructions. </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>An address that is held in a general-purpose register. </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>A constraint that matches an absolute symbolic address. </p> </dd> <dt><code class="code">vr</code></dt> <dd>
<p>A vector register (if available).. </p> </dd> <dt><code class="code">vd</code></dt> <dd>
<p>A vector register, excluding v0 (if available). </p> </dd> <dt><code class="code">vm</code></dt> <dd>
<p>A vector register, only v0 (if available). </p> </dd> </dl> </dd> <dt>RX—<samp class="file">config/rx/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">Q</code></dt> <dd>
<p>An address which does not involve register indirect addressing or pre/post increment/decrement addressing. </p> </dd> <dt><code class="code">Symbol</code></dt> <dd>
<p>A symbol reference. </p> </dd> <dt><code class="code">Int08</code></dt> <dd>
<p>A constant in the range −256 to 255, inclusive. </p> </dd> <dt><code class="code">Sint08</code></dt> <dd>
<p>A constant in the range −128 to 127, inclusive. </p> </dd> <dt><code class="code">Sint16</code></dt> <dd>
<p>A constant in the range −32768 to 32767, inclusive. </p> </dd> <dt><code class="code">Sint24</code></dt> <dd>
<p>A constant in the range −8388608 to 8388607, inclusive. </p> </dd> <dt><code class="code">Uint04</code></dt> <dd>
<p>A constant in the range 0 to 15, inclusive. </p> </dd> </dl> </dd> <dt>S/390 and zSeries—<samp class="file">config/s390/s390.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Address register (general purpose register except r0) </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Condition code register </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Data register (arbitrary general purpose register) </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Floating-point register </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Unsigned 8-bit constant (0–255) </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Unsigned 12-bit constant (0–4095) </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Signed 16-bit constant (−32768–32767) </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Value appropriate as displacement. </p>
<dl class="table"> <dt><code class="code">(0..4095)</code></dt> <dd><p>for short displacement </p></dd> <dt><code class="code">(−524288..524287)</code></dt> <dd><p>for long displacement </p></dd> </dl> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Constant integer with a value of 0x7fffffff. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Multiple letter constraint followed by 4 parameter letters. </p>
<dl class="table"> <dt><code class="code">0..9:</code></dt> <dd><p>number of the part counting from most to least significant </p></dd> <dt><code class="code">H,Q:</code></dt> <dd><p>mode of the part </p></dd> <dt><code class="code">D,S,H:</code></dt> <dd><p>mode of the containing operand </p></dd> <dt><code class="code">0,F:</code></dt> <dd><p>value of the other parts (F—all bits set) </p></dd> </dl> <p>The constraint matches if the specified part of a constant has a value different from its other parts. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Memory reference without index register and with short displacement. </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>Memory reference with index register and short displacement. </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>Memory reference without index register but with long displacement. </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>Memory reference with index register and long displacement. </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Pointer with short displacement. </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>Pointer with long displacement. </p> </dd> <dt><code class="code">Y</code></dt> <dd>
<p>Shift count operand. </p> </dd> </dl> </dd> <dt>SPARC—<samp class="file">config/sparc/sparc.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">f</code></dt> <dd>
<p>Floating-point register on the SPARC-V8 architecture and lower floating-point register on the SPARC-V9 architecture. </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Floating-point register. It is equivalent to ‘<samp class="samp">f</samp>’ on the SPARC-V8 architecture and contains both lower and upper floating-point registers on the SPARC-V9 architecture. </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Floating-point condition code register. </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Lower floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Floating-point register. It is only valid on the SPARC-V9 architecture when the Visual Instruction Set is available. </p> </dd> <dt><code class="code">h</code></dt> <dd>
<p>64-bit global or out register for the SPARC-V8+ architecture. </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>The constant all-ones, for floating-point. </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>Signed 5-bit constant </p> </dd> <dt><code class="code">D</code></dt> <dd>
<p>A vector constant </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Signed 13-bit constant </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Zero </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>32-bit constant with the low 12 bits clear (a constant that can be loaded with the <code class="code">sethi</code> instruction) </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A constant in the range supported by <code class="code">movcc</code> instructions (11-bit signed immediate) </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>A constant in the range supported by <code class="code">movrcc</code> instructions (10-bit signed immediate) </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Same as ‘<samp class="samp">K</samp>’, except that it verifies that bits that are not in the lower 32-bit range are all zero. Must be used instead of ‘<samp class="samp">K</samp>’ for modes wider than <code class="code">SImode</code> </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>The constant 4096 </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating-point zero </p> </dd> <dt><code class="code">H</code></dt> <dd>
<p>Signed 13-bit constant, sign-extended to 32 or 64 bits </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>The constant -1 </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Floating-point constant whose integral representation can be moved into an integer register using a single sethi instruction </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>Floating-point constant whose integral representation can be moved into an integer register using a single mov instruction </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>Floating-point constant whose integral representation can be moved into an integer register using a high/lo_sum instruction sequence </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>Memory address aligned to an 8-byte boundary </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>Even register </p> </dd> <dt><code class="code">W</code></dt> <dd>
<p>Memory address for ‘<samp class="samp">e</samp>’ constraint registers </p> </dd> <dt><code class="code">w</code></dt> <dd>
<p>Memory address with only a base register </p> </dd> <dt><code class="code">Y</code></dt> <dd>
<p>Vector zero </p> </dd> </dl> </dd> <dt>TI C6X family—<samp class="file">config/c6x/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Register file A (A0–A31). </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Register file B (B0–B31). </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>Predicate registers in register file A (A0–A2 on C64X and higher, A1 and A2 otherwise). </p> </dd> <dt><code class="code">B</code></dt> <dd>
<p>Predicate registers in register file B (B0–B2). </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>A call-used register in register file B (B0–B9, B16–B31). </p> </dd> <dt><code class="code">Da</code></dt> <dd>
<p>Register file A, excluding predicate registers (A3–A31, plus A0 if not C64X or higher). </p> </dd> <dt><code class="code">Db</code></dt> <dd>
<p>Register file B, excluding predicate registers (B3–B31). </p> </dd> <dt><code class="code">Iu4</code></dt> <dd>
<p>Integer constant in the range 0 … 15. </p> </dd> <dt><code class="code">Iu5</code></dt> <dd>
<p>Integer constant in the range 0 … 31. </p> </dd> <dt><code class="code">In5</code></dt> <dd>
<p>Integer constant in the range −31 … 0. </p> </dd> <dt><code class="code">Is5</code></dt> <dd>
<p>Integer constant in the range −16 … 15. </p> </dd> <dt><code class="code">I5x</code></dt> <dd>
<p>Integer constant that can be the operand of an ADDA or a SUBA insn. </p> </dd> <dt><code class="code">IuB</code></dt> <dd>
<p>Integer constant in the range 0 … 65535. </p> </dd> <dt><code class="code">IsB</code></dt> <dd>
<p>Integer constant in the range −32768 … 32767. </p> </dd> <dt><code class="code">IsC</code></dt> <dd>
<p>Integer constant in the range <em class="math">-2^{20}</em> … <em class="math">2^{20} - 1</em>. </p> </dd> <dt><code class="code">Jc</code></dt> <dd>
<p>Integer constant that is a valid mask for the clr instruction. </p> </dd> <dt><code class="code">Js</code></dt> <dd>
<p>Integer constant that is a valid mask for the set instruction. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Memory location with A base register. </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>Memory location with B base register. </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>Register B14 (aka DP). </p> </dd> </dl> </dd> <dt>Visium—<samp class="file">config/visium/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">b</code></dt> <dd>
<p>EAM register <code class="code">mdb</code> </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>EAM register <code class="code">mdc</code> </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Floating point register </p> </dd> <dt><code class="code">l</code></dt> <dd>
<p>General register, but not <code class="code">r29</code>, <code class="code">r30</code> and <code class="code">r31</code> </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>Register <code class="code">r1</code> </p> </dd> <dt><code class="code">u</code></dt> <dd>
<p>Register <code class="code">r2</code> </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>Register <code class="code">r3</code> </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Floating-point constant 0.0 </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer constant in the range 0 .. 65535 (16-bit immediate) </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer constant in the range 1 .. 31 (5-bit immediate) </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Integer constant in the range −65535 .. −1 (16-bit negative immediate) </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>Integer constant −1 </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>Integer constant 0 </p> </dd> <dt><code class="code">P</code></dt> <dd><p>Integer constant 32 </p></dd> </dl> </dd> <dt>x86 family—<samp class="file">config/i386/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">R</code></dt> <dd>
<p>Legacy register—the eight integer registers available on all i386 processors (<code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, <code class="code">d</code>, <code class="code">si</code>, <code class="code">di</code>, <code class="code">bp</code>, <code class="code">sp</code>). </p> </dd> <dt><code class="code">q</code></dt> <dd>
<p>Any register accessible as <code class="code"><var class="var">r</var>l</code>. In 32-bit mode, <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, and <code class="code">d</code>; in 64-bit mode, any integer register. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>Any register accessible as <code class="code"><var class="var">r</var>h</code>: <code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code>, and <code class="code">d</code>. </p> </dd> <dt><code class="code">a</code></dt> <dd>
<p>The <code class="code">a</code> register. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>The <code class="code">b</code> register. </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>The <code class="code">c</code> register. </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>The <code class="code">d</code> register. </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>The <code class="code">si</code> register. </p> </dd> <dt><code class="code">D</code></dt> <dd>
<p>The <code class="code">di</code> register. </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>The <code class="code">a</code> and <code class="code">d</code> registers. This class is used for instructions that return double word results in the <code class="code">ax:dx</code> register pair. Single word values will be allocated either in <code class="code">ax</code> or <code class="code">dx</code>. For example on i386 the following implements <code class="code">rdtsc</code>: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">unsigned long long rdtsc (void)
{
  unsigned long long tick;
  __asm__ __volatile__("rdtsc":"=A"(tick));
  return tick;
}</pre>
</div> <p>This is not correct on x86-64 as it would allocate tick in either <code class="code">ax</code> or <code class="code">dx</code>. You have to use the following variant instead: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">unsigned long long rdtsc (void)
{
  unsigned int tickl, tickh;
  __asm__ __volatile__("rdtsc":"=a"(tickl),"=d"(tickh));
  return ((unsigned long long)tickh &lt;&lt; 32)|tickl;
}</pre>
</div> </dd> <dt><code class="code">U</code></dt> <dd>
<p>The call-clobbered integer registers. </p> </dd> <dt><code class="code">f</code></dt> <dd>
<p>Any 80387 floating-point (stack) register. </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>Top of 80387 floating-point stack (<code class="code">%st(0)</code>). </p> </dd> <dt><code class="code">u</code></dt> <dd>
<p>Second from top of 80387 floating-point stack (<code class="code">%st(1)</code>). </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>Any MMX register. </p> </dd> <dt><code class="code">x</code></dt> <dd>
<p>Any SSE register. </p> </dd> <dt><code class="code">v</code></dt> <dd>
<p>Any EVEX encodable SSE register (<code class="code">%xmm0-%xmm31</code>). </p> </dd> <dt><code class="code">Yz</code></dt> <dd>
<p>First SSE register (<code class="code">%xmm0</code>). </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Integer constant in the range 0 … 31, for 32-bit shifts. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Integer constant in the range 0 … 63, for 64-bit shifts. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Signed 8-bit integer constant. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p><code class="code">0xFF</code> or <code class="code">0xFFFF</code>, for andsi as a zero-extending move. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>0, 1, 2, or 3 (shifts for the <code class="code">lea</code> instruction). </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>Unsigned 8-bit integer constant (for <code class="code">in</code> and <code class="code">out</code> instructions). </p> </dd> <dt><code class="code">G</code></dt> <dd>
<p>Standard 80387 floating point constant. </p> </dd> <dt><code class="code">C</code></dt> <dd>
<p>SSE constant zero operand. </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>32-bit signed integer constant, or a symbolic reference known to fit that range (for immediate operands in sign-extending x86-64 instructions). </p> </dd> <dt><code class="code">We</code></dt> <dd>
<p>32-bit signed integer constant, or a symbolic reference known to fit that range (for sign-extending conversion operations that require non-<code class="code">VOIDmode</code> immediate operands). </p> </dd> <dt><code class="code">Wz</code></dt> <dd>
<p>32-bit unsigned integer constant, or a symbolic reference known to fit that range (for zero-extending conversion operations that require non-<code class="code">VOIDmode</code> immediate operands). </p> </dd> <dt><code class="code">Wd</code></dt> <dd>
<p>128-bit integer constant where both the high and low 64-bit word satisfy the <code class="code">e</code> constraint. </p> </dd> <dt><code class="code">Ws</code></dt> <dd>
<p>A symbolic reference or label reference. You can use the <code class="code">%p</code> modifier to print the raw symbol. </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>32-bit unsigned integer constant, or a symbolic reference known to fit that range (for immediate operands in zero-extending x86-64 instructions). </p> </dd> <dt><code class="code">Tv</code></dt> <dd>
<p>VSIB address operand. </p> </dd> <dt><code class="code">Ts</code></dt> <dd>
<p>Address operand without segment register. </p> </dd> </dl> </dd> <dt>Xstormy16—<samp class="file">config/stormy16/stormy16.h</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>Register r0. </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>Register r1. </p> </dd> <dt><code class="code">c</code></dt> <dd>
<p>Register r2. </p> </dd> <dt><code class="code">d</code></dt> <dd>
<p>Register r8. </p> </dd> <dt><code class="code">e</code></dt> <dd>
<p>Registers r0 through r7. </p> </dd> <dt><code class="code">t</code></dt> <dd>
<p>Registers r0 and r1. </p> </dd> <dt><code class="code">y</code></dt> <dd>
<p>The carry register. </p> </dd> <dt><code class="code">z</code></dt> <dd>
<p>Registers r8 and r9. </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>A constant between 0 and 3 inclusive. </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>A constant that has exactly one bit set. </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>A constant that has exactly one bit clear. </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>A constant between 0 and 255 inclusive. </p> </dd> <dt><code class="code">M</code></dt> <dd>
<p>A constant between −255 and 0 inclusive. </p> </dd> <dt><code class="code">N</code></dt> <dd>
<p>A constant between −3 and 0 inclusive. </p> </dd> <dt><code class="code">O</code></dt> <dd>
<p>A constant between 1 and 4 inclusive. </p> </dd> <dt><code class="code">P</code></dt> <dd>
<p>A constant between −4 and −1 inclusive. </p> </dd> <dt><code class="code">Q</code></dt> <dd>
<p>A memory reference that is a stack push. </p> </dd> <dt><code class="code">R</code></dt> <dd>
<p>A memory reference that is a stack pop. </p> </dd> <dt><code class="code">S</code></dt> <dd>
<p>A memory reference that refers to a constant address of known value. </p> </dd> <dt><code class="code">T</code></dt> <dd>
<p>The register indicated by Rx (not implemented yet). </p> </dd> <dt><code class="code">U</code></dt> <dd>
<p>A constant that is not between 2 and 15 inclusive. </p> </dd> <dt><code class="code">Z</code></dt> <dd>
<p>The constant 0. </p> </dd> </dl> </dd> <dt>Xtensa—<samp class="file">config/xtensa/constraints.md</samp>
</dt> <dd>
<dl class="table"> <dt><code class="code">a</code></dt> <dd>
<p>General-purpose 32-bit register </p> </dd> <dt><code class="code">b</code></dt> <dd>
<p>One-bit boolean register </p> </dd> <dt><code class="code">A</code></dt> <dd>
<p>MAC16 40-bit accumulator register </p> </dd> <dt><code class="code">I</code></dt> <dd>
<p>Signed 12-bit integer constant, for use in MOVI instructions </p> </dd> <dt><code class="code">J</code></dt> <dd>
<p>Signed 8-bit integer constant, for use in ADDI instructions </p> </dd> <dt><code class="code">K</code></dt> <dd>
<p>Integer constant valid for BccI instructions </p> </dd> <dt><code class="code">L</code></dt> <dd>
<p>Unsigned constant valid for BccUI instructions </p> </dd> </dl> </dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Machine-Constraints.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Machine-Constraints.html</a>
  </p>
</div>
