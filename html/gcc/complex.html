<h1 class="section" id="Complex-Numbers">6.11 Complex Numbers</h1> <div class="section-level-extent" id="Complex">       <p>ISO C99 supports complex floating data types, and as an extension GCC supports them in C90 mode and in C++. GCC also supports complex integer data types which are not part of ISO C99. You can declare complex types using the keyword <code class="code">_Complex</code>. As an extension, the older GNU keyword <code class="code">__complex__</code> is also supported. </p> <p>For example, ‘<samp class="samp">_Complex double x;</samp>’ declares <code class="code">x</code> as a variable whose real part and imaginary part are both of type <code class="code">double</code>. ‘<samp class="samp">_Complex short int y;</samp>’ declares <code class="code">y</code> to have real and imaginary parts of type <code class="code">short int</code>; this is not likely to be useful, but it shows that the set of complex types is complete. </p> <p>To write a constant with a complex data type, use the suffix ‘<samp class="samp">i</samp>’ or ‘<samp class="samp">j</samp>’ (either one; they are equivalent). For example, <code class="code">2.5fi</code> has type <code class="code">_Complex float</code> and <code class="code">3i</code> has type <code class="code">_Complex int</code>. Such a constant always has a pure imaginary value, but you can form any complex value you like by adding one to a real constant. This is a GNU extension; if you have an ISO C99 conforming C library (such as the GNU C Library), and want to construct complex constants of floating type, you should include <code class="code">&lt;complex.h&gt;</code> and use the macros <code class="code">I</code> or <code class="code">_Complex_I</code> instead. </p> <p>The ISO C++14 library also defines the ‘<samp class="samp">i</samp>’ suffix, so C++14 code that includes the ‘<samp class="samp">&lt;complex&gt;</samp>’ header cannot use ‘<samp class="samp">i</samp>’ for the GNU extension. The ‘<samp class="samp">j</samp>’ suffix still has the GNU meaning. </p> <p>GCC can handle both implicit and explicit casts between the <code class="code">_Complex</code> types and other <code class="code">_Complex</code> types as casting both the real and imaginary parts to the scalar type. GCC can handle implicit and explicit casts from a scalar type to a <code class="code">_Complex</code> type and where the imaginary part will be considered zero. The C front-end can handle implicit and explicit casts from a <code class="code">_Complex</code> type to a scalar type where the imaginary part will be ignored. In C++ code, this cast is considered illformed and G++ will error out. </p> <p>GCC provides a built-in function <code class="code">__builtin_complex</code> will can be used to construct a complex value. </p>   <p>GCC has a few extensions which can be used to extract the real and the imaginary part of the complex-valued expression. Note these expressions are lvalues if the <var class="var">exp</var> is an lvalue. These expressions operands have the type of a complex type which might get prompoted to a complex type from a scalar type. E.g. <code class="code">__real__ (int)<var class="var">x</var></code> is the same as casting to <code class="code">_Complex int</code> before <code class="code">__real__</code> is done. </p> <table class="multitable"> <thead><tr>
<th width="40%">Expression</th>
<th width="60%">Description</th>
</tr></thead> <tbody>
<tr>
<td width="40%"><code class="code">__real__ <var class="var">exp</var></code></td>
<td width="60%">Extract the real part of <var class="var">exp</var>.</td>
</tr> <tr>
<td width="40%"><code class="code">__imag__ <var class="var">exp</var></code></td>
<td width="60%">Extract the imaginary part of <var class="var">exp</var>.</td>
</tr> </tbody> </table> <p>For values of floating point, you should use the ISO C99 functions, declared in <code class="code">&lt;complex.h&gt;</code> and also provided as built-in functions by GCC. </p> <table class="multitable"> <thead><tr>
<th width="40%">Expression</th>
<th width="20%">float</th>
<th width="20%">double</th>
<th width="20%">long double</th>
</tr></thead> <tbody>
<tr>
<td width="40%"><code class="code">__real__ <var class="var">exp</var></code></td>
<td width="20%"><code class="code">crealf</code></td>
<td width="20%"><code class="code">creal</code></td>
<td width="20%"><code class="code">creall</code></td>
</tr> <tr>
<td width="40%"><code class="code">__imag__ <var class="var">exp</var></code></td>
<td width="20%"><code class="code">cimagf</code></td>
<td width="20%"><code class="code">cimag</code></td>
<td width="20%"><code class="code">cimagl</code></td>
</tr> </tbody> </table>  <p>The operator ‘<samp class="samp">~</samp>’ performs complex conjugation when used on a value with a complex type. This is a GNU extension; for values of floating type, you should use the ISO C99 functions <code class="code">conjf</code>, <code class="code">conj</code> and <code class="code">conjl</code>, declared in <code class="code">&lt;complex.h&gt;</code> and also provided as built-in functions by GCC. Note unlike the <code class="code">__real__</code> and <code class="code">__imag__</code> operators, this operator will not do an implicit cast to the complex type because the ‘<samp class="samp">~</samp>’ is already a normal operator. </p> <p>GCC can allocate complex automatic variables in a noncontiguous fashion; it’s even possible for the real part to be in a register while the imaginary part is on the stack (or vice versa). Only the DWARF debug info format can represent this, so use of DWARF is recommended. If you are using the stabs debug info format, GCC describes a noncontiguous complex variable as if it were two separate variables of noncomplex type. If the variable’s actual name is <code class="code">foo</code>, the two fictitious variables are named <code class="code">foo$real</code> and <code class="code">foo$imag</code>. You can examine and set these two fictitious variables with your debugger. </p> <dl class="first-deftypefn"> <dt class="deftypefn" id="index-_005f_005fbuiltin_005fcomplex">
<span class="category-def">Built-in Function: </span><span><code class="def-type"><var class="var">type</var></code> <strong class="def-name">__builtin_complex</strong> <code class="def-code-arguments">(<var class="var">real</var>, <var class="var">imag</var>)</code></span>
</dt> <dd> <p>The built-in function <code class="code">__builtin_complex</code> is provided for use in implementing the ISO C11 macros <code class="code">CMPLXF</code>, <code class="code">CMPLX</code> and <code class="code">CMPLXL</code>. <var class="var">real</var> and <var class="var">imag</var> must have the same type, a real binary floating-point type, and the result has the corresponding complex type with real and imaginary parts <var class="var">real</var> and <var class="var">imag</var>. Unlike ‘<samp class="samp"><var class="var">real</var> + I * <var class="var">imag</var></samp>’, this works even when infinities, NaNs and negative zeros are involved. </p> </dd>
</dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Complex.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/gcc/Complex.html</a>
  </p>
</div>
