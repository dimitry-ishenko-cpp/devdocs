  <h1 id="downgrademodule">downgradeModule</h1> <p><code class="api-type-label function">function</code></p>  <aio-toc class="embedded"></aio-toc> <div class="api-body">  <p>A helper function for creating an AngularJS module that can bootstrap an Angular module "on-demand" (possibly lazily) when a <a href="downgradecomponent.html">downgraded component</a> needs to be instantiated.</p> <p><a href="downgrademodule.html#description">See more...</a></p>  <div class="overload-info"> <h3 data-language="typescript"><code>downgradeModule(moduleOrBootstrapFn: Type&lt;T&gt; | ((extraProviders: StaticProvider[]) =&gt; Promise&lt;NgModuleRef&lt;T&gt;&gt;)): string</code></h3> <h6 class="no-anchor" id="parameters">Parameters</h6> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>moduleOrBootstrapFn</code> </td> <td class="param-type"><code><a href="../../core/type.html" class="code-anchor">Type</a>&lt;T&gt; | ((extraProviders: <a href="../../core/staticprovider.html" class="code-anchor">StaticProvider</a>[]) =&gt; Promise&lt;<a href="../../core/ngmoduleref.html" class="code-anchor">NgModuleRef</a>&lt;T&gt;&gt;)</code></td> <td class="param-description"> </td> </tr> </tbody> </table> <h6 class="no-anchor" id="returns">Returns</h6> <p><code>string</code></p> </div>  <div class="overload-info"> <h3 data-language="typescript"><code>downgradeModule(moduleOrBootstrapFn: NgModuleFactory&lt;T&gt;): string</code></h3> <div class="deprecated"> <p><strong>Deprecated</strong> Passing <code><a href="../../core/ngmodulefactory.html" class="code-anchor">NgModuleFactory</a></code> as the <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a></code> function argument is deprecated, please pass an NgModule class reference instead.</p> </div> <h6 class="no-anchor" id="parameters-1">Parameters</h6> <table> <tbody> <tr class="function-overload-parameter"> <td class="param-name">  <code>moduleOrBootstrapFn</code> </td> <td class="param-type"><code><a href="../../core/ngmodulefactory.html" class="code-anchor">NgModuleFactory&lt;T&gt;</a></code></td> <td class="param-description"> </td> </tr> </tbody> </table> <h6 class="no-anchor" id="returns-1">Returns</h6> <p><code>string</code></p> </div>  <h2 id="description">Description</h2> <p><em>Part of the <a href="api?query=upgrade/static.html">upgrade/static</a> library for hybrid upgrade apps that support AOT compilation.</em></p> <p>It allows loading/bootstrapping the Angular part of a hybrid application lazily and not having to pay the cost up-front. For example, you can have an AngularJS application that uses Angular for specific routes and only instantiate the Angular modules if/when the user visits one of these routes.</p> <p>The Angular module will be bootstrapped once (when requested for the first time) and the same reference will be used from that point onwards.</p> <p><code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> requires either an <code><a href="../../core/ngmodulefactory.html" class="code-anchor">NgModuleFactory</a></code>, <code><a href="../../core/ngmodule.html" class="code-anchor">NgModule</a></code> class or a function:</p> <ul> <li>
<code><a href="../../core/ngmodulefactory.html" class="code-anchor">NgModuleFactory</a></code>: If you pass an <code><a href="../../core/ngmodulefactory.html" class="code-anchor">NgModuleFactory</a></code>, it will be used to instantiate a module using <code><a href="../../platform-browser/platformbrowser.html" class="code-anchor">platformBrowser</a></code>'s <a href="../../core/platformref.html#bootstrapModuleFactory"><code>PlatformRef#bootstrapModuleFactory</code></a>. NOTE: this type of the argument is deprecated. Please either provide an <code><a href="../../core/ngmodule.html" class="code-anchor">NgModule</a></code> class or a bootstrap function instead.</li> <li>
<code><a href="../../core/ngmodule.html" class="code-anchor">NgModule</a></code> class: If you pass an NgModule class, it will be used to instantiate a module using <code><a href="../../platform-browser/platformbrowser.html" class="code-anchor">platformBrowser</a></code>'s <a href="../../core/platformref.html#bootstrapModule"><code>PlatformRef#bootstrapModule</code></a>.</li> <li>
<code>Function</code>: If you pass a function, it is expected to return a promise resolving to an <code><a href="../../core/ngmoduleref.html" class="code-anchor">NgModuleRef</a></code>. The function is called with an array of extra <a href="../../core/staticprovider.html">Providers</a> that are expected to be available from the returned <code><a href="../../core/ngmoduleref.html" class="code-anchor">NgModuleRef</a></code>'s <code><a href="../../core/injector.html" class="code-anchor">Injector</a></code>.</li> </ul> <p><code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> returns the name of the created AngularJS wrapper module. You can use it to declare a dependency in your main AngularJS module.</p> <pre data-language="typescript">import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';
import {downgradeComponent, downgradeModule, UpgradeComponent} from '@angular/upgrade/static';




// The function that will bootstrap the Angular module (when/if necessary).
// (This would be omitted if we provided an `NgModuleFactory` directly.)
const ng2BootstrapFn = (extraProviders: StaticProvider[]) =&gt;
    platformBrowserDynamic(extraProviders).bootstrapModule(MyLazyAngularModule);


// This AngularJS module represents the AngularJS pieces of the application.
const myMainAngularJsModule = angular.module('myMainAngularJsModule', [
  // We declare a dependency on the "downgraded" Angular module.
  downgradeModule(ng2BootstrapFn)
  // or
  // downgradeModule(MyLazyAngularModuleFactory)
]);</pre> <p>For more details on how to use <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> see <a href="../../../guide/upgrade-performance.html">Upgrading for Performance</a>.</p> <p>Further information is available in the <a href="downgrademodule.html#usage-notes">Usage Notes...</a></p>   <h2 id="usage-notes">Usage notes</h2> <p>Apart from <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code>, you can use the rest of the <code><a href="../static.html" class="code-anchor">upgrade/static</a></code> helpers as usual to build a hybrid application. Note that the Angular pieces (e.g. downgraded services) will not be available until the downgraded module has been bootstrapped, i.e. by instantiating a downgraded component.</p> <blockquote class="alert is-important"> <p> You cannot use <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> and <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code> in the same hybrid application. Use one or the other.</p> </blockquote> <h3 id="differences-with-upgrademodule">Differences with <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code>
</h3> <p>Besides their different API, there are two important internal differences between <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> and <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code> that affect the behavior of hybrid applications:</p> <ol> <li>Unlike <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code>, <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> does not bootstrap the main AngularJS module inside the <a href="../../core/ngzone.html">Angular zone</a>.</li> <li>Unlike <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code>, <code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code> does not automatically run a <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest">$digest()</a> when changes are detected in the Angular part of the application.</li> </ol> <p>What this means is that applications using <code><a href="upgrademodule.html" class="code-anchor">UpgradeModule</a></code> will run change detection more frequently in order to ensure that both frameworks are properly notified about possible changes. This will inevitably result in more change detection runs than necessary.</p> <p><code><a href="downgrademodule.html" class="code-anchor">downgradeModule</a>()</code>, on the other side, does not try to tie the two change detection systems as tightly, restricting the explicit change detection runs only to cases where it knows it is necessary (e.g. when the inputs of a downgraded component change). This improves performance, especially in change-detection-heavy applications, but leaves it up to the developer to manually notify each framework as needed.</p> <p>For a more detailed discussion of the differences and their implications, see <a href="../../../guide/upgrade-performance.html">Upgrading for Performance</a>.</p> <blockquote class="alert is-helpful"> <p> You can manually trigger a change detection run in AngularJS using <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$apply">scope.$apply(...)</a> or <a href="https://docs.angularjs.org/api/ng/type/$rootScope.Scope#$digest">$rootScope.$digest()</a>.</p> <p> You can manually trigger a change detection run in Angular using <a href="../../core/ngzone.html#run"><code>NgZone#run</code></a>.</p> </blockquote> <h3 id="downgrading-multiple-modules">Downgrading multiple modules</h3> <p>It is possible to downgrade multiple modules and include them in an AngularJS application. In that case, each downgraded module will be bootstrapped when an associated downgraded component or injectable needs to be instantiated.</p> <p>Things to keep in mind, when downgrading multiple modules:</p> <ul> <li> <p>Each downgraded component/injectable needs to be explicitly associated with a downgraded module. See <code><a href="downgradecomponent.html" class="code-anchor">downgradeComponent</a>()</code> and <code><a href="downgradeinjectable.html" class="code-anchor">downgradeInjectable</a>()</code> for more details.</p> </li> <li> <p>If you want some injectables to be shared among all downgraded modules, you can provide them as <code><a href="../../core/staticprovider.html" class="code-anchor">StaticProvider</a></code>s, when creating the <code><a href="../../core/platformref.html" class="code-anchor">PlatformRef</a></code> (e.g. via <code><a href="../../platform-browser/platformbrowser.html" class="code-anchor">platformBrowser</a></code> or <code><a href="../../platform-browser-dynamic/platformbrowserdynamic.html" class="code-anchor">platformBrowserDynamic</a></code>).</p> </li> <li> <p>When using <a href="../../core/platformref.html#bootstrapmodule"><code>PlatformRef#bootstrapmodule</code></a> or <a href="../../core/platformref.html#bootstrapmodulefactory"><code>PlatformRef#bootstrapmodulefactory</code></a> to bootstrap the downgraded modules, each one is considered a "root" module. As a consequence, a new instance will be created for every injectable provided in <code>"root"</code> (via <a href="../../core/injectable.html#providedIn"><code>Injectable#providedIn</code></a>). If this is not your intention, you can have a shared module (that will act as act as the "root" module) and create all downgraded modules using that module's injector:</p> <pre data-language="typescript">let rootInjectorPromise: Promise&lt;Injector&gt;|null = null;
const getRootInjector = (extraProviders: StaticProvider[]) =&gt; {
  if (!rootInjectorPromise) {
    rootInjectorPromise = platformBrowserDynamic(extraProviders)
                              .bootstrapModule(Ng2RootModule)
                              .then(moduleRef =&gt; moduleRef.injector);
  }
  return rootInjectorPromise;
};

const downgradedNg2AModule = downgradeModule(async (extraProviders: StaticProvider[]) =&gt; {
  const rootInjector = await getRootInjector(extraProviders);
  const moduleAFactory = await rootInjector.get(Compiler).compileModuleAsync(Ng2AModule);
  return moduleAFactory.create(rootInjector);
});
const downgradedNg2BModule = downgradeModule(async (extraProviders: StaticProvider[]) =&gt; {
  const rootInjector = await getRootInjector(extraProviders);
  const moduleBFactory = await rootInjector.get(Compiler).compileModuleAsync(Ng2BModule);
  return moduleBFactory.create(rootInjector);
});
/* . . . */
const appModule =
    angular
        .module(
            'exampleAppModule', [downgradedNg2AModule, downgradedNg2BModule, downgradedNg2CModule])</pre> </li> </ul> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/api/upgrade/static/downgradeModule" class="_attribution-link">https://angular.io/api/upgrade/static/downgradeModule</a>
  </p>
</div>
