  <h1 id="tosignaloptions">ToSignalOptions</h1> <p><code class="api-type-label interface">interface</code></p>  <aio-toc class="embedded"></aio-toc> <div class="api-body">  <p>Options for <code><a href="tosignal.html" class="code-anchor">toSignal</a></code>.</p>  <pre data-language="typescript">interface ToSignalOptions {
  initialValue?: unknown
  requireSync?: boolean
  injector?: Injector
  manualCleanup?: boolean
  rejectErrors?: boolean
}</pre>   <h2 id="properties">Properties</h2> <table> <thead> <tr> <th>Property</th> <th>Description</th> </tr> </thead> <tbody> <tr class="instance-property"> <td>  <code class=""><span class="member-name">initialValue</span>?: unknown</code> </td> <td> <p>Initial value for the signal produced by <code><a href="tosignal.html" class="code-anchor">toSignal</a></code>.</p> <p>This will be the value of the signal until the observable emits its first value.</p> </td> </tr> <tr class="instance-property"> <td>  <code class=""><span class="member-name">requireSync</span>?: boolean</code> </td> <td> <p>Whether to require that the observable emits synchronously when <code><a href="tosignal.html" class="code-anchor">toSignal</a></code> subscribes.</p> <p>If this is <code>true</code>, <code><a href="tosignal.html" class="code-anchor">toSignal</a></code> will assert that the observable produces a value immediately upon subscription. Setting this option removes the need to either deal with <code>undefined</code> in the signal type or provide an <code>initialValue</code>, at the cost of a runtime error if this requirement is not met.</p> </td> </tr> <tr class="instance-property"> <td>  <code class=""><span class="member-name">injector</span>?: <a href="../injector.html" class="code-anchor">Injector</a></code> </td> <td> <p><code><a href="../injector.html" class="code-anchor">Injector</a></code> which will provide the <code><a href="../destroyref.html" class="code-anchor">DestroyRef</a></code> used to clean up the Observable subscription.</p> <p>If this is not provided, a <code><a href="../destroyref.html" class="code-anchor">DestroyRef</a></code> will be retrieved from the current <a href="../../../guide/dependency-injection-context.html">injection context</a>, unless manual cleanup is requested.</p> </td> </tr> <tr class="instance-property"> <td>  <code class=""><span class="member-name">manualCleanup</span>?: boolean</code> </td> <td> <p>Whether the subscription should be automatically cleaned up (via <code><a href="../destroyref.html" class="code-anchor">DestroyRef</a></code>) when <code><a href="toobservable.html" class="code-anchor">toObservable</a></code>'s creation context is destroyed.</p> <p>If manual cleanup is enabled, then <code><a href="../destroyref.html" class="code-anchor">DestroyRef</a></code> is not used, and the subscription will persist until the <code>Observable</code> itself completes.</p> </td> </tr> <tr class="instance-property"> <td>  <code class=""><span class="member-name">rejectErrors</span>?: boolean</code> </td> <td> <p>Whether <code><a href="tosignal.html" class="code-anchor">toSignal</a></code> should throw errors from the Observable error channel back to RxJS, where they'll be processed as uncaught exceptions.</p> <p>In practice, this means that the signal returned by <code><a href="tosignal.html" class="code-anchor">toSignal</a></code> will keep returning the last good value forever, as Observables which error produce no further values. This option emulates the behavior of the <code><a href="../../common/asyncpipe.html" class="code-anchor">async</a></code> pipe.</p> </td> </tr> </tbody> </table>  </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/api/core/rxjs-interop/ToSignalOptions" class="_attribution-link">https://angular.io/api/core/rxjs-interop/ToSignalOptions</a>
  </p>
</div>
