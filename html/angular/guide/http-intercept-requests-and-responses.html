  <h1 id="http---intercept-requests-and-responses">HTTP - Intercept requests and responses</h1> <p>With interception, you declare <em>interceptors</em> that inspect and transform HTTP requests from your application to a server. The same interceptors can also inspect and transform a server's responses on their way back to the application. Multiple interceptors form a <em>forward-and-backward</em> chain of request/response handlers.</p> <p>Interceptors can perform a variety of <em>implicit</em> tasks, from authentication to logging, in a routine, standard way, for every HTTP request/response.</p> <p>Without interception, developers would have to implement these tasks <em>explicitly</em> for each <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> method call.</p> <h2 id="write-an-interceptor">Write an interceptor</h2> <p>To implement an interceptor, declare a class that implements the <code>intercept()</code> method of the <code><a href="../api/common/http/httpinterceptor.html" class="code-anchor">HttpInterceptor</a></code> interface.</p> <p>Here is a do-nothing <code>noop</code> interceptor that passes the request through without touching it:</p> <pre header="app/http-interceptors/noop-interceptor.ts" data-language="typescript">import { Injectable } from '@angular/core';
import {
  HttpEvent, HttpInterceptor, HttpHandler, HttpRequest
} from '@angular/common/http';

import { Observable } from 'rxjs';

/** Pass untouched request through to the next request handler. */
@Injectable()
export class NoopInterceptor implements HttpInterceptor {
  intercept(req: HttpRequest&lt;any&gt;, next: HttpHandler):
    Observable&lt;HttpEvent&lt;any&gt;&gt; {
    return next.handle(req);
  }
}</pre> <p>The <code>intercept</code> method transforms a request into an <code>Observable</code> that eventually returns the HTTP response. In this sense, each interceptor is fully capable of handling the request entirely by itself.</p> <p>Most interceptors inspect the request on the way in and forward the potentially altered request to the <code>handle()</code> method of the <code>next</code> object which implements the <a href="../api/common/http/httphandler.html"><code>HttpHandler</code></a> interface.</p> <pre format="javascript" data-language="javascript">export abstract class HttpHandler {
  abstract handle(req: HttpRequest&lt;any&gt;): Observable&lt;HttpEvent&lt;any&gt;&gt;;
}</pre> <p>Like <code>intercept()</code>, the <code>handle()</code> method transforms an HTTP request into an <code>Observable</code> of <a href="http-intercept-requests-and-responses#interceptor-events"><code>HttpEvents</code></a> which ultimately include the server's response. The <code>intercept()</code> method could inspect that observable and alter it before returning it to the caller.</p> <p>This <code>no-op</code> interceptor calls <code>next.handle()</code> with the original request and returns the observable without doing a thing.</p> <h2 id="the-next-object">The <code>next</code> object</h2> <p>The <code>next</code> object represents the next interceptor in the chain of interceptors. The final <code>next</code> in the chain is the <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> backend handler that sends the request to the server and receives the server's response.</p> <p>Most interceptors call <code>next.handle()</code> so that the request flows through to the next interceptor and, eventually, the backend handler. An interceptor <em>could</em> skip calling <code>next.handle()</code>, short-circuit the chain, and <a href="http-interceptor-use-cases#caching">return its own <code>Observable</code></a> with an artificial server response.</p> <p>This is a common middleware pattern found in frameworks such as Express.js.</p> <h2 id="provide-the-interceptor">Provide the interceptor</h2> <p>The <code>NoopInterceptor</code> is like a service managed by Angular's <a href="dependency-injection.html">dependency injection (DI)</a> system. As with other services, you must provide the interceptor class before the app can use it.</p> <p>Write a provider for it like this one: </p><pre data-language="typescript">import { Provider } from '@angular/core';

// Injection token for the Http Interceptors multi-provider
import { HTTP_INTERCEPTORS } from '@angular/common/http';

/** Provider for the Noop Interceptor. */
export const noopInterceptorProvider: Provider =
  { provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true };</pre> <p>Notice the <code>multi: true</code> option. This required setting tells Angular that <code><a href="../api/common/http/http_interceptors.html" class="code-anchor">HTTP_INTERCEPTORS</a></code> is a token for a <em>multiprovider</em> that injects an array of values, rather than a single value.</p> <p>Because interceptors are optional dependencies of the <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> service, you must provide them in the same injector or a parent of the injector that provides <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code>. Interceptors provided <em>after</em> DI creates the <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> are ignored.</p> <p>This app provides <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> in the app's root injector by adding the <code><a href="../api/common/http/httpclientmodule.html" class="code-anchor">HttpClientModule</a></code> to the <code>providers</code> array of the <code><a href="../api/platform-browser/bootstrapapplication.html" class="code-anchor">bootstrapApplication</a>()</code> in <code>main.ts</code>. You should provide interceptors there as well.</p> <pre data-language="typescript">bootstrapApplication(AppComponent, {
  providers: [
    importProvidersFrom(HttpClientModule),
    noopInterceptorProvider,
  ]
});</pre> <h2 id="providing-many-interceptors">Providing many interceptors</h2> <p>There's a good chance that you'll create more interceptors.</p> <p>You <em>could</em> add each provider to the <code>providers</code> array of the <code><a href="../api/platform-browser/bootstrapapplication.html" class="code-anchor">bootstrapApplication</a>()</code> as you did for the <code>NoopInterceptor</code>.</p> <p>That's rather verbose and there's a good chance that you'll make a bookkeeping mistake trying to remember to add each one.</p> <p>You must also pay <a href="http-intercept-requests-and-responses#interceptor-order">close attention to the order</a> in which you provide these interceptors.</p> <p>Consider creating a "barrel" file that gathers <em>all the interceptor providers</em> into a single <code>httpInterceptorProviders</code> array.</p> <pre header="app/http-interceptors/index.ts" data-language="typescript">import { HTTP_INTERCEPTORS } from '@angular/common/http';

import { AuthInterceptor } from './auth-interceptor';
import { CachingInterceptor } from './caching-interceptor';
import { EnsureHttpsInterceptor } from './ensure-https-interceptor';
import { LoggingInterceptor } from './logging-interceptor';
import { NoopInterceptor } from './noop-interceptor';
import { TrimNameInterceptor } from './trim-name-interceptor';
import { UploadInterceptor } from './upload-interceptor';

/** Array of Http interceptor providers in outside-in order */
export const httpInterceptorProviders = [
  { provide: HTTP_INTERCEPTORS, useClass: NoopInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: EnsureHttpsInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: TrimNameInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: AuthInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: LoggingInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: UploadInterceptor, multi: true },
  { provide: HTTP_INTERCEPTORS, useClass: CachingInterceptor, multi: true },
];</pre> <blockquote class="alert is-helpful"> <p>These interceptors are defined in the complete sample code.</p> </blockquote> <p>Then import this array and add it to the <code><a href="../api/platform-browser/bootstrapapplication.html" class="code-anchor">bootstrapApplication</a>()</code> <code>providers</code> in <code>main.ts</code> like this:</p> <pre header="main.ts (interceptor providers)" data-language="typescript">bootstrapApplication(AppComponent, {
  providers: [
    importProvidersFrom(HttpClientModule),
    httpInterceptorProviders,
  ]
});</pre> <p>As you create new interceptors, add them to the <code>httpInterceptorProviders</code> array and you won't have to revisit <code>main.ts</code>.</p> <h2 id="interceptor-order">Interceptor order</h2> <p>Angular applies interceptors in the order that you provide them. For example, consider a situation in which you want to handle the authentication of your HTTP requests and log them before sending them to a server. To accomplish this task, you could provide an <code>AuthInterceptor</code> service and then a <code>LoggingInterceptor</code> service. Outgoing requests would flow from the <code>AuthInterceptor</code> to the <code>LoggingInterceptor</code>. Responses from these requests would flow in the other direction, from <code>LoggingInterceptor</code> back to <code>AuthInterceptor</code>. The following is a visual representation of the process:</p> <div class="lightbox"> <img alt="Interceptor in order of HttpClient, AuthInterceptor, AuthInterceptor, HttpBackend, Server, and back in opposite order to show the two-way flow" src="data:image/svg+xml;base64,PHN2ZyB2ZXJzaW9uPSIxLjEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDU0IDk0IiB3aWR0aD0iMzAwIj4KICA8c3R5bGU+CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciB7CiAgICAgIGZpbGw6IG5vbmU7CiAgICAgIHN0cm9rZTogYmxhY2s7CiAgICAgIHN0cm9rZS13aWR0aDogLjM7CiAgICB9CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciA+IHRleHQgewogICAgICBkb21pbmFudC1iYXNlbGluZTogY2VudHJhbDsKICAgICAgZmlsbDogYmxhY2s7CiAgICAgIGZvbnQtc2l6ZTogNHB4OwogICAgICBmb250LXdlaWdodDogbGlnaHRlcjsKICAgICAgbGV0dGVyLXNwYWNpbmc6IC4ycHg7CiAgICAgIHRleHQtYW5jaG9yOiBtaWRkbGU7CiAgICB9CiAgICAjaW50ZXJjZXB0b3ItZXhlYy1vcmRlciA+IC5kYXNoZWQgewogICAgICBzdHJva2UtZGFzaGFycmF5OiAyIDE7CiAgICB9CiAgPC9zdHlsZT4KCiAgPGRlZnM+CiAgICA8cmVjdCBpZD0idGV4dGJveCIgeD0iMiIgd2lkdGg9IjUwIiBoZWlnaHQ9IjEwIiByeD0iMiIgLz4KICAgIDxwYXRoIGlkPSJhcnJvdyIgZD0iTTEyLDAgdjEwIGwtMiwtNCBtMiw0IGwyLC00IiAvPgogICAgPGcgaWQ9ImFycm93cyI+CiAgICAgIDx1c2UgaHJlZj0iI2Fycm93IiAvPgogICAgICA8dXNlIGhyZWY9IiNhcnJvdyIgc3R5bGU9InRyYW5zZm9ybTogcm90YXRlWigxODBkZWcpOyB0cmFuc2Zvcm0tb3JpZ2luOiAyN3B4IDVweDsiIC8+CiAgICA8L2c+CiAgPC9kZWZzPgoKICA8ZyBpZD0iaW50ZXJjZXB0b3ItZXhlYy1vcmRlciI+CiAgICA8dGV4dCB4PSIyNyIgeT0iNyI+SHR0cENsaWVudDwvdGV4dD4KICAgIDx1c2UgaHJlZj0iI3RleHRib3giIHk9IjAyIiBjbGFzcz0iZGFzaGVkIiAvPgogICAgPHVzZSBocmVmPSIjYXJyb3dzIiAgeT0iMTIiIGNsYXNzPSJkYXNoZWQiIC8+CgogICAgPHRleHQgeD0iMjciIHk9IjI3Ij5BdXRoSW50ZXJjZXB0b3I8L3RleHQ+CiAgICA8dXNlIGhyZWY9IiN0ZXh0Ym94IiB5PSIyMiIgLz4KICAgIDx1c2UgaHJlZj0iI2Fycm93cyIgIHk9IjMyIiAvPgoKICAgIDx0ZXh0IHg9IjI3IiB5PSI0NyI+TG9nZ2luZ0ludGVyY2VwdG9yPC90ZXh0PgogICAgPHVzZSBocmVmPSIjdGV4dGJveCIgeT0iNDIiIC8+CiAgICA8dXNlIGhyZWY9IiNhcnJvd3MiICB5PSI1MiIgLz4KCiAgICA8dGV4dCB4PSIyNyIgeT0iNjciPkh0dHBCYWNrZW5kPC90ZXh0PgogICAgPHVzZSBocmVmPSIjdGV4dGJveCIgeT0iNjIiIC8+CiAgICA8dXNlIGhyZWY9IiNhcnJvd3MiICB5PSI3MiIgY2xhc3M9ImRhc2hlZCIgLz4KCiAgICA8dGV4dCB4PSIyNyIgeT0iODciPlNlcnZlcjwvdGV4dD4KICAgIDx1c2UgaHJlZj0iI3RleHRib3giIHk9IjgyIiBjbGFzcz0iZGFzaGVkIiAvPgogIDwvZz4KPC9zdmc+Cg==" width="300" height="522"> </div> <blockquote class="alert is-helpful"> <p>The last interceptor in the process is always the <code><a href="../api/common/http/httpbackend.html" class="code-anchor">HttpBackend</a></code> that handles communication with the server.</p> </blockquote> <p>You cannot change the order or remove interceptors later. If you need to enable and disable an interceptor dynamically, you'll have to build that capability into the interceptor itself.</p>  <h2 id="handle-interceptor-events">Handle interceptor events</h2> <p>Most <code><a href="../api/common/http/httpclient.html" class="code-anchor">HttpClient</a></code> methods return observables of <code><a href="../api/common/http/httpresponse.html" class="code-anchor">HttpResponse</a>&lt;any&gt;</code>. The <code><a href="../api/common/http/httpresponse.html" class="code-anchor">HttpResponse</a></code> class itself is actually an event, whose type is <code><a href="../api/common/http/httpeventtype.html#Response" class="code-anchor">HttpEventType.Response</a></code>. A single HTTP request can, however, generate multiple events of other types, including upload and download progress events. The methods <code>HttpInterceptor.intercept()</code> and <code>HttpHandler.handle()</code> return observables of <code><a href="../api/common/http/httpevent.html" class="code-anchor">HttpEvent</a>&lt;any&gt;</code>.</p> <p>Many interceptors are only concerned with the outgoing request and return the event stream from <code>next.handle()</code> without modifying it. Some interceptors, however, need to examine and modify the response from <code>next.handle()</code>; these operations can see all of these events in the stream.</p>  <p>Although interceptors are capable of modifying requests and responses, the <code><a href="../api/common/http/httprequest.html" class="code-anchor">HttpRequest</a></code> and <code><a href="../api/common/http/httpresponse.html" class="code-anchor">HttpResponse</a></code> instance properties are <code>readonly</code>, rendering them largely immutable. They are immutable for a good reason: An app might retry a request several times before it succeeds, which means that the interceptor chain can re-process the same request multiple times. If an interceptor could modify the original request object, the re-tried operation would start from the modified request rather than the original. Immutability ensures that interceptors see the same request for each try.</p> <blockquote class="alert is-helpful"> <p>Your interceptor should return every event without modification unless it has a compelling reason to do otherwise.</p> </blockquote> <p>TypeScript prevents you from setting <code><a href="../api/common/http/httprequest.html" class="code-anchor">HttpRequest</a></code> read-only properties.</p> <pre format="javascript" data-language="javascript">// Typescript disallows the following assignment because req.url is readonly
req.url = req.url.replace('http://', 'https://');</pre> <p>If you must alter a request, clone it first and modify the clone before passing it to <code>next.handle()</code>. You can clone and modify the request in a single step, as shown in the following example.</p> <pre header="app/http-interceptors/ensure-https-interceptor.ts (excerpt)" data-language="typescript">// clone request and replace 'http://' with 'https://' at the same time
const secureReq = req.clone({
  url: req.url.replace('http://', 'https://')
});
// send the cloned, "secure" request to the next handler.
return next.handle(secureReq);</pre> <p>The <code>clone()</code> method's hash argument lets you mutate specific properties of the request while copying the others.</p> <h3 id="modify-a-request-body">Modify a request body</h3> <p>The <code>readonly</code> assignment guard can't prevent deep updates and, in particular, it can't prevent you from modifying a property of a request body object.</p> <pre format="javascript" data-language="javascript">req.body.name = req.body.name.trim(); // bad idea!</pre> <p>If you must modify the request body, follow these steps.</p> <ol> <li>Copy the body and make your change in the copy.</li> <li>Clone the request object, using its <code>clone()</code> method.</li> <li>Replace the clone's body with the modified copy.</li> </ol> <pre header="app/http-interceptors/trim-name-interceptor.ts (excerpt)" data-language="typescript">// copy the body and trim whitespace from the name property
const newBody = { ...body, name: body.name.trim() };
// clone request and set its body
const newReq = req.clone({ body: newBody });
// send the cloned request to the next handler.
return next.handle(newReq);</pre> <h3 id="clear-the-request-body-in-a-clone">Clear the request body in a clone</h3> <p>Sometimes you need to clear the request body rather than replace it. To do this, set the cloned request body to <code>null</code>.</p> <blockquote class="alert is-helpful"> <p><strong>TIP</strong>:  If you set the cloned request body to <code>undefined</code>, Angular assumes you intend to leave the body as is.</p> </blockquote> <pre format="javascript" data-language="javascript">newReq = req.clone({ … }); // body not mentioned =&gt; preserve original body
newReq = req.clone({ body: undefined }); // preserve original body
newReq = req.clone({ body: null }); // clear the body</pre> <div class="reviewed">Last reviewed on Wed Aug 16 2023</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/guide/http-intercept-requests-and-responses" class="_attribution-link">https://angular.io/guide/http-intercept-requests-and-responses</a>
  </p>
</div>
