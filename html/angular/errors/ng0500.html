  <h1 id="ng0500-during-hydration-angular-expected-a-dom-node-but-either-the-actual-dom-was-different-or-was-not-found">NG0500: During hydration, Angular expected a DOM node, but either the actual DOM was different or was not found.</h1> <div class="error-description"> <h2 id="description">Description</h2> <p>This error means that during the hydration process, Angular expected a DOM structure as rendered and annotated during server side rendering. However, on the client, the DOM tree was different than the server rendered DOM tree.</p> <p>This error typically happens due to direct DOM manipulation using native browser APIs that alter the DOM structure outside of what Angular produced. It will also occur if you use <code>innerHTML</code> or <code>outerHTML</code> to set HTML content, which similarly alters the DOM structure outside of what Angular produced. You can resolve this by refactoring the component to use native Angular APIs instead of native APIs. If that's not possible, you can add the <code>ngSkipHydration</code> attribute to your component's host node, which will disable hydration for the component and its children. <code>ngSkipHydration</code> should only be used as a last resort and should be considered a bug that needs to be fixed.</p> <p>More information about hydration can be found in <a href="../guide/hydration.html">this guide</a>.</p> <p>The following example will trigger the error.</p> <pre data-language="typescript">@Component({
  standalone: true,
  selector: 'example-cmp',
  template: '&lt;div&gt;&lt;span&gt;world&lt;/span&gt;&lt;/div&gt;',
})
export class ExampleCmp {
  hostElement = inject(ElementRef).nativeElement;

  ngOnInit() {
    // Create a new &lt;p&gt; element with the `Hello` text inside
    const newNode = document.createElement('p');
    newNode.innerHTML = 'Hello';

    // Insert the &lt;p&gt; before the first element. Since Angular has no information
	  // about the &lt;p&gt; element, it will be looking for the &lt;div&gt; element at the first
	  // element position instead. As a result, a hydration mismatch error would be
	  // thrown. Instead, update component's template to create the &lt;p&gt; element.
	  this.hostElement.insertBefore(newNode, this.hostElement.firstChild);
	}
}</pre> </div>  <div class="debugging"> <h2 id="debugging-the-error">Debugging the error</h2> <p>The error message in the developer console should contain information on a specific part of the application's DOM structure that is causing the problem. Review that part of the application for hydration-related errors, such as direct DOM manipulation using native APIs.</p> <p>Check that your template has valid HTML structure. See more information in the <a href="../guide/hydration.html#valid-html-structure">hydration guide</a>.</p> <p>You can add the <code>ngSkipHydration</code> attribute to your component host node as a possible workaround.</p> <p>If your application works in development environment, but you see hydration errors in production builds, make sure that the generated HTML that is delivered to a browser contains comment nodes produced by Angular during the rendering on the server. Those comment nodes are used by Angular runtime as anchors for view containers (with and without hydration) and hydration process expects them to be present at their original locations. If you have a custom logic to remove comment nodes from the HTML generated by the server-side rendering or you've configured your CDN to remove them before serving the content - disable the comment nodes removal and check if hydration errors are gone.</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2023 Google, Inc.<br>Licensed under the Creative Commons Attribution License 4.0.<br>
    <a href="https://angular.io/errors/NG0500" class="_attribution-link">https://angular.io/errors/NG0500</a>
  </p>
</div>
