<h1>Application Structure and Lifecycle</h1> <p>Flask makes it pretty easy to write a web application. But there are quite a few different parts to an application and to each request it handles. Knowing what happens during application setup, serving, and handling requests will help you know what’s possible in Flask and how to structure your application.</p> <section id="application-setup"> <h2>Application Setup</h2> <p>The first step in creating a Flask application is creating the application object. Each Flask application is an instance of the <a class="reference internal" href="../api/index.html#flask.Flask" title="flask.Flask"><code>Flask</code></a> class, which collects all configuration, extensions, and views.</p> <pre data-language="python">from flask import Flask

app = Flask(__name__)
app.config.from_mapping(
    SECRET_KEY="dev",
)
app.config.from_prefixed_env()

@app.route("/")
def index():
    return "Hello, World!"
</pre> <p>This is known as the “application setup phase”, it’s the code you write that’s outside any view functions or other handlers. It can be split up between different modules and sub-packages, but all code that you want to be part of your application must be imported in order for it to be registered.</p> <p>All application setup must be completed before you start serving your application and handling requests. This is because WSGI servers divide work between multiple workers, or can be distributed across multiple machines. If the configuration changed in one worker, there’s no way for Flask to ensure consistency between other workers.</p> <p>Flask tries to help developers catch some of these setup ordering issues by showing an error if setup-related methods are called after requests are handled. In that case you’ll see this error:</p>  <p>The setup method ‘route’ can no longer be called on the application. It has already handled its first request, any changes will not be applied consistently. Make sure all imports, decorators, functions, etc. needed to set up the application are done before running it.</p>  <p>However, it is not possible for Flask to detect all cases of out-of-order setup. In general, don’t do anything to modify the <code>Flask</code> app object and <code>Blueprint</code> objects from within view functions that run during requests. This includes:</p> <ul class="simple"> <li>Adding routes, view functions, and other request handlers with <code>@app.route</code>, <code>@app.errorhandler</code>, <code>@app.before_request</code>, etc.</li> <li>Registering blueprints.</li> <li>Loading configuration with <code>app.config</code>.</li> <li>Setting up the Jinja template environment with <code>app.jinja_env</code>.</li> <li>Setting a session interface, instead of the default itsdangerous cookie.</li> <li>Setting a JSON provider with <code>app.json</code>, instead of the default provider.</li> <li>Creating and initializing Flask extensions.</li> </ul> </section> <section id="serving-the-application"> <h2>Serving the Application</h2> <p>Flask is a WSGI application framework. The other half of WSGI is the WSGI server. During development, Flask, through Werkzeug, provides a development WSGI server with the <code>flask run</code> CLI command. When you are done with development, use a production server to serve your application, see <a class="reference internal" href="../deploying/index.html"><span class="doc">Deploying to Production</span></a>.</p> <p>Regardless of what server you’re using, it will follow the <a class="pep reference external" href="https://peps.python.org/pep-3333/" id="index-0"><strong>PEP 3333</strong></a> WSGI spec. The WSGI server will be told how to access your Flask application object, which is the WSGI application. Then it will start listening for HTTP requests, translate the request data into a WSGI environ, and call the WSGI application with that data. The WSGI application will return data that is translated into an HTTP response.</p> <ol class="arabic simple"> <li>Browser or other client makes HTTP request.</li> <li>WSGI server receives request.</li> <li>WSGI server converts HTTP data to WSGI <code>environ</code> dict.</li> <li>WSGI server calls WSGI application with the <code>environ</code>.</li> <li>Flask, the WSGI application, does all its internal processing to route the request to a view function, handle errors, etc.</li> <li>Flask translates View function return into WSGI response data, passes it to WSGI server.</li> <li>WSGI server creates and send an HTTP response.</li> <li>Client receives the HTTP response.</li> </ol> <section id="middleware"> <h3>Middleware</h3> <p>The WSGI application above is a callable that behaves in a certain way. Middleware is a WSGI application that wraps another WSGI application. It’s a similar concept to Python decorators. The outermost middleware will be called by the server. It can modify the data passed to it, then call the WSGI application (or further middleware) that it wraps, and so on. And it can take the return value of that call and modify it further.</p> <p>From the WSGI server’s perspective, there is one WSGI application, the one it calls directly. Typically, Flask is the “real” application at the end of the chain of middleware. But even Flask can call further WSGI applications, although that’s an advanced, uncommon use case.</p> <p>A common middleware you’ll see used with Flask is Werkzeug’s <a class="reference external" href="https://werkzeug.palletsprojects.com/en/stable/middleware/proxy_fix/#werkzeug.middleware.proxy_fix.ProxyFix" title="(in Werkzeug v3.1.x)"><code>ProxyFix</code></a>, which modifies the request to look like it came directly from a client even if it passed through HTTP proxies on the way. There are other middleware that can handle serving static files, authentication, etc.</p> </section> </section> <section id="how-a-request-is-handled"> <h2>How a Request is Handled</h2> <p>For us, the interesting part of the steps above is when Flask gets called by the WSGI server (or middleware). At that point, it will do quite a lot to handle the request and generate the response. At the most basic, it will match the URL to a view function, call the view function, and pass the return value back to the server. But there are many more parts that you can use to customize its behavior.</p> <ol class="arabic simple"> <li>WSGI server calls the Flask object, which calls <a class="reference internal" href="../api/index.html#flask.Flask.wsgi_app" title="flask.Flask.wsgi_app"><code>Flask.wsgi_app()</code></a>.</li> <li>A <a class="reference internal" href="../api/index.html#flask.ctx.RequestContext" title="flask.ctx.RequestContext"><code>RequestContext</code></a> object is created. This converts the WSGI <code>environ</code> dict into a <a class="reference internal" href="../api/index.html#flask.Request" title="flask.Request"><code>Request</code></a> object. It also creates an <code>AppContext</code> object.</li> <li>The <a class="reference internal" href="../appcontext/index.html"><span class="doc">app context</span></a> is pushed, which makes <a class="reference internal" href="../api/index.html#flask.current_app" title="flask.current_app"><code>current_app</code></a> and <a class="reference internal" href="../api/index.html#flask.g" title="flask.g"><code>g</code></a> available.</li> <li>The <a class="reference internal" href="../api/index.html#flask.appcontext_pushed" title="flask.appcontext_pushed"><code>appcontext_pushed</code></a> signal is sent.</li> <li>The <a class="reference internal" href="../reqcontext/index.html"><span class="doc">request context</span></a> is pushed, which makes <a class="reference internal" href="../api/index.html#flask.request" title="flask.request"><code>request</code></a> and <a class="reference internal" href="../api/index.html#flask.session" title="flask.session"><code>session</code></a> available.</li> <li>The session is opened, loading any existing session data using the app’s <a class="reference internal" href="../api/index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>session_interface</code></a>, an instance of <a class="reference internal" href="../api/index.html#flask.sessions.SessionInterface" title="flask.sessions.SessionInterface"><code>SessionInterface</code></a>.</li> <li>The URL is matched against the URL rules registered with the <a class="reference internal" href="../api/index.html#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> decorator during application setup. If there is no match, the error - usually a 404, 405, or redirect - is stored to be handled later.</li> <li>The <a class="reference internal" href="../api/index.html#flask.request_started" title="flask.request_started"><code>request_started</code></a> signal is sent.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.Flask.url_value_preprocessor" title="flask.Flask.url_value_preprocessor"><code>url_value_preprocessor()</code></a> decorated functions are called.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.Flask.before_request" title="flask.Flask.before_request"><code>before_request()</code></a> decorated functions are called. If any of these function returns a value it is treated as the response immediately.</li> <li>If the URL didn’t match a route a few steps ago, that error is raised now.</li> <li>The <a class="reference internal" href="../api/index.html#flask.Flask.route" title="flask.Flask.route"><code>route()</code></a> decorated view function associated with the matched URL is called and returns a value to be used as the response.</li> <li>If any step so far raised an exception, and there is an <a class="reference internal" href="../api/index.html#flask.Flask.errorhandler" title="flask.Flask.errorhandler"><code>errorhandler()</code></a> decorated function that matches the exception class or HTTP error code, it is called to handle the error and return a response.</li> <li>Whatever returned a response value - a before request function, the view, or an error handler, that value is converted to a <a class="reference internal" href="../api/index.html#flask.Response" title="flask.Response"><code>Response</code></a> object.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.after_this_request" title="flask.after_this_request"><code>after_this_request()</code></a> decorated functions are called, then cleared.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.Flask.after_request" title="flask.Flask.after_request"><code>after_request()</code></a> decorated functions are called, which can modify the response object.</li> <li>The session is saved, persisting any modified session data using the app’s <a class="reference internal" href="../api/index.html#flask.Flask.session_interface" title="flask.Flask.session_interface"><code>session_interface</code></a>.</li> <li>The <a class="reference internal" href="../api/index.html#flask.request_finished" title="flask.request_finished"><code>request_finished</code></a> signal is sent.</li> <li>If any step so far raised an exception, and it was not handled by an error handler function, it is handled now. HTTP exceptions are treated as responses with their corresponding status code, other exceptions are converted to a generic 500 response. The <a class="reference internal" href="../api/index.html#flask.got_request_exception" title="flask.got_request_exception"><code>got_request_exception</code></a> signal is sent.</li> <li>The response object’s status, headers, and body are returned to the WSGI server.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.Flask.teardown_request" title="flask.Flask.teardown_request"><code>teardown_request()</code></a> decorated functions are called.</li> <li>The <a class="reference internal" href="../api/index.html#flask.request_tearing_down" title="flask.request_tearing_down"><code>request_tearing_down</code></a> signal is sent.</li> <li>The request context is popped, <a class="reference internal" href="../api/index.html#flask.request" title="flask.request"><code>request</code></a> and <a class="reference internal" href="../api/index.html#flask.session" title="flask.session"><code>session</code></a> are no longer available.</li> <li>Any <a class="reference internal" href="../api/index.html#flask.Flask.teardown_appcontext" title="flask.Flask.teardown_appcontext"><code>teardown_appcontext()</code></a> decorated functions are called.</li> <li>The <a class="reference internal" href="../api/index.html#flask.appcontext_tearing_down" title="flask.appcontext_tearing_down"><code>appcontext_tearing_down</code></a> signal is sent.</li> <li>The app context is popped, <a class="reference internal" href="../api/index.html#flask.current_app" title="flask.current_app"><code>current_app</code></a> and <a class="reference internal" href="../api/index.html#flask.g" title="flask.g"><code>g</code></a> are no longer available.</li> <li>The <a class="reference internal" href="../api/index.html#flask.appcontext_popped" title="flask.appcontext_popped"><code>appcontext_popped</code></a> signal is sent.</li> </ol> <p>There are even more decorators and customization points than this, but that aren’t part of every request lifecycle. They’re more specific to certain things you might use during a request, such as templates, building URLs, or handling JSON data. See the rest of this documentation, as well as the <a class="reference internal" href="../api/index.html"><span class="doc">API</span></a> to explore further.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://flask.palletsprojects.com/en/stable/lifecycle/" class="_attribution-link">https://flask.palletsprojects.com/en/stable/lifecycle/</a>
  </p>
</div>
