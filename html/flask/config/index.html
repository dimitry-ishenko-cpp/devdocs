<h1>Configuration Handling</h1> <p>Applications need some kind of configuration. There are different settings you might want to change depending on the application environment like toggling the debug mode, setting the secret key, and other such environment-specific things.</p> <p>The way Flask is designed usually requires the configuration to be available when the application starts up. You can hard code the configuration in the code, which for many small applications is not actually that bad, but there are better ways.</p> <p>Independent of how you load your config, there is a config object available which holds the loaded configuration values: The <a class="reference internal" href="../api/index.html#flask.Flask.config" title="flask.Flask.config"><code>config</code></a> attribute of the <a class="reference internal" href="../api/index.html#flask.Flask" title="flask.Flask"><code>Flask</code></a> object. This is the place where Flask itself puts certain configuration values and also where extensions can put their configuration values. But this is also where you can have your own configuration.</p> <section id="configuration-basics"> <h2>Configuration Basics</h2> <p>The <a class="reference internal" href="../api/index.html#flask.Flask.config" title="flask.Flask.config"><code>config</code></a> is actually a subclass of a dictionary and can be modified just like any dictionary:</p> <pre data-language="python">app = Flask(__name__)
app.config['TESTING'] = True
</pre> <p>Certain configuration values are also forwarded to the <a class="reference internal" href="../api/index.html#flask.Flask" title="flask.Flask"><code>Flask</code></a> object so you can read and write them from there:</p> <pre data-language="python">app.testing = True
</pre> <p>To update multiple keys at once you can use the <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict.update" title="(in Python v3.13)"><code>dict.update()</code></a> method:</p> <pre data-language="python">app.config.update(
    TESTING=True,
    SECRET_KEY='192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'
)
</pre> </section> <section id="debug-mode"> <h2>Debug Mode</h2> <p>The <a class="reference internal" href="#DEBUG" title="DEBUG"><code>DEBUG</code></a> config value is special because it may behave inconsistently if changed after the app has begun setting up. In order to set debug mode reliably, use the <code>--debug</code> option on the <code>flask</code> or <code>flask run</code> command. <code>flask run</code> will use the interactive debugger and reloader by default in debug mode.</p> <pre data-language="text">$ flask --app hello run --debug
</pre> <p>Using the option is recommended. While it is possible to set <a class="reference internal" href="#DEBUG" title="DEBUG"><code>DEBUG</code></a> in your config or code, this is strongly discouraged. It can’t be read early by the <code>flask run</code> command, and some systems or extensions may have already configured themselves based on a previous value.</p> </section> <section id="builtin-configuration-values"> <h2>Builtin Configuration Values</h2> <p>The following configuration values are used internally by Flask:</p> <dl class="py data"> <dt class="sig sig-object py" id="DEBUG">
<code>DEBUG</code> </dt> <dd>
<p>Whether debug mode is enabled. When using <code>flask run</code> to start the development server, an interactive debugger will be shown for unhandled exceptions, and the server will be reloaded when code changes. The <a class="reference internal" href="../api/index.html#flask.Flask.debug" title="flask.Flask.debug"><code>debug</code></a> attribute maps to this config key. This is set with the <code>FLASK_DEBUG</code> environment variable. It may not behave as expected if set in code.</p> <p><strong>Do not enable debug mode when deploying in production.</strong></p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="TESTING">
<code>TESTING</code> </dt> <dd>
<p>Enable testing mode. Exceptions are propagated rather than handled by the the app’s error handlers. Extensions may also change their behavior to facilitate easier testing. You should enable this in your own tests.</p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="PROPAGATE_EXCEPTIONS">
<code>PROPAGATE_EXCEPTIONS</code> </dt> <dd>
<p>Exceptions are re-raised rather than being handled by the app’s error handlers. If not set, this is implicitly true if <code>TESTING</code> or <code>DEBUG</code> is enabled.</p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="TRAP_HTTP_EXCEPTIONS">
<code>TRAP_HTTP_EXCEPTIONS</code> </dt> <dd>
<p>If there is no handler for an <code>HTTPException</code>-type exception, re-raise it to be handled by the interactive debugger instead of returning it as a simple error response.</p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="TRAP_BAD_REQUEST_ERRORS">
<code>TRAP_BAD_REQUEST_ERRORS</code> </dt> <dd>
<p>Trying to access a key that doesn’t exist from request dicts like <code>args</code> and <code>form</code> will return a 400 Bad Request error page. Enable this to treat the error as an unhandled exception instead so that you get the interactive debugger. This is a more specific version of <code>TRAP_HTTP_EXCEPTIONS</code>. If unset, it is enabled in debug mode.</p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SECRET_KEY">
<code>SECRET_KEY</code> </dt> <dd>
<p>A secret key that will be used for securely signing the session cookie and can be used for any other security related needs by extensions or your application. It should be a long random <code>bytes</code> or <code>str</code>. For example, copy the output of this to your config:</p> <pre data-language="python">$ python -c 'import secrets; print(secrets.token_hex())'
'192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'
</pre> <p><strong>Do not reveal the secret key when posting questions or committing code.</strong></p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SECRET_KEY_FALLBACKS">
<code>SECRET_KEY_FALLBACKS</code> </dt> <dd>
<p>A list of old secret keys that can still be used for unsigning, most recent first. This allows a project to implement key rotation without invalidating active sessions or other recently-signed secrets.</p> <p>Keys should be removed after an appropriate period of time, as checking each additional key adds some overhead.</p> <p>Flask’s built-in secure cookie session supports this. Extensions that use <a class="reference internal" href="#SECRET_KEY" title="SECRET_KEY"><code>SECRET_KEY</code></a> may not support this yet.</p> <p>Default: <code>None</code></p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_NAME">
<code>SESSION_COOKIE_NAME</code> </dt> <dd>
<p>The name of the session cookie. Can be changed in case you already have a cookie with the same name.</p> <p>Default: <code>'session'</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_DOMAIN">
<code>SESSION_COOKIE_DOMAIN</code> </dt> <dd>
<p>The value of the <code>Domain</code> parameter on the session cookie. If not set, browsers will only send the cookie to the exact domain it was set from. Otherwise, they will send it to any subdomain of the given value as well.</p> <p>Not setting this value is more restricted and secure than setting it.</p> <p>Default: <code>None</code></p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>If this is changed after the browser created a cookie is created with one setting, it may result in another being created. Browsers may send send both in an undefined order. In that case, you may want to change <a class="reference internal" href="#SESSION_COOKIE_NAME" title="SESSION_COOKIE_NAME"><code>SESSION_COOKIE_NAME</code></a> as well or otherwise invalidate old sessions.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>Not set by default, does not fall back to <code>SERVER_NAME</code>.</p> </div> </details>
</dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_PATH">
<code>SESSION_COOKIE_PATH</code> </dt> <dd>
<p>The path that the session cookie will be valid for. If not set, the cookie will be valid underneath <code>APPLICATION_ROOT</code> or <code>/</code> if that is not set.</p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_HTTPONLY">
<code>SESSION_COOKIE_HTTPONLY</code> </dt> <dd>
<p>Browsers will not allow JavaScript access to cookies marked as “HTTP only” for security.</p> <p>Default: <code>True</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_SECURE">
<code>SESSION_COOKIE_SECURE</code> </dt> <dd>
<p>Browsers will only send cookies with requests over HTTPS if the cookie is marked “secure”. The application must be served over HTTPS for this to make sense.</p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_PARTITIONED">
<code>SESSION_COOKIE_PARTITIONED</code> </dt> <dd>
<p>Browsers will send cookies based on the top-level document’s domain, rather than only the domain of the document setting the cookie. This prevents third party cookies set in iframes from “leaking” between separate sites.</p> <p>Browsers are beginning to disallow non-partitioned third party cookies, so you need to mark your cookies partitioned if you expect them to work in such embedded situations.</p> <p>Enabling this implicitly enables <a class="reference internal" href="#SESSION_COOKIE_SECURE" title="SESSION_COOKIE_SECURE"><code>SESSION_COOKIE_SECURE</code></a> as well, as it is only valid when served over HTTPS.</p> <p>Default: <code>False</code></p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_COOKIE_SAMESITE">
<code>SESSION_COOKIE_SAMESITE</code> </dt> <dd>
<p>Restrict how cookies are sent with requests from external sites. Can be set to <code>'Lax'</code> (recommended) or <code>'Strict'</code>. See <a class="reference internal" href="../web-security/index.html#security-cookie"><span class="std std-ref">Set-Cookie options</span></a>.</p> <p>Default: <code>None</code></p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">Added in version 1.0.</span></p> </div> </details>
</dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="PERMANENT_SESSION_LIFETIME">
<code>PERMANENT_SESSION_LIFETIME</code> </dt> <dd>
<p>If <code>session.permanent</code> is true, the cookie’s expiration will be set this number of seconds in the future. Can either be a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.13)"><code>datetime.timedelta</code></a> or an <code>int</code>.</p> <p>Flask’s default cookie implementation validates that the cryptographic signature is not older than this value.</p> <p>Default: <code>timedelta(days=31)</code> (<code>2678400</code> seconds)</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SESSION_REFRESH_EACH_REQUEST">
<code>SESSION_REFRESH_EACH_REQUEST</code> </dt> <dd>
<p>Control whether the cookie is sent with every response when <code>session.permanent</code> is true. Sending the cookie every time (the default) can more reliably keep the session from expiring, but uses more bandwidth. Non-permanent sessions are not affected.</p> <p>Default: <code>True</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="USE_X_SENDFILE">
<code>USE_X_SENDFILE</code> </dt> <dd>
<p>When serving files, set the <code>X-Sendfile</code> header instead of serving the data with Flask. Some web servers, such as Apache, recognize this and serve the data more efficiently. This only makes sense when using such a server.</p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SEND_FILE_MAX_AGE_DEFAULT">
<code>SEND_FILE_MAX_AGE_DEFAULT</code> </dt> <dd>
<p>When serving files, set the cache control max age to this number of seconds. Can be a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.13)"><code>datetime.timedelta</code></a> or an <code>int</code>. Override this value on a per-file basis using <a class="reference internal" href="../api/index.html#flask.Flask.get_send_file_max_age" title="flask.Flask.get_send_file_max_age"><code>get_send_file_max_age()</code></a> on the application or blueprint.</p> <p>If <code>None</code>, <code>send_file</code> tells the browser to use conditional requests will be used instead of a timed cache, which is usually preferable.</p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="TRUSTED_HOSTS">
<code>TRUSTED_HOSTS</code> </dt> <dd>
<p>Validate <a class="reference internal" href="../api/index.html#flask.Request.host" title="flask.Request.host"><code>Request.host</code></a> and other attributes that use it against these trusted values. Raise a <a class="reference external" href="https://werkzeug.palletsprojects.com/en/stable/exceptions/#werkzeug.exceptions.SecurityError" title="(in Werkzeug v3.1.x)"><code>SecurityError</code></a> if the host is invalid, which results in a 400 error. If it is <code>None</code>, all hosts are valid. Each value is either an exact match, or can start with a dot <code>.</code> to match any subdomain.</p> <p>Validation is done during routing against this value. <code>before_request</code> and <code>after_request</code> callbacks will still be called.</p> <p>Default: <code>None</code></p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="SERVER_NAME">
<code>SERVER_NAME</code> </dt> <dd>
<p>Inform the application what host and port it is bound to.</p> <p>Must be set if <code>subdomain_matching</code> is enabled, to be able to extract the subdomain from the request.</p> <p>Must be set for <code>url_for</code> to generate external URLs outside of a request context.</p> <p>Default: <code>None</code></p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 3.1: </span>Does not restrict requests to only this domain, for both <code>subdomain_matching</code> and <code>host_matching</code>.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span>Does not affect <code>SESSION_COOKIE_DOMAIN</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span>Does not implicitly enable <code>subdomain_matching</code>.</p> </div> </details>
</dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="APPLICATION_ROOT">
<code>APPLICATION_ROOT</code> </dt> <dd>
<p>Inform the application what path it is mounted under by the application / web server. This is used for generating URLs outside the context of a request (inside a request, the dispatcher is responsible for setting <code>SCRIPT_NAME</code> instead; see <a class="reference internal" href="../patterns/appdispatch/index.html"><span class="doc">Application Dispatching</span></a> for examples of dispatch configuration).</p> <p>Will be used for the session cookie path if <code>SESSION_COOKIE_PATH</code> is not set.</p> <p>Default: <code>'/'</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="PREFERRED_URL_SCHEME">
<code>PREFERRED_URL_SCHEME</code> </dt> <dd>
<p>Use this scheme for generating external URLs when not in a request context.</p> <p>Default: <code>'http'</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="MAX_CONTENT_LENGTH">
<code>MAX_CONTENT_LENGTH</code> </dt> <dd>
<p>The maximum number of bytes that will be read during this request. If this limit is exceeded, a 413 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/stable/exceptions/#werkzeug.exceptions.RequestEntityTooLarge" title="(in Werkzeug v3.1.x)"><code>RequestEntityTooLarge</code></a> error is raised. If it is set to <code>None</code>, no limit is enforced at the Flask application level. However, if it is <code>None</code> and the request has no <code>Content-Length</code> header and the WSGI server does not indicate that it terminates the stream, then no data is read to avoid an infinite stream.</p> <p>Each request defaults to this config. It can be set on a specific <a class="reference internal" href="../api/index.html#flask.Request.max_content_length" title="flask.Request.max_content_length"><code>Request.max_content_length</code></a> to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs.</p> <p>Default: <code>None</code></p> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">Added in version 0.6.</span></p> </div> </details>
</dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="MAX_FORM_MEMORY_SIZE">
<code>MAX_FORM_MEMORY_SIZE</code> </dt> <dd>
<p>The maximum size in bytes any non-file form field may be in a <code>multipart/form-data</code> body. If this limit is exceeded, a 413 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/stable/exceptions/#werkzeug.exceptions.RequestEntityTooLarge" title="(in Werkzeug v3.1.x)"><code>RequestEntityTooLarge</code></a> error is raised. If it is set to <code>None</code>, no limit is enforced at the Flask application level.</p> <p>Each request defaults to this config. It can be set on a specific <code>Request.max_form_memory_parts</code> to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs.</p> <p>Default: <code>500_000</code></p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="MAX_FORM_PARTS">
<code>MAX_FORM_PARTS</code> </dt> <dd>
<p>The maximum number of fields that may be present in a <code>multipart/form-data</code> body. If this limit is exceeded, a 413 <a class="reference external" href="https://werkzeug.palletsprojects.com/en/stable/exceptions/#werkzeug.exceptions.RequestEntityTooLarge" title="(in Werkzeug v3.1.x)"><code>RequestEntityTooLarge</code></a> error is raised. If it is set to <code>None</code>, no limit is enforced at the Flask application level.</p> <p>Each request defaults to this config. It can be set on a specific <a class="reference internal" href="../api/index.html#flask.Request.max_form_parts" title="flask.Request.max_form_parts"><code>Request.max_form_parts</code></a> to apply the limit to that specific view. This should be set appropriately based on an application’s or view’s specific needs.</p> <p>Default: <code>1_000</code></p> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.1.</span></p> </div> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="TEMPLATES_AUTO_RELOAD">
<code>TEMPLATES_AUTO_RELOAD</code> </dt> <dd>
<p>Reload templates when they are changed. If not set, it will be enabled in debug mode.</p> <p>Default: <code>None</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="EXPLAIN_TEMPLATE_LOADING">
<code>EXPLAIN_TEMPLATE_LOADING</code> </dt> <dd>
<p>Log debugging information tracing how a template file was loaded. This can be useful to figure out why a template was not loaded or the wrong file appears to be loaded.</p> <p>Default: <code>False</code></p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="MAX_COOKIE_SIZE">
<code>MAX_COOKIE_SIZE</code> </dt> <dd>
<p>Warn if cookie headers are larger than this many bytes. Defaults to <code>4093</code>. Larger cookies may be silently ignored by browsers. Set to <code>0</code> to disable the warning.</p> </dd>
</dl> <dl class="py data"> <dt class="sig sig-object py" id="PROVIDE_AUTOMATIC_OPTIONS">
<code>PROVIDE_AUTOMATIC_OPTIONS</code> </dt> <dd>
<p>Set to <code>False</code> to disable the automatic addition of OPTIONS responses. This can be overridden per route by altering the <code>provide_automatic_options</code> attribute.</p> </dd>
</dl> <div class="versionadded"> <p><span class="versionmodified added">Added in version 3.10: </span>Added <a class="reference internal" href="#PROVIDE_AUTOMATIC_OPTIONS" title="PROVIDE_AUTOMATIC_OPTIONS"><code>PROVIDE_AUTOMATIC_OPTIONS</code></a> to control the default addition of autogenerated OPTIONS responses.</p> </div> <details class="changelog"> <summary>Changelog</summary><div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span><code>JSON_AS_ASCII</code>, <code>JSON_SORT_KEYS</code>, <code>JSONIFY_MIMETYPE</code>, and <code>JSONIFY_PRETTYPRINT_REGULAR</code> were removed. The default <code>app.json</code> provider has equivalent attributes instead.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.3: </span><code>ENV</code> was removed.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.2: </span>Removed <code>PRESERVE_CONTEXT_ON_EXCEPTION</code>.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.0: </span><code>LOGGER_NAME</code> and <code>LOGGER_HANDLER_POLICY</code> were removed. See <a class="reference internal" href="../logging/index.html"><span class="doc">Logging</span></a> for information about configuration.</p> <p>Added <code>ENV</code> to reflect the <code id="index-0">FLASK_ENV</code> environment variable.</p> <p>Added <a class="reference internal" href="#SESSION_COOKIE_SAMESITE" title="SESSION_COOKIE_SAMESITE"><code>SESSION_COOKIE_SAMESITE</code></a> to control the session cookie’s <code>SameSite</code> option.</p> <p>Added <a class="reference internal" href="#MAX_COOKIE_SIZE" title="MAX_COOKIE_SIZE"><code>MAX_COOKIE_SIZE</code></a> to control a warning from Werkzeug.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.11: </span><code>SESSION_REFRESH_EACH_REQUEST</code>, <code>TEMPLATES_AUTO_RELOAD</code>, <code>LOGGER_HANDLER_POLICY</code>, <code>EXPLAIN_TEMPLATE_LOADING</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.10: </span><code>JSON_AS_ASCII</code>, <code>JSON_SORT_KEYS</code>, <code>JSONIFY_PRETTYPRINT_REGULAR</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.9: </span><code>PREFERRED_URL_SCHEME</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.8: </span><code>TRAP_BAD_REQUEST_ERRORS</code>, <code>TRAP_HTTP_EXCEPTIONS</code>, <code>APPLICATION_ROOT</code>, <code>SESSION_COOKIE_DOMAIN</code>, <code>SESSION_COOKIE_PATH</code>, <code>SESSION_COOKIE_HTTPONLY</code>, <code>SESSION_COOKIE_SECURE</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.7: </span><code>PROPAGATE_EXCEPTIONS</code>, <code>PRESERVE_CONTEXT_ON_EXCEPTION</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.6: </span><code>MAX_CONTENT_LENGTH</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.5: </span><code>SERVER_NAME</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">Added in version 0.4: </span><code>LOGGER_NAME</code></p> </div> </details></section> <section id="configuring-from-python-files"> <h2>Configuring from Python Files</h2> <p>Configuration becomes more useful if you can store it in a separate file, ideally located outside the actual application package. You can deploy your application, then separately configure it for the specific deployment.</p> <p>A common pattern is this:</p> <pre data-language="python">app = Flask(__name__)
app.config.from_object('yourapplication.default_settings')
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
</pre> <p>This first loads the configuration from the <code>yourapplication.default_settings</code> module and then overrides the values with the contents of the file the <code id="index-1">YOURAPPLICATION_SETTINGS</code> environment variable points to. This environment variable can be set in the shell before starting the server:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-0-QmFzaA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-0-QmFzaA==" name="QmFzaA==" role="tab" tabindex="0">Bash</button><button aria-controls="panel-0-RmlzaA==" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-RmlzaA==" name="RmlzaA==" role="tab" tabindex="-1">Fish</button><button aria-controls="panel-0-Q01E" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-Q01E" name="Q01E" role="tab" tabindex="-1">CMD</button><button aria-controls="panel-0-UG93ZXJzaGVsbA==" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-0-UG93ZXJzaGVsbA==" name="UG93ZXJzaGVsbA==" role="tab" tabindex="-1">Powershell</button>
</div>
<div aria-labelledby="tab-0-QmFzaA==" class="sphinx-tabs-panel group-tab" id="panel-0-QmFzaA==" name="QmFzaA==" role="tabpanel" tabindex="0">
<pre data-language="text">$ export YOURAPPLICATION_SETTINGS=/path/to/settings.cfg
$ flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-0-RmlzaA==" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-RmlzaA==" name="RmlzaA==" role="tabpanel" tabindex="0">
<pre data-language="text">$ set -x YOURAPPLICATION_SETTINGS /path/to/settings.cfg
$ flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-0-Q01E" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-Q01E" name="Q01E" role="tabpanel" tabindex="0">
<pre data-language="text">&gt; set YOURAPPLICATION_SETTINGS=\path\to\settings.cfg
&gt; flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-0-UG93ZXJzaGVsbA==" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-0-UG93ZXJzaGVsbA==" name="UG93ZXJzaGVsbA==" role="tabpanel" tabindex="0">
<pre data-language="text">&gt; $env:YOURAPPLICATION_SETTINGS = "\path\to\settings.cfg"
&gt; flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
</div> <p>The configuration files themselves are actual Python files. Only values in uppercase are actually stored in the config object later on. So make sure to use uppercase letters for your config keys.</p> <p>Here is an example of a configuration file:</p> <pre data-language="python"># Example configuration
SECRET_KEY = '192b9bdd22ab9ed4d12e236c78afcb9a393ec15f71bbf5dc987d54727823bcbf'
</pre> <p>Make sure to load the configuration very early on, so that extensions have the ability to access the configuration when starting up. There are other methods on the config object as well to load from individual files. For a complete reference, read the <a class="reference internal" href="../api/index.html#flask.Config" title="flask.Config"><code>Config</code></a> object’s documentation.</p> </section> <section id="configuring-from-data-files"> <h2>Configuring from Data Files</h2> <p>It is also possible to load configuration from a file in a format of your choice using <a class="reference internal" href="../api/index.html#flask.Config.from_file" title="flask.Config.from_file"><code>from_file()</code></a>. For example to load from a TOML file:</p> <pre data-language="python">import tomllib
app.config.from_file("config.toml", load=tomllib.load, text=False)
</pre> <p>Or from a JSON file:</p> <pre data-language="python">import json
app.config.from_file("config.json", load=json.load)
</pre> </section> <section id="configuring-from-environment-variables"> <h2>Configuring from Environment Variables</h2> <p>In addition to pointing to configuration files using environment variables, you may find it useful (or necessary) to control your configuration values directly from the environment. Flask can be instructed to load all environment variables starting with a specific prefix into the config using <a class="reference internal" href="../api/index.html#flask.Config.from_prefixed_env" title="flask.Config.from_prefixed_env"><code>from_prefixed_env()</code></a>.</p> <p>Environment variables can be set in the shell before starting the server:</p> <div class="sphinx-tabs docutils container"> <div aria-label="Tabbed content" class="closeable" role="tablist">
<button aria-controls="panel-1-QmFzaA==" aria-selected="true" class="sphinx-tabs-tab group-tab" id="tab-1-QmFzaA==" name="QmFzaA==" role="tab" tabindex="0">Bash</button><button aria-controls="panel-1-RmlzaA==" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-RmlzaA==" name="RmlzaA==" role="tab" tabindex="-1">Fish</button><button aria-controls="panel-1-Q01E" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-Q01E" name="Q01E" role="tab" tabindex="-1">CMD</button><button aria-controls="panel-1-UG93ZXJzaGVsbA==" aria-selected="false" class="sphinx-tabs-tab group-tab" id="tab-1-UG93ZXJzaGVsbA==" name="UG93ZXJzaGVsbA==" role="tab" tabindex="-1">Powershell</button>
</div>
<div aria-labelledby="tab-1-QmFzaA==" class="sphinx-tabs-panel group-tab" id="panel-1-QmFzaA==" name="QmFzaA==" role="tabpanel" tabindex="0">
<pre data-language="text">$ export FLASK_SECRET_KEY="5f352379324c22463451387a0aec5d2f"
$ export FLASK_MAIL_ENABLED=false
$ flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-1-RmlzaA==" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-RmlzaA==" name="RmlzaA==" role="tabpanel" tabindex="0">
<pre data-language="text">$ set -x FLASK_SECRET_KEY "5f352379324c22463451387a0aec5d2f"
$ set -x FLASK_MAIL_ENABLED false
$ flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-1-Q01E" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-Q01E" name="Q01E" role="tabpanel" tabindex="0">
<pre data-language="text">&gt; set FLASK_SECRET_KEY="5f352379324c22463451387a0aec5d2f"
&gt; set FLASK_MAIL_ENABLED=false
&gt; flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
<div aria-labelledby="tab-1-UG93ZXJzaGVsbA==" class="sphinx-tabs-panel group-tab" hidden="true" id="panel-1-UG93ZXJzaGVsbA==" name="UG93ZXJzaGVsbA==" role="tabpanel" tabindex="0">
<pre data-language="text">&gt; $env:FLASK_SECRET_KEY = "5f352379324c22463451387a0aec5d2f"
&gt; $env:FLASK_MAIL_ENABLED = "false"
&gt; flask run
 * Running on http://127.0.0.1:5000/
</pre> </div>
</div> <p>The variables can then be loaded and accessed via the config with a key equal to the environment variable name without the prefix i.e.</p> <pre data-language="python">app.config.from_prefixed_env()
app.config["SECRET_KEY"]  # Is "5f352379324c22463451387a0aec5d2f"
</pre> <p>The prefix is <code>FLASK_</code> by default. This is configurable via the <code>prefix</code> argument of <a class="reference internal" href="../api/index.html#flask.Config.from_prefixed_env" title="flask.Config.from_prefixed_env"><code>from_prefixed_env()</code></a>.</p> <p>Values will be parsed to attempt to convert them to a more specific type than strings. By default <a class="reference external" href="https://docs.python.org/3/library/json.html#json.loads" title="(in Python v3.13)"><code>json.loads()</code></a> is used, so any valid JSON value is possible, including lists and dicts. This is configurable via the <code>loads</code> argument of <a class="reference internal" href="../api/index.html#flask.Config.from_prefixed_env" title="flask.Config.from_prefixed_env"><code>from_prefixed_env()</code></a>.</p> <p>When adding a boolean value with the default JSON parsing, only “true” and “false”, lowercase, are valid values. Keep in mind that any non-empty string is considered <code>True</code> by Python.</p> <p>It is possible to set keys in nested dictionaries by separating the keys with double underscore (<code>__</code>). Any intermediate keys that don’t exist on the parent dict will be initialized to an empty dict.</p> <pre data-language="text">$ export FLASK_MYAPI__credentials__username=user123
</pre> <pre data-language="python">app.config["MYAPI"]["credentials"]["username"]  # Is "user123"
</pre> <p>On Windows, environment variable keys are always uppercase, therefore the above example would end up as <code>MYAPI__CREDENTIALS__USERNAME</code>.</p> <p>For even more config loading features, including merging and case-insensitive Windows support, try a dedicated library such as <a class="reference external" href="https://www.dynaconf.com/">Dynaconf</a>, which includes integration with Flask.</p> </section> <section id="configuration-best-practices"> <h2>Configuration Best Practices</h2> <p>The downside with the approach mentioned earlier is that it makes testing a little harder. There is no single 100% solution for this problem in general, but there are a couple of things you can keep in mind to improve that experience:</p> <ol class="arabic simple"> <li>Create your application in a function and register blueprints on it. That way you can create multiple instances of your application with different configurations attached which makes unit testing a lot easier. You can use this to pass in configuration as needed.</li> <li>Do not write code that needs the configuration at import time. If you limit yourself to request-only accesses to the configuration you can reconfigure the object later on as needed.</li> <li>Make sure to load the configuration very early on, so that extensions can access the configuration when calling <code>init_app</code>.</li> </ol> </section> <section id="development-production"> <h2 id="config-dev-prod">Development / Production</h2> <p>Most applications need more than one configuration. There should be at least separate configurations for the production server and the one used during development. The easiest way to handle this is to use a default configuration that is always loaded and part of the version control, and a separate configuration that overrides the values as necessary as mentioned in the example above:</p> <pre data-language="python">app = Flask(__name__)
app.config.from_object('yourapplication.default_settings')
app.config.from_envvar('YOURAPPLICATION_SETTINGS')
</pre> <p>Then you just have to add a separate <code>config.py</code> file and export <code>YOURAPPLICATION_SETTINGS=/path/to/config.py</code> and you are done. However there are alternative ways as well. For example you could use imports or subclassing.</p> <p>What is very popular in the Django world is to make the import explicit in the config file by adding <code>from yourapplication.default_settings
import *</code> to the top of the file and then overriding the changes by hand. You could also inspect an environment variable like <code>YOURAPPLICATION_MODE</code> and set that to <code>production</code>, <code>development</code> etc and import different hard-coded files based on that.</p> <p>An interesting pattern is also to use classes and inheritance for configuration:</p> <pre data-language="python">class Config(object):
    TESTING = False

class ProductionConfig(Config):
    DATABASE_URI = 'mysql://user@localhost/foo'

class DevelopmentConfig(Config):
    DATABASE_URI = "sqlite:////tmp/foo.db"

class TestingConfig(Config):
    DATABASE_URI = 'sqlite:///:memory:'
    TESTING = True
</pre> <p>To enable such a config you just have to call into <a class="reference internal" href="../api/index.html#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a>:</p> <pre data-language="python">app.config.from_object('configmodule.ProductionConfig')
</pre> <p>Note that <a class="reference internal" href="../api/index.html#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a> does not instantiate the class object. If you need to instantiate the class, such as to access a property, then you must do so before calling <a class="reference internal" href="../api/index.html#flask.Config.from_object" title="flask.Config.from_object"><code>from_object()</code></a>:</p> <pre data-language="python">from configmodule import ProductionConfig
app.config.from_object(ProductionConfig())

# Alternatively, import via string:
from werkzeug.utils import import_string
cfg = import_string('configmodule.ProductionConfig')()
app.config.from_object(cfg)
</pre> <p>Instantiating the configuration object allows you to use <code>@property</code> in your configuration classes:</p> <pre data-language="python">class Config(object):
    """Base config, uses staging database server."""
    TESTING = False
    DB_SERVER = '192.168.1.56'

    @property
    def DATABASE_URI(self):  # Note: all caps
        return f"mysql://user@{self.DB_SERVER}/foo"

class ProductionConfig(Config):
    """Uses production database server."""
    DB_SERVER = '192.168.19.32'

class DevelopmentConfig(Config):
    DB_SERVER = 'localhost'

class TestingConfig(Config):
    DB_SERVER = 'localhost'
    DATABASE_URI = 'sqlite:///:memory:'
</pre> <p>There are many different ways and it’s up to you how you want to manage your configuration files. However here a list of good recommendations:</p> <ul class="simple"> <li>Keep a default configuration in version control. Either populate the config with this default configuration or import it in your own configuration files before overriding values.</li> <li>Use an environment variable to switch between the configurations. This can be done from outside the Python interpreter and makes development and deployment much easier because you can quickly and easily switch between different configs without having to touch the code at all. If you are working often on different projects you can even create your own script for sourcing that activates a virtualenv and exports the development configuration for you.</li> <li>Use a tool like <a class="reference external" href="https://www.fabfile.org/">fabric</a> to push code and configuration separately to the production server(s).</li> </ul> </section> <section id="instance-folders"> <h2 id="id1">Instance Folders</h2> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">Added in version 0.8.</span></p> </div> </details><p>Flask 0.8 introduces instance folders. Flask for a long time made it possible to refer to paths relative to the application’s folder directly (via <code>Flask.root_path</code>). This was also how many developers loaded configurations stored next to the application. Unfortunately however this only works well if applications are not packages in which case the root path refers to the contents of the package.</p> <p>With Flask 0.8 a new attribute was introduced: <code>Flask.instance_path</code>. It refers to a new concept called the “instance folder”. The instance folder is designed to not be under version control and be deployment specific. It’s the perfect place to drop things that either change at runtime or configuration files.</p> <p>You can either explicitly provide the path of the instance folder when creating the Flask application or you can let Flask autodetect the instance folder. For explicit configuration use the <code>instance_path</code> parameter:</p> <pre data-language="python">app = Flask(__name__, instance_path='/path/to/instance/folder')
</pre> <p>Please keep in mind that this path <em>must</em> be absolute when provided.</p> <p>If the <code>instance_path</code> parameter is not provided the following default locations are used:</p> <ul> <li>
<p>Uninstalled module:</p> <pre data-language="python">/myapp.py
/instance
</pre> </li> <li>
<p>Uninstalled package:</p> <pre data-language="python">/myapp
    /__init__.py
/instance
</pre> </li> <li>
<p>Installed module or package:</p> <pre data-language="python">$PREFIX/lib/pythonX.Y/site-packages/myapp
$PREFIX/var/myapp-instance
</pre> <p><code>$PREFIX</code> is the prefix of your Python installation. This can be <code>/usr</code> or the path to your virtualenv. You can print the value of <code>sys.prefix</code> to see what the prefix is set to.</p> </li> </ul> <p>Since the config object provided loading of configuration files from relative filenames we made it possible to change the loading via filenames to be relative to the instance path if wanted. The behavior of relative paths in config files can be flipped between “relative to the application root” (the default) to “relative to instance folder” via the <code>instance_relative_config</code> switch to the application constructor:</p> <pre data-language="python">app = Flask(__name__, instance_relative_config=True)
</pre> <p>Here is a full example of how to configure Flask to preload the config from a module and then override the config from a file in the instance folder if it exists:</p> <pre data-language="python">app = Flask(__name__, instance_relative_config=True)
app.config.from_object('yourapplication.default_settings')
app.config.from_pyfile('application.cfg', silent=True)
</pre> <p>The path to the instance folder can be found via the <code>Flask.instance_path</code>. Flask also provides a shortcut to open a file from the instance folder with <code>Flask.open_instance_resource()</code>.</p> <p>Example usage for both:</p> <pre data-language="python">filename = os.path.join(app.instance_path, 'application.cfg')
with open(filename) as f:
    config = f.read()

# or via open_instance_resource:
with app.open_instance_resource('application.cfg') as f:
    config = f.read()
</pre> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 Pallets<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://flask.palletsprojects.com/en/stable/config/" class="_attribution-link">https://flask.palletsprojects.com/en/stable/config/</a>
  </p>
</div>
