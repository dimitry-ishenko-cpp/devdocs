<h1 class="title">Troubleshooting common RethinkDB problems</h1> <div class="alg-content">
<h3 id="how-can-i-get-a-dump-of-the-rethinkdb-system-tables">How can I get a dump of the RethinkDB system tables?</h3> <p>This can be useful for diagnostic purposes, as well as for filing bug reports. The easiest way to do this is with ReQL administration commands. Any individual table can be examined with <code class="language-plaintext highlighter-rouge">r.db('rethinkdb').table(&lt;tablename&gt;)</code>.</p> <p>The following command will output the contents of <em>all</em> the configuration/status tables as well as the most recent 50 lines of the <code class="language-plaintext highlighter-rouge">logs</code> table:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.expr(["current_issues", "jobs", "stats", "server_config", "server_status",
"table_config", "table_status", "db_config", "cluster_config"]).map(
    [r.row, r.db('rethinkdb').table(r.row).coerceTo('array')]
).coerceTo('object').merge(
    {logs: r.db('rethinkdb').table('logs').limit(50).coerceTo('array')}
)
</pre></div></div> <p>(That command is suitable for running in the Data Explorer, but can be easily adapted into other languages.)</p> <h3 id="i-get-a-reqlresourcelimiterror-array-over-size-limit-100000-when-trying-to-order-a-table">I get a “ReqlResourceLimitError: Array over size limit 100000” when trying to order a table</h3> <p>Ordering without an index requires the server to load the whole sequence in an array, which is limited by default to 100,000 documents. You can use the <code class="language-plaintext highlighter-rouge">arrayLimit</code> option to <a href="../../api/javascript/run/index.html">run</a> to temporarily raise this limit. However, a more efficient option is to use an index. See the documentation for <a href="../../api/javascript/order_by/index.html">orderBy</a> for more information.</p> <h3 id="my-insert-queries-are-slow-how-can-i-speed-them-up">My insert queries are slow. How can I speed them up?</h3> <p>RethinkDB uses a safe default configuration for write acknowledgement. Each write is committed to disk before the server acknowledges it to the client. If you’re running a single thread that inserts documents into RethinkDB in a loop, each insert must wait for the server acknowledgement before proceeding to the next one. This can significantly slow down the overall throughput.</p> <p>This behavior is similar to any other safe database system. Below is a number of steps you can take to speed up insert performance in RethinkDB. Most of these guidelines will also apply to other database systems.</p> <p><strong>Increase concurrency.</strong> Instead of having a single thread inserting data in a loop, create multiple threads with multiple connections. This will allow parallelization of insert queries without spending most of the time waiting on disk acknowledgement.</p> <p><strong>Batch writes.</strong> Instead of doing single writes in a loop, group writes together. This can result in significant increases in throughput. Instead of doing multiple queries like this:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("foo").table("bar").insert(document_1).run()
r.db("foo").table("bar").insert(document_2).run()
r.db("foo").table("bar").insert(document_3).run()
</pre></div></div> <p>Combine them into a single query:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("foo").table("bar").insert([document_1, document_2, document_3]).run()
</pre></div></div> <p>RethinkDB operates at peak performance when the batch size is around two hundred documents.</p> <p><strong>Consider using soft durability mode.</strong> In soft durability mode RethinkDB will acknowledge the write immediately after receiving it, but before the write has been committed to disk. The server will use main memory to absorb the write, and will flush new data to disk in the background.</p> <p>This mode is <strong>not as safe</strong> as the default hard durability mode. If you’re writing using soft durability, a few seconds worth of data might be lost in case of power failure.</p> <p>You can insert data in soft durability mode as follows:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("foo").table("bar").insert(document).run(durability="soft")
</pre></div></div> <blockquote class="infobox ">
<p><strong>Note:</strong> while some data may be lost in case of power failure in soft durability mode, the RethinkDB database will not get corrupted.</p> </blockquote> <p><strong>Consider using <code class="language-plaintext highlighter-rouge">noreply</code> mode.</strong> In this mode, the client driver will not wait for the server acknowledgement of the query before moving on to the next query. This mode is even less safe than the soft durability mode, but can result in the highest performance improvement. You can run a command in a <code class="language-plaintext highlighter-rouge">noreply</code> mode as follows:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("foo").table("bar").insert(document).run(noreply=True)
</pre></div></div> <p>You can also combine soft durability and <code class="language-plaintext highlighter-rouge">noreply</code> for the highest performance:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.db("foo").table("bar").insert(document).run(durability="soft", noreply=True)
</pre></div></div> <h3 id="how-can-i-order-the-output-of-group">How can I order the output of <code class="language-plaintext highlighter-rouge">group</code>?</h3> <p>Commands chained after <code class="language-plaintext highlighter-rouge">group</code> operate on each group separately. If you want to operate on all the groups at once (e.g. to order them), you need to call <a href="https://rethinkdb.com/api/python/ungroup/"><strong>ungroup</strong></a> before doing so.</p> <h3 id="what-does-received-invalid-clustering-header-mean">What does ‘received invalid clustering header’ mean?</h3> <p>RethinkDB uses three ports to operate—the HTTP web UI port, the client drivers port, and the intracluster traffic port. You can connect the browser to the web UI port to administer the cluster right from your browser, and connect the client drivers to the client driver port to run queries from your application. If you’re running a cluster, different RethinkDB nodes communicate with each other via the intracluster traffic port.</p> <p>The message <code class="language-plaintext highlighter-rouge">received invalid clustering header</code> means there is a port mismatch, and something is connecting to the wrong port. For example, it’s common to get this message if you accidentally point the browser or connect the client drivers to the intracluster traffic port.</p> <h3 id="does-the-web-ui-support-my-browser">Does the web UI support my browser?</h3> <p>The following browsers are supported and known to work with the web UI:</p> <ul> <li>Chrome 9 or higher</li> <li>Firefox 15 or higher</li> <li>Safari 6.02 or higher</li> <li>Opera 1.62 or higher</li> </ul> <blockquote class="infobox ">
<p>The web UI requires <code class="language-plaintext highlighter-rouge">DataView</code> and <code class="language-plaintext highlighter-rouge">Uint8Array</code> JavaScript features to be supported by your browser.</p> </blockquote> <h3 id="which-versions-of-nodejs-are-supported">Which versions of Node.js are supported?</h3> <p>The JavaScript driver currently works with Node.js versions 0.10.0 and above. You can check your node version as follows:</p> <p><code class="language-plaintext highlighter-rouge">node --version</code></p> <p>You can upgrade your version of Node.js via <code class="language-plaintext highlighter-rouge">npm</code>:</p> <p><code class="language-plaintext highlighter-rouge">sudo npm install -g n</code></p> <p>If you’re trying to run the RethinkDB JavaScript driver on an older version of Node.js, you might get an error similar to this one:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">/home/user/rethinkdb.js:13727
return buffer.slice(offset, end);
             ^
TypeError: Object #&lt;ArrayBuffer&gt; has no method 'slice'
at bufferSlice (/home/user/rethinkdb.js:13727:17)
at Socket.TcpConnection.rawSocket.once.handshake_callback (/home/user/rethinkdb.js:13552:26)
</pre></div></div> <h3 id="i-get-back-a-connection-in-my-callback-with-the-node-driver">I get back a connection in my callback with the Node driver</h3> <p>Many people have been reporting that they get back a connection object when they run a query, the object being:</p> <div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{
    _conn: {
        host: 'localhost',
        port: 28015,
        db: undefined,
        authKey: '',
        timeout: 20,
        outstandingCallbacks: {},
        nextToken: 2,
        open: true,
        buffer: &lt;Buffer 04 00 00 00 08 02 10 01&gt;,
        _events: {},
        rawSocket: { ... }
    },
    _token: 1,
    _chunks: [],
    _endFlag: true,
    _contFlag: true,
    _cont: null,
    _cbQueue: []
}
</pre></div></div> <p>This object is not a connection, but a cursor. To retrieve the results, you can call <code class="language-plaintext highlighter-rouge">next</code>, <code class="language-plaintext highlighter-rouge">each</code> or <code class="language-plaintext highlighter-rouge">toArray</code> on this object.</p> <p>For example you can retrieve all the results and put them in an array with <code class="language-plaintext highlighter-rouge">toArray</code>:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table("test").run( conn, function(error, cursor) {
    cursor.toArray( function(error, results) {
        console.log(results) // results is an array of documents
    })
})
</pre></div></div> <h3 id="rethinkdb-is-running-out-of-memory">RethinkDB is running out of memory</h3> <p>You may need to adjust RethinkDB’s page cache size, using the <code class="language-plaintext highlighter-rouge">--cache-size</code> argument or configuration file option. Read “<a href="../memory-usage/index.html">Understanding RethinkDB memory requirements</a>” for a more detailed explanation of how RethinkDB uses memory and how to tune its performance.</p> <p>If you’re running RethinkDB on Linux and see a “Data from a process on this server has been placed into swap memory” warning in the <a href="../system-issues/index.html#memory-availability-issues">System issues table</a> even though your server has RAM available, it’s possible you need to adjust the <code class="language-plaintext highlighter-rouge">swappiness</code> kernel parameter. A swappiness setting of 0 prevents swap space from being used unless the server is completely out of physical memory; a setting of 100 uses swap space all the time. To check the swappiness of your kernel:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">$ cat /proc/sys/vm/swappiness
60
</pre></div></div> <p>A setting of 60 (the default for Ubuntu) means that your system will start using swap when RAM usage is at about 40%. If you’d like this to be closer to 90%, set the swappiness to 10. You can do that by editing the <code class="language-plaintext highlighter-rouge">/etc/sysctl.conf</code> file (as root) and change the setting there:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">vm.swappiness = 10
</pre></div></div> <p>This change won’t take effect until you reboot. You can change it while the system is still running, also:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">$ sysctl vm.swappiness=10
$ swapoff -a
$ swapon -a
</pre></div></div> <h3 id="i-get-incorrect-results-when-i-pass-functions-with-iffor-statements-to-reql">I get incorrect results when I pass functions with if/for statements to ReQL</h3> <p>When you pass functions to ReQL, your language’s driver serializes those functions into ReQL lambda functions that are run on the server, not in your client language. (See <a href="https://rethinkdb.com/blog/lambda-functions/">All about lambda functions in RethinkDB queries</a> for more details.) A consequence of this is that native language constructs like <code class="language-plaintext highlighter-rouge">if</code> and <code class="language-plaintext highlighter-rouge">for</code> will not produce the expected result when their conditions involve ReQL commands. While they may not cause errors, they will be executed on the client side before the function is compiled for ReQL, and thus give an incorrect result. Instead, you must use equivalent ReQL control functions such as <a href="../../api/javascript/branch/index.html">branch</a> and <a href="../../api/javascript/for_each/index.html">forEach</a>. Here’s an example in Python from the <a href="../introduction-to-reql/index.html">Introduction to ReQL</a> document:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language=""># WRONG: Get all users older than 30 using the `if` statement
r.table('users').filter(lambda user:
    True if user['age'] &gt; 30 else False
).run(conn)

# RIGHT: Get all users older than 30 using the `r.branch` command
r.table('users').filter(lambda user:
    r.branch(user['age'] &gt; 30, True, False)
).run(conn)
</pre></div></div> <p>And an equivalent example in JavaScript:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">// WRONG: Get all users older than 30 using the ternary operator
r.table('users').filter(function(user) {
    return (r.row('age').gt(30) ? true : false);
}).run(conn, callback)

// RIGHT: Get all users older than 30 using the `r.branch` command
r.table('users').filter(function(user) {
    r.branch(user('age').gt(30), true, false)
}).run(conn, callback)
</pre></div></div> <p>(Note we must use <code class="language-plaintext highlighter-rouge">gt</code> instead of the native <code class="language-plaintext highlighter-rouge">&gt;</code> operator in JavaScript, for the same reason. In Python the <code class="language-plaintext highlighter-rouge">&gt;</code> operator is <a href="https://docs.python.org/2/reference/datamodel.html#special-method-names">overloaded</a> to be translated to ReQL’s <code class="language-plaintext highlighter-rouge">gt</code> command, a trick that is not possible in JavaScript.)</p> <h3 id="how-do-i-specify-an-external-canonical-ip-address-of-a-rethinkdb-node">How do I specify an external canonical IP address of a RethinkDB node?</h3> <p>When a RethinkDB node starts, it will broadcast its “canonical” IP address, the address other nodes should use to connect to it. By default, the canonical address is the server’s primary IP address. However, if this address is an internal IP address that isn’t reachable by other nodes (for example, the nodes are on different networks), the nodes will not be able to reach one another. You may receive an error message such as:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">error: received inconsistent routing information (wrong address) from xxx.xxx.xxx.xxx (expected_address = peer_address{ips=[xxx.xxx.xxx.xxx], port=29015}, other_address = peer_address{ips=[xxx.xxx.xxx.xxx], port=29015}), closing connection
</pre></div></div> <p>To solve this, specify the canonical address explicitly by using the <code class="language-plaintext highlighter-rouge">--canonical-address</code> argument.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">rethinkdb --canonical-address &lt;external IP&gt;
</pre></div></div> <p>This may also be specified in the <a href="http://rethinkdb.com/docs/cluster-on-startup/">config file</a>.</p> <h3 id="my-secondary-index-is-outdated">My secondary index is outdated</h3> <p>You may receive a warning message about secondary indexes on startup being “outdated” when you upgrade RethinkDB versions.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">warn: Namespace &lt;x&gt; contains these outdated indexes which should be recreated:
&lt;index names&gt;
</pre></div></div> <p>(This may happen, for instance, between v1.13 and v1.14, when the internal format of secondary indexes changed.) Outdated indexes can still be used—they don’t affect availability. However, you should rebuild your index before updating to the next version of RethinkDB.</p> <p>You may rebuild indexes with the <code class="language-plaintext highlighter-rouge">rethinkdb</code> command line utility:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">rethinkdb index-rebuild [-c HOST:PORT] [-r (DB|DB.TABLE)] [-n CONCURRENT_REBUILDS]
</pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">-c</code> and <code class="language-plaintext highlighter-rouge">-r</code> options are similar to other <code class="language-plaintext highlighter-rouge">rethinkdb</code> options, specifying the cluster host and port (defaulting to <code class="language-plaintext highlighter-rouge">localhost:28015</code>) and either a database or a table to rebuild. The <code class="language-plaintext highlighter-rouge">-n</code> option specifies the number of rebuilds that will be performed concurrently (defaulting to 1).</p> <p>You may also rebuild indexes manually in ReQL:</p> <ul> <li>Use <a href="https://rethinkdb.com/api/python/index_status/">index_status</a> to retrieve a binary representation of the existing secondary index (whether it is simple, compound, multi, or based on an expression)</li> <li>Create a new index using <a href="https://rethinkdb.com/api/python/index_create/">index_create</a>
</li> <li>Rename the new index to the old index’s name with <a href="https://rethinkdb.com/api/python/index_rename">index_rename</a>.</li> </ul> <p>A simple example in Python:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">old_index = r.table('posts').index_status('old_index').nth(0)['function'].run(conn)
r.table('posts').index_create('new_index', old_index).run(conn)
r.table('posts').index_wait('new_index').run(conn)
r.table('posts').index_rename('new_index', 'old_index', overwrite=True).run(conn)
</pre></div></div> <p>(The same example can be found in <code class="language-plaintext highlighter-rouge">index_create</code> for both <a href="https://rethinkdb.com/api/ruby/index_create">Ruby</a> and <a href="../../api/javascript/index_create/index.html">JavaScript</a>.)</p> <h3 id="how-do-i-store-a-ruby-datetime-object-in-rethinkdb">How do I store a Ruby DateTime object in RethinkDB?</h3> <p>The short answer: you can’t. Use <code class="language-plaintext highlighter-rouge">Time</code> objects instead.</p> <p>The slightly longer answer: there’s only one native <code class="language-plaintext highlighter-rouge">time</code> data type in RethinkDB. When a language supports more than one kind of date/time object, we think it’s better to explicitly support one and only one of them in the client driver to avoid confusion. Otherwise, you might insert a <code class="language-plaintext highlighter-rouge">DateTime</code> object and get a <code class="language-plaintext highlighter-rouge">Time</code> object back.</p> <p>You can use Ruby’s <code class="language-plaintext highlighter-rouge">DateTime.to_time</code> and <code class="language-plaintext highlighter-rouge">Time.to_datetime</code> methods to easily convert between one and the other.</p> <h3 id="filters-with-or-return-incorrectunexpected-results">Filters with <code class="language-plaintext highlighter-rouge">or</code> return incorrect/unexpected results</h3> <p>You might want to use <code class="language-plaintext highlighter-rouge">filter</code> to return documents that have one of two (or more) optional fields set, such as the following:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('posts').filter(
    r.row('category').eq('article').or(r.row('genre').eq('mystery'))
).run(conn, callback);
</pre></div></div> <p>However, if any document in the <code class="language-plaintext highlighter-rouge">posts</code> table above lacks a <code class="language-plaintext highlighter-rouge">category</code> field, it won’t be included in the result set even if it has a <code class="language-plaintext highlighter-rouge">genre</code> field whose value is <code class="language-plaintext highlighter-rouge">'mystery'</code>. The problem isn’t the <code class="language-plaintext highlighter-rouge">or</code> command; it’s that the invocation of <code class="language-plaintext highlighter-rouge">r.row('category')</code> on a document without that field returns an error, and the rest of the filter predicate isn’t evaluated.</p> <p>The solution is to add a <code class="language-plaintext highlighter-rouge">default</code> to the <code class="language-plaintext highlighter-rouge">row</code> command that always evaluates to something other than what you’re testing for, so it will return <code class="language-plaintext highlighter-rouge">false</code> if the field doesn’t exist:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('posts').filter(
    r.row('category').default('foo').eq('article').
    or(r.row('genre').default('foo').eq('mystery'))
).run(conn, callback);
</pre></div></div> <h3 id="nesting-depth-limit-exceeded-error">“Nesting depth limit exceeded” error</h3> <p>Typically, this indicates that a JSON object with subdocuments is too deeply nested:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">{ "level": 1,
  "data": {
    "level": 2,
    "data": {
      "level": 3,
      "data": {
        "level": 4
      }
    }
  }
}
</pre></div></div> <p>ReQL’s nesting depth is limited to 20 levels. This can be changed with the undocumented <code class="language-plaintext highlighter-rouge">nestingDepth</code> (or <code class="language-plaintext highlighter-rouge">nesting_depth</code>) option to <code class="language-plaintext highlighter-rouge">r.expr()</code>, but before using that, consider whether the document can be reorganized to avoid the error.</p> <p>It’s also possible for this error to be caused by a circular reference, where a document inadvertently contains itself:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">user1 = { id: 1, name: 'Bob' };
user2 = { id: 2, name: 'Agatha' };
user1['friends'] = [ user1, user2 ];
</pre></div></div> <p>Trying to access <code class="language-plaintext highlighter-rouge">user1</code> in ReQL will cause a nesting depth error.</p> <p>Depending on the driver, this error may also appear as “Maximum expression depth exceeded.”</p> <h3 id="rqltzinfo-object-is-not-json-serializable-error">“RqlTzinfo object is not JSON serializable” error</h3> <p>If you try to serialize a document containing a ReQL time zone object using Python’s <code class="language-plaintext highlighter-rouge">json</code> library, you may receive this error. Solve this by passing the <code class="language-plaintext highlighter-rouge">time_format="raw"</code> option to <code class="language-plaintext highlighter-rouge">run</code>:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">import json
today = r.expr(datetime.datetime.now(timezone('US/Pacific'))).run(conn,
    time_format="raw")
json.dumps(today)

'{"timezone": "-07:00", "$reql_type$": "TIME", "epoch_time": 1433368112.289}'
</pre></div></div> <h3 id="cannot-use-rrow-in-nested-queries-error">“Cannot use r.row in nested queries” error</h3> <p>The JavaScript and Python drivers support a convenience command, <code class="language-plaintext highlighter-rouge">row()</code>, which simply returns the currently selected document for use with other ReQL functions in the query. However, <code class="language-plaintext highlighter-rouge">row</code> won’t work within nested queries. The solution to this error is to rewrite the <code class="language-plaintext highlighter-rouge">row</code> clause as an anonymous function. So the following:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').filter(
    r.row['name'] == r.table('prizes').get('winner')
).run(conn)
</pre></div></div> <p>Can be rewritten with this function instead:</p> <div class="language-py highlighter-rouge"><div class="highlight"><pre class="highlight" data-language="">r.table('users').filter(
    lambda doc: doc['name'] == r.table('prizes').get('winner')
).run(conn)
</pre></div></div> <p>Any query, nested or otherwise, can be written with an anonymous function instead of <code class="language-plaintext highlighter-rouge">row</code>. (The official Ruby and Java drivers don’t include <code class="language-plaintext highlighter-rouge">row</code> at all.)</p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; RethinkDB contributors<br>Licensed under the Creative Commons Attribution-ShareAlike 3.0 Unported License.<br>
    <a href="https://rethinkdb.com/docs/troubleshooting/" class="_attribution-link">https://rethinkdb.com/docs/troubleshooting/</a>
  </p>
</div>
