<h1 id="schemaeditor">SchemaEditor</h1> <dl class="py class" id="s-module-django.db.backends.base.schema"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor">
<code>class BaseDatabaseSchemaEditor</code> </dt> 
</dl> <p>Django’s migration system is split into two parts; the logic for calculating and storing what operations should be run (<code>django.db.migrations</code>), and the database abstraction layer that turns things like “create a model” or “delete a field” into SQL - which is the job of the <code>SchemaEditor</code>.</p> <p>It’s unlikely that you will want to interact directly with <code>SchemaEditor</code> as a normal developer using Django, but if you want to write your own migration system, or have more advanced needs, it’s a lot nicer than writing SQL.</p> <p>Each database backend in Django supplies its own version of <code>SchemaEditor</code>, and it’s always accessible via the <code>connection.schema_editor()</code> context manager:</p> <pre data-language="python">with connection.schema_editor() as schema_editor:
    schema_editor.delete_model(MyModel)
</pre> <p>It must be used via the context manager as this allows it to manage things like transactions and deferred SQL (like creating <code>ForeignKey</code> constraints).</p> <p>It exposes all possible operations as methods, that should be called in the order you wish changes to be applied. Some possible operations or types of change are not possible on all databases - for example, MyISAM does not support foreign key constraints.</p> <p>If you are writing or maintaining a third-party database backend for Django, you will need to provide a <code>SchemaEditor</code> implementation in order to work with Django’s migration functionality - however, as long as your database is relatively standard in its use of SQL and relational design, you should be able to subclass one of the built-in Django <code>SchemaEditor</code> classes and tweak the syntax a little.</p>  <h2 id="methods">Methods</h2>  <h3 id="execute"><code>execute()</code></h3> <dl class="py method" id="s-methods"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.execute">
<code>BaseDatabaseSchemaEditor.execute(sql, params=())</code> </dt> 
</dl> <p>Executes the SQL statement passed in, with parameters if supplied. This is a wrapper around the normal database cursors that allows capture of the SQL to a <code>.sql</code> file if the user wishes.</p>   <h3 id="create-model"><code>create_model()</code></h3> <dl class="py method" id="s-create-model"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.create_model">
<code>BaseDatabaseSchemaEditor.create_model(model)</code> </dt> 
</dl> <p>Creates a new table in the database for the provided model, along with any unique constraints or indexes it requires.</p>   <h3 id="delete-model"><code>delete_model()</code></h3> <dl class="py method" id="s-delete-model"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.delete_model">
<code>BaseDatabaseSchemaEditor.delete_model(model)</code> </dt> 
</dl> <p>Drops the model’s table in the database along with any unique constraints or indexes it has.</p>   <h3 id="add-index"><code>add_index()</code></h3> <dl class="py method" id="s-add-index"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.add_index">
<code>BaseDatabaseSchemaEditor.add_index(model, index)</code> </dt> 
</dl> <p>Adds <code>index</code> to <code>model</code>’s table.</p>   <h3 id="remove-index"><code>remove_index()</code></h3> <dl class="py method" id="s-remove-index"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.remove_index">
<code>BaseDatabaseSchemaEditor.remove_index(model, index)</code> </dt> 
</dl> <p>Removes <code>index</code> from <code>model</code>’s table.</p>   <h3 id="rename-index"><code>rename_index()</code></h3> <dl class="py method" id="s-rename-index"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.rename_index">
<code>BaseDatabaseSchemaEditor.rename_index(model, old_index, new_index)</code> </dt> 
</dl> <p>Renames <code>old_index</code> from <code>model</code>’s table to <code>new_index</code>.</p>   <h3 id="add-constraint"><code>add_constraint()</code></h3> <dl class="py method" id="s-add-constraint"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.add_constraint">
<code>BaseDatabaseSchemaEditor.add_constraint(model, constraint)</code> </dt> 
</dl> <p>Adds <code>constraint</code> to <code>model</code>’s table.</p>   <h3 id="remove-constraint"><code>remove_constraint()</code></h3> <dl class="py method" id="s-remove-constraint"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.remove_constraint">
<code>BaseDatabaseSchemaEditor.remove_constraint(model, constraint)</code> </dt> 
</dl> <p>Removes <code>constraint</code> from <code>model</code>’s table.</p>   <h3 id="alter-unique-together"><code>alter_unique_together()</code></h3> <dl class="py method" id="s-alter-unique-together"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_unique_together">
<code>BaseDatabaseSchemaEditor.alter_unique_together(model, old_unique_together, new_unique_together)</code> </dt> 
</dl> <p>Changes a model’s <a class="reference internal" href="models/options.html#django.db.models.Options.unique_together" title="django.db.models.Options.unique_together"><code>unique_together</code></a> value; this will add or remove unique constraints from the model’s table until they match the new value.</p>   <h3 id="alter-index-together"><code>alter_index_together()</code></h3> <dl class="py method" id="s-alter-index-together"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_index_together">
<code>BaseDatabaseSchemaEditor.alter_index_together(model, old_index_together, new_index_together)</code> </dt> 
</dl> <p>Changes a model’s <a class="reference internal" href="models/options.html#django.db.models.Options.index_together" title="django.db.models.Options.index_together"><code>index_together</code></a> value; this will add or remove indexes from the model’s table until they match the new value.</p>   <h3 id="alter-db-table"><code>alter_db_table()</code></h3> <dl class="py method" id="s-alter-db-table"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_db_table">
<code>BaseDatabaseSchemaEditor.alter_db_table(model, old_db_table, new_db_table)</code> </dt> 
</dl> <p>Renames the model’s table from <code>old_db_table</code> to <code>new_db_table</code>.</p>   <h3 id="alter-db-table-comment"><code>alter_db_table_comment()</code></h3> <div class="versionadded" id="s-alter-db-table-comment"> <span class="title">New in Django 4.2.</span> </div> <dl class="py method"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_db_table_comment">
<code>BaseDatabaseSchemaEditor.alter_db_table_comment(model, old_db_table_comment, new_db_table_comment)</code> </dt> 
</dl> <p>Change the <code>model</code>’s table comment to <code>new_db_table_comment</code>.</p>   <h3 id="alter-db-tablespace"><code>alter_db_tablespace()</code></h3> <dl class="py method" id="s-alter-db-tablespace"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_db_tablespace">
<code>BaseDatabaseSchemaEditor.alter_db_tablespace(model, old_db_tablespace, new_db_tablespace)</code> </dt> 
</dl> <p>Moves the model’s table from one tablespace to another.</p>   <h3 id="add-field"><code>add_field()</code></h3> <dl class="py method" id="s-add-field"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.add_field">
<code>BaseDatabaseSchemaEditor.add_field(model, field)</code> </dt> 
</dl> <p>Adds a column (or sometimes multiple) to the model’s table to represent the field. This will also add indexes or a unique constraint if the field has <code>db_index=True</code> or <code>unique=True</code>.</p> <p>If the field is a <code>ManyToManyField</code> without a value for <code>through</code>, instead of creating a column, it will make a table to represent the relationship. If <code>through</code> is provided, it is a no-op.</p> <p>If the field is a <code>ForeignKey</code>, this will also add the foreign key constraint to the column.</p>   <h3 id="remove-field"><code>remove_field()</code></h3> <dl class="py method" id="s-remove-field"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.remove_field">
<code>BaseDatabaseSchemaEditor.remove_field(model, field)</code> </dt> 
</dl> <p>Removes the column(s) representing the field from the model’s table, along with any unique constraints, foreign key constraints, or indexes caused by that field.</p> <p>If the field is a ManyToManyField without a value for <code>through</code>, it will remove the table created to track the relationship. If <code>through</code> is provided, it is a no-op.</p>   <h3 id="alter-field"><code>alter_field()</code></h3> <dl class="py method" id="s-alter-field"> <dt class="sig sig-object py" id="django.db.backends.base.schema.BaseDatabaseSchemaEditor.alter_field">
<code>BaseDatabaseSchemaEditor.alter_field(model, old_field, new_field, strict=False)</code> </dt> 
</dl> <p>This transforms the field on the model from the old field to the new one. This includes changing the name of the column (the <a class="reference internal" href="models/fields.html#django.db.models.Field.db_column" title="django.db.models.Field.db_column"><code>db_column</code></a> attribute), changing the type of the field (if the field class changes), changing the <code>NULL</code> status of the field, adding or removing field-only unique constraints and indexes, changing primary key, and changing the destination of <code>ForeignKey</code> constraints.</p> <p>The most common transformation this cannot do is transforming a <code>ManyToManyField</code> into a normal Field or vice-versa; Django cannot do this without losing data, and so it will refuse to do it. Instead, <a class="reference internal" href="#django.db.backends.base.schema.BaseDatabaseSchemaEditor.remove_field" title="django.db.backends.base.schema.BaseDatabaseSchemaEditor.remove_field"><code>remove_field()</code></a> and <a class="reference internal" href="#django.db.backends.base.schema.BaseDatabaseSchemaEditor.add_field" title="django.db.backends.base.schema.BaseDatabaseSchemaEditor.add_field"><code>add_field()</code></a> should be called separately.</p> <p>If the database has the <code>supports_combined_alters</code>, Django will try and do as many of these in a single database call as possible; otherwise, it will issue a separate ALTER statement for each change, but will not issue ALTERs where no change is required.</p>    <h2 id="attributes">Attributes</h2> <p id="s-attributes">All attributes should be considered read-only unless stated otherwise.</p>  <h3 id="connection"><code>connection</code></h3> <dl class="py attribute" id="s-connection"> <dt class="sig sig-object py" id="django.db.backends.base.schema.SchemaEditor.connection">
<code>SchemaEditor.connection</code> </dt> 
</dl> <p>A connection object to the database. A useful attribute of the connection is <code>alias</code> which can be used to determine the name of the database being accessed.</p> <p>This is useful when doing data migrations for <a class="reference internal" href="../howto/writing-migrations.html#data-migrations-and-multiple-databases"><span class="std std-ref">migrations with multiple databases</span></a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.0/ref/schema-editor/" class="_attribution-link">https://docs.djangoproject.com/en/5.0/ref/schema-editor/</a>
  </p>
</div>
