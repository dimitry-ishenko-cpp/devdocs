<section id="s-module-django.urls.conf"> <h1 id="django-urls-functions-for-use-in-urlconfs">django.urls functions for use in URLconfs</h1> <section id="s-path"> <h2 id="path"><code>path()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.urls.path">
<code>path(route, view, kwargs=None, name=None)</code> </dt> 
</dl> <p>Returns an element for inclusion in <code>urlpatterns</code>. For example:</p> <pre data-language="python">from django.urls import include, path

urlpatterns = [
    path("index/", views.index, name="main-view"),
    path("bio/&lt;username&gt;/", views.bio, name="bio"),
    path("articles/&lt;slug:title&gt;/", views.article, name="article-detail"),
    path("articles/&lt;slug:title&gt;/&lt;int:section&gt;/", views.section, name="article-section"),
    path("blog/", include("blog.urls")),
    ...,
]
</pre> <section id="s-route"> <h3 id="route"><code>route</code></h3> <p>The <code>route</code> argument should be a string or <a class="reference internal" href="utils.html#django.utils.translation.gettext_lazy" title="django.utils.translation.gettext_lazy"><code>gettext_lazy()</code></a> (see <a class="reference internal" href="../topics/i18n/translation.html#translating-urlpatterns"><span class="std std-ref">Translating URL patterns</span></a>) that contains a URL pattern. The string may contain angle brackets (like <code>&lt;username&gt;</code> above) to capture part of the URL and send it as a keyword argument to the view. The angle brackets may include a converter specification (like the <code>int</code> part of <code>&lt;int:section&gt;</code>) which limits the characters matched and may also change the type of the variable passed to the view. For example, <code>&lt;int:section&gt;</code> matches a string of decimal digits and converts the value to an <code>int</code>.</p> <p>When processing a request, Django starts at the first pattern in <code>urlpatterns</code> and makes its way down the list, comparing the requested URL against each pattern until it finds one that matches. See <a class="reference internal" href="../topics/http/urls.html#how-django-processes-a-request"><span class="std std-ref">How Django processes a request</span></a> for more details.</p> <p>Patterns don’t match GET and POST parameters, or the domain name. For example, in a request to <code>https://www.example.com/myapp/</code>, the URLconf will look for <code>myapp/</code>. In a request to <code>https://www.example.com/myapp/?page=3</code>, the URLconf will also look for <code>myapp/</code>.</p> </section> <section id="s-view"> <h3 id="view"><code>view</code></h3> <p>The <code>view</code> argument is a view function or the result of <a class="reference internal" href="class-based-views/base.html#django.views.generic.base.View.as_view" title="django.views.generic.base.View.as_view"><code>as_view()</code></a> for class-based views. It can also be a <a class="reference internal" href="#django.urls.include" title="django.urls.include"><code>django.urls.include()</code></a>.</p> <p>When Django finds a matching pattern, it calls the specified view function with an <a class="reference internal" href="request-response.html#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object as the first argument and any “captured” values from the route as keyword arguments.</p> </section> <section id="s-kwargs"> <h3 id="kwargs"><code>kwargs</code></h3> <p>The <code>kwargs</code> argument allows you to pass additional arguments to the view function or method. See <a class="reference internal" href="../topics/http/urls.html#views-extra-options"><span class="std std-ref">Passing extra options to view functions</span></a> for an example.</p> </section> <section id="s-name"> <h3 id="name"><code>name</code></h3> <p>Naming your URL lets you refer to it unambiguously from elsewhere in Django, especially from within templates. This powerful feature allows you to make global changes to the URL patterns of your project while only touching a single file.</p> <p>See <a class="reference internal" href="../topics/http/urls.html#naming-url-patterns"><span class="std std-ref">Naming URL patterns</span></a> for why the <code>name</code> argument is useful.</p> </section> </section> <section id="s-re-path"> <h2 id="re-path"><code>re_path()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.urls.re_path">
<code>re_path(route, view, kwargs=None, name=None)</code> </dt> 
</dl> <p>Returns an element for inclusion in <code>urlpatterns</code>. For example:</p> <pre data-language="python">from django.urls import include, re_path

urlpatterns = [
    re_path(r"^index/$", views.index, name="index"),
    re_path(r"^bio/(?P&lt;username&gt;\w+)/$", views.bio, name="bio"),
    re_path(r"^blog/", include("blog.urls")),
    ...,
]
</pre> <p>The <code>route</code> argument should be a string or <a class="reference internal" href="utils.html#django.utils.translation.gettext_lazy" title="django.utils.translation.gettext_lazy"><code>gettext_lazy()</code></a> (see <a class="reference internal" href="../topics/i18n/translation.html#translating-urlpatterns"><span class="std std-ref">Translating URL patterns</span></a>) that contains a regular expression compatible with Python’s <a class="reference external" href="https://docs.python.org/3/library/re.html#module-re" title="(in Python v3.13)"><code>re</code></a> module. Strings typically use raw string syntax (<code>r''</code>) so that they can contain sequences like <code>\d</code> without the need to escape the backslash with another backslash. When a match is made, captured groups from the regular expression are passed to the view – as named arguments if the groups are named, and as positional arguments otherwise. The values are passed as strings, without any type conversion.</p> <p>When a <code>route</code> ends with <code>$</code> the whole requested URL, matching against <a class="reference internal" href="request-response.html#django.http.HttpRequest.path_info" title="django.http.HttpRequest.path_info"><code>path_info</code></a>, must match the regular expression pattern (<a class="reference external" href="https://docs.python.org/3/library/re.html#re.fullmatch" title="(in Python v3.13)"><code>re.fullmatch()</code></a> is used).</p> <p>The <code>view</code>, <code>kwargs</code> and <code>name</code> arguments are the same as for <a class="reference internal" href="#django.urls.path" title="django.urls.path"><code>path()</code></a>.</p> </section> <section id="s-include"> <h2 id="include"><code>include()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.urls.include">
<code>include(module, namespace=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/urls/conf.py#L17"><span class="viewcode-link">[source]</span></a>
</dt> <dt class="sig sig-object py"> <span class="sig-name descname">include</span>(<em class="sig-param"><span class="n">pattern_list</span></em>)</dt> <dt class="sig sig-object py"> <span class="sig-name descname">include</span>(<em class="sig-param"><span class="n">(pattern_list</span></em>, <em class="sig-param"><span class="n">app_namespace)</span></em>, <em class="sig-param"><span class="n">namespace=None</span></em>)</dt> <dd>
<p>A function that takes a full Python import path to another URLconf module that should be “included” in this place. Optionally, the <a class="reference internal" href="../topics/http/urls.html#term-application-namespace"><span class="xref std std-term">application namespace</span></a> and <a class="reference internal" href="../topics/http/urls.html#term-instance-namespace"><span class="xref std std-term">instance namespace</span></a> where the entries will be included into can also be specified.</p> <p>Usually, the application namespace should be specified by the included module. If an application namespace is set, the <code>namespace</code> argument can be used to set a different instance namespace.</p> <p><code>include()</code> also accepts as an argument either an iterable that returns URL patterns or a 2-tuple containing such iterable plus the names of the application namespaces.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>
<strong>module</strong> – URLconf module (or module name)</li> <li>
<strong>namespace</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a>) – Instance namespace for the URL entries being included</li> <li>
<strong>pattern_list</strong> – Iterable of <a class="reference internal" href="#django.urls.path" title="django.urls.path"><code>path()</code></a> and/or <a class="reference internal" href="#django.urls.re_path" title="django.urls.re_path"><code>re_path()</code></a> instances.</li> <li>
<strong>app_namespace</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.13)">str</a>) – Application namespace for the URL entries being included</li> </ul> </dd> </dl> </dd>
</dl> <p>See <a class="reference internal" href="../topics/http/urls.html#including-other-urlconfs"><span class="std std-ref">Including other URLconfs</span></a> and <a class="reference internal" href="../topics/http/urls.html#namespaces-and-include"><span class="std std-ref">URL namespaces and included URLconfs</span></a>.</p> </section> <section id="s-register-converter"> <h2 id="register-converter"><code>register_converter()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.urls.register_converter">
<code>register_converter(converter, type_name)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/urls/converters.py#L58"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>The function for registering a converter for use in <a class="reference internal" href="#django.urls.path" title="django.urls.path"><code>path()</code></a> <code>route</code>s.</p> <p>The <code>converter</code> argument is a converter class, and <code>type_name</code> is the converter name to use in path patterns. See <a class="reference internal" href="../topics/http/urls.html#registering-custom-path-converters"><span class="std std-ref">Registering custom path converters</span></a> for an example.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 5.1: </span>Overriding existing converters is deprecated.</p> </div> </section> </section> <section id="s-module-django.conf.urls"> <h1 id="django-conf-urls-functions-for-use-in-urlconfs">django.conf.urls functions for use in URLconfs</h1> <section id="s-static"> <h2 id="static"><code>static()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.conf.urls.static.static">
<code>static.static(prefix, view=django.views.static.serve, **kwargs)</code> </dt> 
</dl> <p>Helper function to return a URL pattern for serving files in debug mode:</p> <pre data-language="python">from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # ... the rest of your URLconf goes here ...
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
</pre> </section> <section id="s-handler400"> <h2 id="handler400"><code>handler400</code></h2> <dl class="py data"> <dt class="sig sig-object py" id="django.conf.urls.handler400">
<code>handler400</code> </dt> 
</dl> <p>A callable, or a string representing the full Python import path to the view that should be called if the HTTP client has sent a request that caused an error condition and a response with a status code of 400.</p> <p>By default, this is <a class="reference internal" href="views.html#django.views.defaults.bad_request" title="django.views.defaults.bad_request"><code>django.views.defaults.bad_request()</code></a>. If you implement a custom view, be sure it accepts <code>request</code> and <code>exception</code> arguments and returns an <a class="reference internal" href="request-response.html#django.http.HttpResponseBadRequest" title="django.http.HttpResponseBadRequest"><code>HttpResponseBadRequest</code></a>.</p> </section> <section id="s-handler403"> <h2 id="handler403"><code>handler403</code></h2> <dl class="py data"> <dt class="sig sig-object py" id="django.conf.urls.handler403">
<code>handler403</code> </dt> 
</dl> <p>A callable, or a string representing the full Python import path to the view that should be called if the user doesn’t have the permissions required to access a resource.</p> <p>By default, this is <a class="reference internal" href="views.html#django.views.defaults.permission_denied" title="django.views.defaults.permission_denied"><code>django.views.defaults.permission_denied()</code></a>. If you implement a custom view, be sure it accepts <code>request</code> and <code>exception</code> arguments and returns an <a class="reference internal" href="request-response.html#django.http.HttpResponseForbidden" title="django.http.HttpResponseForbidden"><code>HttpResponseForbidden</code></a>.</p> </section> <section id="s-handler404"> <h2 id="handler404"><code>handler404</code></h2> <dl class="py data"> <dt class="sig sig-object py" id="django.conf.urls.handler404">
<code>handler404</code> </dt> 
</dl> <p>A callable, or a string representing the full Python import path to the view that should be called if none of the URL patterns match.</p> <p>By default, this is <a class="reference internal" href="views.html#django.views.defaults.page_not_found" title="django.views.defaults.page_not_found"><code>django.views.defaults.page_not_found()</code></a>. If you implement a custom view, be sure it accepts <code>request</code> and <code>exception</code> arguments and returns an <a class="reference internal" href="request-response.html#django.http.HttpResponseNotFound" title="django.http.HttpResponseNotFound"><code>HttpResponseNotFound</code></a>.</p> </section> <section id="s-handler500"> <h2 id="handler500"><code>handler500</code></h2> <dl class="py data"> <dt class="sig sig-object py" id="django.conf.urls.handler500">
<code>handler500</code> </dt> 
</dl> <p>A callable, or a string representing the full Python import path to the view that should be called in case of server errors. Server errors happen when you have runtime errors in view code.</p> <p>By default, this is <a class="reference internal" href="views.html#django.views.defaults.server_error" title="django.views.defaults.server_error"><code>django.views.defaults.server_error()</code></a>. If you implement a custom view, be sure it accepts a <code>request</code> argument and returns an <a class="reference internal" href="request-response.html#django.http.HttpResponseServerError" title="django.http.HttpResponseServerError"><code>HttpResponseServerError</code></a>.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/ref/urls/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/ref/urls/</a>
  </p>
</div>
