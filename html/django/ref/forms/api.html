<section id="s-module-django.forms"> <h1 id="the-forms-api">The Forms API</h1> <div class="admonition-about-this-document admonition"> <p class="admonition-title">About this document</p> <p>This document covers the gritty details of Django’s forms API. You should read the <a class="reference internal" href="../../topics/forms/index.html"><span class="doc">introduction to working with forms</span></a> first.</p> </div> <section id="s-bound-and-unbound-forms"> <h2 id="ref-forms-api-bound-unbound">Bound and unbound forms</h2> <p>A <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance is either <strong>bound</strong> to a set of data, or <strong>unbound</strong>.</p> <ul class="simple"> <li>If it’s <strong>bound</strong> to a set of data, it’s capable of validating that data and rendering the form as HTML with the data displayed in the HTML.</li> <li>If it’s <strong>unbound</strong>, it cannot do validation (because there’s no data to validate!), but it can still render the blank form as HTML.</li> </ul> <dl class="py class"> <dt class="sig sig-object py" id="django.forms.Form">
<code>class Form</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/forms.py#L432"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>To create an unbound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance, instantiate the class:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
</pre> <p>To bind data to a form, pass the data as a dictionary as the first parameter to your <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class constructor:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
</pre> <p>In this dictionary, the keys are the field names, which correspond to the attributes in your <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class. The values are the data you’re trying to validate. These will usually be strings, but there’s no requirement that they be strings; the type of data you pass depends on the <a class="reference internal" href="fields.html#django.forms.Field" title="django.forms.Field"><code>Field</code></a>, as we’ll see in a moment.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.is_bound">
<code>Form.is_bound</code> </dt> 
</dl> <p>If you need to distinguish between bound and unbound form instances at runtime, check the value of the form’s <a class="reference internal" href="#django.forms.Form.is_bound" title="django.forms.Form.is_bound"><code>is_bound</code></a> attribute:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.is_bound
False
&gt;&gt;&gt; f = ContactForm({"subject": "hello"})
&gt;&gt;&gt; f.is_bound
True
</pre> <p>Note that passing an empty dictionary creates a <em>bound</em> form with empty data:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm({})
&gt;&gt;&gt; f.is_bound
True
</pre> <p>If you have a bound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance and want to change the data somehow, or if you want to bind an unbound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance to some data, create another <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance. There is no way to change data in a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance. Once a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance has been created, you should consider its data immutable, whether it has data or not.</p> </section> <section id="s-using-forms-to-validate-data"> <h2 id="using-forms-to-validate-data">Using forms to validate data</h2> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.clean">
<code>Form.clean()</code> </dt> 
</dl> <p>Implement a <code>clean()</code> method on your <code>Form</code> when you must add custom validation for fields that are interdependent. See <a class="reference internal" href="validation.html#validating-fields-with-clean"><span class="std std-ref">Cleaning and validating fields that depend on each other</span></a> for example usage.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.is_valid">
<code>Form.is_valid()</code> </dt> 
</dl> <p>The primary task of a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> object is to validate data. With a bound <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance, call the <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> method to run validation and return a boolean designating whether the data was valid:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
</pre> <p>Let’s try with some invalid data. In this case, <code>subject</code> is blank (an error, because all fields are required by default) and <code>sender</code> is not a valid email address:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "",
...     "message": "Hi there",
...     "sender": "invalid email address",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
False
</pre> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.errors">
<code>Form.errors</code> </dt> 
</dl> <p>Access the <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> attribute to get a dictionary of error messages:</p> <pre data-language="pycon">&gt;&gt;&gt; f.errors
{'sender': ['Enter a valid email address.'], 'subject': ['This field is required.']}
</pre> <p>In this dictionary, the keys are the field names, and the values are lists of strings representing the error messages. The error messages are stored in lists because a field can have multiple error messages.</p> <p>You can access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> without having to call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> first. The form’s data will be validated the first time either you call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> or access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a>.</p> <p>The validation routines will only get called once, regardless of how many times you access <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> or call <a class="reference internal" href="#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a>. This means that if validation has side effects, those side effects will only be triggered once.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.errors.as_data">
<code>Form.errors.as_data()</code> </dt> 
</dl> <p>Returns a <code>dict</code> that maps fields to their original <code>ValidationError</code> instances.</p> <pre data-language="pycon">&gt;&gt;&gt; f.errors.as_data()
{'sender': [ValidationError(['Enter a valid email address.'])],
'subject': [ValidationError(['This field is required.'])]}
</pre> <p>Use this method anytime you need to identify an error by its <code>code</code>. This enables things like rewriting the error’s message or writing custom logic in a view when a given error is present. It can also be used to serialize the errors in a custom format (e.g. XML); for instance, <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>as_json()</code></a> relies on <code>as_data()</code>.</p> <p>The need for the <code>as_data()</code> method is due to backwards compatibility. Previously <code>ValidationError</code> instances were lost as soon as their <strong>rendered</strong> error messages were added to the <code>Form.errors</code> dictionary. Ideally <code>Form.errors</code> would have stored <code>ValidationError</code> instances and methods with an <code>as_</code> prefix could render them, but it had to be done the other way around in order not to break code that expects rendered error messages in <code>Form.errors</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.errors.as_json">
<code>Form.errors.as_json(escape_html=False)</code> </dt> 
</dl> <p>Returns the errors serialized as JSON.</p> <pre data-language="pycon">&gt;&gt;&gt; f.errors.as_json()
{"sender": [{"message": "Enter a valid email address.", "code": "invalid"}],
"subject": [{"message": "This field is required.", "code": "required"}]}
</pre> <p>By default, <code>as_json()</code> does not escape its output. If you are using it for something like AJAX requests to a form view where the client interprets the response and inserts errors into the page, you’ll want to be sure to escape the results on the client-side to avoid the possibility of a cross-site scripting attack. You can do this in JavaScript with <code>element.textContent = errorText</code> or with jQuery’s <code>$(el).text(errorText)</code> (rather than its <code>.html()</code> function).</p> <p>If for some reason you don’t want to use client-side escaping, you can also set <code>escape_html=True</code> and error messages will be escaped so you can use them directly in HTML.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.errors.get_json_data">
<code>Form.errors.get_json_data(escape_html=False)</code> </dt> 
</dl> <p>Returns the errors as a dictionary suitable for serializing to JSON. <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>Form.errors.as_json()</code></a> returns serialized JSON, while this returns the error data before it’s serialized.</p> <p>The <code>escape_html</code> parameter behaves as described in <a class="reference internal" href="#django.forms.Form.errors.as_json" title="django.forms.Form.errors.as_json"><code>Form.errors.as_json()</code></a>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.add_error">
<code>Form.add_error(field, error)</code> </dt> 
</dl> <p>This method allows adding errors to specific fields from within the <code>Form.clean()</code> method, or from outside the form altogether; for instance from a view.</p> <p>The <code>field</code> argument is the name of the field to which the errors should be added. If its value is <code>None</code> the error will be treated as a non-field error as returned by <a class="reference internal" href="#django.forms.Form.non_field_errors" title="django.forms.Form.non_field_errors"><code>Form.non_field_errors()</code></a>.</p> <p>The <code>error</code> argument can be a string, or preferably an instance of <code>ValidationError</code>. See <a class="reference internal" href="validation.html#raising-validation-error"><span class="std std-ref">Raising ValidationError</span></a> for best practices when defining form errors.</p> <p>Note that <code>Form.add_error()</code> automatically removes the relevant field from <code>cleaned_data</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.has_error">
<code>Form.has_error(field, code=None)</code> </dt> 
</dl> <p>This method returns a boolean designating whether a field has an error with a specific error <code>code</code>. If <code>code</code> is <code>None</code>, it will return <code>True</code> if the field contains any errors at all.</p> <p>To check for non-field errors use <a class="reference internal" href="../exceptions.html#django.core.exceptions.NON_FIELD_ERRORS" title="django.core.exceptions.NON_FIELD_ERRORS"><code>NON_FIELD_ERRORS</code></a> as the <code>field</code> parameter.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.non_field_errors">
<code>Form.non_field_errors()</code> </dt> 
</dl> <p>This method returns the list of errors from <a class="reference internal" href="#django.forms.Form.errors" title="django.forms.Form.errors"><code>Form.errors</code></a> that aren’t associated with a particular field. This includes <code>ValidationError</code>s that are raised in <a class="reference internal" href="#django.forms.Form.clean" title="django.forms.Form.clean"><code>Form.clean()</code></a> and errors added using <a class="reference internal" href="#django.forms.Form.add_error" title="django.forms.Form.add_error"><code>Form.add_error(None,
"...")</code></a>.</p> <section id="s-behavior-of-unbound-forms"> <h3 id="behavior-of-unbound-forms">Behavior of unbound forms</h3> <p>It’s meaningless to validate a form with no data, but, for the record, here’s what happens with unbound forms:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.is_valid()
False
&gt;&gt;&gt; f.errors
{}
</pre> </section> </section> <section id="s-initial-form-values"> <h2 id="ref-forms-initial-form-values">Initial form values</h2> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.initial">
<code>Form.initial</code> </dt> 
</dl> <p>Use <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> to declare the initial value of form fields at runtime. For example, you might want to fill in a <code>username</code> field with the username of the current session.</p> <p>To accomplish this, use the <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> argument to a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a>. This argument, if given, should be a dictionary mapping field names to initial values. Only include the fields for which you’re specifying an initial value; it’s not necessary to include every field in your form. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(initial={"subject": "Hi there!"})
</pre> <p>These values are only displayed for unbound forms, and they’re not used as fallback values if a particular value isn’t provided.</p> <p>If a <a class="reference internal" href="fields.html#django.forms.Field" title="django.forms.Field"><code>Field</code></a> defines <a class="reference internal" href="fields.html#django.forms.Field.initial" title="django.forms.Field.initial"><code>initial</code></a> <em>and</em> you include <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> when instantiating the <code>Form</code>, then the latter <code>initial</code> will have precedence. In this example, <code>initial</code> is provided both at the field level and at the form instance level, and the latter gets precedence:</p> <pre data-language="pycon">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class CommentForm(forms.Form):
...     name = forms.CharField(initial="class")
...     url = forms.URLField()
...     comment = forms.CharField()
...
&gt;&gt;&gt; f = CommentForm(initial={"name": "instance"}, auto_id=False)
&gt;&gt;&gt; print(f)
&lt;div&gt;Name:&lt;input type="text" name="name" value="instance" required&gt;&lt;/div&gt;
&lt;div&gt;Url:&lt;input type="url" name="url" required&gt;&lt;/div&gt;
&lt;div&gt;Comment:&lt;input type="text" name="comment" required&gt;&lt;/div&gt;
</pre> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.get_initial_for_field">
<code>Form.get_initial_for_field(field, field_name)</code> </dt> 
</dl> <p>Returns the initial data for a form field. It retrieves the data from <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>Form.initial</code></a> if present, otherwise trying <a class="reference internal" href="fields.html#django.forms.Field.initial" title="django.forms.Field.initial"><code>Field.initial</code></a>. Callable values are evaluated.</p> <p>It is recommended to use <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> over <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a> because <code>BoundField.initial</code> has a simpler interface. Also, unlike <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a>, <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> caches its values. This is useful especially when dealing with callables whose return values can change (e.g. <code>datetime.now</code> or <code>uuid.uuid4</code>):</p> <pre data-language="pycon">&gt;&gt;&gt; import uuid
&gt;&gt;&gt; class UUIDCommentForm(CommentForm):
...     identifier = forms.UUIDField(initial=uuid.uuid4)
...
&gt;&gt;&gt; f = UUIDCommentForm()
&gt;&gt;&gt; f.get_initial_for_field(f.fields["identifier"], "identifier")
UUID('972ca9e4-7bfe-4f5b-af7d-07b3aa306334')
&gt;&gt;&gt; f.get_initial_for_field(f.fields["identifier"], "identifier")
UUID('1b411fab-844e-4dec-bd4f-e9b0495f04d0')
&gt;&gt;&gt; # Using BoundField.initial, for comparison
&gt;&gt;&gt; f["identifier"].initial
UUID('28a09c59-5f00-4ed9-9179-a3b074fa9c30')
&gt;&gt;&gt; f["identifier"].initial
UUID('28a09c59-5f00-4ed9-9179-a3b074fa9c30')
</pre> </section> <section id="s-checking-which-form-data-has-changed"> <h2 id="checking-which-form-data-has-changed">Checking which form data has changed</h2> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.has_changed">
<code>Form.has_changed()</code> </dt> 
</dl> <p>Use the <code>has_changed()</code> method on your <code>Form</code> when you need to check if the form data has been changed from the initial data.</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data, initial=data)
&gt;&gt;&gt; f.has_changed()
False
</pre> <p>When the form is submitted, we reconstruct it and provide the original data so that the comparison can be done:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(request.POST, initial=data)
&gt;&gt;&gt; f.has_changed()
</pre> <p><code>has_changed()</code> will be <code>True</code> if the data from <code>request.POST</code> differs from what was provided in <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a> or <code>False</code> otherwise. The result is computed by calling <a class="reference internal" href="fields.html#django.forms.Field.has_changed" title="django.forms.Field.has_changed"><code>Field.has_changed()</code></a> for each field in the form.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.changed_data">
<code>Form.changed_data</code> </dt> 
</dl> <p>The <code>changed_data</code> attribute returns a list of the names of the fields whose values in the form’s bound data (usually <code>request.POST</code>) differ from what was provided in <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>initial</code></a>. It returns an empty list if no data differs.</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(request.POST, initial=data)
&gt;&gt;&gt; if f.has_changed():
...     print("The following fields changed: %s" % ", ".join(f.changed_data))
...
&gt;&gt;&gt; f.changed_data
['subject', 'message']
</pre> </section> <section id="s-accessing-the-fields-from-the-form"> <h2 id="accessing-the-fields-from-the-form">Accessing the fields from the form</h2> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.fields">
<code>Form.fields</code> </dt> 
</dl> <p>You can access the fields of <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance from its <code>fields</code> attribute:</p> <pre data-language="pycon">&gt;&gt;&gt; for row in f.fields.values():
...     print(row)
...
&lt;django.forms.fields.CharField object at 0x7ffaac632510&gt;
&lt;django.forms.fields.URLField object at 0x7ffaac632f90&gt;
&lt;django.forms.fields.CharField object at 0x7ffaac3aa050&gt;
&gt;&gt;&gt; f.fields["name"]
&lt;django.forms.fields.CharField object at 0x7ffaac6324d0&gt;
</pre> <p>You can alter the field and <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> of <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance to change the way it is presented in the form:</p> <pre data-language="pycon">&gt;&gt;&gt; f.as_div().split("&lt;/div&gt;")[0]
'&lt;div&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_subject"&gt;'
&gt;&gt;&gt; f["subject"].label = "Topic"
&gt;&gt;&gt; f.as_div().split("&lt;/div&gt;")[0]
'&lt;div&gt;&lt;label for="id_subject"&gt;Topic:&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_subject"&gt;'
</pre> <p>Beware not to alter the <code>base_fields</code> attribute because this modification will influence all subsequent <code>ContactForm</code> instances within the same Python process:</p> <pre data-language="pycon">&gt;&gt;&gt; f.base_fields["subject"].label_suffix = "?"
&gt;&gt;&gt; another_f = ContactForm(auto_id=False)
&gt;&gt;&gt; another_f.as_div().split("&lt;/div&gt;")[0]
'&lt;div&gt;&lt;label for="id_subject"&gt;Subject?&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_subject"&gt;'
</pre> </section> <section id="s-accessing-clean-data"> <h2 id="accessing-clean-data">Accessing “clean” data</h2> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.cleaned_data">
<code>Form.cleaned_data</code> </dt> 
</dl> <p>Each field in a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class is responsible not only for validating data, but also for “cleaning” it – normalizing it to a consistent format. This is a nice feature, because it allows data for a particular field to be input in a variety of ways, always resulting in consistent output.</p> <p>For example, <a class="reference internal" href="fields.html#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a> normalizes input into a Python <code>datetime.date</code> object. Regardless of whether you pass it a string in the format <code>'1994-07-15'</code>, a <code>datetime.date</code> object, or a number of other formats, <code>DateField</code> will always normalize it to a <code>datetime.date</code> object as long as it’s valid.</p> <p>Once you’ve created a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance with a set of data and validated it, you can access the clean data via its <code>cleaned_data</code> attribute:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}
</pre> <p>Note that any text-based field – such as <code>CharField</code> or <code>EmailField</code> – always cleans the input into a string. We’ll cover the encoding implications later in this document.</p> <p>If your data does <em>not</em> validate, the <code>cleaned_data</code> dictionary contains only the valid fields:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "",
...     "message": "Hi there",
...     "sender": "invalid email address",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
False
&gt;&gt;&gt; f.cleaned_data
{'cc_myself': True, 'message': 'Hi there'}
</pre> <p><code>cleaned_data</code> will always <em>only</em> contain a key for fields defined in the <code>Form</code>, even if you pass extra data when you define the <code>Form</code>. In this example, we pass a bunch of extra fields to the <code>ContactForm</code> constructor, but <code>cleaned_data</code> contains only the form’s fields:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
...     "extra_field_1": "foo",
...     "extra_field_2": "bar",
...     "extra_field_3": "baz",
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data  # Doesn't contain extra_field_1, etc.
{'cc_myself': True, 'message': 'Hi there', 'sender': 'foo@example.com', 'subject': 'hello'}
</pre> <p>When the <code>Form</code> is valid, <code>cleaned_data</code> will include a key and value for <em>all</em> its fields, even if the data didn’t include a value for some optional fields. In this example, the data dictionary doesn’t include a value for the <code>nick_name</code> field, but <code>cleaned_data</code> includes it, with an empty value:</p> <pre data-language="pycon">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class OptionalPersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...     nick_name = forms.CharField(required=False)
...
&gt;&gt;&gt; data = {"first_name": "John", "last_name": "Lennon"}
&gt;&gt;&gt; f = OptionalPersonForm(data)
&gt;&gt;&gt; f.is_valid()
True
&gt;&gt;&gt; f.cleaned_data
{'nick_name': '', 'first_name': 'John', 'last_name': 'Lennon'}
</pre> <p>In this above example, the <code>cleaned_data</code> value for <code>nick_name</code> is set to an empty string, because <code>nick_name</code> is <code>CharField</code>, and <code>CharField</code>s treat empty values as an empty string. Each field type knows what its “blank” value is – e.g., for <code>DateField</code>, it’s <code>None</code> instead of the empty string. For full details on each field’s behavior in this case, see the “Empty value” note for each field in the <a class="reference internal" href="fields.html#built-in-fields"><span class="std std-ref">Built-in Field classes</span></a> section below.</p> <p>You can write code to perform validation for particular form fields (based on their name) or for the form as a whole (considering combinations of various fields). More information about this is in <a class="reference internal" href="validation.html"><span class="doc">Form and field validation</span></a>.</p> </section> <section id="s-outputting-forms-as-html"> <h2 id="ref-forms-api-outputting-html">Outputting forms as HTML</h2> <p>The second task of a <code>Form</code> object is to render itself as HTML. To do so, <code>print</code> it:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;input type="text" name="message" required id="id_message"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;input type="email" name="sender" required id="id_sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/div&gt;
</pre> <p>If the form is bound to data, the HTML output will include that data appropriately. For example, if a field is represented by an <code>&lt;input type="text"&gt;</code>, the data will be in the <code>value</code> attribute. If a field is represented by an <code>&lt;input type="checkbox"&gt;</code>, then that HTML will include <code>checked</code> if appropriate:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;input type="text" name="subject" value="hello" maxlength="100" required id="id_subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;input type="text" name="message" value="Hi there" required id="id_message"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;input type="email" name="sender" value="foo@example.com" required id="id_sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself" checked&gt;&lt;/div&gt;
</pre> <p>This default output wraps each field with a <code>&lt;div&gt;</code>. Notice the following:</p> <ul class="simple"> <li>For flexibility, the output does <em>not</em> include the <code>&lt;form&gt;</code> and <code>&lt;/form&gt;</code> tags or an <code>&lt;input type="submit"&gt;</code> tag. It’s your job to do that.</li> <li>Each field type has a default HTML representation. <code>CharField</code> is represented by an <code>&lt;input type="text"&gt;</code> and <code>EmailField</code> by an <code>&lt;input type="email"&gt;</code>. <code>BooleanField(null=False)</code> is represented by an <code>&lt;input type="checkbox"&gt;</code>. Note these are merely sensible defaults; you can specify which HTML to use for a given field by using widgets, which we’ll explain shortly.</li> <li>The HTML <code>name</code> for each tag is taken directly from its attribute name in the <code>ContactForm</code> class.</li> <li>The text label for each field – e.g. <code>'Subject:'</code>, <code>'Message:'</code> and <code>'Cc myself:'</code> is generated from the field name by converting all underscores to spaces and upper-casing the first letter. Again, note these are merely sensible defaults; you can also specify labels manually.</li> <li>Each text label is surrounded in an HTML <code>&lt;label&gt;</code> tag, which points to the appropriate form field via its <code>id</code>. Its <code>id</code>, in turn, is generated by prepending <code>'id_'</code> to the field name. The <code>id</code> attributes and <code>&lt;label&gt;</code> tags are included in the output by default, to follow best practices, but you can change that behavior.</li> <li>The output uses HTML5 syntax, targeting <code>&lt;!DOCTYPE html&gt;</code>. For example, it uses boolean attributes such as <code>checked</code> rather than the XHTML style of <code>checked='checked'</code>.</li> </ul> <p>Although <code>&lt;div&gt;</code> output is the default output style when you <code>print</code> a form you can customize the output by using your own form template which can be set site-wide, per-form, or per-instance. See <a class="reference internal" href="../../topics/forms/index.html#reusable-form-templates"><span class="std std-ref">Reusable form templates</span></a>.</p> <section id="s-default-rendering"> <h3 id="default-rendering">Default rendering</h3> <p>The default rendering when you <code>print</code> a form uses the following methods and attributes.</p> <section id="s-template-name"> <h4 id="template-name"><code>template_name</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name">
<code>Form.template_name</code> </dt> 
</dl> <p>The name of the template rendered if the form is cast into a string, e.g. via <code>print(form)</code> or in a template via <code>{{ form }}</code>.</p> <p>By default, a property returning the value of the renderer’s <a class="reference internal" href="renderers.html#django.forms.renderers.BaseRenderer.form_template_name" title="django.forms.renderers.BaseRenderer.form_template_name"><code>form_template_name</code></a>. You may set it as a string template name in order to override that for a particular form class.</p> </section> <section id="s-render"> <h4 id="render"><code>render()</code></h4> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.render">
<code>Form.render(template_name=None, context=None, renderer=None)</code> </dt> 
</dl> <p>The render method is called by <code>__str__</code> as well as the <a class="reference internal" href="#django.forms.Form.as_div" title="django.forms.Form.as_div"><code>Form.as_div()</code></a>, <a class="reference internal" href="#django.forms.Form.as_table" title="django.forms.Form.as_table"><code>Form.as_table()</code></a>, <a class="reference internal" href="#django.forms.Form.as_p" title="django.forms.Form.as_p"><code>Form.as_p()</code></a>, and <a class="reference internal" href="#django.forms.Form.as_ul" title="django.forms.Form.as_ul"><code>Form.as_ul()</code></a> methods. All arguments are optional and default to:</p> <ul class="simple"> <li>
<code>template_name</code>: <a class="reference internal" href="#django.forms.Form.template_name" title="django.forms.Form.template_name"><code>Form.template_name</code></a>
</li> <li>
<code>context</code>: Value returned by <a class="reference internal" href="#django.forms.Form.get_context" title="django.forms.Form.get_context"><code>Form.get_context()</code></a>
</li> <li>
<code>renderer</code>: Value returned by <a class="reference internal" href="#django.forms.Form.default_renderer" title="django.forms.Form.default_renderer"><code>Form.default_renderer</code></a>
</li> </ul> <p>By passing <code>template_name</code> you can customize the template used for just a single call.</p> </section> <section id="s-get-context"> <h4 id="get-context"><code>get_context()</code></h4> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.get_context">
<code>Form.get_context()</code> </dt> 
</dl> <p>Return the template context for rendering the form.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>form</code>: The bound form.</li> <li>
<code>fields</code>: All bound fields, except the hidden fields.</li> <li>
<code>hidden_fields</code>: All hidden bound fields.</li> <li>
<code>errors</code>: All non field related or hidden field related form errors.</li> </ul> </section> <section id="s-template-name-label"> <h4 id="template-name-label"><code>template_name_label</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name_label">
<code>Form.template_name_label</code> </dt> 
</dl> <p>The template used to render a field’s <code>&lt;label&gt;</code>, used when calling <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>BoundField.label_tag()</code></a>/<a class="reference internal" href="#django.forms.BoundField.legend_tag" title="django.forms.BoundField.legend_tag"><code>legend_tag()</code></a>. Can be changed per form by overriding this attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers.html#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p> </section> </section> <section id="s-output-styles"> <h3 id="output-styles">Output styles</h3> <p>The recommended approach for changing form output style is to set a custom form template either site-wide, per-form, or per-instance. See <a class="reference internal" href="../../topics/forms/index.html#reusable-form-templates"><span class="std std-ref">Reusable form templates</span></a> for examples.</p> <p>The following helper functions are provided for backward compatibility and are a proxy to <a class="reference internal" href="#django.forms.Form.render" title="django.forms.Form.render"><code>Form.render()</code></a> passing a particular <code>template_name</code> value.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Of the framework provided templates and output styles, the default <code>as_div()</code> is recommended over the <code>as_p()</code>, <code>as_table()</code>, and <code>as_ul()</code> versions as the template implements <code>&lt;fieldset&gt;</code> and <code>&lt;legend&gt;</code> to group related inputs and is easier for screen reader users to navigate.</p> </div> <p>Each helper pairs a form method with an attribute giving the appropriate template name.</p> <section id="s-as-div"> <h4 id="as-div"><code>as_div()</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name_div">
<code>Form.template_name_div</code> </dt> 
</dl> <p>The template used by <code>as_div()</code>. Default: <code>'django/forms/div.html'</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.as_div">
<code>Form.as_div()</code> </dt> 
</dl> <p><code>as_div()</code> renders the form as a series of <code>&lt;div&gt;</code> elements, with each <code>&lt;div&gt;</code> containing one field, such as:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_div()
</pre> <p>… gives HTML like:</p> <pre data-language="html">&lt;div&gt;
&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;
&lt;input type="text" name="subject" maxlength="100" required id="id_subject"&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;label for="id_message"&gt;Message:&lt;/label&gt;
&lt;input type="text" name="message" required id="id_message"&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;
&lt;input type="email" name="sender" required id="id_sender"&gt;
&lt;/div&gt;
&lt;div&gt;
&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;
&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;
&lt;/div&gt;
</pre> </section> <section id="s-as-p"> <h4 id="as-p"><code>as_p()</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name_p">
<code>Form.template_name_p</code> </dt> 
</dl> <p>The template used by <code>as_p()</code>. Default: <code>'django/forms/p.html'</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.as_p">
<code>Form.as_p()</code> </dt> 
</dl> <p><code>as_p()</code> renders the form as a series of <code>&lt;p&gt;</code> tags, with each <code>&lt;p&gt;</code> containing one field:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_p()
'&lt;p&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="text" name="sender" id="id_sender" required&gt;&lt;/p&gt;\n&lt;p&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/p&gt;'
&gt;&gt;&gt; print(f.as_p())
&lt;p&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/p&gt;
&lt;p&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/p&gt;
</pre> </section> <section id="s-as-ul"> <h4 id="as-ul"><code>as_ul()</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name_ul">
<code>Form.template_name_ul</code> </dt> 
</dl> <p>The template used by <code>as_ul()</code>. Default: <code>'django/forms/ul.html'</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.as_ul">
<code>Form.as_ul()</code> </dt> 
</dl> <p><code>as_ul()</code> renders the form as a series of <code>&lt;li&gt;</code> tags, with each <code>&lt;li&gt;</code> containing one field. It does <em>not</em> include the <code>&lt;ul&gt;</code> or <code>&lt;/ul&gt;</code>, so that you can specify any HTML attributes on the <code>&lt;ul&gt;</code> for flexibility:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_ul()
'&lt;li&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/li&gt;\n&lt;li&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/li&gt;'
&gt;&gt;&gt; print(f.as_ul())
&lt;li&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt; &lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt; &lt;input type="text" name="message" id="id_message" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt; &lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/li&gt;
&lt;li&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; &lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/li&gt;
</pre> </section> <section id="s-as-table"> <h4 id="as-table"><code>as_table()</code></h4> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.template_name_table">
<code>Form.template_name_table</code> </dt> 
</dl> <p>The template used by <code>as_table()</code>. Default: <code>'django/forms/table.html'</code>.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.as_table">
<code>Form.as_table()</code> </dt> 
</dl> <p><code>as_table()</code> renders the form as an HTML <code>&lt;table&gt;</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; f.as_table()
'&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;\n&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;'
&gt;&gt;&gt; print(f.as_table())
&lt;tr&gt;&lt;th&gt;&lt;label for="id_subject"&gt;Subject:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_message"&gt;Message:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="text" name="message" id="id_message" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_sender"&gt;Sender:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="email" name="sender" id="id_sender" required&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;th&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;/th&gt;&lt;td&gt;&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;&lt;/td&gt;&lt;/tr&gt;
</pre> </section> </section> <section id="s-styling-required-or-erroneous-form-rows"> <h3 id="ref-forms-api-styling-form-rows">Styling required or erroneous form rows</h3> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.error_css_class">
<code>Form.error_css_class</code> </dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.required_css_class">
<code>Form.required_css_class</code> </dt> 
</dl> <p>It’s pretty common to style form rows and fields that are required or have errors. For example, you might want to present required form rows in bold and highlight errors in red.</p> <p>The <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> class has a couple of hooks you can use to add <code>class</code> attributes to required rows or to rows with errors: set the <a class="reference internal" href="#django.forms.Form.error_css_class" title="django.forms.Form.error_css_class"><code>Form.error_css_class</code></a> and/or <a class="reference internal" href="#django.forms.Form.required_css_class" title="django.forms.Form.required_css_class"><code>Form.required_css_class</code></a> attributes:</p> <pre data-language="python">from django import forms


class ContactForm(forms.Form):
    error_css_class = "error"
    required_css_class = "required"

    # ... and the rest of your fields here
</pre> <p>Once you’ve done that, rows will be given <code>"error"</code> and/or <code>"required"</code> classes, as needed. The HTML will look something like:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(data)
&gt;&gt;&gt; print(f)
&lt;div class="required"&gt;&lt;label for="id_subject" class="required"&gt;Subject:&lt;/label&gt; ...
&lt;div class="required"&gt;&lt;label for="id_message" class="required"&gt;Message:&lt;/label&gt; ...
&lt;div class="required"&gt;&lt;label for="id_sender" class="required"&gt;Sender:&lt;/label&gt; ...
&lt;div&gt;&lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt; ...
&gt;&gt;&gt; f["subject"].label_tag()
&lt;label class="required" for="id_subject"&gt;Subject:&lt;/label&gt;
&gt;&gt;&gt; f["subject"].legend_tag()
&lt;legend class="required" for="id_subject"&gt;Subject:&lt;/legend&gt;
&gt;&gt;&gt; f["subject"].label_tag(attrs={"class": "foo"})
&lt;label for="id_subject" class="foo required"&gt;Subject:&lt;/label&gt;
&gt;&gt;&gt; f["subject"].legend_tag(attrs={"class": "foo"})
&lt;legend for="id_subject" class="foo required"&gt;Subject:&lt;/legend&gt;
</pre> <p>You may further modify the rendering of form rows by using a <a class="reference internal" href="#custom-boundfield"><span class="std std-ref">custom BoundField</span></a>.</p> </section> <section id="s-configuring-form-elements-html-id-attributes-and-label-tags"> <h3 id="ref-forms-api-configuring-label">Configuring form elements’ HTML <code>id</code> attributes and <code>&lt;label&gt;</code> tags</h3> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.auto_id">
<code>Form.auto_id</code> </dt> 
</dl> <p>By default, the form rendering methods include:</p> <ul class="simple"> <li>HTML <code>id</code> attributes on the form elements.</li> <li>The corresponding <code>&lt;label&gt;</code> tags around the labels. An HTML <code>&lt;label&gt;</code> tag designates which label text is associated with which form element. This small enhancement makes forms more usable and more accessible to assistive devices. It’s always a good idea to use <code>&lt;label&gt;</code> tags.</li> </ul> <p>The <code>id</code> attribute values are generated by prepending <code>id_</code> to the form field names. This behavior is configurable, though, if you want to change the <code>id</code> convention or remove HTML <code>id</code> attributes and <code>&lt;label&gt;</code> tags entirely.</p> <p>Use the <code>auto_id</code> argument to the <code>Form</code> constructor to control the <code>id</code> and label behavior. This argument must be <code>True</code>, <code>False</code> or a string.</p> <p>If <code>auto_id</code> is <code>False</code>, then the form output will not include <code>&lt;label&gt;</code> tags nor <code>id</code> attributes:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(auto_id=False)
&gt;&gt;&gt; print(f)
&lt;div&gt;Subject:&lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/div&gt;
&lt;div&gt;Message:&lt;textarea name="message" cols="40" rows="10" required&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;Sender:&lt;input type="email" name="sender" required&gt;&lt;/div&gt;
&lt;div&gt;Cc myself:&lt;input type="checkbox" name="cc_myself"&gt;&lt;/div&gt;
</pre> <p>If <code>auto_id</code> is set to <code>True</code>, then the form output <em>will</em> include <code>&lt;label&gt;</code> tags and will use the field name as its <code>id</code> for each form field:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(auto_id=True)
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="subject"&gt;Subject:&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="message"&gt;Message:&lt;/label&gt;&lt;textarea name="message" cols="40" rows="10" required id="message"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="sender"&gt;Sender:&lt;/label&gt;&lt;input type="email" name="sender" required id="sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="cc_myself"&gt;&lt;/div&gt;
</pre> <p>If <code>auto_id</code> is set to a string containing the format character <code>'%s'</code>, then the form output will include <code>&lt;label&gt;</code> tags, and will generate <code>id</code> attributes based on the format string. For example, for a format string <code>'field_%s'</code>, a field named <code>subject</code> will get the <code>id</code> value <code>'field_subject'</code>. Continuing our example:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(auto_id="id_for_%s")
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="id_for_subject"&gt;Subject:&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_for_subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_message"&gt;Message:&lt;/label&gt;&lt;textarea name="message" cols="40" rows="10" required id="id_for_message"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_sender"&gt;Sender:&lt;/label&gt;&lt;input type="email" name="sender" required id="id_for_sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself:&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/div&gt;
</pre> <p>If <code>auto_id</code> is set to any other true value – such as a string that doesn’t include <code>%s</code> – then the library will act as if <code>auto_id</code> is <code>True</code>.</p> <p>By default, <code>auto_id</code> is set to the string <code>'id_%s'</code>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.label_suffix">
<code>Form.label_suffix</code> </dt> 
</dl> <p>A translatable string (defaults to a colon (<code>:</code>) in English) that will be appended after any label name when a form is rendered.</p> <p>It’s possible to customize that character, or omit it entirely, using the <code>label_suffix</code> parameter:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(auto_id="id_for_%s", label_suffix="")
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="id_for_subject"&gt;Subject&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_for_subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_message"&gt;Message&lt;/label&gt;&lt;textarea name="message" cols="40" rows="10" required id="id_for_message"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_sender"&gt;Sender&lt;/label&gt;&lt;input type="email" name="sender" required id="id_for_sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/div&gt;
&gt;&gt;&gt; f = ContactForm(auto_id="id_for_%s", label_suffix=" -&gt;")
&gt;&gt;&gt; print(f)
&lt;div&gt;&lt;label for="id_for_subject"&gt;Subject -&amp;gt;&lt;/label&gt;&lt;input type="text" name="subject" maxlength="100" required id="id_for_subject"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_message"&gt;Message -&amp;gt;&lt;/label&gt;&lt;textarea name="message" cols="40" rows="10" required id="id_for_message"&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_sender"&gt;Sender -&amp;gt;&lt;/label&gt;&lt;input type="email" name="sender" required id="id_for_sender"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_for_cc_myself"&gt;Cc myself -&amp;gt;&lt;/label&gt;&lt;input type="checkbox" name="cc_myself" id="id_for_cc_myself"&gt;&lt;/div&gt;
</pre> <p>Note that the label suffix is added only if the last character of the label isn’t a punctuation character (in English, those are <code>.</code>, <code>!</code>, <code>?</code> or <code>:</code>).</p> <p>Fields can also define their own <a class="reference internal" href="fields.html#django.forms.Field.label_suffix" title="django.forms.Field.label_suffix"><code>label_suffix</code></a>. This will take precedence over <a class="reference internal" href="#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>Form.label_suffix</code></a>. The suffix can also be overridden at runtime using the <code>label_suffix</code> parameter to <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>/ <a class="reference internal" href="#django.forms.BoundField.legend_tag" title="django.forms.BoundField.legend_tag"><code>legend_tag()</code></a>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.use_required_attribute">
<code>Form.use_required_attribute</code> </dt> 
</dl> <p>When set to <code>True</code> (the default), required form fields will have the <code>required</code> HTML attribute.</p> <p><a class="reference internal" href="../../topics/forms/formsets.html"><span class="doc">Formsets</span></a> instantiate forms with <code>use_required_attribute=False</code> to avoid incorrect browser validation when adding and deleting forms from a formset.</p> </section> <section id="s-configuring-the-rendering-of-a-form-s-widgets"> <h3 id="configuring-the-rendering-of-a-form-s-widgets">Configuring the rendering of a form’s widgets</h3> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.default_renderer">
<code>Form.default_renderer</code> </dt> 
</dl> <p>Specifies the <a class="reference internal" href="renderers.html"><span class="doc">renderer</span></a> to use for the form. Defaults to <code>None</code> which means to use the default renderer specified by the <a class="reference internal" href="../settings.html#std-setting-FORM_RENDERER"><code>FORM_RENDERER</code></a> setting.</p> <p>You can set this as a class attribute when declaring your form or use the <code>renderer</code> argument to <code>Form.__init__()</code>. For example:</p> <pre data-language="python">from django import forms


class MyForm(forms.Form):
    default_renderer = MyRenderer()
</pre> <p>or:</p> <pre data-language="python">form = MyForm(renderer=MyRenderer())
</pre> </section> <section id="s-notes-on-field-ordering"> <h3 id="notes-on-field-ordering">Notes on field ordering</h3> <p>In the <code>as_p()</code>, <code>as_ul()</code> and <code>as_table()</code> shortcuts, the fields are displayed in the order in which you define them in your form class. For example, in the <code>ContactForm</code> example, the fields are defined in the order <code>subject</code>, <code>message</code>, <code>sender</code>, <code>cc_myself</code>. To reorder the HTML output, change the order in which those fields are listed in the class.</p> <p>There are several other ways to customize the order:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.field_order">
<code>Form.field_order</code> </dt> 
</dl> <p>By default <code>Form.field_order=None</code>, which retains the order in which you define the fields in your form class. If <code>field_order</code> is a list of field names, the fields are ordered as specified by the list and remaining fields are appended according to the default order. Unknown field names in the list are ignored. This makes it possible to disable a field in a subclass by setting it to <code>None</code> without having to redefine ordering.</p> <p>You can also use the <code>Form.field_order</code> argument to a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> to override the field order. If a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> defines <a class="reference internal" href="#django.forms.Form.field_order" title="django.forms.Form.field_order"><code>field_order</code></a> <em>and</em> you include <code>field_order</code> when instantiating the <code>Form</code>, then the latter <code>field_order</code> will have precedence.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.order_fields">
<code>Form.order_fields(field_order)</code> </dt> 
</dl> <p>You may rearrange the fields any time using <code>order_fields()</code> with a list of field names as in <a class="reference internal" href="#django.forms.Form.field_order" title="django.forms.Form.field_order"><code>field_order</code></a>.</p> </section> <section id="s-how-errors-are-displayed"> <h3 id="form-error-display">How errors are displayed</h3> <p>If you render a bound <code>Form</code> object, the act of rendering will automatically run the form’s validation if it hasn’t already happened, and the HTML output will include the validation errors as a <code>&lt;ul class="errorlist"&gt;</code>.</p> <p>The following:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {
...     "subject": "",
...     "message": "Hi there",
...     "sender": "invalid email address",
...     "cc_myself": True,
... }
&gt;&gt;&gt; ContactForm(data).as_div()
</pre> <p>… gives HTML like:</p> <pre data-language="html">&lt;div&gt;
  &lt;label for="id_subject"&gt;Subject:&lt;/label&gt;
  &lt;ul class="errorlist" id="id_subject_error"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;
  &lt;input type="text" name="subject" maxlength="100" required aria-invalid="true" aria-describedby="id_subject_error" id="id_subject"&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;label for="id_message"&gt;Message:&lt;/label&gt;
  &lt;textarea name="message" cols="40" rows="10" required id="id_message"&gt;Hi there&lt;/textarea&gt;
&lt;/div&gt;
&lt;div&gt;
  &lt;label for="id_sender"&gt;Sender:&lt;/label&gt;
  &lt;ul class="errorlist" id="id_sender_error"&gt;&lt;li&gt;Enter a valid email address.&lt;/li&gt;&lt;/ul&gt;
  &lt;input type="email" name="sender" value="invalid email address" maxlength="320" required aria-invalid="true" aria-describedby="id_sender_error" id="id_sender"&gt;
&lt;/div&gt;
&lt;div&gt;
    &lt;label for="id_cc_myself"&gt;Cc myself:&lt;/label&gt;
    &lt;input type="checkbox" name="cc_myself" id="id_cc_myself" checked&gt;
&lt;/div&gt;
</pre> <p>Django’s default form templates will associate validation errors with their input by using the <code>aria-describedby</code> HTML attribute when the field has an <code>auto_id</code> and a custom <code>aria-describedby</code> is not provided. If a custom <code>aria-describedby</code> is set when defining the widget this will override the default value.</p> <p>If the widget is rendered in a <code>&lt;fieldset&gt;</code> then <code>aria-describedby</code> is added to this element, otherwise it is added to the widget’s HTML element (e.g. <code>&lt;input&gt;</code>).</p> <div class="versionchanged"> <span class="title">Changed in Django 5.2:</span> <p><code>aria-describedby</code> was added to associate errors with its input.</p> </div> </section> <section id="s-customizing-the-error-list-format"> <h3 id="ref-forms-error-list-format">Customizing the error list format</h3> <dl class="py class"> <dt class="sig sig-object py" id="django.forms.ErrorList">
<code>class ErrorList(initlist=None, error_class=None, renderer=None, field_id=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/utils.py#L141"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>By default, forms use <code>django.forms.utils.ErrorList</code> to format validation errors. <code>ErrorList</code> is a list like object where <code>initlist</code> is the list of errors. In addition this class has the following attributes and methods.</p> <div class="versionchanged"> <span class="title">Changed in Django 5.2:</span> <p>The <code>field_id</code> argument was added.</p> </div> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.error_class">
<code>error_class</code> </dt> <dd>
<p>The CSS classes to be used when rendering the error list. Any provided classes are added to the default <code>errorlist</code> class.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.renderer">
<code>renderer</code> </dt> <dd>
<p>Specifies the <a class="reference internal" href="renderers.html"><span class="doc">renderer</span></a> to use for <code>ErrorList</code>. Defaults to <code>None</code> which means to use the default renderer specified by the <a class="reference internal" href="../settings.html#std-setting-FORM_RENDERER"><code>FORM_RENDERER</code></a> setting.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.field_id">
<code>field_id</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>An <code>id</code> for the field for which the errors relate. This allows an HTML <code>id</code> attribute to be added in the error template and is useful to associate the errors with the field. The default template uses the format <code>id="{{ field_id }}_error"</code> and a value is provided by <a class="reference internal" href="#django.forms.Form.add_error" title="django.forms.Form.add_error"><code>Form.add_error()</code></a> using the field’s <a class="reference internal" href="#django.forms.BoundField.auto_id" title="django.forms.BoundField.auto_id"><code>auto_id</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.template_name">
<code>template_name</code> </dt> <dd>
<p>The name of the template used when calling <code>__str__</code> or <a class="reference internal" href="#django.forms.ErrorList.render" title="django.forms.ErrorList.render"><code>render()</code></a>. By default this is <code>'django/forms/errors/list/default.html'</code> which is a proxy for the <code>'ul.html'</code> template.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.template_name_text">
<code>template_name_text</code> </dt> <dd>
<p>The name of the template used when calling <a class="reference internal" href="#django.forms.ErrorList.as_text" title="django.forms.ErrorList.as_text"><code>as_text()</code></a>. By default this is <code>'django/forms/errors/list/text.html'</code>. This template renders the errors as a list of bullet points.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.ErrorList.template_name_ul">
<code>template_name_ul</code> </dt> <dd>
<p>The name of the template used when calling <a class="reference internal" href="#django.forms.ErrorList.as_ul" title="django.forms.ErrorList.as_ul"><code>as_ul()</code></a>. By default this is <code>'django/forms/errors/list/ul.html'</code>. This template renders the errors in <code>&lt;li&gt;</code> tags with a wrapping <code>&lt;ul&gt;</code> with the CSS classes as defined by <a class="reference internal" href="#django.forms.ErrorList.error_class" title="django.forms.ErrorList.error_class"><code>error_class</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.ErrorList.get_context">
<code>get_context()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/utils.py#L181"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return context for rendering of errors in a template.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>errors</code> : A list of the errors.</li> <li>
<code>error_class</code> : A string of CSS classes.</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.ErrorList.render">
<code>render(template_name=None, context=None, renderer=None)</code> </dt> <dd>
<p>The render method is called by <code>__str__</code> as well as by the <a class="reference internal" href="#django.forms.ErrorList.as_ul" title="django.forms.ErrorList.as_ul"><code>as_ul()</code></a> method.</p> <p>All arguments are optional and will default to:</p> <ul class="simple"> <li>
<code>template_name</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.template_name" title="django.forms.ErrorList.template_name"><code>template_name</code></a>
</li> <li>
<code>context</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.get_context" title="django.forms.ErrorList.get_context"><code>get_context()</code></a>
</li> <li>
<code>renderer</code>: Value returned by <a class="reference internal" href="#django.forms.ErrorList.renderer" title="django.forms.ErrorList.renderer"><code>renderer</code></a>
</li> </ul> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.ErrorList.as_text">
<code>as_text()</code> </dt> <dd>
<p>Renders the error list using the template defined by <a class="reference internal" href="#django.forms.ErrorList.template_name_text" title="django.forms.ErrorList.template_name_text"><code>template_name_text</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.ErrorList.as_ul">
<code>as_ul()</code> </dt> <dd>
<p>Renders the error list using the template defined by <a class="reference internal" href="#django.forms.ErrorList.template_name_ul" title="django.forms.ErrorList.template_name_ul"><code>template_name_ul</code></a>.</p> </dd>
</dl> <p>If you’d like to customize the rendering of errors this can be achieved by overriding the <a class="reference internal" href="#django.forms.ErrorList.template_name" title="django.forms.ErrorList.template_name"><code>template_name</code></a> attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers.html#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p> </dd>
</dl> </section> </section> <section id="s-more-granular-output"> <h2 id="more-granular-output">More granular output</h2> <p>The <code>as_p()</code>, <code>as_ul()</code>, and <code>as_table()</code> methods are shortcuts – they’re not the only way a form object can be displayed.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.forms.BoundField">
<code>class BoundField</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L13"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Used to display HTML or access attributes for a single field of a <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance.</p> <p>The <code>__str__()</code> method of this object displays the HTML for this field.</p> <p>You can use <a class="reference internal" href="#django.forms.Form.bound_field_class" title="django.forms.Form.bound_field_class"><code>Form.bound_field_class</code></a> and <a class="reference internal" href="fields.html#django.forms.Field.bound_field_class" title="django.forms.Field.bound_field_class"><code>Field.bound_field_class</code></a> to specify a different <code>BoundField</code> class per form or per field, respectively.</p> <p>See <a class="reference internal" href="#custom-boundfield"><span class="std std-ref">Customizing BoundField</span></a> for examples of overriding a <code>BoundField</code>.</p> </dd>
</dl> <p>To retrieve a single <code>BoundField</code>, use dictionary lookup syntax on your form using the field’s name as the key:</p> <pre data-language="pycon">&gt;&gt;&gt; form = ContactForm()
&gt;&gt;&gt; print(form["subject"])
&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;
</pre> <p>To retrieve all <code>BoundField</code> objects, iterate the form:</p> <pre data-language="pycon">&gt;&gt;&gt; form = ContactForm()
&gt;&gt;&gt; for boundfield in form:
...     print(boundfield)
...
&lt;input id="id_subject" type="text" name="subject" maxlength="100" required&gt;
&lt;input type="text" name="message" id="id_message" required&gt;
&lt;input type="email" name="sender" id="id_sender" required&gt;
&lt;input type="checkbox" name="cc_myself" id="id_cc_myself"&gt;
</pre> <p>The field-specific output honors the form object’s <code>auto_id</code> setting:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(auto_id=False)
&gt;&gt;&gt; print(f["message"])
&lt;input type="text" name="message" required&gt;
&gt;&gt;&gt; f = ContactForm(auto_id="id_%s")
&gt;&gt;&gt; print(f["message"])
&lt;input type="text" name="message" id="id_message" required&gt;
</pre> <section id="s-attributes-of-boundfield"> <h3 id="attributes-of-boundfield">Attributes of <code>BoundField</code>
</h3> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.aria_describedby">
<code>BoundField.aria_describedby</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L300"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>Returns an <code>aria-describedby</code> reference to associate a field with its help text and errors. Returns <code>None</code> if <code>aria-describedby</code> is set in <a class="reference internal" href="widgets.html#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>Widget.attrs</code></a> to preserve the user defined attribute when rendering the form.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.auto_id">
<code>BoundField.auto_id</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L239"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The HTML ID attribute for this <code>BoundField</code>. Returns an empty string if <a class="reference internal" href="#django.forms.Form.auto_id" title="django.forms.Form.auto_id"><code>Form.auto_id</code></a> is <code>False</code>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.data">
<code>BoundField.data</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L132"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>This property returns the data for this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> extracted by the widget’s <a class="reference internal" href="widgets.html#django.forms.Widget.value_from_datadict" title="django.forms.Widget.value_from_datadict"><code>value_from_datadict()</code></a> method, or <code>None</code> if it wasn’t given:</p> <pre data-language="pycon">&gt;&gt;&gt; unbound_form = ContactForm()
&gt;&gt;&gt; print(unbound_form["subject"].data)
None
&gt;&gt;&gt; bound_form = ContactForm(data={"subject": "My Subject"})
&gt;&gt;&gt; print(bound_form["subject"].data)
My Subject
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.errors">
<code>BoundField.errors</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L70"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A <a class="reference internal" href="#ref-forms-error-list-format"><span class="std std-ref">list-like object</span></a> that is displayed as an HTML <code>&lt;ul class="errorlist"&gt;</code> when printed:</p> <pre data-language="pycon">&gt;&gt;&gt; data = {"subject": "hi", "message": "", "sender": "", "cc_myself": ""}
&gt;&gt;&gt; f = ContactForm(data, auto_id=False)
&gt;&gt;&gt; print(f["message"])
&lt;input type="text" name="message" required aria-invalid="true"&gt;
&gt;&gt;&gt; f["message"].errors
['This field is required.']
&gt;&gt;&gt; print(f["message"].errors)
&lt;ul class="errorlist"&gt;&lt;li&gt;This field is required.&lt;/li&gt;&lt;/ul&gt;
&gt;&gt;&gt; f["subject"].errors
[]
&gt;&gt;&gt; print(f["subject"].errors)

&gt;&gt;&gt; str(f["subject"].errors)
''
</pre> <p>When rendering a field with errors, <code>aria-invalid="true"</code> will be set on the field’s widget to indicate there is an error to screen reader users.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.field">
<code>BoundField.field</code> </dt> <dd>
<p>The form <a class="reference internal" href="fields.html#django.forms.Field" title="django.forms.Field"><code>Field</code></a> instance from the form class that this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> wraps.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.form">
<code>BoundField.form</code> </dt> <dd>
<p>The <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> instance this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> is bound to.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.help_text">
<code>BoundField.help_text</code> </dt> <dd>
<p>The <a class="reference internal" href="fields.html#django.forms.Field.help_text" title="django.forms.Field.help_text"><code>help_text</code></a> of the field.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.html_name">
<code>BoundField.html_name</code> </dt> <dd>
<p>The name that will be used in the widget’s HTML <code>name</code> attribute. It takes the form <a class="reference internal" href="#django.forms.Form.prefix" title="django.forms.Form.prefix"><code>prefix</code></a> into account.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.id_for_label">
<code>BoundField.id_for_label</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L252"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use this property to render the ID of this field. For example, if you are manually constructing a <code>&lt;label&gt;</code> in your template (despite the fact that <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>/<a class="reference internal" href="#django.forms.BoundField.legend_tag" title="django.forms.BoundField.legend_tag"><code>legend_tag()</code></a> will do this for you):</p> <pre data-language="markup">&lt;label for="{{ form.my_field.id_for_label }}"&gt;...&lt;/label&gt;{{ my_field }}
</pre> <p>By default, this will be the field’s name prefixed by <code>id_</code> (”<code>id_my_field</code>” for the example above). You may modify the ID by setting <a class="reference internal" href="widgets.html#django.forms.Widget.attrs" title="django.forms.Widget.attrs"><code>attrs</code></a> on the field’s widget. For example, declaring a field like this:</p> <pre data-language="python">my_field = forms.CharField(widget=forms.TextInput(attrs={"id": "myFIELD"}))
</pre> <p>and using the template above, would render something like:</p> <pre data-language="html">&lt;label for="myFIELD"&gt;...&lt;/label&gt;&lt;input id="myFIELD" type="text" name="my_field" required&gt;
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.initial">
<code>BoundField.initial</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L263"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> to retrieve initial data for a form field. It retrieves the data from <a class="reference internal" href="#django.forms.Form.initial" title="django.forms.Form.initial"><code>Form.initial</code></a> if present, otherwise trying <a class="reference internal" href="fields.html#django.forms.Field.initial" title="django.forms.Field.initial"><code>Field.initial</code></a>. Callable values are evaluated. See <a class="reference internal" href="#ref-forms-initial-form-values"><span class="std std-ref">Initial form values</span></a> for more examples.</p> <p><a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> caches its return value, which is useful especially when dealing with callables whose return values can change (e.g. <code>datetime.now</code> or <code>uuid.uuid4</code>):</p> <pre data-language="pycon">&gt;&gt;&gt; from datetime import datetime
&gt;&gt;&gt; class DatedCommentForm(CommentForm):
...     created = forms.DateTimeField(initial=datetime.now)
...
&gt;&gt;&gt; f = DatedCommentForm()
&gt;&gt;&gt; f["created"].initial
datetime.datetime(2021, 7, 27, 9, 5, 54)
&gt;&gt;&gt; f["created"].initial
datetime.datetime(2021, 7, 27, 9, 5, 54)
</pre> <p>Using <a class="reference internal" href="#django.forms.BoundField.initial" title="django.forms.BoundField.initial"><code>BoundField.initial</code></a> is recommended over <a class="reference internal" href="#django.forms.Form.get_initial_for_field" title="django.forms.Form.get_initial_for_field"><code>get_initial_for_field()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.is_hidden">
<code>BoundField.is_hidden</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L234"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns <code>True</code> if this <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>’s widget is hidden.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.label">
<code>BoundField.label</code> </dt> <dd>
<p>The <a class="reference internal" href="fields.html#django.forms.Field.label" title="django.forms.Field.label"><code>label</code></a> of the field. This is used in <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a>/<a class="reference internal" href="#django.forms.BoundField.legend_tag" title="django.forms.BoundField.legend_tag"><code>legend_tag()</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.name">
<code>BoundField.name</code> </dt> <dd>
<p>The name of this field in the form:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm()
&gt;&gt;&gt; print(f["subject"].name)
subject
&gt;&gt;&gt; print(f["message"].name)
message
</pre> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.template_name">
<code>BoundField.template_name</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L79"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>The name of the template rendered with <a class="reference internal" href="#django.forms.BoundField.as_field_group" title="django.forms.BoundField.as_field_group"><code>BoundField.as_field_group()</code></a>.</p> <p>A property returning the value of the <a class="reference internal" href="fields.html#django.forms.Field.template_name" title="django.forms.Field.template_name"><code>template_name</code></a> if set otherwise <a class="reference internal" href="renderers.html#django.forms.renderers.BaseRenderer.field_template_name" title="django.forms.renderers.BaseRenderer.field_template_name"><code>field_template_name</code></a>.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.use_fieldset">
<code>BoundField.use_fieldset</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L319"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the value of this BoundField widget’s <code>use_fieldset</code> attribute.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.BoundField.widget_type">
<code>BoundField.widget_type</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L313"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns the lowercased class name of the wrapped field’s widget, with any trailing <code>input</code> or <code>widget</code> removed. This may be used when building forms where the layout is dependent upon the widget type. For example:</p> <pre data-language="markup">{% for field in form %}
    {% if field.widget_type == 'checkbox' %}
        # render one way
    {% else %}
        # render another way
    {% endif %}
{% endfor %}
</pre> </dd>
</dl> </section> <section id="s-methods-of-boundfield"> <h3 id="methods-of-boundfield">Methods of <code>BoundField</code>
</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.as_field_group">
<code>BoundField.as_field_group()</code> </dt> <dd>
<p>Renders the field using <a class="reference internal" href="#django.forms.BoundField.render" title="django.forms.BoundField.render"><code>BoundField.render()</code></a> with default values which renders the <code>BoundField</code>, including its label, help text and errors using the template’s <a class="reference internal" href="fields.html#django.forms.Field.template_name" title="django.forms.Field.template_name"><code>template_name</code></a> if set otherwise <a class="reference internal" href="renderers.html#django.forms.renderers.BaseRenderer.field_template_name" title="django.forms.renderers.BaseRenderer.field_template_name"><code>field_template_name</code></a></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.as_hidden">
<code>BoundField.as_hidden(attrs=None, **kwargs)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L125"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a string of HTML for representing this as an <code>&lt;input type="hidden"&gt;</code>.</p> <p><code>**kwargs</code> are passed to <a class="reference internal" href="#django.forms.BoundField.as_widget" title="django.forms.BoundField.as_widget"><code>as_widget()</code></a>.</p> <p>This method is primarily used internally. You should use a widget instead.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.as_widget">
<code>BoundField.as_widget(widget=None, attrs=None, only_initial=False)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L85"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Renders the field by rendering the passed widget, adding any HTML attributes passed as <code>attrs</code>. If no widget is specified, then the field’s default widget will be used.</p> <p><code>only_initial</code> is used by Django internals and should not be set explicitly.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.css_classes">
<code>BoundField.css_classes(extra_classes=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L220"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>When you use Django’s rendering shortcuts, CSS classes are used to indicate required form fields or fields that contain errors. If you’re manually rendering a form, you can access these CSS classes using the <code>css_classes</code> method:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(data={"message": ""})
&gt;&gt;&gt; f["message"].css_classes()
'required'
</pre> <p>If you want to provide some additional classes in addition to the error and required classes that may be required, you can provide those classes as an argument:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(data={"message": ""})
&gt;&gt;&gt; f["message"].css_classes("foo bar")
'foo bar required'
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.get_context">
<code>BoundField.get_context()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L82"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the template context for rendering the field. The available context is <code>field</code> being the instance of the bound field.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.label_tag">
<code>BoundField.label_tag(contents=None, attrs=None, label_suffix=None, tag=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L165"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Renders a label tag for the form field using the template specified by <a class="reference internal" href="#django.forms.Form.template_name_label" title="django.forms.Form.template_name_label"><code>Form.template_name_label</code></a>.</p> <p>The available context is:</p> <ul class="simple"> <li>
<code>field</code>: This instance of the <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a>.</li> <li>
<code>contents</code>: By default a concatenated string of <a class="reference internal" href="#django.forms.BoundField.label" title="django.forms.BoundField.label"><code>BoundField.label</code></a> and <a class="reference internal" href="#django.forms.Form.label_suffix" title="django.forms.Form.label_suffix"><code>Form.label_suffix</code></a> (or <a class="reference internal" href="fields.html#django.forms.Field.label_suffix" title="django.forms.Field.label_suffix"><code>Field.label_suffix</code></a>, if set). This can be overridden by the <code>contents</code> and <code>label_suffix</code> arguments.</li> <li>
<code>attrs</code>: A <code>dict</code> containing <code>for</code>, <a class="reference internal" href="#django.forms.Form.required_css_class" title="django.forms.Form.required_css_class"><code>Form.required_css_class</code></a>, and <code>id</code>. <code>id</code> is generated by the field’s widget <code>attrs</code> or <a class="reference internal" href="#django.forms.BoundField.auto_id" title="django.forms.BoundField.auto_id"><code>BoundField.auto_id</code></a>. Additional attributes can be provided by the <code>attrs</code> argument.</li> <li>
<code>use_tag</code>: A boolean which is <code>True</code> if the label has an <code>id</code>. If <code>False</code> the default template omits the <code>tag</code>.</li> <li>
<code>tag</code>: An optional string to customize the tag, defaults to <code>label</code>.</li> </ul> <div class="admonition tip"> <p class="admonition-title">Tip</p> <p>In your template <code>field</code> is the instance of the <code>BoundField</code>. Therefore <code>field.field</code> accesses <a class="reference internal" href="#django.forms.BoundField.field" title="django.forms.BoundField.field"><code>BoundField.field</code></a> being the field you declare, e.g. <code>forms.CharField</code>.</p> </div> <p>To separately render the label tag of a form field, you can call its <code>label_tag()</code> method:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactForm(data={"message": ""})
&gt;&gt;&gt; print(f["message"].label_tag())
&lt;label for="id_message"&gt;Message:&lt;/label&gt;
</pre> <p>If you’d like to customize the rendering this can be achieved by overriding the <a class="reference internal" href="#django.forms.Form.template_name_label" title="django.forms.Form.template_name_label"><code>Form.template_name_label</code></a> attribute or more generally by overriding the default template, see also <a class="reference internal" href="renderers.html#overriding-built-in-form-templates"><span class="std std-ref">Overriding built-in form templates</span></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.legend_tag">
<code>BoundField.legend_tag(contents=None, attrs=None, label_suffix=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L208"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calls <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>label_tag()</code></a> with <code>tag='legend'</code> to render the label with <code>&lt;legend&gt;</code> tags. This is useful when rendering radio and multiple checkbox widgets where <code>&lt;legend&gt;</code> may be more appropriate than a <code>&lt;label&gt;</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.render">
<code>BoundField.render(template_name=None, context=None, renderer=None)</code> </dt> <dd>
<p>The render method is called by <code>as_field_group</code>. All arguments are optional and default to:</p> <ul class="simple"> <li>
<code>template_name</code>: <a class="reference internal" href="#django.forms.BoundField.template_name" title="django.forms.BoundField.template_name"><code>BoundField.template_name</code></a>
</li> <li>
<code>context</code>: Value returned by <a class="reference internal" href="#django.forms.BoundField.get_context" title="django.forms.BoundField.get_context"><code>BoundField.get_context()</code></a>
</li> <li>
<code>renderer</code>: Value returned by <a class="reference internal" href="#django.forms.Form.default_renderer" title="django.forms.Form.default_renderer"><code>Form.default_renderer</code></a>
</li> </ul> <p>By passing <code>template_name</code> you can customize the template used for just a single call.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.BoundField.value">
<code>BoundField.value()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/forms/boundfield.py#L138"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Use this method to render the raw value of this field as it would be rendered by a <code>Widget</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; initial = {"subject": "welcome"}
&gt;&gt;&gt; unbound_form = ContactForm(initial=initial)
&gt;&gt;&gt; bound_form = ContactForm(data={"subject": "hi"}, initial=initial)
&gt;&gt;&gt; print(unbound_form["subject"].value())
welcome
&gt;&gt;&gt; print(bound_form["subject"].value())
hi
</pre> </dd>
</dl> </section> </section> <section id="s-customizing-boundfield"> <h2 id="custom-boundfield">Customizing <code>BoundField</code>
</h2> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.bound_field_class">
<code>Form.bound_field_class</code> </dt> 
</dl> <div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>Define a custom <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> class to use when rendering the form. This takes precedence over the project-level <a class="reference internal" href="renderers.html#django.forms.renderers.BaseRenderer.bound_field_class" title="django.forms.renderers.BaseRenderer.bound_field_class"><code>BaseRenderer.bound_field_class</code></a> (along with a custom <a class="reference internal" href="../settings.html#std-setting-FORM_RENDERER"><code>FORM_RENDERER</code></a>), but can be overridden by the field-level <a class="reference internal" href="fields.html#django.forms.Field.bound_field_class" title="django.forms.Field.bound_field_class"><code>Field.bound_field_class</code></a>.</p> <p>If not defined as a class variable, <code>bound_field_class</code> can be set via the <code>bound_field_class</code> argument in the <a class="reference internal" href="#django.forms.Form" title="django.forms.Form"><code>Form</code></a> or <a class="reference internal" href="fields.html#django.forms.Field" title="django.forms.Field"><code>Field</code></a> constructor.</p> <p>For compatibility reasons, a custom form field can still override <a class="reference internal" href="fields.html#django.forms.Field.get_bound_field" title="django.forms.Field.get_bound_field"><code>Field.get_bound_field()</code></a> to use a custom class, though any of the previous options are preferred.</p> <p>You may want to use a custom <a class="reference internal" href="#django.forms.BoundField" title="django.forms.BoundField"><code>BoundField</code></a> if you need to access some additional information about a form field in a template and using a subclass of <a class="reference internal" href="fields.html#django.forms.Field" title="django.forms.Field"><code>Field</code></a> isn’t sufficient.</p> <p>For example, if you have a <code>GPSCoordinatesField</code>, and want to be able to access additional information about the coordinates in a template, this could be implemented as follows:</p> <pre data-language="python">class GPSCoordinatesBoundField(BoundField):
    @property
    def country(self):
        """
        Return the country the coordinates lie in or None if it can't be
        determined.
        """
        value = self.value()
        if value:
            return get_country_from_coordinates(value)
        else:
            return None


class GPSCoordinatesField(Field):
    bound_field_class = GPSCoordinatesBoundField
</pre> <p>Now you can access the country in a template with <code>{{ form.coordinates.country }}</code>.</p> <p>You may also want to customize the default form field template rendering. For example, you can override <a class="reference internal" href="#django.forms.BoundField.label_tag" title="django.forms.BoundField.label_tag"><code>BoundField.label_tag()</code></a> to add a custom class:</p> <pre data-language="python">class StyledLabelBoundField(BoundField):
    def label_tag(self, contents=None, attrs=None, label_suffix=None, tag=None):
        attrs = attrs or {}
        attrs["class"] = "wide"
        return super().label_tag(contents, attrs, label_suffix, tag)


class UserForm(forms.Form):
    bound_field_class = StyledLabelBoundField
    name = CharField()
</pre> <p>This would update the default form rendering:</p> <pre data-language="pycon">&gt;&gt;&gt; f = UserForm()
&gt;&gt;&gt; print(f["name"].label_tag)
&lt;label for="id_name" class="wide"&gt;Name:&lt;/label&gt;
</pre> <p>To add a CSS class to the wrapping HTML element of all fields, a <code>BoundField</code> can be overridden to return a different collection of CSS classes:</p> <pre data-language="python">class WrappedBoundField(BoundField):
    def css_classes(self, extra_classes=None):
        parent_css_classes = super().css_classes(extra_classes)
        return f"field-class {parent_css_classes}".strip()


class UserForm(forms.Form):
    bound_field_class = WrappedBoundField
    name = CharField()
</pre> <p>This would update the form rendering as follows:</p> <pre data-language="pycon">&gt;&gt;&gt; f = UserForm()
&gt;&gt;&gt; print(f)
&lt;div class="field-class"&gt;&lt;label for="id_name"&gt;Name:&lt;/label&gt;&lt;input type="text" name="name" required id="id_name"&gt;&lt;/div&gt;
</pre> <p>Alternatively, to override the <code>BoundField</code> class at the project level, <a class="reference internal" href="renderers.html#django.forms.renderers.BaseRenderer.bound_field_class" title="django.forms.renderers.BaseRenderer.bound_field_class"><code>BaseRenderer.bound_field_class</code></a> can be defined on a custom <a class="reference internal" href="../settings.html#std-setting-FORM_RENDERER"><code>FORM_RENDERER</code></a>:</p> <div class="literal-block-wrapper docutils container" id="id1"> <div class="code-block-caption"><span class="caption-text"><code>mysite/renderers.py</code></span></div> <pre data-language="python">from django.forms.renderers import DjangoTemplates

from .forms import CustomBoundField


class CustomRenderer(DjangoTemplates):
    bound_field_class = CustomBoundField
</pre> </div> <div class="literal-block-wrapper docutils container" id="id2"> <div class="code-block-caption"><span class="caption-text"><code>settings.py</code></span></div> <pre data-language="python">FORM_RENDERER = "mysite.renderers.CustomRenderer"
</pre> </div> </section> <section id="s-binding-uploaded-files-to-a-form"> <h2 id="binding-uploaded-files">Binding uploaded files to a form</h2> <p>Dealing with forms that have <code>FileField</code> and <code>ImageField</code> fields is a little more complicated than a normal form.</p> <p>Firstly, in order to upload files, you’ll need to make sure that your <code>&lt;form&gt;</code> element correctly defines the <code>enctype</code> as <code>"multipart/form-data"</code>:</p> <pre data-language="html">&lt;form enctype="multipart/form-data" method="post" action="/foo/"&gt;
</pre> <p>Secondly, when you use the form, you need to bind the file data. File data is handled separately to normal form data, so when your form contains a <code>FileField</code> and <code>ImageField</code>, you will need to specify a second argument when you bind your form. So if we extend our ContactForm to include an <code>ImageField</code> called <code>mugshot</code>, we need to bind the file data containing the mugshot image:</p> <pre data-language="pycon"># Bound form with an image field
&gt;&gt;&gt; from django.core.files.uploadedfile import SimpleUploadedFile
&gt;&gt;&gt; data = {
...     "subject": "hello",
...     "message": "Hi there",
...     "sender": "foo@example.com",
...     "cc_myself": True,
... }
&gt;&gt;&gt; file_data = {"mugshot": SimpleUploadedFile("face.jpg", b"file data")}
&gt;&gt;&gt; f = ContactFormWithMugshot(data, file_data)
</pre> <p>In practice, you will usually specify <code>request.FILES</code> as the source of file data (just like you use <code>request.POST</code> as the source of form data):</p> <pre data-language="pycon"># Bound form with an image field, data from the request
&gt;&gt;&gt; f = ContactFormWithMugshot(request.POST, request.FILES)
</pre> <p>Constructing an unbound form is the same as always – omit both form data <em>and</em> file data:</p> <pre data-language="pycon"># Unbound form with an image field
&gt;&gt;&gt; f = ContactFormWithMugshot()
</pre> <section id="s-testing-for-multipart-forms"> <h3 id="testing-for-multipart-forms">Testing for multipart forms</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.forms.Form.is_multipart">
<code>Form.is_multipart()</code> </dt> 
</dl> <p>If you’re writing reusable views or templates, you may not know ahead of time whether your form is a multipart form or not. The <code>is_multipart()</code> method tells you whether the form requires multipart encoding for submission:</p> <pre data-language="pycon">&gt;&gt;&gt; f = ContactFormWithMugshot()
&gt;&gt;&gt; f.is_multipart()
True
</pre> <p>Here’s an example of how you might use this in a template:</p> <pre data-language="markup">{% if form.is_multipart %}
    &lt;form enctype="multipart/form-data" method="post" action="/foo/"&gt;
{% else %}
    &lt;form method="post" action="/foo/"&gt;
{% endif %}
{{ form }}
&lt;/form&gt;
</pre> </section> </section> <section id="s-subclassing-forms"> <h2 id="subclassing-forms">Subclassing forms</h2> <p>If you have multiple <code>Form</code> classes that share fields, you can use subclassing to remove redundancy.</p> <p>When you subclass a custom <code>Form</code> class, the resulting subclass will include all fields of the parent class(es), followed by the fields you define in the subclass.</p> <p>In this example, <code>ContactFormWithPriority</code> contains all the fields from <code>ContactForm</code>, plus an additional field, <code>priority</code>. The <code>ContactForm</code> fields are ordered first:</p> <pre data-language="pycon">&gt;&gt;&gt; class ContactFormWithPriority(ContactForm):
...     priority = forms.CharField()
...
&gt;&gt;&gt; f = ContactFormWithPriority(auto_id=False)
&gt;&gt;&gt; print(f)
&lt;div&gt;Subject:&lt;input type="text" name="subject" maxlength="100" required&gt;&lt;/div&gt;
&lt;div&gt;Message:&lt;textarea name="message" cols="40" rows="10" required&gt;&lt;/textarea&gt;&lt;/div&gt;
&lt;div&gt;Sender:&lt;input type="email" name="sender" required&gt;&lt;/div&gt;
&lt;div&gt;Cc myself:&lt;input type="checkbox" name="cc_myself"&gt;&lt;/div&gt;
&lt;div&gt;Priority:&lt;input type="text" name="priority" required&gt;&lt;/div&gt;
</pre> <p>It’s possible to subclass multiple forms, treating forms as mixins. In this example, <code>BeatleForm</code> subclasses both <code>PersonForm</code> and <code>InstrumentForm</code> (in that order), and its field list includes the fields from the parent classes:</p> <pre data-language="pycon">&gt;&gt;&gt; from django import forms
&gt;&gt;&gt; class PersonForm(forms.Form):
...     first_name = forms.CharField()
...     last_name = forms.CharField()
...
&gt;&gt;&gt; class InstrumentForm(forms.Form):
...     instrument = forms.CharField()
...
&gt;&gt;&gt; class BeatleForm(InstrumentForm, PersonForm):
...     haircut_type = forms.CharField()
...
&gt;&gt;&gt; b = BeatleForm(auto_id=False)
&gt;&gt;&gt; print(b)
&lt;div&gt;First name:&lt;input type="text" name="first_name" required&gt;&lt;/div&gt;
&lt;div&gt;Last name:&lt;input type="text" name="last_name" required&gt;&lt;/div&gt;
&lt;div&gt;Instrument:&lt;input type="text" name="instrument" required&gt;&lt;/div&gt;
&lt;div&gt;Haircut type:&lt;input type="text" name="haircut_type" required&gt;&lt;/div&gt;
</pre> <p>It’s possible to declaratively remove a <code>Field</code> inherited from a parent class by setting the name of the field to <code>None</code> on the subclass. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django import forms

&gt;&gt;&gt; class ParentForm(forms.Form):
...     name = forms.CharField()
...     age = forms.IntegerField()
...

&gt;&gt;&gt; class ChildForm(ParentForm):
...     name = None
...

&gt;&gt;&gt; list(ChildForm().fields)
['age']
</pre> </section> <section id="s-prefixes-for-forms"> <h2 id="form-prefix">Prefixes for forms</h2> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.Form.prefix">
<code>Form.prefix</code> </dt> 
</dl> <p>You can put several Django forms inside one <code>&lt;form&gt;</code> tag. To give each <code>Form</code> its own namespace, use the <code>prefix</code> keyword argument:</p> <pre data-language="pycon">&gt;&gt;&gt; mother = PersonForm(prefix="mother")
&gt;&gt;&gt; father = PersonForm(prefix="father")
&gt;&gt;&gt; print(mother)
&lt;div&gt;&lt;label for="id_mother-first_name"&gt;First name:&lt;/label&gt;&lt;input type="text" name="mother-first_name" required id="id_mother-first_name"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_mother-last_name"&gt;Last name:&lt;/label&gt;&lt;input type="text" name="mother-last_name" required id="id_mother-last_name"&gt;&lt;/div&gt;
&gt;&gt;&gt; print(father)
&lt;div&gt;&lt;label for="id_father-first_name"&gt;First name:&lt;/label&gt;&lt;input type="text" name="father-first_name" required id="id_father-first_name"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_father-last_name"&gt;Last name:&lt;/label&gt;&lt;input type="text" name="father-last_name" required id="id_father-last_name"&gt;&lt;/div&gt;
</pre> <p>The prefix can also be specified on the form class:</p> <pre data-language="pycon">&gt;&gt;&gt; class PersonForm(forms.Form):
...     ...
...     prefix = "person"
...
</pre> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/ref/forms/api/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/ref/forms/api/</a>
  </p>
</div>
