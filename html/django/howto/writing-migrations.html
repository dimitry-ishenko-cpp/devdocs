<section id="s-how-to-create-database-migrations"> <h1 id="how-to-create-database-migrations">How to create database migrations</h1> <p>This document explains how to structure and write database migrations for different scenarios you might encounter. For introductory material on migrations, see <a class="reference internal" href="../topics/migrations.html"><span class="doc">the topic guide</span></a>.</p> <section id="s-data-migrations-and-multiple-databases"> <h2 id="id1">Data migrations and multiple databases</h2> <p>When using multiple databases, you may need to figure out whether or not to run a migration against a particular database. For example, you may want to <strong>only</strong> run a migration on a particular database.</p> <p>In order to do that you can check the database connection’s alias inside a <code>RunPython</code> operation by looking at the <code>schema_editor.connection.alias</code> attribute:</p> <pre data-language="python">from django.db import migrations


def forwards(apps, schema_editor):
    if schema_editor.connection.alias != "default":
        return
    # Your migration code goes here


class Migration(migrations.Migration):
    dependencies = [
        # Dependencies to other migrations
    ]

    operations = [
        migrations.RunPython(forwards),
    ]
</pre> <p>You can also provide hints that will be passed to the <a class="reference internal" href="../topics/db/multi-db.html#allow_migrate" title="allow_migrate"><code>allow_migrate()</code></a> method of database routers as <code>**hints</code>:</p> <div class="literal-block-wrapper docutils container" id="id4"> <div class="code-block-caption"><span class="caption-text"><code>myapp/dbrouters.py</code></span></div> <pre data-language="python">class MyRouter:
    def allow_migrate(self, db, app_label, model_name=None, **hints):
        if "target_db" in hints:
            return db == hints["target_db"]
        return True
</pre> </div> <p>Then, to leverage this in your migrations, do the following:</p> <pre data-language="python">from django.db import migrations


def forwards(apps, schema_editor):
    # Your migration code goes here
    ...


class Migration(migrations.Migration):
    dependencies = [
        # Dependencies to other migrations
    ]

    operations = [
        migrations.RunPython(forwards, hints={"target_db": "default"}),
    ]
</pre> <p>If your <code>RunPython</code> or <code>RunSQL</code> operation only affects one model, it’s good practice to pass <code>model_name</code> as a hint to make it as transparent as possible to the router. This is especially important for reusable and third-party apps.</p> </section> <section id="s-migrations-that-add-unique-fields"> <h2 id="migrations-that-add-unique-fields">Migrations that add unique fields</h2> <p>Applying a “plain” migration that adds a unique non-nullable field to a table with existing rows will raise an error because the value used to populate existing rows is generated only once, thus breaking the unique constraint.</p> <p>Therefore, the following steps should be taken. In this example, we’ll add a non-nullable <a class="reference internal" href="../ref/models/fields.html#django.db.models.UUIDField" title="django.db.models.UUIDField"><code>UUIDField</code></a> with a default value. Modify the respective field according to your needs.</p> <ul> <li>Add the field on your model with <code>default=uuid.uuid4</code> and <code>unique=True</code> arguments (choose an appropriate default for the type of the field you’re adding).</li> <li>Run the <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a> command. This should generate a migration with an <code>AddField</code> operation.</li> <li>Generate two empty migration files for the same app by running <code>makemigrations myapp --empty</code> twice. We’ve renamed the migration files to give them meaningful names in the examples below.</li> <li>
<p>Copy the <code>AddField</code> operation from the auto-generated migration (the first of the three new files) to the last migration, change <code>AddField</code> to <code>AlterField</code>, and add imports of <code>uuid</code> and <code>models</code>. For example:</p> <div class="literal-block-wrapper docutils container" id="id5"> <div class="code-block-caption"><span class="caption-text"><code>0006_remove_uuid_null.py</code></span></div> <pre data-language="python"># Generated by Django A.B on YYYY-MM-DD HH:MM
from django.db import migrations, models
import uuid


class Migration(migrations.Migration):
    dependencies = [
        ("myapp", "0005_populate_uuid_values"),
    ]

    operations = [
        migrations.AlterField(
            model_name="mymodel",
            name="uuid",
            field=models.UUIDField(default=uuid.uuid4, unique=True),
        ),
    ]
</pre> </div> </li> <li>
<p>Edit the first migration file. The generated migration class should look similar to this:</p> <div class="literal-block-wrapper docutils container" id="id6"> <div class="code-block-caption"><span class="caption-text"><code>0004_add_uuid_field.py</code></span></div> <pre data-language="python">class Migration(migrations.Migration):
    dependencies = [
        ("myapp", "0003_auto_20150129_1705"),
    ]

    operations = [
        migrations.AddField(
            model_name="mymodel",
            name="uuid",
            field=models.UUIDField(default=uuid.uuid4, unique=True),
        ),
    ]
</pre> </div> <p>Change <code>unique=True</code> to <code>null=True</code> – this will create the intermediary null field and defer creating the unique constraint until we’ve populated unique values on all the rows.</p> </li> <li>
<p>In the first empty migration file, add a <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code>RunPython</code></a> or <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunSQL" title="django.db.migrations.operations.RunSQL"><code>RunSQL</code></a> operation to generate a unique value (UUID in the example) for each existing row. Also add an import of <code>uuid</code>. For example:</p> <div class="literal-block-wrapper docutils container" id="id7"> <div class="code-block-caption"><span class="caption-text"><code>0005_populate_uuid_values.py</code></span></div> <pre data-language="python"># Generated by Django A.B on YYYY-MM-DD HH:MM
from django.db import migrations
import uuid


def gen_uuid(apps, schema_editor):
    MyModel = apps.get_model("myapp", "MyModel")
    for row in MyModel.objects.all():
        row.uuid = uuid.uuid4()
        row.save(update_fields=["uuid"])


class Migration(migrations.Migration):
    dependencies = [
        ("myapp", "0004_add_uuid_field"),
    ]

    operations = [
        # omit reverse_code=... if you don't want the migration to be reversible.
        migrations.RunPython(gen_uuid, reverse_code=migrations.RunPython.noop),
    ]
</pre> </div> </li> <li>
<p>Now you can apply the migrations as usual with the <a class="reference internal" href="../ref/django-admin.html#django-admin-migrate"><code>migrate</code></a> command.</p> <p>Note there is a race condition if you allow objects to be created while this migration is running. Objects created after the <code>AddField</code> and before <code>RunPython</code> will have their original <code>uuid</code>’s overwritten.</p> </li> </ul> <section id="s-non-atomic-migrations"> <h3 id="id2">Non-atomic migrations</h3> <p>On databases that support DDL transactions (SQLite and PostgreSQL), migrations will run inside a transaction by default. For use cases such as performing data migrations on large tables, you may want to prevent a migration from running in a transaction by setting the <code>atomic</code> attribute to <code>False</code>:</p> <pre data-language="python">from django.db import migrations


class Migration(migrations.Migration):
    atomic = False
</pre> <p>Within such a migration, all operations are run without a transaction. It’s possible to execute parts of the migration inside a transaction using <a class="reference internal" href="../topics/db/transactions.html#django.db.transaction.atomic" title="django.db.transaction.atomic"><code>atomic()</code></a> or by passing <code>atomic=True</code> to <code>RunPython</code>.</p> <p>Here’s an example of a non-atomic data migration that updates a large table in smaller batches:</p> <pre data-language="python">import uuid

from django.db import migrations, transaction


def gen_uuid(apps, schema_editor):
    MyModel = apps.get_model("myapp", "MyModel")
    while MyModel.objects.filter(uuid__isnull=True).exists():
        with transaction.atomic():
            for row in MyModel.objects.filter(uuid__isnull=True)[:1000]:
                row.uuid = uuid.uuid4()
                row.save()


class Migration(migrations.Migration):
    atomic = False

    operations = [
        migrations.RunPython(gen_uuid),
    ]
</pre> <p>The <code>atomic</code> attribute doesn’t have an effect on databases that don’t support DDL transactions (e.g. MySQL, Oracle). (MySQL’s <a class="reference external" href="https://dev.mysql.com/doc/refman/en/atomic-ddl.html">atomic DDL statement support</a> refers to individual statements rather than multiple statements wrapped in a transaction that can be rolled back.)</p> </section> </section> <section id="s-controlling-the-order-of-migrations"> <h2 id="controlling-the-order-of-migrations">Controlling the order of migrations</h2> <p>Django determines the order in which migrations should be applied not by the filename of each migration, but by building a graph using two properties on the <code>Migration</code> class: <code>dependencies</code> and <code>run_before</code>.</p> <p>If you’ve used the <a class="reference internal" href="../ref/django-admin.html#django-admin-makemigrations"><code>makemigrations</code></a> command you’ve probably already seen <code>dependencies</code> in action because auto-created migrations have this defined as part of their creation process.</p> <p>The <code>dependencies</code> property is declared like this:</p> <pre data-language="python">from django.db import migrations


class Migration(migrations.Migration):
    dependencies = [
        ("myapp", "0123_the_previous_migration"),
    ]
</pre> <p>Usually this will be enough, but from time to time you may need to ensure that your migration runs <em>before</em> other migrations. This is useful, for example, to make third-party apps’ migrations run <em>after</em> your <a class="reference internal" href="../ref/settings.html#std-setting-AUTH_USER_MODEL"><code>AUTH_USER_MODEL</code></a> replacement.</p> <p>To achieve this, place all migrations that should depend on yours in the <code>run_before</code> attribute on your <code>Migration</code> class:</p> <pre data-language="python">class Migration(migrations.Migration):
    ...

    run_before = [
        ("third_party_app", "0001_do_awesome"),
    ]
</pre> <p>Prefer using <code>dependencies</code> over <code>run_before</code> when possible. You should only use <code>run_before</code> if it is undesirable or impractical to specify <code>dependencies</code> in the migration which you want to run after the one you are writing.</p> </section> <section id="s-migrating-data-between-third-party-apps"> <h2 id="migrating-data-between-third-party-apps">Migrating data between third-party apps</h2> <p>You can use a data migration to move data from one third-party application to another.</p> <p>If you plan to remove the old app later, you’ll need to set the <code>dependencies</code> property based on whether or not the old app is installed. Otherwise, you’ll have missing dependencies once you uninstall the old app. Similarly, you’ll need to catch <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#LookupError" title="(in Python v3.13)"><code>LookupError</code></a> in the <code>apps.get_model()</code> call that retrieves models from the old app. This approach allows you to deploy your project anywhere without first installing and then uninstalling the old app.</p> <p>Here’s a sample migration:</p> <div class="literal-block-wrapper docutils container" id="id8"> <div class="code-block-caption"><span class="caption-text"><code>myapp/migrations/0124_move_old_app_to_new_app.py</code></span></div> <pre data-language="python">from django.apps import apps as global_apps
from django.db import migrations


def forwards(apps, schema_editor):
    try:
        OldModel = apps.get_model("old_app", "OldModel")
    except LookupError:
        # The old app isn't installed.
        return

    NewModel = apps.get_model("new_app", "NewModel")
    NewModel.objects.bulk_create(
        NewModel(new_attribute=old_object.old_attribute)
        for old_object in OldModel.objects.all()
    )


class Migration(migrations.Migration):
    operations = [
        migrations.RunPython(forwards, migrations.RunPython.noop),
    ]
    dependencies = [
        ("myapp", "0123_the_previous_migration"),
        ("new_app", "0001_initial"),
    ]

    if global_apps.is_installed("old_app"):
        dependencies.append(("old_app", "0001_initial"))
</pre> </div> <p>Also consider what you want to happen when the migration is unapplied. You could either do nothing (as in the example above) or remove some or all of the data from the new application. Adjust the second argument of the <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.RunPython" title="django.db.migrations.operations.RunPython"><code>RunPython</code></a> operation accordingly.</p> </section> <section id="s-changing-a-manytomanyfield-to-use-a-through-model"> <h2 id="id3">Changing a <code>ManyToManyField</code> to use a <code>through</code> model</h2> <p>If you change a <a class="reference internal" href="../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> to use a <code>through</code> model, the default migration will delete the existing table and create a new one, losing the existing relations. To avoid this, you can use <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.SeparateDatabaseAndState" title="django.db.migrations.operations.SeparateDatabaseAndState"><code>SeparateDatabaseAndState</code></a> to rename the existing table to the new table name while telling the migration autodetector that the new model has been created. You can check the existing table name through <a class="reference internal" href="../ref/django-admin.html#django-admin-sqlmigrate"><code>sqlmigrate</code></a> or <a class="reference internal" href="../ref/django-admin.html#django-admin-dbshell"><code>dbshell</code></a>. You can check the new table name with the through model’s <code>_meta.db_table</code> property. Your new <code>through</code> model should use the same names for the <code>ForeignKey</code>s as Django did. Also if it needs any extra fields, they should be added in operations after <a class="reference internal" href="../ref/migration-operations.html#django.db.migrations.operations.SeparateDatabaseAndState" title="django.db.migrations.operations.SeparateDatabaseAndState"><code>SeparateDatabaseAndState</code></a>.</p> <p>For example, if we had a <code>Book</code> model with a <code>ManyToManyField</code> linking to <code>Author</code>, we could add a through model <code>AuthorBook</code> with a new field <code>is_primary</code>, like so:</p> <pre data-language="python">from django.db import migrations, models
import django.db.models.deletion


class Migration(migrations.Migration):
    dependencies = [
        ("core", "0001_initial"),
    ]

    operations = [
        migrations.SeparateDatabaseAndState(
            database_operations=[
                # Old table name from checking with sqlmigrate, new table
                # name from AuthorBook._meta.db_table.
                migrations.RunSQL(
                    sql="ALTER TABLE core_book_authors RENAME TO core_authorbook",
                    reverse_sql="ALTER TABLE core_authorbook RENAME TO core_book_authors",
                ),
            ],
            state_operations=[
                migrations.CreateModel(
                    name="AuthorBook",
                    fields=[
                        (
                            "id",
                            models.AutoField(
                                auto_created=True,
                                primary_key=True,
                                serialize=False,
                                verbose_name="ID",
                            ),
                        ),
                        (
                            "author",
                            models.ForeignKey(
                                on_delete=django.db.models.deletion.DO_NOTHING,
                                to="core.Author",
                            ),
                        ),
                        (
                            "book",
                            models.ForeignKey(
                                on_delete=django.db.models.deletion.DO_NOTHING,
                                to="core.Book",
                            ),
                        ),
                    ],
                ),
                migrations.AlterField(
                    model_name="book",
                    name="authors",
                    field=models.ManyToManyField(
                        to="core.Author",
                        through="core.AuthorBook",
                    ),
                ),
            ],
        ),
        migrations.AddField(
            model_name="authorbook",
            name="is_primary",
            field=models.BooleanField(default=False),
        ),
    ]
</pre> </section> <section id="s-changing-an-unmanaged-model-to-managed"> <h2 id="changing-an-unmanaged-model-to-managed">Changing an unmanaged model to managed</h2> <p>If you want to change an unmanaged model (<a class="reference internal" href="../ref/models/options.html#django.db.models.Options.managed" title="django.db.models.Options.managed"><code>managed=False</code></a>) to managed, you must remove <code>managed=False</code> and generate a migration before making other schema-related changes to the model, since schema changes that appear in the migration that contains the operation to change <code>Meta.managed</code> may not be applied.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/howto/writing-migrations/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/howto/writing-migrations/</a>
  </p>
</div>
