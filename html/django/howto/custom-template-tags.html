<section id="s-how-to-create-custom-template-tags-and-filters"> <h1 id="how-to-create-custom-template-tags-and-filters">How to create custom template tags and filters</h1> <p>Django’s template language comes with a wide variety of <a class="reference internal" href="../ref/templates/builtins.html"><span class="doc">built-in tags and filters</span></a> designed to address the presentation logic needs of your application. Nevertheless, you may find yourself needing functionality that is not covered by the core set of template primitives. You can extend the template engine by defining custom tags and filters using Python, and then make them available to your templates using the <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-load"><code>{% load %}</code></a> tag.</p> <section id="s-code-layout"> <h2 id="code-layout">Code layout</h2> <p>The most common place to specify custom template tags and filters is inside a Django app. If they relate to an existing app, it makes sense to bundle them there; otherwise, they can be added to a new app. When a Django app is added to <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, any tags it defines in the conventional location described below are automatically made available to load within templates.</p> <p>The app should contain a <code>templatetags</code> directory, at the same level as <code>models.py</code>, <code>views.py</code>, etc. If this doesn’t already exist, create it - don’t forget the <code>__init__.py</code> file to ensure the directory is treated as a Python package.</p> <div class="admonition-development-server-won-t-automatically-restart admonition"> <p class="admonition-title">Development server won’t automatically restart</p> <p>After adding the <code>templatetags</code> module, you will need to restart your server before you can use the tags or filters in templates.</p> </div> <p>Your custom tags and filters will live in a module inside the <code>templatetags</code> directory. The name of the module file is the name you’ll use to load the tags later, so be careful to pick a name that won’t clash with custom tags and filters in another app.</p> <p>For example, if your custom tags/filters are in a file called <code>poll_extras.py</code>, your app layout might look like this:</p> <pre data-language="text">polls/
    __init__.py
    models.py
    templatetags/
        __init__.py
        poll_extras.py
    views.py
</pre> <p>And in your template you would use the following:</p> <pre data-language="markup">{% load poll_extras %}
</pre> <p>The app that contains the custom tags must be in <a class="reference internal" href="../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> in order for the <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-load"><code>{% load %}</code></a> tag to work. This is a security feature: It allows you to host Python code for many template libraries on a single host machine without enabling access to all of them for every Django installation.</p> <p>There’s no limit on how many modules you put in the <code>templatetags</code> package. Just keep in mind that a <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-load"><code>{% load %}</code></a> statement will load tags/filters for the given Python module name, not the name of the app.</p> <p>To be a valid tag library, the module must contain a module-level variable named <code>register</code> that is a <code>template.Library</code> instance, in which all the tags and filters are registered. So, near the top of your module, put the following:</p> <pre data-language="python">from django import template

register = template.Library()
</pre> <p>Alternatively, template tag modules can be registered through the <code>'libraries'</code> argument to <a class="reference internal" href="../topics/templates.html#django.template.backends.django.DjangoTemplates" title="django.template.backends.django.DjangoTemplates"><code>DjangoTemplates</code></a>. This is useful if you want to use a different label from the template tag module name when loading template tags. It also enables you to register tags without installing an application.</p> <div class="admonition-behind-the-scenes admonition"> <p class="admonition-title">Behind the scenes</p> <p>For a ton of examples, read the source code for Django’s default filters and tags. They’re in <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/template/defaultfilters.py">django/template/defaultfilters.py</a> and <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/template/defaulttags.py">django/template/defaulttags.py</a>, respectively.</p> <p>For more information on the <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-load"><code>load</code></a> tag, read its documentation.</p> </div> </section> <section id="s-writing-custom-template-filters"> <h2 id="howto-writing-custom-template-filters">Writing custom template filters</h2> <p>Custom filters are Python functions that take one or two arguments:</p> <ul class="simple"> <li>The value of the variable (input) – not necessarily a string.</li> <li>The value of the argument – this can have a default value, or be left out altogether.</li> </ul> <p>For example, in the filter <code>{{ var|foo:"bar" }}</code>, the filter <code>foo</code> would be passed the variable <code>var</code> and the argument <code>"bar"</code>.</p> <p>Since the template language doesn’t provide exception handling, any exception raised from a template filter will be exposed as a server error. Thus, filter functions should avoid raising exceptions if there is a reasonable fallback value to return. In case of input that represents a clear bug in a template, raising an exception may still be better than silent failure which hides the bug.</p> <p>Here’s an example filter definition:</p> <pre data-language="python">def cut(value, arg):
    """Removes all values of arg from the given string"""
    return value.replace(arg, "")
</pre> <p>And here’s an example of how that filter would be used:</p> <pre data-language="markup">{{ somevariable|cut:"0" }}
</pre> <p>Most filters don’t take arguments. In this case, leave the argument out of your function:</p> <pre data-language="python">def lower(value):  # Only one argument.
    """Converts a string into all lowercase"""
    return value.lower()
</pre> <section id="s-registering-custom-filters"> <h3 id="registering-custom-filters">Registering custom filters</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.template.Library.filter">
<code>django.template.Library.filter()</code> </dt> 
</dl> <p>Once you’ve written your filter definition, you need to register it with your <code>Library</code> instance, to make it available to Django’s template language:</p> <pre data-language="python">register.filter("cut", cut)
register.filter("lower", lower)
</pre> <p>The <code>Library.filter()</code> method takes two arguments:</p> <ol class="arabic simple"> <li>The name of the filter – a string.</li> <li>The compilation function – a Python function (not the name of the function as a string).</li> </ol> <p>You can use <code>register.filter()</code> as a decorator instead:</p> <pre data-language="python">@register.filter(name="cut")
def cut(value, arg):
    return value.replace(arg, "")


@register.filter
def lower(value):
    return value.lower()
</pre> <p>If you leave off the <code>name</code> argument, as in the second example above, Django will use the function’s name as the filter name.</p> <p>Finally, <code>register.filter()</code> also accepts three keyword arguments, <code>is_safe</code>, <code>needs_autoescape</code>, and <code>expects_localtime</code>. These arguments are described in <a class="reference internal" href="#filters-auto-escaping"><span class="std std-ref">filters and auto-escaping</span></a> and <a class="reference internal" href="#filters-timezones"><span class="std std-ref">filters and time zones</span></a> below.</p> </section> <section id="s-template-filters-that-expect-strings"> <h3 id="template-filters-that-expect-strings">Template filters that expect strings</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.template.defaultfilters.stringfilter">
<code>django.template.defaultfilters.stringfilter()</code> </dt> 
</dl> <p>If you’re writing a template filter that only expects a string as the first argument, you should use the decorator <code>stringfilter</code>. This will convert an object to its string value before being passed to your function:</p> <pre data-language="python">from django import template
from django.template.defaultfilters import stringfilter

register = template.Library()


@register.filter
@stringfilter
def lower(value):
    return value.lower()
</pre> <p>This way, you’ll be able to pass, say, an integer to this filter, and it won’t cause an <code>AttributeError</code> (because integers don’t have <code>lower()</code> methods).</p> </section> <section id="s-filters-and-auto-escaping"> <h3 id="filters-auto-escaping">Filters and auto-escaping</h3> <p>When writing a custom filter, give some thought to how the filter will interact with Django’s auto-escaping behavior. Note that two types of strings can be passed around inside the template code:</p> <ul> <li>
<strong>Raw strings</strong> are the native Python strings. On output, they’re escaped if auto-escaping is in effect and presented unchanged, otherwise.</li> <li>
<p><strong>Safe strings</strong> are strings that have been marked safe from further escaping at output time. Any necessary escaping has already been done. They’re commonly used for output that contains raw HTML that is intended to be interpreted as-is on the client side.</p> <p>Internally, these strings are of type <a class="reference internal" href="../ref/utils.html#django.utils.safestring.SafeString" title="django.utils.safestring.SafeString"><code>SafeString</code></a>. You can test for them using code like:</p> <pre data-language="python">from django.utils.safestring import SafeString

if isinstance(value, SafeString):
    # Do something with the "safe" string.
    ...
</pre> </li> </ul> <p>Template filter code falls into one of two situations:</p> <ol class="arabic"> <li>
<p>Your filter does not introduce any HTML-unsafe characters (<code>&lt;</code>, <code>&gt;</code>, <code>'</code>, <code>"</code> or <code>&amp;</code>) into the result that were not already present. In this case, you can let Django take care of all the auto-escaping handling for you. All you need to do is set the <code>is_safe</code> flag to <code>True</code> when you register your filter function, like so:</p> <pre data-language="python">@register.filter(is_safe=True)
def myfilter(value):
    return value
</pre> <p>This flag tells Django that if a “safe” string is passed into your filter, the result will still be “safe” and if a non-safe string is passed in, Django will automatically escape it, if necessary.</p> <p>You can think of this as meaning “this filter is safe – it doesn’t introduce any possibility of unsafe HTML.”</p> <p>The reason <code>is_safe</code> is necessary is because there are plenty of normal string operations that will turn a <code>SafeData</code> object back into a normal <code>str</code> object and, rather than try to catch them all, which would be very difficult, Django repairs the damage after the filter has completed.</p> <p>For example, suppose you have a filter that adds the string <code>xx</code> to the end of any input. Since this introduces no dangerous HTML characters to the result (aside from any that were already present), you should mark your filter with <code>is_safe</code>:</p> <pre data-language="python">@register.filter(is_safe=True)
def add_xx(value):
    return "%sxx" % value
</pre> <p>When this filter is used in a template where auto-escaping is enabled, Django will escape the output whenever the input is not already marked as “safe”.</p> <p>By default, <code>is_safe</code> is <code>False</code>, and you can omit it from any filters where it isn’t required.</p> <p>Be careful when deciding if your filter really does leave safe strings as safe. If you’re <em>removing</em> characters, you might inadvertently leave unbalanced HTML tags or entities in the result. For example, removing a <code>&gt;</code> from the input might turn <code>&lt;a&gt;</code> into <code>&lt;a</code>, which would need to be escaped on output to avoid causing problems. Similarly, removing a semicolon (<code>;</code>) can turn <code>&amp;amp;</code> into <code>&amp;amp</code>, which is no longer a valid entity and thus needs further escaping. Most cases won’t be nearly this tricky, but keep an eye out for any problems like that when reviewing your code.</p> <p>Marking a filter <code>is_safe</code> will coerce the filter’s return value to a string. If your filter should return a boolean or other non-string value, marking it <code>is_safe</code> will probably have unintended consequences (such as converting a boolean False to the string ‘False’).</p> </li> <li>
<p>Alternatively, your filter code can manually take care of any necessary escaping. This is necessary when you’re introducing new HTML markup into the result. You want to mark the output as safe from further escaping so that your HTML markup isn’t escaped further, so you’ll need to handle the input yourself.</p> <p>To mark the output as a safe string, use <a class="reference internal" href="../ref/utils.html#django.utils.safestring.mark_safe" title="django.utils.safestring.mark_safe"><code>django.utils.safestring.mark_safe()</code></a>.</p> <p>Be careful, though. You need to do more than just mark the output as safe. You need to ensure it really <em>is</em> safe, and what you do depends on whether auto-escaping is in effect. The idea is to write filters that can operate in templates where auto-escaping is either on or off in order to make things easier for your template authors.</p> <p>In order for your filter to know the current auto-escaping state, set the <code>needs_autoescape</code> flag to <code>True</code> when you register your filter function. (If you don’t specify this flag, it defaults to <code>False</code>). This flag tells Django that your filter function wants to be passed an extra keyword argument, called <code>autoescape</code>, that is <code>True</code> if auto-escaping is in effect and <code>False</code> otherwise. It is recommended to set the default of the <code>autoescape</code> parameter to <code>True</code>, so that if you call the function from Python code it will have escaping enabled by default.</p> <p>For example, let’s write a filter that emphasizes the first character of a string:</p> <pre data-language="python">from django import template
from django.utils.html import conditional_escape
from django.utils.safestring import mark_safe

register = template.Library()


@register.filter(needs_autoescape=True)
def initial_letter_filter(text, autoescape=True):
    first, other = text[0], text[1:]
    if autoescape:
        esc = conditional_escape
    else:
        esc = lambda x: x
    result = "&lt;strong&gt;%s&lt;/strong&gt;%s" % (esc(first), esc(other))
    return mark_safe(result)
</pre> <p>The <code>needs_autoescape</code> flag and the <code>autoescape</code> keyword argument mean that our function will know whether automatic escaping is in effect when the filter is called. We use <code>autoescape</code> to decide whether the input data needs to be passed through <code>django.utils.html.conditional_escape</code> or not. (In the latter case, we use the identity function as the “escape” function.) The <code>conditional_escape()</code> function is like <code>escape()</code> except it only escapes input that is <strong>not</strong> a <code>SafeData</code> instance. If a <code>SafeData</code> instance is passed to <code>conditional_escape()</code>, the data is returned unchanged.</p> <p>Finally, in the above example, we remember to mark the result as safe so that our HTML is inserted directly into the template without further escaping.</p> <p>There’s no need to worry about the <code>is_safe</code> flag in this case (although including it wouldn’t hurt anything). Whenever you manually handle the auto-escaping issues and return a safe string, the <code>is_safe</code> flag won’t change anything either way.</p> </li> </ol> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Avoiding XSS vulnerabilities when reusing built-in filters</p> <p>Django’s built-in filters have <code>autoescape=True</code> by default in order to get the proper autoescaping behavior and avoid a cross-site script vulnerability.</p> <p>In older versions of Django, be careful when reusing Django’s built-in filters as <code>autoescape</code> defaults to <code>None</code>. You’ll need to pass <code>autoescape=True</code> to get autoescaping.</p> <p>For example, if you wanted to write a custom filter called <code>urlize_and_linebreaks</code> that combined the <a class="reference internal" href="../ref/templates/builtins.html#std-templatefilter-urlize"><code>urlize</code></a> and <a class="reference internal" href="../ref/templates/builtins.html#std-templatefilter-linebreaksbr"><code>linebreaksbr</code></a> filters, the filter would look like:</p> <pre data-language="python">from django.template.defaultfilters import linebreaksbr, urlize


@register.filter(needs_autoescape=True)
def urlize_and_linebreaks(text, autoescape=True):
    return linebreaksbr(urlize(text, autoescape=autoescape), autoescape=autoescape)
</pre> <p>Then:</p> <pre data-language="markup">{{ comment|urlize_and_linebreaks }}
</pre> <p>would be equivalent to:</p> <pre data-language="markup">{{ comment|urlize|linebreaksbr }}
</pre> </div> </section> <section id="s-filters-and-time-zones"> <h3 id="filters-timezones">Filters and time zones</h3> <p>If you write a custom filter that operates on <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.13)"><code>datetime</code></a> objects, you’ll usually register it with the <code>expects_localtime</code> flag set to <code>True</code>:</p> <pre data-language="python">@register.filter(expects_localtime=True)
def businesshours(value):
    try:
        return 9 &lt;= value.hour &lt; 17
    except AttributeError:
        return ""
</pre> <p>When this flag is set, if the first argument to your filter is a time zone aware datetime, Django will convert it to the current time zone before passing it to your filter when appropriate, according to <a class="reference internal" href="../topics/i18n/timezones.html#time-zones-in-templates"><span class="std std-ref">rules for time zones conversions in templates</span></a>.</p> </section> </section> <section id="s-writing-custom-template-tags"> <h2 id="howto-writing-custom-template-tags">Writing custom template tags</h2> <p>Tags are more complex than filters, because tags can do anything. Django provides a number of shortcuts that make writing most types of tags easier. First we’ll explore those shortcuts, then explain how to write a tag from scratch for those cases when the shortcuts aren’t powerful enough.</p> <section id="s-simple-tags"> <h3 id="howto-custom-template-tags-simple-tags">Simple tags</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.template.Library.simple_tag">
<code>django.template.Library.simple_tag()</code> </dt> 
</dl> <p>Many template tags take a number of arguments – strings or template variables – and return a result after doing some processing based solely on the input arguments and some external information. For example, a <code>current_time</code> tag might accept a format string and return the time as a string formatted accordingly.</p> <p>To ease the creation of these types of tags, Django provides a helper function, <code>simple_tag</code>. This function, which is a method of <code>django.template.Library</code>, takes a function that accepts any number of arguments, wraps it in a <code>render</code> function and the other necessary bits mentioned above and registers it with the template system.</p> <p>Our <code>current_time</code> function could thus be written like this:</p> <pre data-language="python">import datetime
from django import template

register = template.Library()


@register.simple_tag
def current_time(format_string):
    return datetime.datetime.now().strftime(format_string)
</pre> <p>A few things to note about the <code>simple_tag</code> helper function:</p> <ul class="simple"> <li>Checking for the required number of arguments, etc., has already been done by the time our function is called, so we don’t need to do that.</li> <li>The quotes around the argument (if any) have already been stripped away, so we receive a plain string.</li> <li>If the argument was a template variable, our function is passed the current value of the variable, not the variable itself.</li> </ul> <p>Unlike other tag utilities, <code>simple_tag</code> passes its output through <a class="reference internal" href="../ref/utils.html#django.utils.html.conditional_escape" title="django.utils.html.conditional_escape"><code>conditional_escape()</code></a> if the template context is in autoescape mode, to ensure correct HTML and protect you from XSS vulnerabilities.</p> <p>If additional escaping is not desired, you will need to use <a class="reference internal" href="../ref/utils.html#django.utils.safestring.mark_safe" title="django.utils.safestring.mark_safe"><code>mark_safe()</code></a> if you are absolutely sure that your code does not contain XSS vulnerabilities. For building small HTML snippets, use of <a class="reference internal" href="../ref/utils.html#django.utils.html.format_html" title="django.utils.html.format_html"><code>format_html()</code></a> instead of <code>mark_safe()</code> is strongly recommended.</p> <p>If your template tag needs to access the current context, you can use the <code>takes_context</code> argument when registering your tag:</p> <pre data-language="python">@register.simple_tag(takes_context=True)
def current_time(context, format_string):
    timezone = context["timezone"]
    return your_get_current_time_method(timezone, format_string)
</pre> <p>Note that the first argument <em>must</em> be called <code>context</code>.</p> <p>For more information on how the <code>takes_context</code> option works, see the section on <a class="reference internal" href="#howto-custom-template-tags-inclusion-tags"><span class="std std-ref">inclusion tags</span></a>.</p> <p>If you need to rename your tag, you can provide a custom name for it:</p> <pre data-language="python">register.simple_tag(lambda x: x - 1, name="minusone")


@register.simple_tag(name="minustwo")
def some_function(value):
    return value - 2
</pre> <p><code>simple_tag</code> functions may accept any number of positional or keyword arguments. For example:</p> <pre data-language="python">@register.simple_tag
def my_tag(a, b, *args, **kwargs):
    warning = kwargs["warning"]
    profile = kwargs["profile"]
    ...
    return ...
</pre> <p>Then in the template any number of arguments, separated by spaces, may be passed to the template tag. Like in Python, the values for keyword arguments are set using the equal sign (”<code>=</code>”) and must be provided after the positional arguments. For example:</p> <pre data-language="markup">{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}
</pre> <p>It’s possible to store the tag results in a template variable rather than directly outputting it. This is done by using the <code>as</code> argument followed by the variable name. Doing so enables you to output the content yourself where you see fit:</p> <pre data-language="markup">{% current_time "%Y-%m-%d %I:%M %p" as the_time %}
&lt;p&gt;The time is {{ the_time }}.&lt;/p&gt;
</pre> </section> <section id="s-simple-block-tags"> <h3 id="howto-custom-template-tags-simple-block-tags">Simple block tags</h3> <div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <dl class="py method"> <dt class="sig sig-object py" id="django.template.Library.simple_block_tag">
<code>django.template.Library.simple_block_tag()</code> </dt> 
</dl> <p>When a section of rendered template needs to be passed into a custom tag, Django provides the <code>simple_block_tag</code> helper function to accomplish this. Similar to <a class="reference internal" href="#django.template.Library.simple_tag" title="django.template.Library.simple_tag"><code>simple_tag()</code></a>, this function accepts a custom tag function, but with the additional <code>content</code> argument, which contains the rendered content as defined inside the tag. This allows dynamic template sections to be easily incorporated into custom tags.</p> <p>For example, a custom block tag which creates a chart could look like this:</p> <pre data-language="python">from django import template
from myapp.charts import render_chart

register = template.Library()


@register.simple_block_tag
def chart(content):
    return render_chart(source=content)
</pre> <p>The <code>content</code> argument contains everything in between the <code>{% chart %}</code> and <code>{% endchart %}</code> tags:</p> <pre data-language="markup">{% chart %}
  digraph G {
      label = "Chart for {{ request.user }}"
      A -&gt; {B C}
  }
{% endchart %}
</pre> <p>If there are other template tags or variables inside the <code>content</code> block, they will be rendered before being passed to the tag function. In the example above, <code>request.user</code> will be resolved by the time <code>render_chart</code> is called.</p> <p>Block tags are closed with <code>end{name}</code> (for example, <code>endchart</code>). This can be customized with the <code>end_name</code> parameter:</p> <pre data-language="python">@register.simple_block_tag(end_name="endofchart")
def chart(content):
    return render_chart(source=content)
</pre> <p>Which would require a template definition like this:</p> <pre data-language="markup">{% chart %}
  digraph G {
      label = "Chart for {{ request.user }}"
      A -&gt; {B C}
  }
{% endofchart %}
</pre> <p>A few things to note about <code>simple_block_tag</code>:</p> <ul class="simple"> <li>The first argument must be called <code>content</code>, and it will contain the contents of the template tag as a rendered string.</li> <li>Variables passed to the tag are not included in the rendering context of the content, as would be when using the <code>{% with %}</code> tag.</li> </ul> <p>Just like <a class="reference internal" href="#howto-custom-template-tags-simple-tags"><span class="std std-ref">simple_tag</span></a>, <code>simple_block_tag</code>:</p> <ul class="simple"> <li>Validates the quantity and quality of the arguments.</li> <li>Strips quotes from arguments if necessary.</li> <li>Escapes the output accordingly.</li> <li>Supports passing <code>takes_context=True</code> at registration time to access context. Note that in this case, the first argument to the custom function <em>must</em> be called <code>context</code>, and <code>content</code> must follow.</li> <li>Supports renaming the tag by passing the <code>name</code> argument when registering.</li> <li>Supports accepting any number of positional or keyword arguments.</li> <li>Supports storing the result in a template variable using the <code>as</code> variant.</li> </ul> <div class="admonition-content-escaping admonition"> <p class="admonition-title">Content Escaping</p> <p><code>simple_block_tag</code> behaves similarly to <code>simple_tag</code> regarding auto-escaping. For details on escaping and safety, refer to <code>simple_tag</code>. Because the <code>content</code> argument has already been rendered by Django, it is already escaped.</p> </div> <section id="s-a-complete-example"> <h4 id="a-complete-example">A complete example</h4> <p>Consider a custom template tag that generates a message box that supports multiple message levels and content beyond a simple phrase. This could be implemented using a <code>simple_block_tag</code> as follows:</p> <div class="literal-block-wrapper docutils container" id="id1"> <div class="code-block-caption"><span class="caption-text"><code>testapp/templatetags/testapptags.py</code></span></div> <pre data-language="python">from django import template
from django.utils.html import format_html


register = template.Library()


@register.simple_block_tag(takes_context=True)
def msgbox(context, content, level):
    format_kwargs = {
        "level": level.lower(),
        "level_title": level.capitalize(),
        "content": content,
        "open": " open" if level.lower() == "error" else "",
        "site": context.get("site", "My Site"),
    }
    result = """
    &lt;div class="msgbox {level}"&gt;
      &lt;details{open}&gt;
        &lt;summary&gt;
          &lt;strong&gt;{level_title}&lt;/strong&gt;: Please read for &lt;i&gt;{site}&lt;/i&gt;
        &lt;/summary&gt;
        &lt;p&gt;
          {content}
        &lt;/p&gt;
      &lt;/details&gt;
    &lt;/div&gt;
    """
    return format_html(result, **format_kwargs)
</pre> </div> <p>When combined with a minimal view and corresponding template, as shown here:</p> <div class="literal-block-wrapper docutils container" id="id2"> <div class="code-block-caption"><span class="caption-text"><code>testapp/views.py</code></span></div> <pre data-language="python">from django.shortcuts import render


def simpleblocktag_view(request):
    return render(request, "test.html", context={"site": "Important Site"})
</pre> </div> <div class="literal-block-wrapper docutils container" id="id3"> <div class="code-block-caption"><span class="caption-text"><code>testapp/templates/test.html</code></span></div> <pre data-language="markup">{% extends "base.html" %}

{% load testapptags %}

{% block content %}

  {% msgbox level="error" %}
    Please fix all errors. Further documentation can be found at
    &lt;a href="http://example.com"&gt;Docs&lt;/a&gt;.
  {% endmsgbox %}

  {% msgbox level="info" %}
    More information at: &lt;a href="http://othersite.com"&gt;Other Site&lt;/a&gt;/
  {% endmsgbox %}

{% endblock %}
</pre> </div> <p>The following HTML is produced as the rendered output:</p> <pre data-language="html">&lt;div class="msgbox error"&gt;
  &lt;details open&gt;
    &lt;summary&gt;
      &lt;strong&gt;Error&lt;/strong&gt;: Please read for &lt;i&gt;Important Site&lt;/i&gt;
    &lt;/summary&gt;
    &lt;p&gt;
      Please fix all errors. Further documentation can be found at
      &lt;a href="http://example.com"&gt;Docs&lt;/a&gt;.
    &lt;/p&gt;
  &lt;/details&gt;
&lt;/div&gt;

&lt;div class="msgbox info"&gt;
  &lt;details&gt;
    &lt;summary&gt;
      &lt;strong&gt;Info&lt;/strong&gt;: Please read for &lt;i&gt;Important Site&lt;/i&gt;
    &lt;/summary&gt;
    &lt;p&gt;
      More information at: &lt;a href="http://othersite.com"&gt;Other Site&lt;/a&gt;
    &lt;/p&gt;
  &lt;/details&gt;
&lt;/div&gt;
</pre> </section> </section> <section id="s-inclusion-tags"> <h3 id="howto-custom-template-tags-inclusion-tags">Inclusion tags</h3> <dl class="py method"> <dt class="sig sig-object py" id="django.template.Library.inclusion_tag">
<code>django.template.Library.inclusion_tag()</code> </dt> 
</dl> <p>Another common type of template tag is the type that displays some data by rendering <em>another</em> template. For example, Django’s admin interface uses custom template tags to display the buttons along the bottom of the “add/change” form pages. Those buttons always look the same, but the link targets change depending on the object being edited – so they’re a perfect case for using a small template that is filled with details from the current object. (In the admin’s case, this is the <code>submit_row</code> tag.)</p> <p>These sorts of tags are called “inclusion tags”.</p> <p>Writing inclusion tags is probably best demonstrated by example. Let’s write a tag that outputs a list of choices for a given <code>Poll</code> object, such as was created in the <a class="reference internal" href="../intro/tutorial02.html#creating-models"><span class="std std-ref">tutorials</span></a>. We’ll use the tag like this:</p> <pre data-language="markup">{% show_results poll %}
</pre> <p>…and the output will be something like this:</p> <pre data-language="html">&lt;ul&gt;
  &lt;li&gt;First choice&lt;/li&gt;
  &lt;li&gt;Second choice&lt;/li&gt;
  &lt;li&gt;Third choice&lt;/li&gt;
&lt;/ul&gt;
</pre> <p>First, define the function that takes the argument and produces a dictionary of data for the result. The important point here is we only need to return a dictionary, not anything more complex. This will be used as a template context for the template fragment. Example:</p> <pre data-language="python">def show_results(poll):
    choices = poll.choice_set.all()
    return {"choices": choices}
</pre> <p>Next, create the template used to render the tag’s output. This template is a fixed feature of the tag: the tag writer specifies it, not the template designer. Following our example, the template is very short:</p> <pre data-language="markup">&lt;ul&gt;
{% for choice in choices %}
    &lt;li&gt; {{ choice }} &lt;/li&gt;
{% endfor %}
&lt;/ul&gt;
</pre> <p>Now, create and register the inclusion tag by calling the <code>inclusion_tag()</code> method on a <code>Library</code> object. Following our example, if the above template is in a file called <code>results.html</code> in a directory that’s searched by the template loader, we’d register the tag like this:</p> <pre data-language="python"># Here, register is a django.template.Library instance, as before
@register.inclusion_tag("results.html")
def show_results(poll): ...
</pre> <p>Alternatively it is possible to register the inclusion tag using a <a class="reference internal" href="../ref/templates/api.html#django.template.Template" title="django.template.Template"><code>django.template.Template</code></a> instance:</p> <pre data-language="python">from django.template.loader import get_template

t = get_template("results.html")
register.inclusion_tag(t)(show_results)
</pre> <p>…when first creating the function.</p> <p>Sometimes, your inclusion tags might require a large number of arguments, making it a pain for template authors to pass in all the arguments and remember their order. To solve this, Django provides a <code>takes_context</code> option for inclusion tags. If you specify <code>takes_context</code> in creating a template tag, the tag will have no required arguments, and the underlying Python function will have one argument – the template context as of when the tag was called.</p> <p>For example, say you’re writing an inclusion tag that will always be used in a context that contains <code>home_link</code> and <code>home_title</code> variables that point back to the main page. Here’s what the Python function would look like:</p> <pre data-language="python">@register.inclusion_tag("link.html", takes_context=True)
def jump_link(context):
    return {
        "link": context["home_link"],
        "title": context["home_title"],
    }
</pre> <p>Note that the first parameter to the function <em>must</em> be called <code>context</code>.</p> <p>In that <code>register.inclusion_tag()</code> line, we specified <code>takes_context=True</code> and the name of the template. Here’s what the template <code>link.html</code> might look like:</p> <pre data-language="markup">Jump directly to &lt;a href="{{ link }}.html"&gt;{{ title }}&lt;/a&gt;.
</pre> <p>Then, any time you want to use that custom tag, load its library and call it without any arguments, like so:</p> <pre data-language="markup">{% jump_link %}
</pre> <p>Note that when you’re using <code>takes_context=True</code>, there’s no need to pass arguments to the template tag. It automatically gets access to the context.</p> <p>The <code>takes_context</code> parameter defaults to <code>False</code>. When it’s set to <code>True</code>, the tag is passed the context object, as in this example. That’s the only difference between this case and the previous <code>inclusion_tag</code> example.</p> <p><code>inclusion_tag</code> functions may accept any number of positional or keyword arguments. For example:</p> <pre data-language="python">@register.inclusion_tag("my_template.html")
def my_tag(a, b, *args, **kwargs):
    warning = kwargs["warning"]
    profile = kwargs["profile"]
    ...
    return ...
</pre> <p>Then in the template any number of arguments, separated by spaces, may be passed to the template tag. Like in Python, the values for keyword arguments are set using the equal sign (”<code>=</code>”) and must be provided after the positional arguments. For example:</p> <pre data-language="markup">{% my_tag 123 "abcd" book.title warning=message|lower profile=user.profile %}
</pre> </section> <section id="s-advanced-custom-template-tags"> <h3 id="advanced-custom-template-tags">Advanced custom template tags</h3> <p>Sometimes the basic features for custom template tag creation aren’t enough. Don’t worry, Django gives you complete access to the internals required to build a template tag from the ground up.</p> </section> <section id="s-a-quick-overview"> <h3 id="a-quick-overview">A quick overview</h3> <p>The template system works in a two-step process: compiling and rendering. To define a custom template tag, you specify how the compilation works and how the rendering works.</p> <p>When Django compiles a template, it splits the raw template text into ‘’nodes’’. Each node is an instance of <code>django.template.Node</code> and has a <code>render()</code> method. A compiled template is a list of <code>Node</code> objects. When you call <code>render()</code> on a compiled template object, the template calls <code>render()</code> on each <code>Node</code> in its node list, with the given context. The results are all concatenated together to form the output of the template.</p> <p>Thus, to define a custom template tag, you specify how the raw template tag is converted into a <code>Node</code> (the compilation function), and what the node’s <code>render()</code> method does.</p> </section> <section id="s-writing-the-compilation-function"> <h3 id="writing-the-compilation-function">Writing the compilation function</h3> <p>For each template tag the template parser encounters, it calls a Python function with the tag contents and the parser object itself. This function is responsible for returning a <code>Node</code> instance based on the contents of the tag.</p> <p>For example, let’s write a full implementation of our template tag, <code>{% current_time %}</code>, that displays the current date/time, formatted according to a parameter given in the tag, in <a class="reference external" href="https://docs.python.org/3/library/time.html#time.strftime" title="(in Python v3.13)"><code>strftime()</code></a> syntax. It’s a good idea to decide the tag syntax before anything else. In our case, let’s say the tag should be used like this:</p> <pre data-language="markup">&lt;p&gt;The time is {% current_time "%Y-%m-%d %I:%M %p" %}.&lt;/p&gt;
</pre> <p>The parser for this function should grab the parameter and create a <code>Node</code> object:</p> <pre data-language="python">from django import template


def do_current_time(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, format_string = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError(
            "%r tag requires a single argument" % token.contents.split()[0]
        )
    if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
        raise template.TemplateSyntaxError(
            "%r tag's argument should be in quotes" % tag_name
        )
    return CurrentTimeNode(format_string[1:-1])
</pre> <p>Notes:</p> <ul class="simple"> <li>
<code>parser</code> is the template parser object. We don’t need it in this example.</li> <li>
<code>token.contents</code> is a string of the raw contents of the tag. In our example, it’s <code>'current_time "%Y-%m-%d %I:%M %p"'</code>.</li> <li>The <code>token.split_contents()</code> method separates the arguments on spaces while keeping quoted strings together. The more straightforward <code>token.contents.split()</code> wouldn’t be as robust, as it would naively split on <em>all</em> spaces, including those within quoted strings. It’s a good idea to always use <code>token.split_contents()</code>.</li> <li>This function is responsible for raising <code>django.template.TemplateSyntaxError</code>, with helpful messages, for any syntax error.</li> <li>The <code>TemplateSyntaxError</code> exceptions use the <code>tag_name</code> variable. Don’t hard-code the tag’s name in your error messages, because that couples the tag’s name to your function. <code>token.contents.split()[0]</code> will ‘’always’’ be the name of your tag – even when the tag has no arguments.</li> <li>The function returns a <code>CurrentTimeNode</code> with everything the node needs to know about this tag. In this case, it passes the argument – <code>"%Y-%m-%d %I:%M %p"</code>. The leading and trailing quotes from the template tag are removed in <code>format_string[1:-1]</code>.</li> <li>The parsing is very low-level. The Django developers have experimented with writing small frameworks on top of this parsing system, using techniques such as EBNF grammars, but those experiments made the template engine too slow. It’s low-level because that’s fastest.</li> </ul> </section> <section id="s-writing-the-renderer"> <h3 id="writing-the-renderer">Writing the renderer</h3> <p>The second step in writing custom tags is to define a <code>Node</code> subclass that has a <code>render()</code> method.</p> <p>Continuing the above example, we need to define <code>CurrentTimeNode</code>:</p> <pre data-language="python">import datetime
from django import template


class CurrentTimeNode(template.Node):
    def __init__(self, format_string):
        self.format_string = format_string

    def render(self, context):
        return datetime.datetime.now().strftime(self.format_string)
</pre> <p>Notes:</p> <ul class="simple"> <li>
<code>__init__()</code> gets the <code>format_string</code> from <code>do_current_time()</code>. Always pass any options/parameters/arguments to a <code>Node</code> via its <code>__init__()</code>.</li> <li>The <code>render()</code> method is where the work actually happens.</li> <li>
<code>render()</code> should generally fail silently, particularly in a production environment. In some cases however, particularly if <code>context.template.engine.debug</code> is <code>True</code>, this method may raise an exception to make debugging easier. For example, several core tags raise <code>django.template.TemplateSyntaxError</code> if they receive the wrong number or type of arguments.</li> </ul> <p>Ultimately, this decoupling of compilation and rendering results in an efficient template system, because a template can render multiple contexts without having to be parsed multiple times.</p> </section> <section id="s-auto-escaping-considerations"> <h3 id="tags-auto-escaping">Auto-escaping considerations</h3> <p>The output from template tags is <strong>not</strong> automatically run through the auto-escaping filters (with the exception of <a class="reference internal" href="#django.template.Library.simple_tag" title="django.template.Library.simple_tag"><code>simple_tag()</code></a> as described above). However, there are still a couple of things you should keep in mind when writing a template tag.</p> <p>If the <code>render()</code> method of your template tag stores the result in a context variable (rather than returning the result in a string), it should take care to call <code>mark_safe()</code> if appropriate. When the variable is ultimately rendered, it will be affected by the auto-escape setting in effect at the time, so content that should be safe from further escaping needs to be marked as such.</p> <p>Also, if your template tag creates a new context for performing some sub-rendering, set the auto-escape attribute to the current context’s value. The <code>__init__</code> method for the <code>Context</code> class takes a parameter called <code>autoescape</code> that you can use for this purpose. For example:</p> <pre data-language="python">from django.template import Context


def render(self, context):
    # ...
    new_context = Context({"var": obj}, autoescape=context.autoescape)
    # ... Do something with new_context ...
</pre> <p>This is not a very common situation, but it’s useful if you’re rendering a template yourself. For example:</p> <pre data-language="python">def render(self, context):
    t = context.template.engine.get_template("small_fragment.html")
    return t.render(Context({"var": obj}, autoescape=context.autoescape))
</pre> <p>If we had neglected to pass in the current <code>context.autoescape</code> value to our new <code>Context</code> in this example, the results would have <em>always</em> been automatically escaped, which may not be the desired behavior if the template tag is used inside a <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-autoescape"><code>{% autoescape off %}</code></a> block.</p> </section> <section id="s-thread-safety-considerations"> <h3 id="template-tag-thread-safety">Thread-safety considerations</h3> <p>Once a node is parsed, its <code>render</code> method may be called any number of times. Since Django is sometimes run in multi-threaded environments, a single node may be simultaneously rendering with different contexts in response to two separate requests. Therefore, it’s important to make sure your template tags are thread safe.</p> <p>To make sure your template tags are thread safe, you should never store state information on the node itself. For example, Django provides a builtin <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-cycle"><code>cycle</code></a> template tag that cycles among a list of given strings each time it’s rendered:</p> <pre data-language="markup">{% for o in some_list %}
    &lt;tr class="{% cycle 'row1' 'row2' %}"&gt;
        ...
    &lt;/tr&gt;
{% endfor %}
</pre> <p>A naive implementation of <code>CycleNode</code> might look something like this:</p> <pre data-language="python">import itertools
from django import template


class CycleNode(template.Node):
    def __init__(self, cyclevars):
        self.cycle_iter = itertools.cycle(cyclevars)

    def render(self, context):
        return next(self.cycle_iter)
</pre> <p>But, suppose we have two templates rendering the template snippet from above at the same time:</p> <ol class="arabic simple"> <li>Thread 1 performs its first loop iteration, <code>CycleNode.render()</code> returns ‘row1’</li> <li>Thread 2 performs its first loop iteration, <code>CycleNode.render()</code> returns ‘row2’</li> <li>Thread 1 performs its second loop iteration, <code>CycleNode.render()</code> returns ‘row1’</li> <li>Thread 2 performs its second loop iteration, <code>CycleNode.render()</code> returns ‘row2’</li> </ol> <p>The CycleNode is iterating, but it’s iterating globally. As far as Thread 1 and Thread 2 are concerned, it’s always returning the same value. This is not what we want!</p> <p>To address this problem, Django provides a <code>render_context</code> that’s associated with the <code>context</code> of the template that is currently being rendered. The <code>render_context</code> behaves like a Python dictionary, and should be used to store <code>Node</code> state between invocations of the <code>render</code> method.</p> <p>Let’s refactor our <code>CycleNode</code> implementation to use the <code>render_context</code>:</p> <pre data-language="python">class CycleNode(template.Node):
    def __init__(self, cyclevars):
        self.cyclevars = cyclevars

    def render(self, context):
        if self not in context.render_context:
            context.render_context[self] = itertools.cycle(self.cyclevars)
        cycle_iter = context.render_context[self]
        return next(cycle_iter)
</pre> <p>Note that it’s perfectly safe to store global information that will not change throughout the life of the <code>Node</code> as an attribute. In the case of <code>CycleNode</code>, the <code>cyclevars</code> argument doesn’t change after the <code>Node</code> is instantiated, so we don’t need to put it in the <code>render_context</code>. But state information that is specific to the template that is currently being rendered, like the current iteration of the <code>CycleNode</code>, should be stored in the <code>render_context</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Notice how we used <code>self</code> to scope the <code>CycleNode</code> specific information within the <code>render_context</code>. There may be multiple <code>CycleNodes</code> in a given template, so we need to be careful not to clobber another node’s state information. The easiest way to do this is to always use <code>self</code> as the key into <code>render_context</code>. If you’re keeping track of several state variables, make <code>render_context[self]</code> a dictionary.</p> </div> </section> <section id="s-registering-the-tag"> <h3 id="registering-the-tag">Registering the tag</h3> <p>Finally, register the tag with your module’s <code>Library</code> instance, as explained in <a class="reference internal" href="#howto-writing-custom-template-tags"><span class="std std-ref">writing custom template tags</span></a> above. Example:</p> <pre data-language="python">register.tag("current_time", do_current_time)
</pre> <p>The <code>tag()</code> method takes two arguments:</p> <ol class="arabic simple"> <li>The name of the template tag – a string. If this is left out, the name of the compilation function will be used.</li> <li>The compilation function – a Python function (not the name of the function as a string).</li> </ol> <p>As with filter registration, it is also possible to use this as a decorator:</p> <pre data-language="python">@register.tag(name="current_time")
def do_current_time(parser, token): ...


@register.tag
def shout(parser, token): ...
</pre> <p>If you leave off the <code>name</code> argument, as in the second example above, Django will use the function’s name as the tag name.</p> </section> <section id="s-passing-template-variables-to-the-tag"> <h3 id="passing-template-variables-to-the-tag">Passing template variables to the tag</h3> <p>Although you can pass any number of arguments to a template tag using <code>token.split_contents()</code>, the arguments are all unpacked as string literals. A little more work is required in order to pass dynamic content (a template variable) to a template tag as an argument.</p> <p>While the previous examples have formatted the current time into a string and returned the string, suppose you wanted to pass in a <a class="reference internal" href="../ref/models/fields.html#django.db.models.DateTimeField" title="django.db.models.DateTimeField"><code>DateTimeField</code></a> from an object and have the template tag format that date-time:</p> <pre data-language="markup">&lt;p&gt;This post was last updated at {% format_time blog_entry.date_updated "%Y-%m-%d %I:%M %p" %}.&lt;/p&gt;
</pre> <p>Initially, <code>token.split_contents()</code> will return three values:</p> <ol class="arabic simple"> <li>The tag name <code>format_time</code>.</li> <li>The string <code>'blog_entry.date_updated'</code> (without the surrounding quotes).</li> <li>The formatting string <code>'"%Y-%m-%d %I:%M %p"'</code>. The return value from <code>split_contents()</code> will include the leading and trailing quotes for string literals like this.</li> </ol> <p>Now your tag should begin to look like this:</p> <pre data-language="python">from django import template


def do_format_time(parser, token):
    try:
        # split_contents() knows not to split quoted strings.
        tag_name, date_to_be_formatted, format_string = token.split_contents()
    except ValueError:
        raise template.TemplateSyntaxError(
            "%r tag requires exactly two arguments" % token.contents.split()[0]
        )
    if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
        raise template.TemplateSyntaxError(
            "%r tag's argument should be in quotes" % tag_name
        )
    return FormatTimeNode(date_to_be_formatted, format_string[1:-1])
</pre> <p>You also have to change the renderer to retrieve the actual contents of the <code>date_updated</code> property of the <code>blog_entry</code> object. This can be accomplished by using the <code>Variable()</code> class in <code>django.template</code>.</p> <p>To use the <code>Variable</code> class, instantiate it with the name of the variable to be resolved, and then call <code>variable.resolve(context)</code>. So, for example:</p> <pre data-language="python">class FormatTimeNode(template.Node):
    def __init__(self, date_to_be_formatted, format_string):
        self.date_to_be_formatted = template.Variable(date_to_be_formatted)
        self.format_string = format_string

    def render(self, context):
        try:
            actual_date = self.date_to_be_formatted.resolve(context)
            return actual_date.strftime(self.format_string)
        except template.VariableDoesNotExist:
            return ""
</pre> <p>Variable resolution will throw a <code>VariableDoesNotExist</code> exception if it cannot resolve the string passed to it in the current context of the page.</p> </section> <section id="s-setting-a-variable-in-the-context"> <h3 id="setting-a-variable-in-the-context">Setting a variable in the context</h3> <p>The above examples output a value. Generally, it’s more flexible if your template tags set template variables instead of outputting values. That way, template authors can reuse the values that your template tags create.</p> <p>To set a variable in the context, use dictionary assignment on the context object in the <code>render()</code> method. Here’s an updated version of <code>CurrentTimeNode</code> that sets a template variable <code>current_time</code> instead of outputting it:</p> <pre data-language="python">import datetime
from django import template


class CurrentTimeNode2(template.Node):
    def __init__(self, format_string):
        self.format_string = format_string

    def render(self, context):
        context["current_time"] = datetime.datetime.now().strftime(self.format_string)
        return ""
</pre> <p>Note that <code>render()</code> returns the empty string. <code>render()</code> should always return string output. If all the template tag does is set a variable, <code>render()</code> should return the empty string.</p> <p>Here’s how you’d use this new version of the tag:</p> <pre data-language="markup">{% current_time "%Y-%m-%d %I:%M %p" %}&lt;p&gt;The time is {{ current_time }}.&lt;/p&gt;
</pre> <div class="admonition-variable-scope-in-context admonition"> <p class="admonition-title">Variable scope in context</p> <p>Any variable set in the context will only be available in the same <code>block</code> of the template in which it was assigned. This behavior is intentional; it provides a scope for variables so that they don’t conflict with context in other blocks.</p> </div> <p>But, there’s a problem with <code>CurrentTimeNode2</code>: The variable name <code>current_time</code> is hard-coded. This means you’ll need to make sure your template doesn’t use <code>{{ current_time }}</code> anywhere else, because the <code>{% current_time %}</code> will blindly overwrite that variable’s value. A cleaner solution is to make the template tag specify the name of the output variable, like so:</p> <pre data-language="markup">{% current_time "%Y-%m-%d %I:%M %p" as my_current_time %}
&lt;p&gt;The current time is {{ my_current_time }}.&lt;/p&gt;
</pre> <p>To do that, you’ll need to refactor both the compilation function and <code>Node</code> class, like so:</p> <pre data-language="python">import re


class CurrentTimeNode3(template.Node):
    def __init__(self, format_string, var_name):
        self.format_string = format_string
        self.var_name = var_name

    def render(self, context):
        context[self.var_name] = datetime.datetime.now().strftime(self.format_string)
        return ""


def do_current_time(parser, token):
    # This version uses a regular expression to parse tag contents.
    try:
        # Splitting by None == splitting by spaces.
        tag_name, arg = token.contents.split(None, 1)
    except ValueError:
        raise template.TemplateSyntaxError(
            "%r tag requires arguments" % token.contents.split()[0]
        )
    m = re.search(r"(.*?) as (\w+)", arg)
    if not m:
        raise template.TemplateSyntaxError("%r tag had invalid arguments" % tag_name)
    format_string, var_name = m.groups()
    if not (format_string[0] == format_string[-1] and format_string[0] in ('"', "'")):
        raise template.TemplateSyntaxError(
            "%r tag's argument should be in quotes" % tag_name
        )
    return CurrentTimeNode3(format_string[1:-1], var_name)
</pre> <p>The difference here is that <code>do_current_time()</code> grabs the format string and the variable name, passing both to <code>CurrentTimeNode3</code>.</p> <p>Finally, if you only need to have a simple syntax for your custom context-updating template tag, consider using the <a class="reference internal" href="#django.template.Library.simple_tag" title="django.template.Library.simple_tag"><code>simple_tag()</code></a> shortcut, which supports assigning the tag results to a template variable.</p> </section> <section id="s-parsing-until-another-block-tag"> <h3 id="parsing-until-another-block-tag">Parsing until another block tag</h3> <p>Template tags can work in tandem. For instance, the standard <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-comment"><code>{% comment %}</code></a> tag hides everything until <code>{% endcomment %}</code>. To create a template tag such as this, use <code>parser.parse()</code> in your compilation function.</p> <p>Here’s how a simplified <code>{% comment %}</code> tag might be implemented:</p> <pre data-language="python">def do_comment(parser, token):
    nodelist = parser.parse(("endcomment",))
    parser.delete_first_token()
    return CommentNode()


class CommentNode(template.Node):
    def render(self, context):
        return ""
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The actual implementation of <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-comment"><code>{% comment %}</code></a> is slightly different in that it allows broken template tags to appear between <code>{% comment %}</code> and <code>{% endcomment %}</code>. It does so by calling <code>parser.skip_past('endcomment')</code> instead of <code>parser.parse(('endcomment',))</code> followed by <code>parser.delete_first_token()</code>, thus avoiding the generation of a node list.</p> </div> <p><code>parser.parse()</code> takes a tuple of names of block tags ‘’to parse until’’. It returns an instance of <code>django.template.NodeList</code>, which is a list of all <code>Node</code> objects that the parser encountered ‘’before’’ it encountered any of the tags named in the tuple.</p> <p>In <code>"nodelist = parser.parse(('endcomment',))"</code> in the above example, <code>nodelist</code> is a list of all nodes between the <code>{% comment %}</code> and <code>{% endcomment %}</code>, not counting <code>{% comment %}</code> and <code>{% endcomment %}</code> themselves.</p> <p>After <code>parser.parse()</code> is called, the parser hasn’t yet “consumed” the <code>{% endcomment %}</code> tag, so the code needs to explicitly call <code>parser.delete_first_token()</code>.</p> <p><code>CommentNode.render()</code> returns an empty string. Anything between <code>{% comment %}</code> and <code>{% endcomment %}</code> is ignored.</p> </section> <section id="s-parsing-until-another-block-tag-and-saving-contents"> <h3 id="parsing-until-another-block-tag-and-saving-contents">Parsing until another block tag, and saving contents</h3> <p>In the previous example, <code>do_comment()</code> discarded everything between <code>{% comment %}</code> and <code>{% endcomment %}</code>. Instead of doing that, it’s possible to do something with the code between block tags.</p> <p>For example, here’s a custom template tag, <code>{% upper %}</code>, that capitalizes everything between itself and <code>{% endupper %}</code>.</p> <p>Usage:</p> <pre data-language="markup">{% upper %}This will appear in uppercase, {{ your_name }}.{% endupper %}
</pre> <p>As in the previous example, we’ll use <code>parser.parse()</code>. But this time, we pass the resulting <code>nodelist</code> to the <code>Node</code>:</p> <pre data-language="python">def do_upper(parser, token):
    nodelist = parser.parse(("endupper",))
    parser.delete_first_token()
    return UpperNode(nodelist)


class UpperNode(template.Node):
    def __init__(self, nodelist):
        self.nodelist = nodelist

    def render(self, context):
        output = self.nodelist.render(context)
        return output.upper()
</pre> <p>The only new concept here is the <code>self.nodelist.render(context)</code> in <code>UpperNode.render()</code>.</p> <p>For more examples of complex rendering, see the source code of <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-for"><code>{% for %}</code></a> in <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/template/defaulttags.py">django/template/defaulttags.py</a> and <a class="reference internal" href="../ref/templates/builtins.html#std-templatetag-if"><code>{% if %}</code></a> in <a class="extlink-source reference external" href="https://github.com/django/django/blob/main/django/template/smartif.py">django/template/smartif.py</a>.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/howto/custom-template-tags/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/howto/custom-template-tags/</a>
  </p>
</div>
