<h1 id="making-queries">Making queries</h1> <p id="s-making-queries">Once you’ve created your <a class="reference internal" href="models.html"><span class="doc">data models</span></a>, Django automatically gives you a database-abstraction API that lets you create, retrieve, update and delete objects. This document explains how to use this API. Refer to the <a class="reference internal" href="../../ref/models/index.html"><span class="doc">data model reference</span></a> for full details of all the various model lookup options.</p> <p>Throughout this guide (and in the reference), we’ll refer to the following models, which comprise a blog application:</p> <pre data-language="python">from datetime import date

from django.db import models


class Blog(models.Model):
    name = models.CharField(max_length=100)
    tagline = models.TextField()

    def __str__(self):
        return self.name


class Author(models.Model):
    name = models.CharField(max_length=200)
    email = models.EmailField()

    def __str__(self):
        return self.name


class Entry(models.Model):
    blog = models.ForeignKey(Blog, on_delete=models.CASCADE)
    headline = models.CharField(max_length=255)
    body_text = models.TextField()
    pub_date = models.DateField()
    mod_date = models.DateField(default=date.today)
    authors = models.ManyToManyField(Author)
    number_of_comments = models.IntegerField(default=0)
    number_of_pingbacks = models.IntegerField(default=0)
    rating = models.IntegerField(default=5)

    def __str__(self):
        return self.headline
</pre>  <h2 id="creating-objects">Creating objects</h2> <p id="s-creating-objects">To represent database-table data in Python objects, Django uses an intuitive system: A model class represents a database table, and an instance of that class represents a particular record in the database table.</p> <p>To create an object, instantiate it using keyword arguments to the model class, then call <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> to save it to the database.</p> <p>Assuming models live in a file <code>mysite/blog/models.py</code>, here’s an example:</p> <pre data-language="pycon">&gt;&gt;&gt; from blog.models import Blog
&gt;&gt;&gt; b = Blog(name="Beatles Blog", tagline="All the latest Beatles news.")
&gt;&gt;&gt; b.save()
</pre> <p>This performs an <code>INSERT</code> SQL statement behind the scenes. Django doesn’t hit the database until you explicitly call <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>.</p> <p>The <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> method has no return value.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p><a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> takes a number of advanced options not described here. See the documentation for <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> for complete details.</p> <p class="last">To create and save an object in a single step, use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.create" title="django.db.models.query.QuerySet.create"><code>create()</code></a> method.</p> </div>   <h2 id="saving-changes-to-objects">Saving changes to objects</h2> <p id="s-saving-changes-to-objects">To save changes to an object that’s already in the database, use <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>.</p> <p>Given a <code>Blog</code> instance <code>b5</code> that has already been saved to the database, this example changes its name and updates its record in the database:</p> <pre data-language="pycon">&gt;&gt;&gt; b5.name = "New name"
&gt;&gt;&gt; b5.save()
</pre> <p>This performs an <code>UPDATE</code> SQL statement behind the scenes. Django doesn’t hit the database until you explicitly call <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>.</p>  <h3 id="saving-foreignkey-and-manytomanyfield-fields">Saving <code>ForeignKey</code> and <code>ManyToManyField</code> fields</h3> <p id="s-saving-foreignkey-and-manytomanyfield-fields">Updating a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> field works exactly the same way as saving a normal field – assign an object of the right type to the field in question. This example updates the <code>blog</code> attribute of an <code>Entry</code> instance <code>entry</code>, assuming appropriate instances of <code>Entry</code> and <code>Blog</code> are already saved to the database (so we can retrieve them below):</p> <pre data-language="pycon">&gt;&gt;&gt; from blog.models import Blog, Entry
&gt;&gt;&gt; entry = Entry.objects.get(pk=1)
&gt;&gt;&gt; cheese_blog = Blog.objects.get(name="Cheddar Talk")
&gt;&gt;&gt; entry.blog = cheese_blog
&gt;&gt;&gt; entry.save()
</pre> <p>Updating a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> works a little differently – use the <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code>add()</code></a> method on the field to add a record to the relation. This example adds the <code>Author</code> instance <code>joe</code> to the <code>entry</code> object:</p> <pre data-language="pycon">&gt;&gt;&gt; from blog.models import Author
&gt;&gt;&gt; joe = Author.objects.create(name="Joe")
&gt;&gt;&gt; entry.authors.add(joe)
</pre> <p>To add multiple records to a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> in one go, include multiple arguments in the call to <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code>add()</code></a>, like this:</p> <pre data-language="pycon">&gt;&gt;&gt; john = Author.objects.create(name="John")
&gt;&gt;&gt; paul = Author.objects.create(name="Paul")
&gt;&gt;&gt; george = Author.objects.create(name="George")
&gt;&gt;&gt; ringo = Author.objects.create(name="Ringo")
&gt;&gt;&gt; entry.authors.add(john, paul, george, ringo)
</pre> <p>Django will complain if you try to assign or add an object of the wrong type.</p>    <h2 id="id1">Retrieving objects</h2> <p id="s-retrieving-objects">To retrieve objects from your database, construct a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> via a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> on your model class.</p> <p>A <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> represents a collection of objects from your database. It can have zero, one or many <em>filters</em>. Filters narrow down the query results based on the given parameters. In SQL terms, a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> equates to a <code>SELECT</code> statement, and a filter is a limiting clause such as <code>WHERE</code> or <code>LIMIT</code>.</p> <p>You get a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> by using your model’s <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a>. Each model has at least one <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a>, and it’s called <a class="reference internal" href="../../ref/models/class.html#django.db.models.Model.objects" title="django.db.models.Model.objects"><code>objects</code></a> by default. Access it directly via the model class, like so:</p> <pre data-language="pycon">&gt;&gt;&gt; Blog.objects
&lt;django.db.models.manager.Manager object at ...&gt;
&gt;&gt;&gt; b = Blog(name="Foo", tagline="Bar")
&gt;&gt;&gt; b.objects
Traceback:
    ...
AttributeError: "Manager isn't accessible via Blog instances."
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><code>Managers</code> are accessible only via model classes, rather than from model instances, to enforce a separation between “table-level” operations and “record-level” operations.</p> </div> <p>The <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> is the main source of <code>QuerySets</code> for a model. For example, <code>Blog.objects.all()</code> returns a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> that contains all <code>Blog</code> objects in the database.</p>  <h3 id="retrieving-all-objects">Retrieving all objects</h3> <p id="s-retrieving-all-objects">The simplest way to retrieve objects from a table is to get all of them. To do this, use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code>all()</code></a> method on a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; all_entries = Entry.objects.all()
</pre> <p>The <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code>all()</code></a> method returns a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> of all the objects in the database.</p>   <h3 id="retrieving-specific-objects-with-filters">Retrieving specific objects with filters</h3> <p id="s-retrieving-specific-objects-with-filters">The <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> returned by <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code>all()</code></a> describes all objects in the database table. Usually, though, you’ll need to select only a subset of the complete set of objects.</p> <p>To create such a subset, you refine the initial <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, adding filter conditions. The two most common ways to refine a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> are:</p> <dl class="docutils"> <dt>
<code>filter(**kwargs)</code> </dt>
<dd>Returns a new <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> containing objects that match the given lookup parameters.</dd> <dt>
<code>exclude(**kwargs)</code> </dt>
<dd>Returns a new <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> containing objects that do <em>not</em> match the given lookup parameters.</dd> </dl> <p>The lookup parameters (<code>**kwargs</code> in the above function definitions) should be in the format described in <a class="reference internal" href="#field-lookups">Field lookups</a> below.</p> <p>For example, to get a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> of blog entries from the year 2006, use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> like so:</p> <pre data-language="python">Entry.objects.filter(pub_date__year=2006)
</pre> <p>With the default manager class, it is the same as:</p> <pre data-language="python">Entry.objects.all().filter(pub_date__year=2006)
</pre>  <h4 id="id2">Chaining filters</h4> <p id="s-chaining-filters">The result of refining a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> is itself a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, so it’s possible to chain refinements together. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(headline__startswith="What").exclude(
...     pub_date__gte=datetime.date.today()
... ).filter(pub_date__gte=datetime.date(2005, 1, 30))
</pre> <p>This takes the initial <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> of all entries in the database, adds a filter, then an exclusion, then another filter. The final result is a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> containing all entries with a headline that starts with “What”, that were published between January 30, 2005, and the current day.</p>   <h4 id="id3">Filtered <code>QuerySet</code>s are unique</h4> <p id="s-filtered-querysets-are-unique">Each time you refine a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, you get a brand-new <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> that is in no way bound to the previous <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>. Each refinement creates a separate and distinct <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> that can be stored, used and reused.</p> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; q1 = Entry.objects.filter(headline__startswith="What")
&gt;&gt;&gt; q2 = q1.exclude(pub_date__gte=datetime.date.today())
&gt;&gt;&gt; q3 = q1.filter(pub_date__gte=datetime.date.today())
</pre> <p>These three <code>QuerySets</code> are separate. The first is a base <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> containing all entries that contain a headline starting with “What”. The second is a subset of the first, with an additional criteria that excludes records whose <code>pub_date</code> is today or in the future. The third is a subset of the first, with an additional criteria that selects only the records whose <code>pub_date</code> is today or in the future. The initial <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> (<code>q1</code>) is unaffected by the refinement process.</p>   <h4 id="id4">
<code>QuerySet</code>s are lazy</h4> <p id="s-querysets-are-lazy"><code>QuerySets</code> are lazy – the act of creating a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> doesn’t involve any database activity. You can stack filters together all day long, and Django won’t actually run the query until the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> is <em>evaluated</em>. Take a look at this example:</p> <pre data-language="pycon">&gt;&gt;&gt; q = Entry.objects.filter(headline__startswith="What")
&gt;&gt;&gt; q = q.filter(pub_date__lte=datetime.date.today())
&gt;&gt;&gt; q = q.exclude(body_text__icontains="food")
&gt;&gt;&gt; print(q)
</pre> <p>Though this looks like three database hits, in fact it hits the database only once, at the last line (<code>print(q)</code>). In general, the results of a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> aren’t fetched from the database until you “ask” for them. When you do, the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> is <em>evaluated</em> by accessing the database. For more details on exactly when evaluation takes place, see <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><span class="std std-ref">When QuerySets are evaluated</span></a>.</p>    <h3 id="retrieving-single-object-with-get">Retrieving a single object with <code>get()</code>
</h3> <p id="s-retrieving-a-single-object-with-get"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> will always give you a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, even if only a single object matches the query - in this case, it will be a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> containing a single element.</p> <p>If you know there is only one object that matches your query, you can use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> method on a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> which returns the object directly:</p> <pre data-language="pycon">&gt;&gt;&gt; one_entry = Entry.objects.get(pk=1)
</pre> <p>You can use any query expression with <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>, just like with <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> - again, see <a class="reference internal" href="#field-lookups">Field lookups</a> below.</p> <p>Note that there is a difference between using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>, and using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> with a slice of <code>[0]</code>. If there are no results that match the query, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> will raise a <code>DoesNotExist</code> exception. This exception is an attribute of the model class that the query is being performed on - so in the code above, if there is no <code>Entry</code> object with a primary key of 1, Django will raise <code>Entry.DoesNotExist</code>.</p> <p>Similarly, Django will complain if more than one item matches the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> query. In this case, it will raise <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.MultipleObjectsReturned" title="django.core.exceptions.MultipleObjectsReturned"><code>MultipleObjectsReturned</code></a>, which again is an attribute of the model class itself.</p>   <h3 id="other-queryset-methods">Other <code>QuerySet</code> methods</h3> <p id="s-other-queryset-methods">Most of the time you’ll use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.all" title="django.db.models.query.QuerySet.all"><code>all()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> when you need to look up objects from the database. However, that’s far from all there is; see the <a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><span class="std std-ref">QuerySet API Reference</span></a> for a complete list of all the various <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> methods.</p>   <h3 id="id5">Limiting <code>QuerySet</code>s</h3> <p id="s-limiting-querysets">Use a subset of Python’s array-slicing syntax to limit your <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> to a certain number of results. This is the equivalent of SQL’s <code>LIMIT</code> and <code>OFFSET</code> clauses.</p> <p>For example, this returns the first 5 objects (<code>LIMIT 5</code>):</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.all()[:5]
</pre> <p>This returns the sixth through tenth objects (<code>OFFSET 5 LIMIT 5</code>):</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.all()[5:10]
</pre> <p>Negative indexing (i.e. <code>Entry.objects.all()[-1]</code>) is not supported.</p> <p>Generally, slicing a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> returns a new <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> – it doesn’t evaluate the query. An exception is if you use the “step” parameter of Python slice syntax. For example, this would actually execute the query in order to return a list of every <em>second</em> object of the first 10:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.all()[:10:2]
</pre> <p>Further filtering or ordering of a sliced queryset is prohibited due to the ambiguous nature of how that might work.</p> <p>To retrieve a <em>single</em> object rather than a list (e.g. <code>SELECT foo FROM bar LIMIT 1</code>), use an index instead of a slice. For example, this returns the first <code>Entry</code> in the database, after ordering entries alphabetically by headline:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.order_by("headline")[0]
</pre> <p>This is roughly equivalent to:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.order_by("headline")[0:1].get()
</pre> <p>Note, however, that the first of these will raise <code>IndexError</code> while the second will raise <code>DoesNotExist</code> if no objects match the given criteria. See <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> for more details.</p>   <h3 id="field-lookups-intro">Field lookups</h3> <p id="s-field-lookups">Field lookups are how you specify the meat of an SQL <code>WHERE</code> clause. They’re specified as keyword arguments to the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> methods <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>.</p> <p>Basic lookups keyword arguments take the form <code>field__lookuptype=value</code>. (That’s a double-underscore). For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(pub_date__lte="2006-01-01")
</pre> <p>translates (roughly) into the following SQL:</p> <pre data-language="sql">SELECT * FROM blog_entry WHERE pub_date &lt;= '2006-01-01';
</pre> <div class="admonition-how-this-is-possible admonition"> <p class="first admonition-title">How this is possible</p> <p class="last">Python has the ability to define functions that accept arbitrary name-value arguments whose names and values are evaluated at runtime. For more information, see <a class="reference external" href="https://docs.python.org/3/tutorial/controlflow.html#tut-keywordargs" title="(in Python v3.12)"><span>Keyword Arguments</span></a> in the official Python tutorial.</p> </div> <p>The field specified in a lookup has to be the name of a model field. There’s one exception though, in case of a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> you can specify the field name suffixed with <code>_id</code>. In this case, the value parameter is expected to contain the raw value of the foreign model’s primary key. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(blog_id=4)
</pre> <p>If you pass an invalid keyword argument, a lookup function will raise <code>TypeError</code>.</p> <p>The database API supports about two dozen lookup types; a complete reference can be found in the <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">field lookup reference</span></a>. To give you a taste of what’s available, here’s some of the more common lookups you’ll probably use:</p> <dl class="docutils"> <dt>
 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code>exact</code></a>
</dt>
<dd>
<p>An “exact” match. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.get(headline__exact="Cat bites dog")
</pre> <p>Would generate SQL along these lines:</p> <pre data-language="sql">SELECT ... WHERE headline = 'Cat bites dog';
</pre> <p>If you don’t provide a lookup type – that is, if your keyword argument doesn’t contain a double underscore – the lookup type is assumed to be <code>exact</code>.</p> <p>For example, the following two statements are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; Blog.objects.get(id__exact=14)  # Explicit form
&gt;&gt;&gt; Blog.objects.get(id=14)  # __exact is implied
</pre> <p>This is for convenience, because <code>exact</code> lookups are the common case.</p> </dd> <dt>
 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code>iexact</code></a>
</dt>
<dd>
<p>A case-insensitive match. So, the query:</p> <pre data-language="pycon">&gt;&gt;&gt; Blog.objects.get(name__iexact="beatles blog")
</pre> <p>Would match a <code>Blog</code> titled <code>"Beatles Blog"</code>, <code>"beatles blog"</code>, or even <code>"BeAtlES blOG"</code>.</p> </dd> <dt>
 <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code>contains</code></a>
</dt>
<dd>
<p>Case-sensitive containment test. For example:</p> <pre data-language="python">Entry.objects.get(headline__contains="Lennon")
</pre> <p>Roughly translates to this SQL:</p> <pre data-language="sql">SELECT ... WHERE headline LIKE '%Lennon%';
</pre> <p>Note this will match the headline <code>'Today Lennon honored'</code> but not <code>'today lennon honored'</code>.</p> <p>There’s also a case-insensitive version, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code>icontains</code></a>.</p> </dd> <dt>
<code>startswith,</code> <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code>endswith</code></a>
</dt>
<dd>Starts-with and ends-with search, respectively. There are also case-insensitive versions called <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code>istartswith</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code>iendswith</code></a>.</dd> </dl> <p>Again, this only scratches the surface. A complete reference can be found in the <a class="reference internal" href="../../ref/models/querysets.html#field-lookups"><span class="std std-ref">field lookup reference</span></a>.</p>   <h3 id="id6">Lookups that span relationships</h3> <p id="s-lookups-that-span-relationships">Django offers a powerful and intuitive way to “follow” relationships in lookups, taking care of the SQL <code>JOIN</code>s for you automatically, behind the scenes. To span a relationship, use the field name of related fields across models, separated by double underscores, until you get to the field you want.</p> <p>This example retrieves all <code>Entry</code> objects with a <code>Blog</code> whose <code>name</code> is <code>'Beatles Blog'</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(blog__name="Beatles Blog")
</pre> <p>This spanning can be as deep as you’d like.</p> <p>It works backwards, too. While it <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_query_name" title="django.db.models.ForeignKey.related_query_name"><code>can be customized</code></a>, by default you refer to a “reverse” relationship in a lookup using the lowercase name of the model.</p> <p>This example retrieves all <code>Blog</code> objects which have at least one <code>Entry</code> whose <code>headline</code> contains <code>'Lennon'</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; Blog.objects.filter(entry__headline__contains="Lennon")
</pre> <p>If you are filtering across multiple relationships and one of the intermediate models doesn’t have a value that meets the filter condition, Django will treat it as if there is an empty (all values are <code>NULL</code>), but valid, object there. All this means is that no error will be raised. For example, in this filter:</p> <pre data-language="python">Blog.objects.filter(entry__authors__name="Lennon")
</pre> <p>(if there was a related <code>Author</code> model), if there was no <code>author</code> associated with an entry, it would be treated as if there was also no <code>name</code> attached, rather than raising an error because of the missing <code>author</code>. Usually this is exactly what you want to have happen. The only case where it might be confusing is if you are using <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code>isnull</code></a>. Thus:</p> <pre data-language="python">Blog.objects.filter(entry__authors__name__isnull=True)
</pre> <p>will return <code>Blog</code> objects that have an empty <code>name</code> on the <code>author</code> and also those which have an empty <code>author</code> on the <code>entry</code>. If you don’t want those latter objects, you could write:</p> <pre data-language="python">Blog.objects.filter(entry__authors__isnull=False, entry__authors__name__isnull=True)
</pre>  <h4 id="id7">Spanning multi-valued relationships</h4> <p id="s-spanning-multi-valued-relationships">When spanning a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> or a reverse <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> (such as from <code>Blog</code> to <code>Entry</code>), filtering on multiple attributes raises the question of whether to require each attribute to coincide in the same related object. We might seek blogs that have an entry from 2008 with <em>“Lennon”</em> in its headline, or we might seek blogs that merely have any entry from 2008 as well as some newer or older entry with <em>“Lennon”</em> in its headline.</p> <p>To select all blogs containing at least one entry from 2008 having <em>“Lennon”</em> in its headline (the same entry satisfying both conditions), we would write:</p> <pre data-language="python">Blog.objects.filter(entry__headline__contains="Lennon", entry__pub_date__year=2008)
</pre> <p>Otherwise, to perform a more permissive query selecting any blogs with merely <em>some</em> entry with <em>“Lennon”</em> in its headline and <em>some</em> entry from 2008, we would write:</p> <pre data-language="python">Blog.objects.filter(entry__headline__contains="Lennon").filter(
    entry__pub_date__year=2008
)
</pre> <p>Suppose there is only one blog that has both entries containing <em>“Lennon”</em> and entries from 2008, but that none of the entries from 2008 contained <em>“Lennon”</em>. The first query would not return any blogs, but the second query would return that one blog. (This is because the entries selected by the second filter may or may not be the same as the entries in the first filter. We are filtering the <code>Blog</code> items with each filter statement, not the <code>Entry</code> items.) In short, if each condition needs to match the same related object, then each should be contained in a single <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> call.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>As the second (more permissive) query chains multiple filters, it performs multiple joins to the primary model, potentially yielding duplicates.</p> <pre data-language="pycon">&gt;&gt;&gt; from datetime import date
&gt;&gt;&gt; beatles = Blog.objects.create(name="Beatles Blog")
&gt;&gt;&gt; pop = Blog.objects.create(name="Pop Music Blog")
&gt;&gt;&gt; Entry.objects.create(
...     blog=beatles,
...     headline="New Lennon Biography",
...     pub_date=date(2008, 6, 1),
... )
&lt;Entry: New Lennon Biography&gt;
&gt;&gt;&gt; Entry.objects.create(
...     blog=beatles,
...     headline="New Lennon Biography in Paperback",
...     pub_date=date(2009, 6, 1),
... )
&lt;Entry: New Lennon Biography in Paperback&gt;
&gt;&gt;&gt; Entry.objects.create(
...     blog=pop,
...     headline="Best Albums of 2008",
...     pub_date=date(2008, 12, 15),
... )
&lt;Entry: Best Albums of 2008&gt;
&gt;&gt;&gt; Entry.objects.create(
...     blog=pop,
...     headline="Lennon Would Have Loved Hip Hop",
...     pub_date=date(2020, 4, 1),
... )
&lt;Entry: Lennon Would Have Loved Hip Hop&gt;
&gt;&gt;&gt; Blog.objects.filter(
...     entry__headline__contains="Lennon",
...     entry__pub_date__year=2008,
... )
&lt;QuerySet [&lt;Blog: Beatles Blog&gt;]&gt;
&gt;&gt;&gt; Blog.objects.filter(
...     entry__headline__contains="Lennon",
... ).filter(
...     entry__pub_date__year=2008,
... )
&lt;QuerySet [&lt;Blog: Beatles Blog&gt;, &lt;Blog: Beatles Blog&gt;, &lt;Blog: Pop Music Blog]&gt;
</pre> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>The behavior of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> for queries that span multi-value relationships, as described above, is not implemented equivalently for <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a>. Instead, the conditions in a single <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> call will not necessarily refer to the same item.</p> <p>For example, the following query would exclude blogs that contain <em>both</em> entries with <em>“Lennon”</em> in the headline <em>and</em> entries published in 2008:</p> <pre data-language="python">Blog.objects.exclude(
    entry__headline__contains="Lennon",
    entry__pub_date__year=2008,
)
</pre> <p>However, unlike the behavior when using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, this will not limit blogs based on entries that satisfy both conditions. In order to do that, i.e. to select all blogs that do not contain entries published with <em>“Lennon”</em> that were published in 2008, you need to make two queries:</p> <pre data-language="python">Blog.objects.exclude(
    entry__in=Entry.objects.filter(
        headline__contains="Lennon",
        pub_date__year=2008,
    ),
)
</pre> </div>    <h3 id="using-f-expressions-in-filters">Filters can reference fields on the model</h3> <p id="s-filters-can-reference-fields-on-the-model">In the examples given so far, we have constructed filters that compare the value of a model field with a constant. But what if you want to compare the value of a model field with another field on the same model?</p> <p>Django provides <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code>F expressions</code></a> to allow such comparisons. Instances of <code>F()</code> act as a reference to a model field within a query. These references can then be used in query filters to compare the values of two different fields on the same model instance.</p> <p>For example, to find a list of all blog entries that have had more comments than pingbacks, we construct an <code>F()</code> object to reference the pingback count, and use that <code>F()</code> object in the query:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.db.models import F
&gt;&gt;&gt; Entry.objects.filter(number_of_comments__gt=F("number_of_pingbacks"))
</pre> <p>Django supports the use of addition, subtraction, multiplication, division, modulo, and power arithmetic with <code>F()</code> objects, both with constants and with other <code>F()</code> objects. To find all the blog entries with more than <em>twice</em> as many comments as pingbacks, we modify the query:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(number_of_comments__gt=F("number_of_pingbacks") * 2)
</pre> <p>To find all the entries where the rating of the entry is less than the sum of the pingback count and comment count, we would issue the query:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(rating__lt=F("number_of_comments") + F("number_of_pingbacks"))
</pre> <p>You can also use the double underscore notation to span relationships in an <code>F()</code> object. An <code>F()</code> object with a double underscore will introduce any joins needed to access the related object. For example, to retrieve all the entries where the author’s name is the same as the blog name, we could issue the query:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(authors__name=F("blog__name"))
</pre> <p>For date and date/time fields, you can add or subtract a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.timedelta" title="(in Python v3.12)"><code>timedelta</code></a> object. The following would return all entries that were modified more than 3 days after they were published:</p> <pre data-language="pycon">&gt;&gt;&gt; from datetime import timedelta
&gt;&gt;&gt; Entry.objects.filter(mod_date__gt=F("pub_date") + timedelta(days=3))
</pre> <p>The <code>F()</code> objects support bitwise operations by <code>.bitand()</code>, <code>.bitor()</code>, <code>.bitxor()</code>, <code>.bitrightshift()</code>, and <code>.bitleftshift()</code>. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; F("somefield").bitand(16)
</pre> <div class="admonition-oracle admonition"> <p class="first admonition-title">Oracle</p> <p class="last">Oracle doesn’t support bitwise XOR operation.</p> </div>   <h3 id="using-transforms-in-expressions">Expressions can reference transforms</h3> <p id="s-expressions-can-reference-transforms">Django supports using transforms in expressions.</p> <p>For example, to find all <code>Entry</code> objects published in the same year as they were last modified:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.db.models import F
&gt;&gt;&gt; Entry.objects.filter(pub_date__year=F("mod_date__year"))
</pre> <p>To find the earliest year an entry was published, we can issue the query:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.db.models import Min
&gt;&gt;&gt; Entry.objects.aggregate(first_published_year=Min("pub_date__year"))
</pre> <p>This example finds the value of the highest rated entry and the total number of comments on all entries for each year:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.db.models import OuterRef, Subquery, Sum
&gt;&gt;&gt; Entry.objects.values("pub_date__year").annotate(
...     top_rating=Subquery(
...         Entry.objects.filter(
...             pub_date__year=OuterRef("pub_date__year"),
...         )
...         .order_by("-rating")
...         .values("rating")[:1]
...     ),
...     total_comments=Sum("number_of_comments"),
... )
</pre>   <h3 id="the-pk-lookup-shortcut">The <code>pk</code> lookup shortcut</h3> <p id="s-the-pk-lookup-shortcut">For convenience, Django provides a <code>pk</code> lookup shortcut, which stands for “primary key”.</p> <p>In the example <code>Blog</code> model, the primary key is the <code>id</code> field, so these three statements are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; Blog.objects.get(id__exact=14)  # Explicit form
&gt;&gt;&gt; Blog.objects.get(id=14)  # __exact is implied
&gt;&gt;&gt; Blog.objects.get(pk=14)  # pk implies id__exact
</pre> <p>The use of <code>pk</code> isn’t limited to <code>__exact</code> queries – any query term can be combined with <code>pk</code> to perform a query on the primary key of a model:</p> <pre data-language="pycon"># Get blogs entries with id 1, 4 and 7
&gt;&gt;&gt; Blog.objects.filter(pk__in=[1, 4, 7])

# Get all blog entries with id &gt; 14
&gt;&gt;&gt; Blog.objects.filter(pk__gt=14)
</pre> <p><code>pk</code> lookups also work across joins. For example, these three statements are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(blog__id__exact=3)  # Explicit form
&gt;&gt;&gt; Entry.objects.filter(blog__id=3)  # __exact is implied
&gt;&gt;&gt; Entry.objects.filter(blog__pk=3)  # __pk implies __id__exact
</pre>   <h3 id="escaping-percent-signs-and-underscores-in-like-statements">Escaping percent signs and underscores in <code>LIKE</code> statements</h3> <p id="s-escaping-percent-signs-and-underscores-in-like-statements">The field lookups that equate to <code>LIKE</code> SQL statements (<code>iexact</code>, <code>contains</code>, <code>icontains</code>, <code>startswith</code>, <code>istartswith</code>, <code>endswith</code> and <code>iendswith</code>) will automatically escape the two special characters used in <code>LIKE</code> statements – the percent sign and the underscore. (In a <code>LIKE</code> statement, the percent sign signifies a multiple-character wildcard and the underscore signifies a single-character wildcard.)</p> <p>This means things should work intuitively, so the abstraction doesn’t leak. For example, to retrieve all the entries that contain a percent sign, use the percent sign as any other character:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(headline__contains="%")
</pre> <p>Django takes care of the quoting for you; the resulting SQL will look something like this:</p> <pre data-language="sql">SELECT ... WHERE headline LIKE '%\%%';
</pre> <p>Same goes for underscores. Both percentage signs and underscores are handled for you transparently.</p>   <h3 id="id8">Caching and <code>QuerySet</code>s</h3> <p id="s-caching-and-querysets">Each <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> contains a cache to minimize database access. Understanding how it works will allow you to write the most efficient code.</p> <p>In a newly created <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>, the cache is empty. The first time a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> is evaluated – and, hence, a database query happens – Django saves the query results in the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>’s cache and returns the results that have been explicitly requested (e.g., the next element, if the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> is being iterated over). Subsequent evaluations of the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> reuse the cached results.</p> <p>Keep this caching behavior in mind, because it may bite you if you don’t use your <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>s correctly. For example, the following will create two <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>s, evaluate them, and throw them away:</p> <pre data-language="pycon">&gt;&gt;&gt; print([e.headline for e in Entry.objects.all()])
&gt;&gt;&gt; print([e.pub_date for e in Entry.objects.all()])
</pre> <p>That means the same database query will be executed twice, effectively doubling your database load. Also, there’s a possibility the two lists may not include the same database records, because an <code>Entry</code> may have been added or deleted in the split second between the two requests.</p> <p>To avoid this problem, save the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> and reuse it:</p> <pre data-language="pycon">&gt;&gt;&gt; queryset = Entry.objects.all()
&gt;&gt;&gt; print([p.headline for p in queryset])  # Evaluate the query set.
&gt;&gt;&gt; print([p.pub_date for p in queryset])  # Reuse the cache from the evaluation.
</pre>  <h4 id="when-querysets-are-not-cached">When <code>QuerySet</code>s are not cached</h4> <p id="s-when-querysets-are-not-cached">Querysets do not always cache their results. When evaluating only <em>part</em> of the queryset, the cache is checked, but if it is not populated then the items returned by the subsequent query are not cached. Specifically, this means that <a class="reference internal" href="#limiting-querysets"><span class="std std-ref">limiting the queryset</span></a> using an array slice or an index will not populate the cache.</p> <p>For example, repeatedly getting a certain index in a queryset object will query the database each time:</p> <pre data-language="pycon">&gt;&gt;&gt; queryset = Entry.objects.all()
&gt;&gt;&gt; print(queryset[5])  # Queries the database
&gt;&gt;&gt; print(queryset[5])  # Queries the database again
</pre> <p>However, if the entire queryset has already been evaluated, the cache will be checked instead:</p> <pre data-language="pycon">&gt;&gt;&gt; queryset = Entry.objects.all()
&gt;&gt;&gt; [entry for entry in queryset]  # Queries the database
&gt;&gt;&gt; print(queryset[5])  # Uses cache
&gt;&gt;&gt; print(queryset[5])  # Uses cache
</pre> <p>Here are some examples of other actions that will result in the entire queryset being evaluated and therefore populate the cache:</p> <pre data-language="pycon">&gt;&gt;&gt; [entry for entry in queryset]
&gt;&gt;&gt; bool(queryset)
&gt;&gt;&gt; entry in queryset
&gt;&gt;&gt; list(queryset)
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Simply printing the queryset will not populate the cache. This is because the call to <code>__repr__()</code> only returns a slice of the entire queryset.</p> </div>     <h2 id="async-queries">Asynchronous queries</h2> <p id="s-asynchronous-queries">If you are writing asynchronous views or code, you cannot use the ORM for queries in quite the way we have described above, as you cannot call <em>blocking</em> synchronous code from asynchronous code - it will block up the event loop (or, more likely, Django will notice and raise a <code>SynchronousOnlyOperation</code> to stop that from happening).</p> <p>Fortunately, you can do many queries using Django’s asynchronous query APIs. Every method that might block - such as <code>get()</code> or <code>delete()</code> - has an asynchronous variant (<code>aget()</code> or <code>adelete()</code>), and when you iterate over results, you can use asynchronous iteration (<code>async for</code>) instead.</p>  <h3 id="query-iteration">Query iteration</h3> <p id="s-query-iteration">The default way of iterating over a query - with <code>for</code> - will result in a blocking database query behind the scenes as Django loads the results at iteration time. To fix this, you can swap to <code>async for</code>:</p> <pre data-language="python">async for entry in Authors.objects.filter(name__startswith="A"):
    ...
</pre> <p>Be aware that you also can’t do other things that might iterate over the queryset, such as wrapping <code>list()</code> around it to force its evaluation (you can use <code>async for</code> in a comprehension, if you want it).</p> <p>Because <code>QuerySet</code> methods like <code>filter()</code> and <code>exclude()</code> do not actually run the query - they set up the queryset to run when it’s iterated over - you can use those freely in asynchronous code. For a guide to which methods can keep being used like this, and which have asynchronous versions, read the next section.</p>   <h3 id="queryset-and-manager-methods">
<code>QuerySet</code> and manager methods</h3> <p id="s-queryset-and-manager-methods">Some methods on managers and querysets - like <code>get()</code> and <code>first()</code> - force execution of the queryset and are blocking. Some, like <code>filter()</code> and <code>exclude()</code>, don’t force execution and so are safe to run from asynchronous code. But how are you supposed to tell the difference?</p> <p>While you could poke around and see if there is an <code>a</code>-prefixed version of the method (for example, we have <code>aget()</code> but not <code>afilter()</code>), there is a more logical way - look up what kind of method it is in the <a class="reference internal" href="../../ref/models/querysets.html"><span class="doc">QuerySet reference</span></a>.</p> <p>In there, you’ll find the methods on QuerySets grouped into two sections:</p> <ul class="simple"> <li>
<em>Methods that return new querysets</em>: These are the non-blocking ones, and don’t have asynchronous versions. You’re free to use these in any situation, though read the notes on <code>defer()</code> and <code>only()</code> before you use them.</li> <li>
<em>Methods that do not return querysets</em>: These are the blocking ones, and have asynchronous versions - the asynchronous name for each is noted in its documentation, though our standard pattern is to add an <code>a</code> prefix.</li> </ul> <p>Using this distinction, you can work out when you need to use asynchronous versions, and when you don’t. For example, here’s a valid asynchronous query:</p> <pre data-language="python">user = await User.objects.filter(username=my_input).afirst()
</pre> <p><code>filter()</code> returns a queryset, and so it’s fine to keep chaining it inside an asynchronous environment, whereas <code>first()</code> evaluates and returns a model instance - thus, we change to <code>afirst()</code>, and use <code>await</code> at the front of the whole expression in order to call it in an asynchronous-friendly way.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">If you forget to put the <code>await</code> part in, you may see errors like <em>“coroutine object has no attribute x”</em> or <em>“&lt;coroutine …&gt;”</em> strings in place of your model instances. If you ever see these, you are missing an <code>await</code> somewhere to turn that coroutine into a real value.</p> </div>   <h3 id="transactions">Transactions</h3> <p id="s-transactions">Transactions are <strong>not</strong> currently supported with asynchronous queries and updates. You will find that trying to use one raises <code>SynchronousOnlyOperation</code>.</p> <p>If you wish to use a transaction, we suggest you write your ORM code inside a separate, synchronous function and then call that using <code>sync_to_async</code> - see <a class="reference internal" href="../async.html"><span class="doc">Asynchronous support</span></a> for more.</p>    <h2 id="id9">Querying <code>JSONField</code>
</h2> <p id="s-querying-jsonfield">Lookups implementation is different in <a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code>JSONField</code></a>, mainly due to the existence of key transformations. To demonstrate, we will use the following example model:</p> <pre data-language="python">from django.db import models


class Dog(models.Model):
    name = models.CharField(max_length=200)
    data = models.JSONField(null=True)

    def __str__(self):
        return self.name
</pre>  <h3 id="storing-and-querying-for-none">Storing and querying for <code>None</code>
</h3> <p id="s-storing-and-querying-for-none">As with other fields, storing <code>None</code> as the field’s value will store it as SQL <code>NULL</code>. While not recommended, it is possible to store JSON scalar <code>null</code> instead of SQL <code>NULL</code> by using <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.Value" title="django.db.models.Value"><code>Value(None, JSONField())</code></a>.</p> <p>Whichever of the values is stored, when retrieved from the database, the Python representation of the JSON scalar <code>null</code> is the same as SQL <code>NULL</code>, i.e. <code>None</code>. Therefore, it can be hard to distinguish between them.</p> <p>This only applies to <code>None</code> as the top-level value of the field. If <code>None</code> is inside a <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.12)"><code>list</code></a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.12)"><code>dict</code></a>, it will always be interpreted as JSON <code>null</code>.</p> <p>When querying, <code>None</code> value will always be interpreted as JSON <code>null</code>. To query for SQL <code>NULL</code>, use <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-isnull"><code>isnull</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Max", data=None)  # SQL NULL.
&lt;Dog: Max&gt;
&gt;&gt;&gt; Dog.objects.create(name="Archie", data=Value(None, JSONField()))  # JSON null.
&lt;Dog: Archie&gt;
&gt;&gt;&gt; Dog.objects.filter(data=None)
&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;
&gt;&gt;&gt; Dog.objects.filter(data=Value(None, JSONField()))
&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;
&gt;&gt;&gt; Dog.objects.filter(data__isnull=True)
&lt;QuerySet [&lt;Dog: Max&gt;]&gt;
&gt;&gt;&gt; Dog.objects.filter(data__isnull=False)
&lt;QuerySet [&lt;Dog: Archie&gt;]&gt;
</pre> <p>Unless you are sure you wish to work with SQL <code>NULL</code> values, consider setting <code>null=False</code> and providing a suitable default for empty values, such as <code>default=dict</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Storing JSON scalar <code>null</code> does not violate <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.null" title="django.db.models.Field.null"><code>null=False</code></a>.</p> </div>   <h3 id="std:fieldlookup-jsonfield.key">Key, index, and path transforms</h3> <p id="s-key-index-and-path-transforms">To query based on a given dictionary key, use that key as the lookup name:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(
...     name="Rufus",
...     data={
...         "breed": "labrador",
...         "owner": {
...             "name": "Bob",
...             "other_pets": [
...                 {
...                     "name": "Fishy",
...                 }
...             ],
...         },
...     },
... )
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"breed": "collie", "owner": None})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.filter(data__breed="collie")
&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;
</pre> <p>Multiple keys can be chained together to form a path lookup:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.filter(data__owner__name="Bob")
&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;
</pre> <p>If the key is an integer, it will be interpreted as an index transform in an array:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.filter(data__owner__other_pets__0__name="Fishy")
&lt;QuerySet [&lt;Dog: Rufus&gt;]&gt;
</pre> <p>If the key you wish to query by clashes with the name of another lookup, use the <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code>contains</code></a> lookup instead.</p> <p>To query for missing keys, use the <code>isnull</code> lookup:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Shep", data={"breed": "collie"})
&lt;Dog: Shep&gt;
&gt;&gt;&gt; Dog.objects.filter(data__owner__isnull=True)
&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The lookup examples given above implicitly use the <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-exact"><code>exact</code></a> lookup. Key, index, and path transforms can also be chained with: <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-icontains"><code>icontains</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-endswith"><code>endswith</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iendswith"><code>iendswith</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iexact"><code>iexact</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-regex"><code>regex</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-iregex"><code>iregex</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-startswith"><code>startswith</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-istartswith"><code>istartswith</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lt"><code>lt</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-lte"><code>lte</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gt"><code>gt</code></a>, and <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-gte"><code>gte</code></a>, as well as with <a class="reference internal" href="#containment-and-key-lookups"><span class="std std-ref">Containment and key lookups</span></a>.</p> </div>  <h4 id="kt-expressions">
<code>KT()</code> expressions</h4> <dl class="py class" id="s-module-django.db.models.fields.json"> <dt class="sig sig-object py" id="django.db.models.fields.json.KT">
<code>class KT(lookup)</code> </dt> <dd>
<p>Represents the text value of a key, index, or path transform of <a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code>JSONField</code></a>. You can use the double underscore notation in <code>lookup</code> to chain dictionary key and index transforms.</p> <p>For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.db.models.fields.json import KT
&gt;&gt;&gt; Dog.objects.create(
...     name="Shep",
...     data={
...         "owner": {"name": "Bob"},
...         "breed": ["collie", "lhasa apso"],
...     },
... )
&lt;Dog: Shep&gt;
&gt;&gt;&gt; Dogs.objects.annotate(
...     first_breed=KT("data__breed__1"), owner_name=KT("data__owner__name")
... ).filter(first_breed__startswith="lhasa", owner_name="Bob")
&lt;QuerySet [&lt;Dog: Shep&gt;]&gt;
</pre> </dd>
</dl> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Due to the way in which key-path queries work, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a> are not guaranteed to produce exhaustive sets. If you want to include objects that do not have the path, add the <code>isnull</code> lookup.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">Since any string could be a key in a JSON object, any lookup other than those listed below will be interpreted as a key lookup. No errors are raised. Be extra careful for typing mistakes, and always check your queries work as you intend.</p> </div> <div class="admonition-mariadb-and-oracle-users admonition"> <p class="first admonition-title">MariaDB and Oracle users</p> <p class="last">Using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a> on key, index, or path transforms will sort the objects using the string representation of the values. This is because MariaDB and Oracle Database do not provide a function that converts JSON values into their equivalent SQL values.</p> </div> <div class="admonition-oracle-users admonition"> <p class="first admonition-title">Oracle users</p> <p class="last">On Oracle Database, using <code>None</code> as the lookup value in an <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a> query will return objects that do not have <code>null</code> as the value at the given path, including objects that do not have the path. On other database backends, the query will return objects that have the path and the value is not <code>null</code>.</p> </div> <div class="admonition-postgresql-users admonition"> <p class="first admonition-title">PostgreSQL users</p> <p class="last">On PostgreSQL, if only one key or index is used, the SQL operator <code>-&gt;</code> is used. If multiple operators are used then the <code>#&gt;</code> operator is used.</p> </div> <div class="admonition-sqlite-users admonition"> <p class="first admonition-title">SQLite users</p> <p class="last">On SQLite, <code>"true"</code>, <code>"false"</code>, and <code>"null"</code> string values will always be interpreted as <code>True</code>, <code>False</code>, and JSON <code>null</code> respectively.</p> </div>    <h3 id="id10">Containment and key lookups</h3>  <h4 id="std:fieldlookup-jsonfield.contains"><code>contains</code></h4> <p id="s-containment-and-key-lookups">The <a class="reference internal" href="../../ref/models/querysets.html#std-fieldlookup-contains"><code>contains</code></a> lookup is overridden on <code>JSONField</code>. The returned objects are those where the given <code>dict</code> of key-value pairs are all contained in the top-level of the field. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Rufus", data={"breed": "labrador", "owner": "Bob"})
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.create(name="Fred", data={})
&lt;Dog: Fred&gt;
&gt;&gt;&gt; Dog.objects.filter(data__contains={"owner": "Bob"})
&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;
&gt;&gt;&gt; Dog.objects.filter(data__contains={"breed": "collie"})
&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;
</pre> <div class="admonition-oracle-and-sqlite admonition"> <p class="first admonition-title">Oracle and SQLite</p> <p class="last"><code>contains</code> is not supported on Oracle and SQLite.</p> </div>   <h4 id="std:fieldlookup-jsonfield.contained_by"><code>contained_by</code></h4> <p id="s-contained-by">This is the inverse of the <a class="reference internal" href="#std-fieldlookup-jsonfield.contains"><code>contains</code></a> lookup - the objects returned will be those where the key-value pairs on the object are a subset of those in the value passed. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Rufus", data={"breed": "labrador", "owner": "Bob"})
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.create(name="Fred", data={})
&lt;Dog: Fred&gt;
&gt;&gt;&gt; Dog.objects.filter(data__contained_by={"breed": "collie", "owner": "Bob"})
&lt;QuerySet [&lt;Dog: Meg&gt;, &lt;Dog: Fred&gt;]&gt;
&gt;&gt;&gt; Dog.objects.filter(data__contained_by={"breed": "collie"})
&lt;QuerySet [&lt;Dog: Fred&gt;]&gt;
</pre> <div class="admonition-oracle-and-sqlite admonition"> <p class="first admonition-title">Oracle and SQLite</p> <p class="last"><code>contained_by</code> is not supported on Oracle and SQLite.</p> </div>   <h4 id="std:fieldlookup-jsonfield.has_key"><code>has_key</code></h4> <p id="s-has-key">Returns objects where the given key is in the top-level of the data. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Rufus", data={"breed": "labrador"})
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.filter(data__has_key="owner")
&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;
</pre>   <h4 id="std:fieldlookup-jsonfield.has_any_keys"><code>has_keys</code></h4> <p id="s-has-keys">Returns objects where all of the given keys are in the top-level of the data. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Rufus", data={"breed": "labrador"})
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"breed": "collie", "owner": "Bob"})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.filter(data__has_keys=["breed", "owner"])
&lt;QuerySet [&lt;Dog: Meg&gt;]&gt;
</pre>   <h4 id="std:fieldlookup-jsonfield.has_keys"><code>has_any_keys</code></h4> <p id="s-has-any-keys">Returns objects where any of the given keys are in the top-level of the data. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; Dog.objects.create(name="Rufus", data={"breed": "labrador"})
&lt;Dog: Rufus&gt;
&gt;&gt;&gt; Dog.objects.create(name="Meg", data={"owner": "Bob"})
&lt;Dog: Meg&gt;
&gt;&gt;&gt; Dog.objects.filter(data__has_any_keys=["owner", "breed"])
&lt;QuerySet [&lt;Dog: Rufus&gt;, &lt;Dog: Meg&gt;]&gt;
</pre>     <h2 id="complex-lookups-with-q">Complex lookups with <code>Q</code> objects</h2> <p id="s-complex-lookups-with-q-objects">Keyword argument queries – in <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, etc. – are “AND”ed together. If you need to execute more complex queries (for example, queries with <code>OR</code> statements), you can use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code>Q objects</code></a>.</p> <p>A <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code>Q object</code></a> (<code>django.db.models.Q</code>) is an object used to encapsulate a collection of keyword arguments. These keyword arguments are specified as in “Field lookups” above.</p> <p>For example, this <code>Q</code> object encapsulates a single <code>LIKE</code> query:</p> <pre data-language="python">from django.db.models import Q

Q(question__startswith="What")
</pre> <p><code>Q</code> objects can be combined using the <code>&amp;</code>, <code>|</code>, and <code>^</code> operators. When an operator is used on two <code>Q</code> objects, it yields a new <code>Q</code> object.</p> <p>For example, this statement yields a single <code>Q</code> object that represents the “OR” of two <code>"question__startswith"</code> queries:</p> <pre data-language="python">Q(question__startswith="Who") | Q(question__startswith="What")
</pre> <p>This is equivalent to the following SQL <code>WHERE</code> clause:</p> <pre data-language="sql">WHERE question LIKE 'Who%' OR question LIKE 'What%'
</pre> <p>You can compose statements of arbitrary complexity by combining <code>Q</code> objects with the <code>&amp;</code>, <code>|</code>, and <code>^</code> operators and use parenthetical grouping. Also, <code>Q</code> objects can be negated using the <code>~</code> operator, allowing for combined lookups that combine both a normal query and a negated (<code>NOT</code>) query:</p> <pre data-language="python">Q(question__startswith="Who") | ~Q(pub_date__year=2005)
</pre> <p>Each lookup function that takes keyword-arguments (e.g. <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a>) can also be passed one or more <code>Q</code> objects as positional (not-named) arguments. If you provide multiple <code>Q</code> object arguments to a lookup function, the arguments will be “AND”ed together. For example:</p> <pre data-language="python">Poll.objects.get(
    Q(question__startswith="Who"),
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)
</pre> <p>… roughly translates into the SQL:</p> <pre data-language="sql">SELECT * from polls WHERE question LIKE 'Who%'
    AND (pub_date = '2005-05-02' OR pub_date = '2005-05-06')
</pre> <p>Lookup functions can mix the use of <code>Q</code> objects and keyword arguments. All arguments provided to a lookup function (be they keyword arguments or <code>Q</code> objects) are “AND”ed together. However, if a <code>Q</code> object is provided, it must precede the definition of any keyword arguments. For example:</p> <pre data-language="python">Poll.objects.get(
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
    question__startswith="Who",
)
</pre> <p>… would be a valid query, equivalent to the previous example; but:</p> <pre data-language="python"># INVALID QUERY
Poll.objects.get(
    question__startswith="Who",
    Q(pub_date=date(2005, 5, 2)) | Q(pub_date=date(2005, 5, 6)),
)
</pre> <p>… would not be valid.</p> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last">The <a class="reference external" href="https://github.com/django/django/blob/main/tests/or_lookups/tests.py">OR lookups examples</a> in Django’s unit tests show some possible uses of <code>Q</code>.</p> </div>   <h2 id="comparing-objects">Comparing objects</h2> <p id="s-comparing-objects">To compare two model instances, use the standard Python comparison operator, the double equals sign: <code>==</code>. Behind the scenes, that compares the primary key values of two models.</p> <p>Using the <code>Entry</code> example above, the following two statements are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; some_entry == other_entry
&gt;&gt;&gt; some_entry.id == other_entry.id
</pre> <p>If a model’s primary key isn’t called <code>id</code>, no problem. Comparisons will always use the primary key, whatever it’s called. For example, if a model’s primary key field is called <code>name</code>, these two statements are equivalent:</p> <pre data-language="pycon">&gt;&gt;&gt; some_obj == other_obj
&gt;&gt;&gt; some_obj.name == other_obj.name
</pre>   <h2 id="topics-db-queries-delete">Deleting objects</h2> <p id="s-deleting-objects">The delete method, conveniently, is named <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.delete" title="django.db.models.Model.delete"><code>delete()</code></a>. This method immediately deletes the object and returns the number of objects deleted and a dictionary with the number of deletions per object type. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e.delete()
(1, {'blog.Entry': 1})
</pre> <p>You can also delete objects in bulk. Every <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> has a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code>delete()</code></a> method, which deletes all members of that <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>.</p> <p>For example, this deletes all <code>Entry</code> objects with a <code>pub_date</code> year of 2005:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.filter(pub_date__year=2005).delete()
(5, {'webapp.Entry': 5})
</pre> <p>Keep in mind that this will, whenever possible, be executed purely in SQL, and so the <code>delete()</code> methods of individual object instances will not necessarily be called during the process. If you’ve provided a custom <code>delete()</code> method on a model class and want to ensure that it is called, you will need to “manually” delete instances of that model (e.g., by iterating over a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> and calling <code>delete()</code> on each object individually) rather than using the bulk <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code>delete()</code></a> method of a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>.</p> <p>When Django deletes an object, by default it emulates the behavior of the SQL constraint <code>ON DELETE CASCADE</code> – in other words, any objects which had foreign keys pointing at the object to be deleted will be deleted along with it. For example:</p> <pre data-language="python">b = Blog.objects.get(pk=1)
# This will delete the Blog and all of its Entry objects.
b.delete()
</pre> <p>This cascade behavior is customizable via the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.on_delete" title="django.db.models.ForeignKey.on_delete"><code>on_delete</code></a> argument to the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>.</p> <p>Note that <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code>delete()</code></a> is the only <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> method that is not exposed on a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> itself. This is a safety mechanism to prevent you from accidentally requesting <code>Entry.objects.delete()</code>, and deleting <em>all</em> the entries. If you <em>do</em> want to delete all the objects, then you have to explicitly request a complete query set:</p> <pre data-language="python">Entry.objects.all().delete()
</pre>   <h2 id="topics-db-queries-copy">Copying model instances</h2> <p id="s-copying-model-instances">Although there is no built-in method for copying model instances, it is possible to easily create new instance with all fields’ values copied. In the simplest case, you can set <code>pk</code> to <code>None</code> and <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model._state" title="django.db.models.Model._state"><code>_state.adding</code></a> to <code>True</code>. Using our blog example:</p> <pre data-language="python">blog = Blog(name="My blog", tagline="Blogging is easy")
blog.save()  # blog.pk == 1

blog.pk = None
blog._state.adding = True
blog.save()  # blog.pk == 2
</pre> <p>Things get more complicated if you use inheritance. Consider a subclass of <code>Blog</code>:</p> <pre data-language="python">class ThemeBlog(Blog):
    theme = models.CharField(max_length=200)


django_blog = ThemeBlog(name="Django", tagline="Django is easy", theme="python")
django_blog.save()  # django_blog.pk == 3
</pre> <p>Due to how inheritance works, you have to set both <code>pk</code> and <code>id</code> to <code>None</code>, and <code>_state.adding</code> to <code>True</code>:</p> <pre data-language="python">django_blog.pk = None
django_blog.id = None
django_blog._state.adding = True
django_blog.save()  # django_blog.pk == 4
</pre> <p>This process doesn’t copy relations that aren’t part of the model’s database table. For example, <code>Entry</code> has a <code>ManyToManyField</code> to <code>Author</code>. After duplicating an entry, you must set the many-to-many relations for the new entry:</p> <pre data-language="python">entry = Entry.objects.all()[0]  # some previous entry
old_authors = entry.authors.all()
entry.pk = None
entry._state.adding = True
entry.save()
entry.authors.set(old_authors)
</pre> <p>For a <code>OneToOneField</code>, you must duplicate the related object and assign it to the new object’s field to avoid violating the one-to-one unique constraint. For example, assuming <code>entry</code> is already duplicated as above:</p> <pre data-language="python">detail = EntryDetail.objects.all()[0]
detail.pk = None
detail._state.adding = True
detail.entry = entry
detail.save()
</pre>   <h2 id="topics-db-queries-update">Updating multiple objects at once</h2> <p id="s-updating-multiple-objects-at-once">Sometimes you want to set a field to a particular value for all the objects in a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a>. You can do this with the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.update" title="django.db.models.query.QuerySet.update"><code>update()</code></a> method. For example:</p> <pre data-language="python"># Update all the headlines with pub_date in 2007.
Entry.objects.filter(pub_date__year=2007).update(headline="Everything is the same")
</pre> <p>You can only set non-relation fields and <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> fields using this method. To update a non-relation field, provide the new value as a constant. To update <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> fields, set the new value to be the new model instance you want to point to. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; b = Blog.objects.get(pk=1)

# Change every Entry so that it belongs to this Blog.
&gt;&gt;&gt; Entry.objects.update(blog=b)
</pre> <p>The <code>update()</code> method is applied instantly and returns the number of rows matched by the query (which may not be equal to the number of rows updated if some rows already have the new value). The only restriction on the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> being updated is that it can only access one database table: the model’s main table. You can filter based on related fields, but you can only update columns in the model’s main table. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; b = Blog.objects.get(pk=1)

# Update all the headlines belonging to this Blog.
&gt;&gt;&gt; Entry.objects.filter(blog=b).update(headline="Everything is the same")
</pre> <p>Be aware that the <code>update()</code> method is converted directly to an SQL statement. It is a bulk operation for direct updates. It doesn’t run any <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> methods on your models, or emit the <code>pre_save</code> or <code>post_save</code> signals (which are a consequence of calling <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>), or honor the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField.auto_now" title="django.db.models.DateField.auto_now"><code>auto_now</code></a> field option. If you want to save every item in a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> and make sure that the <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a> method is called on each instance, you don’t need any special function to handle that. Loop over them and call <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>:</p> <pre data-language="python">for item in my_queryset:
    item.save()
</pre> <p>Calls to update can also use <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code>F expressions</code></a> to update one field based on the value of another field in the model. This is especially useful for incrementing counters based upon their current value. For example, to increment the pingback count for every entry in the blog:</p> <pre data-language="pycon">&gt;&gt;&gt; Entry.objects.update(number_of_pingbacks=F("number_of_pingbacks") + 1)
</pre> <p>However, unlike <code>F()</code> objects in filter and exclude clauses, you can’t introduce joins when you use <code>F()</code> objects in an update – you can only reference fields local to the model being updated. If you attempt to introduce a join with an <code>F()</code> object, a <code>FieldError</code> will be raised:</p> <pre data-language="pycon"># This will raise a FieldError
&gt;&gt;&gt; Entry.objects.update(headline=F("blog__name"))
</pre>   <h2 id="topics-db-queries-related">Related objects</h2> <p id="s-related-objects">When you define a relationship in a model (i.e., a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>, <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a>, or <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a>), instances of that model will have a convenient API to access the related object(s).</p> <p>Using the models at the top of this page, for example, an <code>Entry</code> object <code>e</code> can get its associated <code>Blog</code> object by accessing the <code>blog</code> attribute: <code>e.blog</code>.</p> <p>(Behind the scenes, this functionality is implemented by Python <a class="reference external" href="https://docs.python.org/3/howto/descriptor.html" title="(in Python v3.12)"><span class="xref std std-doc">descriptors</span></a>. This shouldn’t really matter to you, but we point it out here for the curious.)</p> <p>Django also creates API accessors for the “other” side of the relationship – the link from the related model to the model that defines the relationship. For example, a <code>Blog</code> object <code>b</code> has access to a list of all related <code>Entry</code> objects via the <code>entry_set</code> attribute: <code>b.entry_set.all()</code>.</p> <p>All examples in this section use the sample <code>Blog</code>, <code>Author</code> and <code>Entry</code> models defined at the top of this page.</p>  <h3 id="one-to-many-relationships">One-to-many relationships</h3>  <h4 id="forward">Forward</h4> <p id="s-one-to-many-relationships">If a model has a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>, instances of that model will have access to the related (foreign) object via an attribute of the model.</p> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog  # Returns the related Blog object.
</pre> <p>You can get and set via a foreign-key attribute. As you may expect, changes to the foreign key aren’t saved to the database until you call <a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.save" title="django.db.models.Model.save"><code>save()</code></a>. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog = some_blog
&gt;&gt;&gt; e.save()
</pre> <p>If a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> field has <code>null=True</code> set (i.e., it allows <code>NULL</code> values), you can assign <code>None</code> to remove the relation. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; e.blog = None
&gt;&gt;&gt; e.save()  # "UPDATE blog_entry SET blog_id = NULL ...;"
</pre> <p>Forward access to one-to-many relationships is cached the first time the related object is accessed. Subsequent accesses to the foreign key on the same object instance are cached. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e = Entry.objects.get(id=2)
&gt;&gt;&gt; print(e.blog)  # Hits the database to retrieve the associated Blog.
&gt;&gt;&gt; print(e.blog)  # Doesn't hit the database; uses cached version.
</pre> <p>Note that the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a> <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> method recursively prepopulates the cache of all one-to-many relationships ahead of time. Example:</p> <pre data-language="pycon">&gt;&gt;&gt; e = Entry.objects.select_related().get(id=2)
&gt;&gt;&gt; print(e.blog)  # Doesn't hit the database; uses cached version.
&gt;&gt;&gt; print(e.blog)  # Doesn't hit the database; uses cached version.
</pre>   <h4 id="backwards-related-objects">Following relationships “backward”</h4> <p id="s-following-relationships-backward">If a model has a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>, instances of the foreign-key model will have access to a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> that returns all instances of the first model. By default, this <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> is named <code>FOO_set</code>, where <code>FOO</code> is the source model name, lowercased. This <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> returns <code>QuerySets</code>, which can be filtered and manipulated as described in the “Retrieving objects” section above.</p> <p>Example:</p> <pre data-language="pycon">&gt;&gt;&gt; b = Blog.objects.get(id=1)
&gt;&gt;&gt; b.entry_set.all()  # Returns all Entry objects related to Blog.

# b.entry_set is a Manager that returns QuerySets.
&gt;&gt;&gt; b.entry_set.filter(headline__contains="Lennon")
&gt;&gt;&gt; b.entry_set.count()
</pre> <p>You can override the <code>FOO_set</code> name by setting the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code>related_name</code></a> parameter in the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> definition. For example, if the <code>Entry</code> model was altered to <code>blog = ForeignKey(Blog, on_delete=models.CASCADE,
related_name='entries')</code>, the above example code would look like this:</p> <pre data-language="pycon">&gt;&gt;&gt; b = Blog.objects.get(id=1)
&gt;&gt;&gt; b.entries.all()  # Returns all Entry objects related to Blog.

# b.entries is a Manager that returns QuerySets.
&gt;&gt;&gt; b.entries.filter(headline__contains="Lennon")
&gt;&gt;&gt; b.entries.count()
</pre>   <h4 id="using-custom-reverse-manager">Using a custom reverse manager</h4> <p id="s-using-a-custom-reverse-manager">By default the <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager" title="django.db.models.fields.related.RelatedManager"><code>RelatedManager</code></a> used for reverse relations is a subclass of the <a class="reference internal" href="managers.html#manager-names"><span class="std std-ref">default manager</span></a> for that model. If you would like to specify a different manager for a given query you can use the following syntax:</p> <pre data-language="python">from django.db import models


class Entry(models.Model):
    # ...
    objects = models.Manager()  # Default Manager
    entries = EntryManager()  # Custom Manager


b = Blog.objects.get(id=1)
b.entry_set(manager="entries").all()
</pre> <p>If <code>EntryManager</code> performed default filtering in its <code>get_queryset()</code> method, that filtering would apply to the <code>all()</code> call.</p> <p>Specifying a custom reverse manager also enables you to call its custom methods:</p> <pre data-language="python">b.entry_set(manager="entries").is_published()
</pre> <div class="admonition-interaction-with-prefetching admonition"> <p class="first admonition-title">Interaction with prefetching</p> <p>When calling <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code>prefetch_related()</code></a> with a reverse relation, the default manager will be used. If you want to prefetch related objects using a custom reverse manager, use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Prefetch" title="django.db.models.Prefetch"><code>Prefetch()</code></a>. For example:</p> <pre data-language="python">from django.db.models import Prefetch

prefetch_manager = Prefetch("entry_set", queryset=Entry.entries.all())
Blog.objects.prefetch_related(prefetch_manager)
</pre> </div>   <h4 id="additional-methods-to-handle-related-objects">Additional methods to handle related objects</h4> <p id="s-additional-methods-to-handle-related-objects">In addition to the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet" title="django.db.models.query.QuerySet"><code>QuerySet</code></a> methods defined in “Retrieving objects” above, the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a> <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> has additional methods used to handle the set of related objects. A synopsis of each is below, and complete details can be found in the <a class="reference internal" href="../../ref/models/relations.html"><span class="doc">related objects reference</span></a>.</p> <dl class="docutils"> <dt>
<code>add(obj1, obj2, ...)</code> </dt>
<dd>Adds the specified model objects to the related object set.</dd> <dt>
<code>create(**kwargs)</code> </dt>
<dd>Creates a new object, saves it and puts it in the related object set. Returns the newly created object.</dd> <dt>
<code>remove(obj1, obj2, ...)</code> </dt>
<dd>Removes the specified model objects from the related object set.</dd> <dt>
<code>clear()</code> </dt>
<dd>Removes all objects from the related object set.</dd> <dt>
<code>set(objs)</code> </dt>
<dd>Replace the set of related objects.</dd> </dl> <p>To assign the members of a related set, use the <code>set()</code> method with an iterable of object instances. For example, if <code>e1</code> and <code>e2</code> are <code>Entry</code> instances:</p> <pre data-language="python">b = Blog.objects.get(id=1)
b.entry_set.set([e1, e2])
</pre> <p>If the <code>clear()</code> method is available, any preexisting objects will be removed from the <code>entry_set</code> before all objects in the iterable (in this case, a list) are added to the set. If the <code>clear()</code> method is <em>not</em> available, all objects in the iterable will be added without removing any existing elements.</p> <p>Each “reverse” operation described in this section has an immediate effect on the database. Every addition, creation and deletion is immediately and automatically saved to the database.</p>    <h3 id="m2m-reverse-relationships">Many-to-many relationships</h3> <p id="s-many-to-many-relationships">Both ends of a many-to-many relationship get automatic API access to the other end. The API works similar to a “backward” one-to-many relationship, above.</p> <p>One difference is in the attribute naming: The model that defines the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> uses the attribute name of that field itself, whereas the “reverse” model uses the lowercased model name of the original model, plus <code>'_set'</code> (just like reverse one-to-many relationships).</p> <p>An example makes this easier to understand:</p> <pre data-language="python">e = Entry.objects.get(id=3)
e.authors.all()  # Returns all Author objects for this Entry.
e.authors.count()
e.authors.filter(name__contains="John")

a = Author.objects.get(id=5)
a.entry_set.all()  # Returns all Entry objects for this Author.
</pre> <p>Like <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a>, <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> can specify <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.related_name" title="django.db.models.ManyToManyField.related_name"><code>related_name</code></a>. In the above example, if the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> in <code>Entry</code> had specified <code>related_name='entries'</code>, then each <code>Author</code> instance would have an <code>entries</code> attribute instead of <code>entry_set</code>.</p> <p>Another difference from one-to-many relationships is that in addition to model instances, the <code>add()</code>, <code>set()</code>, and <code>remove()</code> methods on many-to-many relationships accept primary key values. For example, if <code>e1</code> and <code>e2</code> are <code>Entry</code> instances, then these <code>set()</code> calls work identically:</p> <pre data-language="python">a = Author.objects.get(id=5)
a.entry_set.set([e1, e2])
a.entry_set.set([e1.pk, e2.pk])
</pre>   <h3 id="one-to-one-relationships">One-to-one relationships</h3> <p id="s-one-to-one-relationships">One-to-one relationships are very similar to many-to-one relationships. If you define a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.OneToOneField" title="django.db.models.OneToOneField"><code>OneToOneField</code></a> on your model, instances of that model will have access to the related object via an attribute of the model.</p> <p>For example:</p> <pre data-language="python">class EntryDetail(models.Model):
    entry = models.OneToOneField(Entry, on_delete=models.CASCADE)
    details = models.TextField()


ed = EntryDetail.objects.get(id=2)
ed.entry  # Returns the related Entry object.
</pre> <p>The difference comes in “reverse” queries. The related model in a one-to-one relationship also has access to a <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> object, but that <a class="reference internal" href="managers.html#django.db.models.Manager" title="django.db.models.Manager"><code>Manager</code></a> represents a single object, rather than a collection of objects:</p> <pre data-language="python">e = Entry.objects.get(id=2)
e.entrydetail  # returns the related EntryDetail object
</pre> <p>If no object has been assigned to this relationship, Django will raise a <code>DoesNotExist</code> exception.</p> <p>Instances can be assigned to the reverse relationship in the same way as you would assign the forward relationship:</p> <pre data-language="python">e.entrydetail = ed
</pre>   <h3 id="how-are-the-backward-relationships-possible">How are the backward relationships possible?</h3> <p id="s-how-are-the-backward-relationships-possible">Other object-relational mappers require you to define relationships on both sides. The Django developers believe this is a violation of the DRY (Don’t Repeat Yourself) principle, so Django only requires you to define the relationship on one end.</p> <p>But how is this possible, given that a model class doesn’t know which other model classes are related to it until those other model classes are loaded?</p> <p>The answer lies in the <a class="reference internal" href="../../ref/applications.html#django.apps.apps" title="django.apps.apps"><code>app registry</code></a>. When Django starts, it imports each application listed in <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>, and then the <code>models</code> module inside each application. Whenever a new model class is created, Django adds backward-relationships to any related models. If the related models haven’t been imported yet, Django keeps tracks of the relationships and adds them when the related models eventually are imported.</p> <p>For this reason, it’s particularly important that all the models you’re using be defined in applications listed in <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>. Otherwise, backwards relations may not work properly.</p>   <h3 id="queries-over-related-objects">Queries over related objects</h3> <p id="s-queries-over-related-objects">Queries involving related objects follow the same rules as queries involving normal value fields. When specifying the value for a query to match, you may use either an object instance itself, or the primary key value for the object.</p> <p>For example, if you have a Blog object <code>b</code> with <code>id=5</code>, the following three queries would be identical:</p> <pre data-language="python">Entry.objects.filter(blog=b)  # Query using object instance
Entry.objects.filter(blog=b.id)  # Query using id from instance
Entry.objects.filter(blog=5)  # Query using id directly
</pre>    <h2 id="falling-back-to-raw-sql">Falling back to raw SQL</h2> <p id="s-falling-back-to-raw-sql">If you find yourself needing to write an SQL query that is too complex for Django’s database-mapper to handle, you can fall back on writing SQL by hand. Django has a couple of options for writing raw SQL queries; see <a class="reference internal" href="sql.html"><span class="doc">Performing raw SQL queries</span></a>.</p> <p>Finally, it’s important to note that the Django database layer is merely an interface to your database. You can access your database via other tools, programming languages or database frameworks; there’s nothing Django-specific about your database.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.1/topics/db/queries/" class="_attribution-link">https://docs.djangoproject.com/en/5.1/topics/db/queries/</a>
  </p>
</div>
