<h1 id="database-access-optimization">Database access optimization</h1> <p id="s-database-access-optimization">Django’s database layer provides various ways to help developers get the most out of their databases. This document gathers together links to the relevant documentation, and adds various tips, organized under a number of headings that outline the steps to take when attempting to optimize your database usage.</p>  <h2 id="profile-first">Profile first</h2> <p id="s-profile-first">As general programming practice, this goes without saying. Find out <a class="reference internal" href="https://docs.djangoproject.com/en/5.1/faq/models/#faq-see-raw-sql-queries"><span class="std std-ref">what queries you are doing and what they are costing you</span></a>. Use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.explain" title="django.db.models.query.QuerySet.explain"><code>QuerySet.explain()</code></a> to understand how specific <code>QuerySet</code>s are executed by your database. You may also want to use an external project like <a class="reference external" href="https://pypi.org/project/django-debug-toolbar/">django-debug-toolbar</a>, or a tool that monitors your database directly.</p> <p>Remember that you may be optimizing for speed or memory or both, depending on your requirements. Sometimes optimizing for one will be detrimental to the other, but sometimes they will help each other. Also, work that is done by the database process might not have the same cost (to you) as the same amount of work done in your Python process. It is up to you to decide what your priorities are, where the balance must lie, and profile all of these as required since this will depend on your application and server.</p> <p>With everything that follows, remember to profile after every change to ensure that the change is a benefit, and a big enough benefit given the decrease in readability of your code. <strong>All</strong> of the suggestions below come with the caveat that in your circumstances the general principle might not apply, or might even be reversed.</p>   <h2 id="use-standard-db-optimization-techniques">Use standard DB optimization techniques</h2> <p id="s-use-standard-db-optimization-techniques">…including:</p> <ul class="simple"> <li>
<a class="reference external" href="https://en.wikipedia.org/wiki/Database_index">Indexes</a>. This is a number one priority, <em>after</em> you have determined from profiling what indexes should be added. Use <a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.indexes" title="django.db.models.Options.indexes"><code>Meta.indexes</code></a> or <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.db_index" title="django.db.models.Field.db_index"><code>Field.db_index</code></a> to add these from Django. Consider adding indexes to fields that you frequently query using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.filter" title="django.db.models.query.QuerySet.filter"><code>filter()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.exclude" title="django.db.models.query.QuerySet.exclude"><code>exclude()</code></a>, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a>, etc. as indexes may help to speed up lookups. Note that determining the best indexes is a complex database-dependent topic that will depend on your particular application. The overhead of maintaining an index may outweigh any gains in query speed.</li> </ul> <ul class="simple"> <li>Appropriate use of field types.</li> </ul> <p>We will assume you have done the things listed above. The rest of this document focuses on how to use Django in such a way that you are not doing unnecessary work. This document also does not address other optimization techniques that apply to all expensive operations, such as <a class="reference internal" href="../cache.html"><span class="doc">general purpose caching</span></a>.</p>   <h2 id="understand-querysets">Understand <code>QuerySet</code>s</h2> <p id="s-understand-querysets">Understanding <a class="reference internal" href="../../ref/models/querysets.html"><span class="doc">QuerySets</span></a> is vital to getting good performance with simple code. In particular:</p>  <h3 id="understand-queryset-evaluation">Understand <code>QuerySet</code> evaluation</h3> <p id="s-understand-queryset-evaluation">To avoid performance problems, it is important to understand:</p> <ul class="simple"> <li>that <a class="reference internal" href="queries.html#querysets-are-lazy"><span class="std std-ref">QuerySets are lazy</span></a>.</li> <li>when <a class="reference internal" href="../../ref/models/querysets.html#when-querysets-are-evaluated"><span class="std std-ref">they are evaluated</span></a>.</li> <li>how <a class="reference internal" href="queries.html#caching-and-querysets"><span class="std std-ref">the data is held in memory</span></a>.</li> </ul>   <h3 id="understand-cached-attributes">Understand cached attributes</h3> <p id="s-understand-cached-attributes">As well as caching of the whole <code>QuerySet</code>, there is caching of the result of attributes on ORM objects. In general, attributes that are not callable will be cached. For example, assuming the <a class="reference internal" href="queries.html#queryset-model-example"><span class="std std-ref">example blog models</span></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; entry = Entry.objects.get(id=1)
&gt;&gt;&gt; entry.blog  # Blog object is retrieved at this point
&gt;&gt;&gt; entry.blog  # cached version, no DB access
</pre> <p>But in general, callable attributes cause DB lookups every time:</p> <pre data-language="pycon">&gt;&gt;&gt; entry = Entry.objects.get(id=1)
&gt;&gt;&gt; entry.authors.all()  # query performed
&gt;&gt;&gt; entry.authors.all()  # query performed again
</pre> <p>Be careful when reading template code - the template system does not allow use of parentheses, but will call callables automatically, hiding the above distinction.</p> <p>Be careful with your own custom properties - it is up to you to implement caching when required, for example using the <a class="reference internal" href="../../ref/utils.html#django.utils.functional.cached_property" title="django.utils.functional.cached_property"><code>cached_property</code></a> decorator.</p>   <h3 id="use-the-with-template-tag">Use the <code>with</code> template tag</h3> <p id="s-use-the-with-template-tag">To make use of the caching behavior of <code>QuerySet</code>, you may need to use the <a class="reference internal" href="../../ref/templates/builtins.html#std-templatetag-with"><code>with</code></a> template tag.</p>   <h3 id="use-iterator">Use <code>iterator()</code>
</h3> <p id="s-use-iterator">When you have a lot of objects, the caching behavior of the <code>QuerySet</code> can cause a large amount of memory to be used. In this case, <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.iterator" title="django.db.models.query.QuerySet.iterator"><code>iterator()</code></a> may help.</p>   <h3 id="use-explain">Use <code>explain()</code>
</h3> <p id="s-use-explain"><a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.explain" title="django.db.models.query.QuerySet.explain"><code>QuerySet.explain()</code></a> gives you detailed information about how the database executes a query, including indexes and joins that are used. These details may help you find queries that could be rewritten more efficiently, or identify indexes that could be added to improve performance.</p>    <h2 id="do-database-work-in-the-database-rather-than-in-python">Do database work in the database rather than in Python</h2> <p id="s-do-database-work-in-the-database-rather-than-in-python">For instance:</p> <ul class="simple"> <li>At the most basic level, use <a class="reference internal" href="../../ref/models/querysets.html#queryset-api"><span class="std std-ref">filter and exclude</span></a> to do filtering in the database.</li> <li>Use <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.F" title="django.db.models.F"><code>F expressions</code></a> to filter based on other fields within the same model.</li> <li>Use <a class="reference internal" href="aggregation.html"><span class="doc">annotate to do aggregation in the database</span></a>.</li> </ul> <p>If these aren’t enough to generate the SQL you need:</p>  <h3 id="use-rawsql">Use <code>RawSQL</code>
</h3> <p id="s-use-rawsql">A less portable but more powerful method is the <a class="reference internal" href="../../ref/models/expressions.html#django.db.models.expressions.RawSQL" title="django.db.models.expressions.RawSQL"><code>RawSQL</code></a> expression, which allows some SQL to be explicitly added to the query. If that still isn’t powerful enough:</p>   <h3 id="use-raw-sql">Use raw SQL</h3> <p id="s-use-raw-sql">Write your own <a class="reference internal" href="sql.html"><span class="doc">custom SQL to retrieve data or populate models</span></a>. Use <code>django.db.connection.queries</code> to find out what Django is writing for you and start from there.</p>    <h2 id="retrieve-individual-objects-using-a-unique-indexed-column">Retrieve individual objects using a unique, indexed column</h2> <p id="s-retrieve-individual-objects-using-a-unique-indexed-column">There are two reasons to use a column with <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.unique" title="django.db.models.Field.unique"><code>unique</code></a> or <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.db_index" title="django.db.models.Field.db_index"><code>db_index</code></a> when using <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.get" title="django.db.models.query.QuerySet.get"><code>get()</code></a> to retrieve individual objects. First, the query will be quicker because of the underlying database index. Also, the query could run much slower if multiple objects match the lookup; having a unique constraint on the column guarantees this will never happen.</p> <p>So using the <a class="reference internal" href="queries.html#queryset-model-example"><span class="std std-ref">example blog models</span></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; entry = Entry.objects.get(id=10)
</pre> <p>will be quicker than:</p> <pre data-language="pycon">&gt;&gt;&gt; entry = Entry.objects.get(headline="News Item Title")
</pre> <p>because <code>id</code> is indexed by the database and is guaranteed to be unique.</p> <p>Doing the following is potentially quite slow:</p> <pre data-language="pycon">&gt;&gt;&gt; entry = Entry.objects.get(headline__startswith="News")
</pre> <p>First of all, <code>headline</code> is not indexed, which will make the underlying database fetch slower.</p> <p>Second, the lookup doesn’t guarantee that only one object will be returned. If the query matches more than one object, it will retrieve and transfer all of them from the database. This penalty could be substantial if hundreds or thousands of records are returned. The penalty will be compounded if the database lives on a separate server, where network overhead and latency also play a factor.</p>   <h2 id="retrieve-everything-at-once-if-you-know-you-will-need-it">Retrieve everything at once if you know you will need it</h2> <p id="s-retrieve-everything-at-once-if-you-know-you-will-need-it">Hitting the database multiple times for different parts of a single ‘set’ of data that you will need all parts of is, in general, less efficient than retrieving it all in one query. This is particularly important if you have a query that is executed in a loop, and could therefore end up doing many database queries, when only one was needed. So:</p>  <h3 id="use-queryset-select-related-and-prefetch-related">Use <code>QuerySet.select_related()</code> and <code>prefetch_related()</code>
</h3> <p id="s-use-queryset-select-related-and-prefetch-related">Understand <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.select_related" title="django.db.models.query.QuerySet.select_related"><code>select_related()</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.prefetch_related" title="django.db.models.query.QuerySet.prefetch_related"><code>prefetch_related()</code></a> thoroughly, and use them:</p> <ul class="simple"> <li>in <a class="reference internal" href="managers.html"><span class="doc">managers and default managers</span></a> where appropriate. Be aware when your manager is and is not used; sometimes this is tricky so don’t make assumptions.</li> <li>in view code or other layers, possibly making use of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.prefetch_related_objects" title="django.db.models.prefetch_related_objects"><code>prefetch_related_objects()</code></a> where needed.</li> </ul>    <h2 id="don-t-retrieve-things-you-don-t-need">Don’t retrieve things you don’t need</h2>  <h3 id="use-queryset-values-and-values-list">Use <code>QuerySet.values()</code> and <code>values_list()</code>
</h3> <p id="s-don-t-retrieve-things-you-don-t-need">When you only want a <code>dict</code> or <code>list</code> of values, and don’t need ORM model objects, make appropriate usage of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.values" title="django.db.models.query.QuerySet.values"><code>values()</code></a>. These can be useful for replacing model objects in template code - as long as the dicts you supply have the same attributes as those used in the template, you are fine.</p>   <h3 id="use-queryset-defer-and-only">Use <code>QuerySet.defer()</code> and <code>only()</code>
</h3> <p id="s-use-queryset-defer-and-only">Use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.defer" title="django.db.models.query.QuerySet.defer"><code>defer()</code></a> and <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.only" title="django.db.models.query.QuerySet.only"><code>only()</code></a> if there are database columns you know that you won’t need (or won’t need in most cases) to avoid loading them. Note that if you <em>do</em> use them, the ORM will have to go and get them in a separate query, making this a pessimization if you use it inappropriately.</p> <p>Don’t be too aggressive in deferring fields without profiling as the database has to read most of the non-text, non-<code>VARCHAR</code> data from the disk for a single row in the results, even if it ends up only using a few columns. The <code>defer()</code> and <code>only()</code> methods are most useful when you can avoid loading a lot of text data or for fields that might take a lot of processing to convert back to Python. As always, profile first, then optimize.</p>   <h3 id="use-queryset-contains-obj">Use <code>QuerySet.contains(obj)</code>
</h3> <p id="s-use-queryset-contains-obj">…if you only want to find out if <code>obj</code> is in the queryset, rather than <code>if obj in queryset</code>.</p>   <h3 id="use-queryset-count">Use <code>QuerySet.count()</code>
</h3> <p id="s-use-queryset-count">…if you only want the count, rather than doing <code>len(queryset)</code>.</p>   <h3 id="use-queryset-exists">Use <code>QuerySet.exists()</code>
</h3> <p id="s-use-queryset-exists">…if you only want to find out if at least one result exists, rather than <code>if
queryset</code>.</p> <p>But:</p>   <h3 id="overuse-of-count-and-exists">Don’t overuse <code>contains()</code>, <code>count()</code>, and <code>exists()</code>
</h3> <p id="s-don-t-overuse-contains-count-and-exists">If you are going to need other data from the QuerySet, evaluate it immediately.</p> <p>For example, assuming a <code>Group</code> model that has a many-to-many relation to <code>User</code>, the following code is optimal:</p> <pre data-language="python">members = group.members.all()

if display_group_members:
    if members:
        if current_user in members:
            print("You and", len(members) - 1, "other users are members of this group.")
        else:
            print("There are", len(members), "members in this group.")

        for member in members:
            print(member.username)
    else:
        print("There are no members in this group.")
</pre> <p>It is optimal because:</p> <ol class="arabic simple"> <li>Since QuerySets are lazy, this does no database queries if <code>display_group_members</code> is <code>False</code>.</li> <li>Storing <code>group.members.all()</code> in the <code>members</code> variable allows its result cache to be reused.</li> <li>The line <code>if members:</code> causes <code>QuerySet.__bool__()</code> to be called, which causes the <code>group.members.all()</code> query to be run on the database. If there aren’t any results, it will return <code>False</code>, otherwise <code>True</code>.</li> <li>The line <code>if current_user in members:</code> checks if the user is in the result cache, so no additional database queries are issued.</li> <li>The use of <code>len(members)</code> calls <code>QuerySet.__len__()</code>, reusing the result cache, so again, no database queries are issued.</li> <li>The <code>for member</code> loop iterates over the result cache.</li> </ol> <p>In total, this code does either one or zero database queries. The only deliberate optimization performed is using the <code>members</code> variable. Using <code>QuerySet.exists()</code> for the <code>if</code>, <code>QuerySet.contains()</code> for the <code>in</code>, or <code>QuerySet.count()</code> for the count would each cause additional queries.</p>   <h3 id="use-queryset-update-and-delete">Use <code>QuerySet.update()</code> and <code>delete()</code>
</h3> <p id="s-use-queryset-update-and-delete">Rather than retrieve a load of objects, set some values, and save them individual, use a bulk SQL UPDATE statement, via <a class="reference internal" href="queries.html#topics-db-queries-update"><span class="std std-ref">QuerySet.update()</span></a>. Similarly, do <a class="reference internal" href="queries.html#topics-db-queries-delete"><span class="std std-ref">bulk deletes</span></a> where possible.</p> <p>Note, however, that these bulk update methods cannot call the <code>save()</code> or <code>delete()</code> methods of individual instances, which means that any custom behavior you have added for these methods will not be executed, including anything driven from the normal database object <a class="reference internal" href="../../ref/signals.html"><span class="doc">signals</span></a>.</p>   <h3 id="use-foreign-key-values-directly">Use foreign key values directly</h3> <p id="s-use-foreign-key-values-directly">If you only need a foreign key value, use the foreign key value that is already on the object you’ve got, rather than getting the whole related object and taking its primary key. i.e. do:</p> <pre data-language="python">entry.blog_id
</pre> <p>instead of:</p> <pre data-language="python">entry.blog.id
</pre>   <h3 id="don-t-order-results-if-you-don-t-care">Don’t order results if you don’t care</h3> <p id="s-don-t-order-results-if-you-don-t-care">Ordering is not free; each field to order by is an operation the database must perform. If a model has a default ordering (<a class="reference internal" href="../../ref/models/options.html#django.db.models.Options.ordering" title="django.db.models.Options.ordering"><code>Meta.ordering</code></a>) and you don’t need it, remove it on a <code>QuerySet</code> by calling <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.order_by" title="django.db.models.query.QuerySet.order_by"><code>order_by()</code></a> with no parameters.</p> <p>Adding an index to your database may help to improve ordering performance.</p>    <h2 id="use-bulk-methods">Use bulk methods</h2> <p id="s-use-bulk-methods">Use bulk methods to reduce the number of SQL statements.</p>  <h3 id="create-in-bulk">Create in bulk</h3> <p id="s-create-in-bulk">When creating objects, where possible, use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_create" title="django.db.models.query.QuerySet.bulk_create"><code>bulk_create()</code></a> method to reduce the number of SQL queries. For example:</p> <pre data-language="python">Entry.objects.bulk_create(
    [
        Entry(headline="This is a test"),
        Entry(headline="This is only a test"),
    ]
)
</pre> <p>…is preferable to:</p> <pre data-language="python">Entry.objects.create(headline="This is a test")
Entry.objects.create(headline="This is only a test")
</pre> <p>Note that there are a number of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_create" title="django.db.models.query.QuerySet.bulk_create"><code>caveats to this method</code></a>, so make sure it’s appropriate for your use case.</p>   <h3 id="update-in-bulk">Update in bulk</h3> <p id="s-update-in-bulk">When updating objects, where possible, use the <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_update" title="django.db.models.query.QuerySet.bulk_update"><code>bulk_update()</code></a> method to reduce the number of SQL queries. Given a list or queryset of objects:</p> <pre data-language="python">entries = Entry.objects.bulk_create(
    [
        Entry(headline="This is a test"),
        Entry(headline="This is only a test"),
    ]
)
</pre> <p>The following example:</p> <pre data-language="python">entries[0].headline = "This is not a test"
entries[1].headline = "This is no longer a test"
Entry.objects.bulk_update(entries, ["headline"])
</pre> <p>…is preferable to:</p> <pre data-language="python">entries[0].headline = "This is not a test"
entries[0].save()
entries[1].headline = "This is no longer a test"
entries[1].save()
</pre> <p>Note that there are a number of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_update" title="django.db.models.query.QuerySet.bulk_update"><code>caveats to this method</code></a>, so make sure it’s appropriate for your use case.</p>   <h3 id="insert-in-bulk">Insert in bulk</h3> <p id="s-insert-in-bulk">When inserting objects into <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyFields</code></a>, use <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.add" title="django.db.models.fields.related.RelatedManager.add"><code>add()</code></a> with multiple objects to reduce the number of SQL queries. For example:</p> <pre data-language="python">my_band.members.add(me, my_friend)
</pre> <p>…is preferable to:</p> <pre data-language="python">my_band.members.add(me)
my_band.members.add(my_friend)
</pre> <p>…where <code>Bands</code> and <code>Artists</code> have a many-to-many relationship.</p> <p>When inserting different pairs of objects into <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a> or when the custom <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.through" title="django.db.models.ManyToManyField.through"><code>through</code></a> table is defined, use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_create" title="django.db.models.query.QuerySet.bulk_create"><code>bulk_create()</code></a> method to reduce the number of SQL queries. For example:</p> <pre data-language="python">PizzaToppingRelationship = Pizza.toppings.through
PizzaToppingRelationship.objects.bulk_create(
    [
        PizzaToppingRelationship(pizza=my_pizza, topping=pepperoni),
        PizzaToppingRelationship(pizza=your_pizza, topping=pepperoni),
        PizzaToppingRelationship(pizza=your_pizza, topping=mushroom),
    ],
    ignore_conflicts=True,
)
</pre> <p>…is preferable to:</p> <pre data-language="python">my_pizza.toppings.add(pepperoni)
your_pizza.toppings.add(pepperoni, mushroom)
</pre> <p>…where <code>Pizza</code> and <code>Topping</code> have a many-to-many relationship. Note that there are a number of <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.bulk_create" title="django.db.models.query.QuerySet.bulk_create"><code>caveats to this method</code></a>, so make sure it’s appropriate for your use case.</p>   <h3 id="remove-in-bulk">Remove in bulk</h3> <p id="s-remove-in-bulk">When removing objects from <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyFields</code></a>, use <a class="reference internal" href="../../ref/models/relations.html#django.db.models.fields.related.RelatedManager.remove" title="django.db.models.fields.related.RelatedManager.remove"><code>remove()</code></a> with multiple objects to reduce the number of SQL queries. For example:</p> <pre data-language="python">my_band.members.remove(me, my_friend)
</pre> <p>…is preferable to:</p> <pre data-language="python">my_band.members.remove(me)
my_band.members.remove(my_friend)
</pre> <p>…where <code>Bands</code> and <code>Artists</code> have a many-to-many relationship.</p> <p>When removing different pairs of objects from <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyFields</code></a>, use <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.query.QuerySet.delete" title="django.db.models.query.QuerySet.delete"><code>delete()</code></a> on a <a class="reference internal" href="../../ref/models/querysets.html#django.db.models.Q" title="django.db.models.Q"><code>Q</code></a> expression with multiple <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField.through" title="django.db.models.ManyToManyField.through"><code>through</code></a> model instances to reduce the number of SQL queries. For example:</p> <pre data-language="python">from django.db.models import Q

PizzaToppingRelationship = Pizza.toppings.through
PizzaToppingRelationship.objects.filter(
    Q(pizza=my_pizza, topping=pepperoni)
    | Q(pizza=your_pizza, topping=pepperoni)
    | Q(pizza=your_pizza, topping=mushroom)
).delete()
</pre> <p>…is preferable to:</p> <pre data-language="python">my_pizza.toppings.remove(pepperoni)
your_pizza.toppings.remove(pepperoni, mushroom)
</pre> <p>…where <code>Pizza</code> and <code>Topping</code> have a many-to-many relationship.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.1/topics/db/optimization/" class="_attribution-link">https://docs.djangoproject.com/en/5.1/topics/db/optimization/</a>
  </p>
</div>
