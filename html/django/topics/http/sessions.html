<h1 id="how-to-use-sessions">How to use sessions</h1> <p id="s-module-django.contrib.sessions">Django provides full support for anonymous sessions. The session framework lets you store and retrieve arbitrary data on a per-site-visitor basis. It stores data on the server side and abstracts the sending and receiving of cookies. Cookies contain a session ID – not the data itself (unless you’re using the <a class="reference internal" href="#cookie-session-backend"><span class="std std-ref">cookie based backend</span></a>).</p>  <h2 id="enabling-sessions">Enabling sessions</h2> <p id="s-enabling-sessions">Sessions are implemented via a piece of <a class="reference internal" href="../../ref/middleware.html"><span class="doc">middleware</span></a>.</p> <p>To enable session functionality, do the following:</p> <ul class="simple"> <li>Edit the <a class="reference internal" href="../../ref/settings.html#std-setting-MIDDLEWARE"><code>MIDDLEWARE</code></a> setting and make sure it contains <code>'django.contrib.sessions.middleware.SessionMiddleware'</code>. The default <code>settings.py</code> created by <code>django-admin startproject</code> has <code>SessionMiddleware</code> activated.</li> </ul> <p>If you don’t want to use sessions, you might as well remove the <code>SessionMiddleware</code> line from <a class="reference internal" href="../../ref/settings.html#std-setting-MIDDLEWARE"><code>MIDDLEWARE</code></a> and <code>'django.contrib.sessions'</code> from your <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>. It’ll save you a small bit of overhead.</p>   <h2 id="configuring-sessions">Configuring the session engine</h2> <p id="s-configuring-the-session-engine">By default, Django stores sessions in your database (using the model <code>django.contrib.sessions.models.Session</code>). Though this is convenient, in some setups it’s faster to store session data elsewhere, so Django can be configured to store session data on your filesystem or in your cache.</p>  <h3 id="using-database-backed-sessions">Using database-backed sessions</h3> <p id="s-using-database-backed-sessions">If you want to use a database-backed session, you need to add <code>'django.contrib.sessions'</code> to your <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a> setting.</p> <p>Once you have configured your installation, run <code>manage.py migrate</code> to install the single database table that stores session data.</p>   <h3 id="cached-sessions-backend">Using cached sessions</h3> <p id="s-using-cached-sessions">For better performance, you may want to use a cache-based session backend.</p> <p>To store session data using Django’s cache system, you’ll first need to make sure you’ve configured your cache; see the <a class="reference internal" href="../cache.html"><span class="doc">cache documentation</span></a> for details.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">You should only use cache-based sessions if you’re using the Memcached or Redis cache backend. The local-memory cache backend doesn’t retain data long enough to be a good choice, and it’ll be faster to use file or database sessions directly instead of sending everything through the file or database cache backends. Additionally, the local-memory cache backend is NOT multi-process safe, therefore probably not a good choice for production environments.</p> </div> <p>If you have multiple caches defined in <a class="reference internal" href="../../ref/settings.html#std-setting-CACHES"><code>CACHES</code></a>, Django will use the default cache. To use another cache, set <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_CACHE_ALIAS"><code>SESSION_CACHE_ALIAS</code></a> to the name of that cache.</p> <p>Once your cache is configured, you have to choose between a database-backed cache or a non-persistent cache.</p> <p>The cached database backend (<code>cached_db</code>) uses a write-through cache – session writes are applied to both the cache and the database. Session reads use the cache, or the database if the data has been evicted from the cache. To use this backend, set <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a> to <code>"django.contrib.sessions.backends.cached_db"</code>, and follow the configuration instructions for the <a class="reference internal" href="#using-database-backed-sessions">using database-backed sessions</a>.</p> <p>The cache backend (<code>cache</code>) stores session data only in your cache. This is faster because it avoids database persistence, but you will have to consider what happens when cache data is evicted. Eviction can occur if the cache fills up or the cache server is restarted, and it will mean session data is lost, including logging out users. To use this backend, set <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a> to <code>"django.contrib.sessions.backends.cache"</code>.</p> <p>The cache backend can be made persistent by using a persistent cache, such as Redis with appropriate configuration. But unless your cache is definitely configured for sufficient persistence, opt for the cached database backend. This avoids edge cases caused by unreliable data storage in production.</p>   <h3 id="using-file-based-sessions">Using file-based sessions</h3> <p id="s-using-file-based-sessions">To use file-based sessions, set the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a> setting to <code>"django.contrib.sessions.backends.file"</code>.</p> <p>You might also want to set the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_FILE_PATH"><code>SESSION_FILE_PATH</code></a> setting (which defaults to output from <code>tempfile.gettempdir()</code>, most likely <code>/tmp</code>) to control where Django stores session files. Be sure to check that your web server has permissions to read and write to this location.</p>   <h3 id="cookie-session-backend">Using cookie-based sessions</h3> <p id="s-using-cookie-based-sessions">To use cookies-based sessions, set the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a> setting to <code>"django.contrib.sessions.backends.signed_cookies"</code>. The session data will be stored using Django’s tools for <a class="reference internal" href="../signing.html"><span class="doc">cryptographic signing</span></a> and the <a class="reference internal" href="../../ref/settings.html#std-setting-SECRET_KEY"><code>SECRET_KEY</code></a> setting.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">It’s recommended to leave the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_HTTPONLY"><code>SESSION_COOKIE_HTTPONLY</code></a> setting on <code>True</code> to prevent access to the stored data from JavaScript.</p> </div> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p><strong>The session data is signed but not encrypted</strong></p> <p>When using the cookies backend the session data can be read by the client.</p> <p>A MAC (Message Authentication Code) is used to protect the data against changes by the client, so that the session data will be invalidated when being tampered with. The same invalidation happens if the client storing the cookie (e.g. your user’s browser) can’t store all of the session cookie and drops data. Even though Django compresses the data, it’s still entirely possible to exceed the <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2965.html#section-5.3" id="index-0"><strong>common limit of 4096 bytes</strong></a> per cookie.</p> <p><strong>No freshness guarantee</strong></p> <p>Note also that while the MAC can guarantee the authenticity of the data (that it was generated by your site, and not someone else), and the integrity of the data (that it is all there and correct), it cannot guarantee freshness i.e. that you are being sent back the last thing you sent to the client. This means that for some uses of session data, the cookie backend might open you up to <a class="reference external" href="https://en.wikipedia.org/wiki/Replay_attack">replay attacks</a>. Unlike other session backends which keep a server-side record of each session and invalidate it when a user logs out, cookie-based sessions are not invalidated when a user logs out. Thus if an attacker steals a user’s cookie, they can use that cookie to login as that user even if the user logs out. Cookies will only be detected as ‘stale’ if they are older than your <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a>.</p> <p><strong>Performance</strong></p> <p class="last">Finally, the size of a cookie can have an impact on the speed of your site.</p> </div>    <h2 id="using-sessions-in-views">Using sessions in views</h2> <p id="s-using-sessions-in-views">When <code>SessionMiddleware</code> is activated, each <a class="reference internal" href="../../ref/request-response.html#django.http.HttpRequest" title="django.http.HttpRequest"><code>HttpRequest</code></a> object – the first argument to any Django view function – will have a <code>session</code> attribute, which is a dictionary-like object.</p> <p>You can read it and write to <code>request.session</code> at any point in your view. You can edit it multiple times.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase">
<code>class backends.base.SessionBase</code> </dt> <dd>
<p>This is the base class for all session objects. It has the following standard dictionary methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.__getitem__">
<code>__getitem__(key)</code> </dt> <dd>
<p>Example: <code>fav_color = request.session['fav_color']</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.__setitem__">
<code>__setitem__(key, value)</code> </dt> <dd>
<p>Example: <code>request.session['fav_color'] = 'blue'</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.__delitem__">
<code>__delitem__(key)</code> </dt> <dd>
<p>Example: <code>del request.session['fav_color']</code>. This raises <code>KeyError</code> if the given <code>key</code> isn’t already in the session.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.__contains__">
<code>__contains__(key)</code> </dt> <dd>
<p>Example: <code>'fav_color' in request.session</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.get">
<code>get(key, default=None)</code> </dt> <dd>
<p>Example: <code>fav_color = request.session.get('fav_color', 'red')</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.pop">
<code>pop(key, default=__not_given)</code> </dt> <dd>
<p>Example: <code>fav_color = request.session.pop('fav_color', 'blue')</code></p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.keys">
<code>keys()</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.items">
<code>items()</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.setdefault">
<code>setdefault()</code> </dt> 
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.clear">
<code>clear()</code> </dt> 
</dl> <p>It also has these methods:</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.flush">
<code>flush()</code> </dt> <dd>
<p>Deletes the current session data from the session and deletes the session cookie. This is used if you want to ensure that the previous session data can’t be accessed again from the user’s browser (for example, the <a class="reference internal" href="../auth/default.html#django.contrib.auth.logout" title="django.contrib.auth.logout"><code>django.contrib.auth.logout()</code></a> function calls it).</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.set_test_cookie">
<code>set_test_cookie()</code> </dt> <dd>
<p>Sets a test cookie to determine whether the user’s browser supports cookies. Due to the way cookies work, you won’t be able to test this until the user’s next page request. See <a class="reference internal" href="#setting-test-cookies">Setting test cookies</a> below for more information.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.test_cookie_worked">
<code>test_cookie_worked()</code> </dt> <dd>
<p>Returns either <code>True</code> or <code>False</code>, depending on whether the user’s browser accepted the test cookie. Due to the way cookies work, you’ll have to call <code>set_test_cookie()</code> on a previous, separate page request. See <a class="reference internal" href="#setting-test-cookies">Setting test cookies</a> below for more information.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.delete_test_cookie">
<code>delete_test_cookie()</code> </dt> <dd>
<p>Deletes the test cookie. Use this to clean up after yourself.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.get_session_cookie_age">
<code>get_session_cookie_age()</code> </dt> <dd>
<p>Returns the value of the setting <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a>. This can be overridden in a custom session backend.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.set_expiry">
<code>set_expiry(value)</code> </dt> <dd>
<p>Sets the expiration time for the session. You can pass a number of different values:</p> <ul class="simple"> <li>If <code>value</code> is an integer, the session will expire after that many seconds of inactivity. For example, calling <code>request.session.set_expiry(300)</code> would make the session expire in 5 minutes.</li> <li>If <code>value</code> is a <code>datetime</code> or <code>timedelta</code> object, the session will expire at that specific date/time.</li> <li>If <code>value</code> is <code>0</code>, the user’s session cookie will expire when the user’s web browser is closed.</li> <li>If <code>value</code> is <code>None</code>, the session reverts to using the global session expiry policy.</li> </ul> <p>Reading a session is not considered activity for expiration purposes. Session expiration is computed from the last time the session was <em>modified</em>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.get_expiry_age">
<code>get_expiry_age()</code> </dt> <dd>
<p>Returns the number of seconds until this session expires. For sessions with no custom expiration (or those set to expire at browser close), this will equal <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a>.</p> <p>This function accepts two optional keyword arguments:</p> <ul class="simple"> <li>
<code>modification</code>: last modification of the session, as a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.12)"><code>datetime</code></a> object. Defaults to the current time.</li> <li>
<code>expiry</code>: expiry information for the session, as a <a class="reference external" href="https://docs.python.org/3/library/datetime.html#datetime.datetime" title="(in Python v3.12)"><code>datetime</code></a> object, an <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.12)"><code>int</code></a> (in seconds), or <code>None</code>. Defaults to the value stored in the session by <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.set_expiry" title="django.contrib.sessions.backends.base.SessionBase.set_expiry"><code>set_expiry()</code></a>, if there is one, or <code>None</code>.</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>This method is used by session backends to determine the session expiry age in seconds when saving the session. It is not really intended for usage outside of that context.</p> <p>In particular, while it is <strong>possible</strong> to determine the remaining lifetime of a session <strong>just when</strong> you have the correct <code>modification</code> value <strong>and</strong> the <code>expiry</code> is set as a <code>datetime</code> object, where you do have the <code>modification</code> value, it is more straight-forward to calculate the expiry by-hand:</p> <pre data-language="python">expires_at = modification + timedelta(seconds=settings.SESSION_COOKIE_AGE)
</pre> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.get_expiry_date">
<code>get_expiry_date()</code> </dt> <dd>
<p>Returns the date this session will expire. For sessions with no custom expiration (or those set to expire at browser close), this will equal the date <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a> seconds from now.</p> <p>This function accepts the same keyword arguments as <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.get_expiry_age" title="django.contrib.sessions.backends.base.SessionBase.get_expiry_age"><code>get_expiry_age()</code></a>, and similar notes on usage apply.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.get_expire_at_browser_close">
<code>get_expire_at_browser_close()</code> </dt> <dd>
<p>Returns either <code>True</code> or <code>False</code>, depending on whether the user’s session cookie will expire when the user’s web browser is closed.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.clear_expired">
<code>clear_expired()</code> </dt> <dd>
<p>Removes expired sessions from the session store. This class method is called by <a class="reference internal" href="../../ref/django-admin.html#django-admin-clearsessions"><code>clearsessions</code></a>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.base.SessionBase.cycle_key">
<code>cycle_key()</code> </dt> <dd>
<p>Creates a new session key while retaining the current session data. <a class="reference internal" href="../auth/default.html#django.contrib.auth.login" title="django.contrib.auth.login"><code>django.contrib.auth.login()</code></a> calls this method to mitigate against session fixation.</p> </dd>
</dl> </dd>
</dl>  <h3 id="id1">Session serialization</h3> <p id="s-session-serialization">By default, Django serializes session data using JSON. You can use the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_SERIALIZER"><code>SESSION_SERIALIZER</code></a> setting to customize the session serialization format. Even with the caveats described in <a class="reference internal" href="#custom-serializers"><span class="std std-ref">Write your own serializer</span></a>, we highly recommend sticking with JSON serialization <em>especially if you are using the cookie backend</em>.</p> <p>For example, here’s an attack scenario if you use <a class="reference external" href="https://docs.python.org/3/library/pickle.html#module-pickle" title="(in Python v3.12)"><code>pickle</code></a> to serialize session data. If you’re using the <a class="reference internal" href="#cookie-session-backend"><span class="std std-ref">signed cookie session backend</span></a> and <a class="reference internal" href="../../ref/settings.html#std-setting-SECRET_KEY"><code>SECRET_KEY</code></a> (or any key of <a class="reference internal" href="../../ref/settings.html#std-setting-SECRET_KEY_FALLBACKS"><code>SECRET_KEY_FALLBACKS</code></a>) is known by an attacker (there isn’t an inherent vulnerability in Django that would cause it to leak), the attacker could insert a string into their session which, when unpickled, executes arbitrary code on the server. The technique for doing so is simple and easily available on the internet. Although the cookie session storage signs the cookie-stored data to prevent tampering, a <a class="reference internal" href="../../ref/settings.html#std-setting-SECRET_KEY"><code>SECRET_KEY</code></a> leak immediately escalates to a remote code execution vulnerability.</p>  <h4 id="bundled-serializers">Bundled serializers</h4> <dl class="py class" id="s-bundled-serializers"> <dt class="sig sig-object py" id="django.contrib.sessions.serializers.JSONSerializer">
<code>class serializers.JSONSerializer</code> </dt> <dd>
<p>A wrapper around the JSON serializer from <a class="reference internal" href="../signing.html#module-django.core.signing" title="django.core.signing: Django's signing framework."><code>django.core.signing</code></a>. Can only serialize basic data types.</p> <p>In addition, as JSON supports only string keys, note that using non-string keys in <code>request.session</code> won’t work as expected:</p> <pre data-language="pycon">&gt;&gt;&gt; # initial assignment
&gt;&gt;&gt; request.session[0] = "bar"
&gt;&gt;&gt; # subsequent requests following serialization &amp; deserialization
&gt;&gt;&gt; # of session data
&gt;&gt;&gt; request.session[0]  # KeyError
&gt;&gt;&gt; request.session["0"]
'bar'
</pre> <p>Similarly, data that can’t be encoded in JSON, such as non-UTF8 bytes like <code>'\xd9'</code> (which raises <a class="reference external" href="https://docs.python.org/3/library/exceptions.html#UnicodeDecodeError" title="(in Python v3.12)"><code>UnicodeDecodeError</code></a>), can’t be stored.</p> <p>See the <a class="reference internal" href="#custom-serializers"><span class="std std-ref">Write your own serializer</span></a> section for more details on limitations of JSON serialization.</p> </dd>
</dl>   <h4 id="custom-serializers">Write your own serializer</h4> <p id="s-write-your-own-serializer">Note that the <a class="reference internal" href="#django.contrib.sessions.serializers.JSONSerializer" title="django.contrib.sessions.serializers.JSONSerializer"><code>JSONSerializer</code></a> cannot handle arbitrary Python data types. As is often the case, there is a trade-off between convenience and security. If you wish to store more advanced data types including <code>datetime</code> and <code>Decimal</code> in JSON backed sessions, you will need to write a custom serializer (or convert such values to a JSON serializable object before storing them in <code>request.session</code>). While serializing these values is often straightforward (<a class="reference internal" href="../serialization.html#django.core.serializers.json.DjangoJSONEncoder" title="django.core.serializers.json.DjangoJSONEncoder"><code>DjangoJSONEncoder</code></a> may be helpful), writing a decoder that can reliably get back the same thing that you put in is more fragile. For example, you run the risk of returning a <code>datetime</code> that was actually a string that just happened to be in the same format chosen for <code>datetime</code>s).</p> <p>Your serializer class must implement two methods, <code>dumps(self, obj)</code> and <code>loads(self, data)</code>, to serialize and deserialize the dictionary of session data, respectively.</p>    <h3 id="session-object-guidelines">Session object guidelines</h3> <ul class="simple" id="s-session-object-guidelines"> <li>Use normal Python strings as dictionary keys on <code>request.session</code>. This is more of a convention than a hard-and-fast rule.</li> <li>Session dictionary keys that begin with an underscore are reserved for internal use by Django.</li> <li>Don’t override <code>request.session</code> with a new object, and don’t access or set its attributes. Use it like a Python dictionary.</li> </ul>   <h3 id="examples">Examples</h3> <p id="s-examples">This simplistic view sets a <code>has_commented</code> variable to <code>True</code> after a user posts a comment. It doesn’t let a user post a comment more than once:</p> <pre data-language="python">def post_comment(request, new_comment):
    if request.session.get("has_commented", False):
        return HttpResponse("You've already commented.")
    c = comments.Comment(comment=new_comment)
    c.save()
    request.session["has_commented"] = True
    return HttpResponse("Thanks for your comment!")
</pre> <p>This simplistic view logs in a “member” of the site:</p> <pre data-language="python">def login(request):
    m = Member.objects.get(username=request.POST["username"])
    if m.check_password(request.POST["password"]):
        request.session["member_id"] = m.id
        return HttpResponse("You're logged in.")
    else:
        return HttpResponse("Your username and password didn't match.")
</pre> <p>…And this one logs a member out, according to <code>login()</code> above:</p> <pre data-language="python">def logout(request):
    try:
        del request.session["member_id"]
    except KeyError:
        pass
    return HttpResponse("You're logged out.")
</pre> <p>The standard <a class="reference internal" href="../auth/default.html#django.contrib.auth.logout" title="django.contrib.auth.logout"><code>django.contrib.auth.logout()</code></a> function actually does a bit more than this to prevent inadvertent data leakage. It calls the <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.flush" title="django.contrib.sessions.backends.base.SessionBase.flush"><code>flush()</code></a> method of <code>request.session</code>. We are using this example as a demonstration of how to work with session objects, not as a full <code>logout()</code> implementation.</p>    <h2 id="setting-test-cookies">Setting test cookies</h2> <p id="s-setting-test-cookies">As a convenience, Django provides a way to test whether the user’s browser accepts cookies. Call the <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.set_test_cookie" title="django.contrib.sessions.backends.base.SessionBase.set_test_cookie"><code>set_test_cookie()</code></a> method of <code>request.session</code> in a view, and call <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.test_cookie_worked" title="django.contrib.sessions.backends.base.SessionBase.test_cookie_worked"><code>test_cookie_worked()</code></a> in a subsequent view – not in the same view call.</p> <p>This awkward split between <code>set_test_cookie()</code> and <code>test_cookie_worked()</code> is necessary due to the way cookies work. When you set a cookie, you can’t actually tell whether a browser accepted it until the browser’s next request.</p> <p>It’s good practice to use <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.delete_test_cookie" title="django.contrib.sessions.backends.base.SessionBase.delete_test_cookie"><code>delete_test_cookie()</code></a> to clean up after yourself. Do this after you’ve verified that the test cookie worked.</p> <p>Here’s a typical usage example:</p> <pre data-language="python">from django.http import HttpResponse
from django.shortcuts import render


def login(request):
    if request.method == "POST":
        if request.session.test_cookie_worked():
            request.session.delete_test_cookie()
            return HttpResponse("You're logged in.")
        else:
            return HttpResponse("Please enable cookies and try again.")
    request.session.set_test_cookie()
    return render(request, "foo/login_form.html")
</pre>   <h2 id="using-sessions-out-of-views">Using sessions out of views</h2> <div class="admonition note" id="s-using-sessions-out-of-views"> <p class="first admonition-title">Note</p> <p>The examples in this section import the <code>SessionStore</code> object directly from the <code>django.contrib.sessions.backends.db</code> backend. In your own code, you should consider importing <code>SessionStore</code> from the session engine designated by <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a>, as below:</p> <pre data-language="pycon">&gt;&gt;&gt; from importlib import import_module
&gt;&gt;&gt; from django.conf import settings
&gt;&gt;&gt; SessionStore = import_module(settings.SESSION_ENGINE).SessionStore
</pre> </div> <p>An API is available to manipulate session data outside of a view:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.sessions.backends.db import SessionStore
&gt;&gt;&gt; s = SessionStore()
&gt;&gt;&gt; # stored as seconds since epoch since datetimes are not serializable in JSON.
&gt;&gt;&gt; s["last_login"] = 1376587691
&gt;&gt;&gt; s.create()
&gt;&gt;&gt; s.session_key
'2b1189a188b44ad18c35e113ac6ceead'
&gt;&gt;&gt; s = SessionStore(session_key="2b1189a188b44ad18c35e113ac6ceead")
&gt;&gt;&gt; s["last_login"]
1376587691
</pre> <p><code>SessionStore.create()</code> is designed to create a new session (i.e. one not loaded from the session store and with <code>session_key=None</code>). <code>save()</code> is designed to save an existing session (i.e. one loaded from the session store). Calling <code>save()</code> on a new session may also work but has a small chance of generating a <code>session_key</code> that collides with an existing one. <code>create()</code> calls <code>save()</code> and loops until an unused <code>session_key</code> is generated.</p> <p>If you’re using the <code>django.contrib.sessions.backends.db</code> backend, each session is a normal Django model. The <code>Session</code> model is defined in <a class="reference external" href="https://github.com/django/django/blob/main/django/contrib/sessions/models.py">django/contrib/sessions/models.py</a>. Because it’s a normal model, you can access sessions using the normal Django database API:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.contrib.sessions.models import Session
&gt;&gt;&gt; s = Session.objects.get(pk="2b1189a188b44ad18c35e113ac6ceead")
&gt;&gt;&gt; s.expire_date
datetime.datetime(2005, 8, 20, 13, 35, 12)
</pre> <p>Note that you’ll need to call <a class="reference internal" href="#django.contrib.sessions.base_session.AbstractBaseSession.get_decoded" title="django.contrib.sessions.base_session.AbstractBaseSession.get_decoded"><code>get_decoded()</code></a> to get the session dictionary. This is necessary because the dictionary is stored in an encoded format:</p> <pre data-language="pycon">&gt;&gt;&gt; s.session_data
'KGRwMQpTJ19hdXRoX3VzZXJfaWQnCnAyCkkxCnMuMTExY2ZjODI2Yj...'
&gt;&gt;&gt; s.get_decoded()
{'user_id': 42}
</pre>   <h2 id="when-sessions-are-saved">When sessions are saved</h2> <p id="s-when-sessions-are-saved">By default, Django only saves to the session database when the session has been modified – that is if any of its dictionary values have been assigned or deleted:</p> <pre data-language="python"># Session is modified.
request.session["foo"] = "bar"

# Session is modified.
del request.session["foo"]

# Session is modified.
request.session["foo"] = {}

# Gotcha: Session is NOT modified, because this alters
# request.session['foo'] instead of request.session.
request.session["foo"]["bar"] = "baz"
</pre> <p>In the last case of the above example, we can tell the session object explicitly that it has been modified by setting the <code>modified</code> attribute on the session object:</p> <pre data-language="python">request.session.modified = True
</pre> <p>To change this default behavior, set the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_SAVE_EVERY_REQUEST"><code>SESSION_SAVE_EVERY_REQUEST</code></a> setting to <code>True</code>. When set to <code>True</code>, Django will save the session to the database on every single request.</p> <p>Note that the session cookie is only sent when a session has been created or modified. If <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_SAVE_EVERY_REQUEST"><code>SESSION_SAVE_EVERY_REQUEST</code></a> is <code>True</code>, the session cookie will be sent on every request.</p> <p>Similarly, the <code>expires</code> part of a session cookie is updated each time the session cookie is sent.</p> <p>The session is not saved if the response’s status code is 500.</p>   <h2 id="browser-length-vs-persistent-sessions">Browser-length sessions vs. persistent sessions</h2> <p id="s-browser-length-sessions-vs-persistent-sessions">You can control whether the session framework uses browser-length sessions vs. persistent sessions with the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a> setting.</p> <p>By default, <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a> is set to <code>False</code>, which means session cookies will be stored in users’ browsers for as long as <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a>. Use this if you don’t want people to have to log in every time they open a browser.</p> <p>If <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a> is set to <code>True</code>, Django will use browser-length cookies – cookies that expire as soon as the user closes their browser. Use this if you want people to have to log in every time they open a browser.</p> <p>This setting is a global default and can be overwritten at a per-session level by explicitly calling the <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.set_expiry" title="django.contrib.sessions.backends.base.SessionBase.set_expiry"><code>set_expiry()</code></a> method of <code>request.session</code> as described above in <a class="reference internal" href="#using-sessions-in-views">using sessions in views</a>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Some browsers (Chrome, for example) provide settings that allow users to continue browsing sessions after closing and reopening the browser. In some cases, this can interfere with the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a> setting and prevent sessions from expiring on browser close. Please be aware of this while testing Django applications which have the <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a> setting enabled.</p> </div>   <h2 id="id2">Clearing the session store</h2> <p id="s-clearing-the-session-store">As users create new sessions on your website, session data can accumulate in your session store. If you’re using the database backend, the <code>django_session</code> database table will grow. If you’re using the file backend, your temporary directory will contain an increasing number of files.</p> <p>To understand this problem, consider what happens with the database backend. When a user logs in, Django adds a row to the <code>django_session</code> database table. Django updates this row each time the session data changes. If the user logs out manually, Django deletes the row. But if the user does <em>not</em> log out, the row never gets deleted. A similar process happens with the file backend.</p> <p>Django does <em>not</em> provide automatic purging of expired sessions. Therefore, it’s your job to purge expired sessions on a regular basis. Django provides a clean-up management command for this purpose: <a class="reference internal" href="../../ref/django-admin.html#django-admin-clearsessions"><code>clearsessions</code></a>. It’s recommended to call this command on a regular basis, for example as a daily cron job.</p> <p>Note that the cache backend isn’t vulnerable to this problem, because caches automatically delete stale data. Neither is the cookie backend, because the session data is stored by the users’ browsers.</p>   <h2 id="settings">Settings</h2> <p id="s-settings">A few <a class="reference internal" href="../../ref/settings.html#settings-sessions"><span class="std std-ref">Django settings</span></a> give you control over session behavior:</p> <ul class="simple"> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_CACHE_ALIAS"><code>SESSION_CACHE_ALIAS</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_AGE"><code>SESSION_COOKIE_AGE</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_DOMAIN"><code>SESSION_COOKIE_DOMAIN</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_HTTPONLY"><code>SESSION_COOKIE_HTTPONLY</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_NAME"><code>SESSION_COOKIE_NAME</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_PATH"><code>SESSION_COOKIE_PATH</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_SAMESITE"><code>SESSION_COOKIE_SAMESITE</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_SECURE"><code>SESSION_COOKIE_SECURE</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_EXPIRE_AT_BROWSER_CLOSE"><code>SESSION_EXPIRE_AT_BROWSER_CLOSE</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_FILE_PATH"><code>SESSION_FILE_PATH</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_SAVE_EVERY_REQUEST"><code>SESSION_SAVE_EVERY_REQUEST</code></a></li> <li><a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_SERIALIZER"><code>SESSION_SERIALIZER</code></a></li> </ul>   <h2 id="topics-session-security">Session security</h2> <p id="s-session-security">Subdomains within a site are able to set cookies on the client for the whole domain. This makes session fixation possible if cookies are permitted from subdomains not controlled by trusted users.</p> <p>For example, an attacker could log into <code>good.example.com</code> and get a valid session for their account. If the attacker has control over <code>bad.example.com</code>, they can use it to send their session key to you since a subdomain is permitted to set cookies on <code>*.example.com</code>. When you visit <code>good.example.com</code>, you’ll be logged in as the attacker and might inadvertently enter your sensitive personal data (e.g. credit card info) into the attacker’s account.</p> <p>Another possible attack would be if <code>good.example.com</code> sets its <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_COOKIE_DOMAIN"><code>SESSION_COOKIE_DOMAIN</code></a> to <code>"example.com"</code> which would cause session cookies from that site to be sent to <code>bad.example.com</code>.</p>   <h2 id="technical-details">Technical details</h2> <ul class="simple" id="s-technical-details"> <li>The session dictionary accepts any <a class="reference external" href="https://docs.python.org/3/library/json.html#module-json" title="(in Python v3.12)"><code>json</code></a> serializable value when using <a class="reference internal" href="#django.contrib.sessions.serializers.JSONSerializer" title="django.contrib.sessions.serializers.JSONSerializer"><code>JSONSerializer</code></a>.</li> <li>Session data is stored in a database table named <code>django_session</code> .</li> <li>Django only sends a cookie if it needs to. If you don’t set any session data, it won’t send a session cookie.</li> </ul>  <h3 id="the-sessionstore-object">The <code>SessionStore</code> object</h3> <p id="s-the-sessionstore-object">When working with sessions internally, Django uses a session store object from the corresponding session engine. By convention, the session store object class is named <code>SessionStore</code> and is located in the module designated by <a class="reference internal" href="../../ref/settings.html#std-setting-SESSION_ENGINE"><code>SESSION_ENGINE</code></a>.</p> <p>All <code>SessionStore</code> classes available in Django inherit from <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase" title="django.contrib.sessions.backends.base.SessionBase"><code>SessionBase</code></a> and implement data manipulation methods, namely:</p> <ul class="simple"> <li><code>exists()</code></li> <li><code>create()</code></li> <li><code>save()</code></li> <li><code>delete()</code></li> <li><code>load()</code></li> <li><a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase.clear_expired" title="django.contrib.sessions.backends.base.SessionBase.clear_expired"><code>clear_expired()</code></a></li> </ul> <p>In order to build a custom session engine or to customize an existing one, you may create a new class inheriting from <a class="reference internal" href="#django.contrib.sessions.backends.base.SessionBase" title="django.contrib.sessions.backends.base.SessionBase"><code>SessionBase</code></a> or any other existing <code>SessionStore</code> class.</p> <p>You can extend the session engines, but doing so with database-backed session engines generally requires some extra effort (see the next section for details).</p>    <h2 id="id3">Extending database-backed session engines</h2> <p id="s-extending-database-backed-session-engines">Creating a custom database-backed session engine built upon those included in Django (namely <code>db</code> and <code>cached_db</code>) may be done by inheriting <a class="reference internal" href="#django.contrib.sessions.base_session.AbstractBaseSession" title="django.contrib.sessions.base_session.AbstractBaseSession"><code>AbstractBaseSession</code></a> and either <code>SessionStore</code> class.</p> <p><code>AbstractBaseSession</code> and <code>BaseSessionManager</code> are importable from <code>django.contrib.sessions.base_session</code> so that they can be imported without including <code>django.contrib.sessions</code> in <a class="reference internal" href="../../ref/settings.html#std-setting-INSTALLED_APPS"><code>INSTALLED_APPS</code></a>.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession">
<code>class base_session.AbstractBaseSession</code> </dt> <dd>
<p>The abstract base session model.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession.session_key">
<code>session_key</code> </dt> <dd>
<p>Primary key. The field itself may contain up to 40 characters. The current implementation generates a 32-character string (a random sequence of digits and lowercase ASCII letters).</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession.session_data">
<code>session_data</code> </dt> <dd>
<p>A string containing an encoded and serialized session dictionary.</p> </dd>
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession.expire_date">
<code>expire_date</code> </dt> <dd>
<p>A datetime designating when the session expires.</p> <p>Expired sessions are not available to a user, however, they may still be stored in the database until the <a class="reference internal" href="../../ref/django-admin.html#django-admin-clearsessions"><code>clearsessions</code></a> management command is run.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession.get_session_store_class">
<code>classmethod get_session_store_class()</code> </dt> <dd>
<p>Returns a session store class to be used with this session model.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.AbstractBaseSession.get_decoded">
<code>get_decoded()</code> </dt> <dd>
<p>Returns decoded session data.</p> <p>Decoding is performed by the session store class.</p> </dd>
</dl> </dd>
</dl> <p>You can also customize the model manager by subclassing <a class="reference internal" href="#django.contrib.sessions.base_session.BaseSessionManager" title="django.contrib.sessions.base_session.BaseSessionManager"><code>BaseSessionManager</code></a>:</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.BaseSessionManager">
<code>class base_session.BaseSessionManager</code> </dt> <dd>
<dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.BaseSessionManager.encode">
<code>encode(session_dict)</code> </dt> <dd>
<p>Returns the given session dictionary serialized and encoded as a string.</p> <p>Encoding is performed by the session store class tied to a model class.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.base_session.BaseSessionManager.save">
<code>save(session_key, session_dict, expire_date)</code> </dt> <dd>
<p>Saves session data for a provided session key, or deletes the session in case the data is empty.</p> </dd>
</dl> </dd>
</dl> <p>Customization of <code>SessionStore</code> classes is achieved by overriding methods and properties described below:</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.db.SessionStore">
<code>class backends.db.SessionStore</code> </dt> <dd>
<p>Implements database-backed session store.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.db.SessionStore.get_model_class">
<code>classmethod get_model_class()</code> </dt> <dd>
<p>Override this method to return a custom session model if you need one.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.db.SessionStore.create_model_instance">
<code>create_model_instance(data)</code> </dt> <dd>
<p>Returns a new instance of the session model object, which represents the current session state.</p> <p>Overriding this method provides the ability to modify session model data before it’s saved to database.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.cached_db.SessionStore">
<code>class backends.cached_db.SessionStore</code> </dt> <dd>
<p>Implements cached database-backed session store.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.contrib.sessions.backends.cached_db.SessionStore.cache_key_prefix">
<code>cache_key_prefix</code> </dt> <dd>
<p>A prefix added to a session key to build a cache key string.</p> </dd>
</dl> </dd>
</dl>  <h3 id="example">Example</h3> <p id="s-example">The example below shows a custom database-backed session engine that includes an additional database column to store an account ID (thus providing an option to query the database for all active sessions for an account):</p> <pre data-language="python">from django.contrib.sessions.backends.db import SessionStore as DBStore
from django.contrib.sessions.base_session import AbstractBaseSession
from django.db import models


class CustomSession(AbstractBaseSession):
    account_id = models.IntegerField(null=True, db_index=True)

    @classmethod
    def get_session_store_class(cls):
        return SessionStore


class SessionStore(DBStore):
    @classmethod
    def get_model_class(cls):
        return CustomSession

    def create_model_instance(self, data):
        obj = super().create_model_instance(data)
        try:
            account_id = int(data.get("_auth_user_id"))
        except (ValueError, TypeError):
            account_id = None
        obj.account_id = account_id
        return obj
</pre> <p>If you are migrating from the Django’s built-in <code>cached_db</code> session store to a custom one based on <code>cached_db</code>, you should override the cache key prefix in order to prevent a namespace clash:</p> <pre data-language="python">class SessionStore(CachedDBStore):
    cache_key_prefix = "mysessions.custom_cached_db_backend"

    # ...
</pre>    <h2 id="session-ids-in-urls">Session IDs in URLs</h2> <p id="s-session-ids-in-urls">The Django sessions framework is entirely, and solely, cookie-based. It does not fall back to putting session IDs in URLs as a last resort, as PHP does. This is an intentional design decision. Not only does that behavior make URLs ugly, it makes your site vulnerable to session-ID theft via the “Referer” header.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.0/topics/http/sessions/" class="_attribution-link">https://docs.djangoproject.com/en/5.0/topics/http/sessions/</a>
  </p>
</div>
