<h1 id="creating-forms-from-models">Creating forms from models</h1>  <h2 id="modelform"><code>ModelForm</code></h2> <dl class="py class" id="s-creating-forms-from-models"> <dt class="sig sig-object py" id="django.forms.ModelForm">
<code>class ModelForm</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.1.x/django/forms/models.py#L565"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>If you’re building a database-driven app, chances are you’ll have forms that map closely to Django models. For instance, you might have a <code>BlogComment</code> model, and you want to create a form that lets people submit comments. In this case, it would be redundant to define the field types in your form, because you’ve already defined the fields in your model.</p> <p>For this reason, Django provides a helper class that lets you create a <code>Form</code> class from a Django model.</p> <p>For example:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import ModelForm
&gt;&gt;&gt; from myapp.models import Article

# Create the form class.
&gt;&gt;&gt; class ArticleForm(ModelForm):
...     class Meta:
...         model = Article
...         fields = ["pub_date", "headline", "content", "reporter"]
...

# Creating a form to add an article.
&gt;&gt;&gt; form = ArticleForm()

# Creating a form to change an existing article.
&gt;&gt;&gt; article = Article.objects.get(pk=1)
&gt;&gt;&gt; form = ArticleForm(instance=article)
</pre>  <h3 id="field-types">Field types</h3> <p id="s-field-types">The generated <code>Form</code> class will have a form field for every model field specified, in the order specified in the <code>fields</code> attribute.</p> <p>Each model field has a corresponding default form field. For example, a <code>CharField</code> on a model is represented as a <code>CharField</code> on a form. A model <code>ManyToManyField</code> is represented as a <code>MultipleChoiceField</code>. Here is the full list of conversions:</p> <table class="docutils">  <thead valign="bottom"> <tr>
<th class="head">Model field</th> <th class="head">Form field</th> </tr> </thead>  <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.AutoField" title="django.db.models.AutoField"><code>AutoField</code></a></td> <td>Not represented in the form</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.BigAutoField" title="django.db.models.BigAutoField"><code>BigAutoField</code></a></td> <td>Not represented in the form</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.BigIntegerField" title="django.db.models.BigIntegerField"><code>BigIntegerField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a> with <code>min_value</code> set to -9223372036854775808 and <code>max_value</code> set to 9223372036854775807.</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.BinaryField" title="django.db.models.BinaryField"><code>BinaryField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a>, if <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.editable" title="django.db.models.Field.editable"><code>editable</code></a> is set to <code>True</code> on the model field, otherwise not represented in the form.</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.BooleanField" title="django.db.models.BooleanField"><code>BooleanField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.BooleanField" title="django.forms.BooleanField"><code>BooleanField</code></a>, or <a class="reference internal" href="../../ref/forms/fields.html#django.forms.NullBooleanField" title="django.forms.NullBooleanField"><code>NullBooleanField</code></a> if <code>null=True</code>.</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.CharField" title="django.db.models.CharField"><code>CharField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a> with <code>max_length</code> set to the model field’s <code>max_length</code> and <a class="reference internal" href="../../ref/forms/fields.html#django.forms.CharField.empty_value" title="django.forms.CharField.empty_value"><code>empty_value</code></a> set to <code>None</code> if <code>null=True</code>.</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateField" title="django.db.models.DateField"><code>DateField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.DateField" title="django.forms.DateField"><code>DateField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.DateTimeField" title="django.db.models.DateTimeField"><code>DateTimeField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.DateTimeField" title="django.forms.DateTimeField"><code>DateTimeField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.DecimalField" title="django.db.models.DecimalField"><code>DecimalField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.DecimalField" title="django.forms.DecimalField"><code>DecimalField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.DurationField" title="django.db.models.DurationField"><code>DurationField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.DurationField" title="django.forms.DurationField"><code>DurationField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.EmailField" title="django.db.models.EmailField"><code>EmailField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.EmailField" title="django.forms.EmailField"><code>EmailField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.FileField" title="django.db.models.FileField"><code>FileField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.FileField" title="django.forms.FileField"><code>FileField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.FilePathField" title="django.db.models.FilePathField"><code>FilePathField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.FilePathField" title="django.forms.FilePathField"><code>FilePathField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.FloatField" title="django.db.models.FloatField"><code>FloatField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.FloatField" title="django.forms.FloatField"><code>FloatField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey" title="django.db.models.ForeignKey"><code>ForeignKey</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.ModelChoiceField" title="django.forms.ModelChoiceField"><code>ModelChoiceField</code></a> (see below)</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ImageField" title="django.db.models.ImageField"><code>ImageField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.ImageField" title="django.forms.ImageField"><code>ImageField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.IntegerField" title="django.db.models.IntegerField"><code>IntegerField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a></td> </tr> <tr>
<td><code>IPAddressField</code></td> <td><code>IPAddressField</code></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.GenericIPAddressField" title="django.db.models.GenericIPAddressField"><code>GenericIPAddressField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.GenericIPAddressField" title="django.forms.GenericIPAddressField"><code>GenericIPAddressField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.JSONField" title="django.db.models.JSONField"><code>JSONField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.JSONField" title="django.forms.JSONField"><code>JSONField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.ManyToManyField" title="django.db.models.ManyToManyField"><code>ManyToManyField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.ModelMultipleChoiceField" title="django.forms.ModelMultipleChoiceField"><code>ModelMultipleChoiceField</code></a> (see below)</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.PositiveBigIntegerField" title="django.db.models.PositiveBigIntegerField"><code>PositiveBigIntegerField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.PositiveIntegerField" title="django.db.models.PositiveIntegerField"><code>PositiveIntegerField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.PositiveSmallIntegerField" title="django.db.models.PositiveSmallIntegerField"><code>PositiveSmallIntegerField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.SlugField" title="django.db.models.SlugField"><code>SlugField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.SlugField" title="django.forms.SlugField"><code>SlugField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.SmallAutoField" title="django.db.models.SmallAutoField"><code>SmallAutoField</code></a></td> <td>Not represented in the form</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.SmallIntegerField" title="django.db.models.SmallIntegerField"><code>SmallIntegerField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.IntegerField" title="django.forms.IntegerField"><code>IntegerField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.TextField" title="django.db.models.TextField"><code>TextField</code></a></td> <td>
<a class="reference internal" href="../../ref/forms/fields.html#django.forms.CharField" title="django.forms.CharField"><code>CharField</code></a> with <code>widget=forms.Textarea</code>
</td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.TimeField" title="django.db.models.TimeField"><code>TimeField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.TimeField" title="django.forms.TimeField"><code>TimeField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.URLField" title="django.db.models.URLField"><code>URLField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.URLField" title="django.forms.URLField"><code>URLField</code></a></td> </tr> <tr>
<td><a class="reference internal" href="../../ref/models/fields.html#django.db.models.UUIDField" title="django.db.models.UUIDField"><code>UUIDField</code></a></td> <td><a class="reference internal" href="../../ref/forms/fields.html#django.forms.UUIDField" title="django.forms.UUIDField"><code>UUIDField</code></a></td> </tr>  </table> <p>As you might expect, the <code>ForeignKey</code> and <code>ManyToManyField</code> model field types are special cases:</p> <ul class="simple"> <li>
<code>ForeignKey</code> is represented by <code>django.forms.ModelChoiceField</code>, which is a <code>ChoiceField</code> whose choices are a model <code>QuerySet</code>.</li> <li>
<code>ManyToManyField</code> is represented by <code>django.forms.ModelMultipleChoiceField</code>, which is a <code>MultipleChoiceField</code> whose choices are a model <code>QuerySet</code>.</li> </ul> <p>In addition, each generated form field has attributes set as follows:</p> <ul class="simple"> <li>If the model field has <code>blank=True</code>, then <code>required</code> is set to <code>False</code> on the form field. Otherwise, <code>required=True</code>.</li> <li>The form field’s <code>label</code> is set to the <code>verbose_name</code> of the model field, with the first character capitalized.</li> <li>The form field’s <code>help_text</code> is set to the <code>help_text</code> of the model field.</li> <li>If the model field has <code>choices</code> set, then the form field’s <code>widget</code> will be set to <code>Select</code>, with choices coming from the model field’s <code>choices</code>. The choices will normally include the blank choice which is selected by default. If the field is required, this forces the user to make a selection. The blank choice will not be included if the model field has <code>blank=False</code> and an explicit <code>default</code> value (the <code>default</code> value will be initially selected instead).</li> </ul> <p>Finally, note that you can override the form field used for a given model field. See <a class="reference internal" href="#overriding-the-default-fields">Overriding the default fields</a> below.</p>   <h3 id="a-full-example">A full example</h3> <p id="s-a-full-example">Consider this set of models:</p> <pre data-language="python">from django.db import models
from django.forms import ModelForm

TITLE_CHOICES = {
    "MR": "Mr.",
    "MRS": "Mrs.",
    "MS": "Ms.",
}


class Author(models.Model):
    name = models.CharField(max_length=100)
    title = models.CharField(max_length=3, choices=TITLE_CHOICES)
    birth_date = models.DateField(blank=True, null=True)

    def __str__(self):
        return self.name


class Book(models.Model):
    name = models.CharField(max_length=100)
    authors = models.ManyToManyField(Author)


class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = ["name", "title", "birth_date"]


class BookForm(ModelForm):
    class Meta:
        model = Book
        fields = ["name", "authors"]
</pre> <p>With these models, the <code>ModelForm</code> subclasses above would be roughly equivalent to this (the only difference being the <code>save()</code> method, which we’ll discuss in a moment.):</p> <pre data-language="python">from django import forms


class AuthorForm(forms.Form):
    name = forms.CharField(max_length=100)
    title = forms.CharField(
        max_length=3,
        widget=forms.Select(choices=TITLE_CHOICES),
    )
    birth_date = forms.DateField(required=False)


class BookForm(forms.Form):
    name = forms.CharField(max_length=100)
    authors = forms.ModelMultipleChoiceField(queryset=Author.objects.all())
</pre>   <h3 id="validation-on-modelform">Validation on a <code>ModelForm</code>
</h3> <p id="s-validation-on-a-modelform">There are two main steps involved in validating a <code>ModelForm</code>:</p> <ol class="arabic simple"> <li><a class="reference internal" href="../../ref/forms/validation.html"><span class="doc">Validating the form</span></a></li> <li><a class="reference internal" href="../../ref/models/instances.html#validating-objects"><span class="std std-ref">Validating the model instance</span></a></li> </ol> <p>Just like normal form validation, model form validation is triggered implicitly when calling <a class="reference internal" href="../../ref/forms/api.html#django.forms.Form.is_valid" title="django.forms.Form.is_valid"><code>is_valid()</code></a> or accessing the <a class="reference internal" href="../../ref/forms/api.html#django.forms.Form.errors" title="django.forms.Form.errors"><code>errors</code></a> attribute and explicitly when calling <code>full_clean()</code>, although you will typically not use the latter method in practice.</p> <p><code>Model</code> validation (<a class="reference internal" href="../../ref/models/instances.html#django.db.models.Model.full_clean" title="django.db.models.Model.full_clean"><code>Model.full_clean()</code></a>) is triggered from within the form validation step, right after the form’s <code>clean()</code> method is called.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The cleaning process modifies the model instance passed to the <code>ModelForm</code> constructor in various ways. For instance, any date fields on the model are converted into actual date objects. Failed validation may leave the underlying model instance in an inconsistent state and therefore it’s not recommended to reuse it.</p> </div>  <h4 id="overriding-modelform-clean-method">Overriding the <code>clean()</code> method</h4> <p id="s-overriding-the-clean-method">You can override the <code>clean()</code> method on a model form to provide additional validation in the same way you can on a normal form.</p> <p>A model form instance attached to a model object will contain an <code>instance</code> attribute that gives its methods access to that specific model instance.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>The <code>ModelForm.clean()</code> method sets a flag that makes the <a class="reference internal" href="../../ref/models/instances.html#validating-objects"><span class="std std-ref">model validation</span></a> step validate the uniqueness of model fields that are marked as <code>unique</code>, <code>unique_together</code> or <code>unique_for_date|month|year</code>.</p> <p class="last">If you would like to override the <code>clean()</code> method and maintain this validation, you must call the parent class’s <code>clean()</code> method.</p> </div>   <h4 id="interaction-with-model-validation">Interaction with model validation</h4> <p id="s-interaction-with-model-validation">As part of the validation process, <code>ModelForm</code> will call the <code>clean()</code> method of each field on your model that has a corresponding field on your form. If you have excluded any model fields, validation will not be run on those fields. See the <a class="reference internal" href="../../ref/forms/validation.html"><span class="doc">form validation</span></a> documentation for more on how field cleaning and validation work.</p> <p>The model’s <code>clean()</code> method will be called before any uniqueness checks are made. See <a class="reference internal" href="../../ref/models/instances.html#validating-objects"><span class="std std-ref">Validating objects</span></a> for more information on the model’s <code>clean()</code> hook.</p>   <h4 id="considerations-regarding-model-errormessages">Considerations regarding model’s <code>error_messages</code>
</h4> <p id="s-considerations-regarding-model-s-error-messages">Error messages defined at the <a class="reference internal" href="../../ref/forms/fields.html#django.forms.Field.error_messages" title="django.forms.Field.error_messages"><code>form field</code></a> level or at the <a class="reference internal" href="#modelforms-overriding-default-fields"><span class="std std-ref">form Meta</span></a> level always take precedence over the error messages defined at the <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.error_messages" title="django.db.models.Field.error_messages"><code>model field</code></a> level.</p> <p>Error messages defined on <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.error_messages" title="django.db.models.Field.error_messages"><code>model fields</code></a> are only used when the <code>ValidationError</code> is raised during the <a class="reference internal" href="../../ref/models/instances.html#validating-objects"><span class="std std-ref">model validation</span></a> step and no corresponding error messages are defined at the form level.</p> <p>You can override the error messages from <code>NON_FIELD_ERRORS</code> raised by model validation by adding the <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.NON_FIELD_ERRORS" title="django.core.exceptions.NON_FIELD_ERRORS"><code>NON_FIELD_ERRORS</code></a> key to the <code>error_messages</code> dictionary of the <code>ModelForm</code>’s inner <code>Meta</code> class:</p> <pre data-language="python">from django.core.exceptions import NON_FIELD_ERRORS
from django.forms import ModelForm


class ArticleForm(ModelForm):
    class Meta:
        error_messages = {
            NON_FIELD_ERRORS: {
                "unique_together": "%(model_name)s's %(field_labels)s are not unique.",
            }
        }
</pre>    <h3 id="topics-modelform-save">The <code>save()</code> method</h3> <p id="s-the-save-method">Every <code>ModelForm</code> also has a <code>save()</code> method. This method creates and saves a database object from the data bound to the form. A subclass of <code>ModelForm</code> can accept an existing model instance as the keyword argument <code>instance</code>; if this is supplied, <code>save()</code> will update that instance. If it’s not supplied, <code>save()</code> will create a new instance of the specified model:</p> <pre data-language="pycon">&gt;&gt;&gt; from myapp.models import Article
&gt;&gt;&gt; from myapp.forms import ArticleForm

# Create a form instance from POST data.
&gt;&gt;&gt; f = ArticleForm(request.POST)

# Save a new Article object from the form's data.
&gt;&gt;&gt; new_article = f.save()

# Create a form to edit an existing Article, but use
# POST data to populate the form.
&gt;&gt;&gt; a = Article.objects.get(pk=1)
&gt;&gt;&gt; f = ArticleForm(request.POST, instance=a)
&gt;&gt;&gt; f.save()
</pre> <p>Note that if the form <a class="reference internal" href="#validation-on-modelform"><span class="std std-ref">hasn’t been validated</span></a>, calling <code>save()</code> will do so by checking <code>form.errors</code>. A <code>ValueError</code> will be raised if the data in the form doesn’t validate – i.e., if <code>form.errors</code> evaluates to <code>True</code>.</p> <p>If an optional field doesn’t appear in the form’s data, the resulting model instance uses the model field <a class="reference internal" href="../../ref/models/fields.html#django.db.models.Field.default" title="django.db.models.Field.default"><code>default</code></a>, if there is one, for that field. This behavior doesn’t apply to fields that use <a class="reference internal" href="../../ref/forms/widgets.html#django.forms.CheckboxInput" title="django.forms.CheckboxInput"><code>CheckboxInput</code></a>, <a class="reference internal" href="../../ref/forms/widgets.html#django.forms.CheckboxSelectMultiple" title="django.forms.CheckboxSelectMultiple"><code>CheckboxSelectMultiple</code></a>, or <a class="reference internal" href="../../ref/forms/widgets.html#django.forms.SelectMultiple" title="django.forms.SelectMultiple"><code>SelectMultiple</code></a> (or any custom widget whose <a class="reference internal" href="../../ref/forms/widgets.html#django.forms.Widget.value_omitted_from_data" title="django.forms.Widget.value_omitted_from_data"><code>value_omitted_from_data()</code></a> method always returns <code>False</code>) since an unchecked checkbox and unselected <code>&lt;select multiple&gt;</code> don’t appear in the data of an HTML form submission. Use a custom form field or widget if you’re designing an API and want the default fallback behavior for a field that uses one of these widgets.</p> <p>This <code>save()</code> method accepts an optional <code>commit</code> keyword argument, which accepts either <code>True</code> or <code>False</code>. If you call <code>save()</code> with <code>commit=False</code>, then it will return an object that hasn’t yet been saved to the database. In this case, it’s up to you to call <code>save()</code> on the resulting model instance. This is useful if you want to do custom processing on the object before saving it, or if you want to use one of the specialized <a class="reference internal" href="../../ref/models/instances.html#ref-models-force-insert"><span class="std std-ref">model saving options</span></a>. <code>commit</code> is <code>True</code> by default.</p> <p>Another side effect of using <code>commit=False</code> is seen when your model has a many-to-many relation with another model. If your model has a many-to-many relation and you specify <code>commit=False</code> when you save a form, Django cannot immediately save the form data for the many-to-many relation. This is because it isn’t possible to save many-to-many data for an instance until the instance exists in the database.</p> <p>To work around this problem, every time you save a form using <code>commit=False</code>, Django adds a <code>save_m2m()</code> method to your <code>ModelForm</code> subclass. After you’ve manually saved the instance produced by the form, you can invoke <code>save_m2m()</code> to save the many-to-many form data. For example:</p> <pre data-language="pycon"># Create a form instance with POST data.
&gt;&gt;&gt; f = AuthorForm(request.POST)

# Create, but don't save the new author instance.
&gt;&gt;&gt; new_author = f.save(commit=False)

# Modify the author in some way.
&gt;&gt;&gt; new_author.some_field = "some_value"

# Save the new instance.
&gt;&gt;&gt; new_author.save()

# Now, save the many-to-many data for the form.
&gt;&gt;&gt; f.save_m2m()
</pre> <p>Calling <code>save_m2m()</code> is only required if you use <code>save(commit=False)</code>. When you use a <code>save()</code> on a form, all data – including many-to-many data – is saved without the need for any additional method calls. For example:</p> <pre data-language="pycon"># Create a form instance with POST data.
&gt;&gt;&gt; a = Author()
&gt;&gt;&gt; f = AuthorForm(request.POST, instance=a)

# Create and save the new author instance. There's no need to do anything else.
&gt;&gt;&gt; new_author = f.save()
</pre> <p>Other than the <code>save()</code> and <code>save_m2m()</code> methods, a <code>ModelForm</code> works exactly the same way as any other <code>forms</code> form. For example, the <code>is_valid()</code> method is used to check for validity, the <code>is_multipart()</code> method is used to determine whether a form requires multipart file upload (and hence whether <code>request.FILES</code> must be passed to the form), etc. See <a class="reference internal" href="../../ref/forms/api.html#binding-uploaded-files"><span class="std std-ref">Binding uploaded files to a form</span></a> for more information.</p>   <h3 id="modelforms-selecting-fields">Selecting the fields to use</h3> <p id="s-selecting-the-fields-to-use">It is strongly recommended that you explicitly set all fields that should be edited in the form using the <code>fields</code> attribute. Failure to do so can easily lead to security problems when a form unexpectedly allows a user to set certain fields, especially when new fields are added to a model. Depending on how the form is rendered, the problem may not even be visible on the web page.</p> <p>The alternative approach would be to include all fields automatically, or remove only some. This fundamental approach is known to be much less secure and has led to serious exploits on major websites (e.g. <a class="reference external" href="https://github.blog/2012-03-04-public-key-security-vulnerability-and-mitigation/">GitHub</a>).</p> <p>There are, however, two shortcuts available for cases where you can guarantee these security concerns do not apply to you:</p> <ol class="arabic"> <li>
<p class="first">Set the <code>fields</code> attribute to the special value <code>'__all__'</code> to indicate that all fields in the model should be used. For example:</p> <pre data-language="python">from django.forms import ModelForm


class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = "__all__"
</pre> </li> <li>
<p class="first">Set the <code>exclude</code> attribute of the <code>ModelForm</code>’s inner <code>Meta</code> class to a list of fields to be excluded from the form.</p> <p>For example:</p> <pre data-language="python">class PartialAuthorForm(ModelForm):
    class Meta:
        model = Author
        exclude = ["title"]
</pre> <p>Since the <code>Author</code> model has the 3 fields <code>name</code>, <code>title</code> and <code>birth_date</code>, this will result in the fields <code>name</code> and <code>birth_date</code> being present on the form.</p> </li> </ol> <p>If either of these are used, the order the fields appear in the form will be the order the fields are defined in the model, with <code>ManyToManyField</code> instances appearing last.</p> <p>In addition, Django applies the following rule: if you set <code>editable=False</code> on the model field, <em>any</em> form created from the model via <code>ModelForm</code> will not include that field.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>Any fields not included in a form by the above logic will not be set by the form’s <code>save()</code> method. Also, if you manually add the excluded fields back to the form, they will not be initialized from the model instance.</p> <p>Django will prevent any attempt to save an incomplete model, so if the model does not allow the missing fields to be empty, and does not provide a default value for the missing fields, any attempt to <code>save()</code> a <code>ModelForm</code> with missing fields will fail. To avoid this failure, you must instantiate your model with initial values for the missing, but required fields:</p> <pre data-language="python">author = Author(title="Mr")
form = PartialAuthorForm(request.POST, instance=author)
form.save()
</pre> <p>Alternatively, you can use <code>save(commit=False)</code> and manually set any extra required fields:</p> <pre data-language="python">form = PartialAuthorForm(request.POST)
author = form.save(commit=False)
author.title = "Mr"
author.save()
</pre> <p class="last">See the <a class="reference internal" href="#the-save-method">section on saving forms</a> for more details on using <code>save(commit=False)</code>.</p> </div>   <h3 id="modelforms-overriding-default-fields">Overriding the default fields</h3> <p id="s-overriding-the-default-fields">The default field types, as described in the <a class="reference internal" href="#field-types">Field types</a> table above, are sensible defaults. If you have a <code>DateField</code> in your model, chances are you’d want that to be represented as a <code>DateField</code> in your form. But <code>ModelForm</code> gives you the flexibility of changing the form field for a given model.</p> <p>To specify a custom widget for a field, use the <code>widgets</code> attribute of the inner <code>Meta</code> class. This should be a dictionary mapping field names to widget classes or instances.</p> <p>For example, if you want the <code>CharField</code> for the <code>name</code> attribute of <code>Author</code> to be represented by a <code>&lt;textarea&gt;</code> instead of its default <code>&lt;input type="text"&gt;</code>, you can override the field’s widget:</p> <pre data-language="python">from django.forms import ModelForm, Textarea
from myapp.models import Author


class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = ["name", "title", "birth_date"]
        widgets = {
            "name": Textarea(attrs={"cols": 80, "rows": 20}),
        }
</pre> <p>The <code>widgets</code> dictionary accepts either widget instances (e.g., <code>Textarea(...)</code>) or classes (e.g., <code>Textarea</code>). Note that the <code>widgets</code> dictionary is ignored for a model field with a non-empty <code>choices</code> attribute. In this case, you must override the form field to use a different widget.</p> <p>Similarly, you can specify the <code>labels</code>, <code>help_texts</code> and <code>error_messages</code> attributes of the inner <code>Meta</code> class if you want to further customize a field.</p> <p>For example if you wanted to customize the wording of all user facing strings for the <code>name</code> field:</p> <pre data-language="python">from django.utils.translation import gettext_lazy as _


class AuthorForm(ModelForm):
    class Meta:
        model = Author
        fields = ["name", "title", "birth_date"]
        labels = {
            "name": _("Writer"),
        }
        help_texts = {
            "name": _("Some useful help text."),
        }
        error_messages = {
            "name": {
                "max_length": _("This writer's name is too long."),
            },
        }
</pre> <p>You can also specify <code>field_classes</code> or <code>formfield_callback</code> to customize the type of fields instantiated by the form.</p> <p>For example, if you wanted to use <code>MySlugFormField</code> for the <code>slug</code> field, you could do the following:</p> <pre data-language="python">from django.forms import ModelForm
from myapp.models import Article


class ArticleForm(ModelForm):
    class Meta:
        model = Article
        fields = ["pub_date", "headline", "content", "reporter", "slug"]
        field_classes = {
            "slug": MySlugFormField,
        }
</pre> <p>or:</p> <pre data-language="python">from django.forms import ModelForm
from myapp.models import Article


def formfield_for_dbfield(db_field, **kwargs):
    if db_field.name == "slug":
        return MySlugFormField()
    return db_field.formfield(**kwargs)


class ArticleForm(ModelForm):
    class Meta:
        model = Article
        fields = ["pub_date", "headline", "content", "reporter", "slug"]
        formfield_callback = formfield_for_dbfield
</pre> <p>Finally, if you want complete control over of a field – including its type, validators, required, etc. – you can do this by declaratively specifying fields like you would in a regular <code>Form</code>.</p> <p>If you want to specify a field’s validators, you can do so by defining the field declaratively and setting its <code>validators</code> parameter:</p> <pre data-language="python">from django.forms import CharField, ModelForm
from myapp.models import Article


class ArticleForm(ModelForm):
    slug = CharField(validators=[validate_slug])

    class Meta:
        model = Article
        fields = ["pub_date", "headline", "content", "reporter", "slug"]
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p>When you explicitly instantiate a form field like this, it is important to understand how <code>ModelForm</code> and regular <code>Form</code> are related.</p> <p><code>ModelForm</code> is a regular <code>Form</code> which can automatically generate certain fields. The fields that are automatically generated depend on the content of the <code>Meta</code> class and on which fields have already been defined declaratively. Basically, <code>ModelForm</code> will <strong>only</strong> generate fields that are <strong>missing</strong> from the form, or in other words, fields that weren’t defined declaratively.</p> <p>Fields defined declaratively are left as-is, therefore any customizations made to <code>Meta</code> attributes such as <code>widgets</code>, <code>labels</code>, <code>help_texts</code>, or <code>error_messages</code> are ignored; these only apply to fields that are generated automatically.</p> <p>Similarly, fields defined declaratively do not draw their attributes like <code>max_length</code> or <code>required</code> from the corresponding model. If you want to maintain the behavior specified in the model, you must set the relevant arguments explicitly when declaring the form field.</p> <p>For example, if the <code>Article</code> model looks like this:</p> <pre data-language="python">class Article(models.Model):
    headline = models.CharField(
        max_length=200,
        null=True,
        blank=True,
        help_text="Use puns liberally",
    )
    content = models.TextField()
</pre> <p>and you want to do some custom validation for <code>headline</code>, while keeping the <code>blank</code> and <code>help_text</code> values as specified, you might define <code>ArticleForm</code> like this:</p> <pre data-language="python">class ArticleForm(ModelForm):
    headline = MyFormField(
        max_length=200,
        required=False,
        help_text="Use puns liberally",
    )

    class Meta:
        model = Article
        fields = ["headline", "content"]
</pre> <p>You must ensure that the type of the form field can be used to set the contents of the corresponding model field. When they are not compatible, you will get a <code>ValueError</code> as no implicit conversion takes place.</p> <p class="last">See the <a class="reference internal" href="../../ref/forms/fields.html"><span class="doc">form field documentation</span></a> for more information on fields and their arguments.</p> </div>   <h3 id="enabling-localization-of-fields">Enabling localization of fields</h3> <p id="s-enabling-localization-of-fields">By default, the fields in a <code>ModelForm</code> will not localize their data. To enable localization for fields, you can use the <code>localized_fields</code> attribute on the <code>Meta</code> class.</p> <pre data-language="python">&gt;&gt;&gt; from django.forms import ModelForm
&gt;&gt;&gt; from myapp.models import Author
&gt;&gt;&gt; class AuthorForm(ModelForm):
...     class Meta:
...         model = Author
...         localized_fields = ['birth_date']
</pre> <p>If <code>localized_fields</code> is set to the special value <code>'__all__'</code>, all fields will be localized.</p>   <h3 id="form-inheritance">Form inheritance</h3> <p id="s-form-inheritance">As with basic forms, you can extend and reuse <code>ModelForms</code> by inheriting them. This is useful if you need to declare extra fields or extra methods on a parent class for use in a number of forms derived from models. For example, using the previous <code>ArticleForm</code> class:</p> <pre data-language="pycon">&gt;&gt;&gt; class EnhancedArticleForm(ArticleForm):
...     def clean_pub_date(self): ...
...
</pre> <p>This creates a form that behaves identically to <code>ArticleForm</code>, except there’s some extra validation and cleaning for the <code>pub_date</code> field.</p> <p>You can also subclass the parent’s <code>Meta</code> inner class if you want to change the <code>Meta.fields</code> or <code>Meta.exclude</code> lists:</p> <pre data-language="pycon">&gt;&gt;&gt; class RestrictedArticleForm(EnhancedArticleForm):
...     class Meta(ArticleForm.Meta):
...         exclude = ["body"]
...
</pre> <p>This adds the extra method from the <code>EnhancedArticleForm</code> and modifies the original <code>ArticleForm.Meta</code> to remove one field.</p> <p>There are a couple of things to note, however.</p> <ul> <li>Normal Python name resolution rules apply. If you have multiple base classes that declare a <code>Meta</code> inner class, only the first one will be used. This means the child’s <code>Meta</code>, if it exists, otherwise the <code>Meta</code> of the first parent, etc. </li> <li>It’s possible to inherit from both <code>Form</code> and <code>ModelForm</code> simultaneously, however, you must ensure that <code>ModelForm</code> appears first in the MRO. This is because these classes rely on different metaclasses and a class can only have one metaclass. </li> <li>
<p class="first">It’s possible to declaratively remove a <code>Field</code> inherited from a parent class by setting the name to be <code>None</code> on the subclass.</p> <p>You can only use this technique to opt out from a field defined declaratively by a parent class; it won’t prevent the <code>ModelForm</code> metaclass from generating a default field. To opt-out from default fields, see <a class="reference internal" href="#modelforms-selecting-fields"><span class="std std-ref">Selecting the fields to use</span></a>.</p> </li> </ul>   <h3 id="providing-initial-values">Providing initial values</h3> <p id="s-providing-initial-values">As with regular forms, it’s possible to specify initial data for forms by specifying an <code>initial</code> parameter when instantiating the form. Initial values provided this way will override both initial values from the form field and values from an attached model instance. For example:</p> <pre data-language="pycon">&gt;&gt;&gt; article = Article.objects.get(pk=1)
&gt;&gt;&gt; article.headline
'My headline'
&gt;&gt;&gt; form = ArticleForm(initial={"headline": "Initial headline"}, instance=article)
&gt;&gt;&gt; form["headline"].value()
'Initial headline'
</pre>   <h3 id="modelforms-factory">ModelForm factory function</h3> <p id="s-modelform-factory-function">You can create forms from a given model using the standalone function <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelform_factory" title="django.forms.models.modelform_factory"><code>modelform_factory()</code></a>, instead of using a class definition. This may be more convenient if you do not have many customizations to make:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import modelform_factory
&gt;&gt;&gt; from myapp.models import Book
&gt;&gt;&gt; BookForm = modelform_factory(Book, fields=["author", "title"])
</pre> <p>This can also be used to make modifications to existing forms, for example by specifying the widgets to be used for a given field:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import Textarea
&gt;&gt;&gt; Form = modelform_factory(Book, form=BookForm, widgets={"title": Textarea()})
</pre> <p>The fields to include can be specified using the <code>fields</code> and <code>exclude</code> keyword arguments, or the corresponding attributes on the <code>ModelForm</code> inner <code>Meta</code> class. Please see the <code>ModelForm</code> <a class="reference internal" href="#modelforms-selecting-fields"><span class="std std-ref">Selecting the fields to use</span></a> documentation.</p> <p>… or enable localization for specific fields:</p> <pre data-language="pycon">&gt;&gt;&gt; Form = modelform_factory(Author, form=AuthorForm, localized_fields=["birth_date"])
</pre>    <h2 id="id1">Model formsets</h2> <dl class="py class" id="s-model-formsets"> <dt class="sig sig-object py" id="django.forms.models.BaseModelFormSet">
<code>class models.BaseModelFormSet</code> </dt> 
</dl> <p>Like <a class="reference internal" href="formsets.html"><span class="doc">regular formsets</span></a>, Django provides a couple of enhanced formset classes to make working with Django models more convenient. Let’s reuse the <code>Author</code> model from above:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import modelformset_factory
&gt;&gt;&gt; from myapp.models import Author
&gt;&gt;&gt; AuthorFormSet = modelformset_factory(Author, fields=["name", "title"])
</pre> <p>Using <code>fields</code> restricts the formset to use only the given fields. Alternatively, you can take an “opt-out” approach, specifying which fields to exclude:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(Author, exclude=["birth_date"])
</pre> <p>This will create a formset that is capable of working with the data associated with the <code>Author</code> model. It works just like a regular formset:</p> <pre data-language="pycon">&gt;&gt;&gt; formset = AuthorFormSet()
&gt;&gt;&gt; print(formset)
&lt;input type="hidden" name="form-TOTAL_FORMS" value="1" id="id_form-TOTAL_FORMS"&gt;&lt;input type="hidden" name="form-INITIAL_FORMS" value="0" id="id_form-INITIAL_FORMS"&gt;&lt;input type="hidden" name="form-MIN_NUM_FORMS" value="0" id="id_form-MIN_NUM_FORMS"&gt;&lt;input type="hidden" name="form-MAX_NUM_FORMS" value="1000" id="id_form-MAX_NUM_FORMS"&gt;
&lt;div&gt;&lt;label for="id_form-0-name"&gt;Name:&lt;/label&gt;&lt;input id="id_form-0-name" type="text" name="form-0-name" maxlength="100"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_form-0-title"&gt;Title:&lt;/label&gt;&lt;select name="form-0-title" id="id_form-0-title"&gt;
&lt;option value="" selected&gt;---------&lt;/option&gt;
&lt;option value="MR"&gt;Mr.&lt;/option&gt;
&lt;option value="MRS"&gt;Mrs.&lt;/option&gt;
&lt;option value="MS"&gt;Ms.&lt;/option&gt;
&lt;/select&gt;&lt;input type="hidden" name="form-0-id" id="id_form-0-id"&gt;&lt;/div&gt;
</pre> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a> uses <a class="reference internal" href="../../ref/forms/formsets.html#django.forms.formsets.formset_factory" title="django.forms.formsets.formset_factory"><code>formset_factory()</code></a> to generate formsets. This means that a model formset is an extension of a basic formset that knows how to interact with a particular model.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When using <a class="reference internal" href="../db/models.html#multi-table-inheritance"><span class="std std-ref">multi-table inheritance</span></a>, forms generated by a formset factory will contain a parent link field (by default <code>&lt;parent_model_name&gt;_ptr</code>) instead of an <code>id</code> field.</p> </div>  <h3 id="changing-the-queryset">Changing the queryset</h3> <p id="s-changing-the-queryset">By default, when you create a formset from a model, the formset will use a queryset that includes all objects in the model (e.g., <code>Author.objects.all()</code>). You can override this behavior by using the <code>queryset</code> argument:</p> <pre data-language="pycon">&gt;&gt;&gt; formset = AuthorFormSet(queryset=Author.objects.filter(name__startswith="O"))
</pre> <p>Alternatively, you can create a subclass that sets <code>self.queryset</code> in <code>__init__</code>:</p> <pre data-language="python">from django.forms import BaseModelFormSet
from myapp.models import Author


class BaseAuthorFormSet(BaseModelFormSet):
    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.queryset = Author.objects.filter(name__startswith="O")
</pre> <p>Then, pass your <code>BaseAuthorFormSet</code> class to the factory function:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(
...     Author, fields=["name", "title"], formset=BaseAuthorFormSet
... )
</pre> <p>If you want to return a formset that doesn’t include <em>any</em> preexisting instances of the model, you can specify an empty QuerySet:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet(queryset=Author.objects.none())
</pre>   <h3 id="changing-the-form">Changing the form</h3> <p id="s-changing-the-form">By default, when you use <code>modelformset_factory</code>, a model form will be created using <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelform_factory" title="django.forms.models.modelform_factory"><code>modelform_factory()</code></a>. Often, it can be useful to specify a custom model form. For example, you can create a custom model form that has custom validation:</p> <pre data-language="python">class AuthorForm(forms.ModelForm):
    class Meta:
        model = Author
        fields = ["name", "title"]

    def clean_name(self):
        # custom validation for the name field
        ...
</pre> <p>Then, pass your model form to the factory function:</p> <pre data-language="python">AuthorFormSet = modelformset_factory(Author, form=AuthorForm)
</pre> <p>It is not always necessary to define a custom model form. The <code>modelformset_factory</code> function has several arguments which are passed through to <code>modelform_factory</code>, which are described below.</p>   <h3 id="specifying-widgets-to-use-in-the-form-with-widgets">Specifying widgets to use in the form with <code>widgets</code>
</h3> <p id="s-specifying-widgets-to-use-in-the-form-with-widgets">Using the <code>widgets</code> parameter, you can specify a dictionary of values to customize the <code>ModelForm</code>’s widget class for a particular field. This works the same way as the <code>widgets</code> dictionary on the inner <code>Meta</code> class of a <code>ModelForm</code> works:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(
...     Author,
...     fields=["name", "title"],
...     widgets={"name": Textarea(attrs={"cols": 80, "rows": 20})},
... )
</pre>   <h3 id="enabling-localization-for-fields-with-localized-fields">Enabling localization for fields with <code>localized_fields</code>
</h3> <p id="s-enabling-localization-for-fields-with-localized-fields">Using the <code>localized_fields</code> parameter, you can enable localization for fields in the form.</p> <pre data-language="python">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(
...     Author, fields=['name', 'title', 'birth_date'],
...     localized_fields=['birth_date'])
</pre> <p>If <code>localized_fields</code> is set to the special value <code>'__all__'</code>, all fields will be localized.</p>   <h3 id="id2">Providing initial values</h3> <p id="s-id2">As with regular formsets, it’s possible to <a class="reference internal" href="formsets.html#formsets-initial-data"><span class="std std-ref">specify initial data</span></a> for forms in the formset by specifying an <code>initial</code> parameter when instantiating the model formset class returned by <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a>. However, with model formsets, the initial values only apply to extra forms, those that aren’t attached to an existing model instance. If the length of <code>initial</code> exceeds the number of extra forms, the excess initial data is ignored. If the extra forms with initial data aren’t changed by the user, they won’t be validated or saved.</p>   <h3 id="id3">Saving objects in the formset</h3> <p id="s-saving-objects-in-the-formset">As with a <code>ModelForm</code>, you can save the data as a model object. This is done with the formset’s <code>save()</code> method:</p> <pre data-language="pycon"># Create a formset instance with POST data.
&gt;&gt;&gt; formset = AuthorFormSet(request.POST)

# Assuming all is valid, save the data.
&gt;&gt;&gt; instances = formset.save()
</pre> <p>The <code>save()</code> method returns the instances that have been saved to the database. If a given instance’s data didn’t change in the bound data, the instance won’t be saved to the database and won’t be included in the return value (<code>instances</code>, in the above example).</p> <p>When fields are missing from the form (for example because they have been excluded), these fields will not be set by the <code>save()</code> method. You can find more information about this restriction, which also holds for regular <code>ModelForms</code>, in <a class="reference internal" href="#selecting-the-fields-to-use">Selecting the fields to use</a>.</p> <p>Pass <code>commit=False</code> to return the unsaved model instances:</p> <pre data-language="pycon"># don't save to the database
&gt;&gt;&gt; instances = formset.save(commit=False)
&gt;&gt;&gt; for instance in instances:
...     # do something with instance
...     instance.save()
...
</pre> <p>This gives you the ability to attach data to the instances before saving them to the database. If your formset contains a <code>ManyToManyField</code>, you’ll also need to call <code>formset.save_m2m()</code> to ensure the many-to-many relationships are saved properly.</p> <p>After calling <code>save()</code>, your model formset will have three new attributes containing the formset’s changes:</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.models.BaseModelFormSet.changed_objects">
<code>models.BaseModelFormSet.changed_objects</code> </dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.models.BaseModelFormSet.deleted_objects">
<code>models.BaseModelFormSet.deleted_objects</code> </dt> 
</dl> <dl class="py attribute"> <dt class="sig sig-object py" id="django.forms.models.BaseModelFormSet.new_objects">
<code>models.BaseModelFormSet.new_objects</code> </dt> 
</dl>   <h3 id="model-formsets-max-num">Limiting the number of editable objects</h3> <p id="s-limiting-the-number-of-editable-objects">As with regular formsets, you can use the <code>max_num</code> and <code>extra</code> parameters to <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a> to limit the number of extra forms displayed.</p> <p><code>max_num</code> does not prevent existing objects from being displayed:</p> <pre data-language="pycon">&gt;&gt;&gt; Author.objects.order_by("name")
&lt;QuerySet [&lt;Author: Charles Baudelaire&gt;, &lt;Author: Paul Verlaine&gt;, &lt;Author: Walt Whitman&gt;]&gt;

&gt;&gt;&gt; AuthorFormSet = modelformset_factory(Author, fields=["name"], max_num=1)
&gt;&gt;&gt; formset = AuthorFormSet(queryset=Author.objects.order_by("name"))
&gt;&gt;&gt; [x.name for x in formset.get_queryset()]
['Charles Baudelaire', 'Paul Verlaine', 'Walt Whitman']
</pre> <p>Also, <code>extra=0</code> doesn’t prevent creation of new model instances as you can <a class="reference internal" href="formsets.html#understanding-the-managementform"><span class="std std-ref">add additional forms with JavaScript</span></a> or send additional POST data. See <a class="reference internal" href="#model-formsets-edit-only"><span class="std std-ref">Preventing new objects creation</span></a> on how to do this.</p> <p>If the value of <code>max_num</code> is greater than the number of existing related objects, up to <code>extra</code> additional blank forms will be added to the formset, so long as the total number of forms does not exceed <code>max_num</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(Author, fields=["name"], max_num=4, extra=2)
&gt;&gt;&gt; formset = AuthorFormSet(queryset=Author.objects.order_by("name"))
&gt;&gt;&gt; for form in formset:
...     print(form)
...
&lt;div&gt;&lt;label for="id_form-0-name"&gt;Name:&lt;/label&gt;&lt;input id="id_form-0-name" type="text" name="form-0-name" value="Charles Baudelaire" maxlength="100"&gt;&lt;input type="hidden" name="form-0-id" value="1" id="id_form-0-id"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_form-1-name"&gt;Name:&lt;/label&gt;&lt;input id="id_form-1-name" type="text" name="form-1-name" value="Paul Verlaine" maxlength="100"&gt;&lt;input type="hidden" name="form-1-id" value="3" id="id_form-1-id"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_form-2-name"&gt;Name:&lt;/label&gt;&lt;input id="id_form-2-name" type="text" name="form-2-name" value="Walt Whitman" maxlength="100"&gt;&lt;input type="hidden" name="form-2-id" value="2" id="id_form-2-id"&gt;&lt;/div&gt;
&lt;div&gt;&lt;label for="id_form-3-name"&gt;Name:&lt;/label&gt;&lt;input id="id_form-3-name" type="text" name="form-3-name" maxlength="100"&gt;&lt;input type="hidden" name="form-3-id" id="id_form-3-id"&gt;&lt;/div&gt;
</pre> <p>A <code>max_num</code> value of <code>None</code> (the default) puts a high limit on the number of forms displayed (1000). In practice this is equivalent to no limit.</p>   <h3 id="model-formsets-edit-only">Preventing new objects creation</h3> <p id="s-preventing-new-objects-creation">Using the <code>edit_only</code> parameter, you can prevent creation of any new objects:</p> <pre data-language="pycon">&gt;&gt;&gt; AuthorFormSet = modelformset_factory(
...     Author,
...     fields=["name", "title"],
...     edit_only=True,
... )
</pre> <p>Here, the formset will only edit existing <code>Author</code> instances. No other objects will be created or edited.</p>   <h3 id="using-a-model-formset-in-a-view">Using a model formset in a view</h3> <p id="s-using-a-model-formset-in-a-view">Model formsets are very similar to formsets. Let’s say we want to present a formset to edit <code>Author</code> model instances:</p> <pre data-language="python">from django.forms import modelformset_factory
from django.shortcuts import render
from myapp.models import Author


def manage_authors(request):
    AuthorFormSet = modelformset_factory(Author, fields=["name", "title"])
    if request.method == "POST":
        formset = AuthorFormSet(request.POST, request.FILES)
        if formset.is_valid():
            formset.save()
            # do something.
    else:
        formset = AuthorFormSet()
    return render(request, "manage_authors.html", {"formset": formset})
</pre> <p>As you can see, the view logic of a model formset isn’t drastically different than that of a “normal” formset. The only difference is that we call <code>formset.save()</code> to save the data into the database. (This was described above, in <a class="reference internal" href="#saving-objects-in-the-formset"><span class="std std-ref">Saving objects in the formset</span></a>.)</p>   <h3 id="model-formsets-overriding-clean">Overriding <code>clean()</code> on a <code>ModelFormSet</code>
</h3> <p id="s-overriding-clean-on-a-modelformset">Just like with <code>ModelForms</code>, by default the <code>clean()</code> method of a <code>ModelFormSet</code> will validate that none of the items in the formset violate the unique constraints on your model (either <code>unique</code>, <code>unique_together</code> or <code>unique_for_date|month|year</code>). If you want to override the <code>clean()</code> method on a <code>ModelFormSet</code> and maintain this validation, you must call the parent class’s <code>clean</code> method:</p> <pre data-language="python">from django.forms import BaseModelFormSet


class MyModelFormSet(BaseModelFormSet):
    def clean(self):
        super().clean()
        # example custom validation across forms in the formset
        for form in self.forms:
            # your custom formset validation
            ...
</pre> <p>Also note that by the time you reach this step, individual model instances have already been created for each <code>Form</code>. Modifying a value in <code>form.cleaned_data</code> is not sufficient to affect the saved value. If you wish to modify a value in <code>ModelFormSet.clean()</code> you must modify <code>form.instance</code>:</p> <pre data-language="python">from django.forms import BaseModelFormSet


class MyModelFormSet(BaseModelFormSet):
    def clean(self):
        super().clean()

        for form in self.forms:
            name = form.cleaned_data["name"].upper()
            form.cleaned_data["name"] = name
            # update the instance value.
            form.instance.name = name
</pre>   <h3 id="using-a-custom-queryset">Using a custom queryset</h3> <p id="s-using-a-custom-queryset">As stated earlier, you can override the default queryset used by the model formset:</p> <pre data-language="python">from django.forms import modelformset_factory
from django.shortcuts import render
from myapp.models import Author


def manage_authors(request):
    AuthorFormSet = modelformset_factory(Author, fields=["name", "title"])
    queryset = Author.objects.filter(name__startswith="O")
    if request.method == "POST":
        formset = AuthorFormSet(
            request.POST,
            request.FILES,
            queryset=queryset,
        )
        if formset.is_valid():
            formset.save()
            # Do something.
    else:
        formset = AuthorFormSet(queryset=queryset)
    return render(request, "manage_authors.html", {"formset": formset})
</pre> <p>Note that we pass the <code>queryset</code> argument in both the <code>POST</code> and <code>GET</code> cases in this example.</p>   <h3 id="using-the-formset-in-the-template">Using the formset in the template</h3> <p id="s-using-the-formset-in-the-template">There are three ways to render a formset in a Django template.</p> <p>First, you can let the formset do most of the work:</p> <pre data-language="markup">&lt;form method="post"&gt;
    {{ formset }}
&lt;/form&gt;
</pre> <p>Second, you can manually render the formset, but let the form deal with itself:</p> <pre data-language="markup">&lt;form method="post"&gt;
    {{ formset.management_form }}
    {% for form in formset %}
        {{ form }}
    {% endfor %}
&lt;/form&gt;
</pre> <p>When you manually render the forms yourself, be sure to render the management form as shown above. See the <a class="reference internal" href="formsets.html#understanding-the-managementform"><span class="std std-ref">management form documentation</span></a>.</p> <p>Third, you can manually render each field:</p> <pre data-language="markup">&lt;form method="post"&gt;
    {{ formset.management_form }}
    {% for form in formset %}
        {% for field in form %}
            {{ field.label_tag }} {{ field }}
        {% endfor %}
    {% endfor %}
&lt;/form&gt;
</pre> <p>If you opt to use this third method and you don’t iterate over the fields with a <code>{% for %}</code> loop, you’ll need to render the primary key field. For example, if you were rendering the <code>name</code> and <code>age</code> fields of a model:</p> <pre data-language="markup">&lt;form method="post"&gt;
    {{ formset.management_form }}
    {% for form in formset %}
        {{ form.id }}
        &lt;ul&gt;
            &lt;li&gt;{{ form.name }}&lt;/li&gt;
            &lt;li&gt;{{ form.age }}&lt;/li&gt;
        &lt;/ul&gt;
    {% endfor %}
&lt;/form&gt;
</pre> <p>Notice how we need to explicitly render <code>{{ form.id }}</code>. This ensures that the model formset, in the <code>POST</code> case, will work correctly. (This example assumes a primary key named <code>id</code>. If you’ve explicitly defined your own primary key that isn’t called <code>id</code>, make sure it gets rendered.)</p>    <h2 id="id4">Inline formsets</h2> <dl class="py class" id="s-inline-formsets"> <dt class="sig sig-object py" id="django.forms.models.BaseInlineFormSet">
<code>class models.BaseInlineFormSet</code> </dt> 
</dl> <p>Inline formsets is a small abstraction layer on top of model formsets. These simplify the case of working with related objects via a foreign key. Suppose you have these two models:</p> <pre data-language="python">from django.db import models


class Author(models.Model):
    name = models.CharField(max_length=100)


class Book(models.Model):
    author = models.ForeignKey(Author, on_delete=models.CASCADE)
    title = models.CharField(max_length=100)
</pre> <p>If you want to create a formset that allows you to edit books belonging to a particular author, you could do this:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import inlineformset_factory
&gt;&gt;&gt; BookFormSet = inlineformset_factory(Author, Book, fields=["title"])
&gt;&gt;&gt; author = Author.objects.get(name="Mike Royko")
&gt;&gt;&gt; formset = BookFormSet(instance=author)
</pre> <p><code>BookFormSet</code>’s <a class="reference internal" href="formsets.html#formset-prefix"><span class="std std-ref">prefix</span></a> is <code>'book_set'</code> (<code>&lt;model name&gt;_set</code> ). If <code>Book</code>’s <code>ForeignKey</code> to <code>Author</code> has a <a class="reference internal" href="../../ref/models/fields.html#django.db.models.ForeignKey.related_name" title="django.db.models.ForeignKey.related_name"><code>related_name</code></a>, that’s used instead.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last"><a class="reference internal" href="../../ref/forms/models.html#django.forms.models.inlineformset_factory" title="django.forms.models.inlineformset_factory"><code>inlineformset_factory()</code></a> uses <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.modelformset_factory" title="django.forms.models.modelformset_factory"><code>modelformset_factory()</code></a> and marks <code>can_delete=True</code>.</p> </div> <div class="admonition seealso"> <p class="first admonition-title">See also</p> <p class="last"><a class="reference internal" href="formsets.html#manually-rendered-can-delete-and-can-order"><span class="std std-ref">Manually rendered can_delete and can_order</span></a>.</p> </div>  <h3 id="overriding-methods-on-an-inlineformset">Overriding methods on an <code>InlineFormSet</code>
</h3> <p id="s-overriding-methods-on-an-inlineformset">When overriding methods on <code>InlineFormSet</code>, you should subclass <a class="reference internal" href="#django.forms.models.BaseInlineFormSet" title="django.forms.models.BaseInlineFormSet"><code>BaseInlineFormSet</code></a> rather than <a class="reference internal" href="#django.forms.models.BaseModelFormSet" title="django.forms.models.BaseModelFormSet"><code>BaseModelFormSet</code></a>.</p> <p>For example, if you want to override <code>clean()</code>:</p> <pre data-language="python">from django.forms import BaseInlineFormSet


class CustomInlineFormSet(BaseInlineFormSet):
    def clean(self):
        super().clean()
        # example custom validation across forms in the formset
        for form in self.forms:
            # your custom formset validation
            ...
</pre> <p>See also <a class="reference internal" href="#model-formsets-overriding-clean"><span class="std std-ref">Overriding clean() on a ModelFormSet</span></a>.</p> <p>Then when you create your inline formset, pass in the optional argument <code>formset</code>:</p> <pre data-language="pycon">&gt;&gt;&gt; from django.forms import inlineformset_factory
&gt;&gt;&gt; BookFormSet = inlineformset_factory(
...     Author, Book, fields=["title"], formset=CustomInlineFormSet
... )
&gt;&gt;&gt; author = Author.objects.get(name="Mike Royko")
&gt;&gt;&gt; formset = BookFormSet(instance=author)
</pre>   <h3 id="more-than-one-foreign-key-to-the-same-model">More than one foreign key to the same model</h3> <p id="s-more-than-one-foreign-key-to-the-same-model">If your model contains more than one foreign key to the same model, you’ll need to resolve the ambiguity manually using <code>fk_name</code>. For example, consider the following model:</p> <pre data-language="python">class Friendship(models.Model):
    from_friend = models.ForeignKey(
        Friend,
        on_delete=models.CASCADE,
        related_name="from_friends",
    )
    to_friend = models.ForeignKey(
        Friend,
        on_delete=models.CASCADE,
        related_name="friends",
    )
    length_in_months = models.IntegerField()
</pre> <p>To resolve this, you can use <code>fk_name</code> to <a class="reference internal" href="../../ref/forms/models.html#django.forms.models.inlineformset_factory" title="django.forms.models.inlineformset_factory"><code>inlineformset_factory()</code></a>:</p> <pre data-language="pycon">&gt;&gt;&gt; FriendshipFormSet = inlineformset_factory(
...     Friend, Friendship, fk_name="from_friend", fields=["to_friend", "length_in_months"]
... )
</pre>   <h3 id="using-an-inline-formset-in-a-view">Using an inline formset in a view</h3> <p id="s-using-an-inline-formset-in-a-view">You may want to provide a view that allows a user to edit the related objects of a model. Here’s how you can do that:</p> <pre data-language="python">def manage_books(request, author_id):
    author = Author.objects.get(pk=author_id)
    BookInlineFormSet = inlineformset_factory(Author, Book, fields=["title"])
    if request.method == "POST":
        formset = BookInlineFormSet(request.POST, request.FILES, instance=author)
        if formset.is_valid():
            formset.save()
            # Do something. Should generally end with a redirect. For example:
            return HttpResponseRedirect(author.get_absolute_url())
    else:
        formset = BookInlineFormSet(instance=author)
    return render(request, "manage_books.html", {"formset": formset})
</pre> <p>Notice how we pass <code>instance</code> in both the <code>POST</code> and <code>GET</code> cases.</p>   <h3 id="specifying-widgets-to-use-in-the-inline-form">Specifying widgets to use in the inline form</h3> <p id="s-specifying-widgets-to-use-in-the-inline-form"><code>inlineformset_factory</code> uses <code>modelformset_factory</code> and passes most of its arguments to <code>modelformset_factory</code>. This means you can use the <code>widgets</code> parameter in much the same way as passing it to <code>modelformset_factory</code>. See <a class="reference internal" href="#specifying-widgets-to-use-in-the-form-with-widgets">Specifying widgets to use in the form with widgets</a> above.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.1/topics/forms/modelforms/" class="_attribution-link">https://docs.djangoproject.com/en/5.1/topics/forms/modelforms/</a>
  </p>
</div>
