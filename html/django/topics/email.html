<section id="s-module-django.core.mail"> <h1 id="sending-email">Sending email</h1> <p>Although Python provides a mail sending interface via the <a class="reference external" href="https://docs.python.org/3/library/smtplib.html#module-smtplib" title="(in Python v3.13)"><code>smtplib</code></a> module, Django provides a couple of light wrappers over it. These wrappers are provided to make sending email extra quick, to help test email sending during development, and to provide support for platforms that can’t use SMTP.</p> <p>The code lives in the <code>django.core.mail</code> module.</p> <section id="s-quick-examples"> <h2 id="quick-examples">Quick examples</h2> <p>Use <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> for straightforward email sending. For example, to send a plain text message:</p> <pre data-language="python">from django.core.mail import send_mail

send_mail(
    "Subject here",
    "Here is the message.",
    "from@example.com",
    ["to@example.com"],
    fail_silently=False,
)
</pre> <p>When additional email sending functionality is needed, use <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> or <a class="reference internal" href="#django.core.mail.EmailMultiAlternatives" title="django.core.mail.EmailMultiAlternatives"><code>EmailMultiAlternatives</code></a>. For example, to send a multipart email that includes both HTML and plain text versions with a specific template and custom headers, you can use the following approach:</p> <pre data-language="python">from django.core.mail import EmailMultiAlternatives
from django.template.loader import render_to_string

# First, render the plain text content.
text_content = render_to_string(
    "templates/emails/my_email.txt",
    context={"my_variable": 42},
)

# Secondly, render the HTML content.
html_content = render_to_string(
    "templates/emails/my_email.html",
    context={"my_variable": 42},
)

# Then, create a multipart email instance.
msg = EmailMultiAlternatives(
    "Subject here",
    text_content,
    "from@example.com",
    ["to@example.com"],
    headers={"List-Unsubscribe": "&lt;mailto:unsub@example.com&gt;"},
)

# Lastly, attach the HTML content to the email instance and send.
msg.attach_alternative(html_content, "text/html")
msg.send()
</pre> <p>Mail is sent using the SMTP host and port specified in the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST"><code>EMAIL_HOST</code></a> and <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_PORT"><code>EMAIL_PORT</code></a> settings. The <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_USER"><code>EMAIL_HOST_USER</code></a> and <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_PASSWORD"><code>EMAIL_HOST_PASSWORD</code></a> settings, if set, are used to authenticate to the SMTP server, and the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_USE_TLS"><code>EMAIL_USE_TLS</code></a> and <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_USE_SSL"><code>EMAIL_USE_SSL</code></a> settings control whether a secure connection is used.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The character set of email sent with <code>django.core.mail</code> will be set to the value of your <a class="reference internal" href="../ref/settings.html#std-setting-DEFAULT_CHARSET"><code>DEFAULT_CHARSET</code></a> setting.</p> </div> </section> <section id="s-send-mail"> <h2 id="send-mail"><code>send_mail()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.core.mail.send_mail">
<code>send_mail(subject, message, from_email, recipient_list, fail_silently=False, auth_user=None, auth_password=None, connection=None, html_message=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/__init__.py#L59"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>In most cases, you can send email using <code>django.core.mail.send_mail()</code>.</p> <p>The <code>subject</code>, <code>message</code>, <code>from_email</code> and <code>recipient_list</code> parameters are required.</p> <ul class="simple"> <li>
<code>subject</code>: A string.</li> <li>
<code>message</code>: A string.</li> <li>
<code>from_email</code>: A string. If <code>None</code>, Django will use the value of the <a class="reference internal" href="../ref/settings.html#std-setting-DEFAULT_FROM_EMAIL"><code>DEFAULT_FROM_EMAIL</code></a> setting.</li> <li>
<code>recipient_list</code>: A list of strings, each an email address. Each member of <code>recipient_list</code> will see the other recipients in the “To:” field of the email message.</li> <li>
<code>fail_silently</code>: A boolean. When it’s <code>False</code>, <code>send_mail()</code> will raise an <a class="reference external" href="https://docs.python.org/3/library/smtplib.html#smtplib.SMTPException" title="(in Python v3.13)"><code>smtplib.SMTPException</code></a> if an error occurs. See the <a class="reference external" href="https://docs.python.org/3/library/smtplib.html#module-smtplib" title="(in Python v3.13)"><code>smtplib</code></a> docs for a list of possible exceptions, all of which are subclasses of <a class="reference external" href="https://docs.python.org/3/library/smtplib.html#smtplib.SMTPException" title="(in Python v3.13)"><code>SMTPException</code></a>.</li> <li>
<code>auth_user</code>: The optional username to use to authenticate to the SMTP server. If this isn’t provided, Django will use the value of the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_USER"><code>EMAIL_HOST_USER</code></a> setting.</li> <li>
<code>auth_password</code>: The optional password to use to authenticate to the SMTP server. If this isn’t provided, Django will use the value of the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_PASSWORD"><code>EMAIL_HOST_PASSWORD</code></a> setting.</li> <li>
<code>connection</code>: The optional email backend to use to send the mail. If unspecified, an instance of the default backend will be used. See the documentation on <a class="reference internal" href="#topic-email-backends"><span class="std std-ref">Email backends</span></a> for more details.</li> <li>
<code>html_message</code>: If <code>html_message</code> is provided, the resulting email will be a <em class="mimetype">multipart/alternative</em> email with <code>message</code> as the <em class="mimetype">text/plain</em> content type and <code>html_message</code> as the <em class="mimetype">text/html</em> content type.</li> </ul> <p>The return value will be the number of successfully delivered messages (which can be <code>0</code> or <code>1</code> since it can only send one message).</p> </section> <section id="s-send-mass-mail"> <h2 id="send-mass-mail"><code>send_mass_mail()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.core.mail.send_mass_mail">
<code>send_mass_mail(datatuple, fail_silently=False, auth_user=None, auth_password=None, connection=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/__init__.py#L95"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p><code>django.core.mail.send_mass_mail()</code> is intended to handle mass emailing.</p> <p><code>datatuple</code> is a tuple in which each element is in this format:</p> <pre data-language="python">(subject, message, from_email, recipient_list)
</pre> <p><code>fail_silently</code>, <code>auth_user</code> and <code>auth_password</code> have the same functions as in <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a>.</p> <p>Each separate element of <code>datatuple</code> results in a separate email message. As in <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a>, recipients in the same <code>recipient_list</code> will all see the other addresses in the email messages’ “To:” field.</p> <p>For example, the following code would send two different messages to two different sets of recipients; however, only one connection to the mail server would be opened:</p> <pre data-language="python">message1 = (
    "Subject here",
    "Here is the message",
    "from@example.com",
    ["first@example.com", "other@example.com"],
)
message2 = (
    "Another Subject",
    "Here is another message",
    "from@example.com",
    ["second@test.com"],
)
send_mass_mail((message1, message2), fail_silently=False)
</pre> <p>The return value will be the number of successfully delivered messages.</p> <section id="s-send-mass-mail-vs-send-mail"> <h3 id="send-mass-mail-vs-send-mail">
<code>send_mass_mail()</code> vs. <code>send_mail()</code>
</h3> <p>The main difference between <a class="reference internal" href="#django.core.mail.send_mass_mail" title="django.core.mail.send_mass_mail"><code>send_mass_mail()</code></a> and <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> is that <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> opens a connection to the mail server each time it’s executed, while <a class="reference internal" href="#django.core.mail.send_mass_mail" title="django.core.mail.send_mass_mail"><code>send_mass_mail()</code></a> uses a single connection for all of its messages. This makes <a class="reference internal" href="#django.core.mail.send_mass_mail" title="django.core.mail.send_mass_mail"><code>send_mass_mail()</code></a> slightly more efficient.</p> </section> </section> <section id="s-mail-admins"> <h2 id="mail-admins"><code>mail_admins()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.core.mail.mail_admins">
<code>mail_admins(subject, message, fail_silently=False, connection=None, html_message=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/__init__.py#L122"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p><code>django.core.mail.mail_admins()</code> is a shortcut for sending an email to the site admins, as defined in the <a class="reference internal" href="../ref/settings.html#std-setting-ADMINS"><code>ADMINS</code></a> setting.</p> <p><code>mail_admins()</code> prefixes the subject with the value of the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_SUBJECT_PREFIX"><code>EMAIL_SUBJECT_PREFIX</code></a> setting, which is <code>"[Django] "</code> by default.</p> <p>The “From:” header of the email will be the value of the <a class="reference internal" href="../ref/settings.html#std-setting-SERVER_EMAIL"><code>SERVER_EMAIL</code></a> setting.</p> <p>This method exists for convenience and readability.</p> <p>If <code>html_message</code> is provided, the resulting email will be a <em class="mimetype">multipart/alternative</em> email with <code>message</code> as the <em class="mimetype">text/plain</em> content type and <code>html_message</code> as the <em class="mimetype">text/html</em> content type.</p> </section> <section id="s-mail-managers"> <h2 id="mail-managers"><code>mail_managers()</code></h2> <dl class="py function"> <dt class="sig sig-object py" id="django.core.mail.mail_managers">
<code>mail_managers(subject, message, fail_silently=False, connection=None, html_message=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/__init__.py#L142"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p><code>django.core.mail.mail_managers()</code> is just like <code>mail_admins()</code>, except it sends an email to the site managers, as defined in the <a class="reference internal" href="../ref/settings.html#std-setting-MANAGERS"><code>MANAGERS</code></a> setting.</p> </section> <section id="s-examples"> <h2 id="examples">Examples</h2> <p>This sends a single email to <a class="reference external" href="mailto:john%40example.com.html">john<span>@</span>example<span>.</span>com</a> and <a class="reference external" href="mailto:jane%40example.com.html">jane<span>@</span>example<span>.</span>com</a>, with them both appearing in the “To:”:</p> <pre data-language="python">send_mail(
    "Subject",
    "Message.",
    "from@example.com",
    ["john@example.com", "jane@example.com"],
)
</pre> <p>This sends a message to <a class="reference external" href="mailto:john%40example.com.html">john<span>@</span>example<span>.</span>com</a> and <a class="reference external" href="mailto:jane%40example.com.html">jane<span>@</span>example<span>.</span>com</a>, with them both receiving a separate email:</p> <pre data-language="python">datatuple = (
    ("Subject", "Message.", "from@example.com", ["john@example.com"]),
    ("Subject", "Message.", "from@example.com", ["jane@example.com"]),
)
send_mass_mail(datatuple)
</pre> </section> <section id="s-preventing-header-injection"> <h2 id="preventing-header-injection">Preventing header injection</h2> <p><a class="reference external" href="http://www.nyphp.org/phundamentals/8_Preventing-Email-Header-Injection.html">Header injection</a> is a security exploit in which an attacker inserts extra email headers to control the “To:” and “From:” in email messages that your scripts generate.</p> <p>The Django email functions outlined above all protect against header injection by forbidding newlines in header values. If any <code>subject</code>, <code>from_email</code> or <code>recipient_list</code> contains a newline (in either Unix, Windows or Mac style), the email function (e.g. <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a>) will raise <code>django.core.mail.BadHeaderError</code> (a subclass of <code>ValueError</code>) and, hence, will not send the email. It’s your responsibility to validate all data before passing it to the email functions.</p> <p>If a <code>message</code> contains headers at the start of the string, the headers will be printed as the first bit of the email message.</p> <p>Here’s an example view that takes a <code>subject</code>, <code>message</code> and <code>from_email</code> from the request’s POST data, sends that to <a class="reference external" href="mailto:admin%40example.com.html">admin<span>@</span>example<span>.</span>com</a> and redirects to “/contact/thanks/” when it’s done:</p> <pre data-language="python">from django.core.mail import BadHeaderError, send_mail
from django.http import HttpResponse, HttpResponseRedirect


def send_email(request):
    subject = request.POST.get("subject", "")
    message = request.POST.get("message", "")
    from_email = request.POST.get("from_email", "")
    if subject and message and from_email:
        try:
            send_mail(subject, message, from_email, ["admin@example.com"])
        except BadHeaderError:
            return HttpResponse("Invalid header found.")
        return HttpResponseRedirect("/contact/thanks/")
    else:
        # In reality we'd use a form class
        # to get proper validation errors.
        return HttpResponse("Make sure all fields are entered and valid.")
</pre> </section> <section id="s-the-emailmessage-class"> <h2 id="emailmessage-and-smtpconnection">The <code>EmailMessage</code> class</h2> <p>Django’s <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> and <a class="reference internal" href="#django.core.mail.send_mass_mail" title="django.core.mail.send_mass_mail"><code>send_mass_mail()</code></a> functions are actually thin wrappers that make use of the <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> class.</p> <p>Not all features of the <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> class are available through the <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> and related wrapper functions. If you wish to use advanced features, such as BCC’ed recipients, file attachments, or multi-part email, you’ll need to create <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> instances directly.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is a design feature. <a class="reference internal" href="#django.core.mail.send_mail" title="django.core.mail.send_mail"><code>send_mail()</code></a> and related functions were originally the only interface Django provided. However, the list of parameters they accepted was slowly growing over time. It made sense to move to a more object-oriented design for email messages and retain the original functions only for backwards compatibility.</p> </div> <p><a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> is responsible for creating the email message itself. The <a class="reference internal" href="#topic-email-backends"><span class="std std-ref">email backend</span></a> is then responsible for sending the email.</p> <p>For convenience, <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> provides a <code>send()</code> method for sending a single email. If you need to send multiple messages, the email backend API <a class="reference internal" href="#topics-sending-multiple-emails"><span class="std std-ref">provides an alternative</span></a>.</p> <section id="s-emailmessage-objects"> <h3 id="emailmessage-objects">
<code>EmailMessage</code> Objects</h3> <dl class="py class"> <dt class="sig sig-object py" id="django.core.mail.EmailMessage">
<code>class EmailMessage</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/message.py#L198"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>The <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> class is initialized with the following parameters (in the given order, if positional arguments are used). All parameters are optional and can be set at any time prior to calling the <code>send()</code> method.</p> <ul> <li>
<code>subject</code>: The subject line of the email.</li> <li>
<code>body</code>: The body text. This should be a plain text message.</li> <li>
<code>from_email</code>: The sender’s address. Both <code>fred@example.com</code> and <code>"Fred" &lt;fred@example.com&gt;</code> forms are legal. If omitted, the <a class="reference internal" href="../ref/settings.html#std-setting-DEFAULT_FROM_EMAIL"><code>DEFAULT_FROM_EMAIL</code></a> setting is used.</li> <li>
<code>to</code>: A list or tuple of recipient addresses.</li> <li>
<code>bcc</code>: A list or tuple of addresses used in the “Bcc” header when sending the email.</li> <li>
<code>connection</code>: An <a class="reference internal" href="#topic-email-backends"><span class="std std-ref">email backend</span></a> instance. Use this parameter if you are sending the <code>EmailMessage</code> via <code>send()</code> and you want to use the same connection for multiple messages. If omitted, a new connection is created when <code>send()</code> is called. This parameter is ignored when using <a class="reference internal" href="#topics-sending-multiple-emails"><span class="std std-ref">send_messages()</span></a>.</li> <li>
<p><code>attachments</code>: A list of attachments to put on the message. These can be instances of <a class="reference external" href="https://docs.python.org/3/library/email.mime.html#email.mime.base.MIMEBase" title="(in Python v3.13)"><code>MIMEBase</code></a> or <a class="reference internal" href="#django.core.mail.EmailAttachment" title="django.core.mail.EmailAttachment"><code>EmailAttachment</code></a>, or a tuple with attributes <code>(filename, content, mimetype)</code>.</p> <div class="versionchanged"> <span class="title">Changed in Django 5.2:</span> <p>Support for <a class="reference internal" href="#django.core.mail.EmailAttachment" title="django.core.mail.EmailAttachment"><code>EmailAttachment</code></a> items of <code>attachments</code> were added.</p> </div> </li> <li>
<code>headers</code>: A dictionary of extra headers to put on the message. The keys are the header name, values are the header values. It’s up to the caller to ensure header names and values are in the correct format for an email message. The corresponding attribute is <code>extra_headers</code>.</li> <li>
<code>cc</code>: A list or tuple of recipient addresses used in the “Cc” header when sending the email.</li> <li>
<code>reply_to</code>: A list or tuple of recipient addresses used in the “Reply-To” header when sending the email.</li> </ul> <p>For example:</p> <pre data-language="python">from django.core.mail import EmailMessage

email = EmailMessage(
    "Hello",
    "Body goes here",
    "from@example.com",
    ["to1@example.com", "to2@example.com"],
    ["bcc@example.com"],
    reply_to=["another@example.com"],
    headers={"Message-ID": "foo"},
)
</pre> <p>The class has the following methods:</p> <ul> <li>
<code>send(fail_silently=False)</code> sends the message. If a connection was specified when the email was constructed, that connection will be used. Otherwise, an instance of the default backend will be instantiated and used. If the keyword argument <code>fail_silently</code> is <code>True</code>, exceptions raised while sending the message will be quashed. An empty list of recipients will not raise an exception. It will return <code>1</code> if the message was sent successfully, otherwise <code>0</code>.</li> <li>
<code>message()</code> constructs a <code>django.core.mail.SafeMIMEText</code> object (a subclass of Python’s <a class="reference external" href="https://docs.python.org/3/library/email.mime.html#email.mime.text.MIMEText" title="(in Python v3.13)"><code>MIMEText</code></a> class) or a <code>django.core.mail.SafeMIMEMultipart</code> object holding the message to be sent. If you ever need to extend the <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> class, you’ll probably want to override this method to put the content you want into the MIME object.</li> <li>
<code>recipients()</code> returns a list of all the recipients of the message, whether they’re recorded in the <code>to</code>, <code>cc</code> or <code>bcc</code> attributes. This is another method you might need to override when subclassing, because the SMTP server needs to be told the full list of recipients when the message is sent. If you add another way to specify recipients in your class, they need to be returned from this method as well.</li> <li>
<p><code>attach()</code> creates a new file attachment and adds it to the message. There are two ways to call <code>attach()</code>:</p> <ul> <li>You can pass it a single argument that is a <a class="reference external" href="https://docs.python.org/3/library/email.mime.html#email.mime.base.MIMEBase" title="(in Python v3.13)"><code>MIMEBase</code></a> instance. This will be inserted directly into the resulting message.</li> <li>
<p>Alternatively, you can pass <code>attach()</code> three arguments: <code>filename</code>, <code>content</code> and <code>mimetype</code>. <code>filename</code> is the name of the file attachment as it will appear in the email, <code>content</code> is the data that will be contained inside the attachment and <code>mimetype</code> is the optional MIME type for the attachment. If you omit <code>mimetype</code>, the MIME content type will be guessed from the filename of the attachment.</p> <p>For example:</p> <pre data-language="python">message.attach("design.png", img_data, "image/png")
</pre> <p>If you specify a <code>mimetype</code> of <em class="mimetype">message/rfc822</em>, it will also accept <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>django.core.mail.EmailMessage</code></a> and <a class="reference external" href="https://docs.python.org/3/library/email.compat32-message.html#email.message.Message" title="(in Python v3.13)"><code>email.message.Message</code></a>.</p> <p>For a <code>mimetype</code> starting with <em class="mimetype">text/</em>, content is expected to be a string. Binary data will be decoded using UTF-8, and if that fails, the MIME type will be changed to <em class="mimetype">application/octet-stream</em> and the data will be attached unchanged.</p> <p>In addition, <em class="mimetype">message/rfc822</em> attachments will no longer be base64-encoded in violation of <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc2046.html#section-5.2.1" id="index-0"><strong>RFC 2046 Section 5.2.1</strong></a>, which can cause issues with displaying the attachments in <a class="reference external" href="https://bugzilla.gnome.org/show_bug.cgi?id=651197">Evolution</a> and <a class="reference external" href="https://bugzilla.mozilla.org/show_bug.cgi?id=333880">Thunderbird</a>.</p> </li> </ul> </li> <li>
<p><code>attach_file()</code> creates a new attachment using a file from your filesystem. Call it with the path of the file to attach and, optionally, the MIME type to use for the attachment. If the MIME type is omitted, it will be guessed from the filename. You can use it like this:</p> <pre data-language="python">message.attach_file("/images/weather_map.png")
</pre> <p>For MIME types starting with <em class="mimetype">text/</em>, binary data is handled as in <code>attach()</code>.</p> </li> </ul> <dl class="py class"> <dt class="sig sig-object py" id="django.core.mail.EmailAttachment">
<code>class EmailAttachment</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A named tuple to store attachments to an email.</p> <p>The named tuple has the following indexes:</p> <ul class="simple"> <li><code>filename</code></li> <li><code>content</code></li> <li><code>mimetype</code></li> </ul> </dd>
</dl> </section> <section id="s-sending-alternative-content-types"> <h3 id="sending-alternative-content-types">Sending alternative content types</h3> <section id="s-sending-multiple-content-versions"> <h4 id="sending-multiple-content-versions">Sending multiple content versions</h4> <p>It can be useful to include multiple versions of the content in an email; the classic example is to send both text and HTML versions of a message. With Django’s email library, you can do this using the <a class="reference internal" href="#django.core.mail.EmailMultiAlternatives" title="django.core.mail.EmailMultiAlternatives"><code>EmailMultiAlternatives</code></a> class.</p> <dl class="py class"> <dt class="sig sig-object py" id="django.core.mail.EmailMultiAlternatives">
<code>class EmailMultiAlternatives</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/message.py#L440"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A subclass of <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> that allows additional versions of the message body in the email via the <a class="reference internal" href="#django.core.mail.EmailMultiAlternatives.attach_alternative" title="django.core.mail.EmailMultiAlternatives.attach_alternative"><code>attach_alternative()</code></a> method. This directly inherits all methods (including the class initialization) from <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a>.</p> <dl class="py attribute"> <dt class="sig sig-object py" id="django.core.mail.EmailMultiAlternatives.alternatives">
<code>alternatives</code> </dt> <dd>
<p>A list of <a class="reference internal" href="#django.core.mail.EmailAlternative" title="django.core.mail.EmailAlternative"><code>EmailAlternative</code></a> named tuples. This is particularly useful in tests:</p> <pre data-language="python">self.assertEqual(len(msg.alternatives), 1)
self.assertEqual(msg.alternatives[0].content, html_content)
self.assertEqual(msg.alternatives[0].mimetype, "text/html")
</pre> <p>Alternatives should only be added using the <a class="reference internal" href="#django.core.mail.EmailMultiAlternatives.attach_alternative" title="django.core.mail.EmailMultiAlternatives.attach_alternative"><code>attach_alternative()</code></a> method, or passed to the constructor.</p> <div class="versionchanged"> <span class="title">Changed in Django 5.2:</span> <p>In older versions, <code>alternatives</code> was a list of regular tuples, as opposed to <a class="reference internal" href="#django.core.mail.EmailAlternative" title="django.core.mail.EmailAlternative"><code>EmailAlternative</code></a> named tuples.</p> </div> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.core.mail.EmailMultiAlternatives.attach_alternative">
<code>attach_alternative(content, mimetype)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/message.py#L483"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Attach an alternative representation of the message body in the email.</p> <p>For example, to send a text and HTML combination, you could write:</p> <pre data-language="python">from django.core.mail import EmailMultiAlternatives

subject = "hello"
from_email = "from@example.com"
to = "to@example.com"
text_content = "This is an important message."
html_content = "&lt;p&gt;This is an &lt;strong&gt;important&lt;/strong&gt; message.&lt;/p&gt;"
msg = EmailMultiAlternatives(subject, text_content, from_email, [to])
msg.attach_alternative(html_content, "text/html")
msg.send()
</pre> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.core.mail.EmailMultiAlternatives.body_contains">
<code>body_contains(text)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/message.py#L509"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>Returns a boolean indicating whether the provided <code>text</code> is contained in the email <code>body</code> and in all attached MIME type <code>text/*</code> alternatives.</p> <p>This can be useful when testing emails. For example:</p> <pre data-language="python">def test_contains_email_content(self):
    subject = "Hello World"
    from_email = "from@example.com"
    to = "to@example.com"
    msg = EmailMultiAlternatives(subject, "I am content.", from_email, [to])
    msg.attach_alternative("&lt;p&gt;I am content.&lt;/p&gt;", "text/html")

    self.assertIs(msg.body_contains("I am content"), True)
    self.assertIs(msg.body_contains("&lt;p&gt;I am content.&lt;/p&gt;"), False)
</pre> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.core.mail.EmailAlternative">
<code>class EmailAlternative</code> </dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A named tuple to store alternative versions of email content.</p> <p>The named tuple has the following indexes:</p> <ul class="simple"> <li><code>content</code></li> <li><code>mimetype</code></li> </ul> </dd>
</dl> </section> <section id="s-updating-the-default-content-type"> <h4 id="updating-the-default-content-type">Updating the default content type</h4> <p>By default, the MIME type of the <code>body</code> parameter in an <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> is <code>"text/plain"</code>. It is good practice to leave this alone, because it guarantees that any recipient will be able to read the email, regardless of their mail client. However, if you are confident that your recipients can handle an alternative content type, you can use the <code>content_subtype</code> attribute on the <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> class to change the main content type. The major type will always be <code>"text"</code>, but you can change the subtype. For example:</p> <pre data-language="python">msg = EmailMessage(subject, html_content, from_email, [to])
msg.content_subtype = "html"  # Main content is now text/html
msg.send()
</pre> </section> </section> </section> <section id="s-email-backends"> <h2 id="topic-email-backends">Email backends</h2> <p>The actual sending of an email is handled by the email backend.</p> <p>The email backend class has the following methods:</p> <ul class="simple"> <li>
<code>open()</code> instantiates a long-lived email-sending connection.</li> <li>
<code>close()</code> closes the current email-sending connection.</li> <li>
<code>send_messages(email_messages)</code> sends a list of <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> objects. If the connection is not open, this call will implicitly open the connection, and close the connection afterward. If the connection is already open, it will be left open after mail has been sent.</li> </ul> <p>It can also be used as a context manager, which will automatically call <code>open()</code> and <code>close()</code> as needed:</p> <pre data-language="python">from django.core import mail

with mail.get_connection() as connection:
    mail.EmailMessage(
        subject1,
        body1,
        from1,
        [to1],
        connection=connection,
    ).send()
    mail.EmailMessage(
        subject2,
        body2,
        from2,
        [to2],
        connection=connection,
    ).send()
</pre> <section id="s-obtaining-an-instance-of-an-email-backend"> <h3 id="obtaining-an-instance-of-an-email-backend">Obtaining an instance of an email backend</h3> <p>The <a class="reference internal" href="#django.core.mail.get_connection" title="django.core.mail.get_connection"><code>get_connection()</code></a> function in <code>django.core.mail</code> returns an instance of the email backend that you can use.</p> <dl class="py function"> <dt class="sig sig-object py" id="django.core.mail.get_connection">
<code>get_connection(backend=None, fail_silently=False, *args, **kwargs)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/core/mail/__init__.py#L47"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <p>By default, a call to <code>get_connection()</code> will return an instance of the email backend specified in <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_BACKEND"><code>EMAIL_BACKEND</code></a>. If you specify the <code>backend</code> argument, an instance of that backend will be instantiated.</p> <p>The <code>fail_silently</code> argument controls how the backend should handle errors. If <code>fail_silently</code> is True, exceptions during the email sending process will be silently ignored.</p> <p>All other arguments are passed directly to the constructor of the email backend.</p> <p>Django ships with several email sending backends. With the exception of the SMTP backend (which is the default), these backends are only useful during testing and development. If you have special email sending requirements, you can <a class="reference internal" href="#topic-custom-email-backend"><span class="std std-ref">write your own email backend</span></a>.</p> <section id="s-smtp-backend"> <h4 id="topic-email-smtp-backend">SMTP backend</h4> <dl class="py class"> <dt class="sig sig-object py" id="django.core.mail.backends.smtp.EmailBackend">
<code>class backends.smtp.EmailBackend(host=None, port=None, username=None, password=None, use_tls=None, fail_silently=False, use_ssl=None, timeout=None, ssl_keyfile=None, ssl_certfile=None, **kwargs)</code> </dt> <dd>
<p>This is the default backend. Email will be sent through a SMTP server.</p> <p>The value for each argument is retrieved from the matching setting if the argument is <code>None</code>:</p> <ul class="simple"> <li>
<code>host</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST"><code>EMAIL_HOST</code></a>
</li> <li>
<code>port</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_PORT"><code>EMAIL_PORT</code></a>
</li> <li>
<code>username</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_USER"><code>EMAIL_HOST_USER</code></a>
</li> <li>
<code>password</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST_PASSWORD"><code>EMAIL_HOST_PASSWORD</code></a>
</li> <li>
<code>use_tls</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_USE_TLS"><code>EMAIL_USE_TLS</code></a>
</li> <li>
<code>use_ssl</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_USE_SSL"><code>EMAIL_USE_SSL</code></a>
</li> <li>
<code>timeout</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_TIMEOUT"><code>EMAIL_TIMEOUT</code></a>
</li> <li>
<code>ssl_keyfile</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_SSL_KEYFILE"><code>EMAIL_SSL_KEYFILE</code></a>
</li> <li>
<code>ssl_certfile</code>: <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_SSL_CERTFILE"><code>EMAIL_SSL_CERTFILE</code></a>
</li> </ul> <p>The SMTP backend is the default configuration inherited by Django. If you want to specify it explicitly, put the following in your settings:</p> <pre data-language="python">EMAIL_BACKEND = "django.core.mail.backends.smtp.EmailBackend"
</pre> <p>If unspecified, the default <code>timeout</code> will be the one provided by <a class="reference external" href="https://docs.python.org/3/library/socket.html#socket.getdefaulttimeout" title="(in Python v3.13)"><code>socket.getdefaulttimeout()</code></a>, which defaults to <code>None</code> (no timeout).</p> </dd>
</dl> </section> <section id="s-console-backend"> <h4 id="topic-email-console-backend">Console backend</h4> <p>Instead of sending out real emails the console backend just writes the emails that would be sent to the standard output. By default, the console backend writes to <code>stdout</code>. You can use a different stream-like object by providing the <code>stream</code> keyword argument when constructing the connection.</p> <p>To specify this backend, put the following in your settings:</p> <pre data-language="python">EMAIL_BACKEND = "django.core.mail.backends.console.EmailBackend"
</pre> <p>This backend is not intended for use in production – it is provided as a convenience that can be used during development.</p> </section> <section id="s-file-backend"> <h4 id="topic-email-file-backend">File backend</h4> <p>The file backend writes emails to a file. A new file is created for each new session that is opened on this backend. The directory to which the files are written is either taken from the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_FILE_PATH"><code>EMAIL_FILE_PATH</code></a> setting or from the <code>file_path</code> keyword when creating a connection with <a class="reference internal" href="#django.core.mail.get_connection" title="django.core.mail.get_connection"><code>get_connection()</code></a>.</p> <p>To specify this backend, put the following in your settings:</p> <pre data-language="python">EMAIL_BACKEND = "django.core.mail.backends.filebased.EmailBackend"
EMAIL_FILE_PATH = "/tmp/app-messages"  # change this to a proper location
</pre> <p>This backend is not intended for use in production – it is provided as a convenience that can be used during development.</p> </section> <section id="s-in-memory-backend"> <h4 id="topic-email-memory-backend">In-memory backend</h4> <p>The <code>'locmem'</code> backend stores messages in a special attribute of the <code>django.core.mail</code> module. The <code>outbox</code> attribute is created when the first message is sent. It’s a list with an <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> instance for each message that would be sent.</p> <p>To specify this backend, put the following in your settings:</p> <pre data-language="python">EMAIL_BACKEND = "django.core.mail.backends.locmem.EmailBackend"
</pre> <p>This backend is not intended for use in production – it is provided as a convenience that can be used during development and testing.</p> <p>Django’s test runner <a class="reference internal" href="testing/tools.html#topics-testing-email"><span class="std std-ref">automatically uses this backend for testing</span></a>.</p> </section> <section id="s-dummy-backend"> <h4 id="topic-email-dummy-backend">Dummy backend</h4> <p>As the name suggests the dummy backend does nothing with your messages. To specify this backend, put the following in your settings:</p> <pre data-language="python">EMAIL_BACKEND = "django.core.mail.backends.dummy.EmailBackend"
</pre> <p>This backend is not intended for use in production – it is provided as a convenience that can be used during development.</p> </section> </section> <section id="s-defining-a-custom-email-backend"> <h3 id="topic-custom-email-backend">Defining a custom email backend</h3> <p>If you need to change how emails are sent you can write your own email backend. The <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_BACKEND"><code>EMAIL_BACKEND</code></a> setting in your settings file is then the Python import path for your backend class.</p> <p>Custom email backends should subclass <code>BaseEmailBackend</code> that is located in the <code>django.core.mail.backends.base</code> module. A custom email backend must implement the <code>send_messages(email_messages)</code> method. This method receives a list of <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> instances and returns the number of successfully delivered messages. If your backend has any concept of a persistent session or connection, you should also implement the <code>open()</code> and <code>close()</code> methods. Refer to <code>smtp.EmailBackend</code> for a reference implementation.</p> </section> <section id="s-sending-multiple-emails"> <h3 id="topics-sending-multiple-emails">Sending multiple emails</h3> <p>Establishing and closing an SMTP connection (or any other network connection, for that matter) is an expensive process. If you have a lot of emails to send, it makes sense to reuse an SMTP connection, rather than creating and destroying a connection every time you want to send an email.</p> <p>There are two ways you tell an email backend to reuse a connection.</p> <p>Firstly, you can use the <code>send_messages()</code> method on a connection. This takes a list of <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> (or subclass) instances, and sends them all using that single connection. As a consequence, any <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>connection</code></a> set on an individual message is ignored.</p> <p>For example, if you have a function called <code>get_notification_email()</code> that returns a list of <a class="reference internal" href="#django.core.mail.EmailMessage" title="django.core.mail.EmailMessage"><code>EmailMessage</code></a> objects representing some periodic email you wish to send out, you could send these emails using a single call to send_messages:</p> <pre data-language="python">from django.core import mail

connection = mail.get_connection()  # Use default email connection
messages = get_notification_email()
connection.send_messages(messages)
</pre> <p>In this example, the call to <code>send_messages()</code> opens a connection on the backend, sends the list of messages, and then closes the connection again.</p> <p>The second approach is to use the <code>open()</code> and <code>close()</code> methods on the email backend to manually control the connection. <code>send_messages()</code> will not manually open or close the connection if it is already open, so if you manually open the connection, you can control when it is closed. For example:</p> <pre data-language="python">from django.core import mail

connection = mail.get_connection()

# Manually open the connection
connection.open()

# Construct an email message that uses the connection
email1 = mail.EmailMessage(
    "Hello",
    "Body goes here",
    "from@example.com",
    ["to1@example.com"],
    connection=connection,
)
email1.send()  # Send the email

# Construct two more messages
email2 = mail.EmailMessage(
    "Hello",
    "Body goes here",
    "from@example.com",
    ["to2@example.com"],
)
email3 = mail.EmailMessage(
    "Hello",
    "Body goes here",
    "from@example.com",
    ["to3@example.com"],
)

# Send the two emails in a single call -
connection.send_messages([email2, email3])
# The connection was already open so send_messages() doesn't close it.
# We need to manually close the connection.
connection.close()
</pre> </section> </section> <section id="s-configuring-email-for-development"> <h2 id="configuring-email-for-development">Configuring email for development</h2> <p>There are times when you do not want Django to send emails at all. For example, while developing a website, you probably don’t want to send out thousands of emails – but you may want to validate that emails will be sent to the right people under the right conditions, and that those emails will contain the correct content.</p> <p>The easiest way to configure email for local development is to use the <a class="reference internal" href="#topic-email-console-backend"><span class="std std-ref">console</span></a> email backend. This backend redirects all email to <code>stdout</code>, allowing you to inspect the content of mail.</p> <p>The <a class="reference internal" href="#topic-email-file-backend"><span class="std std-ref">file</span></a> email backend can also be useful during development – this backend dumps the contents of every SMTP connection to a file that can be inspected at your leisure.</p> <p>Another approach is to use a “dumb” SMTP server that receives the emails locally and displays them to the terminal, but does not actually send anything. The <a class="extlink-pypi reference external" href="https://pypi.org/project/aiosmtpd/">aiosmtpd</a> package provides a way to accomplish this:</p> <pre data-language="shell">python -m pip install aiosmtpd

python -m aiosmtpd -n -l localhost:8025
</pre> <p>This command will start a minimal SMTP server listening on port 8025 of localhost. This server prints to standard output all email headers and the email body. You then only need to set the <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_HOST"><code>EMAIL_HOST</code></a> and <a class="reference internal" href="../ref/settings.html#std-setting-EMAIL_PORT"><code>EMAIL_PORT</code></a> accordingly. For a more detailed discussion of SMTP server options, see the documentation of the <a class="reference external" href="https://aiosmtpd.readthedocs.io/en/latest/">aiosmtpd</a> module.</p> <p>For information about unit-testing the sending of emails in your application, see the <a class="reference internal" href="testing/tools.html#topics-testing-email"><span class="std std-ref">Email services</span></a> section of the testing documentation.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/topics/email/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/topics/email/</a>
  </p>
</div>
