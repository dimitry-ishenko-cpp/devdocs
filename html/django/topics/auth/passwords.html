<section id="s-password-management-in-django"> <h1 id="password-management-in-django">Password management in Django</h1> <p>Password management is something that should generally not be reinvented unnecessarily, and Django endeavors to provide a secure and flexible set of tools for managing user passwords. This document describes how Django stores passwords, how the storage hashing can be configured, and some utilities to work with hashed passwords.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <p>Even though users may use strong passwords, attackers might be able to eavesdrop on their connections. Use <a class="reference internal" href="../security.html#security-recommendation-ssl"><span class="std std-ref">HTTPS</span></a> to avoid sending passwords (or any other sensitive data) over plain HTTP connections because they will be vulnerable to password sniffing.</p> </div> <section id="s-how-django-stores-passwords"> <h2 id="auth-password-storage">How Django stores passwords</h2> <p>Django provides a flexible password storage system and uses PBKDF2 by default.</p> <p>The <a class="reference internal" href="../../ref/contrib/auth.html#django.contrib.auth.models.User.password" title="django.contrib.auth.models.User.password"><code>password</code></a> attribute of a <a class="reference internal" href="../../ref/contrib/auth.html#django.contrib.auth.models.User" title="django.contrib.auth.models.User"><code>User</code></a> object is a string in this format:</p> <pre data-language="text">&lt;algorithm&gt;$&lt;iterations&gt;$&lt;salt&gt;$&lt;hash&gt;
</pre> <p>Those are the components used for storing a User’s password, separated by the dollar-sign character and consist of: the hashing algorithm, the number of algorithm iterations (work factor), the random salt, and the resulting password hash. The algorithm is one of a number of one-way hashing or password storage algorithms Django can use; see below. Iterations describe the number of times the algorithm is run over the hash. Salt is the random seed used and the hash is the result of the one-way function.</p> <p>By default, Django uses the <a class="reference external" href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> algorithm with a SHA256 hash, a password stretching mechanism recommended by <a class="reference external" href="https://nvlpubs.nist.gov/nistpubs/Legacy/SP/nistspecialpublication800-132.pdf">NIST</a>. This should be sufficient for most users: it’s quite secure, requiring massive amounts of computing time to break.</p> <p>However, depending on your requirements, you may choose a different algorithm, or even use a custom algorithm to match your specific security situation. Again, most users shouldn’t need to do this – if you’re not sure, you probably don’t. If you do, please read on:</p> <p>Django chooses the algorithm to use by consulting the <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> setting. This is a list of hashing algorithm classes that this Django installation supports.</p> <p>For storing passwords, Django will use the first hasher in <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a>. To store new passwords with a different algorithm, put your preferred algorithm first in <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a>.</p> <p>For verifying passwords, Django will find the hasher in the list that matches the algorithm name in the stored password. If a stored password names an algorithm not found in <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a>, trying to verify it will raise <code>ValueError</code>.</p> <p>The default for <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> is:</p> <pre data-language="python">PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
</pre> <p>This means that Django will use <a class="reference external" href="https://en.wikipedia.org/wiki/PBKDF2">PBKDF2</a> to store all passwords but will support checking passwords stored with PBKDF2SHA1, <a class="reference external" href="https://en.wikipedia.org/wiki/Argon2">argon2</a>, and <a class="reference external" href="https://en.wikipedia.org/wiki/Bcrypt">bcrypt</a>.</p> <p>The next few sections describe a couple of common ways advanced users may want to modify this setting.</p> <section id="s-using-argon2-with-django"> <h3 id="argon2-usage">Using Argon2 with Django</h3> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> is the winner of the 2015 <a class="reference external" href="https://www.password-hashing.net/">Password Hashing Competition</a>, a community organized open competition to select a next generation hashing algorithm. It’s designed not to be easier to compute on custom hardware than it is to compute on an ordinary CPU. The default variant for the Argon2 password hasher is Argon2id.</p> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Argon2">Argon2</a> is not the default for Django because it requires a third-party library. The Password Hashing Competition panel, however, recommends immediate use of Argon2 rather than the other algorithms supported by Django.</p> <p>To use Argon2id as your default storage algorithm, do the following:</p> <ol class="arabic"> <li>Install the <a class="extlink-pypi reference external" href="https://pypi.org/project/argon2-cffi/">argon2-cffi</a> package. This can be done by running <code>python -m pip install django[argon2]</code>, which is equivalent to <code>python -m pip install argon2-cffi</code> (along with any version requirement from Django’s <code>pyproject.toml</code>).</li> <li>
<p>Modify <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> to list <code>Argon2PasswordHasher</code> first. That is, in your settings file, you’d put:</p> <pre data-language="python">PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
</pre> <p>Keep and/or add any entries in this list if you need Django to <a class="reference internal" href="#password-upgrades"><span class="std std-ref">upgrade passwords</span></a>.</p> </li> </ol> </section> <section id="s-using-bcrypt-with-django"> <h3 id="bcrypt-usage">Using <code>bcrypt</code> with Django</h3> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Bcrypt">Bcrypt</a> is a popular password storage algorithm that’s specifically designed for long-term password storage. It’s not the default used by Django since it requires the use of third-party libraries, but since many people may want to use it Django supports bcrypt with minimal effort.</p> <p>To use Bcrypt as your default storage algorithm, do the following:</p> <ol class="arabic"> <li>Install the <a class="extlink-pypi reference external" href="https://pypi.org/project/bcrypt/">bcrypt</a> package. This can be done by running <code>python -m pip install django[bcrypt]</code>, which is equivalent to <code>python -m pip install bcrypt</code> (along with any version requirement from Django’s <code>pyproject.toml</code>).</li> <li>
<p>Modify <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> to list <code>BCryptSHA256PasswordHasher</code> first. That is, in your settings file, you’d put:</p> <pre data-language="python">PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
</pre> <p>Keep and/or add any entries in this list if you need Django to <a class="reference internal" href="#password-upgrades"><span class="std std-ref">upgrade passwords</span></a>.</p> </li> </ol> <p>That’s it – now your Django install will use Bcrypt as the default storage algorithm.</p> </section> <section id="s-using-scrypt-with-django"> <h3 id="scrypt-usage">Using <code>scrypt</code> with Django</h3> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> is similar to PBKDF2 and bcrypt in utilizing a set number of iterations to slow down brute-force attacks. However, because PBKDF2 and bcrypt do not require a lot of memory, attackers with sufficient resources can launch large-scale parallel attacks in order to speed up the attacking process. <a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> is specifically designed to use more memory compared to other password-based key derivation functions in order to limit the amount of parallelism an attacker can use, see <a class="rfc reference external" href="https://datatracker.ietf.org/doc/html/rfc7914.html" id="index-0"><strong>RFC 7914</strong></a> for more details.</p> <p>To use <a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> as your default storage algorithm, do the following:</p> <ol class="arabic"> <li>
<p>Modify <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> to list <code>ScryptPasswordHasher</code> first. That is, in your settings file:</p> <pre data-language="python">PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.ScryptPasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
]
</pre> <p>Keep and/or add any entries in this list if you need Django to <a class="reference internal" href="#password-upgrades"><span class="std std-ref">upgrade passwords</span></a>.</p> </li> </ol> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>scrypt</code> requires OpenSSL 1.1+.</p> </div> </section> <section id="s-increasing-the-salt-entropy"> <h3 id="increasing-the-salt-entropy">Increasing the salt entropy</h3> <p>Most password hashes include a salt along with their password hash in order to protect against rainbow table attacks. The salt itself is a random value which increases the size and thus the cost of the rainbow table and is currently set at 128 bits with the <code>salt_entropy</code> value in the <code>BasePasswordHasher</code>. As computing and storage costs decrease this value should be raised. When implementing your own password hasher you are free to override this value in order to use a desired entropy level for your password hashes. <code>salt_entropy</code> is measured in bits.</p> <div class="admonition-implementation-detail admonition"> <p class="admonition-title">Implementation detail</p> <p>Due to the method in which salt values are stored the <code>salt_entropy</code> value is effectively a minimum value. For instance a value of 128 would provide a salt which would actually contain 131 bits of entropy.</p> </div> </section> <section id="s-increasing-the-work-factor"> <h3 id="increasing-password-algorithm-work-factor">Increasing the work factor</h3> <section id="s-pbkdf2-and-bcrypt"> <h4 id="pbkdf2-and-bcrypt">PBKDF2 and bcrypt</h4> <p>The PBKDF2 and bcrypt algorithms use a number of iterations or rounds of hashing. This deliberately slows down attackers, making attacks against hashed passwords harder. However, as computing power increases, the number of iterations needs to be increased. We’ve chosen a reasonable default (and will increase it with each release of Django), but you may wish to tune it up or down, depending on your security needs and available processing power. To do so, you’ll subclass the appropriate algorithm and override the <code>iterations</code> parameter (use the <code>rounds</code> parameter when subclassing a bcrypt hasher). For example, to increase the number of iterations used by the default PBKDF2 algorithm:</p> <ol class="arabic"> <li>
<p>Create a subclass of <code>django.contrib.auth.hashers.PBKDF2PasswordHasher</code></p> <pre data-language="python">from django.contrib.auth.hashers import PBKDF2PasswordHasher


class MyPBKDF2PasswordHasher(PBKDF2PasswordHasher):
    """
    A subclass of PBKDF2PasswordHasher that uses 100 times more iterations.
    """

    iterations = PBKDF2PasswordHasher.iterations * 100
</pre> <p>Save this somewhere in your project. For example, you might put this in a file like <code>myproject/hashers.py</code>.</p> </li> <li>
<p>Add your new hasher as the first entry in <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a>:</p> <pre data-language="python">PASSWORD_HASHERS = [
    "myproject.hashers.MyPBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
]
</pre> </li> </ol> <p>That’s it – now your Django install will use more iterations when it stores passwords using PBKDF2.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>bcrypt <code>rounds</code> is a logarithmic work factor, e.g. 12 rounds means <code>2 ** 12</code> iterations.</p> </div> </section> <section id="s-argon2"> <h4 id="argon2">Argon2</h4> <p>Argon2 has the following attributes that can be customized:</p> <ol class="arabic simple"> <li>
<code>time_cost</code> controls the number of iterations within the hash.</li> <li>
<code>memory_cost</code> controls the size of memory that must be used during the computation of the hash.</li> <li>
<code>parallelism</code> controls how many CPUs the computation of the hash can be parallelized on.</li> </ol> <p>The default values of these attributes are probably fine for you. If you determine that the password hash is too fast or too slow, you can tweak it as follows:</p> <ol class="arabic simple"> <li>Choose <code>parallelism</code> to be the number of threads you can spare computing the hash.</li> <li>Choose <code>memory_cost</code> to be the KiB of memory you can spare.</li> <li>Adjust <code>time_cost</code> and measure the time hashing a password takes. Pick a <code>time_cost</code> that takes an acceptable time for you. If <code>time_cost</code> set to 1 is unacceptably slow, lower <code>memory_cost</code>.</li> </ol> <div class="admonition-memory-cost-interpretation admonition"> <p class="admonition-title"><code>memory_cost</code> interpretation</p> <p>The argon2 command-line utility and some other libraries interpret the <code>memory_cost</code> parameter differently from the value that Django uses. The conversion is given by <code>memory_cost == 2 ** memory_cost_commandline</code>.</p> </div> </section> <section id="s-scrypt"> <h4 id="scrypt"><code>scrypt</code></h4> <p><a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> has the following attributes that can be customized:</p> <ol class="arabic simple"> <li>
<code>work_factor</code> controls the number of iterations within the hash.</li> <li><code>block_size</code></li> <li>
<code>parallelism</code> controls how many threads will run in parallel.</li> <li>
<code>maxmem</code> limits the maximum size of memory that can be used during the computation of the hash. Defaults to <code>0</code>, which means the default limitation from the OpenSSL library.</li> </ol> <p>We’ve chosen reasonable defaults, but you may wish to tune it up or down, depending on your security needs and available processing power.</p> <div class="admonition-estimating-memory-usage admonition"> <p class="admonition-title">Estimating memory usage</p> <p>The minimum memory requirement of <a class="reference external" href="https://en.wikipedia.org/wiki/Scrypt">scrypt</a> is:</p> <pre data-language="python">work_factor * 2 * block_size * 64
</pre> <p>so you may need to tweak <code>maxmem</code> when changing the <code>work_factor</code> or <code>block_size</code> values.</p> </div> </section> </section> <section id="s-password-upgrading"> <h3 id="password-upgrades">Password upgrading</h3> <p>When users log in, if their passwords are stored with anything other than the preferred algorithm, Django will automatically upgrade the algorithm to the preferred one. This means that old installs of Django will get automatically more secure as users log in, and it also means that you can switch to new (and better) storage algorithms as they get invented.</p> <p>However, Django can only upgrade passwords that use algorithms mentioned in <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a>, so as you upgrade to new systems you should make sure never to <em>remove</em> entries from this list. If you do, users using unmentioned algorithms won’t be able to upgrade. Hashed passwords will be updated when increasing (or decreasing) the number of PBKDF2 iterations, bcrypt rounds, or argon2 attributes.</p> <p>Be aware that if all the passwords in your database aren’t encoded in the default hasher’s algorithm, you may be vulnerable to a user enumeration timing attack due to a difference between the duration of a login request for a user with a password encoded in a non-default algorithm and the duration of a login request for a nonexistent user (which runs the default hasher). You may be able to mitigate this by <a class="reference internal" href="#wrapping-password-hashers"><span class="std std-ref">upgrading older password hashes</span></a>.</p> </section> <section id="s-password-upgrading-without-requiring-a-login"> <h3 id="wrapping-password-hashers">Password upgrading without requiring a login</h3> <p>If you have an existing database with an older, weak hash such as MD5, you might want to upgrade those hashes yourself instead of waiting for the upgrade to happen when a user logs in (which may never happen if a user doesn’t return to your site). In this case, you can use a “wrapped” password hasher.</p> <p>For this example, we’ll migrate a collection of MD5 hashes to use PBKDF2(MD5(password)) and add the corresponding password hasher for checking if a user entered the correct password on login. We assume we’re using the built-in <code>User</code> model and that our project has an <code>accounts</code> app. You can modify the pattern to work with any algorithm or with a custom user model.</p> <p>First, we’ll add the custom hasher:</p> <div class="literal-block-wrapper docutils container" id="id4"> <div class="code-block-caption"><span class="caption-text"><code>accounts/hashers.py</code></span></div> <pre data-language="python">from django.contrib.auth.hashers import (
    PBKDF2PasswordHasher,
    MD5PasswordHasher,
)


class PBKDF2WrappedMD5PasswordHasher(PBKDF2PasswordHasher):
    algorithm = "pbkdf2_wrapped_md5"

    def encode_md5_hash(self, md5_hash, salt, iterations=None):
        return super().encode(md5_hash, salt, iterations)

    def encode(self, password, salt, iterations=None):
        _, _, md5_hash = MD5PasswordHasher().encode(password, salt).split("$", 2)
        return self.encode_md5_hash(md5_hash, salt, iterations)
</pre> </div> <p>The data migration might look something like:</p> <div class="literal-block-wrapper docutils container" id="id5"> <div class="code-block-caption"><span class="caption-text"><code>accounts/migrations/0002_migrate_md5_passwords.py</code></span></div> <pre data-language="python">from django.db import migrations

from ..hashers import PBKDF2WrappedMD5PasswordHasher


def forwards_func(apps, schema_editor):
    User = apps.get_model("auth", "User")
    users = User.objects.filter(password__startswith="md5$")
    hasher = PBKDF2WrappedMD5PasswordHasher()
    for user in users:
        algorithm, salt, md5_hash = user.password.split("$", 2)
        user.password = hasher.encode_md5_hash(md5_hash, salt)
        user.save(update_fields=["password"])


class Migration(migrations.Migration):
    dependencies = [
        ("accounts", "0001_initial"),
        # replace this with the latest migration in contrib.auth
        ("auth", "####_migration_name"),
    ]

    operations = [
        migrations.RunPython(forwards_func),
    ]
</pre> </div> <p>Be aware that this migration will take on the order of several minutes for several thousand users, depending on the speed of your hardware.</p> <p>Finally, we’ll add a <a class="reference internal" href="../../ref/settings.html#std-setting-PASSWORD_HASHERS"><code>PASSWORD_HASHERS</code></a> setting:</p> <div class="literal-block-wrapper docutils container" id="id6"> <div class="code-block-caption"><span class="caption-text"><code>mysite/settings.py</code></span></div> <pre data-language="python">PASSWORD_HASHERS = [
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "accounts.hashers.PBKDF2WrappedMD5PasswordHasher",
]
</pre> </div> <p>Include any other hashers that your site uses in this list.</p> </section> <section id="s-included-hashers"> <h3 id="auth-included-hashers">Included hashers</h3> <p>The full list of hashers included in Django is:</p> <pre data-language="python">[
    "django.contrib.auth.hashers.PBKDF2PasswordHasher",
    "django.contrib.auth.hashers.PBKDF2SHA1PasswordHasher",
    "django.contrib.auth.hashers.Argon2PasswordHasher",
    "django.contrib.auth.hashers.BCryptSHA256PasswordHasher",
    "django.contrib.auth.hashers.BCryptPasswordHasher",
    "django.contrib.auth.hashers.ScryptPasswordHasher",
    "django.contrib.auth.hashers.MD5PasswordHasher",
]
</pre> <p>The corresponding algorithm names are:</p> <ul class="simple"> <li><code>pbkdf2_sha256</code></li> <li><code>pbkdf2_sha1</code></li> <li><code>argon2</code></li> <li><code>bcrypt_sha256</code></li> <li><code>bcrypt</code></li> <li><code>scrypt</code></li> <li><code>md5</code></li> </ul> </section> <section id="s-writing-your-own-hasher"> <h3 id="write-your-own-password-hasher">Writing your own hasher</h3> <p>If you write your own password hasher that contains a work factor such as a number of iterations, you should implement a <code>harden_runtime(self, password, encoded)</code> method to bridge the runtime gap between the work factor supplied in the <code>encoded</code> password and the default work factor of the hasher. This prevents a user enumeration timing attack due to difference between a login request for a user with a password encoded in an older number of iterations and a nonexistent user (which runs the default hasher’s default number of iterations).</p> <p>Taking PBKDF2 as example, if <code>encoded</code> contains 20,000 iterations and the hasher’s default <code>iterations</code> is 30,000, the method should run <code>password</code> through another 10,000 iterations of PBKDF2.</p> <p>If your hasher doesn’t have a work factor, implement the method as a no-op (<code>pass</code>).</p> </section> </section> <section id="s-module-django.contrib.auth.hashers"> <h2 id="manually-managing-a-user-s-password">Manually managing a user’s password</h2> <p>The <a class="reference internal" href="#module-django.contrib.auth.hashers" title="django.contrib.auth.hashers"><code>django.contrib.auth.hashers</code></a> module provides a set of functions to create and validate hashed passwords. You can use them independently from the <code>User</code> model.</p> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.hashers.check_password">
<code>check_password(password, encoded, setter=None, preferred='default')</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L72"><span class="viewcode-link">[source]</span></a>
</dt> 
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.hashers.acheck_password">
<code>acheck_password(password, encoded, asetter=None, preferred='default')</code> </dt> <dd>
<p><em>Asynchronous version</em>: <code>acheck_password()</code></p> <p>If you’d like to manually authenticate a user by comparing a plain-text password to the hashed password in the database, use the convenience function <a class="reference internal" href="#django.contrib.auth.hashers.check_password" title="django.contrib.auth.hashers.check_password"><code>check_password()</code></a>. It takes two mandatory arguments: the plain-text password to check, and the full value of a user’s <code>password</code> field in the database to check against. It returns <code>True</code> if they match, <code>False</code> otherwise. Optionally, you can pass a callable <code>setter</code> that takes the password and will be called when you need to regenerate it. You can also pass <code>preferred</code> to change a hashing algorithm if you don’t want to use the default (first entry of <code>PASSWORD_HASHERS</code> setting). See <a class="reference internal" href="#auth-included-hashers"><span class="std std-ref">Included hashers</span></a> for the algorithm name of each hasher.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.hashers.make_password">
<code>make_password(password, salt=None, hasher='default')</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L94"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Creates a hashed password in the format used by this application. It takes one mandatory argument: the password in plain-text (string or bytes). Optionally, you can provide a salt and a hashing algorithm to use, if you don’t want to use the defaults (first entry of <code>PASSWORD_HASHERS</code> setting). See <a class="reference internal" href="#auth-included-hashers"><span class="std std-ref">Included hashers</span></a> for the algorithm name of each hasher. If the password argument is <code>None</code>, an unusable password is returned (one that will never be accepted by <a class="reference internal" href="#django.contrib.auth.hashers.check_password" title="django.contrib.auth.hashers.check_password"><code>check_password()</code></a>).</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.hashers.is_password_usable">
<code>is_password_usable(encoded_password)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/hashers.py#L28"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns <code>False</code> if the password is a result of <a class="reference internal" href="../../ref/contrib/auth.html#django.contrib.auth.models.User.set_unusable_password" title="django.contrib.auth.models.User.set_unusable_password"><code>User.set_unusable_password()</code></a>.</p> </dd>
</dl> </section> <section id="s-module-django.contrib.auth.password_validation"> <h2 id="password-validation">Password validation</h2> <p>Users often choose poor passwords. To help mitigate this problem, Django offers pluggable password validation. You can configure multiple password validators at the same time. A few validators are included in Django, but you can write your own as well.</p> <p>Each password validator must provide a help text to explain the requirements to the user, validate a given password and return an error message if it does not meet the requirements, and optionally define a callback to be notified when the password for a user has been changed. Validators can also have optional settings to fine tune their behavior.</p> <p>Validation is controlled by the <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a> setting. The default for the setting is an empty list, which means no validators are applied. In new projects created with the default <a class="reference internal" href="../../ref/django-admin.html#django-admin-startproject"><code>startproject</code></a> template, a set of validators is enabled by default.</p> <p>By default, validators are used in the forms to reset or change passwords and in the <a class="reference internal" href="../../ref/django-admin.html#django-admin-createsuperuser"><code>createsuperuser</code></a> and <a class="reference internal" href="../../ref/django-admin.html#django-admin-changepassword"><code>changepassword</code></a> management commands. Validators aren’t applied at the model level, for example in <code>User.objects.create_user()</code> and <code>create_superuser()</code>, because we assume that developers, not users, interact with Django at that level and also because model validation doesn’t automatically run as part of creating models.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Password validation can prevent the use of many types of weak passwords. However, the fact that a password passes all the validators doesn’t guarantee that it is a strong password. There are many factors that can weaken a password that are not detectable by even the most advanced password validators.</p> </div> <section id="s-enabling-password-validation"> <h3 id="enabling-password-validation">Enabling password validation</h3> <p>Password validation is configured in the <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a> setting:</p> <pre data-language="python">AUTH_PASSWORD_VALIDATORS = [
    {
        "NAME": "django.contrib.auth.password_validation.UserAttributeSimilarityValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.MinimumLengthValidator",
        "OPTIONS": {
            "min_length": 9,
        },
    },
    {
        "NAME": "django.contrib.auth.password_validation.CommonPasswordValidator",
    },
    {
        "NAME": "django.contrib.auth.password_validation.NumericPasswordValidator",
    },
]
</pre> <p>This example enables all four included validators:</p> <ul class="simple"> <li>
<code>UserAttributeSimilarityValidator</code>, which checks the similarity between the password and a set of attributes of the user.</li> <li>
<code>MinimumLengthValidator</code>, which checks whether the password meets a minimum length. This validator is configured with a custom option: it now requires the minimum length to be nine characters, instead of the default eight.</li> <li>
<code>CommonPasswordValidator</code>, which checks whether the password occurs in a list of common passwords. By default, it compares to an included list of 20,000 common passwords.</li> <li>
<code>NumericPasswordValidator</code>, which checks whether the password isn’t entirely numeric.</li> </ul> <p>For <code>UserAttributeSimilarityValidator</code> and <code>CommonPasswordValidator</code>, we’re using the default settings in this example. <code>NumericPasswordValidator</code> has no settings.</p> <p>The help texts and any errors from password validators are always returned in the order they are listed in <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a>.</p> </section> <section id="s-included-validators"> <h3 id="included-password-validators">Included validators</h3> <p>Django includes four validators:</p> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.MinimumLengthValidator">
<code>class MinimumLengthValidator(min_length=8)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L99"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Validates that the password is of a minimum length. The minimum length can be customized with the <code>min_length</code> parameter.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.MinimumLengthValidator.get_error_message">
<code>get_error_message()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L111"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A hook for customizing the <code>ValidationError</code> error message. Defaults to <code>"This password is too short. It must contain at least &lt;min_length&gt;
characters."</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.MinimumLengthValidator.get_help_text">
<code>get_help_text()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L120"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A hook for customizing the validator’s help text. Defaults to <code>"Your
password must contain at least &lt;min_length&gt; characters."</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.UserAttributeSimilarityValidator">
<code>class UserAttributeSimilarityValidator(user_attributes=DEFAULT_USER_ATTRIBUTES, max_similarity=0.7)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L158"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Validates that the password is sufficiently different from certain attributes of the user.</p> <p>The <code>user_attributes</code> parameter should be an iterable of names of user attributes to compare to. If this argument is not provided, the default is used: <code>'username', 'first_name', 'last_name', 'email'</code>. Attributes that don’t exist are ignored.</p> <p>The maximum allowed similarity of passwords can be set on a scale of 0.1 to 1.0 with the <code>max_similarity</code> parameter. This is compared to the result of <a class="reference external" href="https://docs.python.org/3/library/difflib.html#difflib.SequenceMatcher.quick_ratio" title="(in Python v3.13)"><code>difflib.SequenceMatcher.quick_ratio()</code></a>. A value of 0.1 rejects passwords unless they are substantially different from the <code>user_attributes</code>, whereas a value of 1.0 rejects only passwords that are identical to an attribute’s value.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.UserAttributeSimilarityValidator.get_error_message">
<code>get_error_message()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L210"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A hook for customizing the <code>ValidationError</code> error message. Defaults to <code>"The password is too similar to the &lt;user_attribute&gt;."</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.UserAttributeSimilarityValidator.get_help_text">
<code>get_help_text()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L213"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A hook for customizing the validator’s help text. Defaults to <code>"Your
password can’t be too similar to your other personal information."</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.CommonPasswordValidator">
<code>class CommonPasswordValidator(password_list_path=DEFAULT_PASSWORD_LIST_PATH)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L219"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Validates that the password is not a common password. This converts the password to lowercase (to do a case-insensitive comparison) and checks it against a list of 20,000 common password created by <a class="reference external" href="https://gist.github.com/roycewilliams/226886fd01572964e1431ac8afc999ce">Royce Williams</a>.</p> <p>The <code>password_list_path</code> can be set to the path of a custom file of common passwords. This file should contain one lowercase password per line and may be plain text or gzipped.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.CommonPasswordValidator.get_error_message">
<code>get_error_message()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L251"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A hook for customizing the <code>ValidationError</code> error message. Defaults to <code>"This password is too common."</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.CommonPasswordValidator.get_help_text">
<code>get_help_text()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L254"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A hook for customizing the validator’s help text. Defaults to <code>"Your
password can’t be a commonly used password."</code>.</p> </dd>
</dl> </dd>
</dl> <dl class="py class"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.NumericPasswordValidator">
<code>class NumericPasswordValidator</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L258"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Validate that the password is not entirely numeric.</p> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.NumericPasswordValidator.get_error_message">
<code>get_error_message()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L270"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<div class="versionadded"> <span class="title">New in Django 5.2.</span> </div> <p>A hook for customizing the <code>ValidationError</code> error message. Defaults to <code>"This password is entirely numeric."</code>.</p> </dd>
</dl> <dl class="py method"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.NumericPasswordValidator.get_help_text">
<code>get_help_text()</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L273"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>A hook for customizing the validator’s help text. Defaults to <code>"Your
password can’t be entirely numeric."</code>.</p> </dd>
</dl> </dd>
</dl> </section> <section id="s-integrating-validation"> <h3 id="integrating-validation">Integrating validation</h3> <p>There are a few functions in <code>django.contrib.auth.password_validation</code> that you can call from your own forms or other code to integrate password validation. This can be useful if you use custom forms for password setting, or if you have API calls that allow passwords to be set, for example.</p> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.validate_password">
<code>validate_password(password, user=None, password_validators=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L41"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Validates a password. If all validators find the password valid, returns <code>None</code>. If one or more validators reject the password, raises a <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code>ValidationError</code></a> with all the error messages from the validators.</p> <p>The <code>user</code> object is optional: if it’s not provided, some validators may not be able to perform any validation and will accept any password.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.password_changed">
<code>password_changed(password, user=None, password_validators=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L60"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Informs all validators that the password has been changed. This can be used by validators such as one that prevents password reuse. This should be called once the password has been successfully changed.</p> <p>For subclasses of <a class="reference internal" href="customizing.html#django.contrib.auth.models.AbstractBaseUser" title="django.contrib.auth.models.AbstractBaseUser"><code>AbstractBaseUser</code></a>, the password field will be marked as “dirty” when calling <a class="reference internal" href="customizing.html#django.contrib.auth.models.AbstractBaseUser.set_password" title="django.contrib.auth.models.AbstractBaseUser.set_password"><code>set_password()</code></a> which triggers a call to <code>password_changed()</code> after the user is saved.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.password_validators_help_texts">
<code>password_validators_help_texts(password_validators=None)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L72"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a list of the help texts of all validators. These explain the password requirements to the user.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.password_validators_help_text_html">
<code>password_validators_help_text_html(password_validators=None)</code> </dt> <dd>
<p>Returns an HTML string with all help texts in an <code>&lt;ul&gt;</code>. This is helpful when adding password validation to forms, as you can pass the output directly to the <code>help_text</code> parameter of a form field.</p> </dd>
</dl> <dl class="py function"> <dt class="sig sig-object py" id="django.contrib.auth.password_validation.get_password_validators">
<code>get_password_validators(validator_config)</code> <a class="reference external" href="https://github.com/django/django/blob/stable/5.2.x/django/contrib/auth/password_validation.py#L25"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Returns a set of validator objects based on the <code>validator_config</code> parameter. By default, all functions use the validators defined in <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a>, but by calling this function with an alternate set of validators and then passing the result into the <code>password_validators</code> parameter of the other functions, your custom set of validators will be used instead. This is useful when you have a typical set of validators to use for most scenarios, but also have a special situation that requires a custom set. If you always use the same set of validators, there is no need to use this function, as the configuration from <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a> is used by default.</p> <p>The structure of <code>validator_config</code> is identical to the structure of <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a>. The return value of this function can be passed into the <code>password_validators</code> parameter of the functions listed above.</p> </dd>
</dl> <p>Note that where the password is passed to one of these functions, this should always be the clear text password - not a hashed password.</p> </section> <section id="s-writing-your-own-validator"> <h3 id="writing-your-own-validator">Writing your own validator</h3> <p>If Django’s built-in validators are not sufficient, you can write your own password validators. Validators have a fairly small interface. They must implement two methods:</p> <ul class="simple"> <li>
<code>validate(self, password, user=None)</code>: validate a password. Return <code>None</code> if the password is valid, or raise a <a class="reference internal" href="../../ref/exceptions.html#django.core.exceptions.ValidationError" title="django.core.exceptions.ValidationError"><code>ValidationError</code></a> with an error message if the password is not valid. You must be able to deal with <code>user</code> being <code>None</code> - if that means your validator can’t run, return <code>None</code> for no error.</li> <li>
<code>get_help_text()</code>: provide a help text to explain the requirements to the user.</li> </ul> <p>Any items in the <code>OPTIONS</code> in <a class="reference internal" href="../../ref/settings.html#std-setting-AUTH_PASSWORD_VALIDATORS"><code>AUTH_PASSWORD_VALIDATORS</code></a> for your validator will be passed to the constructor. All constructor arguments should have a default value.</p> <p>Here’s a basic example of a validator, with one optional setting:</p> <pre data-language="python">from django.core.exceptions import ValidationError
from django.utils.translation import gettext as _


class MinimumLengthValidator:
    def __init__(self, min_length=8):
        self.min_length = min_length

    def validate(self, password, user=None):
        if len(password) &lt; self.min_length:
            raise ValidationError(
                _("This password must contain at least %(min_length)d characters."),
                code="password_too_short",
                params={"min_length": self.min_length},
            )

    def get_help_text(self):
        return _(
            "Your password must contain at least %(min_length)d characters."
            % {"min_length": self.min_length}
        )
</pre> <p>You can also implement <code>password_changed(password, user=None</code>), which will be called after a successful password change. That can be used to prevent password reuse, for example. However, if you decide to store a user’s previous passwords, you should never do so in clear text.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.2/topics/auth/passwords/" class="_attribution-link">https://docs.djangoproject.com/en/5.2/topics/auth/passwords/</a>
  </p>
</div>
