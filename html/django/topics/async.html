<h1 id="asynchronous-support">Asynchronous support</h1> <p id="s-asynchronous-support">Django has support for writing asynchronous (“async”) views, along with an entirely async-enabled request stack if you are running under <a class="reference internal" href="../howto/deployment/asgi/index.html"><span class="doc">ASGI</span></a>. Async views will still work under WSGI, but with performance penalties, and without the ability to have efficient long-running requests.</p> <p>We’re still working on async support for the ORM and other parts of Django. You can expect to see this in future releases. For now, you can use the <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> adapter to interact with the sync parts of Django. There is also a whole range of async-native Python libraries that you can integrate with.</p>  <h2 id="async-views">Async views</h2> <p id="s-async-views">Any view can be declared async by making the callable part of it return a coroutine - commonly, this is done using <code>async def</code>. For a function-based view, this means declaring the whole view using <code>async def</code>. For a class-based view, this means declaring the HTTP method handlers, such as <code>get()</code> and <code>post()</code> as <code>async def</code> (not its <code>__init__()</code>, or <code>as_view()</code>).</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Django uses <code>asgiref.sync.iscoroutinefunction</code> to test if your view is asynchronous or not. If you implement your own method of returning a coroutine, ensure you use <code>asgiref.sync.markcoroutinefunction</code> so this function returns <code>True</code>.</p> </div> <p>Under a WSGI server, async views will run in their own, one-off event loop. This means you can use async features, like concurrent async HTTP requests, without any issues, but you will not get the benefits of an async stack.</p> <p>The main benefits are the ability to service hundreds of connections without using Python threads. This allows you to use slow streaming, long-polling, and other exciting response types.</p> <p>If you want to use these, you will need to deploy Django using <a class="reference internal" href="../howto/deployment/asgi/index.html"><span class="doc">ASGI</span></a> instead.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p>You will only get the benefits of a fully-asynchronous request stack if you have <em>no synchronous middleware</em> loaded into your site. If there is a piece of synchronous middleware, then Django must use a thread per request to safely emulate a synchronous environment for it.</p> <p class="last">Middleware can be built to support <a class="reference internal" href="http/middleware#async-middleware"><span class="std std-ref">both sync and async</span></a> contexts. Some of Django’s middleware is built like this, but not all. To see what middleware Django has to adapt for, you can turn on debug logging for the <code>django.request</code> logger and look for log messages about <em>“Asynchronous handler adapted for middleware …”</em>.</p> </div> <p>In both ASGI and WSGI mode, you can still safely use asynchronous support to run code concurrently rather than serially. This is especially handy when dealing with external APIs or data stores.</p> <p>If you want to call a part of Django that is still synchronous, you will need to wrap it in a <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> call. For example:</p> <pre data-language="python">from asgiref.sync import sync_to_async

results = await sync_to_async(sync_function, thread_sensitive=True)(pk=123)
</pre> <p>If you accidentally try to call a part of Django that is synchronous-only from an async view, you will trigger Django’s <a class="reference internal" href="#async-safety"><span class="std std-ref">asynchronous safety protection</span></a> to protect your data from corruption.</p>  <h3 id="decorators">Decorators</h3> <div class="versionadded" id="s-decorators"> <span class="title">New in Django 5.0.</span> </div> <p>The following decorators can be used with both synchronous and asynchronous view functions:</p> <ul class="simple"> <li><a class="reference internal" href="http/decorators#django.views.decorators.cache.cache_control" title="django.views.decorators.cache.cache_control"><code>cache_control()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.cache.never_cache" title="django.views.decorators.cache.never_cache"><code>never_cache()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.common.no_append_slash" title="django.views.decorators.common.no_append_slash"><code>no_append_slash()</code></a></li> <li><a class="reference internal" href="../ref/csrf.html#django.views.decorators.csrf.csrf_exempt" title="django.views.decorators.csrf.csrf_exempt"><code>csrf_exempt()</code></a></li> <li><a class="reference internal" href="../ref/csrf.html#django.views.decorators.csrf.csrf_protect" title="django.views.decorators.csrf.csrf_protect"><code>csrf_protect()</code></a></li> <li><a class="reference internal" href="../ref/csrf.html#django.views.decorators.csrf.ensure_csrf_cookie" title="django.views.decorators.csrf.ensure_csrf_cookie"><code>ensure_csrf_cookie()</code></a></li> <li><a class="reference internal" href="../ref/csrf.html#django.views.decorators.csrf.requires_csrf_token" title="django.views.decorators.csrf.requires_csrf_token"><code>requires_csrf_token()</code></a></li> <li><a class="reference internal" href="../howto/error-reporting.html#django.views.decorators.debug.sensitive_variables" title="django.views.decorators.debug.sensitive_variables"><code>sensitive_variables()</code></a></li> <li><a class="reference internal" href="../howto/error-reporting.html#django.views.decorators.debug.sensitive_post_parameters" title="django.views.decorators.debug.sensitive_post_parameters"><code>sensitive_post_parameters()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.gzip.gzip_page" title="django.views.decorators.gzip.gzip_page"><code>gzip_page()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.condition" title="django.views.decorators.http.condition"><code>condition()</code></a></li> <li><code>conditional_page()</code></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.etag" title="django.views.decorators.http.etag"><code>etag()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.last_modified" title="django.views.decorators.http.last_modified"><code>last_modified()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.require_http_methods" title="django.views.decorators.http.require_http_methods"><code>require_http_methods()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.require_GET" title="django.views.decorators.http.require_GET"><code>require_GET()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.require_POST" title="django.views.decorators.http.require_POST"><code>require_POST()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.http.require_safe" title="django.views.decorators.http.require_safe"><code>require_safe()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.vary.vary_on_cookie" title="django.views.decorators.vary.vary_on_cookie"><code>vary_on_cookie()</code></a></li> <li><a class="reference internal" href="http/decorators#django.views.decorators.vary.vary_on_headers" title="django.views.decorators.vary.vary_on_headers"><code>vary_on_headers()</code></a></li> <li><code>xframe_options_deny()</code></li> <li><code>xframe_options_sameorigin()</code></li> <li><code>xframe_options_exempt()</code></li> </ul> <p>For example:</p> <pre data-language="python">from django.views.decorators.cache import never_cache


@never_cache
def my_sync_view(request): ...


@never_cache
async def my_async_view(request): ...
</pre>   <h3 id="queries-the-orm">Queries &amp; the ORM</h3> <p id="s-queries-the-orm">With some exceptions, Django can run ORM queries asynchronously as well:</p> <pre data-language="python">async for author in Author.objects.filter(name__startswith="A"):
    book = await author.books.afirst()
</pre> <p>Detailed notes can be found in <a class="reference internal" href="db/queries.html#async-queries"><span class="std std-ref">Asynchronous queries</span></a>, but in short:</p> <ul class="simple"> <li>All <code>QuerySet</code> methods that cause an SQL query to occur have an <code>a</code>-prefixed asynchronous variant.</li> <li>
<code>async for</code> is supported on all QuerySets (including the output of <code>values()</code> and <code>values_list()</code>.)</li> </ul> <p>Django also supports some asynchronous model methods that use the database:</p> <pre data-language="python">async def make_book(*args, **kwargs):
    book = Book(...)
    await book.asave(using="secondary")


async def make_book_with_tags(tags, *args, **kwargs):
    book = await Book.objects.acreate(...)
    await book.tags.aset(tags)
</pre> <p>Transactions do not yet work in async mode. If you have a piece of code that needs transactions behavior, we recommend you write that piece as a single synchronous function and call it using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a>.</p>   <h3 id="async-performance">Performance</h3> <p id="s-performance">When running in a mode that does not match the view (e.g. an async view under WSGI, or a traditional sync view under ASGI), Django must emulate the other call style to allow your code to run. This context-switch causes a small performance penalty of around a millisecond.</p> <p>This is also true of middleware. Django will attempt to minimize the number of context-switches between sync and async. If you have an ASGI server, but all your middleware and views are synchronous, it will switch just once, before it enters the middleware stack.</p> <p>However, if you put synchronous middleware between an ASGI server and an asynchronous view, it will have to switch into sync mode for the middleware and then back to async mode for the view. Django will also hold the sync thread open for middleware exception propagation. This may not be noticeable at first, but adding this penalty of one thread per request can remove any async performance advantage.</p> <p>You should do your own performance testing to see what effect ASGI versus WSGI has on your code. In some cases, there may be a performance increase even for a purely synchronous codebase under ASGI because the request-handling code is still all running asynchronously. In general you will only want to enable ASGI mode if you have asynchronous code in your project.</p>   <h3 id="async-handling-disconnect">Handling disconnects</h3> <div class="versionadded" id="s-handling-disconnects"> <span class="title">New in Django 5.0.</span> </div> <p>For long-lived requests, a client may disconnect before the view returns a response. In this case, an <code>asyncio.CancelledError</code> will be raised in the view. You can catch this error and handle it if you need to perform any cleanup:</p> <pre data-language="python">async def my_view(request):
    try:
        # Do some work
        ...
    except asyncio.CancelledError:
        # Handle disconnect
        raise
</pre> <p>You can also <a class="reference internal" href="../ref/request-response.html#request-response-streaming-disconnect"><span class="std std-ref">handle client disconnects in streaming responses</span></a>.</p>    <h2 id="id1">Async safety</h2> <dl class="std envvar" id="s-async-safety"> <dt class="sig sig-object std" id="envvar-DJANGO_ALLOW_ASYNC_UNSAFE">
<code>DJANGO_ALLOW_ASYNC_UNSAFE</code> </dt> 
</dl> <p>Certain key parts of Django are not able to operate safely in an async environment, as they have global state that is not coroutine-aware. These parts of Django are classified as “async-unsafe”, and are protected from execution in an async environment. The ORM is the main example, but there are other parts that are also protected in this way.</p> <p>If you try to run any of these parts from a thread where there is a <em>running event loop</em>, you will get a <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.SynchronousOnlyOperation" title="django.core.exceptions.SynchronousOnlyOperation"><code>SynchronousOnlyOperation</code></a> error. Note that you don’t have to be inside an async function directly to have this error occur. If you have called a sync function directly from an async function, without using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> or similar, then it can also occur. This is because your code is still running in a thread with an active event loop, even though it may not be declared as async code.</p> <p>If you encounter this error, you should fix your code to not call the offending code from an async context. Instead, write your code that talks to async-unsafe functions in its own, sync function, and call that using <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>asgiref.sync.sync_to_async()</code></a> (or any other way of running sync code in its own thread).</p> <p>The async context can be imposed upon you by the environment in which you are running your Django code. For example, <a class="reference external" href="https://jupyter.org/">Jupyter</a> notebooks and <a class="reference external" href="https://ipython.org">IPython</a> interactive shells both transparently provide an active event loop so that it is easier to interact with asynchronous APIs.</p> <p>If you’re using an IPython shell, you can disable this event loop by running:</p> <pre data-language="shell">%autoawait off
</pre> <p>as a command at the IPython prompt. This will allow you to run synchronous code without generating <a class="reference internal" href="../ref/exceptions.html#django.core.exceptions.SynchronousOnlyOperation" title="django.core.exceptions.SynchronousOnlyOperation"><code>SynchronousOnlyOperation</code></a> errors; however, you also won’t be able to <code>await</code> asynchronous APIs. To turn the event loop back on, run:</p> <pre data-language="shell">%autoawait on
</pre> <p>If you’re in an environment other than IPython (or you can’t turn off <code>autoawait</code> in IPython for some reason), you are <em>certain</em> there is no chance of your code being run concurrently, and you <em>absolutely</em> need to run your sync code from an async context, then you can disable the warning by setting the <a class="reference internal" href="#envvar-DJANGO_ALLOW_ASYNC_UNSAFE" id="index-0"><code>DJANGO_ALLOW_ASYNC_UNSAFE</code></a> environment variable to any value.</p> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">If you enable this option and there is concurrent access to the async-unsafe parts of Django, you may suffer data loss or corruption. Be very careful and do not use this in production environments.</p> </div> <p>If you need to do this from within Python, do that with <code>os.environ</code>:</p> <pre data-language="python">import os

os.environ["DJANGO_ALLOW_ASYNC_UNSAFE"] = "true"
</pre>   <h2 id="async-adapter-functions">Async adapter functions</h2> <p id="s-async-adapter-functions">It is necessary to adapt the calling style when calling sync code from an async context, or vice-versa. For this there are two adapter functions, from the <code>asgiref.sync</code> module: <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> and <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a>. They are used to transition between the calling styles while preserving compatibility.</p> <p>These adapter functions are widely used in Django. The <a class="reference external" href="https://pypi.org/project/asgiref/">asgiref</a> package itself is part of the Django project, and it is automatically installed as a dependency when you install Django with <code>pip</code>.</p>  <h3 id="async-to-sync"><code>async_to_sync()</code></h3> <dl class="py function" id="s-async-to-sync"> <dt class="sig sig-object py" id="asgiref.sync.async_to_sync">
<code>async_to_sync(async_function, force_new_loop=False)</code> </dt> 
</dl> <p>Takes an async function and returns a sync function that wraps it. Can be used as either a direct wrapper or a decorator:</p> <pre data-language="python">from asgiref.sync import async_to_sync


async def get_data(): ...


sync_get_data = async_to_sync(get_data)


@async_to_sync
async def get_other_data(): ...
</pre> <p>The async function is run in the event loop for the current thread, if one is present. If there is no current event loop, a new event loop is spun up specifically for the single async invocation and shut down again once it completes. In either situation, the async function will execute on a different thread to the calling code.</p> <p>Threadlocals and contextvars values are preserved across the boundary in both directions.</p> <p><a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> is essentially a more powerful version of the <a class="reference external" href="https://docs.python.org/3/library/asyncio-runner.html#asyncio.run" title="(in Python v3.12)"><code>asyncio.run()</code></a> function in Python’s standard library. As well as ensuring threadlocals work, it also enables the <code>thread_sensitive</code> mode of <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> when that wrapper is used below it.</p>   <h3 id="sync-to-async"><code>sync_to_async()</code></h3> <dl class="py function" id="s-sync-to-async"> <dt class="sig sig-object py" id="asgiref.sync.sync_to_async">
<code>sync_to_async(sync_function, thread_sensitive=True)</code> </dt> 
</dl> <p>Takes a sync function and returns an async function that wraps it. Can be used as either a direct wrapper or a decorator:</p> <pre data-language="python">from asgiref.sync import sync_to_async

async_function = sync_to_async(sync_function, thread_sensitive=False)
async_function = sync_to_async(sensitive_sync_function, thread_sensitive=True)


@sync_to_async
def sync_function(): ...
</pre> <p>Threadlocals and contextvars values are preserved across the boundary in both directions.</p> <p>Sync functions tend to be written assuming they all run in the main thread, so <a class="reference internal" href="#asgiref.sync.sync_to_async" title="asgiref.sync.sync_to_async"><code>sync_to_async()</code></a> has two threading modes:</p> <ul class="simple"> <li>
<code>thread_sensitive=True</code> (the default): the sync function will run in the same thread as all other <code>thread_sensitive</code> functions. This will be the main thread, if the main thread is synchronous and you are using the <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> wrapper.</li> <li>
<code>thread_sensitive=False</code>: the sync function will run in a brand new thread which is then closed once the invocation completes.</li> </ul> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last"><code>asgiref</code> version 3.3.0 changed the default value of the <code>thread_sensitive</code> parameter to <code>True</code>. This is a safer default, and in many cases interacting with Django the correct value, but be sure to evaluate uses of <code>sync_to_async()</code> if updating <code>asgiref</code> from a prior version.</p> </div> <p>Thread-sensitive mode is quite special, and does a lot of work to run all functions in the same thread. Note, though, that it <em>relies on usage of</em> <a class="reference internal" href="#asgiref.sync.async_to_sync" title="asgiref.sync.async_to_sync"><code>async_to_sync()</code></a> <em>above it in the stack</em> to correctly run things on the main thread. If you use <code>asyncio.run()</code> or similar, it will fall back to running thread-sensitive functions in a single, shared thread, but this will not be the main thread.</p> <p>The reason this is needed in Django is that many libraries, specifically database adapters, require that they are accessed in the same thread that they were created in. Also a lot of existing Django code assumes it all runs in the same thread, e.g. middleware adding things to a request for later use in views.</p> <p>Rather than introduce potential compatibility issues with this code, we instead opted to add this mode so that all existing Django sync code runs in the same thread and thus is fully compatible with async mode. Note that sync code will always be in a <em>different</em> thread to any async code that is calling it, so you should avoid passing raw database handles or other thread-sensitive references around.</p> <p>In practice this restriction means that you should not pass features of the database <code>connection</code> object when calling <code>sync_to_async()</code>. Doing so will trigger the thread safety checks:</p> <pre data-language="pycon"># DJANGO_SETTINGS_MODULE=settings.py python -m asyncio
&gt;&gt;&gt; import asyncio
&gt;&gt;&gt; from asgiref.sync import sync_to_async
&gt;&gt;&gt; from django.db import connection
&gt;&gt;&gt; # In an async context so you cannot use the database directly:
&gt;&gt;&gt; connection.cursor()
django.core.exceptions.SynchronousOnlyOperation: You cannot call this from
an async context - use a thread or sync_to_async.
&gt;&gt;&gt; # Nor can you pass resolved connection attributes across threads:
&gt;&gt;&gt; await sync_to_async(connection.cursor)()
django.db.utils.DatabaseError: DatabaseWrapper objects created in a thread
can only be used in that same thread. The object with alias 'default' was
created in thread id 4371465600 and this is thread id 6131478528.
</pre> <p>Rather, you should encapsulate all database access within a helper function that can be called with <code>sync_to_async()</code> without relying on the connection object in the calling code.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Django Software Foundation and individual contributors<br>Licensed under the BSD License.<br>
    <a href="https://docs.djangoproject.com/en/5.1/topics/async/" class="_attribution-link">https://docs.djangoproject.com/en/5.1/topics/async/</a>
  </p>
</div>
