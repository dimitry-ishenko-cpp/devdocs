<header><h1>Plug'n'Play</h1></header><h2 class="anchor anchorWithStickyNavbar_ATBP" id="what-is-yarn-plugnplay">What is Yarn Plug'n'Play?<a class="hash-link" aria-label="Direct link to What is Yarn Plug'n'Play?" title="Direct link to What is Yarn Plug'n'Play?" href="pnp.html#what-is-yarn-plugnplay">​</a>
</h2> <p>Yarn Plug'n'Play (generally referred to as Yarn PnP) is the default installation strategy in modern releases of Yarn. It can be swapped out for more traditional approaches (including <code>node_modules</code> installs, or pnpm-style symlink-based approaches), but we recommend it when creating new projects due to its numerous improvements.</p> <h2 class="anchor anchorWithStickyNavbar_ATBP" id="how-does-it-work">How does it work?<a class="hash-link" aria-label="Direct link to How does it work?" title="Direct link to How does it work?" href="pnp.html#how-does-it-work">​</a>
</h2> <p>If you look into the files in your project, you may notice the absence of a <code>node_modules</code> folder. This is unusual! We regularly get asked on Discord where the folder is, by people thinking <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Install the project dependencies
" href="../cli/install.html"><span class="token_Ye2a" data-type="path">install</span></a></code></span> silently failed.</p> <p>The thing is, this is actually expected! The way Yarn PnP works, it tells Yarn to generate a single Node.js loader file in place of the typical <code>node_modules</code> folder. This loader file, named <code>.pnp.cjs</code>, contains all information about your project's dependency tree, informing your tools as to the location of the packages on the disk and letting them know how to resolve require and import calls.</p> <h2 class="anchor anchorWithStickyNavbar_ATBP" id="what-are-the-advantages">What are the advantages?<a class="hash-link" aria-label="Direct link to What are the advantages?" title="Direct link to What are the advantages?" href="pnp.html#what-are-the-advantages">​</a>
</h2> <p>Yarn PnP addresses various problems. It would be possible to address <em>some</em> of them via smarter <code>node_modules</code> layout algorithms (that's for example what the pnpm-style symlink-based install strategy attempts to do), but PnP is the only strategy that can address them all:</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="minimal-install-footprint">Minimal install footprint<a class="hash-link" aria-label="Direct link to Minimal install footprint" title="Direct link to Minimal install footprint" href="pnp.html#minimal-install-footprint">​</a>
</h3> <p>A Yarn PnP install typically does one thing: generate the Node.js loader file (<code>.pnp.cjs</code>). In other package managers, a significant portion of the time is spent performing I/O operations to copy files from one location to another, be it on disk like npm, or via symlinks / hardlinks like pnpm.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="shared-installs-across-disks">Shared installs across disks<a class="hash-link" aria-label="Direct link to Shared installs across disks" title="Direct link to Shared installs across disks" href="pnp.html#shared-installs-across-disks">​</a>
</h3> <p>Related to the previous point, Yarn PnP allows to reuse the same package artifacts across all projects on the disk. Unlike pnpm, which uses a content-addressable store where each file from each package needs to be hardlinked into its final destination, the PnP loader directly references packages via their cache path, removing a lot of complexity.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="perfect-and-correct-hoisting">Perfect and correct hoisting<a class="hash-link" aria-label="Direct link to Perfect and correct hoisting" title="Direct link to Perfect and correct hoisting" href="pnp.html#perfect-and-correct-hoisting">​</a>
</h3> <p>Typical <code>node_modules</code> installs attempt to optimize the resulting <code>node_modules</code> size by hoisting packages, at the cost of higher risks of ghost dependencies. Unfortunately, even these optimizations have limits! Some dependency patterns prevent safe hoisting, leading to package duplication and multiple instantiations.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="ghost-dependencies-protection">Ghost dependencies protection<a class="hash-link" aria-label="Direct link to Ghost dependencies protection" title="Direct link to Ghost dependencies protection" href="pnp.html#ghost-dependencies-protection">​</a>
</h3> <p>Because Yarn keeps a list of all packages and their dependencies, it can prevent accesses to dependencies unaccounted for during resolution, giving you the ability to quickly identify and fix those problems before they get deep into your codebase and jeopardize the stability of your application at deploy time.</p> <div class="theme-admonition theme-admonition-info admonition_JrWa alert alert--info">
<div class="admonitionHeading_MtRg">
info</div>
<div class="admonitionContent_G2Ck">
<p>This is sometimes mentioned as a challenge to adopting Yarn PnP. It means errors may be reported when other package managers would seem to work out of the box - that is, until strange breakages start happening as you add, upgrade, or remove unrelated dependencies.</p>
<p>While it does add a bit of friction, it's a critical part of what makes Yarn a <strong>very</strong> stable package manager. An application that works today won't suddenly break in the future, and your colleagues won't face seemingly random issues long after your PRs got merged.</p>
</div>
</div> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="semantic-erroring">Semantic erroring<a class="hash-link" aria-label="Direct link to Semantic erroring" title="Direct link to Semantic erroring" href="pnp.html#semantic-erroring">​</a>
</h3> <p>You may never have noticed it, but when a Node.js import or require call is invalid, you only get a generic error in return, that doesn't really tell you what's the problem or how to address it:</p> <div class="codeBlockContainer_EXcq theme-code-block"><div class="codeBlockContent_gO9Y">
<pre tabindex="0" class="prism-code language-text codeBlock_itEV thin-scrollbar" data-language="text">Uncaught Error: Cannot find module 'not-found'</pre>

</div></div> <p>Yarn PnP not only tells you exactly <em>what</em> the problem is, but also which packages are involved. For example, the two following error messages may be emitted depending on the circumstances:</p> <div class="codeBlockContainer_EXcq theme-code-block"><div class="codeBlockContent_gO9Y">
<pre tabindex="0" class="prism-code language-text codeBlock_itEV thin-scrollbar" data-language="text">Error: Your application tried to access not-found, but it isn't declared in your dependencies; this makes the require call ambiguous and unsound.

Required package: not-found
Required by: /path/to/my-project/</pre>

</div></div> <div class="codeBlockContainer_EXcq theme-code-block"><div class="codeBlockContent_gO9Y">
<pre tabindex="0" class="prism-code language-text codeBlock_itEV thin-scrollbar" data-language="text">Error: awesome-plugin tried to access awesome-core (a peer dependency) but it isn't provided by its ancestors; this makes the require call ambiguous and unsound.

Required package: awesome-plugin
Required by: awesome-core

Ancestor breaking the chain: awesome-template</pre>

</div></div> <p>Semantic erroring goes a long way into letting you understand and address problems caused by your dependencies.</p> <h2 class="anchor anchorWithStickyNavbar_ATBP" id="is-it-difficult-to-use">Is it difficult to use?<a class="hash-link" aria-label="Direct link to Is it difficult to use?" title="Direct link to Is it difficult to use?" href="pnp.html#is-it-difficult-to-use">​</a>
</h2> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="when-creating-a-new-project">When creating a new project<a class="hash-link" aria-label="Direct link to When creating a new project" title="Direct link to When creating a new project" href="pnp.html#when-creating-a-new-project">​</a>
</h3> <p>If you're creating a project from scratch, your project itself should work almost "out of the box". You may have to use <code data-tooltip-id="tooltip" data-tooltip-content="Extend the package definitions of your dependencies; useful to fix third-party issues."><a class="key_FEvO" href="../configuration/yarnrc.html#packageExtensions">packageExtensions</a></code> from time to time to fix an occasional ghost dependency, but that remains uncommon, and this process is otherwise straightforward. Most tools in the ecosystem are designed and tested to work well in Yarn PnP environments, so problems are infrequent.</p> <div class="theme-admonition theme-admonition-danger admonition_JrWa alert alert--danger">
<div class="admonitionHeading_MtRg">
danger</div>
<div class="admonitionContent_G2Ck"><p>A notable exception is React Native / Expo, which require using typical <code>node_modules</code> installs.</p></div>
</div> <p>Really, the main problem you will face will be around IDE integrations. All IDEs have some level of support for Yarn PnP, but in general you should expect having to follow one of the procedures from this guide to make sure all your imports are properly resolved.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="when-migrating-an-existing-project">When migrating an existing project<a class="hash-link" aria-label="Direct link to When migrating an existing project" title="Direct link to When migrating an existing project" href="pnp.html#when-migrating-an-existing-project">​</a>
</h3> <div class="theme-admonition theme-admonition-info admonition_JrWa alert alert--info">
<div class="admonitionHeading_MtRg">
info</div>
<div class="admonitionContent_G2Ck"><p>Running <span class="inline_hdsZ"><code><span class="token_Ye2a" data-type="binary">yarn</span> <a class="path_tCL7" data-tooltip-id="tooltip" data-tooltip-content="Install the project dependencies
" href="../cli/install.html"><span class="token_Ye2a" data-type="path">install</span></a></code></span> in a project which used to be installed by Yarn Classic will cause Yarn PnP to be automatically disabled, to make the migration smoother. You'll still benefit from the enhanced stability and other features implemented in modern releases, and can decide whether to spend the time to migrate to PnP or not at a later time.</p></div>
</div> <p>Existing projects can be tougher to migrate to Yarn PnP for a couple of reasons:</p> <ul> <li>You already start with a lot of dependencies, so there'll be a proportionally higher amount of packages that may list ghost dependencies</li> <li>They may be locked on old versions of their respective packages, and thus have a higher chance to contain ghost dependencies</li> <li>Your own scripts may inadvertently rely on some implementation details or ghost dependencies, sometimes even without you realizing it.</li> </ul> <p>None of these are blockers, but they mean it can take a couple of days to migrate an existing project to Yarn PnP. We however provide tools to simplify some of this process, and taking a look at the footguns below will help you identify quicker what way cause something to break, so it's not impossible.</p> <p>Remember that migrating to Yarn PnP is optional: you can revert to <code>node_modules</code> installs at any time by setting the <code data-tooltip-id="tooltip" data-tooltip-content="Define how Node packages should be installed."><a class="key_FEvO" href="../configuration/yarnrc.html#nodeLinker">nodeLinker</a><span class="assign_Ad7a">:</span> <span class="value_jT9z">node-modules</span></code> setting in your project's <code>.yarnrc.yml</code> file.</p> <h2 class="anchor anchorWithStickyNavbar_ATBP" id="footguns">Footguns<a class="hash-link" aria-label="Direct link to Footguns" title="Direct link to Footguns" href="pnp.html#footguns">​</a>
</h2> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="peer-dependencies">Peer dependencies<a class="hash-link" aria-label="Direct link to Peer dependencies" title="Direct link to Peer dependencies" href="pnp.html#peer-dependencies">​</a>
</h3> <p>Peer dependencies are powerful, but are very difficult to implement - even more so for non-PnP projects, which have to work within the limits of what the filesystem hierarchy allows.</p> <p>Yarn PnP, on the other hand, doesn't have this limitation, and will accurately represent the peer dependencies of every project in your dependency tree - even workspaces. If a workspace has a peer dependency, and if this dependency is fulfilled by different versions depending on its grandparent, then the workspace will instantiated twice, once for each unique "dependency set".</p> <p>This is the correct behaviour, but it may cause an accidental explosion of the number of instantiated workspaces if your project heavily uses peer dependencies without ensuring they are always fulfilled by the exact same versions.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="shared-binaries">Shared binaries<a class="hash-link" aria-label="Direct link to Shared binaries" title="Direct link to Shared binaries" href="pnp.html#shared-binaries">​</a>
</h3> <p>Yarn prevents ghost dependencies in the packages your project depends on, but also in your own code itself - this is to decrease the chances that a package would work on your development machine but break once published.</p> <p>It however has a side effect when it comes to bins. If you have <code>typescript</code> listed at the root of your project, the <code>tsc</code> binary will be available in the root package <em>but only in the root project</em>. In other words, any workspace using the <code>tsc</code> binary in its scripts will need to declare it in its dependencies.</p> <p>A good recommendation to avoid this kind of issue is to have a "tooling" workspace to contain your infrastructure tools and scripts, and have all other workspaces depend on it.</p> <h2 class="anchor anchorWithStickyNavbar_ATBP" id="frequently-asked-questions">Frequently asked questions<a class="hash-link" aria-label="Direct link to Frequently asked questions" title="Direct link to Frequently asked questions" href="pnp.html#frequently-asked-questions">​</a>
</h2> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="compatibility-with-npm--pnpm">Compatibility with npm / pnpm<a class="hash-link" aria-label="Direct link to Compatibility with npm / pnpm" title="Direct link to Compatibility with npm / pnpm" href="pnp.html#compatibility-with-npm--pnpm">​</a>
</h3> <p>Yarn PnP was designed to use the exact same "public interfaces" as other package managers, with differences being kept to what already were implementation details. If a project works with Yarn PnP, it should work everywhere!</p> <p>One caveat though: the opposite isn't always true. Since other package managers don't / can't enforce proper listing of dependencies, they are more vulnerable to shipping ghost dependencies by accident to their consumers. In that way, using Yarn PnP can be seen as a good practice for the health of the ecosystem! 🙂</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="how-can-i-fix-ghost-dependencies">How can I fix ghost dependencies?<a class="hash-link" aria-label="Direct link to How can I fix ghost dependencies?" title="Direct link to How can I fix ghost dependencies?" href="pnp.html#how-can-i-fix-ghost-dependencies">​</a>
</h3> <p>Ghost dependencies can be solved using the <code data-tooltip-id="tooltip" data-tooltip-content="Extend the package definitions of your dependencies; useful to fix third-party issues."><a class="key_FEvO" href="../configuration/yarnrc.html#packageExtensions">packageExtensions</a></code> setting, which allows you to add new dependencies to any package in your dependency tree. For example, should you face an error such as <code>@babel/core tried to access @babel/types, but it isn't declared in its dependencies</code>, you can easily fix it by adding the following to your <code>.yarnrc.yml</code> file:</p> <div class="language-yaml codeBlockContainer_EXcq theme-code-block"><div class="codeBlockContent_gO9Y">
<pre tabindex="0" class="prism-code language-yaml codeBlock_itEV thin-scrollbar" data-language="yaml">packageExtensions:
  "@babel/core@*":
    dependencies:
      "@babel/types": "*"</pre>

</div></div> <p>It may sometimes make sense to extend the <code data-tooltip-id="tooltip" data-tooltip-content="Set of dependencies that the package must inherit from its ancestor in the dependency tree."><a class="key_FEvO" href="../configuration/manifest.html#peerDependencies">peerDependencies</a></code> field rather the <code data-tooltip-id="tooltip" data-tooltip-content="Set of dependencies that must be made available to the current package in order for it to work properly."><a class="key_FEvO" href="../configuration/manifest.html#dependencies">dependencies</a></code> field, this is to be addressed case-by-case.</p> <div class="theme-admonition theme-admonition-tip admonition_JrWa alert alert--success">
<div class="admonitionHeading_MtRg">
tip</div>
<div class="admonitionContent_G2Ck"><p>To avoid you having to add too many <code data-tooltip-id="tooltip" data-tooltip-content="Extend the package definitions of your dependencies; useful to fix third-party issues."><a class="key_FEvO" href="../configuration/yarnrc.html#packageExtensions">packageExtensions</a></code> entries, the Yarn team maintains a list of <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-extensions/sources/index.ts" target="_blank" rel="noopener noreferrer">known ghost dependencies in the ecosystem</a> that we automatically fix. This list is used by both Yarn and pnpm, and we're more than happy to merge contributions there.</p></div>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/features/pnp" class="_attribution-link">https://yarnpkg.com/features/pnp</a>
  </p>
</div>
