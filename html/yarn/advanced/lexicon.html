<header><h1>Lexicon</h1></header><h3 class="anchor anchorWithStickyNavbar_ATBP" id="build-scripts">Build Scripts<a class="hash-link" aria-label="Direct link to Build Scripts" title="Direct link to Build Scripts" href="lexicon.html#build-scripts">​</a>
</h3> <p>Refers to tasks executed right after the packages got installed; typically the <code>postinstall</code> scripts configured in the <code data-tooltip-id="tooltip" data-tooltip-content="Set of scripts to expose via `yarn run script-name`, or as lifecycle hooks."><a class="key_FEvO" href="../configuration/manifest.html#scripts">scripts</a></code> field from the manifest.</p> <p>Build scripts should be left to native dependencies, there is virtually no reason for pure JavaScript packages to use them. They have <a href="lifecycle-scripts.html#a-note-about-postinstall">significant side effects</a> on your user's projects, so weight carefully whether you really need them.</p> <p>See also: <a href="lifecycle-scripts.html">Lifecycle Scripts</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="dependency">Dependency<a class="hash-link" aria-label="Direct link to Dependency" title="Direct link to Dependency" href="lexicon.html#dependency">​</a>
</h3> <p>A dependency (listed in the <code data-tooltip-id="tooltip" data-tooltip-content="Set of dependencies that must be made available to the current package in order for it to work properly."><a class="key_FEvO" href="../configuration/manifest.html#dependencies">dependencies</a></code> field of the manifest) describes a relationship between two packages.</p> <p>When a package A has a dependency B, Yarn guarantees that A will be able to access B if the install is successful. Note that this is the only promise we make regarding regular dependencies: in particular, there is no guarantee that package B will be the same version than the one used in other parts of the application.</p> <p>See also: <a href="lexicon.html#development-dependency">Development Dependency</a>, <a href="lexicon.html#peer-dependency">Peer Dependency</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="descriptor">Descriptor<a class="hash-link" aria-label="Direct link to Descriptor" title="Direct link to Descriptor" href="lexicon.html#descriptor">​</a>
</h3> <p>A descriptor is a combination of a package name (for example <code>lodash</code>) and a package <abbr>range</abbr> (for example <code>^1.0.0</code>). Descriptors are used to identify a set of packages rather than one unique package.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="development-dependency">Development Dependency<a class="hash-link" aria-label="Direct link to Development Dependency" title="Direct link to Development Dependency" href="lexicon.html#development-dependency">​</a>
</h3> <p>A dependency (listed in the <code data-tooltip-id="tooltip" data-tooltip-content="Set of dependencies that must be made available to the current package in order for it to work properly as a workspace."><a class="key_FEvO" href="../configuration/manifest.html#devDependencies">devDependencies</a></code> field of the manifest) describes a relationship between two packages.</p> <p>Development dependencies are very much like regular dependencies except that they only matter for local packages. Packages fetched from remote registries such as npm will not be able to access their development dependencies, but packages installed from local sources (such as <a href="lexicon.html#workspaces">workspaces</a> or the <a href="lexicon.html#portals"><code>portal:</code> protocol</a>) will.</p> <p>See also: <a href="lexicon.html#dependency">Dependency</a>, <a href="lexicon.html#peer-dependency">Peer Dependency</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="fetcher">Fetcher<a class="hash-link" aria-label="Direct link to Fetcher" title="Direct link to Fetcher" href="lexicon.html#fetcher">​</a>
</h3> <p>Fetchers are the components tasked with extracting the full package data from a <abbr>reference</abbr>. For example, the npm fetcher would download the package tarballs from the npm registry.</p> <p>See also: <a href="architecture.html">Architecture</a>, <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Fetcher.ts#L34" target="_blank" rel="noopener noreferrer">Fetcher interface</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="hoisting">Hoisting<a class="hash-link" aria-label="Direct link to Hoisting" title="Direct link to Hoisting" href="lexicon.html#hoisting">​</a>
</h3> <p>Hoisting is the act of transforming the dependency tree to optimize it by removing as many nodes as possible. There isn't a single way to decide how to transform the tree, and different package managers make different tradeoffs (some optimize for package popularity, package size, highest versions, ...). For this reason, no guarantee can be made regarding the final hoisting layout - except that packages will always be able to access the dependencies they listed in their <a href="lexicon.html#Manifest">manifests</a>.</p> <p>Because the hoisting is heavily connected to the filesystem and the Node resolution, its very design makes it easy to make an error and accidentally access packages without them being properly defined as dependencies - and thus without being accounted for during the hoisting process, making their very existence unpredictable. For this reason and others, hoisting got sidelined starting from Yarn 2 in favour of the <a href="lexicon.html#plugnplay">Plug'n'Play resolution</a>.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="linker">Linker<a class="hash-link" aria-label="Direct link to Linker" title="Direct link to Linker" href="lexicon.html#linker">​</a>
</h3> <p>Linkers are the components that consume both a dependency tree and a store of package data, and generate in return disk artifacts specific to the environment they target. For example, the <abbr>Plug'n'Play</abbr> linker generates a single <code>.pnp.cjs</code> file.</p> <p>See also: <a href="architecture.html">Architecture</a>, <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Installer.ts#L18" target="_blank" rel="noopener noreferrer">Installer interface</a>, <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Linker.ts#L28" target="_blank" rel="noopener noreferrer">Linker interface</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="local-cache">Local Cache<a class="hash-link" aria-label="Direct link to Local Cache" title="Direct link to Local Cache" href="lexicon.html#local-cache">​</a>
</h3> <p>The local cache, or offline mirror, is a way to protect your project against the package registry going down.</p> <p>When the local cache is enabled, Yarn generates a copy of all packages you install in the <code>.yarn/cache</code> folder that you can then add to your repository. Subsequent installs will then reuse packages from this folder rather than downloading them anew.</p> <p>While not always practical (it causes the repository size to grow, although we have ways to mitigate it significantly), it presents various interesting properties:</p> <ul> <li>It doesn't require additional infrastructure, such as a <a href="https://verdaccio.org/" target="_blank" rel="noopener noreferrer">Verdaccio proxy</a>
</li> <li>It doesn't require additional configuration, such as registry authentication</li> <li>The install fetch step is as fast as it can be, with no data transfer at all</li> <li>It lets you reach <a href="../features/caching.html#zero-installs">zero-installs</a> if you also use the PnP linker</li> </ul> <p>To enable the local cache, set <code data-tooltip-id="tooltip" data-tooltip-content="Define whether the cache should be shared between all local projects."><a class="key_FEvO" href="../configuration/yarnrc.html#enableGlobalCache">enableGlobalCache</a></code> to <code>false</code>, run an install, and add the new artifacts to your repository (you might want to <a href="../getting-started/qa.html#which-files-should-be-gitignored">update your gitignore</a> accordingly).</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="locator">Locator<a class="hash-link" aria-label="Direct link to Locator" title="Direct link to Locator" href="lexicon.html#locator">​</a>
</h3> <p>A locator is a combination of a package name (for example <code>lodash</code>) and a package <abbr>reference</abbr> (for example <code>1.2.3</code>). Locators are used to identify a single unique package (interestingly, all valid locators also are valid <abbr>descriptors</abbr>).</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="manifest">Manifest<a class="hash-link" aria-label="Direct link to Manifest" title="Direct link to Manifest" href="lexicon.html#manifest">​</a>
</h3> <p>The manifest is the file defining the metadata associated to a package (its name, version, dependencies...). In the JavaScript ecosystem, it's the <code>package.json</code> file.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="monorepo">Monorepo<a class="hash-link" aria-label="Direct link to Monorepo" title="Direct link to Monorepo" href="lexicon.html#monorepo">​</a>
</h3> <p>A monorepo is a repository that contains multiple packages. <a href="https://github.com/babel/babel/tree/master/packages" target="_blank" rel="noopener noreferrer">Babel</a>, <a href="https://github.com/facebook/jest/tree/master/packages" target="_blank" rel="noopener noreferrer">Jest</a>, and even <a href="https://github.com/yarnpkg/yarn/tree/master/packages" target="_blank" rel="noopener noreferrer">Yarn itself</a> are examples of such repositories - they each contain dozen of small packages that depend on one another.</p> <p>Yarn provides native support for monorepos via "workspaces". It makes it easy to install the dependencies of multiple local packages by running a single install, and to connect them all together so that they don't have to be published before their changes can be reused by other parts of your project.</p> <p>See also: <a href="../features/workspaces.html">Workspaces (feature)</a>, <a href="lexicon.html#workspace">Workspace (lexicon)</a>.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="package">Package<a class="hash-link" aria-label="Direct link to Package" title="Direct link to Package" href="lexicon.html#package">​</a>
</h3> <p>Packages are nodes of the dependency tree. Simply put, a package is a bundle of source code usually characterized by a <code>package.json</code> at its root. Packages can define <abbr>dependencies</abbr>, which are other packages that need to be made available for it to work properly.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="peer-dependency">Peer Dependency<a class="hash-link" aria-label="Direct link to Peer Dependency" title="Direct link to Peer Dependency" href="lexicon.html#peer-dependency">​</a>
</h3> <p>A dependency (listed in the <code data-tooltip-id="tooltip" data-tooltip-content="Set of dependencies that the package must inherit from its ancestor in the dependency tree."><a class="key_FEvO" href="../configuration/manifest.html#peerDependencies">peerDependencies</a></code> field of the manifest) describes a relationship between two packages.</p> <p>Contrary to regular dependencies, a package A with a peer dependency on B doesn't guarantee that A will be able to access B - it's up to the package that depends on A to manually provide a version of B compatible with request from A. This drawback has a good side too: the package instance of B that A will access is guaranteed to be the exact same one as the one used by the ancestor of A. This matters a lot when B uses <code>instanceof</code> checks or singletons.</p> <p>See also: <a href="lexicon.html#development-dependency">Development Dependency</a>, <a href="lexicon.html#singleton-package">Singleton Package</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="peer-dependent-package">Peer-Dependent Package<a class="hash-link" aria-label="Direct link to Peer-Dependent Package" title="Direct link to Peer-Dependent Package" href="lexicon.html#peer-dependent-package">​</a>
</h3> <p>A peer-dependent package is a package that lists peer dependencies.</p> <p>See also: <a href="lexicon.html#virtual-package">Virtual Packages</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="plugin">Plugin<a class="hash-link" aria-label="Direct link to Plugin" title="Direct link to Plugin" href="lexicon.html#plugin">​</a>
</h3> <p>Plugins are a new concept introduced in Yarn 2+. Through the use of plugins, Yarn can be extended and made even more powerful - whether it's through the addition of new <abbr>resolvers</abbr>, <abbr>fetchers</abbr>, or <abbr>linkers</abbr>.</p> <p>See also: <a href="../features/extensibility.html">Plugins</a>, <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Plugin.ts#L67" target="_blank" rel="noopener noreferrer">Plugin interface</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="plugnplay">Plug'n'Play<a class="hash-link" aria-label="Direct link to Plug'n'Play" title="Direct link to Plug'n'Play" href="lexicon.html#plugnplay">​</a>
</h3> <p>Plug'n'Play is an alternative installation strategy that, instead of generating the typical <code>node_modules</code> directories, generate one single file that is then injected into Node to let it know where to find the installed packages. Starting from the v2, Plug'n'Play becomes the default installation strategy for Javascript projects.</p> <p>See also: <a href="../features/pnp.html">Plug'n'Play</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="pnp">PnP<a class="hash-link" aria-label="Direct link to PnP" title="Direct link to PnP" href="lexicon.html#pnp">​</a>
</h3> <p>See <a href="lexicon.html#plugnplay">Plug'n'Play</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="portal">Portal<a class="hash-link" aria-label="Direct link to Portal" title="Direct link to Portal" href="lexicon.html#portal">​</a>
</h3> <p>A portal is a dependency that uses the <code>portal:</code> protocol, pointing to a package located on the disk.</p> <p>Contrary to the <code>link:</code> protocol (which can point to any location but cannot have dependencies), Yarn will setup its dependency map in such a way that not only will the dependent package be able to access the file referenced through the portal, but the portal itself will also be able to access its own dependencies. Even peer dependencies!</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="project">Project<a class="hash-link" aria-label="Direct link to Project" title="Direct link to Project" href="lexicon.html#project">​</a>
</h3> <p>The term project is used to encompass all the <abbr>worktrees</abbr> that belong to the same dependency tree.</p> <p>See also: <a href="../features/workspaces.html">Workspaces</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="range">Range<a class="hash-link" aria-label="Direct link to Range" title="Direct link to Range" href="lexicon.html#range">​</a>
</h3> <p>A range is a string that, when combined with a package name, can be used to select multiple versions of a single package. Ranges typically follow <abbr>semver</abbr>, but can use any of the supported Yarn protocols.</p> <p>See also: <a href="https://yarnpkg.com/protocols">Protocols</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="reference">Reference<a class="hash-link" aria-label="Direct link to Reference" title="Direct link to Reference" href="lexicon.html#reference">​</a>
</h3> <p>A reference is a string that, when combined with a package name, can be used to select one single version of a single package. References typically follow <abbr>semver</abbr>, but can use any of the supported Yarn protocols.</p> <p>See also: <a href="https://yarnpkg.com/protocols">Protocols</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="resolver">Resolver<a class="hash-link" aria-label="Direct link to Resolver" title="Direct link to Resolver" href="lexicon.html#resolver">​</a>
</h3> <p>Resolvers are the components tasked from converting <abbr>descriptors</abbr> into <abbr>locators</abbr>, and extracting the package <abbr>manifests</abbr> from the package <abbr>locators</abbr>. For example, the npm resolver would check what versions are available on the npm registry and return all the candidates that satisfy the <abbr>semver</abbr> requirements, then would query the npm registry to fetch the full metadata associated with the selected resolution.</p> <p>See also: <a href="architecture.html">Architecture</a>, <a href="https://github.com/yarnpkg/berry/blob/master/packages/yarnpkg-core/sources/Resolver.ts#L45" target="_blank" rel="noopener noreferrer">Resolver interface</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="scope">Scope<a class="hash-link" aria-label="Direct link to Scope" title="Direct link to Scope" href="lexicon.html#scope">​</a>
</h3> <p>Scopes are a term linked inherited from the npm registry; they are used to describe a set of packages that all belong to the same entity. For example, all the Yarn packages related to the v2 belong to the <code>berry</code> scope on the npm registry. Scopes are traditionally prefixed with the <code>@</code> symbol.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="singleton-package">Singleton Package<a class="hash-link" aria-label="Direct link to Singleton Package" title="Direct link to Singleton Package" href="lexicon.html#singleton-package">​</a>
</h3> <p>A singleton package is a package which is instantiated a single time across the dependency tree.</p> <p>While singleton packages aren't a first-class citizen, they can be easily created using <a href="lexicon.html#peer-dependency">peer dependencies</a> by using one of their properties: since packages depended upon by peer dependencies are guaranteed to be the exact same instance as the one used by their direct ancestor, using peer dependencies across the entire dependency branch all the way up to the nearest workspace will ensure that a single instance of the package is ever created - making it a de-facto singleton package.</p> <p>See also: <a href="lexicon.html#peer-dependency">Peer Dependency</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="transitive-dependency">Transitive Dependency<a class="hash-link" aria-label="Direct link to Transitive Dependency" title="Direct link to Transitive Dependency" href="lexicon.html#transitive-dependency">​</a>
</h3> <p>A transitive dependency is a dependency of a package you depend on.</p> <p>Imagine the case of <code>react</code>. Your application depends on it (you listed it yourself in your manifest), so it's a direct dependency. But <code>react</code> also depends on <code>prop-types</code>! That makes <code>prop-types</code> a transitive dependency, in that you don't directly declare it.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="unplugged-package">Unplugged Package<a class="hash-link" aria-label="Direct link to Unplugged Package" title="Direct link to Unplugged Package" href="lexicon.html#unplugged-package">​</a>
</h3> <p>With Yarn PnP, most packages are kept within their zip archives rather than being unpacked on the disk. The archives are then mounted on the filesystem at runtime, and transparently accessed. The mounts are read-only so that the archives don't get corrupted if something tries to write into them.</p> <p>In some cases, however, keeping the package read-only may be difficult (such as when a package lists postinstall scripts - the build steps will often need to generate build artifacts, making read-only folders impractical). For those situations, Yarn can unpack specific packages and keep them into their own individual folders. Such packages are referred to as "unplugged".</p> <p>Packages are unplugged in a few scenarios:</p> <ul> <li>explicitly by setting the <code>dependenciesMeta[].unplugged</code> field to <code>true</code>
</li> <li>explicitly when the package set its <code data-tooltip-id="tooltip" data-tooltip-content="Define whether the package must be unplugged or not."><a class="key_FEvO" href="../configuration/manifest.html#preferUnplugged">preferUnplugged</a></code> field to <code>true</code>
</li> <li>implicitly when the package lists postinstall scripts</li> <li>implicitly when the package contains native files</li> </ul> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="virtual-package">Virtual Package<a class="hash-link" aria-label="Direct link to Virtual Package" title="Direct link to Virtual Package" href="lexicon.html#virtual-package">​</a>
</h3> <p>Because <a href="lexicon.html#peer-dependent-package">peer-dependent packages</a> effectively define an <em>horizon</em> of possible dependency sets rather than a single static set of dependencies, a peer-dependent package may have multiple dependency sets. When this happens, the package will need to be instantiated at least once for each such set.</p> <p>Since in Node-land the JS modules are instantiated based on their path (a file is never instantiated twice for any given path), and since PnP makes it so that packages are installed only once in any given project, the only way to instantiate those packages multiple times is to give them multiple paths while still referencing to the same on-disk location. That's where virtual packages come handy.</p> <p>Virtual packages are specialized instances of the peer-dependent packages that encode the set of dependencies that this particular instance should use. Each virtual package is given a unique filesystem path that ensures that the scripts it references will be instantiated with their proper dependency set.</p> <p>In the past virtual packages were implemented using symlinks, but this recently changed and they are now implemented through a virtual filesystem layer. This circumvents the need to create hundreds of confusing symlinks, improving compatibility with Windows and preventing issues that would arise with third-party tools calling <code>realpath</code>.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="workspace">Workspace<a class="hash-link" aria-label="Direct link to Workspace" title="Direct link to Workspace" href="lexicon.html#workspace">​</a>
</h3> <p>Generally speaking workspaces are a Yarn features used to work on multiple projects stored within the same repository.</p> <p>In the context of Yarn's vocabulary, workspaces are local <abbr>packages</abbr> that directly belong to a <abbr>project</abbr>.</p> <p>See also: <a href="../features/workspaces.html">Workspaces</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="worktree">Worktree<a class="hash-link" aria-label="Direct link to Worktree" title="Direct link to Worktree" href="lexicon.html#worktree">​</a>
</h3> <p>A worktree is a private workspace that adds new child workspaces to the current <abbr>project</abbr>.</p> <p>See also: <a href="../features/workspaces.html">Workspaces</a></p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="yarn">Yarn<a class="hash-link" aria-label="Direct link to Yarn" title="Direct link to Yarn" href="lexicon.html#yarn">​</a>
</h3> <p>Yarn is a command line tool used to manage programming environments. Written in Javascript, it is mostly used along with other Javascript projects but has capabilities that make it suitable to be used in various situations.</p> <h3 class="anchor anchorWithStickyNavbar_ATBP" id="zero-install">Zero-Install<a class="hash-link" aria-label="Direct link to Zero-Install" title="Direct link to Zero-Install" href="lexicon.html#zero-install">​</a>
</h3> <p>See also: <a href="../features/caching.html#zero-installs">Zero-Install</a></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://yarnpkg.com/advanced/lexicon" class="_attribution-link">https://yarnpkg.com/advanced/lexicon</a>
  </p>
</div>
