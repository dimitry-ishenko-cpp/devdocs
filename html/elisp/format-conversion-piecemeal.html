 <h4 class="subsection">Piecemeal Specification</h4> <p>In contrast to the round-trip specification described in the previous subsection (see <a href="format-conversion-round_002dtrip.html">Format Conversion Round-Trip</a>), you can use the variables <code>after-insert-file-functions</code> and <code>write-region-annotate-functions</code> to separately control the respective reading and writing conversions. </p> <p>Conversion starts with one representation and produces another representation. When there is only one conversion to do, there is no conflict about what to start with. However, when there are multiple conversions involved, conflict may arise when two conversions need to start with the same data. </p> <p>This situation is best understood in the context of converting text properties during <code>write-region</code>. For example, the character at position 42 in a buffer is ‘<samp>X</samp>’ with a text property <code>foo</code>. If the conversion for <code>foo</code> is done by inserting into the buffer, say, ‘<samp>FOO:</samp>’, then that changes the character at position 42 from ‘<samp>X</samp>’ to ‘<samp>F</samp>’. The next conversion will start with the wrong data straight away. </p> <p>To avoid conflict, cooperative conversions do not modify the buffer, but instead specify <em>annotations</em>, a list of elements of the form <code>(<var>position</var> . <var>string</var>)</code>, sorted in order of increasing <var>position</var>. </p> <p>If there is more than one conversion, <code>write-region</code> merges their annotations destructively into one sorted list. Later, when the text from the buffer is actually written to the file, it intermixes the specified annotations at the corresponding positions. All this takes place without modifying the buffer. </p> <p>In contrast, when reading, the annotations intermixed with the text are handled immediately. <code>insert-file-contents</code> sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can’t be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function. </p> <dl> <dt id="write-region-annotate-functions">Variable: <strong>write-region-annotate-functions</strong>
</dt> <dd>
<p>A list of functions for <code>write-region</code> to call. Each function in the list is called with two arguments: the start and end of the region to be written. These functions should not alter the contents of the buffer. Instead, they should return annotations. </p> <p>As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the <var>start</var> and <var>end</var> arguments of the <code>write-region</code> call, giving them the values of <code>point-min</code> and <code>point-max</code> in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function. </p>
</dd>
</dl> <dl> <dt id="write-region-post-annotation-function">Variable: <strong>write-region-post-annotation-function</strong>
</dt> <dd>
<p>The value of this variable, if non-<code>nil</code>, should be a function. This function is called, with no arguments, after <code>write-region</code> has completed. </p> <p>If any function in <code>write-region-annotate-functions</code> returns with a different buffer current, Emacs calls <code>write-region-post-annotation-function</code> more than once. Emacs calls it with the last buffer that was current, and again with the buffer before that, and so on back to the original buffer. </p> <p>Thus, a function in <code>write-region-annotate-functions</code> can create a buffer, give this variable the local value of <code>kill-buffer</code> in that buffer, set up the buffer with altered text, and make the buffer current. The buffer will be killed after <code>write-region</code> is done. </p>
</dd>
</dl> <dl> <dt id="after-insert-file-functions">Variable: <strong>after-insert-file-functions</strong>
</dt> <dd><p>Each function in this list is called by <code>insert-file-contents</code> with one argument, the number of characters inserted, and with point at the beginning of the inserted text. Each function should leave point unchanged, and return the new character count describing the inserted text as modified by the function. </p></dd>
</dl> <p>We invite users to write Lisp programs to store and retrieve text properties in files, using these hooks, and thus to experiment with various data formats and find good ones. Eventually we hope users will produce good, general extensions we can install in Emacs. </p> <p>We suggest not trying to handle arbitrary Lisp objects as text property names or values—because a program that general is probably difficult to write, and slow. Instead, choose a set of possible data types that are reasonably flexible, and not too hard to encode. </p><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 1990-1996, 1998-2022 Free Software Foundation, Inc. <br>Licensed under the GNU GPL license.<br>
    <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Format-Conversion-Piecemeal.html" class="_attribution-link">https://www.gnu.org/software/emacs/manual/html_node/elisp/Format-Conversion-Piecemeal.html</a>
  </p>
</div>
