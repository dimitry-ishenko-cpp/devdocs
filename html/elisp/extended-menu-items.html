 <h4 class="subsubsection">Extended Menu Items</h4>   <p>An extended-format menu item is a more flexible and also cleaner alternative to the simple format. You define an event type with a binding that’s a list starting with the symbol <code>menu-item</code>. For a non-selectable string, the binding looks like this: </p> <div class="example"> <pre class="example">(menu-item <var>item-name</var>)
</pre>
</div> <p>A string starting with two or more dashes specifies a separator line; see <a href="menu-separators.html">Menu Separators</a>. </p> <p>To define a real menu item which can be selected, the extended format binding looks like this: </p> <div class="example"> <pre class="example">(menu-item <var>item-name</var> <var>real-binding</var>
    . <var>item-property-list</var>)
</pre>
</div> <p>Here, <var>item-name</var> is an expression which evaluates to the menu item string. Thus, the string need not be a constant. </p> <p>The third element, <var>real-binding</var>, can be the command to execute (in which case you get a normal menu item). It can also be a keymap, which will result in a submenu, and <var>item-name</var> is used as the submenu name. Finally, it can be <code>nil</code>, in which case you will get a non-selectable menu item. This is mostly useful when creating separator lines and the like. </p> <p>The tail of the list, <var>item-property-list</var>, has the form of a property list which contains other information. </p> <p>Here is a table of the properties that are supported: </p> <dl compact> <dt><code>:enable <var>form</var></code></dt> <dd>
<p>The result of evaluating <var>form</var> determines whether the item is enabled (non-<code>nil</code> means yes). If the item is not enabled, you can’t really click on it. </p> </dd> <dt><code>:visible <var>form</var></code></dt> <dd>
<p>The result of evaluating <var>form</var> determines whether the item should actually appear in the menu (non-<code>nil</code> means yes). If the item does not appear, then the menu is displayed as if this item were not defined at all. </p> </dd> <dt><code>:help <var>help</var></code></dt> <dd>
<p>The value of this property, <var>help</var>, specifies a help-echo string to display while the mouse is on that item. This is displayed in the same way as <code>help-echo</code> text properties (see <a href="special-properties.html#Help-display">Help display</a>). Note that this must be a constant string, unlike the <code>help-echo</code> property for text and overlays. </p> </dd> <dt><code>:button (<var>type</var> . <var>selected</var>)</code></dt> <dd>
<p>This property provides a way to define radio buttons and toggle buttons. The <small>CAR</small>, <var>type</var>, says which: it should be <code>:toggle</code> or <code>:radio</code>. The <small>CDR</small>, <var>selected</var>, should be a form; the result of evaluating it says whether this button is currently selected. </p> <p>A <em>toggle</em> is a menu item which is labeled as either on or off according to the value of <var>selected</var>. The command itself should toggle <var>selected</var>, setting it to <code>t</code> if it is <code>nil</code>, and to <code>nil</code> if it is <code>t</code>. Here is how the menu item to toggle the <code>debug-on-error</code> flag is defined: </p> <div class="example"> <pre class="example">(menu-item "Debug on Error" toggle-debug-on-error
           :button (:toggle
                    . (and (boundp 'debug-on-error)
                           debug-on-error)))
</pre>
</div> <p>This works because <code>toggle-debug-on-error</code> is defined as a command which toggles the variable <code>debug-on-error</code>. </p> <p><em>Radio buttons</em> are a group of menu items, in which at any time one and only one is selected. There should be a variable whose value says which one is selected at any time. The <var>selected</var> form for each radio button in the group should check whether the variable has the right value for selecting that button. Clicking on the button should set the variable so that the button you clicked on becomes selected. </p> </dd> <dt><code>:key-sequence <var>key-sequence</var></code></dt> <dd>
<p>This property specifies which key sequence to display as keyboard equivalent. Before Emacs displays <var>key-sequence</var> in the menu, it verifies that <var>key-sequence</var> is really equivalent to this menu item, so it only has an effect if you specify a correct key sequence. Specifying <code>nil</code> for <var>key-sequence</var> is equivalent to the <code>:key-sequence</code> attribute being absent. </p> </dd> <dt><code>:keys <var>string</var></code></dt> <dd>
<p>This property specifies that <var>string</var> is the string to display as the keyboard equivalent for this menu item. You can use the ‘<samp>\\[...]</samp>’ documentation construct in <var>string</var>. </p> </dd> <dt><code>:filter <var>filter-fn</var></code></dt> <dd>
<p>This property provides a way to compute the menu item dynamically. The property value <var>filter-fn</var> should be a function of one argument; when it is called, its argument will be <var>real-binding</var>. The function should return the binding to use instead. </p> <p>Emacs can call this function at any time that it does redisplay or operates on menu data structures, so you should write it so it can safely be called at any time. </p>
</dd> </dl><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 1990-1996, 1998-2022 Free Software Foundation, Inc. <br>Licensed under the GNU GPL license.<br>
    <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Extended-Menu-Items.html" class="_attribution-link">https://www.gnu.org/software/emacs/manual/html_node/elisp/Extended-Menu-Items.html</a>
  </p>
</div>
