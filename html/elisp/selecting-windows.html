 <h3 class="section">Selecting Windows</h3>    <p>In each frame, at any time, exactly one Emacs window is designated as <em>selected within the frame</em>. For the selected frame, that window is called the <em>selected window</em>—the one in which most editing takes place, and in which the cursor for selected windows appears (see <a href="cursor-parameters.html">Cursor Parameters</a>). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window’s buffer is usually also the current buffer, except when <code>set-buffer</code> has been used (see <a href="current-buffer.html">Current Buffer</a>). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. </p> <dl> <dt id="selected-window">Function: <strong>selected-window</strong>
</dt> <dd><p>This function returns the selected window (which is always a live window). </p></dd>
</dl> <p>The following function explicitly selects a window and its frame. </p> <dl> <dt id="select-window">Function: <strong>select-window</strong> <em>window &amp;optional norecord</em>
</dt> <dd>
<p>This function makes <var>window</var> the selected window and the window selected within its frame, and selects that frame. It also makes <var>window</var>’s buffer (see <a href="buffers-and-windows.html">Buffers and Windows</a>) current and sets that buffer’s value of <code>point</code> to the value of <code>window-point</code> (see <a href="window-point.html">Window Point</a>) in <var>window</var>. <var>window</var> must be a live window. The return value is <var>window</var>. </p> <p>By default, this function also moves <var>window</var>’s buffer to the front of the buffer list (see <a href="buffer-list.html">Buffer List</a>) and makes <var>window</var> the most recently selected window. If the optional argument <var>norecord</var> is non-<code>nil</code>, these additional actions are omitted. </p> <p>In addition, this function by default also tells the display engine to update the display of <var>window</var> when its frame gets redisplayed the next time. If <var>norecord</var> is non-<code>nil</code>, such updates are usually not performed. If, however, <var>norecord</var> equals the special symbol <code>mark-for-redisplay</code>, the additional actions mentioned above are omitted but <var>window</var>’s display will be nevertheless updated. </p> <p>Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See <a href="input-focus.html">Input Focus</a>. </p>
</dd>
</dl>   <p>For historical reasons, Emacs does not run a separate hook whenever a window gets selected. Applications and internal routines often temporarily select a window to perform a few actions on it. They do that either to simplify coding—because many functions by default operate on the selected window when no <var>window</var> argument is specified—or because some functions did not (and still do not) take a window as argument and always operate(d) on the selected window instead. Running a hook every time a window gets selected for a short time and once more when the previously selected window gets restored is not useful. </p> <p>However, when its <var>norecord</var> argument is <code>nil</code>, <code>select-window</code> updates the buffer list and thus indirectly runs the normal hook <code>buffer-list-update-hook</code> (see <a href="buffer-list.html">Buffer List</a>). Consequently, that hook provides one way to run a function whenever a window gets selected more “permanently”. </p> <p>Since <code>buffer-list-update-hook</code> is also run by functions that are not related to window management, it will usually make sense to save the value of the selected window somewhere and compare it with the value of <code>selected-window</code> while running that hook. Also, to avoid false positives when using <code>buffer-list-update-hook</code>, it is good practice that every <code>select-window</code> call supposed to select a window only temporarily passes a non-<code>nil</code> <var>norecord</var> argument. If possible, the macro <code>with-selected-window</code> (see below) should be used in such cases. </p> <p>Emacs also runs the hook <code>window-selection-change-functions</code> whenever the redisplay routine detects that another window has been selected since last redisplay. See <a href="window-hooks.html">Window Hooks</a>, for a detailed explanation. <code>window-state-change-functions</code> (described in the same section) is another abnormal hook run after a different window has been selected but is triggered by other window changes as well. </p>  <p>The sequence of calls to <code>select-window</code> with a non-<code>nil</code> <var>norecord</var> argument determines an ordering of windows by their selection or use time, see below. The function <code>get-lru-window</code>, for example, can then be used to retrieve the least recently selected window (see <a href="cyclic-window-ordering.html">Cyclic Window Ordering</a>). </p> <dl> <dt id="frame-selected-window">Function: <strong>frame-selected-window</strong> <em>&amp;optional frame</em>
</dt> <dd><p>This function returns the window on <var>frame</var> that is selected within that frame. <var>frame</var> should be a live frame; if omitted or <code>nil</code>, it defaults to the selected frame. </p></dd>
</dl> <dl> <dt id="set-frame-selected-window">Function: <strong>set-frame-selected-window</strong> <em>frame window &amp;optional norecord</em>
</dt> <dd>
<p>This function makes <var>window</var> the window selected within the frame <var>frame</var>. <var>frame</var> should be a live frame; if <code>nil</code>, it defaults to the selected frame. <var>window</var> should be a live window; if <code>nil</code>, it defaults to the selected window. </p> <p>If <var>frame</var> is the selected frame, this makes <var>window</var> the selected window. </p> <p>If the optional argument <var>norecord</var> is non-<code>nil</code>, this function does not alter the ordering of the most recently selected windows, nor the buffer list. </p>
</dd>
</dl> <p>The following macros are useful to temporarily select a window without affecting the ordering of recently selected windows or the buffer list. </p> <dl> <dt id="save-selected-window">Macro: <strong>save-selected-window</strong> <em>forms…</em>
</dt> <dd>
<p>This macro records the selected frame, as well as the selected window of each frame, executes <var>forms</var> in sequence, then restores the earlier selected frame and windows. It also saves and restores the current buffer. It returns the value of the last form in <var>forms</var>. </p> <p>This macro does not save or restore anything about the sizes, arrangement or contents of windows; therefore, if <var>forms</var> change them, the change persists. If the previously selected window of some frame is no longer live at the time of exit from <var>forms</var>, that frame’s selected window is left alone. If the previously selected window is no longer live, then whatever window is selected at the end of <var>forms</var> remains selected. The current buffer is restored if and only if it is still live when exiting <var>forms</var>. </p> <p>This macro changes neither the ordering of recently selected windows nor the buffer list. </p>
</dd>
</dl> <dl> <dt id="with-selected-window">Macro: <strong>with-selected-window</strong> <em>window forms…</em>
</dt> <dd><p>This macro selects <var>window</var>, executes <var>forms</var> in sequence, then restores the previously selected window and current buffer. The ordering of recently selected windows and the buffer list remain unchanged unless you deliberately change them within <var>forms</var>; for example, by calling <code>select-window</code> with argument <var>norecord</var> <code>nil</code>. Hence, this macro is the preferred way to temporarily work with <var>window</var> as the selected window without needlessly running <code>buffer-list-update-hook</code>. </p></dd>
</dl> <dl> <dt id="with-selected-frame">Macro: <strong>with-selected-frame</strong> <em>frame forms…</em>
</dt> <dd><p>This macro executes <var>forms</var> with <var>frame</var> as the selected frame. The value returned is the value of the last form in <var>forms</var>. This macro saves and restores the selected frame, and changes the order of neither the recently selected windows nor the buffers in the buffer list. </p></dd>
</dl>    <dl> <dt id="window-use-time">Function: <strong>window-use-time</strong> <em>&amp;optional window</em>
</dt> <dd>
<p>This function returns the use time of window <var>window</var>. <var>window</var> must be a live window and defaults to the selected one. </p> <p>The <em>use time</em> of a window is not really a time value, but an integer that does increase monotonically with each call of <code>select-window</code> with a <code>nil</code> <var>norecord</var> argument. The window with the lowest use time is usually called the least recently used window while the window with the highest use time is called the most recently used one (see <a href="cyclic-window-ordering.html">Cyclic Window Ordering</a>). </p>
</dd>
</dl> <dl> <dt id="window-bump-use-time">Function: <strong>window-bump-use-time</strong> <em>&amp;optional window</em>
</dt> <dd><p>This function marks <var>window</var> as being the most recently used one. This can be useful when writing certain <code>pop-to-buffer</code> scenarios (see <a href="switching-buffers.html">Switching Buffers</a>). <var>window</var> must be a live window and defaults to the selected one. </p></dd>
</dl> <p>Sometimes several windows collectively and cooperatively display a buffer, for example, under the management of Follow Mode (see <a href="https://www.gnu.org/software/emacs/manual/html_node/emacs/Follow-Mode.html#Follow-Mode">(emacs)Follow Mode</a>), where the windows together display a bigger portion of the buffer than one window could alone. It is often useful to consider such a <em>window group</em> as a single entity. Several functions such as <code>window-group-start</code> (see <a href="window-start-and-end.html">Window Start and End</a>) allow you to do this by supplying, as an argument, one of the windows as a stand-in for the whole group. </p> <dl> <dt id="selected-window-group">Function: <strong>selected-window-group</strong>
</dt> <dd>
 <p>When the selected window is a member of a group of windows, this function returns a list of the windows in the group, ordered such that the first window in the list is displaying the earliest part of the buffer, and so on. Otherwise the function returns a list containing just the selected window. </p> <p>The selected window is considered part of a group when the buffer local variable <code>selected-window-group-function</code> is set to a function. In this case, <code>selected-window-group</code> calls it with no arguments and returns its result (which should be the list of windows in the group). </p>
</dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 1990-1996, 1998-2022 Free Software Foundation, Inc. <br>Licensed under the GNU GPL license.<br>
    <a href="https://www.gnu.org/software/emacs/manual/html_node/elisp/Selecting-Windows.html" class="_attribution-link">https://www.gnu.org/software/emacs/manual/html_node/elisp/Selecting-Windows.html</a>
  </p>
</div>
