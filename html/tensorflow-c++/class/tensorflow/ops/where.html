<devsite-feature-tooltip ack-key="AckCollectionsBookmarkTooltipDismiss" analytics-category="Site-Wide Custom Events" analytics-action-show="Callout Profile displayed" analytics-action-close="Callout Profile dismissed" analytics-label="Create Collection Callout" class="devsite-page-bookmark-tooltip nocontent" dismiss-button="true" id="devsite-collections-dropdown" dismiss-button-text="Dismiss" close-button-text="Got it">    </devsite-feature-tooltip>   <devsite-mathjax config="TeX-AMS-MML_SVG"></devsite-mathjax>  <h1 id="tensorflow::ops::where" data-text="tensorflow::ops::Where" tabindex="-1">tensorflow::ops::Where</h1> <p><code translate="no" dir="ltr">#include &lt;array_ops.h&gt;</code></p> <p>Reshapes a quantized tensor as per the Reshape op. </p> <h2 id="summary" data-text="Summary" tabindex="-1">Summary</h2> 

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* shape: Defines the shape of the output tensor.
* input_min: The minimum value of the input.
* input_max: The maximum value of the input.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output` output
    * `Output` output_min: This value is copied from input_min.
    * `Output` output_max: This value is copied from input_max. */
class QuantizedReshape {
 public:
  QuantizedReshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input shape, tensorflow::Input input_min,
                 tensorflow::Input input_max);</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
  tensorflow::Output output_min;
  tensorflow::Output output_max;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns the rank of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns an integer representing the rank of `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="t-is-[[[1,-1,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]" data-text="'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]" tabindex="-1">'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1> 
<h1 id="shape-of-tensor-t-is-[2,-2,-3]" data-text="shape of tensor 't' is [2, 2, 3]" tabindex="-1">shape of tensor 't' is [2, 2, 3]</h1> <p>rank(t) ==&gt; 3 </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">**Note**: The rank of a tensor is not the same as the rank of a matrix. The rank
of a tensor is the number of indices required to uniquely select each element
of the tensor. Rank is also known as "order", "degree", or "ndims."</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Rank {
 public:
  Rank(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Reshapes a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Given `tensor`, this operation returns a tensor that has the same values
as `tensor` with shape `shape`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">If one component of 1-D tensor `shape` is the special value -1, the size of that
dimension is computed so that the total size remains constant.  In particular, a
`shape` of `[-1]` flattens into 1-D.  At most one component of `shape` may be
unknown.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The `shape` must be 1-D and the operation returns a tensor with shape
`shape` filled with the values of `tensor`. In this case, the number of elements
implied by `shape` must be the same as the number of elements in `tensor`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">It is an error if `shape` is not 1-D.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-t-is-[1,-2,-3,-4,-5,-6,-7,-8,-9]" data-text="tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]" tabindex="-1">tensor 't' is [1, 2, 3, 4, 5, 6, 7, 8, 9]</h1> 
<h1 id="tensor-t-has-shape-[9]" data-text="tensor 't' has shape [9]" tabindex="-1">tensor 't' has shape [9]</h1> <p>reshape(t, [3, 3]) ==&gt; [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</p> 
<h1 id="tensor-t-is-[[[1,-1],-[2,-2]]," data-text="tensor 't' is [[[1, 1], [2, 2]]," tabindex="-1">tensor 't' is [[[1, 1], [2, 2]],</h1> 
<h1 id="[[3,-3],-[4,-4]]]" data-text="[[3, 3], [4, 4]]]" tabindex="-1">[[3, 3], [4, 4]]]</h1> 
<h1 id="tensor-t-has-shape-[2,-2,-2]" data-text="tensor 't' has shape [2, 2, 2]" tabindex="-1">tensor 't' has shape [2, 2, 2]</h1> <p>reshape(t, [2, 4]) ==&gt; [[1, 1, 2, 2], [3, 3, 4, 4]]</p> 
<h1 id="tensor-t-is-[[[1,-1,-1]," data-text="tensor 't' is [[[1, 1, 1]," tabindex="-1">tensor 't' is [[[1, 1, 1],</h1> 
<h1 id="[2,-2,-2]]," data-text="[2, 2, 2]]," tabindex="-1">[2, 2, 2]],</h1> 
<h1 id="[[3,-3,-3]," data-text="[[3, 3, 3]," tabindex="-1">[[3, 3, 3],</h1> 
<h1 id="[4,-4,-4]]," data-text="[4, 4, 4]]," tabindex="-1">[4, 4, 4]],</h1> 
<h1 id="[[5,-5,-5]," data-text="[[5, 5, 5]," tabindex="-1">[[5, 5, 5],</h1> 
<h1 id="[6,-6,-6]]]" data-text="[6, 6, 6]]]" tabindex="-1">[6, 6, 6]]]</h1> 
<h1 id="tensor-t-has-shape-[3,-2,-3]" data-text="tensor 't' has shape [3, 2, 3]" tabindex="-1">tensor 't' has shape [3, 2, 3]</h1> 
<h1 id="pass-[-1]-to-flatten-t" data-text="pass '[-1]' to flatten 't'" tabindex="-1">pass '[-1]' to flatten 't'</h1> <p>reshape(t, [-1]) ==&gt; [1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]</p> 
<h1 id="-1-can-also-be-used-to-infer-the-shape" data-text="-1 can also be used to infer the shape" tabindex="-1">-1 can also be used to infer the shape</h1> 
<h1 id="-1-is-inferred-to-be-9:" data-text="-1 is inferred to be 9:" tabindex="-1">-1 is inferred to be 9:</h1> <p>reshape(t, [2, -1]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] </p>
<h1 id="-1-is-inferred-to-be-2:" data-text="-1 is inferred to be 2:" tabindex="-1">-1 is inferred to be 2:</h1> <p>reshape(t, [-1, 9]) ==&gt; [[1, 1, 1, 2, 2, 2, 3, 3, 3], [4, 4, 4, 5, 5, 5, 6, 6, 6]] </p>
<h1 id="-1-is-inferred-to-be-3:" data-text="-1 is inferred to be 3:" tabindex="-1">-1 is inferred to be 3:</h1> <p>reshape(t, [ 2, -1, 3]) ==&gt; [[[1, 1, 1], [2, 2, 2], [3, 3, 3]], [[4, 4, 4], [5, 5, 5], [6, 6, 6]]]</p> 
<h1 id="tensor-t-is-[7]" data-text="tensor 't' is [7]" tabindex="-1">tensor 't' is [7]</h1> 
<h1 id="shape-[]-reshapes-to-a-scalar" data-text="shape [] reshapes to a scalar" tabindex="-1">shape <code translate="no" dir="ltr">[]</code> reshapes to a scalar</h1> <p>reshape(t, []) ==&gt; 7 </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* shape: Defines the shape of the output tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Reshape {
 public:
  Reshape(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Assign `value` to the sliced l-value reference of `ref`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The values of `value` are assigned to the positions in the variable
`ref` that are selected by the slice parameters. The slice parameters
`begin, `end`, `strides`, etc. work exactly as in `StridedSlice`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">NOTE this op currently does not support broadcasting and so `value`'s
shape must be exactly the shape produced by the slice of `ref`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * the created `Operation` */
class ResourceStridedSliceAssign {
 public:
  /// Optional attribute setters for ResourceStridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                         tensorflow::Input ref, tensorflow::Input begin,
                         tensorflow::Input end, tensorflow::Input
                         strides, tensorflow::Input value);
ResourceStridedSliceAssign(const tensorflow::Scope&amp; scope,
                         tensorflow::Input ref, tensorflow::Input begin,
                         tensorflow::Input end, tensorflow::Input
                         strides, tensorflow::Input value, const
                         ResourceStridedSliceAssign::Attrs&amp; attrs);
operator ::tensorflow::Operation() const { return operation; }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Operation operation;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">/** Reverses variable length slices.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This op first slices `input` along the dimension `batch_dim`, and for each
slice `i`, reverses the first `seq_lengths[i]` elements along
the dimension `seq_dim`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">The elements of `seq_lengths` must obey `seq_lengths[i] &lt;= input.dims[seq_dim]`,
and `seq_lengths` must be a vector of length `input.dims[batch_dim]`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The output slice `i` along dimension `batch_dim` is then given by input
slice `i`, with the first `seq_lengths[i]` slices along dimension
`seq_dim` reversed.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="given-this:" data-text="Given this:" tabindex="-1">Given this:</h1> <p>batch_dim = 0 seq_dim = 1 input.dims = (4, 8, ...) seq_lengths = [7, 2, 3, 5]</p> 
<h1 id="then-slices-of-input-are-reversed-on-seq_dim,-but-only-up-to-seq_lengths:" data-text="then slices of input are reversed on seq_dim, but only up to seq_lengths:" tabindex="-1">then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1> <p>output[0, 0:7, :, ...] = input[0, 7:0:-1, :, ...] output[1, 0:2, :, ...] = input[1, 2:0:-1, :, ...] output[2, 0:3, :, ...] = input[2, 3:0:-1, :, ...] output[3, 0:5, :, ...] = input[3, 5:0:-1, :, ...]</p> 
<h1 id="while-entries-past-seq_lens-are-copied-through:" data-text="while entries past seq_lens are copied through:" tabindex="-1">while entries past seq_lens are copied through:</h1> <p>output[0, 7:, :, ...] = input[0, 7:, :, ...] output[1, 2:, :, ...] = input[1, 2:, :, ...] output[2, 3:, :, ...] = input[2, 3:, :, ...] output[3, 2:, :, ...] = input[3, 2:, :, ...] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In contrast, if:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="given-this:_1" data-text="Given this:" tabindex="-1">Given this:</h1> <p>batch_dim = 2 seq_dim = 0 input.dims = (8, ?, 4, ...) seq_lengths = [7, 2, 3, 5]</p> 
<h1 id="then-slices-of-input-are-reversed-on-seq_dim,-but-only-up-to-seq_lengths:_1" data-text="then slices of input are reversed on seq_dim, but only up to seq_lengths:" tabindex="-1">then slices of input are reversed on seq_dim, but only up to seq_lengths:</h1> <p>output[0:7, :, 0, :, ...] = input[7:0:-1, :, 0, :, ...] output[0:2, :, 1, :, ...] = input[2:0:-1, :, 1, :, ...] output[0:3, :, 2, :, ...] = input[3:0:-1, :, 2, :, ...] output[0:5, :, 3, :, ...] = input[5:0:-1, :, 3, :, ...]</p> 
<h1 id="while-entries-past-seq_lens-are-copied-through:_1" data-text="while entries past seq_lens are copied through:" tabindex="-1">while entries past seq_lens are copied through:</h1> <p>output[7:, :, 0, :, ...] = input[7:, :, 0, :, ...] output[2:, :, 1, :, ...] = input[2:, :, 1, :, ...] output[3:, :, 2, :, ...] = input[3:, :, 2, :, ...] output[2:, :, 3, :, ...] = input[2:, :, 3, :, ...] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* input: The input to reverse.
* seq_lengths: 1-D with length `input.dims(batch_dim)` and
`max(seq_lengths) &lt;= input.dims(seq_dim)`
* seq_dim: The dimension which is partially reversed.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Optional attributes (see `Attrs`):
* batch_dim: The dimension along which reversal is performed.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The partially reversed input. It has the same shape as `input`. */
class ReverseSequence {
 public:
  /// Optional attribute setters for ReverseSequence
  struct Attrs {
    /** The dimension along which reversal is performed.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs BatchDim(int64 x) {
  Attrs ret = *this;
  ret.batch_dim_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 batch_dim_ = 0;
};
ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
              tensorflow::Input seq_lengths, int64 seq_dim);
ReverseSequence(const tensorflow::Scope&amp; scope, tensorflow::Input input,
              tensorflow::Input seq_lengths, int64 seq_dim, const
              ReverseSequence::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BatchDim(int64 x) {
  return Attrs().BatchDim(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Reverses specific dimensions of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Given a `tensor`, and a `int32` tensor `axis` representing the set of
dimensions of `tensor` to reverse. This operation reverses each dimension
`i` for which there exists `j` s.t. `axis[j] == i`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`tensor` can have up to 8 dimensions. The number of dimensions specified
in `axis` may be 0 or more entries. If an index is specified more than
once, a InvalidArgument error is raised.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-t-is-[[[[-0,-1,-2,-3]," data-text="tensor 't' is [[[[ 0, 1, 2, 3]," tabindex="-1">tensor 't' is [[[[ 0, 1, 2, 3],</h1> 
<h1 id="[-4,-5,-6,-7]," data-text="[ 4, 5, 6, 7]," tabindex="-1">[ 4, 5, 6, 7],</h1> 
<h1 id="[-8,-9,-10,-11]]," data-text="[ 8, 9, 10, 11]]," tabindex="-1">[ 8, 9, 10, 11]],</h1> 
<h1 id="[[12,-13,-14,-15]," data-text="[[12, 13, 14, 15]," tabindex="-1">[[12, 13, 14, 15],</h1> 
<h1 id="[16,-17,-18,-19]," data-text="[16, 17, 18, 19]," tabindex="-1">[16, 17, 18, 19],</h1> 
<h1 id="[20,-21,-22,-23]]]]" data-text="[20, 21, 22, 23]]]]" tabindex="-1">[20, 21, 22, 23]]]]</h1> 
<h1 id="tensor-t-shape-is-[1,-2,-3,-4]" data-text="tensor 't' shape is [1, 2, 3, 4]" tabindex="-1">tensor 't' shape is [1, 2, 3, 4]</h1> 
<h1 id="dims-is-[3]-or-dims-is-[-1]" data-text="'dims' is [3] or 'dims' is [-1]" tabindex="-1">'dims' is [3] or 'dims' is [-1]</h1> <p>reverse(t, dims) ==&gt; [[[[ 3, 2, 1, 0], [ 7, 6, 5, 4], [ 11, 10, 9, 8]], [[15, 14, 13, 12], [19, 18, 17, 16], [23, 22, 21, 20]]]]</p> 
<h1 id="dims-is-[1]-or-dims-is-[-3]" data-text="'dims' is '[1]' (or 'dims' is '[-3]')" tabindex="-1">'dims' is '[1]' (or 'dims' is '[-3]')</h1> <p>reverse(t, dims) ==&gt; [[[[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23] [[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]]]]</p> 
<h1 id="dims-is-[2]-or-dims-is-[-2]" data-text="'dims' is '[2]' (or 'dims' is '[-2]')" tabindex="-1">'dims' is '[2]' (or 'dims' is '[-2]')</h1> <p>reverse(t, dims) ==&gt; [[[[8, 9, 10, 11], [4, 5, 6, 7], [0, 1, 2, 3]] [[20, 21, 22, 23], [16, 17, 18, 19], [12, 13, 14, 15]]]] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Up to 8-D.
* axis: 1-D. The indices of the dimensions to reverse. Must be in the range
`[-rank(tensor), rank(tensor))`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The same shape as `tensor`. */
class Reverse {
 public:
  Reverse(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
        tensorflow::Input axis);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Scatters `updates` into a tensor of shape `shape` according to `indices`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Scatter sparse `updates` according to individual values at the specified
`indices`. This op returns an output tensor with the `shape` you specify. This
op is the inverse of the tf.gather_nd operator which extracts values or slices
from a given tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">This operation is similar to tf.tensor_scatter_nd_add, except that the tensor
is zero-initialized. Calling tf.scatter_nd(indices, updates, shape)
is identical to calling
`tf.tensor_scatter_nd_add(tf.zeros(shape, updates.dtype), indices, updates)`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">If `indices` contains duplicates, the associated `updates` are accumulated
(summed) into the output tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">**WARNING**: For floating-point data types, the output may be nondeterministic.
This is because the order in which the updates are applied is nondeterministic
and when floating-point numbers are added in different orders the resulting
numerical approximation error can be slightly different. However, the output
will be deterministic if op determinism is enabled via
tf.config.experimental.enable_op_determinism.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`indices` is an integer tensor containing indices into the output tensor. The
last dimension of `indices` can be at most the rank of `shape`:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">indices.shape[-1] &lt;= shape.rank</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The last dimension of `indices` corresponds to indices of elements
(if `indices.shape[-1] = shape.rank`) or slices
(if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
`shape`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`updates` is a tensor with shape:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="cplint" data-language="cpp">indices.shape[:-1] + shape[indices.shape[-1]:]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">The simplest form of the scatter op is to insert individual elements in
a tensor by index. Consider an example where you want to insert 4 scattered
elements in a rank-1 tensor with 8 elements.</pre></devsite-code> 

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter operation would look like this:</pre></devsite-code> 

<devsite-code></devsite-code>python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) shape = tf.constant([8]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter) 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The resulting tensor would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">[0, 11, 0, 10, 9, 0, 0, 12]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">You can also insert entire slices of a higher rank tensor all at once. For
example, you can insert two slices in the first dimension of a rank-3 tensor
with two matrices of new values.</pre></devsite-code> 

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter operation would look like this:</pre></devsite-code> 

<devsite-code></devsite-code>python indices = tf.constant([[1], [3]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) shape = tf.constant([4, 4, 4]) scatter = tf.scatter_nd(indices, updates, shape) print(scatter) 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The resulting tensor would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">[[[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
 [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]],
 [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]],
 [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Note that on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* indices: Tensor of indices.
* updates: Values to scatter into the output tensor.
* shape: 1-D. The shape of the output tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class ScatterNd {
 public:
  ScatterNd(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
          tensorflow::Input updates, tensorflow::Input shape);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Applies sparse addition to `input` using individual values or slices</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">from `updates` according to indices `indices`.  The updates are non-aliasing:
`input` is only modified in-place if no other operations will use it.
Otherwise, a copy of `input` is made.  This operation has a gradient with
respect to both `input` and `updates`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`input` is a `Tensor` with rank `P` and `indices` is a `Tensor` of rank `Q`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`indices` must be integer tensor, containing indices into `input`.
It must be shape \([d_0, ..., d_{Q-2}, K]\) where `0 &lt; K &lt;= P`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The innermost dimension of `indices` (with length `K`) corresponds to
indices into elements (if `K = P`) or `(P-K)`-dimensional slices
(if `K &lt; P`) along the `K`th dimension of `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`updates` is `Tensor` of rank `Q-1+P-K` with shape:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">$$[d_0, ..., d_{Q-2}, input.shape[K], ..., input.shape[P-1]].$$</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example, say we want to add 4 scattered elements to a rank-1 tensor to 8
elements. In Python, that addition would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">input = tf.constant([1, 2, 3, 4, 5, 6, 7, 8])
indices = tf.constant([[4], [3], [1], [7]])
updates = tf.constant([9, 10, 11, 12])
output = tf.scatter_nd_non_aliasing_add(input, indices, updates)
with tf.Session() as sess:
  print(sess.run(output))</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The resulting value `output` would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">[1, 13, 3, 14, 14, 6, 7, 20]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">See tf.scatter_nd for more details about how to make updates to slices.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* input: A Tensor.
* indices: A Tensor. Must be one of the following types: `int32`, `int64`.
A tensor of indices into `input`.
* updates: A Tensor. Must have the same type as ref. A tensor of updated values
to add to `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A `Tensor` with the same shape as `input`, containing values of `input`
    updated with `updates`. */
class ScatterNdNonAliasingAdd {
 public:
  ScatterNdNonAliasingAdd(const tensorflow::Scope&amp; scope, tensorflow::Input
                        input, tensorflow::Input indices, tensorflow::Input
                        updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns the shape of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns a 1-D integer tensor representing the shape of `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="t-is-[[[1,-1,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]_1" data-text="'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]" tabindex="-1">'t' is [[[1, 1, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]</h1> <p>shape(t) ==&gt; [2, 2, 3] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Shape {
 public:
  /// Optional attribute setters for Shape
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_type_ = DT_INT32;
};
Shape(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Shape(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
    Shape::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns shape of tensors.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">This operation returns N 1-D integer tensors representing shape of `input[i]s`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `OutputList`: The output tensor. */
class ShapeN {
 public:
  /// Optional attribute setters for ShapeN
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">  DataType out_type_ = DT_INT32;
};
ShapeN(const ::tensorflow::Scope&amp; scope, ::tensorflow::InputList input);
ShapeN(const tensorflow::Scope&amp; scope, tensorflow::InputList input, const
     ShapeN::Attrs&amp; attrs);
tensorflow::Output operator[](size_t index) const { return output[index]; }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns the size of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns an integer representing the number of elements in
`input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="t-is-[[[1,-1,,-1],-[2,-2,-2]],-[[3,-3,-3],-[4,-4,-4]]]]" data-text="'t' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]" tabindex="-1">'t' is [[[1, 1,, 1], [2, 2, 2]], [[3, 3, 3], [4, 4, 4]]]]</h1> <p>size(t) ==&gt; 12 </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Size {
 public:
  /// Optional attribute setters for Size
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutType(DataType x) {
      Attrs ret = *this;
      ret.out_type_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_type_ = DT_INT32;
};
Size(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Size(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
   Size::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutType(DataType x) {
  return Attrs().OutType(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Return a slice from 'input'.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor is a tensor with dimensions described by 'size'
whose values are extracted from 'input' starting at the offsets in
'begin'.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">*Requirements*:
  0 &lt;= begin[i] &lt;= begin[i] + size[i] &lt;= Di  for i in [0, n)</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Args:
* scope: A Scope object
* begin: begin[i] specifies the offset into the 'i'th dimension of
'input' to slice from.
* size: size[i] specifies the number of elements of the 'i'th dimension
of 'input' to slice. If size[i] is -1, all remaining elements in dimension
i are included in the slice (i.e. this is equivalent to setting
size[i] = input.dim_size(i) - begin[i]).</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Slice {
 public:
  Slice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
      tensorflow::Input begin, tensorflow::Input size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns a copy of the input tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Snapshot {
 public:
  Snapshot(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">/** SpaceToBatch for 4-D tensors of type T.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">This is a legacy version of the more general SpaceToBatchND.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Zero-pads and then rearranges (permutes) blocks of spatial data into batch.
More specifically, this op outputs a copy of the input tensor where values from
the `height` and `width` dimensions are moved to the `batch` dimension. After
the zero-padding, both `height` and `width` of the input must be divisible by the
block size.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The attr `block_size` must be greater than one. It indicates the block size.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">* Non-overlapping blocks of size `block_size x block size` in the height and
  width dimensions are rearranged into the batch dimension at each location.
* The batch of the output tensor is `batch * block_size * block_size`.
* Both height_pad and width_pad must be divisible by block_size.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The shape of the output will be:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">[batch*block_size*block_size, height_pad/block_size, width_pad/block_size,
 depth]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Some examples:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(1) For the following input of shape `[1, 2, 2, 1]` and block_size of 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2]], [[3], [4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 1, 1, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(2) For the following input of shape `[1, 2, 2, 3]` and block_size of 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 1, 1, 3]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(3) For the following input of shape `[1, 4, 4, 1]` and block_size of 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 2, 2, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(4) For the following input of shape `[2, 2, 4, 1]` and block_size of 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[8, 1, 2, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [3]]], [[[9], [11]]], [[[2], [4]]], [[[10], [12]]], [[[5], [7]]], [[[13], [15]]], [[[6], [8]]], [[[14], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="verilog" data-language="cpp">Among others, this operation is useful for reducing atrous convolution into
regular convolution.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* input: 4-D with shape `[batch, height, width, depth]`.
* paddings: 2-D tensor of non-negative integers with shape `[2, 2]`. It specifies
  the padding of the input with zeros across the spatial dimensions as follows:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">paddings = [[pad_top, pad_bottom], [pad_left, pad_right]]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The effective spatial dimensions of the zero-padded input tensor will be:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">height_pad = pad_top + height + pad_bottom
width_pad = pad_left + width + pad_right</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToBatch {
 public:
  SpaceToBatch(const tensorflow::Scope&amp; scope, tensorflow::Input input,
             tensorflow::Input paddings, int64 block_size);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">/** SpaceToBatch for N-D tensors of type T.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation divides "spatial" dimensions `[1, ..., M]` of the input into a
grid of blocks of shape `block_shape`, and interleaves these blocks with the
"batch" dimension (0) such that in the output, the spatial dimensions
`[1, ..., M]` correspond to the position within the grid, and the batch
dimension combines both the position within a spatial block and the original
batch position.  Prior to division into blocks, the spatial dimensions of the
input are optionally zero padded according to `paddings`. See below for a
precise description.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">This operation is equivalent to the following steps:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">1. Zero-pad the start and end of dimensions `[1, ..., M]` of the
   input according to `paddings` to produce `padded` of shape `padded_shape`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">2. Reshape `padded` to `reshaped_padded` of shape:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">[batch] +
[padded_shape[1] / block_shape[0],
  block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1],
 block_shape[M-1]] +
remaining_shape</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">3. Permute dimensions of `reshaped_padded` to produce
   `permuted_reshaped_padded` of shape:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">block_shape +
[batch] +
[padded_shape[1] / block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1]] +
remaining_shape</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">4. Reshape `permuted_reshaped_padded` to flatten `block_shape` into the batch
   dimension, producing an output tensor of shape:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">[batch * prod(block_shape)] +
[padded_shape[1] / block_shape[0],
 ...,
 padded_shape[M] / block_shape[M-1]] +
remaining_shape</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Some examples:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(1) For the following input of shape `[1, 2, 2, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2]], [[3], [4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 1, 1, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1]]], [[[2]]], [[[3]]], [[[4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(2) For the following input of shape `[1, 2, 2, 3]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 1, 1, 3]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1, 2, 3]]], [[[4, 5, 6]]], [[[7, 8, 9]]], [[[10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(3) For the following input of shape `[1, 4, 4, 1]`, `block_shape = [2, 2]`, and
    `paddings = [[0, 0], [0, 0]]`:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]], [[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[4, 2, 2, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [3]], [[9], [11]]], [[[2], [4]], [[10], [12]]], [[[5], [7]], [[13], [15]]], [[[6], [8]], [[14], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(4) For the following input of shape `[2, 2, 4, 1]`, block_shape = `[2, 2]`, and
    paddings = `[[0, 0], [2, 0]]`:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2], [3], [4]], [[5], [6], [7], [8]]], [[[9], [10], [11], [12]], [[13], [14], [15], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The output tensor has shape `[8, 1, 3, 1]` and value:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[0], [1], [3]]], [[[0], [9], [11]]], [[[0], [2], [4]]], [[[0], [10], [12]]], [[[0], [5], [7]]], [[[0], [13], [15]]], [[[0], [6], [8]]], [[[0], [14], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="verilog" data-language="cpp">Among others, this operation is useful for reducing atrous convolution into
regular convolution.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Args:
* scope: A Scope object
* input: N-D with shape `input_shape = [batch] + spatial_shape + remaining_shape`,
where spatial_shape has `M` dimensions.
* block_shape: 1-D with shape `[M]`, all values must be &gt;= 1.
* paddings: 2-D with shape `[M, 2]`, all values must be &gt;= 0.
  `paddings[i] = [pad_start, pad_end]` specifies the padding for input dimension
  `i + 1`, which corresponds to spatial dimension `i`.  It is required that
  `block_shape[i]` divides `input_shape[i + 1] + pad_start + pad_end`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToBatchND {
 public:
  SpaceToBatchND(const tensorflow::Scope&amp; scope, tensorflow::Input input,
               tensorflow::Input block_shape, tensorflow::Input paddings);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">/** SpaceToDepth for tensors of type T.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Rearranges blocks of spatial data, into depth. More specifically,
this op outputs a copy of the input tensor where values from the `height`
and `width` dimensions are moved to the `depth` dimension.
The attr `block_size` indicates the input block size.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">* Non-overlapping blocks of size `block_size x block size` are rearranged
  into depth at each location.
* The depth of the output tensor is `block_size * block_size * input_depth`.
* The Y, X coordinates within each block of the input become the high order
  component of the output channel index.
* The input tensor's height and width must be divisible by block_size.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The `data_format` attr specifies the layout of the input and output tensors
with the following options:
  "NHWC": `[ batch, height, width, channels ]`
  "NCHW": `[ batch, channels, height, width ]`
  "NCHW_VECT_C":
      `qint8 [ batch, channels / 4, height, width, 4 ]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">It is useful to consider the operation as transforming a 6-D Tensor.
e.g. for data_format = NHWC,
     Each element in the input tensor can be specified via 6 coordinates,
     ordered by decreasing memory layout significance as:
     n,oY,bY,oX,bX,iC  (where n=batch index, oX, oY means X or Y coordinates
                        within the output image, bX, bY means coordinates
                        within the input block, iC means input channels).
     The output would be a transpose to the following layout:
     n,oY,oX,bY,bX,iC</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">This operation is useful for resizing the activations between convolutions
(but keeping all data), e.g. instead of pooling. It is also useful for training
purely convolutional models.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">For example, given an input of shape `[1, 2, 2, 1]`, data_format = "NHWC" and
block_size = 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2]], [[3], [4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">This operation will output a tensor of shape `[1, 1, 1, 4]`:</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1, 2, 3, 4]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Here, the input has a batch of 1 and each batch element has shape `[2, 2, 1]`,
the corresponding output will have a single element (i.e. width and height are
both 1) and will have a depth of 4 channels (1 * block_size * block_size).
The output element shape is `[1, 1, 4]`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For an input tensor with larger depth, here of shape `[1, 2, 2, 3]`, e.g.</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1, 2, 3], [4, 5, 6]], [[7, 8, 9], [10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">This operation, for block_size of 2, will return the following tensor of shape
`[1, 1, 1, 12]`</pre></devsite-code> 

<devsite-code></devsite-code> [[[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Similarly, for the following input of shape `[1 4 4 1]`, and a block size of 2:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1], [2], [5], [6]], [[3], [4], [7], [8]], [[9], [10], [13], [14]], [[11], [12], [15], [16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">the operator will return the following tensor of shape `[1 2 2 4]`:</pre></devsite-code> 

<devsite-code></devsite-code> x = [[[[1, 2, 3, 4], [5, 6, 7, 8]], [[9, 10, 11, 12], [13, 14, 15, 16]]]] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* block_size: The size of the spatial block.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class SpaceToDepth {
 public:
  /// Optional attribute setters for SpaceToDepth
  struct Attrs {
    /// Defaults to "NHWC"
    TF_MUST_USE_RESULT Attrs DataFormat(StringPiece x) {
      Attrs ret = *this;
      ret.data_format_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  StringPiece data_format_ = "NHWC";
};
SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
           block_size);
SpaceToDepth(const tensorflow::Scope&amp; scope, tensorflow::Input input, int64
           block_size, const SpaceToDepth::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs DataFormat(StringPiece x) {
  return Attrs().DataFormat(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Splits a tensor into `num_split` tensors along one dimension.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Args:
* scope: A Scope object
* axis: 0-D.  The dimension along which to split.  Must be in the range
`[-rank(value), rank(value))`.
* value: The tensor to split.
* num_split: The number of ways to split.  Must evenly divide
`value.shape[split_dim]`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">    Returns:
    * `OutputList`: They are identically shaped tensors, whose shape matches that of `value`
    except along `axis`, where their sizes are
    `values.shape[split_dim] / num_split`. */
class Split {
 public:
  Split(const tensorflow::Scope&amp; scope, tensorflow::Input axis,
      tensorflow::Input value, int64 num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Splits a tensor into `num_split` tensors along one dimension.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* value: The tensor to split.
* size_splits: list containing the sizes of each output tensor along the split
dimension. Must sum to the dimension of value along split_dim.
Can contain one -1 indicating that dimension is to be inferred.
* axis: 0-D.  The dimension along which to split.  Must be in the range
`[-rank(value), rank(value))`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">    Returns:
    * `OutputList`: Tensors whose shape matches that of `value`
    except along `axis`, where their sizes are
    `size_splits[i]`. */
class SplitV {
 public:
  SplitV(const tensorflow::Scope&amp; scope, tensorflow::Input value,
       tensorflow::Input size_splits, tensorflow::Input axis, int64
       num_split);
  tensorflow::Output operator[](size_t index) const { return output[index]; }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Removes dimensions of size 1 from the shape of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Given a tensor `input`, this operation returns a tensor of the same type with
all dimensions of size 1 removed. If you don't want to remove all size 1
dimensions, you can remove specific size 1 dimensions by specifying
`axis`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="t-is-a-tensor-of-shape-[1,-2,-1,-3,-1,-1]" data-text="'t' is a tensor of shape [1, 2, 1, 3, 1, 1]" tabindex="-1">'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1> <p>shape(squeeze(t)) ==&gt; [2, 3] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Or, to remove specific size 1 dimensions:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="t-is-a-tensor-of-shape-[1,-2,-1,-3,-1,-1]_1" data-text="'t' is a tensor of shape [1, 2, 1, 3, 1, 1]" tabindex="-1">'t' is a tensor of shape [1, 2, 1, 3, 1, 1]</h1> <p>shape(squeeze(t, [2, 4])) ==&gt; [1, 2, 3, 1] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* input: The `input` to squeeze.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Optional attributes (see `Attrs`):
* axis: If specified, only squeezes the dimensions listed. The dimension
index starts at 0. It is an error to squeeze a dimension that is not 1. Must
be in the range `[-rank(input), rank(input))`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: Contains the same data as `input`, but has one or more dimensions of
    size 1 removed. */
class Squeeze {
 public:
  /// Optional attribute setters for Squeeze
  struct Attrs {
    /** If specified, only squeezes the dimensions listed. The dimension
        index starts at 0. It is an error to squeeze a dimension that is not 1. Must
        be in the range `[-rank(input), rank(input))`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">    Defaults to [] */
TF_MUST_USE_RESULT Attrs Axis(const gtl::ArraySlice&amp; x) {
  Attrs ret = *this;
  ret.axis_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  gtl::ArraySlice axis_ = {};
};
Squeeze(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
Squeeze(const tensorflow::Scope&amp; scope, tensorflow::Input input, const
      Squeeze::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">static Attrs Axis(const gtl::ArraySlice&amp; x) {
  return Attrs().Axis(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Stops gradient computation.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">When executed in a graph, this op outputs its input tensor as-is.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">When building ops to compute gradients, this op prevents the contribution of
its inputs to be taken into account.  Normally, the gradient generator adds ops
to a graph to compute the derivatives of a specified 'loss' by recursively
finding out inputs that contributed to its computation.  If you insert this op
in the graph it inputs are masked from the gradient generator.  They are not
taken into account for computing gradients.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">This is useful any time you want to compute a value with TensorFlow but need
to pretend that the value was a constant. For example, the softmax function
for a vector x can be written as</pre></devsite-code> 

<devsite-code></devsite-code>python <p>def softmax(x): numerator = tf.exp(x) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">This however is susceptible to overflow if the values in x are large. An
alternative more stable way is to subtract the maximum of x from each of the
values.</pre></devsite-code> 

<devsite-code></devsite-code>python <p>def stable_softmax(x): z = x - tf.reduce_max(x) numerator = tf.exp(z) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">However, when we backprop through the softmax to x, we dont want to backprop
through the tf.reduce_max(x) (if the max values are not unique then the
gradient could flow to the wrong input) calculation and treat that as a
constant. Therefore, we should write this out as</pre></devsite-code> 

<devsite-code></devsite-code>python <p>def stable_softmax(x): z = x - tf.stop_gradient(tf.reduce_max(x)) numerator = tf.exp(z) denominator = tf.reduce_sum(numerator) return numerator / denominator </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Some other examples include:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">*  The *EM* algorithm where the *M-step* should not involve backpropagation
   through the output of the *E-step*.
*  Contrastive divergence training of Boltzmann machines where, when
   differentiating the energy function, the training must not backpropagate
   through the graph that generated the samples from the model.
*  Adversarial training, where no backprop should happen through the adversarial
   example generation process.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class StopGradient {
 public:
  StopGradient(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input input);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Return a strided slice from `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Note, most python users will want to use the Python Tensor.__getitem__
or Variable.__getitem__ rather than this op directly.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The goal of this op is to produce a new tensor with a subset of
the elements from the `n` dimensional `input` tensor. The subset is chosen using
a sequence of `m` sparse range specifications encoded into the arguments
of this function. Note, in some cases
`m` could be equal to `n`, but this need not be the case. Each
range specification entry can be one of the following:</pre></devsite-code> 

<devsite-code>
<ul><li>
<span class="devsite-syntax-n">An</span><span class="devsite-syntax-n">ellipsis</span><span class="devsite-syntax-p">(...).</span><span class="devsite-syntax-n">Ellipses</span><span class="devsite-syntax-n">are</span><span class="devsite-syntax-n">used</span><span class="devsite-syntax-k">to</span><span class="devsite-syntax-n">imply</span><span class="devsite-syntax-n">zero</span><span class="devsite-syntax-k">or</span><span class="devsite-syntax-n">more</span> <span class="devsite-syntax-n">dimensions</span><span class="devsite-syntax-k">of</span><span class="devsite-syntax-k">full</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-n">dimension</span><span class="devsite-syntax-n">selection</span><span class="devsite-syntax-k">and</span><span class="devsite-syntax-n">are</span><span class="devsite-syntax-n">produced</span><span class="devsite-syntax-k">using</span> <span class="devsite-syntax-n devsite-syntax-n-Quoted">`ellipsis_mask`</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-k">For</span><span class="devsite-syntax-n">example</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`foo[...]`</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">the</span><span class="devsite-syntax-n">identity</span><span class="devsite-syntax-n">slice</span><span class="devsite-syntax-p">.</span>
</li></ul></devsite-code> 

<devsite-code>
<ul><li>
<span class="devsite-syntax-n">A</span><span class="devsite-syntax-k">new</span><span class="devsite-syntax-n">axis</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-n">This</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">used</span><span class="devsite-syntax-k">to</span><span class="devsite-syntax-k">insert</span><span class="devsite-syntax-n">a</span><span class="devsite-syntax-k">new</span><span class="devsite-syntax-n">shape</span><span class="devsite-syntax-o">=</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-n">dimension</span><span class="devsite-syntax-k">and</span><span class="devsite-syntax-k">is</span> <span class="devsite-syntax-n">produced</span><span class="devsite-syntax-k">using</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`new_axis_mask`</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-k">For</span><span class="devsite-syntax-n">example</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`foo[:, ...]`</span><span class="devsite-syntax-k">where</span> <span class="devsite-syntax-n devsite-syntax-n-Quoted">`foo`</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">shape</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`(3, 4)`</span><span class="devsite-syntax-n">produces</span><span class="devsite-syntax-n">a</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`(1, 3, 4)`</span><span class="devsite-syntax-n">tensor</span><span class="devsite-syntax-p">.</span>
</li></ul></devsite-code> 

<devsite-code>
<ul><li>
<span class="devsite-syntax-nv">A</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">range</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-p">:</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-p">:</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-nv">This</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">used</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">specify</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">how</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">much</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">choose</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">from</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">a</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">given</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">dimension</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">can</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">be</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">any</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">integer</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">but</span> <span class="devsite-syntax-mf">0.</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">an</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">integer</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">which</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">represents</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">index</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">first</span> <span class="devsite-syntax-nb">val</span><span class="devsite-syntax-s devsite-syntax-s-Atom">ue</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">select</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">while</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">represents</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">index</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">last</span> <span class="devsite-syntax-nb">val</span><span class="devsite-syntax-s devsite-syntax-s-Atom">ue</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">select</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-nv">The</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">number</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-nb">val</span><span class="devsite-syntax-s devsite-syntax-s-Atom">ues</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">selected</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">in</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">each</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">dimension</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span> <span class="devsite-syntax-o">-</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">if</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span> &gt; <span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span> <span class="devsite-syntax-o">-</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">if</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span> &lt; <span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">can</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">be</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">negative</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">where</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">last</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">element</span><span class="devsite-syntax-p">,</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-mi">2</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">second</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">last</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin_mask</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">controls</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">whether</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">replace</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">explicitly</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">given</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">with</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">an</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">implicit</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">effective</span> <span class="devsite-syntax-nb">val</span><span class="devsite-syntax-s devsite-syntax-s-Atom">ue</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">if</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span> &gt; <span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">if</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">stride</span> &lt; <span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end_mask</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">analogous</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">but</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">produces</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">number</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">required</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">create</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">largest</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">open</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">interval</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-nv">For</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">example</span><span class="devsite-syntax-p">,</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">given</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">a</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">shape</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">(</span><span class="devsite-syntax-mi">3</span><span class="devsite-syntax-p">,)</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">tensor</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">foo</span><span class="devsite-syntax-p">[</span><span class="devsite-syntax-o">:</span><span class="devsite-syntax-p">]</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">,</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">effective</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">are</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-mi">3</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-nv">Do</span> <span class="devsite-syntax-o">not</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">assume</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">this</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">equivalent</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">to</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">foo</span><span class="devsite-syntax-p">[</span><span class="devsite-syntax-mi">0</span><span class="devsite-syntax-o">:-</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-p">]</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">which</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">has</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">an</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">effective</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">begin</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">end</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-mi">0</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">and</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-mi">2</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span> <span class="devsite-syntax-nv">Another</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">example</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">foo</span><span class="devsite-syntax-p">[</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-mi">2</span><span class="devsite-syntax-o">::-</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-p">]</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">which</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">reverses</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">first</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">dimension</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">of</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">a</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">tensor</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">while</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">dropping</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">last</span> <span class="devsite-syntax-nf">two</span> <span class="devsite-syntax-p">(</span><span class="devsite-syntax-s devsite-syntax-s-Atom">in</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">the</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">original</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">order</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">elements</span><span class="devsite-syntax-p">).</span> <span class="devsite-syntax-nv">For</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">example</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-s devsite-syntax-s-Atom">foo</span> <span class="devsite-syntax-o">=</span> <span class="devsite-syntax-p">[</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-mi">2</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-mi">3</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-mi">4</span><span class="devsite-syntax-p">];</span> <span class="devsite-syntax-s devsite-syntax-s-Atom">foo</span><span class="devsite-syntax-p">[</span><span class="devsite-syntax-o">-</span><span class="devsite-syntax-mi">2</span><span class="devsite-syntax-o">::-</span><span class="devsite-syntax-mi">1</span><span class="devsite-syntax-p">]</span><span class="devsite-syntax-err">`</span> <span class="devsite-syntax-o">is</span> <span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">[</span><span class="devsite-syntax-mi">4</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-mi">3</span><span class="devsite-syntax-p">]</span><span class="devsite-syntax-err">`</span><span class="devsite-syntax-p">.</span>
</li></ul></devsite-code> 

<devsite-code>
<ul><li>
<span class="devsite-syntax-n">A</span><span class="devsite-syntax-n">single</span><span class="devsite-syntax-k">index</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-n">This</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">used</span><span class="devsite-syntax-k">to</span><span class="devsite-syntax-n">keep</span><span class="devsite-syntax-k">only</span><span class="devsite-syntax-n">elements</span><span class="devsite-syntax-n">that</span><span class="devsite-syntax-n">have</span><span class="devsite-syntax-n">a</span><span class="devsite-syntax-n">given</span> <span class="devsite-syntax-k">index</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-k">For</span><span class="devsite-syntax-n">example</span><span class="devsite-syntax-p">(</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`foo[2, :]`</span><span class="devsite-syntax-k">on</span><span class="devsite-syntax-n">a</span><span class="devsite-syntax-n">shape</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`(5,6)`</span><span class="devsite-syntax-n">tensor</span><span class="devsite-syntax-n">produces</span><span class="devsite-syntax-n">a</span> <span class="devsite-syntax-n">shape</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`(6,)`</span><span class="devsite-syntax-n">tensor</span><span class="devsite-syntax-p">.</span><span class="devsite-syntax-n">This</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">encoded</span><span class="devsite-syntax-k">in</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`begin`</span><span class="devsite-syntax-k">and</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`end`</span><span class="devsite-syntax-k">and</span> <span class="devsite-syntax-n devsite-syntax-n-Quoted">`shrink_axis_mask`</span><span class="devsite-syntax-p">.</span>
</li></ul></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="cplint" data-language="cpp">Each conceptual range specification is encoded in the op's argument. This
encoding is best understand by considering a non-trivial example. In
particular,
`foo[1, 2:4, None, ..., :-3:-1, :]` will be encoded as</pre></devsite-code> 

<devsite-code></devsite-code> begin = [1, 2, x, x, 0, x] # x denotes don't care (usually 0) end = [2, 4, x, x, -3, x] strides = [1, 1, x, x, -1, 1] begin_mask = 1&lt;&lt;4 | 1&lt;&lt;5 = 48 end_mask = 1&lt;&lt;5 = 32 ellipsis_mask = 1&lt;&lt;3 = 8 new_axis_mask = 1&lt;&lt;2 = 4 shrink_axis_mask = 1&lt;&lt;0 = 1 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In this case if foo.shape is (5, 5, 5, 5, 5, 5) the final shape of
the slice becomes (2, 1, 5, 5, 2, 5).
Let us walk step by step through each argument specification.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">1.  The first argument in the example slice is turned into begin = 1 and
end = begin + 1 = 2. To disambiguate from the original spec 2:4 we
also set the appropriate bit in shrink_axis_mask.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">2. 2:4 is contributes 2, 4, 1 to begin, end, and stride. All masks have
zero bits contributed.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">3. None is a synonym for tf.newaxis. This means insert a dimension of size 1
dimension in the final shape. Dummy values are contributed to begin,
end and stride, while the new_axis_mask bit is set.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">4. ... grab the full ranges from as many dimensions as needed to
fully specify a slice for every dimension of the input shape.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="cplint" data-language="cpp">5. :-3:-1 shows the use of negative indices. A negative index i associated
with a dimension that has shape s is converted to a positive index
s + i. So -1 becomes s-1 (i.e. the last element). This conversion
is done internally so begin, end and strides receive x, -3, and -1.
The appropriate begin_mask bit is set to indicate the start range is the
full range (ignoring the x).</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">6. : indicates that the entire contents of the corresponding dimension
is selected. This is equivalent to :: or 0::1. begin, end, and strides
receive 0, 0, and 1, respectively. The appropriate bits in begin_mask and
end_mask are also set.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Requirements:
      0 != strides[i] for i in [0, m)ellipsis_mask must be a power of two (only one ellipsis)</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Args:
* scope: A Scope object
* begin: begin[k] specifies the offset into the kth range specification.
The exact dimension this corresponds to will be determined by context.
Out-of-bounds values will be silently clamped. If the kth bit of
begin_mask then begin[k] is ignored and the full range of the
appropriate dimension is used instead. Negative values causes indexing
to start from the highest element e.g. If foo==[1,2,3] then foo[-1]==3.
* end: end[i] is like begin with the exception that end_mask is
used to determine full ranges.
* strides: strides[i] specifies the increment in the ith specification
after extracting a given element. Negative indices will reverse
the original order. Out or range values are
clamped to [0,dim[i]) if slice[i]&gt;0 or [-1,dim[i]-1] if slice[i] &lt; 0</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">Optional attributes (see Attrs):
* begin_mask: a bitmask where a bit i being 1 means to ignore the begin
value and instead use the largest interval possible. At runtime
begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
[-1, n-1] if stride[i] &lt; 0
* end_mask: analogous to begin_mask
* ellipsis_mask: a bitmask where bit i being 1 means the ith
position is actually an ellipsis. One bit at most can be 1.
If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
implicitly creates as many range specifications as necessary to fully
specify the sliced range for every dimension. For example for a 4-dimensional
tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].
* new_axis_mask: a bitmask where bit i being 1 means the ith
specification creates a new shape 1 dimension. For example
foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.
* shrink_axis_mask: a bitmask where bit i implies that the ith
specification should shrink the dimensionality. begin and end
must imply a slice of size 1 in the dimension. For example in
python one might do foo[:, 3, :] which would result in
shrink_axis_mask being 2.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">    Returns:
    * Output: The output tensor. */
class StridedSlice {
 public:
  /// Optional attribute setters for StridedSlice
  struct Attrs {
    /** a bitmask where a bit i being 1 means to ignore the begin
        value and instead use the largest interval possible. At runtime
        begin[i] will be replaced with [0, n-1) if stride[i] &gt; 0 or
        [-1, n-1] if stride[i] &lt; 0</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
  Attrs ret = *this;
  ret.begin_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** analogous to begin_mask</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">/** a bitmask where bit i being 1 means the ith
    position is actually an ellipsis. One bit at most can be 1.
    If ellipsis_mask == 0, then an implicit ellipsis mask of 1 &lt;&lt; (m+1)
    is provided. This means that foo[3:5] == foo[3:5, ...]. An ellipsis
    implicitly creates as many range specifications as necessary to fully
    specify the sliced range for every dimension. For example for a 4-dimensional
    tensor foo the slice foo[2, ..., 5:8] implies foo[2, :, :, 5:8].</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** a bitmask where bit i being 1 means the ith
    specification creates a new shape 1 dimension. For example
    foo[:4, tf.newaxis, :2] would produce a shape (4, 1, 2) tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">/** a bitmask where bit i implies that the ith
    specification should shrink the dimensionality. begin and end
    must imply a slice of size 1 in the dimension. For example in
    python one might do foo[:, 3, :] which would result in
    shrink_axis_mask being 2.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
           tensorflow::Input begin, tensorflow::Input end,
           tensorflow::Input strides);
StridedSlice(const tensorflow::Scope&amp; scope, tensorflow::Input input,
           tensorflow::Input begin, tensorflow::Input end,
           tensorflow::Input strides, const StridedSlice::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Assignvalue to the sliced l-value reference of ref.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">The values of value are assigned to the positions in the variable
ref that are selected by the slice parameters. The slice parameters
begin, end, strides, etc. work exactly as in StridedSlice.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">NOTE this op currently does not support broadcasting and so value's
shape must be exactly the shape produced by the slice of ref.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">    Returns:
    * Output: The output_ref tensor. */
class StridedSliceAssign {
 public:
  /// Optional attribute setters for StridedSliceAssign
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input value);
StridedSliceAssign(const tensorflow::Scope&amp; scope, tensorflow::Input ref,
                 tensorflow::Input begin, tensorflow::Input end,
                 tensorflow::Input strides, tensorflow::Input value,
                 const StridedSliceAssign::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output_ref; }
operator ::tensorflow::Input() const { return output_ref; }
::tensorflow::Node* node() const { return output_ref.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output_ref;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns the gradient of StridedSlice.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Since StridedSlice cuts out pieces of its input which is size
shape, its gradient will have the same shape (which is passed here
as shape). The gradient will be zero in any element that the slice
does not select.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Arguments are the same as StridedSliceGrad with the exception that
dy is the input gradient to be propagated and shape is the
shape of StridedSlice's input.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">    Returns:
    * Output: The output tensor. */
class StridedSliceGrad {
 public:
  /// Optional attribute setters for StridedSliceGrad
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
               tensorflow::Input begin, tensorflow::Input end,
               tensorflow::Input strides, tensorflow::Input dy);
StridedSliceGrad(const tensorflow::Scope&amp; scope, tensorflow::Input shape,
               tensorflow::Input begin, tensorflow::Input end,
               tensorflow::Input strides, tensorflow::Input dy, const
               StridedSliceGrad::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Adds sparse updates to an existing tensor according to indices.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">This operation creates a new tensor by adding sparse updates to the passed
in tensor.
This operation is very similar to tf.compat.v1.scatter_nd_add, except that the
updates are added onto an existing tensor (as opposed to a variable). If the
memory for the existing tensor cannot be re-used, a copy is made and updated.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">indices is an integer tensor containing indices into a new tensor of shape
    tensor.shape.  The last dimension of indices can be at most the rank of
    tensor.shape:</pre></devsite-code> 

<devsite-code></devsite-code> indices.shape[-1] &lt;= tensor.shape.rank 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The last dimension of `indices` corresponds to indices into elements
(if `indices.shape[-1] = tensor.shape.rank`) or slices
(if `indices.shape[-1] &lt; tensor.shape.rank`) along dimension
`indices.shape[-1]` of `tensor.shape`.  `updates` is a tensor with shape</pre></devsite-code> 

<devsite-code></devsite-code> indices.shape[:-1] + tensor.shape[indices.shape[-1]:] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The simplest form of `tensor_scatter_nd_add` is to add individual elements to a
tensor by index. For example, say we want to add 4 elements in a rank-1
tensor with 8 elements.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter add operation would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML" data-language="cpp">&gt;&gt;&gt; indices = tf.constant([[4], [3], [1], [7]])
&gt;&gt;&gt; updates = tf.constant([9, 10, 11, 12])
&gt;&gt;&gt; tensor = tf.ones([8], dtype=tf.int32)
&gt;&gt;&gt; updated = tf.tensor_scatter_nd_add(tensor, indices, updates)
&gt;&gt;&gt; updated
 1,="" 10,="" 11,="" 12,="" 13],="" dtype="int32)" numpy="array([" shape="(8,),"&gt;</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter add operation would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML" data-language="cpp">&gt;&gt;&gt; indices = tf.constant([[0], [2]])
&gt;&gt;&gt; updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6],
...                         [7, 7, 7, 7], [8, 8, 8, 8]],
...                        [[5, 5, 5, 5], [6, 6, 6, 6],
...                         [7, 7, 7, 7], [8, 8, 8, 8]]])
&gt;&gt;&gt; tensor = tf.ones([4, 4, 4],dtype=tf.int32)
&gt;&gt;&gt; updated = tf.tensor_scatter_nd_add(tensor, indices, updates)
&gt;&gt;&gt; updated
 1,="" 1],="" 1]],="" 1]]],="" 4),="" 4,="" 6,="" 6],="" 7,="" 7],="" 8,="" 8],="" 9,="" 9]],="" [1,="" [7,="" [8,="" [9,="" [[1,="" [[6,="" dtype="int32)" numpy="array([[[6," shape="(4,"&gt;</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Note: on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor and updates added according to the indices. */
class TensorScatterAdd {
 public:
  TensorScatterAdd(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Apply a sparse update to a tensor taking the element-wise maximum.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Returns a new tensor copied from `tensor` whose values are element-wise maximum between
tensor and updates according to the indices.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">&gt;&gt;&gt; tensor = [0, 0, 0, 0, 0, 0, 0, 0]
&gt;&gt;&gt; indices = [[1], [4], [5]]
&gt;&gt;&gt; updates = [1, -1, 1]
&gt;&gt;&gt; tf.tensor_scatter_nd_max(tensor, indices, updates).numpy()
array([0, 1, 0, 0, 0, 1, 0, 0], dtype=int32)</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Refer to tf.tensor_scatter_nd_update for more details.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise maximum between tensor and updates according to the indices. */
class TensorScatterMax {
 public:
  TensorScatterMax(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** TODO: add doc.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor whose values are element-wise minimum between tensor and updates according to the indices. */
class TensorScatterMin {
 public:
  TensorScatterMin(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Subtracts sparse `updates` from an existing tensor according to `indices`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation creates a new tensor by subtracting sparse `updates` from the
passed in `tensor`.
This operation is very similar to `tf.scatter_nd_sub`, except that the updates
are subtracted from an existing tensor (as opposed to a variable). If the memory
for the existing tensor cannot be re-used, a copy is made and updated.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`indices` is an integer tensor containing indices into a new tensor of shape
`shape`.  The last dimension of `indices` can be at most the rank of `shape`:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">indices.shape[-1] &lt;= shape.rank</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The last dimension of `indices` corresponds to indices into elements
(if `indices.shape[-1] = shape.rank`) or slices
(if `indices.shape[-1] &lt; shape.rank`) along dimension `indices.shape[-1]` of
`shape`.  `updates` is a tensor with shape</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="cplint" data-language="cpp">indices.shape[:-1] + shape[indices.shape[-1]:]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Carbon" data-language="cpp">The simplest form of tensor_scatter_sub is to subtract individual elements
from a tensor by index. For example, say we want to insert 4 scattered elements
in a rank-1 tensor with 8 elements.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter subtract operation would look like this:</pre></devsite-code> 

<devsite-code></devsite-code>python indices = tf.constant([[4], [3], [1], [7]]) updates = tf.constant([9, 10, 11, 12]) tensor = tf.ones([8], dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated) 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The resulting tensor would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">[1, -10, 1, -9, -8, 1, 1, -11]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">We can also, insert entire slices of a higher rank tensor all at once. For
example, if we wanted to insert two slices in the first dimension of a
rank-3 tensor with two matrices of new values.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">In Python, this scatter add operation would look like this:</pre></devsite-code> 

<devsite-code></devsite-code>python indices = tf.constant([[0], [2]]) updates = tf.constant([[[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]], [[5, 5, 5, 5], [6, 6, 6, 6], [7, 7, 7, 7], [8, 8, 8, 8]]]) tensor = tf.ones([4, 4, 4],dtype=tf.int32) updated = tf.tensor_scatter_nd_sub(tensor, indices, updates) print(updated) 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">The resulting tensor would look like this:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">[[[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
 [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]],
 [[-4, -4, -4, -4], [-5, -5, -5, -5], [-6, -6, -6, -6], [-7, -7, -7, -7]],
 [[1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1], [1, 1, 1, 1]]]</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Note that on CPU, if an out of bound index is found, an error is returned.
On GPU, if an out of bound index is found, the index is ignored.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor copied from tensor and updates subtracted according to the indices. */
class TensorScatterSub {
 public:
  TensorScatterSub(const tensorflow::Scope&amp; scope, tensorflow::Input tensor,
                 tensorflow::Input indices, tensorflow::Input updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Scatter `updates` into an existing tensor according to `indices`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation creates a new tensor by applying sparse `updates` to the passed
in `tensor`.
This operation is very similar to tf.scatter_nd, except that the updates are
scattered onto an existing tensor (as opposed to a zero-tensor). If the memory
for the existing tensor cannot be re-used, a copy is made and updated.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">If `indices` contains duplicates, then we pick the last update for the index.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">If an out of bound index is found on CPU, an error is returned.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">**WARNING**: There are some GPU specific semantics for this operation.</pre>
<ul>
<li>
<span class="devsite-syntax-k">If</span><span class="devsite-syntax-n">an</span><span class="devsite-syntax-k">out</span><span class="devsite-syntax-k">of</span><span class="devsite-syntax-n">bound</span><span class="devsite-syntax-k">index</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-k">found</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-n">the</span><span class="devsite-syntax-k">index</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">ignored</span><span class="devsite-syntax-p">.</span>
</li>
<li>
<span class="devsite-syntax-n">The</span><span class="devsite-syntax-k">order</span><span class="devsite-syntax-k">in</span><span class="devsite-syntax-n">which</span><span class="devsite-syntax-n">updates</span><span class="devsite-syntax-n">are</span><span class="devsite-syntax-n">applied</span><span class="devsite-syntax-k">is</span><span class="devsite-syntax-n">nondeterministic</span><span class="devsite-syntax-p">,</span><span class="devsite-syntax-n">so</span><span class="devsite-syntax-n">the</span><span class="devsite-syntax-n">output</span> <span class="devsite-syntax-n">will</span><span class="devsite-syntax-n">be</span><span class="devsite-syntax-n">nondeterministic</span><span class="devsite-syntax-k">if</span><span class="devsite-syntax-n devsite-syntax-n-Quoted">`indices`</span><span class="devsite-syntax-k">contains</span><span class="devsite-syntax-n">duplicates</span><span class="devsite-syntax-p">.</span>
</li>
</ul></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">`indices` is an integer tensor containing indices into a new tensor of shape
`shape`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">* `indices` must have at least 2 axes: `(num_updates, index_depth)`.
* The last axis of `indices` is how deep to index into `tensor` so  this index
  depth must be less than the rank of `tensor`: `indices.shape[-1] &lt;= tensor.ndim`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">if `indices.shape[-1] = tensor.rank` this Op indexes and updates scalar elements.
if `indices.shape[-1] &lt; tensor.rank` it indexes and updates slices of the input
`tensor`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Each `update` has a rank of `tensor.rank - indices.shape[-1]`.
The overall shape of `updates` is:</pre></devsite-code> 

<devsite-code></devsite-code> indices.shape[:-1] + tensor.shape[indices.shape[-1]:] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">For usage examples see the python [tf.tensor_scatter_nd_update](
https://www.tensorflow.org/api_docs/python/tf/tensor_scatter_nd_update) function</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* tensor: Tensor to copy/update.
* indices: Index tensor.
* updates: Updates to scatter into output.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: A new tensor with the given shape and updates applied according
    to the indices. */
class TensorScatterUpdate {
 public:
  TensorScatterUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                    tensor, tensorflow::Input indices, tensorflow::Input
                    updates);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Assign `value` to the sliced l-value reference of `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The values of `value` are assigned to the positions in the tensor `input` that
are selected by the slice parameters. The slice parameters `begin` `end`
`strides` etc. work exactly as in `StridedSlice`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">NOTE this op currently does not support broadcasting and so `value`'s shape
must be exactly the shape produced by the slice of `input`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class TensorStridedSliceUpdate {
 public:
  /// Optional attribute setters for TensorStridedSliceUpdate
  struct Attrs {
    /// Defaults to 0
    TF_MUST_USE_RESULT Attrs BeginMask(int64 x) {
      Attrs ret = *this;
      ret.begin_mask_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EndMask(int64 x) {
  Attrs ret = *this;
  ret.end_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs EllipsisMask(int64 x) {
  Attrs ret = *this;
  ret.ellipsis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs NewAxisMask(int64 x) {
  Attrs ret = *this;
  ret.new_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/// Defaults to 0
TF_MUST_USE_RESULT Attrs ShrinkAxisMask(int64 x) {
  Attrs ret = *this;
  ret.shrink_axis_mask_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  int64 begin_mask_ = 0;
  int64 end_mask_ = 0;
  int64 ellipsis_mask_ = 0;
  int64 new_axis_mask_ = 0;
  int64 shrink_axis_mask_ = 0;
};
TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                       input, tensorflow::Input begin, tensorflow::Input
                       end, tensorflow::Input strides, tensorflow::Input
                       value);
TensorStridedSliceUpdate(const tensorflow::Scope&amp; scope, tensorflow::Input
                       input, tensorflow::Input begin, tensorflow::Input
                       end, tensorflow::Input strides, tensorflow::Input
                       value, const TensorStridedSliceUpdate::Attrs&amp; attrs);
operator ::tensorflow::Output() const { return output; }
operator ::tensorflow::Input() const { return output; }
::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs BeginMask(int64 x) {
  return Attrs().BeginMask(x);
}
static Attrs EndMask(int64 x) {
  return Attrs().EndMask(x);
}
static Attrs EllipsisMask(int64 x) {
  return Attrs().EllipsisMask(x);
}
static Attrs NewAxisMask(int64 x) {
  return Attrs().NewAxisMask(x);
}
static Attrs ShrinkAxisMask(int64 x) {
  return Attrs().ShrinkAxisMask(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Constructs a tensor by tiling a given tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation creates a new tensor by replicating `input` `multiples` times.
The output tensor's i'th dimension has `input.dims(i) * multiples[i]` elements,
and the values of `input` are replicated `multiples[i]` times along the 'i'th
dimension. For example, tiling `[a b c d]` by `[2]` produces
`[a b c d a b c d]`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="XML" data-language="cpp">&gt;&gt;&gt; a = tf.constant([[1,2,3],[4,5,6]], tf.int32)
&gt;&gt;&gt; b = tf.constant([1,2], tf.int32)
&gt;&gt;&gt; tf.tile(a, b)
 1,="" 2,="" 3,="" 3],="" 4,="" 5,="" 6),="" 6,="" 6]],="" [4,="" dtype="int32)" numpy="array([[1," shape="(2,"&gt;
&gt;&gt;&gt; c = tf.constant([2,1], tf.int32)
&gt;&gt;&gt; tf.tile(a, c)
 2,="" 3),="" 3],="" 5,="" 6],="" 6]],="" [1,="" [4,="" dtype="int32)" numpy="array([[1," shape="(4,"&gt;
&gt;&gt;&gt; d = tf.constant([2,2], tf.int32)
&gt;&gt;&gt; tf.tile(a, d)
 1,="" 2,="" 3,="" 3],="" 4,="" 5,="" 6),="" 6,="" 6],="" 6]],="" [1,="" [4,="" dtype="int32)" numpy="array([[1," shape="(4,"&gt;</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* input: 1-D or higher.
* multiples: 1-D. Length must be the same as the number of dimensions in `input`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The output tensor. */
class Tile {
 public:
  Tile(const tensorflow::Scope&amp; scope, tensorflow::Input input,
     tensorflow::Input multiples);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Shuffle dimensions of x according to a permutation.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">The output `y` has the same rank as `x`. The shapes of `x` and `y` satisfy:
  `y.shape[i] == x.shape[perm[i]] for i in [0, 1, ..., rank(x) - 1]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: The y tensor. */
class Transpose {
 public:
  Transpose(const tensorflow::Scope&amp; scope, tensorflow::Input x,
          tensorflow::Input perm);
  operator ::tensorflow::Output() const { return y; }
  operator ::tensorflow::Input() const { return y; }
  ::tensorflow::Node* node() const { return y.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output y;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Finds unique elements in a 1-D tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`; `x` does not need to be sorted.
This operation also returns a tensor `idx` the same size as `x` that contains
the index of each value of `x` in the unique output `y`. In other words:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Examples:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]" tabindex="-1">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] </p>

<devsite-code></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[4,-5,-1,-2,-3,-3,-4,-5]" data-text="tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]" tabindex="-1">tensor 'x' is [4, 5, 1, 2, 3, 3, 4, 5]</h1> <p>y, idx = unique(x) y ==&gt; [4, 5, 1, 2, 3] idx ==&gt; [0, 1, 2, 3, 4, 4, 0, 1] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* x: 1-D.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D. */
class Unique {
 public:
  /// Optional attribute setters for Unique
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
Unique(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
Unique(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
     Unique::Attrs&amp; attrs);</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Finds unique elements along an axis of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation either returns a tensor `y` containing unique elements
along the `axis` of a tensor. The returned unique elements is sorted
in the same order as they occur along `axis` in `x`.
This operation also returns a tensor `idx` that is the same size as
the number of the elements in `x` along the `axis` dimension. It
contains the index in the unique output `y`.
In other words, for an `1-D` tensor `x` with `axis = None:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]_1" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]" tabindex="-1">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx = unique(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">For an `2-D` tensor `x` with `axis = 0`:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[[1,-0,-0]," data-text="tensor 'x' is [[1, 0, 0]," tabindex="-1">tensor 'x' is [[1, 0, 0],</h1> 
<h1 id="[1,-0,-0]," data-text="[1, 0, 0]," tabindex="-1">[1, 0, 0],</h1> 
<h1 id="[2,-0,-0]]" data-text="[2, 0, 0]]" tabindex="-1">[2, 0, 0]]</h1> <p>y, idx = unique(x, axis=0) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">For an `2-D` tensor `x` with `axis = 1`:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[[1,-0,-0],_1" data-text="tensor 'x' is [[1, 0, 0]," tabindex="-1">tensor 'x' is [[1, 0, 0],</h1> 
<h1 id="[1,-0,-0],_1" data-text="[1, 0, 0]," tabindex="-1">[1, 0, 0],</h1> 
<h1 id="[2,-0,-0]]_1" data-text="[2, 0, 0]]" tabindex="-1">[2, 0, 0]]</h1> <p>y, idx = unique(x, axis=1) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* x: A `Tensor`.
* axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
find the unique elements.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y. */
class UniqueV2 {
 public:
  /// Optional attribute setters for UniqueV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
       tensorflow::Input axis);
UniqueV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
       tensorflow::Input axis, const UniqueV2::Attrs&amp; attrs);</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Finds unique elements in a 1-D tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns a tensor `y` containing all of the unique elements of `x`
sorted in the same order that they occur in `x`. This operation also returns a
tensor `idx` the same size as `x` that contains the index of each value of `x`
in the unique output `y`. Finally, it returns a third tensor `count` that
contains the count of each element of `y` in `x`. In other words:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="tensor-x-is-[1,-1,-2,-4,-4,-4,-7,-8,-8]_2" data-text="tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]" tabindex="-1">tensor 'x' is [1, 1, 2, 4, 4, 4, 7, 8, 8]</h1> <p>y, idx, count = unique_with_counts(x) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">Args:
* scope: A Scope object
* x: 1-D.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output` y: 1-D.
    * `Output` idx: 1-D.
    * `Output` count: 1-D. */
class UniqueWithCounts {
 public:
  /// Optional attribute setters for UniqueWithCounts
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueWithCounts(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input x);
UniqueWithCounts(const tensorflow::Scope&amp; scope, tensorflow::Input x, const
               UniqueWithCounts::Attrs&amp; attrs);</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Finds unique elements along an axis of a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation either returns a tensor `y` containing unique elements
along the `axis` of a tensor. The returned unique elements is sorted
in the same order as they occur along `axis` in `x`.
This operation also returns a tensor `idx` and a tensor `count`
that are the same size as the number of the elements in `x` along the
`axis` dimension. The `idx` contains the index in the unique output `y`
and the `count` contains the count in the unique output `y`.
In other words, for an `1-D` tensor `x` with `axis = None:</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">`y[idx[i]] = x[i] for i in [0, 1,...,rank(x) - 1]`</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> x = tf.constant([1, 1, 2, 4, 4, 4, 7, 8, 8]) y, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis = [0]) y ==&gt; [1, 2, 4, 7, 8] idx ==&gt; [0, 0, 1, 2, 2, 2, 3, 4, 4] count ==&gt; [2, 1, 3, 1, 2] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">For a `2-D` tensor `x` with `axis = 0`:</pre></devsite-code> 

<devsite-code></devsite-code> x = tf.constant([[1, 0, 0], [1, 0, 0], [2, 0, 0]]) y, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis=[0]) y ==&gt; [[1, 0, 0], [2, 0, 0]] idx ==&gt; [0, 0, 1] count ==&gt; [2, 1] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">For a `2-D` tensor `x` with `axis = 1`:</pre></devsite-code> 

<devsite-code></devsite-code> x = tf.constant([[1, 0, 0], [1, 0, 0], [2, 0, 0]]) y, idx, count = tf.raw_ops.UniqueWithCountsV2(x=x, axis=[1]) y ==&gt; [[1, 0], [1, 0], [2, 0]] idx ==&gt; [0, 1, 1] count ==&gt; [1, 2] 
<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* x: A `Tensor`.
* axis: A `Tensor` of type `int32` (default: None). The axis of the Tensor to
find the unique elements.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output` y: A `Tensor`. Unique elements along the `axis` of `Tensor` x.
    * `Output` idx: A 1-D Tensor. Has the same type as x that contains the index of each
    value of x in the output y.
    * `Output` count: A 1-D Tensor. The count of each value of x in the output y. */
class UniqueWithCountsV2 {
 public:
  /// Optional attribute setters for UniqueWithCountsV2
  struct Attrs {
    /// Defaults to DT_INT32
    TF_MUST_USE_RESULT Attrs OutIdx(DataType x) {
      Attrs ret = *this;
      ret.out_idx_ = x;
      return ret;
    }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">  DataType out_idx_ = DT_INT32;
};
UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                 tensorflow::Input axis);
UniqueWithCountsV2(const tensorflow::Scope&amp; scope, tensorflow::Input x,
                 tensorflow::Input axis, const UniqueWithCountsV2::Attrs&amp;
                 attrs);</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs OutIdx(DataType x) {
  return Attrs().OutIdx(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output y;
  tensorflow::Output idx;
  tensorflow::Output count;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">/** Unpacks a given dimension of a rank-`R` tensor into `num` rank-`(R-1)` tensors.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Unpacks `num` tensors from `value` by chipping it along the `axis` dimension.
For example, given a tensor of shape `(A, B, C, D)`;</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">If `axis == 0` then the i'th tensor in `output` is the slice `value[i, :, :, :]`
  and each tensor in `output` will have shape `(B, C, D)`. (Note that the
  dimension unpacked along is gone, unlike `split`).</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">If `axis == 1` then the i'th tensor in `output` is the slice `value[:, i, :, :]`
  and each tensor in `output` will have shape `(A, C, D)`.
Etc.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This is the opposite of `pack`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* value: 1-D or higher, with `axis` dimension size equal to `num`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Optional attributes (see `Attrs`):
* axis: Dimension along which to unpack.  Negative values wrap around, so the
valid range is `[-R, R)`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `OutputList`: The list of tensors unpacked from `value`. */
class Unstack {
 public:
  /// Optional attribute setters for Unstack
  struct Attrs {
    /** Dimension along which to unpack.  Negative values wrap around, so the
        valid range is `[-R, R)`.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">    Defaults to 0 */
TF_MUST_USE_RESULT Attrs Axis(int64 x) {
  Attrs ret = *this;
  ret.axis_ = x;
  return ret;
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Transact-SQL" data-language="cpp">  int64 axis_ = 0;
};
Unstack(const ::tensorflow::Scope&amp; scope, ::tensorflow::Input value, int64 num);
Unstack(const tensorflow::Scope&amp; scope, tensorflow::Input value, int64 num,
      const Unstack::Attrs&amp; attrs);
tensorflow::Output operator[](size_t index) const { return output[index]; }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">static Attrs Axis(int64 x) {
  return Attrs().Axis(x);
}</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  ::tensorflow::OutputList output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Converts an array of flat indices into a tuple of coordinate arrays.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Example:</pre></devsite-code> 

<devsite-code></devsite-code> y = tf.unravel_index(indices=[2, 5, 7], dims=[3, 3]) <h1 id="dims-represent-a-hypothetical-3,-3-tensor-of-indices:" data-text="'dims' represent a hypothetical (3, 3) tensor of indices:" tabindex="-1">'dims' represent a hypothetical (3, 3) tensor of indices:</h1> 
<h1 id="[[0,-1,-2]," data-text="[[0, 1, 2]," tabindex="-1">[[0, 1, <i>2</i>],</h1> 
<h1 id="[3,-4,-5]," data-text="[3, 4, 5]," tabindex="-1">[3, 4, <i>5</i>],</h1> 
<h1 id="[6,-7,-8]]" data-text="[6, 7, 8]]" tabindex="-1">[6, <i>7</i>, 8]]</h1> 
<h1 id="for-each-entry-from-indices,-this-operation-returns" data-text="For each entry from 'indices', this operation returns" tabindex="-1">For each entry from 'indices', this operation returns</h1> 
<h1 id="its-coordinates-marked-with-,-such-as" data-text="its coordinates (marked with '*'), such as" tabindex="-1">its coordinates (marked with '*'), such as</h1> 
<h1 id="2-==-0,-2" data-text="2 ==&gt; (0, 2)" tabindex="-1">2 ==&gt; (0, 2)</h1> 
<h1 id="5-==-1,-2" data-text="5 ==&gt; (1, 2)" tabindex="-1">5 ==&gt; (1, 2)</h1> 
<h1 id="7-==-2,-1" data-text="7 ==&gt; (2, 1)" tabindex="-1">7 ==&gt; (2, 1)</h1> <p>y ==&gt; [[0, 1, 2], [2, 2, 1]] </p>

<devsite-code></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="scdoc" data-language="cpp">(numpy)
Equivalent to np.unravel_index
</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">Args:
* scope: A Scope object
* indices: An 0-D or 1-D `int` Tensor whose elements are indices into the
flattened version of an array of dimensions dims.
* dims: An 1-D `int` Tensor. The shape of the array to use for unraveling
indices.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">    Returns:
    * `Output`: An 2-D (or 1-D if indices is 0-D) tensor where each row has the
    same shape as the indices array. */
class UnravelIndex {
 public:
  UnravelIndex(const tensorflow::Scope&amp; scope, tensorflow::Input indices,
             tensorflow::Input dims);
  operator ::tensorflow::Output() const { return output; }
  operator ::tensorflow::Input() const { return output; }
  ::tensorflow::Node* node() const { return output.node(); }</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="CSS+Lasso" data-language="cpp">Operation operation;
  tensorflow::Output output;
};</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Scilab" data-language="cpp">/** Returns locations of nonzero / true values in a tensor.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="MySQL" data-language="cpp">This operation returns the coordinates of true elements in `condition`. The
coordinates are returned in a 2-D tensor where the first dimension (rows)
represents the number of true elements, and the second dimension (columns)
represents the coordinates of the true elements. Keep in mind, the shape of
the output tensor can vary depending on how many true values there are in
`condition`. Indices are output in row-major order.</pre></devsite-code> 

<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">For example:</pre></devsite-code> 

<devsite-code></devsite-code> <h1 id="input-tensor-is-[[true,-false]" data-text="'input' tensor is [[True, False]" tabindex="-1">'input' tensor is [[True, False]</h1> 
<h1 id="[true,-false]]" data-text="[True, False]]" tabindex="-1">[True, False]]</h1> 
<h1 id="input-has-two-true-values,-so-output-has-two-coordinates." data-text="'input' has two true values, so output has two coordinates." tabindex="-1">'input' has two true values, so output has two coordinates.</h1> 
<h1 id="input-has-rank-of-2,-so-coordinates-have-two-indices." data-text="'input' has rank of 2, so coordinates have two indices." tabindex="-1">'input' has rank of 2, so coordinates have two indices.</h1> <p>where(input) ==&gt; [[0, 0], [1, 0]]</p> 
<h1 id="condition-tensor-is-[[[true,-false]" data-text="condition tensor is [[[True, False]" tabindex="-1">
<code translate="no" dir="ltr">condition</code> tensor is [[[True, False]</h1> 
<h1 id="[true,-false]]_1" data-text="[True, False]]" tabindex="-1">[True, False]]</h1> 
<h1 id="[[false,-true]" data-text="[[False, True]" tabindex="-1">[[False, True]</h1> 
<h1 id="[false,-true]]" data-text="[False, True]]" tabindex="-1">[False, True]]</h1> 
<h1 id="[[false,-false]" data-text="[[False, False]" tabindex="-1">[[False, False]</h1> 
<h1 id="[false,-true]]]" data-text="[False, True]]]" tabindex="-1">[False, True]]]</h1> 
<h1 id="input-has-5-true-values,-so-output-has-5-coordinates." data-text="'input' has 5 true values, so output has 5 coordinates." tabindex="-1">'input' has 5 true values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices." data-text="'input' has rank of 3, so coordinates have three indices." tabindex="-1">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]</p> 
<h1 id="condition-tensor-is-[[[1.5,-0.0]" data-text="condition tensor is [[[1.5, 0.0]" tabindex="-1">
<code translate="no" dir="ltr">condition</code> tensor is [[[1.5, 0.0]</h1> 
<h1 id="[-0.5,-0.0]]" data-text="[-0.5, 0.0]]" tabindex="-1">[-0.5, 0.0]]</h1> 
<h1 id="[[0.0,-0.25]" data-text="[[0.0, 0.25]" tabindex="-1">[[0.0, 0.25]</h1> 
<h1 id="[0.0,-0.75]]" data-text="[0.0, 0.75]]" tabindex="-1">[0.0, 0.75]]</h1> 
<h1 id="[[0.0,-0.0]" data-text="[[0.0, 0.0]" tabindex="-1">[[0.0, 0.0]</h1> 
<h1 id="[0.0,-0.01]]]" data-text="[0.0, 0.01]]]" tabindex="-1">[0.0, 0.01]]]</h1> 
<h1 id="input-has-5-nonzero-values,-so-output-has-5-coordinates." data-text="'input' has 5 nonzero values, so output has 5 coordinates." tabindex="-1">'input' has 5 nonzero values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices._1" data-text="'input' has rank of 3, so coordinates have three indices." tabindex="-1">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]]</p> 
<h1 id="condition-tensor-is-[[[1.5-+-0.0j,-0.0-+-0.0j]" data-text="condition tensor is [[[1.5 + 0.0j, 0.0 + 0.0j]" tabindex="-1">
<code translate="no" dir="ltr">condition</code> tensor is [[[1.5 + 0.0j, 0.0 + 0.0j]</h1> 
<h1 id="[0.0-+-0.5j,-0.0-+-0.0j]]" data-text="[0.0 + 0.5j, 0.0 + 0.0j]]" tabindex="-1">[0.0 + 0.5j, 0.0 + 0.0j]]</h1> 
<h1 id="[[0.0-+-0.0j,-0.25-+-1.5j]" data-text="[[0.0 + 0.0j, 0.25 + 1.5j]" tabindex="-1">[[0.0 + 0.0j, 0.25 + 1.5j]</h1> 
<h1 id="[0.0-+-0.0j,-0.75-+-0.0j]]" data-text="[0.0 + 0.0j, 0.75 + 0.0j]]" tabindex="-1">[0.0 + 0.0j, 0.75 + 0.0j]]</h1> 
<h1 id="[[0.0-+-0.0j,-0.0-+-0.0j]" data-text="[[0.0 + 0.0j, 0.0 + 0.0j]" tabindex="-1">[[0.0 + 0.0j, 0.0 + 0.0j]</h1> 
<h1 id="[0.0-+-0.0j,-0.01-+-0.0j]]]" data-text="[0.0 + 0.0j, 0.01 + 0.0j]]]" tabindex="-1">[0.0 + 0.0j, 0.01 + 0.0j]]]</h1> 
<h1 id="input-has-5-nonzero-magnitude-values,-so-output-has-5-coordinates." data-text="'input' has 5 nonzero magnitude values, so output has 5 coordinates." tabindex="-1">'input' has 5 nonzero magnitude values, so output has 5 coordinates.</h1> 
<h1 id="input-has-rank-of-3,-so-coordinates-have-three-indices._2" data-text="'input' has rank of 3, so coordinates have three indices." tabindex="-1">'input' has rank of 3, so coordinates have three indices.</h1> <p>where(input) ==&gt; [[0, 0, 0], [0, 1, 0], [1, 0, 1], [1, 1, 1], [2, 1, 1]] ```</p> <p>Args:</p>
<ul> <li>scope: A <a href="../scope.html#classtensorflow_1_1_scope">Scope</a> object</li> </ul> <p>Returns:</p>
<ul> <li>
<code translate="no" dir="ltr"><a href="../output.html#classtensorflow_1_1_output">Output</a></code>: The index tensor. </li> </ul> <table class="constructors responsive"> <tr> <th colspan="2"> Constructors and Destructors </th> </tr> <tr> <td colspan="2"> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de">Where</a>(const ::<a href="../scope.html#classtensorflow_1_1_scope">tensorflow::Scope</a> &amp; scope, ::<a href="../input.html#classtensorflow_1_1_input">tensorflow::Input</a> condition)</code> <br> </td> </tr> </table> <table class="properties responsive"> <tr> <th colspan="2"> Public attributes </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d">index</a></code> </td> <td> <div> <code translate="no" dir="ltr">::<a href="../output.html#classtensorflow_1_1_output">tensorflow::Output</a></code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296">operation</a></code> </td> <td> <div> <code translate="no" dir="ltr"><a href="../operation.html#classtensorflow_1_1_operation">Operation</a></code> </div> </td> </tr> </table> <table class="methods responsive"> <tr> <th colspan="2"> Public functions </th> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4">node</a>() const </code> </td> <td> <div> <code translate="no" dir="ltr">::tensorflow::Node *</code> </div> </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91">operator::tensorflow::Input</a>() const </code> </td> <td>  </td> </tr> <tr> <td> <code translate="no" dir="ltr"><a href="#classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345">operator::tensorflow::Output</a>() const </code> </td> <td>  </td> </tr> </table> <h2 id="public-attributes_1" data-text="Public attributes" tabindex="-1">Public attributes</h2> <div id="classtensorflow_1_1ops_1_1_where_1aa3b91b7d267d5cee38568a7d1f97647d"> <h3 id="index" data-text="index" tabindex="-1">index</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">::tensorflow::Output index</pre></devsite-code>  </div> <div id="classtensorflow_1_1ops_1_1_where_1ad713509ff4e38a2f5241d9b2cee7b296"> <h3 id="operation" data-text="operation" tabindex="-1">operation</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="Text only" data-language="cpp">Operation operation</pre></devsite-code>  </div> <h2 id="public-functions_1" data-text="Public functions" tabindex="-1">Public functions</h2> <div id="classtensorflow_1_1ops_1_1_where_1a3e4c07125f4b04d6f3a0f99a616273de"> <h3 id="where" data-text="Where" tabindex="-1">Where</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp"> Where(
  const ::tensorflow::Scope &amp; scope,
  ::tensorflow::Input condition
)</pre></devsite-code>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a76eb69d2e854554e8ae583dba19f1df4"> <h3 id="node" data-text="node" tabindex="-1">node</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">::tensorflow::Node * node() const </pre></devsite-code>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a80da544c59726a48be37767fb8fe3c91"> <h3 id="operator::tensorflow::input" data-text="operator::tensorflow::Input" tabindex="-1">operator::tensorflow::Input</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">operator::tensorflow::Input() const </pre></devsite-code>  </div> <div id="classtensorflow_1_1ops_1_1_where_1a5662e0fc5b2303a6072fb9aba2cec345"> <h3 id="operator::tensorflow::output" data-text="operator::tensorflow::Output" tabindex="-1">operator::tensorflow::Output</h3> 
<devsite-code><pre class="devsite-click-to-copy" translate="no" dir="ltr" is-upgraded syntax="GDScript" data-language="cpp">operator::tensorflow::Output() const </pre></devsite-code>  </div>  <devsite-thumb-rating position="footer"> </devsite-thumb-rating> <div class="_attribution">
  <p class="_attribution-p">
    &copy; 2022 The TensorFlow Authors. All rights reserved.<br>Licensed under the Creative Commons Attribution License 4.0.<br>Code samples licensed under the Apache 2.0 License.<br>
    <a href="https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/where" class="_attribution-link">https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/where</a>
  </p>
</div>
