<header><h1>Components (experimental)</h1></header><h2 id="introduction">Introduction<a href="#introduction" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a>
</h2> <p>Playwright Test can now test your components.</p>  <h2 id="example">Example<a href="#example" aria-label="Direct link to Example" title="Direct link to Example">​</a>
</h2> <p>Here is what a typical component test looks like:</p> <pre tabindex="0" data-language="javascript">test('event should work', async ({ mount }) =&gt; {
  let clicked = false;

  // Mount a component. Returns locator pointing to the component.
  const component = await mount(
    &lt;Button title="Submit" onClick={() =&gt; { clicked = true }}&gt;&lt;/Button&gt;
  );

  // As with any Playwright test, assert locator text.
  await expect(component).toContainText('Submit');

  // Perform locator click. This will trigger the event.
  await component.click();

  // Assert that respective events have been fired.
  expect(clicked).toBeTruthy();
});</pre> <h2 id="how-to-get-started">How to get started<a href="#how-to-get-started" aria-label="Direct link to How to get started" title="Direct link to How to get started">​</a>
</h2> <p>Adding Playwright Test to an existing project is easy. Below are the steps to enable Playwright Test for a React, Vue, Svelte or Solid project.</p> <h3 id="step-1-install-playwright-test-for-components-for-your-respective-framework">Step 1: Install Playwright Test for components for your respective framework<a href="#step-1-install-playwright-test-for-components-for-your-respective-framework" aria-label="Direct link to Step 1: Install Playwright Test for components for your respective framework" title="Direct link to Step 1: Install Playwright Test for components for your respective framework">​</a>
</h3> <div>
<ul role="tablist" aria-orientation="horizontal">
<li role="tab" tabindex="0" aria-selected="true">npm</li>
<li role="tab" tabindex="-1" aria-selected="false">yarn</li>
<li role="tab" tabindex="-1" aria-selected="false">pnpm</li>
</ul>
<div>
<div role="tabpanel"><pre tabindex="0" data-language="javascript">npm init playwright@latest -- --ct</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">yarn create playwright --ct</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">pnpm create playwright --ct</pre></div>
</div>
</div> <p>This step creates several files in your workspace:</p> <pre tabindex="0" data-language="html">&lt;html lang="en"&gt;
  &lt;body&gt;
    &lt;div id="root"&gt;&lt;/div&gt;
    &lt;script type="module" src="./index.ts"&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre> <p>This file defines an html file that will be used to render components during testing. It must contain element with <code>id="root"</code>, that's where components are mounted. It must also link the script called <code>playwright/index.{js,ts,jsx,tsx}</code>.</p> <p>You can include stylesheets, apply theme and inject code into the page where component is mounted using this script. It can be either a <code>.js</code>, <code>.ts</code>, <code>.jsx</code> or <code>.tsx</code> file.</p> <pre tabindex="0" data-language="javascript">// Apply theme here, add anything your component needs at runtime here.</pre> <h3 id="step-2-create-a-test-file-srcappspectstsx">Step 2. Create a test file <code>src/App.spec.{ts,tsx}</code><a href="#step-2-create-a-test-file-srcappspectstsx" aria-label="Direct link to step-2-create-a-test-file-srcappspectstsx" title="Direct link to step-2-create-a-test-file-srcappspectstsx">​</a>
</h3> <div>
<ul role="tablist" aria-orientation="horizontal">
<li role="tab" tabindex="0" aria-selected="true">React</li>
<li role="tab" tabindex="-1" aria-selected="false">Solid</li>
<li role="tab" tabindex="-1" aria-selected="false">Svelte</li>
<li role="tab" tabindex="-1" aria-selected="false">Vue</li>
</ul>
<div>
<div role="tabpanel"><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-react';
import App from './App';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(&lt;App /&gt;);
  await expect(component).toContainText('Learn React');
});</pre></div>
<div role="tabpanel" hidden="">
<pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-vue';
import App from './App.vue';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(App);
  await expect(component).toContainText('Vite + Vue');
});</pre>
<p>If using TypeScript and Vue make sure to add a <code>vue.d.ts</code> file to your project:</p>
<pre tabindex="0" data-language="javascript">declare module '*.vue';</pre>
</div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-svelte';
import App from './App.svelte';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(App);
  await expect(component).toContainText('Vite + Svelte');
});</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-solid';
import App from './App';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(&lt;App /&gt;);
  await expect(component).toContainText('Learn Solid');
});</pre></div>
</div>
</div> <h3 id="step-3-run-the-tests">Step 3. Run the tests<a href="#step-3-run-the-tests" aria-label="Direct link to Step 3. Run the tests" title="Direct link to Step 3. Run the tests">​</a>
</h3> <p>You can run tests using the <a href="getting-started-vscode.html">VS Code extension</a> or the command line.</p> <pre tabindex="0" data-language="javascript">npm run test-ct</pre> <h3 id="further-reading-configure-reporting-browsers-tracing">Further reading: configure reporting, browsers, tracing<a href="#further-reading-configure-reporting-browsers-tracing" aria-label="Direct link to Further reading: configure reporting, browsers, tracing" title="Direct link to Further reading: configure reporting, browsers, tracing">​</a>
</h3> <p>Refer to <a href="test-configuration.html">Playwright config</a> for configuring your project.</p> <h2 id="test-stories">Test stories<a href="#test-stories" aria-label="Direct link to Test stories" title="Direct link to Test stories">​</a>
</h2> <p>When Playwright Test is used to test web components, tests run in Node.js, while components run in the real browser. This brings together the best of both worlds: components run in the real browser environment, real clicks are triggered, real layout is executed, visual regression is possible. At the same time, test can use all the powers of Node.js as well as all the Playwright Test features. As a result, the same parallel, parametrized tests with the same post-mortem Tracing story are available during component testing.</p> <p>This however, is introducing a number of limitations:</p> <ul> <li>You can't pass complex live objects to your component. Only plain JavaScript objects and built-in types like strings, numbers, dates etc. can be passed.</li> </ul> <pre tabindex="0" data-language="javascript">test('this will work', async ({ mount }) =&gt; {
  const component = await mount(&lt;ProcessViewer process={{ name: 'playwright' }}/&gt;);
});

test('this will not work', async ({ mount }) =&gt; {
  // `process` is a Node object, we can't pass it to the browser and expect it to work.
  const component = await mount(&lt;ProcessViewer process={process}/&gt;);
});</pre> <ul> <li>You can't pass data to your component synchronously in a callback:</li> </ul> <pre tabindex="0" data-language="javascript">test('this will not work', async ({ mount }) =&gt; {
  // () =&gt; 'red' callback lives in Node. If `ColorPicker` component in the browser calls the parameter function
  // `colorGetter` it won't get result synchronously. It'll be able to get it via await, but that is not how
  // components are typically built.
  const component = await mount(&lt;ColorPicker colorGetter={() =&gt; 'red'}/&gt;);
});</pre> <p>Working around these and other limitations is quick and elegant: for every use case of the tested component, create a wrapper of this component designed specifically for test. Not only it will mitigate the limitations, but it will also offer powerful abstractions for testing where you would be able to define environment, theme and other aspects of your component rendering.</p> <p>Let's say you'd like to test following component:</p> <pre tabindex="0" data-language="javascript">import React from 'react';

export const InputMedia: React.FC&lt;{
  // Media is a complex browser object we can't send to Node while testing.
  onChange: (media: Media) =&gt; void,
}&gt; = ({ onChange }) =&gt; {
  return &lt;&gt;&lt;/&gt; as any;
};</pre> <p>Create a story file for your component:</p> <pre tabindex="0" data-language="javascript">import React from 'react';
import InputMedia from './import-media';

export const InputMediaForTest: React.FC&lt;{
  onMediaChange: (mediaName: string) =&gt; void,
}&gt; = ({ onMediaChange }) =&gt; {
  // Instead of sending a complex `media` object to the test, send the media name.
  return &lt;InputMedia onChange={media =&gt; onMediaChange(media.name)} /&gt;;
};
// Export more stories here.</pre> <p>Then test the component via testing the story:</p> <pre tabindex="0" data-language="javascript">test('changes the image', async ({ mount }) =&gt; {
  let mediaSelected: string | null = null;

  const component = await mount(
    &lt;InputMediaForTest
      onMediaChange={mediaName =&gt; {
        mediaSelected = mediaName;
        console.log({ mediaName });
      }}
    /&gt;
  );
  await component
    .getByTestId('imageInput')
    .setInputFiles('src/assets/logo.png');

  await expect(component.getByAltText(/selected image/i)).toBeVisible();
  await expect.poll(() =&gt; mediaSelected).toBe('logo.png');
});</pre> <p>As a result, for every component you'll have a story file that exports all the stories that are actually tested. These stories live in the browser and "convert" complex object into the simple objects that can be accessed in the test.</p> <h2 id="hooks">Hooks<a href="#hooks" aria-label="Direct link to Hooks" title="Direct link to Hooks">​</a>
</h2> <p>You can use <code>beforeMount</code> and <code>afterMount</code> hooks to configure your app. This lets you setup things like your app router, fake server etc. giving you the flexibility you need. You can also pass custom configuration from the <code>mount</code> call from a test, which is accessible from the <code>hooksConfig</code> fixture. This includes any config that needs to be run before or after mounting the component. An example of configuring a router is provided below:</p> <div>
<ul role="tablist" aria-orientation="horizontal">
<li role="tab" tabindex="0" aria-selected="true">React</li>
<li role="tab" tabindex="-1" aria-selected="false">Solid</li>
<li role="tab" tabindex="-1" aria-selected="false">Vue3</li>
<li role="tab" tabindex="-1" aria-selected="false">Vue2</li>
</ul>
<div>
<div role="tabpanel">
<pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-react/hooks';
import { BrowserRouter } from 'react-router-dom';

export type HooksConfig = {
  enableRouting?: boolean;
}

beforeMount&lt;HooksConfig&gt;(async ({ App, hooksConfig }) =&gt; {
  if (hooksConfig?.enableRouting)
    return &lt;BrowserRouter&gt;&lt;App /&gt;&lt;/BrowserRouter&gt;;
});</pre>
<pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-react';
import type { HooksConfig } from '@playwright/test';
import { ProductsPage } from './pages/ProductsPage';

test('configure routing through hooks config', async ({ page, mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(&lt;ProductsPage /&gt;, {
    hooksConfig: { enableRouting: true },
  });
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');
});</pre>
</div>
<div role="tabpanel" hidden="">
<pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-solid/hooks';
import { Router } from '@solidjs/router';

export type HooksConfig = {
  enableRouting?: boolean;
}

beforeMount&lt;HooksConfig&gt;(async ({ App, hooksConfig }) =&gt; {
  if (hooksConfig?.enableRouting)
    return &lt;Router&gt;&lt;App /&gt;&lt;/Router&gt;;
});</pre>
<pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-solid';
import type { HooksConfig } from '@playwright/test';
import { ProductsPage } from './pages/ProductsPage';

test('configure routing through hooks config', async ({ page, mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(&lt;ProductsPage /&gt;, {
    hooksConfig: { enableRouting: true },
  });
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');
});</pre>
</div>
<div role="tabpanel" hidden="">
<pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-vue/hooks';
import { router } from '../src/router';

export type HooksConfig = {
  enableRouting?: boolean;
}

beforeMount&lt;HooksConfig&gt;(async ({ app, hooksConfig }) =&gt; {
  if (hooksConfig?.enableRouting)
    app.use(router);
});</pre>
<pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-vue';
import type { HooksConfig } from '@playwright/test';
import ProductsPage from './pages/ProductsPage.vue';

test('configure routing through hooks config', async ({ page, mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(ProductsPage, {
    hooksConfig: { enableRouting: true },
  });
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');
});</pre>
</div>
<div role="tabpanel" hidden="">
<pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-vue2/hooks';
import Router from 'vue-router';
import { router } from '../src/router';

export type HooksConfig = {
  enableRouting?: boolean;
}

beforeMount&lt;HooksConfig&gt;(async ({ app, hooksConfig }) =&gt; {
  if (hooksConfig?.enableRouting) {
    Vue.use(Router);
    return { router }
  }
});</pre>
<pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-vue2';
import type { HooksConfig } from '@playwright/test';
import ProductsPage from './pages/ProductsPage.vue';

test('configure routing through hooks config', async ({ page, mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(ProductsPage, {
    hooksConfig: { enableRouting: true },
  });
  await expect(component.getByRole('link')).toHaveAttribute('href', '/products/42');
});</pre>
</div>
</div>
</div> <h2 id="under-the-hood">Under the hood<a href="#under-the-hood" aria-label="Direct link to Under the hood" title="Direct link to Under the hood">​</a>
</h2> <p>Here is how component testing works:</p> <ul> <li>Once the tests are executed, Playwright creates a list of components that the tests need.</li> <li>It then compiles a bundle that includes these components and serves it using a local static web server.</li> <li>Upon the <code>mount</code> call within the test, Playwright navigates to the facade page <code>/playwright/index.html</code> of this bundle and tells it to render the component.</li> <li>Events are marshalled back to the Node.js environment to allow verification.</li> </ul> <p>Playwright is using <a href="https://vitejs.dev/" target="_blank" rel="noopener noreferrer">Vite</a> to create the components bundle and serve it.</p> <h2 id="frequently-asked-questions">Frequently asked questions<a href="#frequently-asked-questions" aria-label="Direct link to Frequently asked questions" title="Direct link to Frequently asked questions">​</a>
</h2> <h3 id="whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid">What's the difference between <code>@playwright/test</code> and <code>@playwright/experimental-ct-{react,svelte,vue,solid}</code>?<a href="#whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid" aria-label="Direct link to whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid" title="Direct link to whats-the-difference-between-playwrighttest-and-playwrightexperimental-ct-reactsveltevuesolid">​</a>
</h3> <pre tabindex="0" data-language="javascript">test('…', async ({ mount, page, context }) =&gt; {
  // …
});</pre> <p><code>@playwright/experimental-ct-{react,svelte,vue,solid}</code> wrap <code>@playwright/test</code> to provide an additional built-in component-testing specific fixture called <code>mount</code>:</p> <div>
<ul role="tablist" aria-orientation="horizontal">
<li role="tab" tabindex="0" aria-selected="true">React</li>
<li role="tab" tabindex="-1" aria-selected="false">Solid</li>
<li role="tab" tabindex="-1" aria-selected="false">Svelte</li>
<li role="tab" tabindex="-1" aria-selected="false">Vue</li>
</ul>
<div>
<div role="tabpanel"><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-react';
import HelloWorld from './HelloWorld';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(&lt;HelloWorld msg="greetings" /&gt;);
  await expect(component).toContainText('Greetings');
});</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-vue';
import HelloWorld from './HelloWorld.vue';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(HelloWorld, {
    props: {
      msg: 'Greetings',
    },
  });
  await expect(component).toContainText('Greetings');
});</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-svelte';
import HelloWorld from './HelloWorld.svelte';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(HelloWorld, {
    props: {
      msg: 'Greetings',
    },
  });
  await expect(component).toContainText('Greetings');
});</pre></div>
<div role="tabpanel" hidden=""><pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-solid';
import HelloWorld from './HelloWorld';

test.use({ viewport: { width: 500, height: 500 } });

test('should work', async ({ mount }) =&gt; {
  const component = await mount(&lt;HelloWorld msg="greetings" /&gt;);
  await expect(component).toContainText('Greetings');
});</pre></div>
</div>
</div> <p>Additionally, it adds some config options you can use in your <code>playwright-ct.config.{ts,js}</code>.</p> <p>Finally, under the hood, each test re-uses the <code>context</code> and <code>page</code> fixture as a speed optimization for Component Testing. It resets them in between each test so it should be functionally equivalent to <code>@playwright/test</code>'s guarantee that you get a new, isolated <code>context</code> and <code>page</code> fixture per-test.</p> <h3 id="i-have-a-project-that-already-uses-vite-can-i-reuse-the-config">I have a project that already uses Vite. Can I reuse the config?<a href="#i-have-a-project-that-already-uses-vite-can-i-reuse-the-config" aria-label="Direct link to I have a project that already uses Vite. Can I reuse the config?" title="Direct link to I have a project that already uses Vite. Can I reuse the config?">​</a>
</h3> <p>At this point, Playwright is bundler-agnostic, so it is not reusing your existing Vite config. Your config might have a lot of things we won't be able to reuse. So for now, you would copy your path mappings and other high level settings into the <code>ctViteConfig</code> property of Playwright config.</p> <pre tabindex="0" data-language="javascript">import { defineConfig } from '@playwright/experimental-ct-react';

export default defineConfig({
  use: {
    ctViteConfig: {
      // ...
    },
  },
});</pre> <p>You can specify plugins via Vite config for testing settings. Note that once you start specifying plugins, you are responsible for specifying the framework plugin as well, <code>vue()</code> in this case:</p> <pre tabindex="0" data-language="javascript">import { defineConfig, devices } from '@playwright/experimental-ct-vue';

import { resolve } from 'path';
import vue from '@vitejs/plugin-vue';
import AutoImport from 'unplugin-auto-import/vite';
import Components from 'unplugin-vue-components/vite';

export default defineConfig({
  testDir: './tests/component',
  use: {
    trace: 'on-first-retry',
    ctViteConfig: {
      plugins: [
        vue(),
        AutoImport({
          imports: [
            'vue',
            'vue-router',
            '@vueuse/head',
            'pinia',
            {
              '@/store': ['useStore'],
            },
          ],
          dts: 'src/auto-imports.d.ts',
          eslintrc: {
            enabled: true,
          },
        }),
        Components({
          dirs: ['src/components'],
          extensions: ['vue'],
        }),
      ],
      resolve: {
        alias: {
          '@': resolve(__dirname, './src'),
        },
      },
    },
  },
});</pre> <h3 id="how-can-i-use-router">How can I use router?<a href="#how-can-i-use-router" aria-label="Direct link to How can I use router?" title="Direct link to How can I use router?">​</a>
</h3> <pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-react/hooks';
import { BrowserRouter } from 'react-router-dom';
import '../src/assets/index.css';

export type HooksConfig = {
  routing?: boolean;
}

beforeMount&lt;HooksConfig&gt;(async ({ hooksConfig, App }) =&gt; {
  console.log(`Before mount: ${JSON.stringify(hooksConfig)}`);

  if (hooksConfig?.routing)
     return &lt;BrowserRouter&gt;&lt;App /&gt;&lt;/BrowserRouter&gt;;
});

afterMount&lt;HooksConfig&gt;(async () =&gt; {
  console.log(`After mount`);
});</pre> <pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-react';
import App from '@/App';
import type { HooksConfig } from '../playwright';

test('navigate to a page by clicking a link', async ({ page, mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(&lt;App /&gt;, {
    hooksConfig: { routing: true },
  });
  await expect(component.getByRole('main')).toHaveText('Login');
  await expect(page).toHaveURL('/');
  await component.getByRole('link', { name: 'Dashboard' }).click();
  await expect(component.getByRole('main')).toHaveText('Dashboard');
  await expect(page).toHaveURL('/dashboard');
});</pre> <h3 id="how-can-i-test-components-that-uses-pinia">How can I test components that uses Pinia?<a href="#how-can-i-test-components-that-uses-pinia" aria-label="Direct link to How can I test components that uses Pinia?" title="Direct link to How can I test components that uses Pinia?">​</a>
</h3> <p>Pinia needs to be initialized in <code>playwright/index.{js,ts,jsx,tsx}</code>. If you do this inside a <code>beforeMount</code> hook, the <code>initialState</code> can be overwritten on a per-test basis:</p> <pre tabindex="0" data-language="javascript">import { beforeMount, afterMount } from '@playwright/experimental-ct-vue/hooks';
import { createTestingPinia } from '@pinia/testing';
import type { StoreState } from 'pinia';
import type { useStore } from '../src/store';

export type HooksConfig = {
  store?: StoreState&lt;ReturnType&lt;typeof useStore&gt;&gt;;
}

beforeMount&lt;HooksConfig&gt;(async ({ hooksConfig }) =&gt; {
  createTestingPinia({
    initialState: hooksConfig?.store,
    /**
     * Use http intercepting to mock api calls instead:
     * https://playwright.dev/docs/mock#mock-api-requests
     */
    stubActions: false,
    createSpy(args) {
      console.log('spy', args)
      return () =&gt; console.log('spy-returns')
    },
  });
});</pre> <pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/experimental-ct-vue';
import type { HooksConfig } from '@playwright/test';
import Store from './Store.vue';

test('override initialState ', async ({ mount }) =&gt; {
  const component = await mount&lt;HooksConfig&gt;(Store, {
    hooksConfig: {
      store: { name: 'override initialState' }
    }
  });
  await expect(component).toContainText('override initialState');
});</pre><div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://playwright.dev/docs/test-components" class="_attribution-link">https://playwright.dev/docs/test-components</a>
  </p>
</div>
