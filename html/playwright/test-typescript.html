<header><h1>TypeScript</h1></header><h2 id="introduction">Introduction<a href="#introduction" aria-label="Direct link to Introduction" title="Direct link to Introduction">​</a>
</h2> <p>Playwright supports TypeScript out of the box. You just write tests in TypeScript, and Playwright will read them, transform to JavaScript and run.</p> <h2 id="tsconfigjson">tsconfig.json<a href="#tsconfigjson" aria-label="Direct link to tsconfig.json" title="Direct link to tsconfig.json">​</a>
</h2> <p>Playwright will pick up <code>tsconfig.json</code> for each source file it loads. Note that Playwright <strong>only supports</strong> the following tsconfig options: <code>paths</code> and <code>baseUrl</code>.</p> <p>We recommend setting up a separate <code>tsconfig.json</code> in the tests directory so that you can change some preferences specifically for the tests. Here is an example directory structure.</p> <pre tabindex="0" data-language="javascript">src/
    source.ts

tests/
    tsconfig.json  # test-specific tsconfig
    example.spec.ts

tsconfig.json  # generic tsconfig for all typescript sources

playwright.config.ts</pre> <h3 id="tsconfig-path-mapping">tsconfig path mapping<a href="#tsconfig-path-mapping" aria-label="Direct link to tsconfig path mapping" title="Direct link to tsconfig path mapping">​</a>
</h3> <p>Playwright supports <a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html#path-mapping" target="_blank" rel="noopener noreferrer">path mapping</a> declared in the <code>tsconfig.json</code>. Make sure that <code>baseUrl</code> is also set.</p> <p>Here is an example <code>tsconfig.json</code> that works with Playwright Test:</p> <pre tabindex="0" data-language="javascript">{
  "compilerOptions": {
    "baseUrl": ".", // This must be specified if "paths" is.
    "paths": {
      "@myhelper/*": ["packages/myhelper/*"] // This mapping is relative to "baseUrl".
    }
  }
}</pre> <p>You can now import using the mapped paths:</p> <pre tabindex="0" data-language="javascript">import { test, expect } from '@playwright/test';
import { username, password } from '@myhelper/credentials';

test('example', async ({ page }) =&gt; {
  await page.getByLabel('User Name').fill(username);
  await page.getByLabel('Password').fill(password);
});</pre> <h2 id="manually-compile-tests-with-typescript">Manually compile tests with TypeScript<a href="#manually-compile-tests-with-typescript" aria-label="Direct link to Manually compile tests with TypeScript" title="Direct link to Manually compile tests with TypeScript">​</a>
</h2> <p>Sometimes, Playwright Test will not be able to transform your TypeScript code correctly, for example when you are using experimental or very recent features of TypeScript, usually configured in <code>tsconfig.json</code>.</p> <p>In this case, you can perform your own TypeScript compilation before sending the tests to Playwright.</p> <p>First add a <code>tsconfig.json</code> file inside the tests directory:</p> <pre tabindex="0" data-language="javascript">{
    "compilerOptions": {
        "target": "ESNext",
        "module": "commonjs",
        "moduleResolution": "Node",
        "sourceMap": true,
        "outDir": "../tests-out",
    }
}</pre> <p>In <code>package.json</code>, add two scripts:</p> <pre tabindex="0" data-language="javascript">{
  "scripts": {
    "pretest": "tsc --incremental -p tests/tsconfig.json",
    "test": "playwright test -c tests-out"
  }
}</pre> <p>The <code>pretest</code> script runs typescript on the tests. <code>test</code> will run the tests that have been generated to the <code>tests-out</code> directory. The <code>-c</code> argument configures the test runner to look for tests inside the <code>tests-out</code> directory.</p> <p>Then <code>npm run test</code> will build the tests and run them.</p> <h2 id="using-import-inside-evaluate">Using <code>import</code> inside <code>evaluate()</code><a href="#using-import-inside-evaluate" aria-label="Direct link to using-import-inside-evaluate" title="Direct link to using-import-inside-evaluate">​</a>
</h2> <p>Using dynamic imports inside a function passed to various <code>evaluate()</code> methods is not supported. This is because Playwright uses <code>Function.prototype.toString()</code> to serialize functions, and transpiler will sometimes replace dynamic imports with <code>require()</code> calls, which are not valid inside the web page.</p> <p>To work around this issue, use a string template instead of a function:</p> <pre tabindex="0" data-language="javascript">await page.evaluate(`(async () =&gt; {
  const { value } = await import('some-module');
  console.log(value);
})()`);</pre><div class="_attribution">
  <p class="_attribution-p">
          &copy; 2024 Microsoft<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://playwright.dev/docs/test-typescript" class="_attribution-link">https://playwright.dev/docs/test-typescript</a>
  </p>
</div>
