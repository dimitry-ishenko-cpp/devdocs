<h1>Web</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot is well suited for web application development. You can create a self-contained HTTP server by using embedded Tomcat, Jetty, Undertow, or Netty. Most web applications use the <code>spring-boot-starter-web</code> module to get up and running quickly. You can also choose to build reactive web applications by using the <code>spring-boot-starter-webflux</code> module.</p> </div> <div class="paragraph"> <p>If you have not yet developed a Spring Boot web application, you can follow the "Hello World!" example in the <em><a href="getting-started.html#getting-started.first-application">Getting started</a></em> section.</p> </div> </div> </div> <div class="sect1"> <h2 id="web.servlet">
1. Servlet Web Applications</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you want to build servlet-based web applications, you can take advantage of Spring Boot’s auto-configuration for Spring MVC or Jersey.</p> </div> <div class="sect2"> <h3 id="web.servlet.spring-mvc">
1.1. The “Spring Web MVC Framework”</h3> <div class="paragraph"> <p>The <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc">Spring Web MVC framework</a> (often referred to as “Spring MVC”) is a rich “model view controller” web framework. Spring MVC lets you create special <code>@Controller</code> or <code>@RestController</code> beans to handle incoming HTTP requests. Methods in your controller are mapped to HTTP by using <code>@RequestMapping</code> annotations.</p> </div> <div class="paragraph"> <p>The following code shows a typical <code>@RestController</code> that serves JSON data:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.util.List;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

</span><span class="fold-block">@RestController
@RequestMapping("/users")
public class MyRestController {

    private final UserRepository userRepository;

    private final CustomerRepository customerRepository;

    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public User getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId).get();
    }

    @GetMapping("/{userId}/customers")
    public List&lt;Customer&gt; getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).map(this.customerRepository::findByUser).get();
    }

    @DeleteMapping("/{userId}")
    public void deleteUser(@PathVariable Long userId) {
        this.userRepository.deleteById(userId);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController


</span><span class="fold-block">@RestController
@RequestMapping("/users")
class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) {

    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: Long): User {
        return userRepository.findById(userId).get()
    }

    @GetMapping("/{userId}/customers")
    fun getUserCustomers(@PathVariable userId: Long): List&lt;Customer&gt; {
        return userRepository.findById(userId).map(customerRepository::findByUser).get()
    }

    @DeleteMapping("/{userId}")
    fun deleteUser(@PathVariable userId: Long) {
        userRepository.deleteById(userId)
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>“WebMvc.fn”, the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.servlet.function.RequestPredicate;
import org.springframework.web.servlet.function.RouterFunction;
import org.springframework.web.servlet.function.ServerResponse;

import static org.springframework.web.servlet.function.RequestPredicates.accept;
import static org.springframework.web.servlet.function.RouterFunctions.route;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {

    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction&lt;ServerResponse&gt; routerFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.servlet.function.RequestPredicates.accept
import org.springframework.web.servlet.function.RouterFunction
import org.springframework.web.servlet.function.RouterFunctions
import org.springframework.web.servlet.function.ServerResponse

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyRoutingConfiguration {

    @Bean
    fun routerFunction(userHandler: MyUserHandler): RouterFunction&lt;ServerResponse&gt; {
        return RouterFunctions.route()
            .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
            .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
            .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
            .build()
    }

    companion object {
        private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON)
    }

}
</span></code></pre> </div> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.stereotype.Component;
import org.springframework.web.servlet.function.ServerRequest;
import org.springframework.web.servlet.function.ServerResponse;

</span><span class="fold-block">@Component
public class MyUserHandler {

    public ServerResponse getUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse getUserCustomers(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

    public ServerResponse deleteUser(ServerRequest request) {
        ...
        return ServerResponse.ok().build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.stereotype.Component
import org.springframework.web.servlet.function.ServerRequest
import org.springframework.web.servlet.function.ServerResponse

</span><span class="fold-block">@Component
class MyUserHandler {

    fun getUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun getUserCustomers(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

    fun deleteUser(request: ServerRequest?): ServerResponse {
        return ServerResponse.ok().build()
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Spring MVC is part of the core Spring Framework, and detailed information is available in the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc">reference documentation</a>. There are also several guides that cover Spring MVC available at <a href="https://spring.io/guides" class="bare">spring.io/guides</a>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> You can define as many <code>RouterFunction</code> beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence. </td> </tr> </table> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.auto-configuration">
1.1.1. Spring MVC Auto-configuration</h4> <div class="paragraph"> <p>Spring Boot provides auto-configuration for Spring MVC that works well with most applications. It replaces the need for <code>@EnableWebMvc</code> and the two cannot be used together. In addition to Spring MVC’s defaults, the auto-configuration provides the following features:</p> </div> <div class="ulist"> <ul> <li> <p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p> </li> <li> <p>Support for serving static resources, including support for WebJars (covered <a href="features.html#web.servlet.spring-mvc.static-content">later in this document</a>).</p> </li> <li> <p>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</p> </li> <li> <p>Support for <code>HttpMessageConverters</code> (covered <a href="features.html#web.servlet.spring-mvc.message-converters">later in this document</a>).</p> </li> <li> <p>Automatic registration of <code>MessageCodesResolver</code> (covered <a href="features.html#web.servlet.spring-mvc.message-codes">later in this document</a>).</p> </li> <li> <p>Static <code>index.html</code> support.</p> </li> <li> <p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (covered <a href="features.html#web.servlet.spring-mvc.binding-initializer">later in this document</a>).</p> </li> </ul> </div> <div class="paragraph"> <p>If you want to keep those Spring Boot MVC customizations and make more <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc">MVC customizations</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>.</p> </div> <div class="paragraph"> <p>If you want to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, and still keep the Spring Boot MVC customizations, you can declare a bean of type <code>WebMvcRegistrations</code> and use it to provide custom instances of those components.</p> </div> <div class="paragraph"> <p>If you do not want to use the auto-configuration and want to take complete control of Spring MVC, add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>. Alternatively, add your own <code>@Configuration</code>-annotated <code>DelegatingWebMvcConfiguration</code> as described in the Javadoc of <code>@EnableWebMvc</code>.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.conversion-service">
1.1.2. Spring MVC Conversion Service</h4> <div class="paragraph"> <p>Spring MVC uses a different <code>ConversionService</code> to the one used to convert values from your <code>application.properties</code> or <code>application.yaml</code> file. It means that <code>Period</code>, <code>Duration</code> and <code>DataSize</code> converters are not available and that <code>@DurationUnit</code> and <code>@DataSizeUnit</code> annotations will be ignored.</p> </div> <div class="paragraph"> <p>If you want to customize the <code>ConversionService</code> used by Spring MVC, you can provide a <code>WebMvcConfigurer</code> bean with an <code>addFormatters</code> method. From this method you can register any converter that you like, or you can delegate to the static methods available on <code>ApplicationConversionService</code>.</p> </div> <div class="paragraph"> <p>Conversion can also be customized using the <code>spring.mvc.format.*</code> configuration properties. When not configured, the following defaults are used:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Property</th> <th class="tableblock halign-left valign-top"><code>DateTimeFormatter</code></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.mvc.format.date</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedDate(FormatStyle.SHORT)</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.mvc.format.time</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedTime(FormatStyle.SHORT)</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.mvc.format.date-time</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedDateTime(FormatStyle.SHORT)</code></p></td> </tr> </tbody> </table> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.message-converters">
1.1.3. HttpMessageConverters</h4> <div class="paragraph"> <p>Spring MVC uses the <code>HttpMessageConverter</code> interface to convert HTTP requests and responses. Sensible defaults are included out of the box. For example, objects can be automatically converted to JSON (by using the Jackson library) or XML (by using the Jackson XML extension, if available, or by using JAXB if the Jackson XML extension is not available). By default, strings are encoded in <code>UTF-8</code>.</p> </div> <div class="paragraph"> <p>If you need to add or customize converters, you can use Spring Boot’s <code>HttpMessageConverters</code> class, as shown in the following listing:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.http.HttpMessageConverters;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.converter.HttpMessageConverter;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyHttpMessageConvertersConfiguration {

    @Bean
    public HttpMessageConverters customConverters() {
        HttpMessageConverter&lt;?&gt; additional = new AdditionalHttpMessageConverter();
        HttpMessageConverter&lt;?&gt; another = new AnotherHttpMessageConverter();
        return new HttpMessageConverters(additional, another);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.http.HttpMessageConverters
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.converter.HttpMessageConverter

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyHttpMessageConvertersConfiguration {

    @Bean
    fun customConverters(): HttpMessageConverters {
        val additional: HttpMessageConverter&lt;*&gt; = AdditionalHttpMessageConverter()
        val another: HttpMessageConverter&lt;*&gt; = AnotherHttpMessageConverter()
        return HttpMessageConverters(additional, another)
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Any <code>HttpMessageConverter</code> bean that is present in the context is added to the list of converters. You can also override default converters in the same way.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.message-codes">
1.1.4. MessageCodesResolver</h4> <div class="paragraph"> <p>Spring MVC has a strategy for generating error codes for rendering error messages from binding errors: <code>MessageCodesResolver</code>. If you set the <code>spring.mvc.message-codes-resolver-format</code> property <code>PREFIX_ERROR_CODE</code> or <code>POSTFIX_ERROR_CODE</code>, Spring Boot creates one for you (see the enumeration in <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/validation/DefaultMessageCodesResolver.Format.html"><code>DefaultMessageCodesResolver.Format</code></a>).</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.static-content">
1.1.5. Static Content</h4> <div class="paragraph"> <p>By default, Spring Boot serves static content from a directory called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code>) in the classpath or from the root of the <code>ServletContext</code>. It uses the <code>ResourceHttpRequestHandler</code> from Spring MVC so that you can modify that behavior by adding your own <code>WebMvcConfigurer</code> and overriding the <code>addResourceHandlers</code> method.</p> </div> <div class="paragraph"> <p>In a stand-alone web application, the default servlet from the container is not enabled. It can be enabled using the <code>server.servlet.register-default-servlet</code> property.</p> </div> <div class="paragraph"> <p>The default servlet acts as a fallback, serving content from the root of the <code>ServletContext</code> if Spring decides not to handle it. Most of the time, this does not happen (unless you modify the default MVC configuration), because Spring can always handle requests through the <code>DispatcherServlet</code>.</p> </div> <div class="paragraph"> <p>By default, resources are mapped on <code>/**</code>, but you can tune that with the <code>spring.mvc.static-path-pattern</code> property. For instance, relocating all resources to <code>/resources/**</code> can be achieved as follows:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mvc.static-path-pattern=/resources/**</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mvc:
    static-path-pattern: "/resources/**"</code></pre> </div> </div> <div class="paragraph"> <p>You can also customize the static resource locations by using the <code>spring.web.resources.static-locations</code> property (replacing the default values with a list of directory locations). The root servlet context path, <code>"/"</code>, is automatically added as a location as well.</p> </div> <div class="paragraph"> <p>In addition to the “standard” static resource locations mentioned earlier, a special case is made for <a href="https://www.webjars.org/">Webjars content</a>. By default, any resources with a path in <code>/webjars/**</code> are served from jar files if they are packaged in the Webjars format. The path can be customized with the <code>spring.mvc.webjars-path-pattern</code> property.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Do not use the <code>src/main/webapp</code> directory if your application is packaged as a jar. Although this directory is a common standard, it works <strong>only</strong> with war packaging, and it is silently ignored by most build tools if you generate a jar. </td> </tr> </table> </div> <div class="paragraph"> <p>Spring Boot also supports the advanced resource handling features provided by Spring MVC, allowing use cases such as cache-busting static resources or using version agnostic URLs for Webjars.</p> </div> <div class="paragraph"> <p>To use version agnostic URLs for Webjars, add the <code>webjars-locator-core</code> dependency. Then declare your Webjar. Using jQuery as an example, adding <code>"/webjars/jquery/jquery.min.js"</code> results in <code>"/webjars/jquery/x.y.z/jquery.min.js"</code> where <code>x.y.z</code> is the Webjar version.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you use JBoss, you need to declare the <code>webjars-locator-jboss-vfs</code> dependency instead of the <code>webjars-locator-core</code>. Otherwise, all Webjars resolve as a <code>404</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>To use cache busting, the following configuration configures a cache busting solution for all static resources, effectively adding a content hash, such as <code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css.html"/&gt;</code>, in URLs:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Links to resources are rewritten in templates at runtime, thanks to a <code>ResourceUrlEncodingFilter</code> that is auto-configured for Thymeleaf and FreeMarker. You should manually declare this filter when using JSPs. Other template engines are currently not automatically supported but can be with custom template macros/helpers and the use of the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/web/servlet/resource/ResourceUrlProvider.html"><code>ResourceUrlProvider</code></a>. </td> </tr> </table> </div> <div class="paragraph"> <p>When loading resources dynamically with, for example, a JavaScript module loader, renaming files is not an option. That is why other strategies are also supported and can be combined. A "fixed" strategy adds a static version string in the URL without changing the file name, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.web.resources.chain.strategy.content.enabled=true
spring.web.resources.chain.strategy.content.paths=/**
spring.web.resources.chain.strategy.fixed.enabled=true
spring.web.resources.chain.strategy.fixed.paths=/js/lib/
spring.web.resources.chain.strategy.fixed.version=v12</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  web:
    resources:
      chain:
        strategy:
          content:
            enabled: true
            paths: "/**"
          fixed:
            enabled: true
            paths: "/js/lib/"
            version: "v12"</code></pre> </div> </div> <div class="paragraph"> <p>With this configuration, JavaScript modules located under <code>"/js/lib/"</code> use a fixed versioning strategy (<code>"/v12/js/lib/mymodule.js"</code>), while other resources still use the content one (<code>&lt;link href="/css/spring-2a2d595e6ed9a0b24f027f2b63b134d6.css.html"/&gt;</code>).</p> </div> <div class="paragraph"> <p>See <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/WebProperties.java"><code>WebProperties.Resources</code></a> for more supported options.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> <div class="paragraph"> <p>This feature has been thoroughly described in a dedicated <a href="https://spring.io/blog/2014/07/24/spring-framework-4-1-handling-static-web-resources">blog post</a> and in Spring Framework’s <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-config-static-resources">reference documentation</a>.</p> </div> </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.welcome-page">
1.1.6. Welcome Page</h4> <div class="paragraph"> <p>Spring Boot supports both static and templated welcome pages. It first looks for an <code>index.html</code> file in the configured static content locations. If one is not found, it then looks for an <code>index</code> template. If either is found, it is automatically used as the welcome page of the application.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.favicon">
1.1.7. Custom Favicon</h4> <div class="paragraph"> <p>As with other static resources, Spring Boot checks for a <code>favicon.ico</code> in the configured static content locations. If such a file is present, it is automatically used as the favicon of the application.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.content-negotiation">
1.1.8. Path Matching and Content Negotiation</h4> <div class="paragraph"> <p>Spring MVC can map incoming HTTP requests to handlers by looking at the request path and matching it to the mappings defined in your application (for example, <code>@GetMapping</code> annotations on Controller methods).</p> </div> <div class="paragraph"> <p>Spring Boot chooses to disable suffix pattern matching by default, which means that requests like <code>"GET /projects/spring-boot.json"</code> will not be matched to <code>@GetMapping("/projects/spring-boot")</code> mappings. This is considered as a <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-ann-requestmapping-suffix-pattern-match">best practice for Spring MVC applications</a>. This feature was mainly useful in the past for HTTP clients which did not send proper "Accept" request headers; we needed to make sure to send the correct Content Type to the client. Nowadays, Content Negotiation is much more reliable.</p> </div> <div class="paragraph"> <p>There are other ways to deal with HTTP clients that do not consistently send proper "Accept" request headers. Instead of using suffix matching, we can use a query parameter to ensure that requests like <code>"GET /projects/spring-boot?format=json"</code> will be mapped to <code>@GetMapping("/projects/spring-boot")</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mvc:
    contentnegotiation:
      favor-parameter: true</code></pre> </div> </div> <div class="paragraph"> <p>Or if you prefer to use a different parameter name:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.favor-parameter=true
spring.mvc.contentnegotiation.parameter-name=myparam</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mvc:
    contentnegotiation:
      favor-parameter: true
      parameter-name: "myparam"</code></pre> </div> </div> <div class="paragraph"> <p>Most standard media types are supported out-of-the-box, but you can also define new ones:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mvc.contentnegotiation.media-types.markdown=text/markdown</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mvc:
    contentnegotiation:
      media-types:
        markdown: "text/markdown"</code></pre> </div> </div> <div class="paragraph"> <p>As of Spring Framework 5.3, Spring MVC supports two strategies for matching request paths to controllers. By default, Spring Boot uses the <code>PathPatternParser</code> strategy. <code>PathPatternParser</code> is an <a href="https://spring.io/blog/2020/06/30/url-matching-with-pathpattern-in-spring-mvc">optimized implementation</a> but comes with some restrictions compared to the <code>AntPathMatcher</code> strategy. <code>PathPatternParser</code> restricts usage of <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-ann-requestmapping-uri-templates">some path patterns variants</a>. It is also incompatible with configuring the <code>DispatcherServlet</code> with a path prefix (<code>spring.mvc.servlet.path</code>).</p> </div> <div class="paragraph"> <p>The strategy can be configured using the <code>spring.mvc.pathmatch.matching-strategy</code> configuration property, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.mvc.pathmatch.matching-strategy=ant-path-matcher</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  mvc:
    pathmatch:
      matching-strategy: "ant-path-matcher"</code></pre> </div> </div> <div class="paragraph"> <p>By default, Spring MVC will send a 404 Not Found error response if a handler is not found for a request. To have a <code>NoHandlerFoundException</code> thrown instead, set configprop:spring.mvc.throw-exception-if-no-handler-found to <code>true</code>. Note that, by default, the <a href="#web.servlet.spring-mvc.static-content">serving of static content</a> is mapped to <code>/**</code> and will, therefore, provide a handler for all requests. For a <code>NoHandlerFoundException</code> to be thrown, you must also set <code>spring.mvc.static-path-pattern</code> to a more specific value such as <code>/resources/**</code> or set <code>spring.web.resources.add-mappings</code> to <code>false</code> to disable serving of static content entirely.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.binding-initializer">
1.1.9. ConfigurableWebBindingInitializer</h4> <div class="paragraph"> <p>Spring MVC uses a <code>WebBindingInitializer</code> to initialize a <code>WebDataBinder</code> for a particular request. If you create your own <code>ConfigurableWebBindingInitializer</code> <code>@Bean</code>, Spring Boot automatically configures Spring MVC to use it.</p> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.template-engines">
1.1.10. Template Engines</h4> <div class="paragraph"> <p>As well as REST web services, you can also use Spring MVC to serve dynamic HTML content. Spring MVC supports a variety of templating technologies, including Thymeleaf, FreeMarker, and JSPs. Also, many other templating engines include their own Spring MVC integrations.</p> </div> <div class="paragraph"> <p>Spring Boot includes auto-configuration support for the following templating engines:</p> </div> <div class="ulist"> <ul> <li> <p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p> </li> <li> <p><a href="https://docs.groovy-lang.org/docs/next/html/documentation/template-engines.html#_the_markuptemplateengine">Groovy</a></p> </li> <li> <p><a href="https://www.thymeleaf.org">Thymeleaf</a></p> </li> <li> <p><a href="https://mustache.github.io/">Mustache</a></p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> If possible, JSPs should be avoided. There are several <a href="#web.servlet.embedded-container.jsp-limitations">known limitations</a> when using them with embedded servlet containers. </td> </tr> </table> </div> <div class="paragraph"> <p>When you use one of these templating engines with the default configuration, your templates are picked up automatically from <code>src/main/resources/templates</code>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Depending on how you run your application, your IDE may order the classpath differently. Running your application in the IDE from its main method results in a different ordering than when you run your application by using Maven or Gradle or from its packaged jar. This can cause Spring Boot to fail to find the expected template. If you have this problem, you can reorder the classpath in the IDE to place the module’s classes and resources first. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.error-handling">
1.1.11. Error Handling</h4> <div class="paragraph"> <p>By default, Spring Boot provides an <code>/error</code> mapping that handles all errors in a sensible way, and it is registered as a “global” error page in the servlet container. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error view that renders the same data in HTML format (to customize it, add a <code>View</code> that resolves to <code>error</code>).</p> </div> <div class="paragraph"> <p>There are a number of <code>server.error</code> properties that can be set if you want to customize the default error handling behavior. See the <a href="application-properties.html#appendix.application-properties.server">“Server Properties”</a> section of the Appendix.</p> </div> <div class="paragraph"> <p>To replace the default behavior completely, you can implement <code>ErrorController</code> and register a bean definition of that type or add a bean of type <code>ErrorAttributes</code> to use the existing mechanism but replace the contents.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> The <code>BasicErrorController</code> can be used as a base class for a custom <code>ErrorController</code>. This is particularly useful if you want to add a handler for a new content type (the default is to handle <code>text/html</code> specifically and provide a fallback for everything else). To do so, extend <code>BasicErrorController</code>, add a public method with a <code>@RequestMapping</code> that has a <code>produces</code> attribute, and create a bean of your new type. </td> </tr> </table> </div> <div class="paragraph"> <p>As of Spring Framework 6.0, <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-ann-rest-exceptions">RFC 7807 Problem Details</a> is supported. Spring MVC can produce custom error messages with the <code>application/problem+json</code> media type, like:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="json"><code class="language-json" data-lang="json">{
  "type": "https://example.org/problems/unknown-project",
  "title": "Unknown project",
  "status": 404,
  "detail": "No project found for id 'spring-unknown'",
  "instance": "/projects/spring-unknown"
}</code></pre> </div> </div> <div class="paragraph"> <p>This support can be enabled by setting <code>spring.mvc.problemdetails.enabled</code> to <code>true</code>.</p> </div> <div class="paragraph"> <p>You can also define a class annotated with <code>@ControllerAdvice</code> to customize the JSON document to return for a particular controller and/or exception type, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.servlet.RequestDispatcher;
import jakarta.servlet.http.HttpServletRequest;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;

</span><span class="fold-block">@ControllerAdvice(basePackageClasses = SomeController.class)
public class MyControllerAdvice extends ResponseEntityExceptionHandler {

    @ResponseBody
    @ExceptionHandler(MyException.class)
    public ResponseEntity&lt;?&gt; handleControllerException(HttpServletRequest request, Throwable ex) {
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(new MyErrorBody(status.value(), ex.getMessage()), status);
    }

    private HttpStatus getStatus(HttpServletRequest request) {
        Integer code = (Integer) request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);
        HttpStatus status = HttpStatus.resolve(code);
        return (status != null) ? status : HttpStatus.INTERNAL_SERVER_ERROR;
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.servlet.RequestDispatcher
import jakarta.servlet.http.HttpServletRequest
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.ResponseBody
import org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler

</span><span class="fold-block">@ControllerAdvice(basePackageClasses = [SomeController::class])
class MyControllerAdvice : ResponseEntityExceptionHandler() {

    @ResponseBody
    @ExceptionHandler(MyException::class)
    fun handleControllerException(request: HttpServletRequest, ex: Throwable): ResponseEntity&lt;*&gt; {
        val status = getStatus(request)
        return ResponseEntity(MyErrorBody(status.value(), ex.message), status)
    }

    private fun getStatus(request: HttpServletRequest): HttpStatus {
        val code = request.getAttribute(RequestDispatcher.ERROR_STATUS_CODE) as Int
        val status = HttpStatus.resolve(code)
        return status ?: HttpStatus.INTERNAL_SERVER_ERROR
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>In the preceding example, if <code>MyException</code> is thrown by a controller defined in the same package as <code>SomeController</code>, a JSON representation of the <code>MyErrorBody</code> POJO is used instead of the <code>ErrorAttributes</code> representation.</p> </div> <div class="paragraph"> <p>In some cases, errors handled at the controller level are not recorded by the <a href="actuator.html#actuator.metrics.supported.spring-mvc">metrics infrastructure</a>. Applications can ensure that such exceptions are recorded with the request metrics by setting the handled exception as a request attribute:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.servlet.http.HttpServletRequest;

import org.springframework.boot.web.servlet.error.ErrorAttributes;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;

</span><span class="fold-block">@Controller
public class MyController {

    @ExceptionHandler(CustomException.class)
    String handleCustomException(HttpServletRequest request, CustomException ex) {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex);
        return "errorView";
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.web.servlet.error.ErrorAttributes
import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.ExceptionHandler

</span><span class="fold-block">@Controller
class MyController {

    @ExceptionHandler(CustomException::class)
    fun handleCustomException(request: HttpServletRequest, ex: CustomException?): String {
        request.setAttribute(ErrorAttributes.ERROR_ATTRIBUTE, ex)
        return "errorView"
    }

}
</span></code></pre> </div> </div> <div class="sect4"> <h5 id="web.servlet.spring-mvc.error-handling.error-pages">
Custom Error Pages</h5> <div class="paragraph"> <p>If you want to display a custom HTML error page for a given status code, you can add a file to an <code>/error</code> directory. Error pages can either be static HTML (that is, added under any of the static resource directories) or be built by using templates. The name of the file should be the exact status code or a series mask.</p> </div> <div class="paragraph"> <p>For example, to map <code>404</code> to a static HTML file, your directory structure would be as follows:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</pre> </div> </div> <div class="paragraph"> <p>To map all <code>5xx</code> errors by using a FreeMarker template, your directory structure would be as follows:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.ftlh
             +- &lt;other templates&gt;</pre> </div> </div> <div class="paragraph"> <p>For more complex mappings, you can also add beans that implement the <code>ErrorViewResolver</code> interface, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.util.Map;

import jakarta.servlet.http.HttpServletRequest;

import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver;
import org.springframework.http.HttpStatus;
import org.springframework.web.servlet.ModelAndView;

</span><span class="fold-block">public class MyErrorViewResolver implements ErrorViewResolver {

    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) {
        // Use the request or status to optionally return a ModelAndView
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // We could add custom model values here
            new ModelAndView("myview");
        }
        return null;
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.servlet.http.HttpServletRequest
import org.springframework.boot.autoconfigure.web.servlet.error.ErrorViewResolver
import org.springframework.http.HttpStatus
import org.springframework.web.servlet.ModelAndView

</span><span class="fold-block">class MyErrorViewResolver : ErrorViewResolver {

    override fun resolveErrorView(request: HttpServletRequest, status: HttpStatus,
            model: Map&lt;String, Any&gt;): ModelAndView? {
        // Use the request or status to optionally return a ModelAndView
        if (status == HttpStatus.INSUFFICIENT_STORAGE) {
            // We could add custom model values here
            return ModelAndView("myview")
        }
        return null
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>You can also use regular Spring MVC features such as <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-exceptionhandlers"><code>@ExceptionHandler</code> methods</a> and <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-ann-controller-advice"><code>@ControllerAdvice</code></a>. The <code>ErrorController</code> then picks up any unhandled exceptions.</p> </div> </div> <div class="sect4"> <h5 id="web.servlet.spring-mvc.error-handling.error-pages-without-spring-mvc">
Mapping Error Pages Outside of Spring MVC</h5> <div class="paragraph"> <p>For applications that do not use Spring MVC, you can use the <code>ErrorPageRegistrar</code> interface to directly register <code>ErrorPages</code>. This abstraction works directly with the underlying embedded servlet container and works even if you do not have a Spring MVC <code>DispatcherServlet</code>.</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.server.ErrorPage;
import org.springframework.boot.web.server.ErrorPageRegistrar;
import org.springframework.boot.web.server.ErrorPageRegistry;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpStatus;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyErrorPagesConfiguration {

    @Bean
    public ErrorPageRegistrar errorPageRegistrar() {
        return this::registerErrorPages;
    }

    private void registerErrorPages(ErrorPageRegistry registry) {
        registry.addErrorPages(new ErrorPage(HttpStatus.BAD_REQUEST, "/400"));
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.server.ErrorPage
import org.springframework.boot.web.server.ErrorPageRegistrar
import org.springframework.boot.web.server.ErrorPageRegistry
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpStatus

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyErrorPagesConfiguration {

    @Bean
    fun errorPageRegistrar(): ErrorPageRegistrar {
        return ErrorPageRegistrar { registry: ErrorPageRegistry -&gt; registerErrorPages(registry) }
    }

    private fun registerErrorPages(registry: ErrorPageRegistry) {
        registry.addErrorPages(ErrorPage(HttpStatus.BAD_REQUEST, "/400"))
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you register an <code>ErrorPage</code> with a path that ends up being handled by a <code>Filter</code> (as is common with some non-Spring web frameworks, like Jersey and Wicket), then the <code>Filter</code> has to be explicitly registered as an <code>ERROR</code> dispatcher, as shown in the following example: </td> </tr> </table> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.util.EnumSet;

import jakarta.servlet.DispatcherType;

import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyFilterConfiguration {

    @Bean
    public FilterRegistrationBean&lt;MyFilter&gt; myFilter() {
        FilterRegistrationBean&lt;MyFilter&gt; registration = new FilterRegistrationBean&lt;&gt;(new MyFilter());
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType.class));
        return registration;
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import jakarta.servlet.DispatcherType
import org.springframework.boot.web.servlet.FilterRegistrationBean
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import java.util.EnumSet

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyFilterConfiguration {

    @Bean
    fun myFilter(): FilterRegistrationBean&lt;MyFilter&gt; {
        val registration = FilterRegistrationBean(MyFilter())
        // ...
        registration.setDispatcherTypes(EnumSet.allOf(DispatcherType::class.java))
        return registration
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Note that the default <code>FilterRegistrationBean</code> does not include the <code>ERROR</code> dispatcher type.</p> </div> </div> <div class="sect4"> <h5 id="web.servlet.spring-mvc.error-handling.in-a-war-deployment">
Error Handling in a WAR Deployment</h5> <div class="paragraph"> <p>When deployed to a servlet container, Spring Boot uses its error page filter to forward a request with an error status to the appropriate error page. This is necessary as the servlet specification does not provide an API for registering error pages. Depending on the container that you are deploying your war file to and the technologies that your application uses, some additional configuration may be required.</p> </div> <div class="paragraph"> <p>The error page filter can only forward the request to the correct error page if the response has not already been committed. By default, WebSphere Application Server 8.0 and later commits the response upon successful completion of a servlet’s service method. You should disable this behavior by setting <code>com.ibm.ws.webcontainer.invokeFlushAfterService</code> to <code>false</code>.</p> </div> </div> </div> <div class="sect3"> <h4 id="web.servlet.spring-mvc.cors">
1.1.12. CORS Support</h4> <div class="paragraph"> <p><a href="https://en.wikipedia.org/wiki/Cross-origin_resource_sharing">Cross-origin resource sharing</a> (CORS) is a <a href="https://www.w3.org/TR/cors/">W3C specification</a> implemented by <a href="https://caniuse.com/#feat=cors">most browsers</a> that lets you specify in a flexible way what kind of cross-domain requests are authorized, instead of using some less secure and less powerful approaches such as IFRAME or JSONP.</p> </div> <div class="paragraph"> <p>As of version 4.2, Spring MVC <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-cors">supports CORS</a>. Using <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-cors-controller">controller method CORS configuration</a> with <a href="https://docs.spring.io/spring-framework/docs/6.0.11/javadoc-api/org/springframework/web/bind/annotation/CrossOrigin.html"><code>@CrossOrigin</code></a> annotations in your Spring Boot application does not require any specific configuration. <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-cors-global">Global CORS configuration</a> can be defined by registering a <code>WebMvcConfigurer</code> bean with a customized <code>addCorsMappings(CorsRegistry)</code> method, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyCorsConfiguration {

    @Bean
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {

            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/api/**");
            }

        };
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyCorsConfiguration {

    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/api/**")
            }
        }
    }

}
</span></code></pre> </div> </div> </div> </div> <div class="sect2"> <h3 id="web.servlet.jersey">
1.2. JAX-RS and Jersey</h3> <div class="paragraph"> <p>If you prefer the JAX-RS programming model for REST endpoints, you can use one of the available implementations instead of Spring MVC. <a href="https://jersey.github.io/">Jersey</a> and <a href="https://cxf.apache.org/">Apache CXF</a> work quite well out of the box. CXF requires you to register its <code>Servlet</code> or <code>Filter</code> as a <code>@Bean</code> in your application context. Jersey has some native Spring support, so we also provide auto-configuration support for it in Spring Boot, together with a starter.</p> </div> <div class="paragraph"> <p>To get started with Jersey, include the <code>spring-boot-starter-jersey</code> as a dependency and then you need one <code>@Bean</code> of type <code>ResourceConfig</code> in which you register all the endpoints, as shown in the following example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.glassfish.jersey.server.ResourceConfig;

import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyJerseyConfig extends ResourceConfig {

    public MyJerseyConfig() {
        register(MyEndpoint.class);
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> Jersey’s support for scanning executable archives is rather limited. For example, it cannot scan for endpoints in a package found in a <a href="deployment.html#deployment.installing">fully executable jar file</a> or in <code>WEB-INF/classes</code> when running an executable war file. To avoid this limitation, the <code>packages</code> method should not be used, and endpoints should be registered individually by using the <code>register</code> method, as shown in the preceding example. </td> </tr> </table> </div> <div class="paragraph"> <p>For more advanced customizations, you can also register an arbitrary number of beans that implement <code>ResourceConfigCustomizer</code>.</p> </div> <div class="paragraph"> <p>All the registered endpoints should be <code>@Components</code> with HTTP resource annotations (<code>@GET</code> and others), as shown in the following example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.ws.rs.GET;
import jakarta.ws.rs.Path;

import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
@Path("/hello")
public class MyEndpoint {

    @GET
    public String message() {
        return "Hello";
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>Since the <code>Endpoint</code> is a Spring <code>@Component</code>, its lifecycle is managed by Spring and you can use the <code>@Autowired</code> annotation to inject dependencies and use the <code>@Value</code> annotation to inject external configuration. By default, the Jersey servlet is registered and mapped to <code>/*</code>. You can change the mapping by adding <code>@ApplicationPath</code> to your <code>ResourceConfig</code>.</p> </div> <div class="paragraph"> <p>By default, Jersey is set up as a servlet in a <code>@Bean</code> of type <code>ServletRegistrationBean</code> named <code>jerseyServletRegistration</code>. By default, the servlet is initialized lazily, but you can customize that behavior by setting <code>spring.jersey.servlet.load-on-startup</code>. You can disable or override that bean by creating one of your own with the same name. You can also use a filter instead of a servlet by setting <code>spring.jersey.type=filter</code> (in which case, the <code>@Bean</code> to replace or override is <code>jerseyFilterRegistration</code>). The filter has an <code>@Order</code>, which you can set with <code>spring.jersey.filter.order</code>. When using Jersey as a filter, a servlet that will handle any requests that are not intercepted by Jersey must be present. If your application does not contain such a servlet, you may want to enable the default servlet by setting <code>server.servlet.register-default-servlet</code> to <code>true</code>. Both the servlet and the filter registrations can be given init parameters by using <code>spring.jersey.init.*</code> to specify a map of properties.</p> </div> </div> <div class="sect2"> <h3 id="web.servlet.embedded-container">
1.3. Embedded Servlet Container Support</h3> <div class="paragraph"> <p>For servlet application, Spring Boot includes support for embedded <a href="https://tomcat.apache.org/">Tomcat</a>, <a href="https://www.eclipse.org/jetty/">Jetty</a>, and <a href="https://github.com/undertow-io/undertow">Undertow</a> servers. Most developers use the appropriate “Starter” to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port <code>8080</code>.</p> </div> <div class="sect3"> <h4 id="web.servlet.embedded-container.servlets-filters-listeners">
1.3.1. Servlets, Filters, and Listeners</h4> <div class="paragraph"> <p>When using an embedded servlet container, you can register servlets, filters, and all the listeners (such as <code>HttpSessionListener</code>) from the servlet spec, either by using Spring beans or by scanning for servlet components.</p> </div> <div class="sect4"> <h5 id="web.servlet.embedded-container.servlets-filters-listeners.beans">
Registering Servlets, Filters, and Listeners as Spring Beans</h5> <div class="paragraph"> <p>Any <code>Servlet</code>, <code>Filter</code>, or servlet <code>*Listener</code> instance that is a Spring bean is registered with the embedded container. This can be particularly convenient if you want to refer to a value from your <code>application.properties</code> during configuration.</p> </div> <div class="paragraph"> <p>By default, if the context contains only a single Servlet, it is mapped to <code>/</code>. In the case of multiple servlet beans, the bean name is used as a path prefix. Filters map to <code>/*</code>.</p> </div> <div class="paragraph"> <p>If convention-based mapping is not flexible enough, you can use the <code>ServletRegistrationBean</code>, <code>FilterRegistrationBean</code>, and <code>ServletListenerRegistrationBean</code> classes for complete control.</p> </div> <div class="paragraph"> <p>It is usually safe to leave filter beans unordered. If a specific order is required, you should annotate the <code>Filter</code> with <code>@Order</code> or make it implement <code>Ordered</code>. You cannot configure the order of a <code>Filter</code> by annotating its bean method with <code>@Order</code>. If you cannot change the <code>Filter</code> class to add <code>@Order</code> or implement <code>Ordered</code>, you must define a <code>FilterRegistrationBean</code> for the <code>Filter</code> and set the registration bean’s order using the <code>setOrder(int)</code> method. Avoid configuring a filter that reads the request body at <code>Ordered.HIGHEST_PRECEDENCE</code>, since it might go against the character encoding configuration of your application. If a servlet filter wraps the request, it should be configured with an order that is less than or equal to <code>OrderedFilter.REQUEST_WRAPPER_FILTER_MAX_ORDER</code>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> To see the order of every <code>Filter</code> in your application, enable debug level logging for the <code>web</code> <a href="features.html#features.logging.log-groups">logging group</a> (<code>logging.level.web=debug</code>). Details of the registered filters, including their order and URL patterns, will then be logged at startup. </td> </tr> </table> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> Take care when registering <code>Filter</code> beans since they are initialized very early in the application lifecycle. If you need to register a <code>Filter</code> that interacts with other beans, consider using a <a href="https://docs.spring.io/spring-boot/docs/3.1.3/api/org/springframework/boot/web/servlet/DelegatingFilterProxyRegistrationBean.html"><code>DelegatingFilterProxyRegistrationBean</code></a> instead. </td> </tr> </table> </div> </div> </div> <div class="sect3"> <h4 id="web.servlet.embedded-container.context-initializer">
1.3.2. Servlet Context Initialization</h4> <div class="paragraph"> <p>Embedded servlet containers do not directly execute the <code>jakarta.servlet.ServletContainerInitializer</code> interface or Spring’s <code>org.springframework.web.WebApplicationInitializer</code> interface. This is an intentional design decision intended to reduce the risk that third party libraries designed to run inside a war may break Spring Boot applications.</p> </div> <div class="paragraph"> <p>If you need to perform servlet context initialization in a Spring Boot application, you should register a bean that implements the <code>org.springframework.boot.web.servlet.ServletContextInitializer</code> interface. The single <code>onStartup</code> method provides access to the <code>ServletContext</code> and, if necessary, can easily be used as an adapter to an existing <code>WebApplicationInitializer</code>.</p> </div> <div class="sect4"> <h5 id="web.servlet.embedded-container.context-initializer.scanning">
Scanning for Servlets, Filters, and listeners</h5> <div class="paragraph"> <p>When using an embedded container, automatic registration of classes annotated with <code>@WebServlet</code>, <code>@WebFilter</code>, and <code>@WebListener</code> can be enabled by using <code>@ServletComponentScan</code>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> <code>@ServletComponentScan</code> has no effect in a standalone container, where the container’s built-in discovery mechanisms are used instead. </td> </tr> </table> </div> </div> </div> <div class="sect3"> <h4 id="web.servlet.embedded-container.application-context">
1.3.3. The ServletWebServerApplicationContext</h4> <div class="paragraph"> <p>Under the hood, Spring Boot uses a different type of <code>ApplicationContext</code> for embedded servlet container support. The <code>ServletWebServerApplicationContext</code> is a special type of <code>WebApplicationContext</code> that bootstraps itself by searching for a single <code>ServletWebServerFactory</code> bean. Usually a <code>TomcatServletWebServerFactory</code>, <code>JettyServletWebServerFactory</code>, or <code>UndertowServletWebServerFactory</code> has been auto-configured.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> You usually do not need to be aware of these implementation classes. Most applications are auto-configured, and the appropriate <code>ApplicationContext</code> and <code>ServletWebServerFactory</code> are created on your behalf. </td> </tr> </table> </div> <div class="paragraph"> <p>In an embedded container setup, the <code>ServletContext</code> is set as part of server startup which happens during application context initialization. Because of this beans in the <code>ApplicationContext</code> cannot be reliably initialized with a <code>ServletContext</code>. One way to get around this is to inject <code>ApplicationContext</code> as a dependency of the bean and access the <code>ServletContext</code> only when it is needed. Another way is to use a callback once the server has started. This can be done using an <code>ApplicationListener</code> which listens for the <code>ApplicationStartedEvent</code> as follows:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import jakarta.servlet.ServletContext;

import org.springframework.boot.context.event.ApplicationStartedEvent;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.web.context.WebApplicationContext;

</span><span class="fold-block">public class MyDemoBean implements ApplicationListener&lt;ApplicationStartedEvent&gt; {

    private ServletContext servletContext;

    @Override
    public void onApplicationEvent(ApplicationStartedEvent event) {
        ApplicationContext applicationContext = event.getApplicationContext();
        this.servletContext = ((WebApplicationContext) applicationContext).getServletContext();
    }

}
</span></code></pre> </div> </div> </div> <div class="sect3"> <h4 id="web.servlet.embedded-container.customizing">
1.3.4. Customizing Embedded Servlet Containers</h4> <div class="paragraph"> <p>Common servlet container settings can be configured by using Spring <code>Environment</code> properties. Usually, you would define the properties in your <code>application.properties</code> or <code>application.yaml</code> file.</p> </div> <div class="paragraph"> <p>Common server settings include:</p> </div> <div class="ulist"> <ul> <li> <p>Network settings: Listen port for incoming HTTP requests (<code>server.port</code>), interface address to bind to <code>server.address</code>, and so on.</p> </li> <li> <p>Session settings: Whether the session is persistent (<code>server.servlet.session.persistent</code>), session timeout (<code>server.servlet.session.timeout</code>), location of session data (<code>server.servlet.session.store-dir</code>), and session-cookie configuration (<code>server.servlet.session.cookie.*</code>).</p> </li> <li> <p>Error management: Location of the error page (<code>server.error.path</code>) and so on.</p> </li> <li> <p><a href="howto.html#howto.webserver.configure-ssl">SSL</a></p> </li> <li> <p><a href="howto.html#howto.webserver.enable-response-compression">HTTP compression</a></p> </li> </ul> </div> <div class="paragraph"> <p>Spring Boot tries as much as possible to expose common settings, but this is not always possible. For those cases, dedicated namespaces offer server-specific customizations (see <code>server.tomcat</code> and <code>server.undertow</code>). For instance, <a href="howto.html#howto.webserver.configure-access-logs">access logs</a> can be configured with specific features of the embedded servlet container.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> See the <a href="https://github.com/spring-projects/spring-boot/tree/v3.1.3/spring-boot-project/spring-boot-autoconfigure/src/main/java/org/springframework/boot/autoconfigure/web/ServerProperties.java"><code>ServerProperties</code></a> class for a complete list. </td> </tr> </table> </div> <div class="sect4"> <h5 id="web.servlet.embedded-container.customizing.samesite">
SameSite Cookies</h5> <div class="paragraph"> <p>The <code>SameSite</code> cookie attribute can be used by web browsers to control if and how cookies are submitted in cross-site requests. The attribute is particularly relevant for modern web browsers which have started to change the default value that is used when the attribute is missing.</p> </div> <div class="paragraph"> <p>If you want to change the <code>SameSite</code> attribute of your session cookie, you can use the <code>server.servlet.session.cookie.same-site</code> property. This property is supported by auto-configured Tomcat, Jetty and Undertow servers. It is also used to configure Spring Session servlet based <code>SessionRepository</code> beans.</p> </div> <div class="paragraph"> <p>For example, if you want your session cookie to have a <code>SameSite</code> attribute of <code>None</code>, you can add the following to your <code>application.properties</code> or <code>application.yaml</code> file:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">server.servlet.session.cookie.same-site=none</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">server:
  servlet:
    session:
      cookie:
        same-site: "none"</code></pre> </div> </div> <div class="paragraph"> <p>If you want to change the <code>SameSite</code> attribute on other cookies added to your <code>HttpServletResponse</code>, you can use a <code>CookieSameSiteSupplier</code>. The <code>CookieSameSiteSupplier</code> is passed a <code>Cookie</code> and may return a <code>SameSite</code> value, or <code>null</code>.</p> </div> <div class="paragraph"> <p>There are a number of convenience factory and filter methods that you can use to quickly match specific cookies. For example, adding the following bean will automatically apply a <code>SameSite</code> of <code>Lax</code> for all cookies with a name that matches the regular expression <code>myapp.*</code>.</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MySameSiteConfiguration {

    @Bean
    public CookieSameSiteSupplier applicationCookieSameSiteSupplier() {
        return CookieSameSiteSupplier.ofLax().whenHasNameMatching("myapp.*");
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.servlet.server.CookieSameSiteSupplier
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MySameSiteConfiguration {

    @Bean
    fun applicationCookieSameSiteSupplier(): CookieSameSiteSupplier {
        return CookieSameSiteSupplier.ofLax().whenHasNameMatching("myapp.*")
    }

}
</span></code></pre> </div> </div> </div> <div class="sect4"> <h5 id="web.servlet.embedded-container.customizing.programmatic">
Programmatic Customization</h5> <div class="paragraph"> <p>If you need to programmatically configure your embedded servlet container, you can register a Spring bean that implements the <code>WebServerFactoryCustomizer</code> interface. <code>WebServerFactoryCustomizer</code> provides access to the <code>ConfigurableServletWebServerFactory</code>, which includes numerous customization setter methods. The following example shows programmatically setting the port:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyWebServerFactoryCustomizer implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    @Override
    public void customize(ConfigurableServletWebServerFactory server) {
        server.setPort(9000);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.boot.web.servlet.server.ConfigurableServletWebServerFactory
import org.springframework.stereotype.Component

</span><span class="fold-block">@Component
class MyWebServerFactoryCustomizer : WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; {

    override fun customize(server: ConfigurableServletWebServerFactory) {
        server.setPort(9000)
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p><code>TomcatServletWebServerFactory</code>, <code>JettyServletWebServerFactory</code> and <code>UndertowServletWebServerFactory</code> are dedicated variants of <code>ConfigurableServletWebServerFactory</code> that have additional customization setter methods for Tomcat, Jetty and Undertow respectively. The following example shows how to customize <code>TomcatServletWebServerFactory</code> that provides access to Tomcat-specific configuration options:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import java.time.Duration;

import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory;
import org.springframework.boot.web.server.WebServerFactoryCustomizer;
import org.springframework.stereotype.Component;

</span><span class="fold-block">@Component
public class MyTomcatWebServerFactoryCustomizer implements WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; {

    @Override
    public void customize(TomcatServletWebServerFactory server) {
        server.addConnectorCustomizers((connector) -&gt; connector.setAsyncTimeout(Duration.ofSeconds(20).toMillis()));
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory
import org.springframework.boot.web.server.WebServerFactoryCustomizer
import org.springframework.stereotype.Component
import java.time.Duration

</span><span class="fold-block">@Component
class MyTomcatWebServerFactoryCustomizer : WebServerFactoryCustomizer&lt;TomcatServletWebServerFactory&gt; {

    override fun customize(server: TomcatServletWebServerFactory) {
        server.addConnectorCustomizers({ connector -&gt; connector.asyncTimeout = Duration.ofSeconds(20).toMillis() })
    }

}
</span></code></pre> </div> </div> </div> <div class="sect4"> <h5 id="web.servlet.embedded-container.customizing.direct">
Customizing ConfigurableServletWebServerFactory Directly</h5> <div class="paragraph"> <p>For more advanced use cases that require you to extend from <code>ServletWebServerFactory</code>, you can expose a bean of such type yourself.</p> </div> <div class="paragraph"> <p>Setters are provided for many configuration options. Several protected method “hooks” are also provided should you need to do something more exotic. See the <a href="https://docs.spring.io/spring-boot/docs/3.1.3/api/org/springframework/boot/web/servlet/server/ConfigurableServletWebServerFactory.html">source code documentation</a> for details.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Auto-configured customizers are still applied on your custom factory, so use that option carefully. </td> </tr> </table> </div> </div> </div> <div class="sect3"> <h4 id="web.servlet.embedded-container.jsp-limitations">
1.3.5. JSP Limitations</h4> <div class="paragraph"> <p>When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.</p> </div> <div class="ulist"> <ul> <li> <p>With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with <code>java -jar</code>, and will also be deployable to any standard container. JSPs are not supported when using an executable jar.</p> </li> <li> <p>Undertow does not support JSPs.</p> </li> <li> <p>Creating a custom <code>error.jsp</code> page does not override the default view for <a href="#web.servlet.spring-mvc.error-handling">error handling</a>. <a href="#web.servlet.spring-mvc.error-handling.error-pages">Custom error pages</a> should be used instead.</p> </li> </ul> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="web.reactive">
2. Reactive Web Applications</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot simplifies development of reactive web applications by providing auto-configuration for Spring Webflux.</p> </div> <div class="sect2"> <h3 id="web.reactive.webflux">
2.1. The “Spring WebFlux Framework”</h3> <div class="paragraph"> <p>Spring WebFlux is the new reactive web framework introduced in Spring Framework 5.0. Unlike Spring MVC, it does not require the servlet API, is fully asynchronous and non-blocking, and implements the <a href="https://www.reactive-streams.org/">Reactive Streams</a> specification through <a href="https://projectreactor.io/">the Reactor project</a>.</p> </div> <div class="paragraph"> <p>Spring WebFlux comes in two flavors: functional and annotation-based. The annotation-based one is quite close to the Spring MVC model, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

</span><span class="fold-block">@RestController
@RequestMapping("/users")
public class MyRestController {

    private final UserRepository userRepository;

    private final CustomerRepository customerRepository;

    public MyRestController(UserRepository userRepository, CustomerRepository customerRepository) {
        this.userRepository = userRepository;
        this.customerRepository = customerRepository;
    }

    @GetMapping("/{userId}")
    public Mono&lt;User&gt; getUser(@PathVariable Long userId) {
        return this.userRepository.findById(userId);
    }

    @GetMapping("/{userId}/customers")
    public Flux&lt;Customer&gt; getUserCustomers(@PathVariable Long userId) {
        return this.userRepository.findById(userId).flatMapMany(this.customerRepository::findByUser);
    }

    @DeleteMapping("/{userId}")
    public Mono&lt;Void&gt; deleteUser(@PathVariable Long userId) {
        return this.userRepository.deleteById(userId);
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

</span><span class="fold-block">@RestController
@RequestMapping("/users")
class MyRestController(private val userRepository: UserRepository, private val customerRepository: CustomerRepository) {

    @GetMapping("/{userId}")
    fun getUser(@PathVariable userId: Long): Mono&lt;User?&gt; {
        return userRepository.findById(userId)
    }

    @GetMapping("/{userId}/customers")
    fun getUserCustomers(@PathVariable userId: Long): Flux&lt;Customer&gt; {
        return userRepository.findById(userId).flatMapMany { user: User? -&gt;
            customerRepository.findByUser(user)
        }
    }

    @DeleteMapping("/{userId}")
    fun deleteUser(@PathVariable userId: Long): Mono&lt;Void&gt; {
        return userRepository.deleteById(userId)
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>“WebFlux.fn”, the functional variant, separates the routing configuration from the actual handling of the requests, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.MediaType;
import org.springframework.web.reactive.function.server.RequestPredicate;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.ServerResponse;

import static org.springframework.web.reactive.function.server.RequestPredicates.accept;
import static org.springframework.web.reactive.function.server.RouterFunctions.route;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyRoutingConfiguration {

    private static final RequestPredicate ACCEPT_JSON = accept(MediaType.APPLICATION_JSON);

    @Bean
    public RouterFunction&lt;ServerResponse&gt; monoRouterFunction(MyUserHandler userHandler) {
        return route()
                .GET("/{user}", ACCEPT_JSON, userHandler::getUser)
                .GET("/{user}/customers", ACCEPT_JSON, userHandler::getUserCustomers)
                .DELETE("/{user}", ACCEPT_JSON, userHandler::deleteUser)
                .build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.MediaType
import org.springframework.web.reactive.function.server.RequestPredicates.DELETE
import org.springframework.web.reactive.function.server.RequestPredicates.GET
import org.springframework.web.reactive.function.server.RequestPredicates.accept
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.RouterFunctions
import org.springframework.web.reactive.function.server.ServerResponse

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyRoutingConfiguration {

    @Bean
    fun monoRouterFunction(userHandler: MyUserHandler): RouterFunction&lt;ServerResponse&gt; {
        return RouterFunctions.route(
            GET("/{user}").and(ACCEPT_JSON), userHandler::getUser).andRoute(
            GET("/{user}/customers").and(ACCEPT_JSON), userHandler::getUserCustomers).andRoute(
            DELETE("/{user}").and(ACCEPT_JSON), userHandler::deleteUser)
    }

    companion object {
        private val ACCEPT_JSON = accept(MediaType.APPLICATION_JSON)
    }

}
</span></code></pre> </div> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Mono;

import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;

</span><span class="fold-block">@Component
public class MyUserHandler {

    public Mono&lt;ServerResponse&gt; getUser(ServerRequest request) {
        ...
    }

    public Mono&lt;ServerResponse&gt; getUserCustomers(ServerRequest request) {
        ...
    }

    public Mono&lt;ServerResponse&gt; deleteUser(ServerRequest request) {
        ...
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import reactor.core.publisher.Mono

</span><span class="fold-block">@Component
class MyUserHandler {

    fun getUser(request: ServerRequest?): Mono&lt;ServerResponse&gt; {
        return ServerResponse.ok().build()
    }

    fun getUserCustomers(request: ServerRequest?): Mono&lt;ServerResponse&gt; {
        return ServerResponse.ok().build()
    }

    fun deleteUser(request: ServerRequest?): Mono&lt;ServerResponse&gt; {
        return ServerResponse.ok().build()
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>WebFlux is part of the Spring Framework and detailed information is available in its <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-fn">reference documentation</a>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> You can define as many <code>RouterFunction</code> beans as you like to modularize the definition of the router. Beans can be ordered if you need to apply a precedence. </td> </tr> </table> </div> <div class="paragraph"> <p>To get started, add the <code>spring-boot-starter-webflux</code> module to your application.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Adding both <code>spring-boot-starter-web</code> and <code>spring-boot-starter-webflux</code> modules in your application results in Spring Boot auto-configuring Spring MVC, not WebFlux. This behavior has been chosen because many Spring developers add <code>spring-boot-starter-webflux</code> to their Spring MVC application to use the reactive <code>WebClient</code>. You can still enforce your choice by setting the chosen application type to <code>SpringApplication.setWebApplicationType(WebApplicationType.REACTIVE)</code>. </td> </tr> </table> </div> <div class="sect3"> <h4 id="web.reactive.webflux.auto-configuration">
2.1.1. Spring WebFlux Auto-configuration</h4> <div class="paragraph"> <p>Spring Boot provides auto-configuration for Spring WebFlux that works well with most applications.</p> </div> <div class="paragraph"> <p>The auto-configuration adds the following features on top of Spring’s defaults:</p> </div> <div class="ulist"> <ul> <li> <p>Configuring codecs for <code>HttpMessageReader</code> and <code>HttpMessageWriter</code> instances (described <a href="#web.reactive.webflux.httpcodecs">later in this document</a>).</p> </li> <li> <p>Support for serving static resources, including support for WebJars (described <a href="#web.servlet.spring-mvc.static-content">later in this document</a>).</p> </li> </ul> </div> <div class="paragraph"> <p>If you want to keep Spring Boot WebFlux features and you want to add additional <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-config">WebFlux configuration</a>, you can add your own <code>@Configuration</code> class of type <code>WebFluxConfigurer</code> but <strong>without</strong> <code>@EnableWebFlux</code>.</p> </div> <div class="paragraph"> <p>If you want to take complete control of Spring WebFlux, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebFlux</code>.</p> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.conversion-service">
2.1.2. Spring WebFlux Conversion Service</h4> <div class="paragraph"> <p>If you want to customize the <code>ConversionService</code> used by Spring WebFlux, you can provide a <code>WebFluxConfigurer</code> bean with an <code>addFormatters</code> method.</p> </div> <div class="paragraph"> <p>Conversion can also be customized using the <code>spring.webflux.format.*</code> configuration properties. When not configured, the following defaults are used:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Property</th> <th class="tableblock halign-left valign-top"><code>DateTimeFormatter</code></th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.webflux.format.date</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedDate(FormatStyle.SHORT)</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.webflux.format.time</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedTime(FormatStyle.SHORT)</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring.webflux.format.date-time</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ofLocalizedDateTime(FormatStyle.SHORT)</code></p></td> </tr> </tbody> </table> </div> <div class="sect3"> <h4 id="web.reactive.webflux.httpcodecs">
2.1.3. HTTP Codecs with HttpMessageReaders and HttpMessageWriters</h4> <div class="paragraph"> <p>Spring WebFlux uses the <code>HttpMessageReader</code> and <code>HttpMessageWriter</code> interfaces to convert HTTP requests and responses. They are configured with <code>CodecConfigurer</code> to have sensible defaults by looking at the libraries available in your classpath.</p> </div> <div class="paragraph"> <p>Spring Boot provides dedicated configuration properties for codecs, <code>spring.codec.*</code>. It also applies further customization by using <code>CodecCustomizer</code> instances. For example, <code>spring.jackson.*</code> configuration keys are applied to the Jackson codec.</p> </div> <div class="paragraph"> <p>If you need to add or customize codecs, you can create a custom <code>CodecCustomizer</code> component, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.codec.CodecCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.codec.ServerSentEventHttpMessageReader;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyCodecsConfiguration {

    @Bean
    public CodecCustomizer myCodecCustomizer() {
        return (configurer) -&gt; {
            configurer.registerDefaults(false);
            configurer.customCodecs().register(new ServerSentEventHttpMessageReader());
            // ...
        };
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.codec.CodecCustomizer
import org.springframework.context.annotation.Bean
import org.springframework.http.codec.CodecConfigurer
import org.springframework.http.codec.ServerSentEventHttpMessageReader

</span><span class="fold-block">class MyCodecsConfiguration {

    @Bean
    fun myCodecCustomizer(): CodecCustomizer {
        return CodecCustomizer { configurer: CodecConfigurer -&gt;
            configurer.registerDefaults(false)
            configurer.customCodecs().register(ServerSentEventHttpMessageReader())
        }
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>You can also leverage <a href="features.html#features.json.jackson.custom-serializers-and-deserializers">Boot’s custom JSON serializers and deserializers</a>.</p> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.static-content">
2.1.4. Static Content</h4> <div class="paragraph"> <p>By default, Spring Boot serves static content from a directory called <code>/static</code> (or <code>/public</code> or <code>/resources</code> or <code>/META-INF/resources</code>) in the classpath. It uses the <code>ResourceWebHandler</code> from Spring WebFlux so that you can modify that behavior by adding your own <code>WebFluxConfigurer</code> and overriding the <code>addResourceHandlers</code> method.</p> </div> <div class="paragraph"> <p>By default, resources are mapped on <code>/**</code>, but you can tune that by setting the <code>spring.webflux.static-path-pattern</code> property. For instance, relocating all resources to <code>/resources/**</code> can be achieved as follows:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.webflux.static-path-pattern=/resources/**</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  webflux:
    static-path-pattern: "/resources/**"</code></pre> </div> </div> <div class="paragraph"> <p>You can also customize the static resource locations by using <code>spring.web.resources.static-locations</code>. Doing so replaces the default values with a list of directory locations. If you do so, the default welcome page detection switches to your custom locations. So, if there is an <code>index.html</code> in any of your locations on startup, it is the home page of the application.</p> </div> <div class="paragraph"> <p>In addition to the “standard” static resource locations listed earlier, a special case is made for <a href="https://www.webjars.org/">Webjars content</a>. By default, any resources with a path in <code>/webjars/**</code> are served from jar files if they are packaged in the Webjars format. The path can be customized with the <code>spring.webflux.webjars-path-pattern</code> property.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Spring WebFlux applications do not strictly depend on the servlet API, so they cannot be deployed as war files and do not use the <code>src/main/webapp</code> directory. </td> </tr> </table> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.welcome-page">
2.1.5. Welcome Page</h4> <div class="paragraph"> <p>Spring Boot supports both static and templated welcome pages. It first looks for an <code>index.html</code> file in the configured static content locations. If one is not found, it then looks for an <code>index</code> template. If either is found, it is automatically used as the welcome page of the application.</p> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.template-engines">
2.1.6. Template Engines</h4> <div class="paragraph"> <p>As well as REST web services, you can also use Spring WebFlux to serve dynamic HTML content. Spring WebFlux supports a variety of templating technologies, including Thymeleaf, FreeMarker, and Mustache.</p> </div> <div class="paragraph"> <p>Spring Boot includes auto-configuration support for the following templating engines:</p> </div> <div class="ulist"> <ul> <li> <p><a href="https://freemarker.apache.org/docs/">FreeMarker</a></p> </li> <li> <p><a href="https://www.thymeleaf.org">Thymeleaf</a></p> </li> <li> <p><a href="https://mustache.github.io/">Mustache</a></p> </li> </ul> </div> <div class="paragraph"> <p>When you use one of these templating engines with the default configuration, your templates are picked up automatically from <code>src/main/resources/templates</code>.</p> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.error-handling">
2.1.7. Error Handling</h4> <div class="paragraph"> <p>Spring Boot provides a <code>WebExceptionHandler</code> that handles all errors in a sensible way. Its position in the processing order is immediately before the handlers provided by WebFlux, which are considered last. For machine clients, it produces a JSON response with details of the error, the HTTP status, and the exception message. For browser clients, there is a “whitelabel” error handler that renders the same data in HTML format. You can also provide your own HTML templates to display errors (see the <a href="#web.reactive.webflux.error-handling.error-pages">next section</a>).</p> </div> <div class="paragraph"> <p>Before customizing error handling in Spring Boot directly, you can leverage the <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-ann-rest-exceptions">RFC 7807 Problem Details</a> support in Spring WebFlux. Spring WebFlux can produce custom error messages with the <code>application/problem+json</code> media type, like:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="json"><code class="language-json" data-lang="json">{
  "type": "https://example.org/problems/unknown-project",
  "title": "Unknown project",
  "status": 404,
  "detail": "No project found for id 'spring-unknown'",
  "instance": "/projects/spring-unknown"
}</code></pre> </div> </div> <div class="paragraph"> <p>This support can be enabled by setting <code>spring.webflux.problemdetails.enabled</code> to <code>true</code>.</p> </div> <div class="paragraph"> <p>The first step to customizing this feature often involves using the existing mechanism but replacing or augmenting the error contents. For that, you can add a bean of type <code>ErrorAttributes</code>.</p> </div> <div class="paragraph"> <p>To change the error handling behavior, you can implement <code>ErrorWebExceptionHandler</code> and register a bean definition of that type. Because an <code>ErrorWebExceptionHandler</code> is quite low-level, Spring Boot also provides a convenient <code>AbstractErrorWebExceptionHandler</code> to let you handle errors in a WebFlux functional way, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import reactor.core.publisher.Mono;

import org.springframework.boot.autoconfigure.web.WebProperties.Resources;
import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler;
import org.springframework.boot.web.reactive.error.ErrorAttributes;
import org.springframework.context.ApplicationContext;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.server.RouterFunction;
import org.springframework.web.reactive.function.server.RouterFunctions;
import org.springframework.web.reactive.function.server.ServerRequest;
import org.springframework.web.reactive.function.server.ServerResponse;
import org.springframework.web.reactive.function.server.ServerResponse.BodyBuilder;

</span><span class="fold-block">@Component
public class MyErrorWebExceptionHandler extends AbstractErrorWebExceptionHandler {

    public MyErrorWebExceptionHandler(ErrorAttributes errorAttributes, Resources resources,
            ApplicationContext applicationContext) {
        super(errorAttributes, resources, applicationContext);
    }

    @Override
    protected RouterFunction&lt;ServerResponse&gt; getRoutingFunction(ErrorAttributes errorAttributes) {
        return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml);
    }

    private boolean acceptsXml(ServerRequest request) {
        return request.headers().accept().contains(MediaType.APPLICATION_XML);
    }

    public Mono&lt;ServerResponse&gt; handleErrorAsXml(ServerRequest request) {
        BodyBuilder builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR);
        // ... additional builder calls
        return builder.build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.web.WebProperties
import org.springframework.boot.autoconfigure.web.reactive.error.AbstractErrorWebExceptionHandler
import org.springframework.boot.web.reactive.error.ErrorAttributes
import org.springframework.context.ApplicationContext
import org.springframework.http.HttpStatus
import org.springframework.http.MediaType
import org.springframework.stereotype.Component
import org.springframework.web.reactive.function.server.RouterFunction
import org.springframework.web.reactive.function.server.RouterFunctions
import org.springframework.web.reactive.function.server.ServerRequest
import org.springframework.web.reactive.function.server.ServerResponse
import reactor.core.publisher.Mono

</span><span class="fold-block">@Component
class MyErrorWebExceptionHandler(errorAttributes: ErrorAttributes?, resources: WebProperties.Resources?,
    applicationContext: ApplicationContext?) : AbstractErrorWebExceptionHandler(errorAttributes, resources, applicationContext) {

    override fun getRoutingFunction(errorAttributes: ErrorAttributes): RouterFunction&lt;ServerResponse&gt; {
        return RouterFunctions.route(this::acceptsXml, this::handleErrorAsXml)
    }

    private fun acceptsXml(request: ServerRequest): Boolean {
        return request.headers().accept().contains(MediaType.APPLICATION_XML)
    }

    fun handleErrorAsXml(request: ServerRequest?): Mono&lt;ServerResponse&gt; {
        val builder = ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
        // ... additional builder calls
        return builder.build()
    }

}
</span></code></pre> </div> </div> <div class="paragraph"> <p>For a more complete picture, you can also subclass <code>DefaultErrorWebExceptionHandler</code> directly and override specific methods.</p> </div> <div class="paragraph"> <p>In some cases, errors handled at the controller or handler function level are not recorded by the <a href="actuator.html#actuator.metrics.supported.spring-webflux">metrics infrastructure</a>. Applications can ensure that such exceptions are recorded with the request metrics by setting the handled exception as a request attribute:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.web.reactive.error.ErrorAttributes;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.reactive.result.view.Rendering;
import org.springframework.web.server.ServerWebExchange;

</span><span class="fold-block">@Controller
public class MyExceptionHandlingController {

    @GetMapping("/profile")
    public Rendering userProfile() {
        // ...
        throw new IllegalStateException();
    }

    @ExceptionHandler(IllegalStateException.class)
    public Rendering handleIllegalState(ServerWebExchange exchange, IllegalStateException exc) {
        exchange.getAttributes().putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc);
        return Rendering.view("errorView").modelAttribute("message", exc.getMessage()).build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.web.reactive.error.ErrorAttributes
import org.springframework.stereotype.Controller
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.reactive.result.view.Rendering
import org.springframework.web.server.ServerWebExchange

</span><span class="fold-block">@Controller
class MyExceptionHandlingController {

    @GetMapping("/profile")
    fun userProfile(): Rendering {
        // ...
        throw IllegalStateException()
    }

    @ExceptionHandler(IllegalStateException::class)
    fun handleIllegalState(exchange: ServerWebExchange, exc: IllegalStateException): Rendering {
        exchange.attributes.putIfAbsent(ErrorAttributes.ERROR_ATTRIBUTE, exc)
        return Rendering.view("errorView").modelAttribute("message", exc.message ?: "").build()
    }

}
</span></code></pre> </div> </div> <div class="sect4"> <h5 id="web.reactive.webflux.error-handling.error-pages">
Custom Error Pages</h5> <div class="paragraph"> <p>If you want to display a custom HTML error page for a given status code, you can add views that resolve from <code>error/*</code>, for example by adding files to a <code>/error</code> directory. Error pages can either be static HTML (that is, added under any of the static resource directories) or built with templates. The name of the file should be the exact status code, a status code series mask, or <code>error</code> for a default if nothing else matches. Note that the path to the default error view is <code>error/error</code>, whereas with Spring MVC the default error view is <code>error</code>.</p> </div> <div class="paragraph"> <p>For example, to map <code>404</code> to a static HTML file, your directory structure would be as follows:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language=""><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- public/
             +- error/
             |   +- 404.html
             +- &lt;other public assets&gt;</code></pre> </div> </div> <div class="paragraph"> <p>To map all <code>5xx</code> errors by using a Mustache template, your directory structure would be as follows:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language=""><code>src/
 +- main/
     +- java/
     |   + &lt;source code&gt;
     +- resources/
         +- templates/
             +- error/
             |   +- 5xx.mustache
             +- &lt;other templates&gt;</code></pre> </div> </div> </div> </div> <div class="sect3"> <h4 id="web.reactive.webflux.web-filters">
2.1.8. Web Filters</h4> <div class="paragraph"> <p>Spring WebFlux provides a <code>WebFilter</code> interface that can be implemented to filter HTTP request-response exchanges. <code>WebFilter</code> beans found in the application context will be automatically used to filter each exchange.</p> </div> <div class="paragraph"> <p>Where the order of the filters is important they can implement <code>Ordered</code> or be annotated with <code>@Order</code>. Spring Boot auto-configuration may configure web filters for you. When it does so, the orders shown in the following table will be used:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 50%;"> <col style="width: 50%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Web Filter</th> <th class="tableblock halign-left valign-top">Order</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>ServerHttpObservationFilter</code> (Micrometer Observability)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.HIGHEST_PRECEDENCE + 1</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>WebFilterChainProxy</code> (Spring Security)</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>-100</code></p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>HttpExchangesWebFilter</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>Ordered.LOWEST_PRECEDENCE - 10</code></p></td> </tr> </tbody> </table> </div> </div> <div class="sect2"> <h3 id="web.reactive.reactive-server">
2.2. Embedded Reactive Server Support</h3> <div class="paragraph"> <p>Spring Boot includes support for the following embedded reactive web servers: Reactor Netty, Tomcat, Jetty, and Undertow. Most developers use the appropriate “Starter” to obtain a fully configured instance. By default, the embedded server listens for HTTP requests on port 8080.</p> </div> </div> <div class="sect2"> <h3 id="web.reactive.reactive-server-resources-configuration">
2.3. Reactive Server Resources Configuration</h3> <div class="paragraph"> <p>When auto-configuring a Reactor Netty or Jetty server, Spring Boot will create specific beans that will provide HTTP resources to the server instance: <code>ReactorResourceFactory</code> or <code>JettyResourceFactory</code>.</p> </div> <div class="paragraph"> <p>By default, those resources will be also shared with the Reactor Netty and Jetty clients for optimal performances, given:</p> </div> <div class="ulist"> <ul> <li> <p>the same technology is used for server and client</p> </li> <li> <p>the client instance is built using the <code>WebClient.Builder</code> bean auto-configured by Spring Boot</p> </li> </ul> </div> <div class="paragraph"> <p>Developers can override the resource configuration for Jetty and Reactor Netty by providing a custom <code>ReactorResourceFactory</code> or <code>JettyResourceFactory</code> bean - this will be applied to both clients and servers.</p> </div> <div class="paragraph"> <p>You can learn more about the resource configuration on the client side in the <a href="io.html#io.rest-client.webclient.runtime">WebClient Runtime section</a>.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="web.graceful-shutdown">
3. Graceful Shutdown</h2> <div class="sectionbody"> <div class="paragraph"> <p>Graceful shutdown is supported with all four embedded web servers (Jetty, Reactor Netty, Tomcat, and Undertow) and with both reactive and servlet-based web applications. It occurs as part of closing the application context and is performed in the earliest phase of stopping <code>SmartLifecycle</code> beans. This stop processing uses a timeout which provides a grace period during which existing requests will be allowed to complete but no new requests will be permitted. The exact way in which new requests are not permitted varies depending on the web server that is being used. Jetty, Reactor Netty, and Tomcat will stop accepting requests at the network layer. Undertow will accept requests but respond immediately with a service unavailable (503) response.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> Graceful shutdown with Tomcat requires Tomcat 9.0.33 or later. </td> </tr> </table> </div> <div class="paragraph"> <p>To enable graceful shutdown, configure the <code>server.shutdown</code> property, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">server.shutdown=graceful</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">server:
  shutdown: "graceful"</code></pre> </div> </div> <div class="paragraph"> <p>To configure the timeout period, configure the <code>spring.lifecycle.timeout-per-shutdown-phase</code> property, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.lifecycle.timeout-per-shutdown-phase=20s</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  lifecycle:
    timeout-per-shutdown-phase: "20s"</code></pre> </div> </div> <div class="admonitionblock important"> <table> <tr> <td class="icon">  </td> <td class="content"> Using graceful shutdown with your IDE may not work properly if it does not send a proper <code>SIGTERM</code> signal. See the documentation of your IDE for more details. </td> </tr> </table> </div> </div> </div> <div class="sect1"> <h2 id="web.security">
4. Spring Security</h2> <div class="sectionbody"> <div class="paragraph"> <p>If <a href="https://spring.io/projects/spring-security">Spring Security</a> is on the classpath, then web applications are secured by default. Spring Boot relies on Spring Security’s content-negotiation strategy to determine whether to use <code>httpBasic</code> or <code>formLogin</code>. To add method-level security to a web application, you can also add <code>@EnableGlobalMethodSecurity</code> with your desired settings. Additional information can be found in the <a href="https://docs.spring.io/spring-security/reference/6.1.3/servlet/authorization/method-security.html">Spring Security Reference Guide</a>.</p> </div> <div class="paragraph"> <p>The default <code>UserDetailsService</code> has a single user. The user name is <code>user</code>, and the password is random and is printed at WARN level when the application starts, as shown in the following example:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">Using generated security password: 78fa095d-3f4c-48b1-ad50-e24c31d5cf35

This generated password is for development use only. Your security configuration must be updated before running your application in production.</pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you fine-tune your logging configuration, ensure that the <code>org.springframework.boot.autoconfigure.security</code> category is set to log <code>WARN</code>-level messages. Otherwise, the default password is not printed. </td> </tr> </table> </div> <div class="paragraph"> <p>You can change the username and password by providing a <code>spring.security.user.name</code> and <code>spring.security.user.password</code>.</p> </div> <div class="paragraph"> <p>The basic features you get by default in a web application are:</p> </div> <div class="ulist"> <ul> <li> <p>A <code>UserDetailsService</code> (or <code>ReactiveUserDetailsService</code> in case of a WebFlux application) bean with in-memory store and a single user with a generated password (see <a href="https://docs.spring.io/spring-boot/docs/3.1.3/api/org/springframework/boot/autoconfigure/security/SecurityProperties.User.html"><code>SecurityProperties.User</code></a> for the properties of the user).</p> </li> <li> <p>Form-based login or HTTP Basic security (depending on the <code>Accept</code> header in the request) for the entire application (including actuator endpoints if actuator is on the classpath).</p> </li> <li> <p>A <code>DefaultAuthenticationEventPublisher</code> for publishing authentication events.</p> </li> </ul> </div> <div class="paragraph"> <p>You can provide a different <code>AuthenticationEventPublisher</code> by adding a bean for it.</p> </div> <div class="sect2"> <h3 id="web.security.spring-mvc">
4.1. MVC Security</h3> <div class="paragraph"> <p>The default security configuration is implemented in <code>SecurityAutoConfiguration</code> and <code>UserDetailsServiceAutoConfiguration</code>. <code>SecurityAutoConfiguration</code> imports <code>SpringBootWebSecurityConfiguration</code> for web security and <code>UserDetailsServiceAutoConfiguration</code> configures authentication, which is also relevant in non-web applications. To switch off the default web application security configuration completely or to combine multiple Spring Security components such as OAuth2 Client and Resource Server, add a bean of type <code>SecurityFilterChain</code> (doing so does not disable the <code>UserDetailsService</code> configuration or Actuator’s security).</p> </div> <div class="paragraph"> <p>To also switch off the <code>UserDetailsService</code> configuration, you can add a bean of type <code>UserDetailsService</code>, <code>AuthenticationProvider</code>, or <code>AuthenticationManager</code>.</p> </div> <div class="paragraph"> <p>Access rules can be overridden by adding a custom <code>SecurityFilterChain</code> bean. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. <code>EndpointRequest</code> can be used to create a <code>RequestMatcher</code> that is based on the <code>management.endpoints.web.base-path</code> property. <code>PathRequest</code> can be used to create a <code>RequestMatcher</code> for resources in commonly used locations.</p> </div> </div> <div class="sect2"> <h3 id="web.security.spring-webflux">
4.2. WebFlux Security</h3> <div class="paragraph"> <p>Similar to Spring MVC applications, you can secure your WebFlux applications by adding the <code>spring-boot-starter-security</code> dependency. The default security configuration is implemented in <code>ReactiveSecurityAutoConfiguration</code> and <code>UserDetailsServiceAutoConfiguration</code>. <code>ReactiveSecurityAutoConfiguration</code> imports <code>WebFluxSecurityConfiguration</code> for web security and <code>UserDetailsServiceAutoConfiguration</code> configures authentication, which is also relevant in non-web applications. To switch off the default web application security configuration completely, you can add a bean of type <code>WebFilterChainProxy</code> (doing so does not disable the <code>UserDetailsService</code> configuration or Actuator’s security).</p> </div> <div class="paragraph"> <p>To also switch off the <code>UserDetailsService</code> configuration, you can add a bean of type <code>ReactiveUserDetailsService</code> or <code>ReactiveAuthenticationManager</code>.</p> </div> <div class="paragraph"> <p>Access rules and the use of multiple Spring Security components such as OAuth 2 Client and Resource Server can be configured by adding a custom <code>SecurityWebFilterChain</code> bean. Spring Boot provides convenience methods that can be used to override access rules for actuator endpoints and static resources. <code>EndpointRequest</code> can be used to create a <code>ServerWebExchangeMatcher</code> that is based on the <code>management.endpoints.web.base-path</code> property.</p> </div> <div class="paragraph"> <p><code>PathRequest</code> can be used to create a <code>ServerWebExchangeMatcher</code> for resources in commonly used locations.</p> </div> <div class="paragraph"> <p>For example, you can customize your security configuration by adding something like:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.security.reactive.PathRequest;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MyWebFluxSecurityConfiguration {

    @Bean
    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) {
        http.authorizeExchange((exchange) -&gt; {
            exchange.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll();
            exchange.pathMatchers("/foo", "/bar").authenticated();
        });
        http.formLogin(withDefaults());
        return http.build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.boot.autoconfigure.security.reactive.PathRequest
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.Customizer
import org.springframework.security.config.Customizer.withDefaults
import org.springframework.security.config.web.server.ServerHttpSecurity
import org.springframework.security.web.server.SecurityWebFilterChain

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
class MyWebFluxSecurityConfiguration {

    @Bean
    fun springSecurityFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {
        http.authorizeExchange { spec -&gt;
            spec.matchers(PathRequest.toStaticResources().atCommonLocations()).permitAll()
            spec.pathMatchers("/foo", "/bar").authenticated()
        }
        http.formLogin(withDefaults())
        return http.build()
    }

}
</span></code></pre> </div> </div> </div> <div class="sect2"> <h3 id="web.security.oauth2">
4.3. OAuth2</h3> <div class="paragraph"> <p><a href="https://oauth.net/2/">OAuth2</a> is a widely used authorization framework that is supported by Spring.</p> </div> <div class="sect3"> <h4 id="web.security.oauth2.client">
4.3.1. Client</h4> <div class="paragraph"> <p>If you have <code>spring-security-oauth2-client</code> on your classpath, you can take advantage of some auto-configuration to set up OAuth2/Open ID Connect clients. This configuration makes use of the properties under <code>OAuth2ClientProperties</code>. The same properties are applicable to both servlet and reactive applications.</p> </div> <div class="paragraph"> <p>You can register multiple OAuth2 clients and providers under the <code>spring.security.oauth2.client</code> prefix, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-login-client.client-id=abcd
spring.security.oauth2.client.registration.my-login-client.client-secret=password
spring.security.oauth2.client.registration.my-login-client.client-name=Client for OpenID Connect
spring.security.oauth2.client.registration.my-login-client.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-login-client.scope=openid,profile,email,phone,address
spring.security.oauth2.client.registration.my-login-client.redirect-uri={baseUrl}/login/oauth2/code/{registrationId}
spring.security.oauth2.client.registration.my-login-client.client-authentication-method=client_secret_basic
spring.security.oauth2.client.registration.my-login-client.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-1.client-id=abcd
spring.security.oauth2.client.registration.my-client-1.client-secret=password
spring.security.oauth2.client.registration.my-client-1.client-name=Client for user scope
spring.security.oauth2.client.registration.my-client-1.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-1.scope=user
spring.security.oauth2.client.registration.my-client-1.redirect-uri={baseUrl}/authorized/user
spring.security.oauth2.client.registration.my-client-1.client-authentication-method=client_secret_basic
spring.security.oauth2.client.registration.my-client-1.authorization-grant-type=authorization_code

spring.security.oauth2.client.registration.my-client-2.client-id=abcd
spring.security.oauth2.client.registration.my-client-2.client-secret=password
spring.security.oauth2.client.registration.my-client-2.client-name=Client for email scope
spring.security.oauth2.client.registration.my-client-2.provider=my-oauth-provider
spring.security.oauth2.client.registration.my-client-2.scope=email
spring.security.oauth2.client.registration.my-client-2.redirect-uri={baseUrl}/authorized/email
spring.security.oauth2.client.registration.my-client-2.client-authentication-method=client_secret_basic
spring.security.oauth2.client.registration.my-client-2.authorization-grant-type=authorization_code

spring.security.oauth2.client.provider.my-oauth-provider.authorization-uri=https://my-auth-server.com/oauth2/authorize
spring.security.oauth2.client.provider.my-oauth-provider.token-uri=https://my-auth-server.com/oauth2/token
spring.security.oauth2.client.provider.my-oauth-provider.user-info-uri=https://my-auth-server.com/userinfo
spring.security.oauth2.client.provider.my-oauth-provider.user-info-authentication-method=header
spring.security.oauth2.client.provider.my-oauth-provider.jwk-set-uri=https://my-auth-server.com/oauth2/jwks
spring.security.oauth2.client.provider.my-oauth-provider.user-name-attribute=name</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          my-login-client:
            client-id: "abcd"
            client-secret: "password"
            client-name: "Client for OpenID Connect"
            provider: "my-oauth-provider"
            scope: "openid,profile,email,phone,address"
            redirect-uri: "{baseUrl}/login/oauth2/code/{registrationId}"
            client-authentication-method: "client_secret_basic"
            authorization-grant-type: "authorization_code"

          my-client-1:
            client-id: "abcd"
            client-secret: "password"
            client-name: "Client for user scope"
            provider: "my-oauth-provider"
            scope: "user"
            redirect-uri: "{baseUrl}/authorized/user"
            client-authentication-method: "client_secret_basic"
            authorization-grant-type: "authorization_code"

          my-client-2:
            client-id: "abcd"
            client-secret: "password"
            client-name: "Client for email scope"
            provider: "my-oauth-provider"
            scope: "email"
            redirect-uri: "{baseUrl}/authorized/email"
            client-authentication-method: "client_secret_basic"
            authorization-grant-type: "authorization_code"

        provider:
          my-oauth-provider:
            authorization-uri: "https://my-auth-server.com/oauth2/authorize"
            token-uri: "https://my-auth-server.com/oauth2/token"
            user-info-uri: "https://my-auth-server.com/userinfo"
            user-info-authentication-method: "header"
            jwk-set-uri: "https://my-auth-server.com/oauth2/jwks"
            user-name-attribute: "name"</code></pre> </div> </div> <div class="paragraph"> <p>For OpenID Connect providers that support <a href="https://openid.net/specs/openid-connect-discovery-1_0.html">OpenID Connect discovery</a>, the configuration can be further simplified. The provider needs to be configured with an <code>issuer-uri</code> which is the URI that it asserts as its Issuer Identifier. For example, if the <code>issuer-uri</code> provided is "https://example.com", then an "OpenID Provider Configuration Request" will be made to "https://example.com/.well-known/openid-configuration". The result is expected to be an "OpenID Provider Configuration Response". The following example shows how an OpenID Connect Provider can be configured with the <code>issuer-uri</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.provider.oidc-provider.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        provider:
          oidc-provider:
            issuer-uri: "https://dev-123456.oktapreview.com/oauth2/default/"</code></pre> </div> </div> <div class="paragraph"> <p>By default, Spring Security’s <code>OAuth2LoginAuthenticationFilter</code> only processes URLs matching <code>/login/oauth2/code/*</code>. If you want to customize the <code>redirect-uri</code> to use a different pattern, you need to provide configuration to process that custom pattern. For example, for servlet applications, you can add your own <code>SecurityFilterChain</code> that resembles the following:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.web.SecurityFilterChain;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
@EnableWebSecurity
public class MyOAuthClientConfiguration {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests((requests) -&gt; requests
                .anyRequest().authenticated()
            )
            .oauth2Login((login) -&gt; login
                .redirectionEndpoint((endpoint) -&gt; endpoint
                    .baseUri("/login/oauth2/callback/*")
                )
            );
        return http.build();
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.invoke
import org.springframework.security.web.SecurityFilterChain

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
@EnableWebSecurity
open class MyOAuthClientConfiguration {

    @Bean
    open fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            authorizeHttpRequests {
                authorize(anyRequest, authenticated)
            }
            oauth2Login {
                redirectionEndpoint {
                    baseUri = "/login/oauth2/callback/*"
                }
            }
        }
        return http.build()
    }

}
</span></code></pre> </div> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Spring Boot auto-configures an <code>InMemoryOAuth2AuthorizedClientService</code> which is used by Spring Security for the management of client registrations. The <code>InMemoryOAuth2AuthorizedClientService</code> has limited capabilities and we recommend using it only for development environments. For production environments, consider using a <code>JdbcOAuth2AuthorizedClientService</code> or creating your own implementation of <code>OAuth2AuthorizedClientService</code>. </td> </tr> </table> </div> <div class="sect4"> <h5 id="web.security.oauth2.client.common-providers">
OAuth2 Client Registration for Common Providers</h5> <div class="paragraph"> <p>For common OAuth2 and OpenID providers, including Google, Github, Facebook, and Okta, we provide a set of provider defaults (<code>google</code>, <code>github</code>, <code>facebook</code>, and <code>okta</code>, respectively).</p> </div> <div class="paragraph"> <p>If you do not need to customize these providers, you can set the <code>provider</code> attribute to the one for which you need to infer defaults. Also, if the key for the client registration matches a default supported provider, Spring Boot infers that as well.</p> </div> <div class="paragraph"> <p>In other words, the two configurations in the following example use the Google provider:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.client.registration.my-client.client-id=abcd
spring.security.oauth2.client.registration.my-client.client-secret=password
spring.security.oauth2.client.registration.my-client.provider=google
spring.security.oauth2.client.registration.google.client-id=abcd
spring.security.oauth2.client.registration.google.client-secret=password</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      client:
        registration:
          my-client:
            client-id: "abcd"
            client-secret: "password"
            provider: "google"
          google:
            client-id: "abcd"
            client-secret: "password"</code></pre> </div> </div> </div> </div> <div class="sect3"> <h4 id="web.security.oauth2.server">
4.3.2. Resource Server</h4> <div class="paragraph"> <p>If you have <code>spring-security-oauth2-resource-server</code> on your classpath, Spring Boot can set up an OAuth2 Resource Server. For JWT configuration, a JWK Set URI or OIDC Issuer URI needs to be specified, as shown in the following examples:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.jwk-set-uri=https://example.com/oauth2/default/v1/keys</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          jwk-set-uri: "https://example.com/oauth2/default/v1/keys"</code></pre> </div> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.issuer-uri=https://dev-123456.oktapreview.com/oauth2/default/</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          issuer-uri: "https://dev-123456.oktapreview.com/oauth2/default/"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If the authorization server does not support a JWK Set URI, you can configure the resource server with the Public Key used for verifying the signature of the JWT. This can be done using the <code>spring.security.oauth2.resourceserver.jwt.public-key-location</code> property, where the value needs to point to a file containing the public key in the PEM-encoded x509 format. </td> </tr> </table> </div> <div class="paragraph"> <p>The <code>spring.security.oauth2.resourceserver.jwt.audiences</code> property can be used to specify the expected values of the aud claim in JWTs. For example, to require JWTs to contain an aud claim with the value <code>my-audience</code>:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.jwt.audiences[0]=my-audience</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          audiences:
            - "my-audience"</code></pre> </div> </div> <div class="paragraph"> <p>The same properties are applicable for both servlet and reactive applications. Alternatively, you can define your own <code>JwtDecoder</code> bean for servlet applications or a <code>ReactiveJwtDecoder</code> for reactive applications.</p> </div> <div class="paragraph"> <p>In cases where opaque tokens are used instead of JWTs, you can configure the following properties to validate tokens through introspection:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.resourceserver.opaquetoken.introspection-uri=https://example.com/check-token
spring.security.oauth2.resourceserver.opaquetoken.client-id=my-client-id
spring.security.oauth2.resourceserver.opaquetoken.client-secret=my-client-secret</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      resourceserver:
        opaquetoken:
          introspection-uri: "https://example.com/check-token"
          client-id: "my-client-id"
          client-secret: "my-client-secret"</code></pre> </div> </div> <div class="paragraph"> <p>Again, the same properties are applicable for both servlet and reactive applications. Alternatively, you can define your own <code>OpaqueTokenIntrospector</code> bean for servlet applications or a <code>ReactiveOpaqueTokenIntrospector</code> for reactive applications.</p> </div> </div> <div class="sect3"> <h4 id="web.security.oauth2.authorization-server">
4.3.3. Authorization Server</h4> <div class="paragraph"> <p>If you have <code>spring-security-oauth2-authorization-server</code> on your classpath, you can take advantage of some auto-configuration to set up a Servlet-based OAuth2 Authorization Server.</p> </div> <div class="paragraph"> <p>You can register multiple OAuth2 clients under the <code>spring.security.oauth2.authorizationserver.client</code> prefix, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-id=abcd
spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-secret={noop}secret1
spring.security.oauth2.authorizationserver.client.my-client-1.registration.client-authentication-methods[0]=client_secret_basic
spring.security.oauth2.authorizationserver.client.my-client-1.registration.authorization-grant-types[0]=authorization_code
spring.security.oauth2.authorizationserver.client.my-client-1.registration.authorization-grant-types[1]=refresh_token
spring.security.oauth2.authorizationserver.client.my-client-1.registration.redirect-uris[0]=https://my-client-1.com/login/oauth2/code/abcd
spring.security.oauth2.authorizationserver.client.my-client-1.registration.redirect-uris[1]=https://my-client-1.com/authorized
spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[0]=openid
spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[1]=profile
spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[2]=email
spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[3]=phone
spring.security.oauth2.authorizationserver.client.my-client-1.registration.scopes[4]=address
spring.security.oauth2.authorizationserver.client.my-client-1.require-authorization-consent=true
spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-id=efgh
spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-secret={noop}secret2
spring.security.oauth2.authorizationserver.client.my-client-2.registration.client-authentication-methods[0]=client_secret_jwt
spring.security.oauth2.authorizationserver.client.my-client-2.registration.authorization-grant-types[0]=client_credentials
spring.security.oauth2.authorizationserver.client.my-client-2.registration.scopes[0]=user.read
spring.security.oauth2.authorizationserver.client.my-client-2.registration.scopes[1]=user.write
spring.security.oauth2.authorizationserver.client.my-client-2.jwk-set-uri=https://my-client-2.com/jwks
spring.security.oauth2.authorizationserver.client.my-client-2.token-endpoint-authentication-signing-algorithm=RS256</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    oauth2:
      authorizationserver:
        client:
          my-client-1:
            registration:
              client-id: "abcd"
              client-secret: "{noop}secret1"
              client-authentication-methods:
                - "client_secret_basic"
              authorization-grant-types:
                - "authorization_code"
                - "refresh_token"
              redirect-uris:
                - "https://my-client-1.com/login/oauth2/code/abcd"
                - "https://my-client-1.com/authorized"
              scopes:
                - "openid"
                - "profile"
                - "email"
                - "phone"
                - "address"
            require-authorization-consent: true
          my-client-2:
            registration:
              client-id: "efgh"
              client-secret: "{noop}secret2"
              client-authentication-methods:
                - "client_secret_jwt"
              authorization-grant-types:
                - "client_credentials"
              scopes:
                - "user.read"
                - "user.write"
            jwk-set-uri: "https://my-client-2.com/jwks"
            token-endpoint-authentication-signing-algorithm: "RS256"</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The <code>client-secret</code> property must be in a format that can be matched by the configured <code>PasswordEncoder</code>. The default instance of <code>PasswordEncoder</code> is created via <code>PasswordEncoderFactories.createDelegatingPasswordEncoder()</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>The auto-configuration Spring Boot provides for Spring Authorization Server is designed for getting started quickly. Most applications will require customization and will want to define several beans to override auto-configuration.</p> </div> <div class="paragraph"> <p>The following components can be defined as beans to override auto-configuration specific to Spring Authorization Server:</p> </div> <div class="ulist"> <ul> <li> <p><code>RegisteredClientRepository</code></p> </li> <li> <p><code>AuthorizationServerSettings</code></p> </li> <li> <p><code>SecurityFilterChain</code></p> </li> <li> <p><code>com.nimbusds.jose.jwk.source.JWKSource&lt;com.nimbusds.jose.proc.SecurityContext&gt;</code></p> </li> <li> <p><code>JwtDecoder</code></p> </li> </ul> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> Spring Boot auto-configures an <code>InMemoryRegisteredClientRepository</code> which is used by Spring Authorization Server for the management of registered clients. The <code>InMemoryRegisteredClientRepository</code> has limited capabilities and we recommend using it only for development environments. For production environments, consider using a <code>JdbcRegisteredClientRepository</code> or creating your own implementation of <code>RegisteredClientRepository</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>Additional information can be found in the <a href="https://docs.spring.io/spring-authorization-server/docs/1.1.2/reference/html/getting-started.html">Getting Started</a> chapter of the <a href="https://docs.spring.io/spring-authorization-server/docs/1.1.2/reference/html/index.html">Spring Authorization Server Reference Guide</a>.</p> </div> </div> </div> <div class="sect2"> <h3 id="web.security.saml2">
4.4. SAML 2.0</h3> <div class="sect3"> <h4 id="web.security.saml2.relying-party">
4.4.1. Relying Party</h4> <div class="paragraph"> <p>If you have <code>spring-security-saml2-service-provider</code> on your classpath, you can take advantage of some auto-configuration to set up a SAML 2.0 Relying Party. This configuration makes use of the properties under <code>Saml2RelyingPartyProperties</code>.</p> </div> <div class="paragraph"> <p>A relying party registration represents a paired configuration between an Identity Provider, IDP, and a Service Provider, SP. You can register multiple relying parties under the <code>spring.security.saml2.relyingparty</code> prefix, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party1.decryption.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.url=https://myapp/logout/saml2/slo
spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.response-url=https://remoteidp2.slo.url
spring.security.saml2.relyingparty.registration.my-relying-party1.singlelogout.binding=POST
spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.verification.credentials[0].certificate-location=path-to-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.entity-id=remote-idp-entity-id1
spring.security.saml2.relyingparty.registration.my-relying-party1.assertingparty.sso-url=https://remoteidp1.sso.url

spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.signing.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].private-key-location=path-to-private-key
spring.security.saml2.relyingparty.registration.my-relying-party2.decryption.credentials[0].certificate-location=path-to-certificate
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.verification.credentials[0].certificate-location=path-to-other-verification-cert
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.entity-id=remote-idp-entity-id2
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.sso-url=https://remoteidp2.sso.url
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.url=https://remoteidp2.slo.url
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.response-url=https://myapp/logout/saml2/slo
spring.security.saml2.relyingparty.registration.my-relying-party2.assertingparty.singlelogout.binding=POST</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  security:
    saml2:
      relyingparty:
        registration:
          my-relying-party1:
            signing:
              credentials:
              - private-key-location: "path-to-private-key"
                certificate-location: "path-to-certificate"
            decryption:
              credentials:
              - private-key-location: "path-to-private-key"
                certificate-location: "path-to-certificate"
            singlelogout:
               url: "https://myapp/logout/saml2/slo"
               response-url: "https://remoteidp2.slo.url"
               binding: "POST"
            assertingparty:
              verification:
                credentials:
                - certificate-location: "path-to-verification-cert"
              entity-id: "remote-idp-entity-id1"
              sso-url: "https://remoteidp1.sso.url"

          my-relying-party2:
            signing:
              credentials:
              - private-key-location: "path-to-private-key"
                certificate-location: "path-to-certificate"
            decryption:
              credentials:
              - private-key-location: "path-to-private-key"
                certificate-location: "path-to-certificate"
            assertingparty:
              verification:
                credentials:
                - certificate-location: "path-to-other-verification-cert"
              entity-id: "remote-idp-entity-id2"
              sso-url: "https://remoteidp2.sso.url"
              singlelogout:
                url: "https://remoteidp2.slo.url"
                response-url: "https://myapp/logout/saml2/slo"
                binding: "POST"</code></pre> </div> </div> <div class="paragraph"> <p>For SAML2 logout, by default, Spring Security’s <code>Saml2LogoutRequestFilter</code> and <code>Saml2LogoutResponseFilter</code> only process URLs matching <code>/logout/saml2/slo</code>. If you want to customize the <code>url</code> to which AP-initiated logout requests get sent to or the <code>response-url</code> to which an AP sends logout responses to, to use a different pattern, you need to provide configuration to process that custom pattern. For example, for servlet applications, you can add your own <code>SecurityFilterChain</code> that resembles the following:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.web.SecurityFilterChain;

import static org.springframework.security.config.Customizer.withDefaults;

</span><span class="fold-block">@Configuration(proxyBeanMethods = false)
public class MySamlRelyingPartyConfiguration {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests((requests) -&gt; requests.anyRequest().authenticated());
        http.saml2Login(withDefaults());
        http.saml2Logout((saml2) -&gt; saml2.logoutRequest((request) -&gt; request.logoutUrl("/SLOService.saml2"))
            .logoutResponse((response) -&gt; response.logoutUrl("/SLOService.saml2")));
        return http.build();
    }

}
</span></code></pre> </div> </div> </div> </div> </div> </div> <div class="sect1"> <h2 id="web.spring-session">
5. Spring Session</h2> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot provides <a href="https://spring.io/projects/spring-session">Spring Session</a> auto-configuration for a wide range of data stores. When building a servlet web application, the following stores can be auto-configured:</p> </div> <div class="ulist"> <ul> <li> <p>Redis</p> </li> <li> <p>JDBC</p> </li> <li> <p>Hazelcast</p> </li> <li> <p>MongoDB</p> </li> </ul> </div> <div class="paragraph"> <p>Additionally, <a href="https://github.com/spring-projects/spring-boot-data-geode">Spring Boot for Apache Geode</a> provides <a href="https://docs.spring.io/spring-boot-data-geode-build/2.0.x/reference/html5/#geode-session">auto-configuration for using Apache Geode as a session store</a>.</p> </div> <div class="paragraph"> <p>The servlet auto-configuration replaces the need to use <code>@Enable*HttpSession</code>.</p> </div> <div class="paragraph"> <p>If a single Spring Session module is present on the classpath, Spring Boot uses that store implementation automatically. If you have more than one implementation, Spring Boot uses the following order for choosing a specific implementation:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Redis</p> </li> <li> <p>JDBC</p> </li> <li> <p>Hazelcast</p> </li> <li> <p>MongoDB</p> </li> <li> <p>If none of Redis, JDBC, Hazelcast and MongoDB are available, we do not configure a <code>SessionRepository</code>.</p> </li> </ol> </div> <div class="paragraph"> <p>When building a reactive web application, the following stores can be auto-configured:</p> </div> <div class="ulist"> <ul> <li> <p>Redis</p> </li> <li> <p>MongoDB</p> </li> </ul> </div> <div class="paragraph"> <p>The reactive auto-configuration replaces the need to use <code>@Enable*WebSession</code>.</p> </div> <div class="paragraph"> <p>Similar to the servlet configuration, if you have more than one implementation, Spring Boot uses the following order for choosing a specific implementation:</p> </div> <div class="olist arabic"> <ol class="arabic"> <li> <p>Redis</p> </li> <li> <p>MongoDB</p> </li> <li> <p>If neither Redis nor MongoDB are available, we do not configure a <code>ReactiveSessionRepository</code>.</p> </li> </ol> </div> <div class="paragraph"> <p>Each store has specific additional settings. For instance, it is possible to customize the name of the table for the JDBC store, as shown in the following example:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.session.jdbc.table-name=SESSIONS</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  session:
    jdbc:
      table-name: "SESSIONS"</code></pre> </div> </div> <div class="paragraph"> <p>For setting the timeout of the session you can use the <code>spring.session.timeout</code> property. If that property is not set with a servlet web application, the auto-configuration falls back to the value of <code>server.servlet.session.timeout</code>.</p> </div> <div class="paragraph"> <p>You can take control over Spring Session’s configuration using <code>@Enable*HttpSession</code> (servlet) or <code>@Enable*WebSession</code> (reactive). This will cause the auto-configuration to back off. Spring Session can then be configured using the annotation’s attributes rather than the previously described configuration properties.</p> </div> </div> </div> <div class="sect1"> <h2 id="web.graphql">
6. Spring for GraphQL</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you want to build GraphQL applications, you can take advantage of Spring Boot’s auto-configuration for <a href="https://spring.io/projects/spring-graphql">Spring for GraphQL</a>. The Spring for GraphQL project is based on <a href="https://github.com/graphql-java/graphql-java">GraphQL Java</a>. You’ll need the <code>spring-boot-starter-graphql</code> starter at a minimum. Because GraphQL is transport-agnostic, you’ll also need to have one or more additional starters in your application to expose your GraphQL API over the web:</p> </div> <table class="tableblock frame-all grid-all stretch"> <colgroup> <col style="width: 33.3333%;"> <col style="width: 33.3333%;"> <col style="width: 33.3334%;"> </colgroup> <thead> <tr> <th class="tableblock halign-left valign-top">Starter</th> <th class="tableblock halign-left valign-top">Transport</th> <th class="tableblock halign-left valign-top">Implementation</th> </tr> </thead> <tbody> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-web</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">HTTP</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Spring MVC</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-websocket</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">WebSocket</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">WebSocket for Servlet apps</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-webflux</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">HTTP, WebSocket</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Spring WebFlux</p></td> </tr> <tr> <td class="tableblock halign-left valign-top"><p class="tableblock"><code>spring-boot-starter-rsocket</code></p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">TCP, WebSocket</p></td> <td class="tableblock halign-left valign-top"><p class="tableblock">Spring WebFlux on Reactor Netty</p></td> </tr> </tbody> </table> <div class="sect2"> <h3 id="web.graphql.schema">
6.1. GraphQL Schema</h3> <div class="paragraph"> <p>A Spring GraphQL application requires a defined schema at startup. By default, you can write ".graphqls" or ".gqls" schema files under <code>src/main/resources/graphql/**</code> and Spring Boot will pick them up automatically. You can customize the locations with <code>spring.graphql.schema.locations</code> and the file extensions with <code>spring.graphql.schema.file-extensions</code>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> If you want Spring Boot to detect schema files in all your application modules and dependencies for that location, you can set <code>spring.graphql.schema.locations</code> to <code>"classpath*:graphql/**/"</code> (note the <code>classpath*:</code> prefix). </td> </tr> </table> </div> <div class="paragraph"> <p>In the following sections, we’ll consider this sample GraphQL schema, defining two types and two queries:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="json"><code class="language-json" data-lang="json">type Query {
    greeting(name: String! = "Spring"): String!
    project(slug: ID!): Project
}

""" A Project in the Spring portfolio """
type Project {
    """ Unique string id used in URLs """
    slug: ID!
    """ Project name """
    name: String!
    """ URL of the git repository """
    repositoryUrl: String!
    """ Current support status """
    status: ProjectStatus!
}

enum ProjectStatus {
    """ Actively supported by the Spring team """
    ACTIVE
    """ Supported by the community """
    COMMUNITY
    """ Prototype, not officially supported yet  """
    INCUBATING
    """ Project being retired, in maintenance mode """
    ATTIC
    """ End-Of-Lifed """
    EOL
}</code></pre> </div> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> By default, <a href="https://spec.graphql.org/draft/#sec-Introspection">field introspection</a> will be allowed on the schema as it is required for tools such as GraphiQL. If you wish to not expose information about the schema, you can disable introspection by setting <code>spring.graphql.schema.introspection.enabled</code> to <code>false</code>. </td> </tr> </table> </div> </div> <div class="sect2"> <h3 id="web.graphql.runtimewiring">
6.2. GraphQL RuntimeWiring</h3> <div class="paragraph"> <p>The GraphQL Java <code>RuntimeWiring.Builder</code> can be used to register custom scalar types, directives, type resolvers, <code>DataFetcher</code>, and more. You can declare <code>RuntimeWiringConfigurer</code> beans in your Spring config to get access to the <code>RuntimeWiring.Builder</code>. Spring Boot detects such beans and adds them to the <a href="https://docs.spring.io/spring-graphql/docs/1.2.2/reference/html/#execution-graphqlsource">GraphQlSource builder</a>.</p> </div> <div class="paragraph"> <p>Typically, however, applications will not implement <code>DataFetcher</code> directly and will instead create <a href="https://docs.spring.io/spring-graphql/docs/1.2.2/reference/html/#controllers">annotated controllers</a>. Spring Boot will automatically detect <code>@Controller</code> classes with annotated handler methods and register those as <code>DataFetcher</code>s. Here’s a sample implementation for our greeting query with a <code>@Controller</code> class:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java"><span class="fold-block hide-when-folded">import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

</span><span class="fold-block">@Controller
public class GreetingController {

    @QueryMapping
    public String greeting(@Argument String name) {
        return "Hello, " + name + "!";
    }

}
</span></code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin"><span class="fold-block">;

</span><span class="fold-block hide-when-folded">import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.stereotype.Controller

</span><span class="fold-block">@Controller
class GreetingController {

    @QueryMapping
    fun greeting(@Argument name: String): String {
        return "Hello, $name!"
    }

}
</span></code></pre> </div> </div> </div> <div class="sect2"> <h3 id="web.graphql.data-query">
6.3. Querydsl and QueryByExample Repositories Support</h3> <div class="paragraph"> <p>Spring Data offers support for both Querydsl and QueryByExample repositories. Spring GraphQL can <a href="https://docs.spring.io/spring-graphql/docs/1.2.2/reference/html/#data">configure Querydsl and QueryByExample repositories as <code>DataFetcher</code></a>.</p> </div> <div class="paragraph"> <p>Spring Data repositories annotated with <code>@GraphQlRepository</code> and extending one of:</p> </div> <div class="ulist"> <ul> <li> <p><code>QuerydslPredicateExecutor</code></p> </li> <li> <p><code>ReactiveQuerydslPredicateExecutor</code></p> </li> <li> <p><code>QueryByExampleExecutor</code></p> </li> <li> <p><code>ReactiveQueryByExampleExecutor</code></p> </li> </ul> </div> <div class="paragraph"> <p>are detected by Spring Boot and considered as candidates for <code>DataFetcher</code> for matching top-level queries.</p> </div> </div> <div class="sect2"> <h3 id="web.graphql.transports">
6.4. Transports</h3> <div class="sect3"> <h4 id="web.graphql.transports.http-websocket">
6.4.1. HTTP and WebSocket</h4> <div class="paragraph"> <p>The GraphQL HTTP endpoint is at HTTP POST <code>/graphql</code> by default. The path can be customized with <code>spring.graphql.path</code>.</p> </div> <div class="admonitionblock tip"> <table> <tr> <td class="icon">  </td> <td class="content"> The HTTP endpoint for both Spring MVC and Spring WebFlux is provided by a <code>RouterFunction</code> bean with an <code>@Order</code> of <code>0</code>. If you define your own <code>RouterFunction</code> beans, you may want to add appropriate <code>@Order</code> annotations to ensure that they are sorted correctly. </td> </tr> </table> </div> <div class="paragraph"> <p>The GraphQL WebSocket endpoint is off by default. To enable it:</p> </div> <div class="ulist"> <ul> <li> <p>For a Servlet application, add the WebSocket starter <code>spring-boot-starter-websocket</code></p> </li> <li> <p>For a WebFlux application, no additional dependency is required</p> </li> <li> <p>For both, the <code>spring.graphql.websocket.path</code> application property must be set</p> </li> </ul> </div> <div class="paragraph"> <p>Spring GraphQL provides a <a href="https://docs.spring.io/spring-graphql/docs/1.2.2/reference/html/#web-interception">Web Interception</a> model. This is quite useful for retrieving information from an HTTP request header and set it in the GraphQL context or fetching information from the same context and writing it to a response header. With Spring Boot, you can declare a <code>WebInterceptor</code> bean to have it registered with the web transport.</p> </div> <div class="paragraph"> <p><a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web.html#mvc-cors">Spring MVC</a> and <a href="https://docs.spring.io/spring-framework/docs/6.0.11/reference/html/web-reactive.html#webflux-cors">Spring WebFlux</a> support CORS (Cross-Origin Resource Sharing) requests. CORS is a critical part of the web config for GraphQL applications that are accessed from browsers using different domains.</p> </div> <div class="paragraph"> <p>Spring Boot supports many configuration properties under the <code>spring.graphql.cors.*</code> namespace; here’s a short configuration sample:</p> </div> <div class="listingblock primary"> <div class="title">Properties</div> <div class="content"> <pre class="highlight" data-language="properties"><code class="language-properties" data-lang="properties">spring.graphql.cors.allowed-origins=https://example.org
spring.graphql.cors.allowed-methods=GET,POST
spring.graphql.cors.max-age=1800s</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Yaml</div> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">spring:
  graphql:
    cors:
      allowed-origins: "https://example.org"
      allowed-methods: GET,POST
      max-age: 1800s</code></pre> </div> </div> </div> <div class="sect3"> <h4 id="web.graphql.transports.rsocket">
6.4.2. RSocket</h4> <div class="paragraph"> <p>RSocket is also supported as a transport, on top of WebSocket or TCP. Once the <a href="messaging.html#messaging.rsocket.server-auto-configuration">RSocket server is configured</a>, we can configure our GraphQL handler on a particular route using <code>spring.graphql.rsocket.mapping</code>. For example, configuring that mapping as <code>"graphql"</code> means we can use that as a route when sending requests with the <code>RSocketGraphQlClient</code>.</p> </div> <div class="paragraph"> <p>Spring Boot auto-configures a <code>RSocketGraphQlClient.Builder&lt;?&gt;</code> bean that you can inject in your components:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">@Component
public class RSocketGraphQlClientExample {

    private final RSocketGraphQlClient graphQlClient;

    public RSocketGraphQlClientExample(RSocketGraphQlClient.Builder&lt;?&gt; builder) {
        this.graphQlClient = builder.tcp("example.spring.io", 8181).route("graphql").build();
    }
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin">@Component
class RSocketGraphQlClientExample(private val builder: RSocketGraphQlClient.Builder&lt;*&gt;) {
</code></pre> </div> </div> <div class="paragraph"> <p>And then send a request:</p> </div> <div class="listingblock primary"> <div class="title">Java</div> <div class="content"> <pre class="highlight" data-language="java"><code class="language-java" data-lang="java">Mono&lt;Book&gt; book = this.graphQlClient.document("{ bookById(id: \"book-1\"){ id name pageCount author } }")
    .retrieve("bookById")
    .toEntity(Book.class);
</code></pre> </div> </div> <div class="listingblock secondary"> <div class="title">Kotlin</div> <div class="content"> <pre class="highlight" data-language="kotlin"><code class="language-kotlin" data-lang="kotlin">val book = graphQlClient.document(
    """
    {
        bookById(id: "book-1"){
            id
            name
            pageCount
            author
        }
    }               
    """
)
    .retrieve("bookById").toEntity(Book::class.java)
</code></pre> </div> </div> </div> </div> <div class="sect2"> <h3 id="web.graphql.exception-handling">
6.5. Exception Handling</h3> <div class="paragraph"> <p>Spring GraphQL enables applications to register one or more Spring <code>DataFetcherExceptionResolver</code> components that are invoked sequentially. The Exception must be resolved to a list of <code>graphql.GraphQLError</code> objects, see <a href="https://docs.spring.io/spring-graphql/docs/1.2.2/reference/html/#execution-exceptions">Spring GraphQL exception handling documentation</a>. Spring Boot will automatically detect <code>DataFetcherExceptionResolver</code> beans and register them with the <code>GraphQlSource.Builder</code>.</p> </div> </div> <div class="sect2"> <h3 id="web.graphql.graphiql">
6.6. GraphiQL and Schema printer</h3> <div class="paragraph"> <p>Spring GraphQL offers infrastructure for helping developers when consuming or developing a GraphQL API.</p> </div> <div class="paragraph"> <p>Spring GraphQL ships with a default <a href="https://github.com/graphql/graphiql">GraphiQL</a> page that is exposed at <code>"/graphiql"</code> by default. This page is disabled by default and can be turned on with the <code>spring.graphql.graphiql.enabled</code> property. Many applications exposing such a page will prefer a custom build. A default implementation is very useful during development, this is why it is exposed automatically with <a href="using.html#using.devtools"><code>spring-boot-devtools</code></a> during development.</p> </div> <div class="paragraph"> <p>You can also choose to expose the GraphQL schema in text format at <code>/graphql/schema</code> when the <code>spring.graphql.schema.printer.enabled</code> property is enabled.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="web.spring-hateoas">
7. Spring HATEOAS</h2> <div class="sectionbody"> <div class="paragraph"> <p>If you develop a RESTful API that makes use of hypermedia, Spring Boot provides auto-configuration for Spring HATEOAS that works well with most applications. The auto-configuration replaces the need to use <code>@EnableHypermediaSupport</code> and registers a number of beans to ease building hypermedia-based applications, including a <code>LinkDiscoverers</code> (for client side support) and an <code>ObjectMapper</code> configured to correctly marshal responses into the desired representation. The <code>ObjectMapper</code> is customized by setting the various <code>spring.jackson.*</code> properties or, if one exists, by a <code>Jackson2ObjectMapperBuilder</code> bean.</p> </div> <div class="paragraph"> <p>You can take control of Spring HATEOAS’s configuration by using <code>@EnableHypermediaSupport</code>. Note that doing so disables the <code>ObjectMapper</code> customization described earlier.</p> </div> <div class="admonitionblock warning"> <table> <tr> <td class="icon">  </td> <td class="content"> <code>spring-boot-starter-hateoas</code> is specific to Spring MVC and should not be combined with Spring WebFlux. In order to use Spring HATEOAS with Spring WebFlux, you can add a direct dependency on <code>org.springframework.hateoas:spring-hateoas</code> along with <code>spring-boot-starter-webflux</code>. </td> </tr> </table> </div> </div> </div> <div class="sect1"> <h2 id="web.whats-next">
8. What to Read Next</h2> <div class="sectionbody"> <div class="paragraph"> <p>You should now have a good understanding of how to develop web applications with Spring Boot. The next few sections describe how Spring Boot integrates with various <a href="data.html#data">data technologies</a>, <a href="messaging.html#messaging">messaging systems</a>, and other IO capabilities. You can pick any of these based on your application’s needs.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2012-2023 VMware, Inc.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/web.html" class="_attribution-link">https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/web.html</a>
  </p>
</div>
