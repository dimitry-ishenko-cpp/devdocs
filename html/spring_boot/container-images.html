<h1>Container Images</h1> <div id="preamble"> <div class="sectionbody"> <div class="paragraph"> <p>Spring Boot applications can be containerized <a href="#container-images.dockerfiles">using Dockerfiles</a>, or by <a href="#container-images.buildpacks">using Cloud Native Buildpacks to create optimized docker compatible container images that you can run anywhere</a>.</p> </div> </div> </div> <div class="sect1"> <h2 id="container-images.efficient-images">
1. Efficient Container Images</h2> <div class="sectionbody"> <div class="paragraph"> <p>It is easily possible to package a Spring Boot fat jar as a docker image. However, there are various downsides to copying and running the fat jar as is in the docker image. There’s always a certain amount of overhead when running a fat jar without unpacking it, and in a containerized environment this can be noticeable. The other issue is that putting your application’s code and all its dependencies in one layer in the Docker image is sub-optimal. Since you probably recompile your code more often than you upgrade the version of Spring Boot you use, it’s often better to separate things a bit more. If you put jar files in the layer before your application classes, Docker often only needs to change the very bottom layer and can pick others up from its cache.</p> </div> <div class="sect2"> <h3 id="container-images.efficient-images.layering">
1.1. Layering Docker Images</h3> <div class="paragraph"> <p>To make it easier to create optimized Docker images, Spring Boot supports adding a layer index file to the jar. It provides a list of layers and the parts of the jar that should be contained within them. The list of layers in the index is ordered based on the order in which the layers should be added to the Docker/OCI image. Out-of-the-box, the following layers are supported:</p> </div> <div class="ulist"> <ul> <li> <p><code>dependencies</code> (for regular released dependencies)</p> </li> <li> <p><code>spring-boot-loader</code> (for everything under <code>org/springframework/boot/loader</code>)</p> </li> <li> <p><code>snapshot-dependencies</code> (for snapshot dependencies)</p> </li> <li> <p><code>application</code> (for application classes and resources)</p> </li> </ul> </div> <div class="paragraph"> <p>The following shows an example of a <code>layers.idx</code> file:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="yaml"><code class="language-yaml" data-lang="yaml">- "dependencies":
  - BOOT-INF/lib/library1.jar
  - BOOT-INF/lib/library2.jar
- "spring-boot-loader":
  - org/springframework/boot/loader/JarLauncher.class
  - org/springframework/boot/loader/jar/JarEntry.class
- "snapshot-dependencies":
  - BOOT-INF/lib/library3-SNAPSHOT.jar
- "application":
  - META-INF/MANIFEST.MF
  - BOOT-INF/classes/a/b/C.class</code></pre> </div> </div> <div class="paragraph"> <p>This layering is designed to separate code based on how likely it is to change between application builds. Library code is less likely to change between builds, so it is placed in its own layers to allow tooling to re-use the layers from cache. Application code is more likely to change between builds so it is isolated in a separate layer.</p> </div> <div class="paragraph"> <p>Spring Boot also supports layering for war files with the help of a <code>layers.idx</code>.</p> </div> <div class="paragraph"> <p>For Maven, see the <a href="https://docs.spring.io/spring-boot/docs/3.1.3/maven-plugin/reference/htmlsingle/#repackage-layers">packaging layered jar or war section</a> for more details on adding a layer index to the archive. For Gradle, see the <a href="https://docs.spring.io/spring-boot/docs/3.1.3/gradle-plugin/reference/htmlsingle/#packaging-layered-archives">packaging layered jar or war section</a> of the Gradle plugin documentation.</p> </div> </div> </div> </div> <div class="sect1"> <h2 id="container-images.dockerfiles">
2. Dockerfiles</h2> <div class="sectionbody"> <div class="paragraph"> <p>While it is possible to convert a Spring Boot fat jar into a docker image with just a few lines in the Dockerfile, we will use the <a href="#container-images.efficient-images.layering">layering feature</a> to create an optimized docker image. When you create a jar containing the layers index file, the <code>spring-boot-jarmode-layertools</code> jar will be added as a dependency to your jar. With this jar on the classpath, you can launch your application in a special mode which allows the bootstrap code to run something entirely different from your application, for example, something that extracts the layers.</p> </div> <div class="admonitionblock caution"> <table> <tr> <td class="icon">  </td> <td class="content"> The <code>layertools</code> mode can not be used with a <a href="deployment.html#deployment.installing">fully executable Spring Boot archive</a> that includes a launch script. Disable launch script configuration when building a jar file that is intended to be used with <code>layertools</code>. </td> </tr> </table> </div> <div class="paragraph"> <p>Here’s how you can launch your jar with a <code>layertools</code> jar mode:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ java -Djarmode=layertools -jar my-app.jar</code></pre> </div> </div> <div class="paragraph"> <p>This will provide the following output:</p> </div> <div class="listingblock"> <div class="content"> <pre data-language="">Usage:
  java -Djarmode=layertools -jar my-app.jar

Available commands:
  list     List layers from the jar that can be extracted
  extract  Extracts layers from the jar for image creation
  help     Help about any command</pre> </div> </div> <div class="paragraph"> <p>The <code>extract</code> command can be used to easily split the application into layers to be added to the dockerfile. Here is an example of a Dockerfile using <code>jarmode</code>.</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="dockerfile"><code class="language-dockerfile" data-lang="dockerfile">FROM eclipse-temurin:17-jre as builder
WORKDIR application
ARG JAR_FILE=target/*.jar
COPY ${JAR_FILE} application.jar
RUN java -Djarmode=layertools -jar application.jar extract

FROM eclipse-temurin:17-jre
WORKDIR application
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
COPY --from=builder application/snapshot-dependencies/ ./
COPY --from=builder application/application/ ./
ENTRYPOINT ["java", "org.springframework.boot.loader.JarLauncher"]</code></pre> </div> </div> <div class="paragraph"> <p>Assuming the above <code>Dockerfile</code> is in the current directory, your docker image can be built with <code>docker build .</code>, or optionally specifying the path to your application jar, as shown in the following example:</p> </div> <div class="listingblock"> <div class="content"> <pre class="highlight" data-language="shell"><code class="language-shell" data-lang="shell">$ docker build --build-arg JAR_FILE=path/to/myapp.jar .</code></pre> </div> </div> <div class="paragraph"> <p>This is a multi-stage dockerfile. The builder stage extracts the directories that are needed later. Each of the <code>COPY</code> commands relates to the layers extracted by the jarmode.</p> </div> <div class="paragraph"> <p>Of course, a Dockerfile can be written without using the jarmode. You can use some combination of <code>unzip</code> and <code>mv</code> to move things to the right layer but jarmode simplifies that.</p> </div> </div> </div> <div class="sect1"> <h2 id="container-images.buildpacks">
3. Cloud Native Buildpacks</h2> <div class="sectionbody"> <div class="paragraph"> <p>Dockerfiles are just one way to build docker images. Another way to build docker images is directly from your Maven or Gradle plugin, using buildpacks. If you’ve ever used an application platform such as Cloud Foundry or Heroku then you’ve probably used a buildpack. Buildpacks are the part of the platform that takes your application and converts it into something that the platform can actually run. For example, Cloud Foundry’s Java buildpack will notice that you’re pushing a <code>.jar</code> file and automatically add a relevant JRE.</p> </div> <div class="paragraph"> <p>With Cloud Native Buildpacks, you can create Docker compatible images that you can run anywhere. Spring Boot includes buildpack support directly for both Maven and Gradle. This means you can just type a single command and quickly get a sensible image into your locally running Docker daemon.</p> </div> <div class="paragraph"> <p>See the individual plugin documentation on how to use buildpacks with <a href="https://docs.spring.io/spring-boot/docs/3.1.3/maven-plugin/reference/htmlsingle/#build-image">Maven</a> and <a href="https://docs.spring.io/spring-boot/docs/3.1.3/gradle-plugin/reference/htmlsingle/#build-image">Gradle</a>.</p> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> The <a href="https://github.com/paketo-buildpacks/spring-boot">Paketo Spring Boot buildpack</a> supports the <code>layers.idx</code> file, so any customization that is applied to it will be reflected in the image created by the buildpack. </td> </tr> </table> </div> <div class="admonitionblock note"> <table> <tr> <td class="icon">  </td> <td class="content"> In order to achieve reproducible builds and container image caching, Buildpacks can manipulate the application resources metadata (such as the file "last modified" information). You should ensure that your application does not rely on that metadata at runtime. Spring Boot can use that information when serving static resources, but this can be disabled with <code>spring.web.resources.cache.use-last-modified</code>. </td> </tr> </table> </div> </div> </div> <div class="sect1"> <h2 id="container-images.whats-next">
4. What to Read Next</h2> <div class="sectionbody"> <div class="paragraph"> <p>Once you’ve learned how to build efficient container images, you can read about <a href="deployment.html#deployment.cloud.kubernetes">deploying applications to a cloud platform</a>, such as Kubernetes.</p> </div> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2012-2023 VMware, Inc.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/container-images.html" class="_attribution-link">https://docs.spring.io/spring-boot/docs/3.1.3/reference/html/container-images.html</a>
  </p>
</div>
