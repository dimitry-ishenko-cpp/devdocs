<h1>session</h1>
<blockquote><p>Manage browser sessions, cookies, cache, proxy settings, etc.</p></blockquote>
<p>Process: <a href="../glossary.html#main-process">Main</a></p>
<p>The <code>session</code> module can be used to create new <code>Session</code> objects.</p>
<p>You can also access the <code>session</code> of existing pages by using the <code>session</code> property of <a href="web-contents.html"><code>WebContents</code></a>, or from the <code>session</code> module.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { BrowserWindow } = require('electron')

const win = new BrowserWindow({ width: 800, height: 600 })
win.loadURL('http://github.com')

const ses = win.webContents.session
console.log(ses.getUserAgent())</pre>

</div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="methods">Methods<a class="hash-link" href="#methods" title="Direct link to heading">​</a>
</h2>
<p>The <code>session</code> module has the following methods:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="sessionfrompartitionpartition-options">
<code>session.fromPartition(partition[, options])</code><a class="hash-link" href="#sessionfrompartitionpartition-options" title="Direct link to heading">​</a>
</h3>
<ul>
<li>
<code>partition</code> string</li>
<li class="electron-api-options-list">
<code>options</code> Object (optional)<ul><li>
<code>cache</code> boolean - Whether to enable cache.</li></ul>
</li>
</ul>
<p>Returns <code>Session</code> - A session instance from <code>partition</code> string. When there is an existing <code>Session</code> with the same <code>partition</code>, it will be returned; otherwise a new <code>Session</code> instance will be created with <code>options</code>.</p>
<p>If <code>partition</code> starts with <code>persist:</code>, the page will use a persistent session available to all pages in the app with the same <code>partition</code>. if there is no <code>persist:</code> prefix, the page will use an in-memory session. If the <code>partition</code> is empty then default session of the app will be returned.</p>
<p>To create a <code>Session</code> with <code>options</code>, you have to ensure the <code>Session</code> with the <code>partition</code> has never been used before. There is no way to change the <code>options</code> of an existing <code>Session</code> object.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="properties">Properties<a class="hash-link" href="#properties" title="Direct link to heading">​</a>
</h2>
<p>The <code>session</code> module has the following properties:</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="sessiondefaultsession">
<code>session.defaultSession</code><a class="hash-link" href="#sessiondefaultsession" title="Direct link to heading">​</a>
</h3>
<p>A <code>Session</code> object, the default session object of the app.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="class-session">Class: Session<a class="hash-link" href="#class-session" title="Direct link to heading">​</a>
</h2>
<blockquote><p>Get and set properties of a session.</p></blockquote>
<p>Process: <a href="../glossary.html#main-process">Main</a><br> <em>This class is not exported from the <code>'electron'</code> module. It is only available as a return value of other methods in the Electron API.</em></p>
<p>You can create a <code>Session</code> object in the <code>session</code> module:</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { session } = require('electron')
const ses = session.fromPartition('persist:name')
console.log(ses.getUserAgent())</pre>

</div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="instance-events">Instance Events<a class="hash-link" href="#instance-events" title="Direct link to heading">​</a>
</h3>
<p>The following events are available on instances of <code>Session</code>:</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-will-download">Event: 'will-download'<a class="hash-link" href="#event-will-download" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>item</code> <a href="download-item.html">DownloadItem</a>
</li>
<li>
<code>webContents</code> <a href="web-contents.html">WebContents</a>
</li>
</ul>
<p>Emitted when Electron is about to download <code>item</code> in <code>webContents</code>.</p>
<p>Calling <code>event.preventDefault()</code> will cancel the download and <code>item</code> will not be available from next tick of the process.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { session } = require('electron')
session.defaultSession.on('will-download', (event, item, webContents) =&gt; {
  event.preventDefault()
  require('got')(item.getURL()).then((response) =&gt; {
    require('fs').writeFileSync('/somewhere', response.body)
  })
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-extension-loaded">Event: 'extension-loaded'<a class="hash-link" href="#event-extension-loaded" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>extension</code> <a aria-describedby="structures-tooltip" href="structures/extension.html" class="link_nCrB">Extension</a>
</li>
</ul>
<p>Emitted after an extension is loaded. This occurs whenever an extension is added to the "enabled" set of extensions. This includes:</p>
<ul>
<li>Extensions being loaded from <code>Session.loadExtension</code>.</li>
<li>Extensions being reloaded:<ul>
<li>from a crash.</li>
<li>if the extension requested it (<a href="https://developer.chrome.com/extensions/runtime#method-reload" target="_blank" rel="noopener noreferrer"><code>chrome.runtime.reload()</code></a>).</li>
</ul>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-extension-unloaded">Event: 'extension-unloaded'<a class="hash-link" href="#event-extension-unloaded" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>extension</code> <a aria-describedby="structures-tooltip" href="structures/extension.html" class="link_nCrB">Extension</a>
</li>
</ul>
<p>Emitted after an extension is unloaded. This occurs when <code>Session.removeExtension</code> is called.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-extension-ready">Event: 'extension-ready'<a class="hash-link" href="#event-extension-ready" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>extension</code> <a aria-describedby="structures-tooltip" href="structures/extension.html" class="link_nCrB">Extension</a>
</li>
</ul>
<p>Emitted after an extension is loaded and all necessary browser state is initialized to support the start of the extension's background page.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-preconnect">Event: 'preconnect'<a class="hash-link" href="#event-preconnect" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>preconnectUrl</code> string - The URL being requested for preconnection by the renderer.</li>
<li>
<code>allowCredentials</code> boolean - True if the renderer is requesting that the connection include credentials (see the <a href="https://w3c.github.io/resource-hints/#preconnect" target="_blank" rel="noopener noreferrer">spec</a> for more details.)</li>
</ul>
<p>Emitted when a render process requests preconnection to a URL, generally due to a <a href="https://w3c.github.io/resource-hints/" target="_blank" rel="noopener noreferrer">resource hint</a>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-spellcheck-dictionary-initialized">Event: 'spellcheck-dictionary-initialized'<a class="hash-link" href="#event-spellcheck-dictionary-initialized" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>languageCode</code> string - The language code of the dictionary file</li>
</ul>
<p>Emitted when a hunspell dictionary file has been successfully initialized. This occurs after the file has been downloaded.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-spellcheck-dictionary-download-begin">Event: 'spellcheck-dictionary-download-begin'<a class="hash-link" href="#event-spellcheck-dictionary-download-begin" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>languageCode</code> string - The language code of the dictionary file</li>
</ul>
<p>Emitted when a hunspell dictionary file starts downloading</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-spellcheck-dictionary-download-success">Event: 'spellcheck-dictionary-download-success'<a class="hash-link" href="#event-spellcheck-dictionary-download-success" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>languageCode</code> string - The language code of the dictionary file</li>
</ul>
<p>Emitted when a hunspell dictionary file has been successfully downloaded</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-spellcheck-dictionary-download-failure">Event: 'spellcheck-dictionary-download-failure'<a class="hash-link" href="#event-spellcheck-dictionary-download-failure" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>languageCode</code> string - The language code of the dictionary file</li>
</ul>
<p>Emitted when a hunspell dictionary file download fails. For details on the failure you should collect a netlog and inspect the download request.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-select-hid-device">Event: 'select-hid-device'<a class="hash-link" href="#event-select-hid-device" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>details</code> Object<ul>
<li>
<code>deviceList</code> <a aria-describedby="structures-tooltip" href="structures/hid-device.html" class="link_nCrB">HIDDevice[]</a>
</li>
<li>
<code>frame</code> <a href="web-frame-main.html">WebFrameMain</a>
</li>
</ul>
</li>
<li>
<code>callback</code> Function<ul><li>
<code>deviceId</code> string | null (optional)</li></ul>
</li>
</ul>
<p>Emitted when a HID device needs to be selected when a call to <code>navigator.hid.requestDevice</code> is made. <code>callback</code> should be called with <code>deviceId</code> to be selected; passing no arguments to <code>callback</code> will cancel the request. Additionally, permissioning on <code>navigator.hid</code> can be further managed by using <a href="#sessetpermissioncheckhandlerhandler">ses.setPermissionCheckHandler(handler)</a> and <a href="#sessetdevicepermissionhandlerhandler">ses.setDevicePermissionHandler(handler)`</a>.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, BrowserWindow } = require('electron')

let win = null

app.whenReady().then(() =&gt; {
  win = new BrowserWindow()

  win.webContents.session.setPermissionCheckHandler((webContents, permission, requestingOrigin, details) =&gt; {
    if (permission === 'hid') {
      // Add logic here to determine if permission should be given to allow HID selection
      return true
    }
    return false
  })

  // Optionally, retrieve previously persisted devices from a persistent store
  const grantedDevices = fetchGrantedDevices()

  win.webContents.session.setDevicePermissionHandler((details) =&gt; {
    if (new URL(details.origin).hostname === 'some-host' &amp;&amp; details.deviceType === 'hid') {
      if (details.device.vendorId === 123 &amp;&amp; details.device.productId === 345) {
        // Always allow this type of device (this allows skipping the call to `navigator.hid.requestDevice` first)
        return true
      }

      // Search through the list of devices that have previously been granted permission
      return grantedDevices.some((grantedDevice) =&gt; {
        return grantedDevice.vendorId === details.device.vendorId &amp;&amp;
              grantedDevice.productId === details.device.productId &amp;&amp;
              grantedDevice.serialNumber &amp;&amp; grantedDevice.serialNumber === details.device.serialNumber
      })
    }
    return false
  })

  win.webContents.session.on('select-hid-device', (event, details, callback) =&gt; {
    event.preventDefault()
    const selectedDevice = details.deviceList.find((device) =&gt; {
      return device.vendorId === '9025' &amp;&amp; device.productId === '67'
    })
    callback(selectedPort?.deviceId)
  })
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-hid-device-added">Event: 'hid-device-added'<a class="hash-link" href="#event-hid-device-added" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>details</code> Object<ul>
<li>
<code>device</code> <a aria-describedby="structures-tooltip" href="structures/hid-device.html" class="link_nCrB">HIDDevice[]</a>
</li>
<li>
<code>frame</code> <a href="web-frame-main.html">WebFrameMain</a>
</li>
</ul>
</li>
</ul>
<p>Emitted after <code>navigator.hid.requestDevice</code> has been called and <code>select-hid-device</code> has fired if a new device becomes available before the callback from <code>select-hid-device</code> is called. This event is intended for use when using a UI to ask users to pick a device so that the UI can be updated with the newly added device.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-hid-device-removed">Event: 'hid-device-removed'<a class="hash-link" href="#event-hid-device-removed" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>details</code> Object<ul>
<li>
<code>device</code> <a aria-describedby="structures-tooltip" href="structures/hid-device.html" class="link_nCrB">HIDDevice[]</a>
</li>
<li>
<code>frame</code> <a href="web-frame-main.html">WebFrameMain</a>
</li>
</ul>
</li>
</ul>
<p>Emitted after <code>navigator.hid.requestDevice</code> has been called and <code>select-hid-device</code> has fired if a device has been removed before the callback from <code>select-hid-device</code> is called. This event is intended for use when using a UI to ask users to pick a device so that the UI can be updated to remove the specified device.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-hid-device-revoked">Event: 'hid-device-revoked'<a class="hash-link" href="#event-hid-device-revoked" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>details</code> Object<ul>
<li>
<code>device</code> <a aria-describedby="structures-tooltip" href="structures/hid-device.html" class="link_nCrB">HIDDevice[]</a>
</li>
<li>
<code>origin</code> string (optional) - The origin that the device has been revoked from.</li>
</ul>
</li>
</ul>
<p>Emitted after <code>HIDDevice.forget()</code> has been called. This event can be used to help maintain persistent storage of permissions when <code>setDevicePermissionHandler</code> is used.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-select-serial-port">Event: 'select-serial-port'<a class="hash-link" href="#event-select-serial-port" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>portList</code> <a aria-describedby="structures-tooltip" href="structures/serial-port.html" class="link_nCrB">SerialPort[]</a>
</li>
<li>
<code>webContents</code> <a href="web-contents.html">WebContents</a>
</li>
<li>
<code>callback</code> Function<ul><li>
<code>portId</code> string</li></ul>
</li>
</ul>
<p>Emitted when a serial port needs to be selected when a call to <code>navigator.serial.requestPort</code> is made. <code>callback</code> should be called with <code>portId</code> to be selected, passing an empty string to <code>callback</code> will cancel the request. Additionally, permissioning on <code>navigator.serial</code> can be managed by using <a href="#sessetpermissioncheckhandlerhandler">ses.setPermissionCheckHandler(handler)</a> with the <code>serial</code> permission.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, BrowserWindow } = require('electron')

let win = null

app.whenReady().then(() =&gt; {
  win = new BrowserWindow({
    width: 800,
    height: 600
  })

  win.webContents.session.setPermissionCheckHandler((webContents, permission, requestingOrigin, details) =&gt; {
    if (permission === 'serial') {
      // Add logic here to determine if permission should be given to allow serial selection
      return true
    }
    return false
  })

  // Optionally, retrieve previously persisted devices from a persistent store
  const grantedDevices = fetchGrantedDevices()

  win.webContents.session.setDevicePermissionHandler((details) =&gt; {
    if (new URL(details.origin).hostname === 'some-host' &amp;&amp; details.deviceType === 'serial') {
      if (details.device.vendorId === 123 &amp;&amp; details.device.productId === 345) {
        // Always allow this type of device (this allows skipping the call to `navigator.serial.requestPort` first)
        return true
      }

      // Search through the list of devices that have previously been granted permission
      return grantedDevices.some((grantedDevice) =&gt; {
        return grantedDevice.vendorId === details.device.vendorId &amp;&amp;
              grantedDevice.productId === details.device.productId &amp;&amp;
              grantedDevice.serialNumber &amp;&amp; grantedDevice.serialNumber === details.device.serialNumber
      })
    }
    return false
  })

  win.webContents.session.on('select-serial-port', (event, portList, webContents, callback) =&gt; {
    event.preventDefault()
    const selectedPort = portList.find((device) =&gt; {
      return device.vendorId === '9025' &amp;&amp; device.productId === '67'
    })
    if (!selectedPort) {
      callback('')
    } else {
      callback(selectedPort.portId)
    }
  })
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-serial-port-added">Event: 'serial-port-added'<a class="hash-link" href="#event-serial-port-added" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>port</code> <a aria-describedby="structures-tooltip" href="structures/serial-port.html" class="link_nCrB">SerialPort</a>
</li>
<li>
<code>webContents</code> <a href="web-contents.html">WebContents</a>
</li>
</ul>
<p>Emitted after <code>navigator.serial.requestPort</code> has been called and <code>select-serial-port</code> has fired if a new serial port becomes available before the callback from <code>select-serial-port</code> is called. This event is intended for use when using a UI to ask users to pick a port so that the UI can be updated with the newly added port.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="event-serial-port-removed">Event: 'serial-port-removed'<a class="hash-link" href="#event-serial-port-removed" title="Direct link to heading">​</a>
</h4>
<p>Returns:</p>
<ul>
<li>
<code>event</code> Event</li>
<li>
<code>port</code> <a aria-describedby="structures-tooltip" href="structures/serial-port.html" class="link_nCrB">SerialPort</a>
</li>
<li>
<code>webContents</code> <a href="web-contents.html">WebContents</a>
</li>
</ul>
<p>Emitted after <code>navigator.serial.requestPort</code> has been called and <code>select-serial-port</code> has fired if a serial port has been removed before the callback from <code>select-serial-port</code> is called. This event is intended for use when using a UI to ask users to pick a port so that the UI can be updated to remove the specified port.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="instance-methods">Instance Methods<a class="hash-link" href="#instance-methods" title="Direct link to heading">​</a>
</h3>
<p>The following methods are available on instances of <code>Session</code>:</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetcachesize">
<code>ses.getCacheSize()</code><a class="hash-link" href="#sesgetcachesize" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;Integer&gt;</code> - the session's current cache size, in bytes.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesclearcache">
<code>ses.clearCache()</code><a class="hash-link" href="#sesclearcache" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;void&gt;</code> - resolves when the cache clear operation is complete.</p>
<p>Clears the session’s HTTP cache.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesclearstoragedataoptions">
<code>ses.clearStorageData([options])</code><a class="hash-link" href="#sesclearstoragedataoptions" title="Direct link to heading">​</a>
</h4>
<ul><li class="electron-api-options-list">
<code>options</code> Object (optional)<ul>
<li>
<code>origin</code> string (optional) - Should follow <code>window.location.origin</code>’s representation <code>scheme://host:port</code>.</li>
<li>
<code>storages</code> string[] (optional) - The types of storages to clear, can contain: <code>appcache</code>, <code>cookies</code>, <code>filesystem</code>, <code>indexdb</code>, <code>localstorage</code>, <code>shadercache</code>, <code>websql</code>, <code>serviceworkers</code>, <code>cachestorage</code>. If not specified, clear all storage types.</li>
<li>
<code>quotas</code> string[] (optional) - The types of quotas to clear, can contain: <code>temporary</code>, <code>persistent</code>, <code>syncable</code>. If not specified, clear all quotas.</li>
</ul>
</li></ul>
<p>Returns <code>Promise&lt;void&gt;</code> - resolves when the storage data has been cleared.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesflushstoragedata">
<code>ses.flushStorageData()</code><a class="hash-link" href="#sesflushstoragedata" title="Direct link to heading">​</a>
</h4>
<p>Writes any unwritten DOMStorage data to disk.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetproxyconfig">
<code>ses.setProxy(config)</code><a class="hash-link" href="#sessetproxyconfig" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>config</code> Object<ul>
<li>
<code>mode</code> string (optional) - The proxy mode. Should be one of <code>direct</code>, <code>auto_detect</code>, <code>pac_script</code>, <code>fixed_servers</code> or <code>system</code>. If it's unspecified, it will be automatically determined based on other specified options.<ul>
<li>
<code>direct</code> In direct mode all connections are created directly, without any proxy involved.</li>
<li>
<code>auto_detect</code> In auto_detect mode the proxy configuration is determined by a PAC script that can be downloaded at http://wpad/wpad.dat.</li>
<li>
<code>pac_script</code> In pac_script mode the proxy configuration is determined by a PAC script that is retrieved from the URL specified in the <code>pacScript</code>. This is the default mode if <code>pacScript</code> is specified.</li>
<li>
<code>fixed_servers</code> In fixed_servers mode the proxy configuration is specified in <code>proxyRules</code>. This is the default mode if <code>proxyRules</code> is specified.</li>
<li>
<code>system</code> In system mode the proxy configuration is taken from the operating system. Note that the system mode is different from setting no proxy configuration. In the latter case, Electron falls back to the system settings only if no command-line options influence the proxy configuration.</li>
</ul>
</li>
<li>
<code>pacScript</code> string (optional) - The URL associated with the PAC file.</li>
<li>
<code>proxyRules</code> string (optional) - Rules indicating which proxies to use.</li>
<li>
<code>proxyBypassRules</code> string (optional) - Rules indicating which URLs should bypass the proxy settings.</li>
</ul>
</li></ul>
<p>Returns <code>Promise&lt;void&gt;</code> - Resolves when the proxy setting process is complete.</p>
<p>Sets the proxy settings.</p>
<p>When <code>mode</code> is unspecified, <code>pacScript</code> and <code>proxyRules</code> are provided together, the <code>proxyRules</code> option is ignored and <code>pacScript</code> configuration is applied.</p>
<p>You may need <code>ses.closeAllConnections</code> to close currently in flight connections to prevent pooled sockets using previous proxy from being reused by future requests.</p>
<p>The <code>proxyRules</code> has to follow the rules below:</p>
<div class="language-sh codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-sh codeBlock_bY9V thin-scrollbar" data-language="javascript">proxyRules = schemeProxies[";"&lt;schemeProxies&gt;]
schemeProxies = [&lt;urlScheme&gt;"="]&lt;proxyURIList&gt;
urlScheme = "http" | "https" | "ftp" | "socks"
proxyURIList = &lt;proxyURL&gt;[","&lt;proxyURIList&gt;]
proxyURL = [&lt;proxyScheme&gt;"://"]&lt;proxyHost&gt;[":"&lt;proxyPort&gt;]</pre>

</div></div>
<p>For example:</p>
<ul>
<li>
<code>http=foopy:80;ftp=foopy2</code> - Use HTTP proxy <code>foopy:80</code> for <code>http://</code> URLs, and HTTP proxy <code>foopy2:80</code> for <code>ftp://</code> URLs.</li>
<li>
<code>foopy:80</code> - Use HTTP proxy <code>foopy:80</code> for all URLs.</li>
<li>
<code>foopy:80,bar,direct://</code> - Use HTTP proxy <code>foopy:80</code> for all URLs, failing over to <code>bar</code> if <code>foopy:80</code> is unavailable, and after that using no proxy.</li>
<li>
<code>socks4://foopy</code> - Use SOCKS v4 proxy <code>foopy:1080</code> for all URLs.</li>
<li>
<code>http=foopy,socks5://bar.com</code> - Use HTTP proxy <code>foopy</code> for http URLs, and fail over to the SOCKS5 proxy <code>bar.com</code> if <code>foopy</code> is unavailable.</li>
<li>
<code>http=foopy,direct://</code> - Use HTTP proxy <code>foopy</code> for http URLs, and use no proxy if <code>foopy</code> is unavailable.</li>
<li>
<code>http=foopy;socks=foopy2</code> - Use HTTP proxy <code>foopy</code> for http URLs, and use <code>socks4://foopy2</code> for all other URLs.</li>
</ul>
<p>The <code>proxyBypassRules</code> is a comma separated list of rules described below:</p>
<ul>
<li>
<p><code>[ URL_SCHEME "://" ] HOSTNAME_PATTERN [ ":" &lt;port&gt; ]</code></p>
<p> Match all hostnames that match the pattern HOSTNAME_PATTERN.</p>
<p> Examples: "foobar.com", "<em>foobar.com", "</em>.foobar.com", "<em>foobar.com:99", "https://x.</em>.y.com:99"</p>
</li>
<li>
<p><code>"." HOSTNAME_SUFFIX_PATTERN [ ":" PORT ]</code></p>
<p> Match a particular domain suffix.</p>
<p> Examples: ".google.com", ".com", "http://.google.com"</p>
</li>
<li>
<p><code>[ SCHEME "://" ] IP_LITERAL [ ":" PORT ]</code></p>
<p> Match URLs which are IP address literals.</p>
<p> Examples: "127.0.1", "[0:0::1]", "[::1]", "http://[::1]:99"</p>
</li>
<li>
<p><code>IP_LITERAL "/" PREFIX_LENGTH_IN_BITS</code></p>
<p> Match any URL that is to an IP literal that falls between the given range. IP range is specified using CIDR notation.</p>
<p> Examples: "192.168.1.1/16", "fefe:13::abc/33".</p>
</li>
<li>
<p><code>&lt;local&gt;</code></p>
<p> Match local addresses. The meaning of <code>&lt;local&gt;</code> is whether the host matches one of: "127.0.0.1", "::1", "localhost".</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesresolveproxyurl">
<code>ses.resolveProxy(url)</code><a class="hash-link" href="#sesresolveproxyurl" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>url</code> URL</li></ul>
<p>Returns <code>Promise&lt;string&gt;</code> - Resolves with the proxy information for <code>url</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesforcereloadproxyconfig">
<code>ses.forceReloadProxyConfig()</code><a class="hash-link" href="#sesforcereloadproxyconfig" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;void&gt;</code> - Resolves when the all internal states of proxy service is reset and the latest proxy configuration is reapplied if it's already available. The pac script will be fetched from <code>pacScript</code> again if the proxy mode is <code>pac_script</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetdownloadpathpath">
<code>ses.setDownloadPath(path)</code><a class="hash-link" href="#sessetdownloadpathpath" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>path</code> string - The download location.</li></ul>
<p>Sets download saving directory. By default, the download directory will be the <code>Downloads</code> under the respective app folder.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesenablenetworkemulationoptions">
<code>ses.enableNetworkEmulation(options)</code><a class="hash-link" href="#sesenablenetworkemulationoptions" title="Direct link to heading">​</a>
</h4>
<ul><li class="electron-api-options-list">
<code>options</code> Object<ul>
<li>
<code>offline</code> boolean (optional) - Whether to emulate network outage. Defaults to false.</li>
<li>
<code>latency</code> Double (optional) - RTT in ms. Defaults to 0 which will disable latency throttling.</li>
<li>
<code>downloadThroughput</code> Double (optional) - Download rate in Bps. Defaults to 0 which will disable download throttling.</li>
<li>
<code>uploadThroughput</code> Double (optional) - Upload rate in Bps. Defaults to 0 which will disable upload throttling.</li>
</ul>
</li></ul>
<p>Emulates network with the given configuration for the <code>session</code>.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">// To emulate a GPRS connection with 50kbps throughput and 500 ms latency.
window.webContents.session.enableNetworkEmulation({
  latency: 500,
  downloadThroughput: 6400,
  uploadThroughput: 6400
})

// To emulate a network outage.
window.webContents.session.enableNetworkEmulation({ offline: true })</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sespreconnectoptions">
<code>ses.preconnect(options)</code><a class="hash-link" href="#sespreconnectoptions" title="Direct link to heading">​</a>
</h4>
<ul><li class="electron-api-options-list">
<code>options</code> Object<ul>
<li>
<code>url</code> string - URL for preconnect. Only the origin is relevant for opening the socket.</li>
<li>
<code>numSockets</code> number (optional) - number of sockets to preconnect. Must be between 1 and 6. Defaults to 1.</li>
</ul>
</li></ul>
<p>Preconnects the given number of sockets to an origin.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sescloseallconnections">
<code>ses.closeAllConnections()</code><a class="hash-link" href="#sescloseallconnections" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;void&gt;</code> - Resolves when all connections are closed.</p>
<p><strong>Note:</strong> It will terminate / fail all requests currently in flight.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesdisablenetworkemulation">
<code>ses.disableNetworkEmulation()</code><a class="hash-link" href="#sesdisablenetworkemulation" title="Direct link to heading">​</a>
</h4>
<p>Disables any network emulation already active for the <code>session</code>. Resets to the original network configuration.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetcertificateverifyprocproc">
<code>ses.setCertificateVerifyProc(proc)</code><a class="hash-link" href="#sessetcertificateverifyprocproc" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>proc</code> Function | null<ul>
<li>
<code>request</code> Object<ul>
<li>
<code>hostname</code> string</li>
<li>
<code>certificate</code> <a aria-describedby="structures-tooltip" href="structures/certificate.html" class="link_nCrB">Certificate</a>
</li>
<li>
<code>validatedCertificate</code> <a aria-describedby="structures-tooltip" href="structures/certificate.html" class="link_nCrB">Certificate</a>
</li>
<li>
<code>isIssuedByKnownRoot</code> boolean - <code>true</code> if Chromium recognises the root CA as a standard root. If it isn't then it's probably the case that this certificate was generated by a MITM proxy whose root has been installed locally (for example, by a corporate proxy). This should not be trusted if the <code>verificationResult</code> is not <code>OK</code>.</li>
<li>
<code>verificationResult</code> string - <code>OK</code> if the certificate is trusted, otherwise an error like <code>CERT_REVOKED</code>.</li>
<li>
<code>errorCode</code> Integer - Error code.</li>
</ul>
</li>
<li>
<code>callback</code> Function<ul><li>
<code>verificationResult</code> Integer - Value can be one of certificate error codes from <a href="https://source.chromium.org/chromium/chromium/src/+/main:net/base/net_error_list.h" target="_blank" rel="noopener noreferrer">here</a>. Apart from the certificate error codes, the following special codes can be used.<ul>
<li>
<code>0</code> - Indicates success and disables Certificate Transparency verification.</li>
<li>
<code>-2</code> - Indicates failure.</li>
<li>
<code>-3</code> - Uses the verification result from chromium.</li>
</ul>
</li></ul>
</li>
</ul>
</li></ul>
<p>Sets the certificate verify proc for <code>session</code>, the <code>proc</code> will be called with <code>proc(request, callback)</code> whenever a server certificate verification is requested. Calling <code>callback(0)</code> accepts the certificate, calling <code>callback(-2)</code> rejects it.</p>
<p>Calling <code>setCertificateVerifyProc(null)</code> will revert back to default certificate verify proc.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { BrowserWindow } = require('electron')
const win = new BrowserWindow()

win.webContents.session.setCertificateVerifyProc((request, callback) =&gt; {
  const { hostname } = request
  if (hostname === 'github.com') {
    callback(0)
  } else {
    callback(-2)
  }
})</pre>

</div></div>
<blockquote><p><strong>NOTE:</strong> The result of this procedure is cached by the network service.</p></blockquote>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetpermissionrequesthandlerhandler">
<code>ses.setPermissionRequestHandler(handler)</code><a class="hash-link" href="#sessetpermissionrequesthandlerhandler" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>handler</code> Function | null<ul>
<li>
<code>webContents</code> <a href="web-contents.html">WebContents</a> - WebContents requesting the permission. Please note that if the request comes from a subframe you should use <code>requestingUrl</code> to check the request origin.</li>
<li>
<code>permission</code> string - The type of requested permission.<ul>
<li>
<code>clipboard-read</code> - Request access to read from the clipboard.</li>
<li>
<code>media</code> - Request access to media devices such as camera, microphone and speakers.</li>
<li>
<code>display-capture</code> - Request access to capture the screen.</li>
<li>
<code>mediaKeySystem</code> - Request access to DRM protected content.</li>
<li>
<code>geolocation</code> - Request access to user's current location.</li>
<li>
<code>notifications</code> - Request notification creation and the ability to display them in the user's system tray.</li>
<li>
<code>midi</code> - Request MIDI access in the <code>webmidi</code> API.</li>
<li>
<code>midiSysex</code> - Request the use of system exclusive messages in the <code>webmidi</code> API.</li>
<li>
<code>pointerLock</code> - Request to directly interpret mouse movements as an input method. Click <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_Lock_API" target="_blank" rel="noopener noreferrer">here</a> to know more.</li>
<li>
<code>fullscreen</code> - Request for the app to enter fullscreen mode.</li>
<li>
<code>openExternal</code> - Request to open links in external applications.</li>
<li>
<code>unknown</code> - An unrecognized permission request</li>
</ul>
</li>
<li>
<code>callback</code> Function<ul><li>
<code>permissionGranted</code> boolean - Allow or deny the permission.</li></ul>
</li>
<li>
<code>details</code> Object - Some properties are only available on certain permission types.<ul>
<li>
<code>externalURL</code> string (optional) - The url of the <code>openExternal</code> request.</li>
<li>
<code>securityOrigin</code> string (optional) - The security origin of the <code>media</code> request.</li>
<li>
<code>mediaTypes</code> string[] (optional) - The types of media access being requested, elements can be <code>video</code> or <code>audio</code>
</li>
<li>
<code>requestingUrl</code> string - The last URL the requesting frame loaded</li>
<li>
<code>isMainFrame</code> boolean - Whether the frame making the request is the main frame</li>
</ul>
</li>
</ul>
</li></ul>
<p>Sets the handler which can be used to respond to permission requests for the <code>session</code>. Calling <code>callback(true)</code> will allow the permission and <code>callback(false)</code> will reject it. To clear the handler, call <code>setPermissionRequestHandler(null)</code>. Please note that you must also implement <code>setPermissionCheckHandler</code> to get complete permission handling. Most web APIs do a permission check and then make a permission request if the check is denied.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { session } = require('electron')
session.fromPartition('some-partition').setPermissionRequestHandler((webContents, permission, callback) =&gt; {
  if (webContents.getURL() === 'some-host' &amp;&amp; permission === 'notifications') {
    return callback(false) // denied.
  }

  callback(true)
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetpermissioncheckhandlerhandler">
<code>ses.setPermissionCheckHandler(handler)</code><a class="hash-link" href="#sessetpermissioncheckhandlerhandler" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>handler</code> Function\&lt;boolean&gt; | null<ul>
<li>
<code>webContents</code> (<a href="web-contents.html">WebContents</a> | null) - WebContents checking the permission. Please note that if the request comes from a subframe you should use <code>requestingUrl</code> to check the request origin. All cross origin sub frames making permission checks will pass a <code>null</code> webContents to this handler, while certain other permission checks such as <code>notifications</code> checks will always pass <code>null</code>. You should use <code>embeddingOrigin</code> and <code>requestingOrigin</code> to determine what origin the owning frame and the requesting frame are on respectively.</li>
<li>
<code>permission</code> string - Type of permission check. Valid values are <code>midiSysex</code>, <code>notifications</code>, <code>geolocation</code>, <code>media</code>,<code>mediaKeySystem</code>,<code>midi</code>, <code>pointerLock</code>, <code>fullscreen</code>, <code>openExternal</code>, <code>hid</code>, or <code>serial</code>.</li>
<li>
<code>requestingOrigin</code> string - The origin URL of the permission check</li>
<li>
<code>details</code> Object - Some properties are only available on certain permission types.<ul>
<li>
<code>embeddingOrigin</code> string (optional) - The origin of the frame embedding the frame that made the permission check. Only set for cross-origin sub frames making permission checks.</li>
<li>
<code>securityOrigin</code> string (optional) - The security origin of the <code>media</code> check.</li>
<li>
<code>mediaType</code> string (optional) - The type of media access being requested, can be <code>video</code>, <code>audio</code> or <code>unknown</code>
</li>
<li>
<code>requestingUrl</code> string (optional) - The last URL the requesting frame loaded. This is not provided for cross-origin sub frames making permission checks.</li>
<li>
<code>isMainFrame</code> boolean - Whether the frame making the request is the main frame</li>
</ul>
</li>
</ul>
</li></ul>
<p>Sets the handler which can be used to respond to permission checks for the <code>session</code>. Returning <code>true</code> will allow the permission and <code>false</code> will reject it. Please note that you must also implement <code>setPermissionRequestHandler</code> to get complete permission handling. Most web APIs do a permission check and then make a permission request if the check is denied. To clear the handler, call <code>setPermissionCheckHandler(null)</code>.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { session } = require('electron')
const url = require('url')
session.fromPartition('some-partition').setPermissionCheckHandler((webContents, permission, requestingOrigin) =&gt; {
  if (new URL(requestingOrigin).hostname === 'some-host' &amp;&amp; permission === 'notifications') {
    return true // granted
  }

  return false // denied
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetdevicepermissionhandlerhandler">
<code>ses.setDevicePermissionHandler(handler)</code><a class="hash-link" href="#sessetdevicepermissionhandlerhandler" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>handler</code> Function\&lt;boolean&gt; | null<ul><li>
<code>details</code> Object<ul>
<li>
<code>deviceType</code> string - The type of device that permission is being requested on, can be <code>hid</code> or <code>serial</code>.</li>
<li>
<code>origin</code> string - The origin URL of the device permission check.</li>
<li>
<code>device</code> <a aria-describedby="structures-tooltip" href="structures/hid-device.html" class="link_nCrB">HIDDevice</a> | <a aria-describedby="structures-tooltip" href="structures/serial-port.html" class="link_nCrB">SerialPort</a>- the device that permission is being requested for.</li>
</ul>
</li></ul>
</li></ul>
<p>Sets the handler which can be used to respond to device permission checks for the <code>session</code>. Returning <code>true</code> will allow the device to be permitted and <code>false</code> will reject it. To clear the handler, call <code>setDevicePermissionHandler(null)</code>. This handler can be used to provide default permissioning to devices without first calling for permission to devices (eg via <code>navigator.hid.requestDevice</code>). If this handler is not defined, the default device permissions as granted through device selection (eg via <code>navigator.hid.requestDevice</code>) will be used. Additionally, the default behavior of Electron is to store granted device permision in memory. If longer term storage is needed, a developer can store granted device permissions (eg when handling the <code>select-hid-device</code> event) and then read from that storage with <code>setDevicePermissionHandler</code>.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, BrowserWindow } = require('electron')

let win = null

app.whenReady().then(() =&gt; {
  win = new BrowserWindow()

  win.webContents.session.setPermissionCheckHandler((webContents, permission, requestingOrigin, details) =&gt; {
    if (permission === 'hid') {
      // Add logic here to determine if permission should be given to allow HID selection
      return true
    } else if (permission === 'serial') {
      // Add logic here to determine if permission should be given to allow serial port selection
    }
    return false
  })

  // Optionally, retrieve previously persisted devices from a persistent store
  const grantedDevices = fetchGrantedDevices()

  win.webContents.session.setDevicePermissionHandler((details) =&gt; {
    if (new URL(details.origin).hostname === 'some-host' &amp;&amp; details.deviceType === 'hid') {
      if (details.device.vendorId === 123 &amp;&amp; details.device.productId === 345) {
        // Always allow this type of device (this allows skipping the call to `navigator.hid.requestDevice` first)
        return true
      }

      // Search through the list of devices that have previously been granted permission
      return grantedDevices.some((grantedDevice) =&gt; {
        return grantedDevice.vendorId === details.device.vendorId &amp;&amp;
              grantedDevice.productId === details.device.productId &amp;&amp;
              grantedDevice.serialNumber &amp;&amp; grantedDevice.serialNumber === details.device.serialNumber
      })
    } else if (details.deviceType === 'serial') {
      if (details.device.vendorId === 123 &amp;&amp; details.device.productId === 345) {
        // Always allow this type of device (this allows skipping the call to `navigator.hid.requestDevice` first)
        return true
      }
    }
    return false
  })

  win.webContents.session.on('select-hid-device', (event, details, callback) =&gt; {
    event.preventDefault()
    const selectedDevice = details.deviceList.find((device) =&gt; {
      return device.vendorId === '9025' &amp;&amp; device.productId === '67'
    })
    callback(selectedPort?.deviceId)
  })
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesclearhostresolvercache">
<code>ses.clearHostResolverCache()</code><a class="hash-link" href="#sesclearhostresolvercache" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;void&gt;</code> - Resolves when the operation is complete.</p>
<p>Clears the host resolver cache.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesallowntlmcredentialsfordomainsdomains">
<code>ses.allowNTLMCredentialsForDomains(domains)</code><a class="hash-link" href="#sesallowntlmcredentialsfordomainsdomains" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>domains</code> string - A comma-separated list of servers for which integrated authentication is enabled.</li></ul>
<p>Dynamically sets whether to always send credentials for HTTP NTLM or Negotiate authentication.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { session } = require('electron')
// consider any url ending with `example.com`, `foobar.com`, `baz`
// for integrated authentication.
session.defaultSession.allowNTLMCredentialsForDomains('*example.com, *foobar.com, *baz')

// consider all urls for integrated authentication.
session.defaultSession.allowNTLMCredentialsForDomains('*')</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetuseragentuseragent-acceptlanguages">
<code>ses.setUserAgent(userAgent[, acceptLanguages])</code><a class="hash-link" href="#sessetuseragentuseragent-acceptlanguages" title="Direct link to heading">​</a>
</h4>
<ul>
<li>
<code>userAgent</code> string</li>
<li>
<code>acceptLanguages</code> string (optional)</li>
</ul>
<p>Overrides the <code>userAgent</code> and <code>acceptLanguages</code> for this session.</p>
<p>The <code>acceptLanguages</code> must a comma separated ordered list of language codes, for example <code>"en-US,fr,de,ko,zh-CN,ja"</code>.</p>
<p>This doesn't affect existing <code>WebContents</code>, and each <code>WebContents</code> can use <code>webContents.setUserAgent</code> to override the session-wide user agent.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesispersistent">
<code>ses.isPersistent()</code><a class="hash-link" href="#sesispersistent" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>boolean</code> - Whether or not this session is a persistent one. The default <code>webContents</code> session of a <code>BrowserWindow</code> is persistent. When creating a session from a partition, session prefixed with <code>persist:</code> will be persistent, while others will be temporary.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetuseragent">
<code>ses.getUserAgent()</code><a class="hash-link" href="#sesgetuseragent" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>string</code> - The user agent for this session.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetsslconfigconfig">
<code>ses.setSSLConfig(config)</code><a class="hash-link" href="#sessetsslconfigconfig" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>config</code> Object<ul>
<li>
<code>minVersion</code> string (optional) - Can be <code>tls1</code>, <code>tls1.1</code>, <code>tls1.2</code> or <code>tls1.3</code>. The minimum SSL version to allow when connecting to remote servers. Defaults to <code>tls1</code>.</li>
<li>
<code>maxVersion</code> string (optional) - Can be <code>tls1.2</code> or <code>tls1.3</code>. The maximum SSL version to allow when connecting to remote servers. Defaults to <code>tls1.3</code>.</li>
<li>
<code>disabledCipherSuites</code> Integer[] (optional) - List of cipher suites which should be explicitly prevented from being used in addition to those disabled by the net built-in policy. Supported literal forms: 0xAABB, where AA is <code>cipher_suite[0]</code> and BB is <code>cipher_suite[1]</code>, as defined in RFC 2246, Section 7.4.1.2. Unrecognized but parsable cipher suites in this form will not return an error. Ex: To disable TLS_RSA_WITH_RC4_128_MD5, specify 0x0004, while to disable TLS_ECDH_ECDSA_WITH_RC4_128_SHA, specify 0xC002. Note that TLSv1.3 ciphers cannot be disabled using this mechanism.</li>
</ul>
</li></ul>
<p>Sets the SSL configuration for the session. All subsequent network requests will use the new configuration. Existing network connections (such as WebSocket connections) will not be terminated, but old sockets in the pool will not be reused for new connections.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetblobdataidentifier">
<code>ses.getBlobData(identifier)</code><a class="hash-link" href="#sesgetblobdataidentifier" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>identifier</code> string - Valid UUID.</li></ul>
<p>Returns <code>Promise&lt;Buffer&gt;</code> - resolves with blob data.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesdownloadurlurl">
<code>ses.downloadURL(url)</code><a class="hash-link" href="#sesdownloadurlurl" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>url</code> string</li></ul>
<p>Initiates a download of the resource at <code>url</code>. The API will generate a <a href="download-item.html">DownloadItem</a> that can be accessed with the <a href="#event-will-download">will-download</a> event.</p>
<p><strong>Note:</strong> This does not perform any security checks that relate to a page's origin, unlike <a href="web-contents.html#contentsdownloadurlurl"><code>webContents.downloadURL</code></a>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sescreateinterrupteddownloadoptions">
<code>ses.createInterruptedDownload(options)</code><a class="hash-link" href="#sescreateinterrupteddownloadoptions" title="Direct link to heading">​</a>
</h4>
<ul><li class="electron-api-options-list">
<code>options</code> Object<ul>
<li>
<code>path</code> string - Absolute path of the download.</li>
<li>
<code>urlChain</code> string[] - Complete URL chain for the download.</li>
<li>
<code>mimeType</code> string (optional)</li>
<li>
<code>offset</code> Integer - Start range for the download.</li>
<li>
<code>length</code> Integer - Total length of the download.</li>
<li>
<code>lastModified</code> string (optional) - Last-Modified header value.</li>
<li>
<code>eTag</code> string (optional) - ETag header value.</li>
<li>
<code>startTime</code> Double (optional) - Time when download was started in number of seconds since UNIX epoch.</li>
</ul>
</li></ul>
<p>Allows resuming <code>cancelled</code> or <code>interrupted</code> downloads from previous <code>Session</code>. The API will generate a <a href="download-item.html">DownloadItem</a> that can be accessed with the <a href="#event-will-download">will-download</a> event. The <a href="download-item.html">DownloadItem</a> will not have any <code>WebContents</code> associated with it and the initial state will be <code>interrupted</code>. The download will start only when the <code>resume</code> API is called on the <a href="download-item.html">DownloadItem</a>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesclearauthcache">
<code>ses.clearAuthCache()</code><a class="hash-link" href="#sesclearauthcache" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;void&gt;</code> - resolves when the session’s HTTP authentication cache has been cleared.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetpreloadspreloads">
<code>ses.setPreloads(preloads)</code><a class="hash-link" href="#sessetpreloadspreloads" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>preloads</code> string[] - An array of absolute path to preload scripts</li></ul>
<p>Adds scripts that will be executed on ALL web contents that are associated with this session just before normal <code>preload</code> scripts run.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetpreloads">
<code>ses.getPreloads()</code><a class="hash-link" href="#sesgetpreloads" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>string[]</code> an array of paths to preload scripts that have been registered.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetcodecachepathpath">
<code>ses.setCodeCachePath(path)</code><a class="hash-link" href="#sessetcodecachepathpath" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>path</code> String - Absolute path to store the v8 generated JS code cache from the renderer.</li></ul>
<p>Sets the directory to store the generated JS <a href="https://v8.dev/blog/code-caching-for-devs" target="_blank" rel="noopener noreferrer">code cache</a> for this session. The directory is not required to be created by the user before this call, the runtime will create if it does not exist otherwise will use the existing directory. If directory cannot be created, then code cache will not be used and all operations related to code cache will fail silently inside the runtime. By default, the directory will be <code>Code Cache</code> under the respective user data folder.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesclearcodecachesoptions">
<code>ses.clearCodeCaches(options)</code><a class="hash-link" href="#sesclearcodecachesoptions" title="Direct link to heading">​</a>
</h4>
<ul><li class="electron-api-options-list">
<code>options</code> Object<ul><li>
<code>urls</code> String[] (optional) - An array of url corresponding to the resource whose generated code cache needs to be removed. If the list is empty then all entries in the cache directory will be removed.</li></ul>
</li></ul>
<p>Returns <code>Promise&lt;void&gt;</code> - resolves when the code cache clear operation is complete.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetspellcheckerenabledenable">
<code>ses.setSpellCheckerEnabled(enable)</code><a class="hash-link" href="#sessetspellcheckerenabledenable" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>enable</code> boolean</li></ul>
<p>Sets whether to enable the builtin spell checker.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesisspellcheckerenabled">
<code>ses.isSpellCheckerEnabled()</code><a class="hash-link" href="#sesisspellcheckerenabled" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>boolean</code> - Whether the builtin spell checker is enabled.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetspellcheckerlanguageslanguages">
<code>ses.setSpellCheckerLanguages(languages)</code><a class="hash-link" href="#sessetspellcheckerlanguageslanguages" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>languages</code> string[] - An array of language codes to enable the spellchecker for.</li></ul>
<p>The built in spellchecker does not automatically detect what language a user is typing in. In order for the spell checker to correctly check their words you must call this API with an array of language codes. You can get the list of supported language codes with the <code>ses.availableSpellCheckerLanguages</code> property.</p>
<p><strong>Note:</strong> On macOS the OS spellchecker is used and will detect your language automatically. This API is a no-op on macOS.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetspellcheckerlanguages">
<code>ses.getSpellCheckerLanguages()</code><a class="hash-link" href="#sesgetspellcheckerlanguages" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>string[]</code> - An array of language codes the spellchecker is enabled for. If this list is empty the spellchecker will fallback to using <code>en-US</code>. By default on launch if this setting is an empty list Electron will try to populate this setting with the current OS locale. This setting is persisted across restarts.</p>
<p><strong>Note:</strong> On macOS the OS spellchecker is used and has its own list of languages. This API is a no-op on macOS.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sessetspellcheckerdictionarydownloadurlurl">
<code>ses.setSpellCheckerDictionaryDownloadURL(url)</code><a class="hash-link" href="#sessetspellcheckerdictionarydownloadurlurl" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>url</code> string - A base URL for Electron to download hunspell dictionaries from.</li></ul>
<p>By default Electron will download hunspell dictionaries from the Chromium CDN. If you want to override this behavior you can use this API to point the dictionary downloader at your own hosted version of the hunspell dictionaries. We publish a <code>hunspell_dictionaries.zip</code> file with each release which contains the files you need to host here.</p>
<p>The file server must be <strong>case insensitive</strong>. If you cannot do this, you must upload each file twice: once with the case it has in the ZIP file and once with the filename as all lowercase.</p>
<p>If the files present in <code>hunspell_dictionaries.zip</code> are available at <code>https://example.com/dictionaries/language-code.bdic</code> then you should call this api with <code>ses.setSpellCheckerDictionaryDownloadURL('https://example.com/dictionaries/')</code>. Please note the trailing slash. The URL to the dictionaries is formed as <code>${url}${filename}</code>.</p>
<p><strong>Note:</strong> On macOS the OS spellchecker is used and therefore we do not download any dictionary files. This API is a no-op on macOS.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="seslistwordsinspellcheckerdictionary">
<code>ses.listWordsInSpellCheckerDictionary()</code><a class="hash-link" href="#seslistwordsinspellcheckerdictionary" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Promise&lt;string[]&gt;</code> - An array of all words in app's custom dictionary. Resolves when the full dictionary is loaded from disk.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesaddwordtospellcheckerdictionaryword">
<code>ses.addWordToSpellCheckerDictionary(word)</code><a class="hash-link" href="#sesaddwordtospellcheckerdictionaryword" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>word</code> string - The word you want to add to the dictionary</li></ul>
<p>Returns <code>boolean</code> - Whether the word was successfully written to the custom dictionary. This API will not work on non-persistent (in-memory) sessions.</p>
<p><strong>Note:</strong> On macOS and Windows 10 this word will be written to the OS custom dictionary as well</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesremovewordfromspellcheckerdictionaryword">
<code>ses.removeWordFromSpellCheckerDictionary(word)</code><a class="hash-link" href="#sesremovewordfromspellcheckerdictionaryword" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>word</code> string - The word you want to remove from the dictionary</li></ul>
<p>Returns <code>boolean</code> - Whether the word was successfully removed from the custom dictionary. This API will not work on non-persistent (in-memory) sessions.</p>
<p><strong>Note:</strong> On macOS and Windows 10 this word will be removed from the OS custom dictionary as well</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesloadextensionpath-options">
<code>ses.loadExtension(path[, options])</code><a class="hash-link" href="#sesloadextensionpath-options" title="Direct link to heading">​</a>
</h4>
<ul>
<li>
<code>path</code> string - Path to a directory containing an unpacked Chrome extension</li>
<li class="electron-api-options-list">
<code>options</code> Object (optional)<ul><li>
<code>allowFileAccess</code> boolean - Whether to allow the extension to read local files over <code>file://</code> protocol and inject content scripts into <code>file://</code> pages. This is required e.g. for loading devtools extensions on <code>file://</code> URLs. Defaults to false.</li></ul>
</li>
</ul>
<p>Returns <code>Promise&lt;Extension&gt;</code> - resolves when the extension is loaded.</p>
<p>This method will raise an exception if the extension could not be loaded. If there are warnings when installing the extension (e.g. if the extension requests an API that Electron does not support) then they will be logged to the console.</p>
<p>Note that Electron does not support the full range of Chrome extensions APIs. See <a href="extensions.html#supported-extensions-apis">Supported Extensions APIs</a> for more details on what is supported.</p>
<p>Note that in previous versions of Electron, extensions that were loaded would be remembered for future runs of the application. This is no longer the case: <code>loadExtension</code> must be called on every boot of your app if you want the extension to be loaded.</p>
<div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, session } = require('electron')
const path = require('path')

app.on('ready', async () =&gt; {
  await session.defaultSession.loadExtension(
    path.join(__dirname, 'react-devtools'),
    // allowFileAccess is required to load the devtools extension on file:// URLs.
    { allowFileAccess: true }
  )
  // Note that in order to use the React DevTools extension, you'll need to
  // download and unzip a copy of the extension.
})</pre>

</div></div>
<p>This API does not support loading packed (.crx) extensions.</p>
<p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>
<p><strong>Note:</strong> Loading extensions into in-memory (non-persistent) sessions is not supported and will throw an error.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesremoveextensionextensionid">
<code>ses.removeExtension(extensionId)</code><a class="hash-link" href="#sesremoveextensionextensionid" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>extensionId</code> string - ID of extension to remove</li></ul>
<p>Unloads an extension.</p>
<p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetextensionextensionid">
<code>ses.getExtension(extensionId)</code><a class="hash-link" href="#sesgetextensionextensionid" title="Direct link to heading">​</a>
</h4>
<ul><li>
<code>extensionId</code> string - ID of extension to query</li></ul>
<p>Returns <code>Extension</code> | <code>null</code> - The loaded extension with the given ID.</p>
<p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetallextensions">
<code>ses.getAllExtensions()</code><a class="hash-link" href="#sesgetallextensions" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>Extension[]</code> - A list of all loaded extensions.</p>
<p><strong>Note:</strong> This API cannot be called before the <code>ready</code> event of the <code>app</code> module is emitted.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesgetstoragepath">
<code>ses.getStoragePath()</code><a class="hash-link" href="#sesgetstoragepath" title="Direct link to heading">​</a>
</h4>
<p>Returns <code>string | null</code> - The absolute file system path where data for this session is persisted on disk. For in memory sessions this returns <code>null</code>.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="instance-properties">Instance Properties<a class="hash-link" href="#instance-properties" title="Direct link to heading">​</a>
</h3>
<p>The following properties are available on instances of <code>Session</code>:</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesavailablespellcheckerlanguages-readonly">
<code>ses.availableSpellCheckerLanguages</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sesavailablespellcheckerlanguages-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <code>string[]</code> array which consists of all the known available spell checker languages. Providing a language code to the <code>setSpellCheckerLanguages</code> API that isn't in this array will result in an error.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesspellcheckerenabled">
<code>ses.spellCheckerEnabled</code><a class="hash-link" href="#sesspellcheckerenabled" title="Direct link to heading">​</a>
</h4>
<p>A <code>boolean</code> indicating whether builtin spell checker is enabled.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesstoragepath-readonly">
<code>ses.storagePath</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sesstoragepath-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <code>string | null</code> indicating the absolute file system path where data for this session is persisted on disk. For in memory sessions this returns <code>null</code>.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sescookies-readonly">
<code>ses.cookies</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sescookies-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <a href="cookies.html"><code>Cookies</code></a> object for this session.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesserviceworkers-readonly">
<code>ses.serviceWorkers</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sesserviceworkers-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <a href="service-workers.html"><code>ServiceWorkers</code></a> object for this session.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="seswebrequest-readonly">
<code>ses.webRequest</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#seswebrequest-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <a href="web-request.html"><code>WebRequest</code></a> object for this session.</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesprotocol-readonly">
<code>ses.protocol</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sesprotocol-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <a href="protocol.html"><code>Protocol</code></a> object for this session.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, session } = require('electron')
const path = require('path')

app.whenReady().then(() =&gt; {
  const protocol = session.fromPartition('some-partition').protocol
  if (!protocol.registerFileProtocol('atom', (request, callback) =&gt; {
    const url = request.url.substr(7)
    callback({ path: path.normalize(`${__dirname}/${url}`) })
  })) {
    console.error('Failed to register protocol')
  }
})</pre>

</div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="sesnetlog-readonly">
<code>ses.netLog</code> <em class="badge badge--info">Readonly</em><a class="hash-link" href="#sesnetlog-readonly" title="Direct link to heading">​</a>
</h4>
<p>A <a href="net-log.html"><code>NetLog</code></a> object for this session.</p>
<div class="language-javascript codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex">
<pre tabindex="0" class="prism-code language-javascript codeBlock_bY9V thin-scrollbar" data-language="javascript">const { app, session } = require('electron')

app.whenReady().then(async () =&gt; {
  const netLog = session.fromPartition('some-partition').netLog
  netLog.startLogging('/path/to/net-log')
  // After some network events
  const path = await netLog.stopLogging()
  console.log('Net-logs written to', path)
})</pre>

</div></div><div class="_attribution">
  <p class="_attribution-p">
    &copy; GitHub Inc.<br>Licensed under the MIT license.<br>
    <a href="https://www.electronjs.org/docs/latest/api/session" class="_attribution-link">https://www.electronjs.org/docs/latest/api/session</a>
  </p>
</div>
