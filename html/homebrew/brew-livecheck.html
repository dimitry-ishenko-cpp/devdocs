<h1 id="brew-livecheck"><code class="language-plaintext highlighter-rouge">brew livecheck</code></h1> <p>The <code class="language-plaintext highlighter-rouge">brew livecheck</code> command finds the newest version of a formula or cask’s software by checking upstream. Livecheck has <a href="https://rubydoc.brew.sh/Homebrew/Livecheck/Strategy.html">strategies</a> to identify versions from various sources, such as Git repositories, websites, etc.</p> <h2 id="behavior">Behavior</h2> <p>When livecheck isn’t given instructions for how to check for upstream versions, it does the following by default:</p> <ol> <li>For formulae: Collect the <code class="language-plaintext highlighter-rouge">head</code>, <code class="language-plaintext highlighter-rouge">stable</code>, and <code class="language-plaintext highlighter-rouge">homepage</code> URLs, in that order. For casks: Collect the <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">homepage</code> URLs, in that order.</li> <li>Determine if any strategies apply to the first URL. If not, try the next URL.</li> <li>If a strategy can be applied, use it to check for new versions.</li> <li>Return the newest version (or an error if versions could not be found at any available URLs).</li> </ol> <p>It’s sometimes necessary to override this default behavior to create a working check. If a source doesn’t provide the newest version, we need to check a different one. If livecheck doesn’t correctly match version text, we need to provide an appropriate regex or <code class="language-plaintext highlighter-rouge">strategy</code> block.</p> <p>This can be accomplished by adding a <code class="language-plaintext highlighter-rouge">livecheck</code> block to the formula/cask. For more information on the available methods, please refer to the <a href="https://rubydoc.brew.sh/Livecheck.html"><code class="language-plaintext highlighter-rouge">Livecheck</code> class documentation</a>.</p> <h2 id="creating-a-check">Creating a check</h2> <ol> <li> <p><strong>Use the debug output to understand the situation</strong>. <code class="language-plaintext highlighter-rouge">brew livecheck --debug &lt;formula&gt;|&lt;cask&gt;</code> provides information about which URLs livecheck tries, any strategies that apply, matched versions, etc.</p> </li> <li> <p><strong>Research available sources to select a URL</strong>. Try removing the file name from <code class="language-plaintext highlighter-rouge">stable</code>/<code class="language-plaintext highlighter-rouge">url</code>, to see if this is a directory listing page. If that doesn’t work, try to find a page that links to the file (e.g. a download page). If it’s not possible to find the newest version on the website, try checking other sources from the formula/cask. When necessary, search for other sources outside of the formula/cask.</p> </li> <li> <p><strong>Create a regex, if necessary</strong>. If the check works without a regex and wouldn’t benefit from having one, it’s usually fine to omit it. More information on creating regexes can be found in the <a href="#regex-guidelines">regex guidelines</a> section.</p> </li> </ol> <h3 id="general-guidelines">General guidelines</h3> <ul> <li> <p><strong>Only use <code class="language-plaintext highlighter-rouge">strategy</code> when it’s necessary</strong>. For example, if livecheck is already using <code class="language-plaintext highlighter-rouge">Git</code> for a URL, it’s not necessary to use <code class="language-plaintext highlighter-rouge">strategy :git</code>. However, if <code class="language-plaintext highlighter-rouge">Git</code> applies to a URL but we need to use <code class="language-plaintext highlighter-rouge">PageMatch</code>, it’s necessary to specify <code class="language-plaintext highlighter-rouge">strategy :page_match</code>.</p> </li> <li> <p><strong>Only use the <code class="language-plaintext highlighter-rouge">GithubLatest</code> strategy when it’s necessary and correct</strong>. <code class="language-plaintext highlighter-rouge">github.com</code> rate limits requests and we try to minimize our use of this strategy to avoid hitting the rate limit on CI or when using <code class="language-plaintext highlighter-rouge">brew livecheck --tap</code> on large taps (e.g. homebrew/core). The <code class="language-plaintext highlighter-rouge">Git</code> strategy is often sufficient and we only need to use <code class="language-plaintext highlighter-rouge">GithubLatest</code> when the “latest” release is different than the newest version from the tags.</p> </li> </ul> <h3 id="url-guidelines">URL guidelines</h3> <ul> <li> <p><strong>A <code class="language-plaintext highlighter-rouge">url</code> is required in a <code class="language-plaintext highlighter-rouge">livecheck</code> block</strong>. This can be a URL string (e.g. <code class="language-plaintext highlighter-rouge">"https://www.example.com/downloads/"</code>) or a formula/cask URL symbol (i.e. <code class="language-plaintext highlighter-rouge">:stable</code>, <code class="language-plaintext highlighter-rouge">:url</code>, <code class="language-plaintext highlighter-rouge">:head</code>, <code class="language-plaintext highlighter-rouge">:homepage</code>). The exception to this rule is a <code class="language-plaintext highlighter-rouge">livecheck</code> block that only uses <code class="language-plaintext highlighter-rouge">skip</code>.</p> </li> <li> <p><strong>Check for versions in the same location as the stable archive, whenever possible</strong>.</p> </li> <li> <p><strong>Avoid checking paginated release pages, when possible</strong>. For example, we generally avoid checking the <code class="language-plaintext highlighter-rouge">release</code> page for a GitHub project because the latest stable version can be pushed off the first page by pre-release versions. In this scenario, it’s more reliable to use the <code class="language-plaintext highlighter-rouge">Git</code> strategy, which fetches all the tags in the repository.</p> </li> </ul> <h3 id="regex-guidelines">Regex guidelines</h3> <p>The <code class="language-plaintext highlighter-rouge">livecheck</code> block regex restricts matches to a subset of the fetched content and uses a capture group around the version text.</p> <ul> <li> <p><strong>Regexes should be made case insensitive, whenever possible</strong>, by adding <code class="language-plaintext highlighter-rouge">i</code> at the end (e.g. <code class="language-plaintext highlighter-rouge">/.../i</code> or <code class="language-plaintext highlighter-rouge">%r{...}i</code>). This improves reliability, as the regex will handle changes in letter case without needing modifications.</p> </li> <li> <p><strong>Regexes should only use a capturing group around the version text</strong>. For example, in <code class="language-plaintext highlighter-rouge">/href=.*?example-v?(\d+(?:\.\d+)+)(?:-src)?\.t/i</code>, we’re only using a capturing group around the version test (matching a version like <code class="language-plaintext highlighter-rouge">1.2</code>, <code class="language-plaintext highlighter-rouge">1.2.3</code>, etc.) and we’re using non-capturing groups elsewhere (e.g. <code class="language-plaintext highlighter-rouge">(?:-src)?</code>).</p> </li> <li> <p><strong>Anchor the start/end of the regex, to restrict the scope</strong>. For example, on HTML pages we often match file names or version directories in <code class="language-plaintext highlighter-rouge">href</code> attribute URLs (e.g. <code class="language-plaintext highlighter-rouge">/href=.*?example[._-]v?(\d+(?:\.\d+)+)\.zip/i</code>). The general idea is that limiting scope will help exclude unwanted matches.</p> </li> <li> <p><strong>Avoid generic catch-alls like <code class="language-plaintext highlighter-rouge">.*</code> or <code class="language-plaintext highlighter-rouge">.+</code></strong> in favor of something non-greedy and/or contextually appropriate. For example, to match characters within the bounds of an HTML attribute, use <code class="language-plaintext highlighter-rouge">[^"' &gt;]+?</code>.</p> </li> <li> <p><strong>Use <code class="language-plaintext highlighter-rouge">[._-]</code> in place of a period/underscore/hyphen between the software name and version in a file name</strong>. For a file named <code class="language-plaintext highlighter-rouge">example-1.2.3.tar.gz</code>, <code class="language-plaintext highlighter-rouge">example[._-]v?(\d+(?:\.\d+)+)\.t</code> will continue matching if the upstream file name format changes to <code class="language-plaintext highlighter-rouge">example_1.2.3.tar.gz</code> or <code class="language-plaintext highlighter-rouge">example.1.2.3.tar.gz</code>.</p> </li> <li> <p><strong>Use <code class="language-plaintext highlighter-rouge">\.t</code> in place of <code class="language-plaintext highlighter-rouge">\.tgz</code>, <code class="language-plaintext highlighter-rouge">\.tar\.gz</code>, etc.</strong> There are a variety of different file extensions for tarballs (e.g. <code class="language-plaintext highlighter-rouge">.tar.bz2</code>, <code class="language-plaintext highlighter-rouge">tbz2</code>, <code class="language-plaintext highlighter-rouge">.tar.gz</code>, <code class="language-plaintext highlighter-rouge">.tgz</code>, <code class="language-plaintext highlighter-rouge">.tar.xz</code>, <code class="language-plaintext highlighter-rouge">.txz</code>, etc.) and the upstream source may switch from one compression format to another over time. <code class="language-plaintext highlighter-rouge">\.t</code> avoids this issue by matching current and future formats starting with <code class="language-plaintext highlighter-rouge">t</code>. Outside of tarballs, we use the full file extension in the regex like <code class="language-plaintext highlighter-rouge">\.zip</code>, <code class="language-plaintext highlighter-rouge">\.jar</code>, etc.</p> </li> </ul> <h2 id="example-livecheck-blocks">Example <code class="language-plaintext highlighter-rouge">livecheck</code> blocks</h2> <p>The following examples cover a number of patterns that you may encounter. These are intended to be representative samples and can be easily adapted.</p> <p>When in doubt, start with one of these examples instead of copy-pasting a <code class="language-plaintext highlighter-rouge">livecheck</code> block from a random formula/cask.</p> <h3 id="file-names">File names</h3> <p>When matching the version from a file name on an HTML page, we often restrict matching to <code class="language-plaintext highlighter-rouge">href</code> attributes. <code class="language-plaintext highlighter-rouge">href=.*?</code> will match the opening delimiter (<code class="language-plaintext highlighter-rouge">"</code>, <code class="language-plaintext highlighter-rouge">'</code>) as well as any part of the URL before the file name.</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/downloads/"
  regex(/href=.*?example[._-]v?(\d+(?:\.\d+)+)\.t/i)
end</pre> <p>We sometimes make this more explicit to exclude unwanted matches. URLs with a preceding path can use <code class="language-plaintext highlighter-rouge">href=.*?/</code> and others can use <code class="language-plaintext highlighter-rouge">href=["']?</code>. For example, this is necessary when the page also contains unwanted files with a longer prefix (<code class="language-plaintext highlighter-rouge">another-example-1.2.tar.gz</code>).</p> <h3 id="version-directories">Version directories</h3> <p>When checking a directory listing page, sometimes files are separated into version directories (e.g. <code class="language-plaintext highlighter-rouge">1.2.3/</code>). In this case, we must identify versions from the directory names.</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/releases/example/"
  regex(%r{href=["']?v?(\d+(?:\.\d+)+)/?["' &gt;]}i)
end</pre> <h3 id="git-tags">Git tags</h3> <p>When the <code class="language-plaintext highlighter-rouge">stable</code> URL uses the <code class="language-plaintext highlighter-rouge">Git</code> strategy, the following example will only match tags like <code class="language-plaintext highlighter-rouge">1.2</code>/<code class="language-plaintext highlighter-rouge">v1.2</code>, etc.</p> <pre data-language="ruby">livecheck do
  url :stable
  regex(/^v?(\d+(?:\.\d+)+)$/i)
end</pre> <p>If tags include the software name as a prefix (e.g. <code class="language-plaintext highlighter-rouge">example-1.2.3</code>), it’s easy to modify the regex accordingly: <code class="language-plaintext highlighter-rouge">/^example[._-]v?(\d+(?:\.\d+)+)$/i</code></p> <h3 id="referenced-formulacask">Referenced formula/cask</h3> <p>A formula/cask can use the same check as another by using <code class="language-plaintext highlighter-rouge">formula</code> or <code class="language-plaintext highlighter-rouge">cask</code>.</p> <pre data-language="ruby">livecheck do
  formula "another-formula"
end</pre> <p>The referenced formula/cask should be in the same tap, as a reference to a formula/cask from another tap will generate an error if the user doesn’t already have it tapped.</p> <h3 id="strategy-blocks">
<code class="language-plaintext highlighter-rouge">strategy</code> blocks</h3> <p>If the upstream version format needs to be manipulated to match the formula/cask format, a <code class="language-plaintext highlighter-rouge">strategy</code> block can be used instead of a <code class="language-plaintext highlighter-rouge">regex</code>.</p> <h4 id="pagematch-strategy-block">
<code class="language-plaintext highlighter-rouge">PageMatch</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>In the example below, we’re converting a date format like <code class="language-plaintext highlighter-rouge">2020-01-01</code> into <code class="language-plaintext highlighter-rouge">20200101</code>.</p> <pre data-language="ruby">livecheck do
  url :homepage
  strategy :page_match do |page|
    page.scan(/href=.*?example[._-]v?(\d{4}-\d{2}-\d{2})\.t/i)
        .map { |match| match&amp;.first&amp;.gsub(/\D/, "") }
  end
end</pre> <p>The <code class="language-plaintext highlighter-rouge">PageMatch</code> <code class="language-plaintext highlighter-rouge">strategy</code> block style seen here also applies to any strategy that uses <code class="language-plaintext highlighter-rouge">PageMatch</code> internally.</p> <h4 id="git-strategy-block">
<code class="language-plaintext highlighter-rouge">Git</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Git</code> is a bit different, as the block receives an array of tag strings instead of a page content string. Similar to the <code class="language-plaintext highlighter-rouge">PageMatch</code> example, this is converting tags with a date format like <code class="language-plaintext highlighter-rouge">2020-01-01</code> into <code class="language-plaintext highlighter-rouge">20200101</code>.</p> <pre data-language="ruby">livecheck do
  url :stable
  strategy :git do |tags|
    tags.map { |tag| tag[/^(\d{4}-\d{2}-\d{2})$/i, 1]&amp;.gsub(/\D/, "") }.compact
  end
end</pre> <h4 id="sparkle-strategy-block">
<code class="language-plaintext highlighter-rouge">Sparkle</code> <code class="language-plaintext highlighter-rouge">strategy</code> block</h4> <p>A <code class="language-plaintext highlighter-rouge">strategy</code> block for <code class="language-plaintext highlighter-rouge">Sparkle</code> receives an <code class="language-plaintext highlighter-rouge">item</code> which has methods for the <code class="language-plaintext highlighter-rouge">short_version</code>, <code class="language-plaintext highlighter-rouge">version</code>, <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">title</code>.</p> <p>The default pattern for the <code class="language-plaintext highlighter-rouge">Sparkle</code> strategy is <code class="language-plaintext highlighter-rouge">"#{item.short_version},#{item.version}"</code> if both are set. In the example below, the <code class="language-plaintext highlighter-rouge">url</code> also includes a download ID which is needed:</p> <pre data-language="ruby">livecheck do
  url "https://www.example.com/example.xml"
  strategy :sparkle do |item|
    "#{item.short_version},#{item.version}:#{item.url[%r{/(\d+)/[^/]+\.zip}i, 1]}"
  end
end</pre> <h3 id="skip"><code class="language-plaintext highlighter-rouge">skip</code></h3> <p>Livecheck automatically skips some formulae/casks for a number of reasons (deprecated, disabled, discontinued, etc.). However, on rare occasions we need to use a <code class="language-plaintext highlighter-rouge">livecheck</code> block to do a manual skip. The <code class="language-plaintext highlighter-rouge">skip</code> method takes a string containing a very brief reason for skipping.</p> <pre data-language="ruby">livecheck do
  skip "No version information available"
end</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;present Homebrew contributors<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://docs.brew.sh/Brew-Livecheck" class="_attribution-link">https://docs.brew.sh/Brew-Livecheck</a>
  </p>
</div>
