<h1 id="cask-cookbook">Cask Cookbook</h1> <p>Each Cask is a Ruby block, beginning with a special header line. The Cask definition itself is always enclosed in a <code class="language-plaintext highlighter-rouge">do … end</code> block. Example:</p> <pre data-language="ruby">cask "alfred" do
  version "2.7.1_387"
  sha256 "a3738d0513d736918a6d71535ef3d85dd184af267c05698e49ac4c6b48f38e17"

  url "https://cachefly.alfredapp.com/Alfred_#{version}.zip"
  name "Alfred"
  desc "Application launcher and productivity software"
  homepage "https://www.alfredapp.com/"

  app "Alfred 2.app"
  app "Alfred 2.app/Contents/Preferences/Alfred Preferences.app"
end</pre> <h2 id="the-cask-language-is-declarative">The Cask Language Is Declarative</h2> <p>Each Cask contains a series of stanzas (or “fields”) which <em>declare</em> how the software is to be obtained and installed. In a declarative language, the author does not need to worry about <strong>order</strong>. As long as all the needed fields are present, Homebrew Cask will figure out what needs to be done at install time.</p> <p>To make maintenance easier, the most-frequently-updated stanzas are usually placed at the top. But that’s a convention, not a rule.</p> <p>Exception: <code class="language-plaintext highlighter-rouge">do</code> blocks such as <code class="language-plaintext highlighter-rouge">postflight</code> may enclose a block of pure Ruby code. Lines within that block follow a procedural (order-dependent) paradigm.</p> <h2 id="conditional-statements">Conditional Statements</h2> <h3 id="efficiency">Efficiency</h3> <p>Conditional statements are permitted, but only if they are very efficient. Tests on the following values are known to be acceptable:</p> <table> <thead> <tr> <th>value</th> <th>examples</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">MacOS.version</code></td> <td>
<a href="https://github.com/Homebrew/homebrew-cask/blob/a11ee55e8ed8255f7dab77120dfb1fb955789559/Casks/coconutbattery.rb#L2-L16">coconutbattery.rb</a>, <a href="https://github.com/Homebrew/homebrew-cask/blob/21d3f7ac8a4adac0fe474b3d4b020d284eeef88d/Casks/yasu.rb#L2-L23">yasu.rb</a>
</td> </tr> </tbody> </table> <h3 id="version-comparisons">Version Comparisons</h3> <p>Tests against <code class="language-plaintext highlighter-rouge">MacOS.version</code> may use either symbolic names or version strings with numeric comparison operators:</p> <pre data-language="ruby">if MacOS.version &lt;= :mojave        # symbolic name</pre> <pre data-language="ruby">if MacOS.version &lt;= "10.14"        # version string</pre> <p>The available symbols for macOS versions are: <code class="language-plaintext highlighter-rouge">:el_capitan</code>, <code class="language-plaintext highlighter-rouge">:sierra</code>, <code class="language-plaintext highlighter-rouge">:high_sierra</code>, <code class="language-plaintext highlighter-rouge">:mojave</code>, <code class="language-plaintext highlighter-rouge">:catalina</code> and <code class="language-plaintext highlighter-rouge">:big_sur</code>. The corresponding numeric version strings should be given as major releases containing a single dot.</p> <p>Note that in the official Homebrew Cask repositories only the symbolic names are allowed. The numeric comparison may only be used for third-party taps.</p> <h3 id="always-fall-through-to-the-newest-case">Always Fall Through to the Newest Case</h3> <p>Conditionals should be constructed so that the default is the newest OS version. When using an <code class="language-plaintext highlighter-rouge">if</code> statement, test for older versions, and then let the <code class="language-plaintext highlighter-rouge">else</code> statement hold the latest and greatest. This makes it more likely that the Cask will work without alteration when a new OS is released. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/2c801af44be29fff7f3cb2996455fce5dd95d1cc/Casks/coconutbattery.rb">coconutbattery.rb</a>):</p> <pre data-language="ruby">if MacOS.version &lt;= :sierra
  # ...
elsif MacOS.version &lt;= :mojave
  # ...
else
  # ...
end</pre> <h3 id="switch-between-languages-or-regions">Switch Between Languages or Regions</h3> <p>If a cask is available in multiple languages, you can use the <code class="language-plaintext highlighter-rouge">language</code> stanza to switch between languages or regions based on the system locale.</p> <h2 id="arbitrary-ruby-methods">Arbitrary Ruby Methods</h2> <p>In the exceptional case that the Cask DSL is insufficient, it is possible to define arbitrary Ruby variables and methods inside the Cask by creating a <code class="language-plaintext highlighter-rouge">Utils</code> namespace. Example:</p> <pre data-language="ruby">cask "myapp" do
  module Utils
    def self.arbitrary_method
      ...
    end
  end

  name "MyApp"
  version "1.0"
  sha256 "a32565cdb1673f4071593d4cc9e1c26bc884218b62fef8abc450daa47ba8fa92"

  url "https://#{Utils.arbitrary_method}"
  homepage "https://www.example.com/"
  ...
end</pre> <p>This should be used sparingly: any method which is needed by two or more Casks should instead be rolled into the core. Care must also be taken that such methods be very efficient.</p> <p>Variables and methods should not be defined outside the <code class="language-plaintext highlighter-rouge">Utils</code> namespace, as they may collide with Homebrew Cask internals.</p> <h2 id="header-line-details">Header Line Details</h2> <p>The first non-comment line in a Cask follows the form:</p> <pre data-language="ruby">cask "&lt;cask-token&gt;" do</pre> <p><a href="#token-reference"><code class="language-plaintext highlighter-rouge">&lt;cask-token&gt;</code></a> should match the Cask filename, without the <code class="language-plaintext highlighter-rouge">.rb</code> extension, enclosed in single quotes.</p> <p>There are currently some arbitrary limitations on Cask tokens which are in the process of being removed. GitHub Actions will catch any errors during the transition.</p> <h2 id="stanza-order">Stanza order</h2> <p>Having a common order for stanzas makes Casks easier to update and parse. Below is the complete stanza sequence (no Cask will have all stanzas). The empty lines shown here are also important, as they help to visually delineate information.</p> <pre data-language="plaintext">version
sha256

language

url
appcast
name
desc
homepage

livecheck

auto_updates
conflicts_with
depends_on
container

suite
app
pkg
installer
binary
manpage
colorpicker
dictionary
font
input_method
internet_plugin
prefpane
qlplugin
mdimporter
screen_saver
service
audio_unit_plugin
vst_plugin
vst3_plugin
artifact, target: # target: shown here as is required with `artifact`
stage_only

preflight

postflight

uninstall_preflight

uninstall_postflight

uninstall

zap

caveats</pre> <p>Note that every stanza that has additional parameters (<code class="language-plaintext highlighter-rouge">:symbols</code> after a <code class="language-plaintext highlighter-rouge">,</code>) shall have them on separate lines, one per line, in alphabetical order. An exception is <code class="language-plaintext highlighter-rouge">target:</code> which typically consists of short lines.</p> <h2 id="stanzas">Stanzas</h2> <h3 id="required-stanzas">Required Stanzas</h3> <p>Each of the following stanzas is required for every Cask.</p> <table> <thead> <tr> <th>name</th> <th>multiple occurrences allowed?</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">version</code></td> <td>no</td> <td>Application version.<br>See <a href="#stanza-version">Version Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">sha256</code></td> <td>no</td> <td>SHA-256 checksum of the file downloaded from <code class="language-plaintext highlighter-rouge">url</code>, calculated by the command <code class="language-plaintext highlighter-rouge">shasum -a 256 &lt;file&gt;</code>. Can be suppressed by using the special value <code class="language-plaintext highlighter-rouge">:no_check</code>.<br>See <a href="#stanza-sha256">Checksum Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">url</code></td> <td>no</td> <td>URL to the <code class="language-plaintext highlighter-rouge">.dmg</code>/<code class="language-plaintext highlighter-rouge">.zip</code>/<code class="language-plaintext highlighter-rouge">.tgz</code>/<code class="language-plaintext highlighter-rouge">.tbz2</code> file that contains the application.<br>A <a href="#when-url-and-homepage-hostnames-differ-add-a-comment">comment</a> should be added if the hostnames in the <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">homepage</code> stanzas differ. Block syntax should be used for URLs that change on every visit.<br>See <a href="#stanza-url">URL Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">name</code></td> <td>yes</td> <td>String providing the full and proper name defined by the vendor.<br>See <a href="#stanza-name">Name Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">desc</code></td> <td>no</td> <td>One-line description of the Cask. Shows when running <code class="language-plaintext highlighter-rouge">brew info</code>.<br>See <a href="#stanza-desc">Desc Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">homepage</code></td> <td>no</td> <td>Application homepage; used for the <code class="language-plaintext highlighter-rouge">brew home</code> command.</td> </tr> </tbody> </table> <h3 id="at-least-one-artifact-stanza-is-also-required">At Least One Artifact Stanza Is Also Required</h3> <p>Each Cask must declare one or more <em>artifacts</em> (i.e. something to install).</p> <table> <thead> <tr> <th>name</th> <th>multiple occurrences allowed?</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">app</code></td> <td>yes</td> <td>Relative path to an <code class="language-plaintext highlighter-rouge">.app</code> that should be moved into the <code class="language-plaintext highlighter-rouge">/Applications</code> folder on installation.<br>See <a href="#stanza-app">App Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">pkg</code></td> <td>yes</td> <td>Relative path to a <code class="language-plaintext highlighter-rouge">.pkg</code> file containing the distribution.<br>See <a href="#stanza-pkg">Pkg Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">binary</code></td> <td>yes</td> <td>Relative path to a Binary that should be linked into the <code class="language-plaintext highlighter-rouge">$(brew --prefix)/bin</code> folder (typically <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>) on installation.<br>See <a href="#stanza-binary">Binary Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">colorpicker</code></td> <td>yes</td> <td>Relative path to a ColorPicker plugin that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/ColorPickers</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">dictionary</code></td> <td>yes</td> <td>Relative path to a Dictionary that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Dictionaries</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">font</code></td> <td>yes</td> <td>Relative path to a Font that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Fonts</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">input_method</code></td> <td>yes</td> <td>Relative path to a Input Method that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Input Methods</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">internet_plugin</code></td> <td>yes</td> <td>Relative path to a Service that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Internet Plug-Ins</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">manpage</code></td> <td>yes</td> <td>Relative path to a Man Page that should be linked into the respective man page folder on installation, e.g. <code class="language-plaintext highlighter-rouge">/usr/local/share/man/man3</code> for <code class="language-plaintext highlighter-rouge">my_app.3</code>.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">prefpane</code></td> <td>yes</td> <td>Relative path to a Preference Pane that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/PreferencePanes</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">qlplugin</code></td> <td>yes</td> <td>Relative path to a QuickLook Plugin that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/QuickLook</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">mdimporter</code></td> <td>yes</td> <td>Relative path to a Spotlight metadata importer that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Spotlight</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">screen_saver</code></td> <td>yes</td> <td>Relative path to a Screen Saver that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Screen Savers</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">service</code></td> <td>yes</td> <td>Relative path to a Service that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Services</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">audio_unit_plugin</code></td> <td>yes</td> <td>Relative path to an Audio Unit plugin that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Audio/Components</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">vst_plugin</code></td> <td>yes</td> <td>Relative path to a VST Plugin that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Audio/VST</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">vst3_plugin</code></td> <td>yes</td> <td>Relative path to a VST3 Plugin that should be moved into the <code class="language-plaintext highlighter-rouge">~/Library/Audio/VST3</code> folder on installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">suite</code></td> <td>yes</td> <td>Relative path to a containing directory that should be moved into the <code class="language-plaintext highlighter-rouge">/Applications</code> folder on installation.<br>See <a href="#stanza-suite">Suite Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">artifact</code></td> <td>yes</td> <td>Relative path to an arbitrary path that should be moved on installation. Must provide an absolute path as a <code class="language-plaintext highlighter-rouge">target</code> (example <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/alcatraz.rb#L12">alcatraz.rb</a>). This is only for unusual cases. The <code class="language-plaintext highlighter-rouge">app</code> stanza is strongly preferred when moving <code class="language-plaintext highlighter-rouge">.app</code> bundles.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">installer</code></td> <td>yes</td> <td>Describes an executable which must be run to complete the installation.<br>See <a href="#stanza-installer">Installer Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">stage_only</code></td> <td>no</td> <td>
<code class="language-plaintext highlighter-rouge">true</code>. Assert that the Cask contains no activatable artifacts.</td> </tr> </tbody> </table> <h3 id="optional-stanzas">Optional Stanzas</h3> <table> <thead> <tr> <th>name</th> <th>multiple occurrences allowed?</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">uninstall</code></td> <td>yes</td> <td>Procedures to uninstall a Cask. Optional unless the <code class="language-plaintext highlighter-rouge">pkg</code> stanza is used.<br>See <a href="#stanza-uninstall">Uninstall Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">zap</code></td> <td>yes</td> <td>Additional procedures for a more complete uninstall, including user files and shared resources.<br>See <a href="#stanza-zap">Zap Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">appcast</code></td> <td>no</td> <td>URL providing an appcast feed to find updates for this Cask.<br>See <a href="#stanza-appcast">Appcast Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">depends_on</code></td> <td>yes</td> <td>List of dependencies and requirements for this Cask.<br>See <a href="#stanza-depends_on">Depends_on Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">conflicts_with</code></td> <td>yes</td> <td>List of conflicts with this Cask (<em>not yet functional</em>).<br>See <a href="#stanza-conflicts_with">Conflicts_with Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">caveats</code></td> <td>yes</td> <td>String or Ruby block providing the user with Cask-specific information at install time.<br>See <a href="#stanza-caveats">Caveats Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">livecheck</code></td> <td>no</td> <td>Ruby block describing how to find updates for this Cask.<br>See <a href="#stanza-livecheck">Livecheck Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">preflight</code></td> <td>yes</td> <td>Ruby block containing preflight install operations (needed only in very rare cases).</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">postflight</code></td> <td>yes</td> <td>Ruby block containing postflight install operations.<br>See <a href="#stanza-flight">Postflight Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">uninstall_preflight</code></td> <td>yes</td> <td>Ruby block containing preflight uninstall operations (needed only in very rare cases).</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">uninstall_postflight</code></td> <td>yes</td> <td>Ruby block containing postflight uninstall operations.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">language</code></td> <td>required</td> <td>Ruby block, called with language code parameters, containing other stanzas and/or a return value.<br>See <a href="#stanza-language">Language Stanza Details</a> for more information.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">container nested:</code></td> <td>no</td> <td>Relative path to an inner container that must be extracted before moving on with the installation. This allows us to support dmg inside tar, zip inside dmg, etc.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">container type:</code></td> <td>no</td> <td>Symbol to override container-type autodetect. May be one of: <code class="language-plaintext highlighter-rouge">:air</code>, <code class="language-plaintext highlighter-rouge">:bz2</code>, <code class="language-plaintext highlighter-rouge">:cab</code>, <code class="language-plaintext highlighter-rouge">:dmg</code>, <code class="language-plaintext highlighter-rouge">:generic_unar</code>, <code class="language-plaintext highlighter-rouge">:gzip</code>, <code class="language-plaintext highlighter-rouge">:otf</code>, <code class="language-plaintext highlighter-rouge">:pkg</code>, <code class="language-plaintext highlighter-rouge">:rar</code>, <code class="language-plaintext highlighter-rouge">:seven_zip</code>, <code class="language-plaintext highlighter-rouge">:sit</code>, <code class="language-plaintext highlighter-rouge">:tar</code>, <code class="language-plaintext highlighter-rouge">:ttf</code>, <code class="language-plaintext highlighter-rouge">:xar</code>, <code class="language-plaintext highlighter-rouge">:zip</code>, <code class="language-plaintext highlighter-rouge">:naked</code>. (Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/parse.rb#L11">parse.rb</a>)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">auto_updates</code></td> <td>no</td> <td>
<code class="language-plaintext highlighter-rouge">true</code>. Assert the Cask artifacts auto-update. Use if <code class="language-plaintext highlighter-rouge">Check for Updates…</code> or similar is present in app menu, but not if it only opens a webpage and does not do the download and installation for you.</td> </tr> </tbody> </table> <h2 id="stanza-descriptions">Stanza descriptions</h2> <h3 id="stanza-app">Stanza: <code class="language-plaintext highlighter-rouge">app</code>
</h3> <p>In the simple case of a string argument to <code class="language-plaintext highlighter-rouge">app</code>, the source file is moved to the target <code class="language-plaintext highlighter-rouge">/Applications</code> directory. For example:</p> <pre data-language="ruby">app "Alfred 2.app"</pre> <p>by default moves the source to:</p> <pre data-language="bash">/Applications/Alfred 2.app</pre> <h4 id="renaming-the-target">Renaming the Target</h4> <p>You can rename the target which appears in your <code class="language-plaintext highlighter-rouge">/Applications</code> directory by adding a <code class="language-plaintext highlighter-rouge">target:</code> key to <code class="language-plaintext highlighter-rouge">app</code>. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/scala-ide.rb#L21">scala-ide.rb</a>):</p> <pre data-language="ruby">app "eclipse/Eclipse.app", target: "Scala IDE.app"</pre> <h4 id="target-may-contain-an-absolute-path">target: May Contain an Absolute Path</h4> <p>If <code class="language-plaintext highlighter-rouge">target:</code> has a leading slash, it is interpreted as an absolute path. The containing directory for the absolute path will be created if it does not already exist. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/manopen.rb#L12">manopen.rb</a>):</p> <pre data-language="ruby">artifact "openman.1", target: "/usr/local/share/man/man1/openman.1"</pre> <h4 id="target-works-on-most-artifact-types">target: Works on Most Artifact Types</h4> <p>The <code class="language-plaintext highlighter-rouge">target:</code> key works similarly for most Cask artifacts, such as <code class="language-plaintext highlighter-rouge">app</code>, <code class="language-plaintext highlighter-rouge">binary</code>, <code class="language-plaintext highlighter-rouge">colorpicker</code>, <code class="language-plaintext highlighter-rouge">dictionary</code>, <code class="language-plaintext highlighter-rouge">font</code>, <code class="language-plaintext highlighter-rouge">input_method</code>, <code class="language-plaintext highlighter-rouge">prefpane</code>, <code class="language-plaintext highlighter-rouge">qlplugin</code>, <code class="language-plaintext highlighter-rouge">mdimporter</code>, <code class="language-plaintext highlighter-rouge">service</code>, <code class="language-plaintext highlighter-rouge">suite</code>, and <code class="language-plaintext highlighter-rouge">artifact</code>.</p> <h4 id="target-should-only-be-used-in-select-cases">target: Should Only Be Used in Select Cases</h4> <p>Don’t use <code class="language-plaintext highlighter-rouge">target:</code> for aesthetic reasons, like removing version numbers (<code class="language-plaintext highlighter-rouge">app "Slack #{version}.app", target: "Slack.app"</code>). Use it when it makes sense functionally and document your reason clearly in the Cask, using one of the templates: <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/imagemin.rb#L12">for clarity</a>; <a href="https://github.com/Homebrew/homebrew-cask/blob/d2a6b26df69fc28c4d84d6f5198b2b652c2f414d/Casks/devonthink-pro-office.rb#L16">for consistency</a>; <a href="https://github.com/Homebrew/homebrew-cask/blob/bd6dc1a64e0bdd35ba0e20789045ea023b0b6aed/Casks/flash-player-debugger.rb#L11">to prevent conflicts</a>; <a href="https://github.com/Homebrew/homebrew-cask/blob/ff3e9c4a6623af44b8a071027e8dcf3f4edfc6d9/Casks/kivy.rb#L12">due to developer suggestion</a>.</p> <h3 id="stanza-appcast">Stanza: <code class="language-plaintext highlighter-rouge">appcast</code>
</h3> <p>The value of the <code class="language-plaintext highlighter-rouge">appcast</code> stanza is a string, holding the URL for an appcast which provides information on future updates.</p> <p>Note: The <a href="#stanza-livecheck"><code class="language-plaintext highlighter-rouge">livecheck</code> stanza</a> should be preferred in most cases, as it allows casks to be updated automatically.</p> <p>The main casks repo only accepts submissions for stable versions of software (and <a href="acceptable-casks.html#but-there-is-no-stable-version">documented exceptions</a>), but it still gets pull requests for unstable versions. By checking the submitted <code class="language-plaintext highlighter-rouge">version</code> against the contents of an appcast, we can better detect these invalid cases.</p> <p>Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/645dbb8228ec2f1f217ed1431e188687aac13ca5/Casks/atom.rb#L7"><code class="language-plaintext highlighter-rouge">atom.rb</code></a></p> <p>There are a few different ways the <code class="language-plaintext highlighter-rouge">appcast</code> can be determined:</p> <ul> <li> <p>If the app is distributed via GitHub releases, the <code class="language-plaintext highlighter-rouge">appcast</code> will be of the form <code class="language-plaintext highlighter-rouge">https://github.com/&lt;user&gt;/&lt;project_name&gt;/releases.atom</code>. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/645dbb8228ec2f1f217ed1431e188687aac13ca5/Casks/electron.rb#L7"><code class="language-plaintext highlighter-rouge">electron.rb</code></a></p> </li> <li> <p>If the app is distributed via GitLab releases, the <code class="language-plaintext highlighter-rouge">appcast</code> will be of the form <code class="language-plaintext highlighter-rouge">https://gitlab.com/&lt;user&gt;/&lt;project_name&gt;/-/tags?format=atom</code>. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/b22381902f9da870bb07d21b496558f283dad612/Casks/grafx.rb#L6"><code class="language-plaintext highlighter-rouge">grafx.rb</code></a></p> </li> <li> <p>The popular update framework <a href="https://sparkle-project.org/">Sparkle</a> generally uses the <code class="language-plaintext highlighter-rouge">SUFeedURL</code> property in <code class="language-plaintext highlighter-rouge">Contents/Info.plist</code> inside <code class="language-plaintext highlighter-rouge">.app</code> bundles. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/645dbb8228ec2f1f217ed1431e188687aac13ca5/Casks/glyphs.rb#L6"><code class="language-plaintext highlighter-rouge">glyphs.rb</code></a></p> </li> <li> <p>Sourceforge projects follow the form <code class="language-plaintext highlighter-rouge">https://sourceforge.net/projects/&lt;project_name&gt;/rss</code>. A more specific page can be used as needed, pointing to a specific directory structure: <code class="language-plaintext highlighter-rouge">https://sourceforge.net/projects/&lt;project_name&gt;/rss?path=/&lt;path_here&gt;</code>. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/645dbb8228ec2f1f217ed1431e188687aac13ca5/Casks/seashore.rb#L6"><code class="language-plaintext highlighter-rouge">seashore.rb</code></a></p> </li> <li> <p>An appcast can be any URL hosted by the app’s developer that changes every time a new release is out or that contains the version number of the current release (e.g. a download HTML page). Webpages that only change on new version releases are preferred, as are sites that do not contain previous version strings (i.e. avoid changelog pages if the download page contains the current version number but not older ones). Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/645dbb8228ec2f1f217ed1431e188687aac13ca5/Casks/razorsql.rb#L6"><code class="language-plaintext highlighter-rouge">razorsql.rb</code></a></p> </li> </ul> <p>The <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/developer/bin/find-appcast"><code class="language-plaintext highlighter-rouge">find-appcast</code></a> script is able to identify some of these, as well as <code class="language-plaintext highlighter-rouge">electron-builder</code> appcasts which are trickier to find by hand. Run it with <code class="language-plaintext highlighter-rouge">"$(brew --repository homebrew/cask)/developer/bin/find-appcast" '&lt;/path/to/software.app&gt;'</code>.</p> <h4 id="parameters">Parameters</h4> <table> <thead> <tr> <th>key</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">must_contain:</code></td> <td>a custom string for <code class="language-plaintext highlighter-rouge">brew audit --appcast &lt;cask&gt;</code> to check against.</td> </tr> </tbody> </table> <p>Sometimes a <code class="language-plaintext highlighter-rouge">version</code> doesn’t match a string on the webpage, in which case we tweak what to search for. Example: if <code class="language-plaintext highlighter-rouge">version</code> is <code class="language-plaintext highlighter-rouge">6.26.1440</code> and the appcast’s contents only show <code class="language-plaintext highlighter-rouge">6.24</code>, the check for “is <code class="language-plaintext highlighter-rouge">version</code> in the appcast feed” will fail. With <code class="language-plaintext highlighter-rouge">must_contain</code>, the check is told to “look for this string instead of <code class="language-plaintext highlighter-rouge">version</code>”. In the example, <code class="language-plaintext highlighter-rouge">must_contain: version.major_minor</code> is saying “look for <code class="language-plaintext highlighter-rouge">6.24</code>”, making the check succeed.</p> <p>If no <code class="language-plaintext highlighter-rouge">must_contain</code> is given, the check considers from the beginning of the <code class="language-plaintext highlighter-rouge">version</code> string until the first character that isn’t alphanumeric or a period. Example: if <code class="language-plaintext highlighter-rouge">version</code> is <code class="language-plaintext highlighter-rouge">6.26b-14,40</code>, the check will see <code class="language-plaintext highlighter-rouge">6.26b</code>. This is so it covers most cases by default, while still allowing complex <code class="language-plaintext highlighter-rouge">version</code>s suitable for interpolation on the rest of the cask.</p> <p>Example of using <code class="language-plaintext highlighter-rouge">must_contain</code>: <a href="https://github.com/Homebrew/homebrew-cask/blob/87bc3860f43d5b14d0c38ae8de469d24ee7f5b2f/Casks/hwsensors.rb#L6L7"><code class="language-plaintext highlighter-rouge">hwsensors.rb</code></a></p> <h3 id="stanza-binary">Stanza: <code class="language-plaintext highlighter-rouge">binary</code>
</h3> <p>In the simple case of a string argument to <code class="language-plaintext highlighter-rouge">binary</code>, the source file is linked into the <code class="language-plaintext highlighter-rouge">$(brew --prefix)/bin</code> directory (typically <code class="language-plaintext highlighter-rouge">/usr/local/bin</code>) on installation. For example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/60531a2812005dd5f17dc92f3ce7419af3c5d019/Casks/operadriver.rb#L11">operadriver.rb</a>):</p> <pre data-language="ruby">binary "operadriver"</pre> <p>creates a symlink to:</p> <pre data-language="bash">$(brew --prefix)/bin/operadriver</pre> <p>from a source file such as:</p> <pre data-language="bash">/usr/local/Caskroom/operadriver/0.2.2/operadriver</pre> <p>A binary (or multiple) can also be contained in an application bundle:</p> <pre data-language="ruby">app "Atom.app"
binary "#{appdir}/Atom.app/Contents/Resources/app/apm/bin/apm"</pre> <p>You can rename the target which appears in your binaries directory by adding a <code class="language-plaintext highlighter-rouge">target:</code> key to <code class="language-plaintext highlighter-rouge">binary</code>:</p> <pre data-language="ruby">binary "#{appdir}/Atom.app/Contents/Resources/app/atom.sh", target: "atom"</pre> <p>Behaviour and usage of <code class="language-plaintext highlighter-rouge">target:</code> is <a href="#renaming-the-target">the same as with <code class="language-plaintext highlighter-rouge">app</code></a>. However, for <code class="language-plaintext highlighter-rouge">binary</code> the select cases don’t apply as rigidly. It’s fine to take extra liberties with <code class="language-plaintext highlighter-rouge">target:</code> to be consistent with other command-line tools, like <a href="https://github.com/Homebrew/homebrew-cask/blob/9ad93b833961f1d969505bc6bdb1c2ad4e58a433/Casks/openscad.rb#L12">changing case</a>, <a href="https://github.com/Homebrew/homebrew-cask/blob/c443d4f5c6864538efe5bb1ecf662565a5ffb438/Casks/filebot.rb#L13">removing an extension</a>, or <a href="https://github.com/Homebrew/homebrew-cask/blob/146917cbcc679648de6b0bccff4e9b43fce0e6c8/Casks/minishift.rb#L13">cleaning up the name</a>.</p> <h3 id="stanza-caveats">Stanza: <code class="language-plaintext highlighter-rouge">caveats</code>
</h3> <p>Sometimes there are particularities with the installation of a piece of software that cannot or should not be handled programmatically by Homebrew Cask. In those instances, <code class="language-plaintext highlighter-rouge">caveats</code> is the way to inform the user. Information in <code class="language-plaintext highlighter-rouge">caveats</code> is displayed when a cask is invoked with either <code class="language-plaintext highlighter-rouge">install</code> or <code class="language-plaintext highlighter-rouge">info</code>.</p> <p>To avoid flooding users with too many messages (thus desensitising them to the important ones), <code class="language-plaintext highlighter-rouge">caveats</code> should be used sparingly and exclusively for installation-related matters. If you’re not sure a <code class="language-plaintext highlighter-rouge">caveat</code> you find pertinent is installation-related or not, ask a maintainer. As a general rule, if your case isn’t already covered in our comprehensive <a href="#caveats-mini-dsl"><code class="language-plaintext highlighter-rouge">caveats Mini-DSL</code></a>, it’s unlikely to be accepted.</p> <h4 id="caveats-as-a-string">caveats as a String</h4> <p>When <code class="language-plaintext highlighter-rouge">caveats</code> is a string, it is evaluated at compile time. The following methods are available for interpolation if <code class="language-plaintext highlighter-rouge">caveats</code> is placed in its customary position at the end of the Cask:</p> <table> <thead> <tr> <th>method</th> <th>description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">token</code></td> <td>the Cask token</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">version</code></td> <td>the Cask version</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">homepage</code></td> <td>the Cask homepage</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">caskroom_path</code></td> <td>the containing directory for this Cask, typically <code class="language-plaintext highlighter-rouge">/usr/local/Caskroom/&lt;token&gt;</code> (only available with block form)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">staged_path</code></td> <td>the staged location for this Cask, including version number: <code class="language-plaintext highlighter-rouge">/usr/local/Caskroom/&lt;token&gt;/&lt;version&gt;</code> (only available with block form)</td> </tr> </tbody> </table> <p>Example:</p> <pre data-language="ruby">caveats "Using #{token} is hazardous to your health."</pre> <h4 id="caveats-as-a-block">caveats as a Block</h4> <p>When <code class="language-plaintext highlighter-rouge">caveats</code> is a Ruby block, evaluation is deferred until install time. Within a block you may refer to the <code class="language-plaintext highlighter-rouge">@cask</code> instance variable, and invoke any method available on <code class="language-plaintext highlighter-rouge">@cask</code>.</p> <h4 id="caveats-mini-dsl">caveats Mini-DSL</h4> <p>There is a mini-DSL available within <code class="language-plaintext highlighter-rouge">caveats</code> blocks.</p> <p>The following methods may be called to generate standard warning messages:</p> <table> <thead> <tr> <th>method</th> <th>description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">path_environment_variable "path"</code></td> <td>users should make sure <code class="language-plaintext highlighter-rouge">path</code> is in their <code class="language-plaintext highlighter-rouge">$PATH</code> environment variable.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">zsh_path_helper "path"</code></td> <td>zsh users must take additional steps to make sure <code class="language-plaintext highlighter-rouge">path</code> is in their <code class="language-plaintext highlighter-rouge">$PATH</code> environment variable.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">depends_on_java "version"</code></td> <td>users should make sure they have the specified version of java installed. <code class="language-plaintext highlighter-rouge">version</code> can be exact (e.g. <code class="language-plaintext highlighter-rouge">6</code>), a minimum (e.g. <code class="language-plaintext highlighter-rouge">7+</code>), or omitted (when any version works).</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">logout</code></td> <td>users should log out and log back in to complete installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">reboot</code></td> <td>users should reboot to complete installation.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">files_in_usr_local</code></td> <td>the Cask installs files to <code class="language-plaintext highlighter-rouge">/usr/local</code>, which may confuse Homebrew.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">discontinued</code></td> <td>all software development has been officially discontinued upstream.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">free_license "web_page"</code></td> <td>users may get an official license to use the software at <code class="language-plaintext highlighter-rouge">web_page</code>.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">kext</code></td> <td>users may need to enable their kexts in System Preferences → Security &amp; Privacy → General.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">unsigned_accessibility</code></td> <td>users will need to re-enable the app on each update in System Preferences → Security &amp; Privacy → Privacy as it is unsigned.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">license "web_page"</code></td> <td>software has a usage license at <code class="language-plaintext highlighter-rouge">web_page</code>.</td> </tr> </tbody> </table> <p>Example:</p> <pre data-language="ruby">caveats do
  path_environment_variable "/usr/texbin"
end</pre> <h3 id="stanza-conflicts_with">Stanza: <code class="language-plaintext highlighter-rouge">conflicts_with</code>
</h3> <p><code class="language-plaintext highlighter-rouge">conflicts_with</code> is used to declare conflicts that keep a Cask from installing or working correctly.</p> <h4 id="conflicts_with-cask">conflicts_with cask</h4> <p>The value should be another Cask token.</p> <p>Example use: <a href="https://github.com/Homebrew/homebrew-cask/blob/903493e09cf33b845e7cf497ecf9cfc9709087ee/Casks/wireshark.rb#L10"><code class="language-plaintext highlighter-rouge">wireshark</code></a>, which conflicts with <code class="language-plaintext highlighter-rouge">wireshark-chmodbpf</code>.</p> <pre data-language="ruby">conflicts_with cask: "wireshark-chmodbpf"</pre> <h4 id="conflicts_with-formula">conflicts_with formula</h4> <p>Note: <code class="language-plaintext highlighter-rouge">conflicts_with formula:</code> is a stub and is not yet functional.</p> <p>The value should be another formula name.</p> <p>Example use: <a href="https://github.com/Homebrew/homebrew-cask/blob/84b90afd7b571e581f8a48d4bdf9c7bb24ebff3b/Casks/macvim.rb#L10"><code class="language-plaintext highlighter-rouge">macvim</code></a>, which conflicts with the <code class="language-plaintext highlighter-rouge">macvim</code> formula.</p> <pre data-language="ruby">conflicts_with formula: "macvim"</pre> <h3 id="stanza-depends_on">Stanza: <code class="language-plaintext highlighter-rouge">depends_on</code>
</h3> <p><code class="language-plaintext highlighter-rouge">depends_on</code> is used to declare dependencies and requirements for a Cask. <code class="language-plaintext highlighter-rouge">depends_on</code> is not consulted until <code class="language-plaintext highlighter-rouge">install</code> is attempted.</p> <h4 id="depends_on-cask">depends_on cask</h4> <p>The value should be another Cask token, needed by the current Cask.</p> <p>Example use: <a href="https://github.com/Homebrew/homebrew-cask/blob/4002df8f6bca93ed6eb40494995fcfa038cf99bf/Casks/cellery.rb#L11"><code class="language-plaintext highlighter-rouge">cellery</code></a> depends on OSXFUSE:</p> <pre data-language="ruby">depends_on cask: "osxfuse"</pre> <h4 id="depends_on-formula">depends_on formula</h4> <p>The value should name a Homebrew Formula needed by the Cask.</p> <p>Example use: some distributions are contained in archive formats such as <code class="language-plaintext highlighter-rouge">7z</code> which are not supported by stock Apple tools. For these cases, a more capable archive reader may be pulled in at install time by declaring a dependency on the Homebrew Formula <code class="language-plaintext highlighter-rouge">unar</code>:</p> <pre data-language="ruby">depends_on formula: "unar"</pre> <h4 id="depends_on-macos">depends_on macos</h4> <h5 id="requiring-an-exact-macos-release">Requiring an Exact macOS Release</h5> <p>The value for <code class="language-plaintext highlighter-rouge">depends_on macos:</code> may be a symbol or an array of symbols, listing the exact compatible macOS releases.</p> <p>The available values for macOS releases are:</p> <table> <thead> <tr> <th>symbol</th> <th>corresponding release</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:el_capitan</code></td> <td><code class="language-plaintext highlighter-rouge">10.11</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:sierra</code></td> <td><code class="language-plaintext highlighter-rouge">10.12</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:high_sierra</code></td> <td><code class="language-plaintext highlighter-rouge">10.13</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:mojave</code></td> <td><code class="language-plaintext highlighter-rouge">10.14</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:catalina</code></td> <td><code class="language-plaintext highlighter-rouge">10.15</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:big_sur</code></td> <td><code class="language-plaintext highlighter-rouge">11.0</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:monterey</code></td> <td><code class="language-plaintext highlighter-rouge">12.0</code></td> </tr> </tbody> </table> <p>Only major releases are covered (version numbers containing a single dot). The symbol form is used for readability. The following are all valid ways to enumerate the exact macOS release requirements for a Cask:</p> <pre data-language="ruby">depends_on macos: :big_sur
depends_on macos: [
  :catalina,
  :big_sur,
]</pre> <h5 id="setting-a-minimum-macos-release">Setting a Minimum macOS Release</h5> <p><code class="language-plaintext highlighter-rouge">depends_on macos:</code> can also accept a string starting with a comparison operator such as <code class="language-plaintext highlighter-rouge">&gt;=</code>, followed by an macOS release in the form above. The following is a valid expression meaning “at least macOS Big Sur (11.0)”:</p> <pre data-language="ruby">depends_on macos: "&gt;= :big_sur"</pre> <p>A comparison expression cannot be combined with any other form of <code class="language-plaintext highlighter-rouge">depends_on macos:</code>.</p> <h4 id="depends_on-arch">depends_on arch</h4> <p>The value for <code class="language-plaintext highlighter-rouge">depends_on arch:</code> may be a symbol or an array of symbols, listing the hardware compatibility requirements for a Cask. The requirement is satisfied at install time if any one of multiple <code class="language-plaintext highlighter-rouge">arch:</code> value matches the user’s hardware.</p> <p>The available symbols for hardware are:</p> <table> <thead> <tr> <th>symbol</th> <th>meaning</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:x86_64</code></td> <td>64-bit Intel</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:intel</code></td> <td>64-bit Intel</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:arm64</code></td> <td>Apple Silicon</td> </tr> </tbody> </table> <p>The following are all valid expressions:</p> <pre data-language="ruby">depends_on arch: :intel
depends_on arch: :x86_64            # same meaning as above
depends_on arch: [:x86_64]          # same meaning as above
depends_on arch: :arm64</pre> <h4 id="all-depends_on-keys">All depends_on Keys</h4> <table> <thead> <tr> <th>key</th> <th>description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">formula:</code></td> <td>a Homebrew Formula</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">cask:</code></td> <td>a Cask token</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">macos:</code></td> <td>a symbol, string, array, or comparison expression defining macOS release requirements</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">arch:</code></td> <td>a symbol or array defining hardware requirements</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">java:</code></td> <td><em>stub - not yet functional</em></td> </tr> </tbody> </table> <h3 id="stanza-desc">Stanza: <code class="language-plaintext highlighter-rouge">desc</code>
</h3> <p><code class="language-plaintext highlighter-rouge">desc</code> accepts a single-line UTF-8 string containing a short description of the software. It’s used to help with searchability and disambiguation, thus it must concisely describe what the software does (or what you can accomplish with it).</p> <p><code class="language-plaintext highlighter-rouge">desc</code> is not for app slogans! Vendors’ descriptions tend to be filled with generic adjectives such as “modern” and “lightweight”. Those are meaningless marketing fluff (do you ever see apps proudly describing themselves as outdated and bulky?) which must the deleted. It’s fine to use the information on the software’s website as a starting point, but it will require editing in almost all cases.</p> <h4 id="dos-and-donts">Dos and Don’ts</h4> <ul> <li> <p><strong>Do</strong> start with an uppercase letter.</p> <pre data-language="diff">- desc "sound and music editor"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do</strong> be brief, i.e. use less than 80 characters.</p> <pre data-language="diff">- desc "Sound and music editor which comes with effects, instruments, sounds and all kinds of creative features"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do</strong> describe what the software does or is:</p> <pre data-language="diff">- desc "Development of musical ideas made easy"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do not</strong> include the platform. Casks only work on macOS, so this is redundant information.</p> <pre data-language="diff">- desc "Sound and music editor for macOS"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do not</strong> include the Cask’s <a href="#stanza-name">name</a>.</p> <pre data-language="diff">- desc "Ableton Live is a sound and music editor"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do not</strong> include the vendor. This should be added to the Cask’s <a href="#stanza-name">name</a> instead.</p> <pre data-language="diff">- desc "Sound and music editor made by Ableton"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do not</strong> add user pronouns.</p> <pre data-language="diff">- desc "Edit your music files"
+ desc "Sound and music editor"</pre> </li> <li> <p><strong>Do not</strong> use empty marketing jargon.</p> <pre data-language="diff">- desc "Beautiful and powerful modern sound and music editor"
+ desc "Sound and music editor"</pre> </li> </ul> <h3 id="stanza-flight">Stanza: <code class="language-plaintext highlighter-rouge">\*flight</code>
</h3> <h4 id="evaluation-of-blocks-is-always-deferred">Evaluation of Blocks is Always Deferred</h4> <p>The Ruby blocks defined by <code class="language-plaintext highlighter-rouge">preflight</code>, <code class="language-plaintext highlighter-rouge">postflight</code>, <code class="language-plaintext highlighter-rouge">uninstall_preflight</code>, and <code class="language-plaintext highlighter-rouge">uninstall_postflight</code> are not evaluated until install time or uninstall time. Within a block, you may refer to the <code class="language-plaintext highlighter-rouge">@cask</code> instance variable, and invoke any method available on <code class="language-plaintext highlighter-rouge">@cask</code>.</p> <h4 id="flight-mini-dsl">*flight Mini-DSL</h4> <p>There is a mini-DSL available within these blocks.</p> <p>The following methods may be called to perform standard tasks:</p> <table> <thead> <tr> <th>method</th> <th>availability</th> <th>description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">set_ownership(paths)</code></td> <td>
<code class="language-plaintext highlighter-rouge">preflight</code>, <code class="language-plaintext highlighter-rouge">postflight</code>, <code class="language-plaintext highlighter-rouge">uninstall_preflight</code>
</td> <td>set user and group ownership of <code class="language-plaintext highlighter-rouge">paths</code>. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/8a452a41707af6a661049da6254571090fac5418/Casks/unifi-controller.rb#L13"><code class="language-plaintext highlighter-rouge">unifi-controller.rb</code></a>
</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">set_permissions(paths, permissions_str)</code></td> <td>
<code class="language-plaintext highlighter-rouge">preflight</code>, <code class="language-plaintext highlighter-rouge">postflight</code>, <code class="language-plaintext highlighter-rouge">uninstall_preflight</code>
</td> <td>set permissions in <code class="language-plaintext highlighter-rouge">paths</code> to <code class="language-plaintext highlighter-rouge">permissions_str</code>. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/8a452a41707af6a661049da6254571090fac5418/Casks/docker-machine.rb#L16"><code class="language-plaintext highlighter-rouge">docker-machine.rb</code></a>
</td> </tr> </tbody> </table> <p><code class="language-plaintext highlighter-rouge">set_ownership(paths)</code> defaults user ownership to the current user and group ownership to <code class="language-plaintext highlighter-rouge">staff</code>. These can be changed by passing in extra options: <code class="language-plaintext highlighter-rouge">set_ownership(paths, user: 'user', group: 'group')</code>.</p> <h3 id="stanza-installer">Stanza: <code class="language-plaintext highlighter-rouge">installer</code>
</h3> <p>This stanza must always be accompanied by <a href="#stanza-uninstall"><code class="language-plaintext highlighter-rouge">uninstall</code></a>.</p> <p>The <code class="language-plaintext highlighter-rouge">installer</code> stanza takes a series of key-value pairs, the first key of which must be <code class="language-plaintext highlighter-rouge">manual:</code> or <code class="language-plaintext highlighter-rouge">script:</code>.</p> <h4 id="installer-manual">installer manual</h4> <p><code class="language-plaintext highlighter-rouge">installer manual:</code> takes a single string value, describing a GUI installer which must be run by the user at a later time. The path may be absolute, or relative to the Cask. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/249ec31048591308e63e50f79dae01d2f933cccf/Casks/nutstore.rb#L9">nutstore.rb</a>):</p> <pre data-language="ruby">installer manual: "Nutstore Installer.app"</pre> <h4 id="installer-script">installer script</h4> <p><code class="language-plaintext highlighter-rouge">installer script:</code> introduces a series of key-value pairs describing a command which will automate completion of the install. <strong>It should never be used for interactive installations.</strong> The form is similar to <code class="language-plaintext highlighter-rouge">uninstall script:</code>:</p> <table> <thead> <tr> <th>key</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">executable:</code></td> <td>path to an install script to be run</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">args:</code></td> <td>array of arguments to the install script</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">input:</code></td> <td>array of lines of input to be sent to <code class="language-plaintext highlighter-rouge">stdin</code> of the script</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">must_succeed:</code></td> <td>set to <code class="language-plaintext highlighter-rouge">false</code> if the script is allowed to fail</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">sudo:</code></td> <td>set to <code class="language-plaintext highlighter-rouge">true</code> if the script needs <code class="language-plaintext highlighter-rouge">sudo</code>
</td> </tr> </tbody> </table> <p>The path may be absolute, or relative to the Cask. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/ed2033fb3578376c3ee58a2cb459ef96fa6eb37d/Casks/miniforge.rb#L15L18">miniforge.rb</a>):</p> <pre data-language="ruby">installer script: {
    executable: "Miniforge3-#{version}-MacOSX-x86_64.sh",
    args:       ["-b", "-p", "#{caskroom_path}/base"],
  }</pre> <p>If the <code class="language-plaintext highlighter-rouge">installer script:</code> does not require any of the key-values it can point directly to the path of the install script:</p> <pre data-language="ruby">installer script: "#{staged_path}/install.sh"</pre> <h3 id="stanza-language">Stanza: <code class="language-plaintext highlighter-rouge">language</code>
</h3> <p>The <code class="language-plaintext highlighter-rouge">language</code> stanza can match <a href="https://en.wikipedia.org/wiki/ISO_639-1">ISO 639-1</a> language codes, regional identifiers (<a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2">ISO 3166-1 Alpha 2</a>) and script codes (<a href="https://en.wikipedia.org/wiki/ISO_15924">ISO 15924</a>), or a combination thereof.</p> <p>US English should always be used as the default language:</p> <pre data-language="ruby">language "zh", "CN" do
  "zh_CN"
end

language "de" do
  "de_DE"
end

language "en-GB" do
  "en_GB"
end

language "en", default: true do
  "en_US"
end</pre> <p>Note that the following are not the same:</p> <pre data-language="ruby">language "en", "GB" do
  # matches all locales containing "en" or "GB"
end

language "en-GB" do
  # matches only locales containing "en" and "GB"
end</pre> <p>The return value of the matching <code class="language-plaintext highlighter-rouge">language</code> block can be accessed by simply calling <code class="language-plaintext highlighter-rouge">language</code>.</p> <pre data-language="ruby">homepage "https://example.org/#{language}"</pre> <p>Examples: <a href="https://github.com/Homebrew/homebrew-cask/blob/306b8fbd9502036f1ca742f70c569d8677b62403/Casks/firefox.rb#L4L74">Firefox</a>, <a href="https://github.com/Homebrew/homebrew-cask/blob/306b8fbd9502036f1ca742f70c569d8677b62403/Casks/battle-net.rb#L5L17">Battle.net</a></p> <h4 id="installation">Installation</h4> <p>To install a cask in a specific language, you can pass the <code class="language-plaintext highlighter-rouge">--language=</code> option to <code class="language-plaintext highlighter-rouge">brew install</code>:</p> <pre data-language="plaintext">brew install firefox --language=it</pre> <h3 id="stanza-livecheck">Stanza: <code class="language-plaintext highlighter-rouge">livecheck</code>
</h3> <p>The <code class="language-plaintext highlighter-rouge">livecheck</code> stanza is used to automatically fetch the latest version of a cask from changelogs, release notes, appcasts, etc. See also: <a href="brew-livecheck.html"><code class="language-plaintext highlighter-rouge">brew livecheck</code> reference</a></p> <p>Every <code class="language-plaintext highlighter-rouge">livecheck</code> block must contain a <code class="language-plaintext highlighter-rouge">url</code>, which can either be a string or a symbol pointing to other URLs in the cask (<code class="language-plaintext highlighter-rouge">:url</code> or <code class="language-plaintext highlighter-rouge">:homepage</code>).</p> <p>Additionally, a <code class="language-plaintext highlighter-rouge">livecheck</code> should specify which <code class="language-plaintext highlighter-rouge">strategy</code> should be used to extract the version:</p> <table> <thead> <tr> <th><code class="language-plaintext highlighter-rouge">strategy</code></th> <th>Description</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">:header_match</code></td> <td>extract version from HTTP headers (e.g. <code class="language-plaintext highlighter-rouge">Location</code> or <code class="language-plaintext highlighter-rouge">Content-Disposition</code>)</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:page_match</code></td> <td>extract version from page contents</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">:sparkle</code></td> <td>extract version from Sparkle appcast contents</td> </tr> </tbody> </table> <p>Here is a basic example, extracting a simple version from a page:</p> <pre data-language="ruby">livecheck do
  url "https://example.org/my-app/download"
  strategy :page_match
  regex(%r{href=.*?/MyApp-(\d+(?:\.\d+)*)\.zip}i)
end</pre> <p>If the download URL is present on the homepage, we can use a symbol instead of a string:</p> <pre data-language="ruby">livecheck do
  url :homepage
  strategy :page_match
  regex(%r{href=.*?/MyApp-(\d+(?:\.\d+)*)\.zip}i)
end</pre> <p>The <code class="language-plaintext highlighter-rouge">header_match</code> strategy will try parsing a version from the filename (in the <code class="language-plaintext highlighter-rouge">Content-Disposition</code> header) and the final URL (in the <code class="language-plaintext highlighter-rouge">Location</code> header). If that doesn’t work, a <code class="language-plaintext highlighter-rouge">regex</code> can be specified, e.g.:</p> <pre data-language="ruby">strategy :header_match
regex(/MyApp-(\d+(?:\.\d+)*)\.zip/i)</pre> <p>If the version depends on multiple header fields, a block can be specified, e.g.</p> <pre data-language="ruby">strategy :header_match do |headers|
  v = headers["content-disposition"][/MyApp-(\d+(?:\.\d+)*)\.zip/i, 1]
  id = headers["location"][%r{/(\d+)/download$}i, 1]
  next if v.blank? || id.blank?

  "#{v},#{id}"
end</pre> <p>Similarly, the <code class="language-plaintext highlighter-rouge">:page_match</code> strategy can also be used for more complex versions by specifying a block:</p> <pre data-language="ruby">strategy :page_match do |page|
  match = page.match(%r{href=.*?/(\d+)/MyApp-(\d+(?:\.\d+)*)\.zip}i)
  next if match.blank?

  "#{match[2]},#{match[1]}"
end</pre> <h3 id="stanza-name">Stanza: <code class="language-plaintext highlighter-rouge">name</code>
</h3> <p><code class="language-plaintext highlighter-rouge">name</code> accepts a UTF-8 string defining the name of the software, including capitalization and punctuation. It is used to help with searchability and disambiguation.</p> <p>Unlike the <a href="#token-reference">token</a>, which is simplified and reduced to a limited set of characters, the <code class="language-plaintext highlighter-rouge">name</code> stanza can include the proper capitalization, spacing and punctuation to match the official name of the software. For disambiguation purposes, it is recommended to spell out the name of the application, and including the vendor name if necessary. A good example is <a href="https://github.com/Homebrew/homebrew-cask/blob/fc05c0353aebb28e40db72faba04b82ca832d11a/Casks/pycharm-ce.rb#L6-L7"><code class="language-plaintext highlighter-rouge">pycharm-ce</code></a>, whose name is spelled out as <code class="language-plaintext highlighter-rouge">Jetbrains PyCharm Community Edition</code>, even though it is likely never referenced as such anywhere.</p> <p>Additional details about the software can be provided in the <a href="#stanza-desc">desc</a> stanza.</p> <p>The <code class="language-plaintext highlighter-rouge">name</code> stanza can be repeated multiple times if there are useful alternative names. The first instance should use the Latin alphabet. For example, see the <a href="https://github.com/Homebrew/homebrew-cask/blob/0fe48607f5656e4f1de58c6884945378b7e6f960/Casks/cave-story.rb#L7-L9"><code class="language-plaintext highlighter-rouge">cave-story</code></a> cask, whose original name does not use the Latin alphabet.</p> <h3 id="stanza-pkg">Stanza: <code class="language-plaintext highlighter-rouge">pkg</code>
</h3> <p>This stanza must always be accompanied by <a href="#stanza-uninstall"><code class="language-plaintext highlighter-rouge">uninstall</code></a></p> <p>The first argument to the <code class="language-plaintext highlighter-rouge">pkg</code> stanza should be a relative path to the <code class="language-plaintext highlighter-rouge">.pkg</code> file to be installed. For example:</p> <pre data-language="ruby">pkg "Unity.pkg"</pre> <p>Subsequent arguments to <code class="language-plaintext highlighter-rouge">pkg</code> are key/value pairs which modify the install process. Currently supported keys are <code class="language-plaintext highlighter-rouge">allow_untrusted:</code> and <code class="language-plaintext highlighter-rouge">choices:</code>.</p> <h4 id="pkg-allow_untrusted"><code class="language-plaintext highlighter-rouge">pkg allow_untrusted:</code></h4> <p><code class="language-plaintext highlighter-rouge">pkg allow_untrusted: true</code> can be used to install the <code class="language-plaintext highlighter-rouge">.pkg</code> with an untrusted certificate passing <code class="language-plaintext highlighter-rouge">-allowUntrusted</code> to <code class="language-plaintext highlighter-rouge">/usr/sbin/installer</code>.</p> <p>This option is not permitted in official Homebrew Cask taps, it is only provided for use in third-party taps or local Casks.</p> <p>Example (<a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/alinof-timer.rb#L10">alinof-timer.rb</a>):</p> <pre data-language="ruby">pkg "AlinofTimer.pkg", allow_untrusted: true</pre> <h4 id="pkg-choices"><code class="language-plaintext highlighter-rouge">pkg choices:</code></h4> <p><code class="language-plaintext highlighter-rouge">pkg choices:</code> can be used to override <code class="language-plaintext highlighter-rouge">.pkg</code>’s default install options via <code class="language-plaintext highlighter-rouge">-applyChoiceChangesXML</code>. It uses a deserialized version of the <code class="language-plaintext highlighter-rouge">choiceChanges</code> property list (refer to the <code class="language-plaintext highlighter-rouge">CHOICE CHANGES FILE</code> section of the <code class="language-plaintext highlighter-rouge">installer</code> manual page by running <code class="language-plaintext highlighter-rouge">man -P 'less --pattern "^CHOICE CHANGES FILE"' installer</code>).</p> <p>Running the macOS command:</p> <pre data-language="bash">installer -showChoicesXML -pkg '/path/to/my.pkg'</pre> <p>will output an XML which you can use to extract the <code class="language-plaintext highlighter-rouge">choices:</code> values, as well as their equivalents to the GUI options.</p> <p>See <a href="https://github.com/Homebrew/homebrew-cask/pull/26997">this pull request for wireshark-chmodbpf</a> and <a href="https://github.com/Homebrew/homebrew-cask/pull/27937">this one for wine-staging</a> for some examples of the procedure.</p> <p>Example (<a href="https://github.com/Homebrew/homebrew-cask/blob/f95b8a8306b91fe9da7908b842f4a5fa80f7afe0/Casks/wireshark-chmodbpf.rb#L9-L26">wireshark-chmodbpf.rb</a>):</p> <pre data-language="ruby">pkg "Wireshark #{version} Intel 64.pkg",
    choices: [
               {
                 "choiceIdentifier" =&gt; "wireshark",
                 "choiceAttribute"  =&gt; "selected",
                 "attributeSetting" =&gt; 0,
               },
               {
                 "choiceIdentifier" =&gt; "chmodbpf",
                 "choiceAttribute"  =&gt; "selected",
                 "attributeSetting" =&gt; 1,
               },
               {
                 "choiceIdentifier" =&gt; "cli",
                 "choiceAttribute"  =&gt; "selected",
                 "attributeSetting" =&gt; 0,
               },
             ]</pre> <p>Example (<a href="https://github.com/Homebrew/homebrew-cask/blob/51b65f6a5a25a7f79af4d372e1a0bf1dc3849251/Casks/wine-staging.rb#L11-L18">wine-staging.rb</a>):</p> <pre data-language="ruby">pkg "winehq-staging-#{version}.pkg",
    choices: [
               {
                 "choiceIdentifier" =&gt; "choice3",
                 "choiceAttribute"  =&gt; "selected",
                 "attributeSetting" =&gt; 1,
               },
             ]</pre> <h3 id="stanza-sha256">Stanza: <code class="language-plaintext highlighter-rouge">sha256</code>
</h3> <h4 id="calculating-the-sha256">Calculating the SHA256</h4> <p>The <code class="language-plaintext highlighter-rouge">sha256</code> value is usually calculated by the command:</p> <pre data-language="bash">shasum --algorithm 256 &lt;file&gt;</pre> <h4 id="special-value-no_check">Special Value <code class="language-plaintext highlighter-rouge">:no_check</code>
</h4> <p>The special value <code class="language-plaintext highlighter-rouge">sha256 :no_check</code> is used to turn off SHA checking whenever checksumming is impractical due to the upstream configuration.</p> <p><code class="language-plaintext highlighter-rouge">version :latest</code> requires <code class="language-plaintext highlighter-rouge">sha256 :no_check</code>, and this pairing is common. However, <code class="language-plaintext highlighter-rouge">sha256 :no_check</code> does not require <code class="language-plaintext highlighter-rouge">version :latest</code>.</p> <p>We use a checksum whenever possible.</p> <h3 id="stanza-suite">Stanza: <code class="language-plaintext highlighter-rouge">suite</code>
</h3> <p>Some distributions provide a suite of multiple applications, or an application with required data, to be installed together in a subdirectory of <code class="language-plaintext highlighter-rouge">/Applications</code>.</p> <p>For these Casks, use the <code class="language-plaintext highlighter-rouge">suite</code> stanza to define the directory containing the application suite. Example (from <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/sketchup.rb#L12">sketchup.rb</a>):</p> <pre data-language="ruby">suite "SketchUp 2016"</pre> <p>The value of <code class="language-plaintext highlighter-rouge">suite</code> is never an <code class="language-plaintext highlighter-rouge">.app</code> bundle, but a plain directory.</p> <h3 id="stanza-uninstall">Stanza: <code class="language-plaintext highlighter-rouge">uninstall</code>
</h3> <blockquote> <p>If you cannot design a working <code class="language-plaintext highlighter-rouge">uninstall</code> stanza, please submit your cask anyway. The maintainers can help you write an <code class="language-plaintext highlighter-rouge">uninstall</code> stanza, just ask!</p> </blockquote> <h4 id="uninstall-pkgutil-is-the-easiest-and-most-useful">
<code class="language-plaintext highlighter-rouge">uninstall pkgutil:</code> Is The Easiest and Most Useful</h4> <p><code class="language-plaintext highlighter-rouge">pkgutil:</code> is the easiest and most useful <code class="language-plaintext highlighter-rouge">uninstall</code> directive. See <a href="#uninstall-key-pkgutil">Uninstall Key pkgutil:</a>.</p> <h4 id="uninstall-is-required-for-casks-that-install-a-pkg-or-installer-manual">
<code class="language-plaintext highlighter-rouge">uninstall</code> Is Required for Casks That Install a pkg or installer manual</h4> <p>For most Casks, uninstall actions are determined automatically, and an explicit <code class="language-plaintext highlighter-rouge">uninstall</code> stanza is not needed. However, a Cask which uses the <code class="language-plaintext highlighter-rouge">pkg</code> or <code class="language-plaintext highlighter-rouge">installer manual:</code> stanzas will <strong>not</strong> know how to uninstall correctly unless an <code class="language-plaintext highlighter-rouge">uninstall</code> stanza is given.</p> <p>So, while the <a href="#required-stanzas">Cask DSL</a> does not enforce the requirement, it is much better for end-users if every <code class="language-plaintext highlighter-rouge">pkg</code> and <code class="language-plaintext highlighter-rouge">installer manual:</code> has a corresponding <code class="language-plaintext highlighter-rouge">uninstall</code>.</p> <p>The <code class="language-plaintext highlighter-rouge">uninstall</code> stanza is available for non-<code class="language-plaintext highlighter-rouge">pkg</code> Casks, and is useful for a few corner cases. However, the documentation below concerns the typical case of using <code class="language-plaintext highlighter-rouge">uninstall</code> to define procedures for a <code class="language-plaintext highlighter-rouge">pkg</code>.</p> <h4 id="there-are-multiple-uninstall-techniques">There Are Multiple Uninstall Techniques</h4> <p>Since <code class="language-plaintext highlighter-rouge">pkg</code> installers can do arbitrary things, different techniques are needed to uninstall in each case. You may need to specify one, or several, of the following key/value pairs as arguments to <code class="language-plaintext highlighter-rouge">uninstall</code>.</p> <h4 id="summary-of-keys">Summary of Keys</h4> <ul> <li>
<code class="language-plaintext highlighter-rouge">early_script:</code> (string or hash) - like <a href="#uninstall-key-script"><code class="language-plaintext highlighter-rouge">script:</code></a>, but runs early (for special cases, best avoided)</li> <li>
<a href="#uninstall-key-launchctl"><code class="language-plaintext highlighter-rouge">launchctl:</code></a> (string or array) - ids of <code class="language-plaintext highlighter-rouge">launchctl</code> jobs to remove</li> <li>
<a href="#uninstall-key-quit"><code class="language-plaintext highlighter-rouge">quit:</code></a> (string or array) - bundle ids of running applications to quit</li> <li>
<a href="#uninstall-key-signal"><code class="language-plaintext highlighter-rouge">signal:</code></a> (array of arrays) - signal numbers and bundle ids of running applications to send a Unix signal to (used when <code class="language-plaintext highlighter-rouge">quit:</code> does not work)</li> <li>
<a href="#uninstall-key-login_item"><code class="language-plaintext highlighter-rouge">login_item:</code></a> (string or array) - names of login items to remove</li> <li>
<a href="#uninstall-key-kext"><code class="language-plaintext highlighter-rouge">kext:</code></a> (string or array) - bundle ids of kexts to unload from the system</li> <li>
<a href="#uninstall-key-script"><code class="language-plaintext highlighter-rouge">script:</code></a> (string or hash) - relative path to an uninstall script to be run via sudo; use hash if args are needed <ul> <li>
<code class="language-plaintext highlighter-rouge">executable:</code> - relative path to an uninstall script to be run via sudo (required for hash form)</li> <li>
<code class="language-plaintext highlighter-rouge">args:</code> - array of arguments to the uninstall script</li> <li>
<code class="language-plaintext highlighter-rouge">input:</code> - array of lines of input to be sent to <code class="language-plaintext highlighter-rouge">stdin</code> of the script</li> <li>
<code class="language-plaintext highlighter-rouge">must_succeed:</code> - set to <code class="language-plaintext highlighter-rouge">false</code> if the script is allowed to fail</li> <li>
<code class="language-plaintext highlighter-rouge">sudo:</code> - set to <code class="language-plaintext highlighter-rouge">true</code> if the script needs <code class="language-plaintext highlighter-rouge">sudo</code>
</li> </ul> </li> <li>
<a href="#uninstall-key-pkgutil"><code class="language-plaintext highlighter-rouge">pkgutil:</code></a> (string, regexp or array of strings and regexps) - strings or regexps matching bundle ids of packages to uninstall using <code class="language-plaintext highlighter-rouge">pkgutil</code>
</li> <li>
<a href="#uninstall-key-delete"><code class="language-plaintext highlighter-rouge">delete:</code></a> (string or array) - single-quoted, absolute paths of files or directory trees to remove. <code class="language-plaintext highlighter-rouge">delete:</code> should only be used as a last resort. <code class="language-plaintext highlighter-rouge">pkgutil:</code> is strongly preferred.</li> <li>
<code class="language-plaintext highlighter-rouge">rmdir:</code> (string or array) - single-quoted, absolute paths of directories to remove if empty. Works recursively.</li> <li>
<a href="#uninstall-key-trash"><code class="language-plaintext highlighter-rouge">trash:</code></a> (string or array) - single-quoted, absolute paths of files or directory trees to move to Trash.</li> </ul> <p>Each <code class="language-plaintext highlighter-rouge">uninstall</code> technique is applied according to the order above. The order in which <code class="language-plaintext highlighter-rouge">uninstall</code> keys appear in the Cask file is ignored.</p> <p>For assistance filling in the right values for <code class="language-plaintext highlighter-rouge">uninstall</code> keys, there are several helper scripts found under <code class="language-plaintext highlighter-rouge">developer/bin</code> in the Homebrew Cask repository. Each of these scripts responds to the <code class="language-plaintext highlighter-rouge">-help</code> option with additional documentation.</p> <p>The easiest way to work out an <code class="language-plaintext highlighter-rouge">uninstall</code> stanza is on a system where the <code class="language-plaintext highlighter-rouge">pkg</code> is currently installed and operational. To operate on an uninstalled <code class="language-plaintext highlighter-rouge">pkg</code> file, see <a href="#working-with-a-pkg-file-manually">Working With a pkg File Manually</a>, below.</p> <h4 id="uninstall-key-pkgutil">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">pkgutil:</code>
</h4> <p>This is the most useful uninstall key. <code class="language-plaintext highlighter-rouge">pkgutil:</code> is often sufficient to completely uninstall a <code class="language-plaintext highlighter-rouge">pkg</code>, and is strongly preferred over <code class="language-plaintext highlighter-rouge">delete:</code>.</p> <p>IDs for the most recently-installed packages can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_recent_pkg_ids"</pre> <p><code class="language-plaintext highlighter-rouge">pkgutil:</code> also accepts a regular expression match against multiple package IDs. The regular expressions are somewhat nonstandard. To test a <code class="language-plaintext highlighter-rouge">pkgutil:</code> regular expression against currently-installed packages, use the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_pkg_ids_by_regexp" &lt;regular-expression&gt;</pre> <h4 id="list-files-associated-with-a-pkg-id">List Files Associated With a pkg Id</h4> <p>Once you know the ID for an installed package, (above), you can list all files on your system associated with that package ID using the macOS command:</p> <pre data-language="bash">pkgutil --files &lt;package.id.goes.here&gt;</pre> <p>Listing the associated files can help you assess whether the package included any <code class="language-plaintext highlighter-rouge">launchctl</code> jobs or kernel extensions (kexts).</p> <h4 id="uninstall-key-launchctl">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">launchctl:</code>
</h4> <p>IDs for currently loaded <code class="language-plaintext highlighter-rouge">launchctl</code> jobs can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_loaded_launchjob_ids"</pre> <p>IDs for all installed <code class="language-plaintext highlighter-rouge">launchctl</code> jobs can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_installed_launchjob_ids"</pre> <h4 id="uninstall-key-quit">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">quit:</code>
</h4> <p>Bundle IDs for currently running Applications can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_running_app_ids"</pre> <p>Bundle IDs inside an Application bundle on disk can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_ids_in_app" '/path/to/application.app'</pre> <h4 id="uninstall-key-signal">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">signal:</code>
</h4> <p><code class="language-plaintext highlighter-rouge">signal:</code> should only be needed in the rare case that a process does not respond to <code class="language-plaintext highlighter-rouge">quit:</code>.</p> <p>Bundle IDs for <code class="language-plaintext highlighter-rouge">signal:</code> targets may be obtained as for <code class="language-plaintext highlighter-rouge">quit:</code>. The value for <code class="language-plaintext highlighter-rouge">signal:</code> is an array-of-arrays, with each cell containing two elements: the desired Unix signal followed by the corresponding bundle ID.</p> <p>The Unix signal may be given in numeric or string form (see the <code class="language-plaintext highlighter-rouge">kill</code> man page for more details).</p> <p>The elements of the <code class="language-plaintext highlighter-rouge">signal:</code> array are applied in order, only if there is an existing process associated the bundle ID, and stopping when that process terminates. A bundle ID may be repeated to send more than one signal to the same process.</p> <p>It is better to use the least-severe signals which are sufficient to stop a process. The <code class="language-plaintext highlighter-rouge">KILL</code> signal in particular can have unwanted side-effects.</p> <p>An example, with commonly-used signals in ascending order of severity:</p> <pre data-language="ruby">uninstall signal: [
                      ["TERM", "fr.madrau.switchresx.daemon"],
                      ["QUIT", "fr.madrau.switchresx.daemon"],
                      ["INT",  "fr.madrau.switchresx.daemon"],
                      ["HUP",  "fr.madrau.switchresx.daemon"],
                      ["KILL", "fr.madrau.switchresx.daemon"],
                    ]</pre> <p>Note that when multiple running processes match the given Bundle ID, all matching processes will be signaled.</p> <p>Unlike <code class="language-plaintext highlighter-rouge">quit:</code> directives, Unix signals originate from the current user, not from the superuser. This is construed as a safety feature, since the superuser is capable of bringing down the system via signals. However, this inconsistency may also be considered a bug, and should be addressed in some fashion in a future version.</p> <h2 id="uninstall-key-login_item">
<code class="language-plaintext highlighter-rouge">uninstall</code> key <code class="language-plaintext highlighter-rouge">login_item:</code>
</h2> <p>Login items associated with an Application bundle on disk can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_login_items_for_app" '/path/to/application.app'</pre> <p>Note that you will likely need to have opened the app at least once for any login items to be present.</p> <h4 id="uninstall-key-kext">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">kext:</code>
</h4> <p>IDs for currently loaded kernel extensions can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_loaded_kext_ids"</pre> <p>IDs inside a kext bundle you have located on disk can be listed using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_id_in_kext" '/path/to/name.kext'</pre> <h4 id="uninstall-key-script">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">script:</code>
</h4> <p><code class="language-plaintext highlighter-rouge">uninstall script:</code> introduces a series of key-value pairs describing a command which will automate completion of the uninstall. Example (from <a href="#">gpgtools.rb</a>):</p> <pre data-language="ruby">uninstall script:    {
                         executable: "#{staged_path}/Uninstall.app/Contents/Resources/GPG Suite Uninstaller.app/Contents/Resources/uninstall.sh",
                         sudo:       true,
                       }</pre> <p>It is important to note that, although <code class="language-plaintext highlighter-rouge">script:</code> in the above example does attempt to completely uninstall the <code class="language-plaintext highlighter-rouge">pkg</code>, it should not be used in detriment of <a href="#uninstall-key-pkgutil"><code class="language-plaintext highlighter-rouge">pkgutil:</code></a>, but as a complement when possible.</p> <h4 id="uninstall-key-delete">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">delete:</code>
</h4> <p><code class="language-plaintext highlighter-rouge">delete:</code> should only be used as a last resort, if other <code class="language-plaintext highlighter-rouge">uninstall</code> methods are insufficient.</p> <p>Arguments to <code class="language-plaintext highlighter-rouge">uninstall delete:</code> should use the following basic rules:</p> <ul> <li>Basic tilde expansion is performed on paths, i.e. leading <code class="language-plaintext highlighter-rouge">~</code> is expanded to the home directory.</li> <li>Paths must be absolute.</li> <li>Glob expansion is performed using the <a href="https://en.wikipedia.org/wiki/Glob_(programming)">standard set of characters</a>.</li> </ul> <p>To remove user-specific files, use the <a href="#stanza-zap"><code class="language-plaintext highlighter-rouge">zap</code> stanza</a>.</p> <h4 id="uninstall-key-trash">
<code class="language-plaintext highlighter-rouge">uninstall</code> Key <code class="language-plaintext highlighter-rouge">trash:</code>
</h4> <p><code class="language-plaintext highlighter-rouge">trash:</code> arguments follow the same rules listed above for <code class="language-plaintext highlighter-rouge">delete:</code>.</p> <h4 id="working-with-a-pkg-file-manually">Working With a pkg File Manually</h4> <p>Advanced users may wish to work with a <code class="language-plaintext highlighter-rouge">pkg</code> file manually, without having the package installed.</p> <p>A list of files which may be installed from a <code class="language-plaintext highlighter-rouge">pkg</code> can be extracted using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_payload_in_pkg" '/path/to/my.pkg'</pre> <p>Candidate application names helpful for determining the name of a Cask may be extracted from a <code class="language-plaintext highlighter-rouge">pkg</code> file using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_apps_in_pkg" '/path/to/my.pkg'</pre> <p>Candidate package IDs which may be useful in a <code class="language-plaintext highlighter-rouge">pkgutil:</code> key may be extracted from a <code class="language-plaintext highlighter-rouge">pkg</code> file using the command:</p> <pre data-language="bash">"$(brew --repository homebrew/cask)/developer/bin/list_ids_in_pkg" '/path/to/my.pkg'</pre> <p>A fully manual method for finding bundle ids in a package file follows:</p> <ol> <li>Unpack <code class="language-plaintext highlighter-rouge">/path/to/my.pkg</code> (replace with your package name) with <code class="language-plaintext highlighter-rouge">pkgutil --expand /path/to/my.pkg /tmp/expanded.unpkg</code>.</li> <li>The unpacked package is a folder. Bundle ids are contained within files named <code class="language-plaintext highlighter-rouge">PackageInfo</code>. These files can be found with the command <code class="language-plaintext highlighter-rouge">find /tmp/expanded.unpkg -name PackageInfo</code>.</li> <li>
<code class="language-plaintext highlighter-rouge">PackageInfo</code> files are XML files, and bundle ids are found within the <code class="language-plaintext highlighter-rouge">identifier</code> attributes of <code class="language-plaintext highlighter-rouge">&lt;pkg-info&gt;</code> tags that look like <code class="language-plaintext highlighter-rouge">&lt;pkg-info ... identifier="com.oracle.jdk7u51" ... &gt;</code>, where extraneous attributes have been snipped out and replaced with ellipses.</li> <li>Kexts inside packages are also described in <code class="language-plaintext highlighter-rouge">PackageInfo</code> files. If any kernel extensions are present, the command <code class="language-plaintext highlighter-rouge">find /tmp/expanded.unpkg -name PackageInfo -print0 | xargs -0 grep -i kext</code> should return a <code class="language-plaintext highlighter-rouge">&lt;bundle id&gt;</code> tag with a <code class="language-plaintext highlighter-rouge">path</code> attribute that contains a <code class="language-plaintext highlighter-rouge">.kext</code> extension, for example <code class="language-plaintext highlighter-rouge">&lt;bundle id="com.wavtap.driver.WavTap" ... path="./WavTap.kext" ... /&gt;</code>.</li> <li>Once bundle ids have been identified, the unpacked package directory can be deleted.</li> </ol> <h3 id="stanza-url">Stanza: <code class="language-plaintext highlighter-rouge">url</code>
</h3> <h4 id="https-urls-are-preferred">HTTPS URLs are Preferred</h4> <p>If available, an HTTPS URL is preferred. A plain HTTP URL should only be used in the absence of a secure alternative.</p> <h4 id="additional-https-url-parameters">Additional HTTP/S URL Parameters</h4> <p>When a plain URL string is insufficient to fetch a file, additional information may be provided to the <code class="language-plaintext highlighter-rouge">curl</code>-based downloader, in the form of key/value pairs appended to <code class="language-plaintext highlighter-rouge">url</code>:</p> <table> <thead> <tr> <th>key</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">verified:</code></td> <td>a string repeating the beginning of <code class="language-plaintext highlighter-rouge">url</code>, for verification purposes. <a href="#when-url-and-homepage-domains-differ-add-verified">See below</a>.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">using:</code></td> <td>the symbol <code class="language-plaintext highlighter-rouge">:post</code> is the only legal value</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">cookies:</code></td> <td>a hash of cookies to be set in the download request</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">referer:</code></td> <td>a string holding the URL to set as referer in the download request</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">header:</code></td> <td>a string holding the header to set for the download request.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">user_agent:</code></td> <td>a string holding the user agent to set for the download request. Can also be set to the symbol <code class="language-plaintext highlighter-rouge">:fake</code>, which will use a generic Browser-like user agent string. We prefer <code class="language-plaintext highlighter-rouge">:fake</code> when the server does not require a specific user agent.</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">data:</code></td> <td>a hash of parameters to be set in the POST request</td> </tr> </tbody> </table> <p>Example of using <code class="language-plaintext highlighter-rouge">cookies:</code>: <a href="https://github.com/Homebrew/homebrew-cask/blob/472930df191d66747a57d5c96c0d00511d56e21b/Casks/java.rb#L5-L8">java.rb</a></p> <p>Example of using <code class="language-plaintext highlighter-rouge">referer:</code>: <a href="https://github.com/Homebrew/homebrew-cask/blob/312ae841f1f1b2ec07f4d88b7dfdd7fbdf8d4f94/Casks/rrootage.rb#L5">rrootage.rb</a></p> <p>Example of using <code class="language-plaintext highlighter-rouge">header:</code>: <a href="https://github.com/Homebrew/brew/pull/6545#issue-325182724">issue-325182724</a></p> <h4 id="when-url-and-homepage-domains-differ-add-verified">When URL and Homepage Domains Differ, Add <code class="language-plaintext highlighter-rouge">verified:</code>
</h4> <p>When the domains of <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">homepage</code> differ, the discrepancy should be documented with the <code class="language-plaintext highlighter-rouge">verified:</code> parameter, repeating the smallest possible portion of the URL that uniquely identifies the app or vendor, excluding the protocol. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/08733296b49c59c58b6beeada59ed4207cef60c3/Casks/shotcut.rb#L5L6"><code class="language-plaintext highlighter-rouge">shotcut.rb</code></a>.</p> <p>This must be added so a user auditing the cask knows the URL was verified by the Homebrew Cask team as the one provided by the vendor, even though it may look unofficial. It is our responsibility as Homebrew Cask maintainers to verify both the <code class="language-plaintext highlighter-rouge">url</code> and <code class="language-plaintext highlighter-rouge">homepage</code> information when first added (or subsequently modified, apart from versioning).</p> <p>The parameter doesn’t mean you should trust the source blindly, but we only approve casks in which users can easily verify its authenticity with basic means, such as checking the official homepage or public repository. Occasionally, slightly more elaborate techniques may be used, such as inspecting an <a href="#stanza-appcast"><code class="language-plaintext highlighter-rouge">appcast</code></a> we established as official. Cases where such quick verifications aren’t possible (e.g. when the download URL is behind a registration wall) are <a href="acceptable-casks.html#unofficial-vendorless-and-walled-builds">treated in a stricter manner</a>.</p> <h4 id="difficulty-finding-a-url">Difficulty Finding a URL</h4> <p>Web browsers may obscure the direct <code class="language-plaintext highlighter-rouge">url</code> download location for a variety of reasons. Homebrew Cask supplies a script which can read extended file attributes to extract the actual source URL for most files downloaded by a browser on macOS. The script usually emits multiple candidate URLs; you may have to test each of them:</p> <pre data-language="bash">$(brew --repository homebrew/cask)/developer/bin/list_url_attributes_on_file &lt;file&gt;</pre> <h4 id="subversion-urls">Subversion URLs</h4> <p>In rare cases, a distribution may not be available over ordinary HTTP/S. Subversion URLs are also supported, and can be specified by appending the following key/value pairs to <code class="language-plaintext highlighter-rouge">url</code>:</p> <table> <thead> <tr> <th>key</th> <th>value</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">using:</code></td> <td>the symbol <code class="language-plaintext highlighter-rouge">:svn</code> is the only legal value</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">revision:</code></td> <td>a string identifying the subversion revision to download</td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">trust_cert:</code></td> <td>set to <code class="language-plaintext highlighter-rouge">true</code> to automatically trust the certificate presented by the server (avoiding an interactive prompt)</td> </tr> </tbody> </table> <h4 id="sourceforgeosdn-urls">SourceForge/OSDN URLs</h4> <p>SourceForge and OSDN (formerly <code class="language-plaintext highlighter-rouge">SourceForge.JP</code>) projects are common ways to distribute binaries, but they provide many different styles of URLs to get to the goods.</p> <p>We prefer URLs of this format:</p> <pre data-language="plaintext">https://downloads.sourceforge.net/&lt;project_name&gt;/&lt;filename&gt;.&lt;ext&gt;</pre> <p>Or, if it’s from <a href="https://osdn.jp/">OSDN</a>:</p> <pre data-language="plaintext">http://&lt;subdomain&gt;.osdn.jp/&lt;project_name&gt;/&lt;release_id&gt;/&lt;filename&gt;.&lt;ext&gt;</pre> <p><code class="language-plaintext highlighter-rouge">&lt;subdomain&gt;</code> is typically of the form <code class="language-plaintext highlighter-rouge">dl</code> or <code class="language-plaintext highlighter-rouge">&lt;user&gt;.dl</code>.</p> <p>If these formats are not available, and the application is macOS-exclusive (otherwise a command-line download defaults to the Windows version) we prefer the use of this format:</p> <pre data-language="plaintext">https://sourceforge.net/projects/&lt;project_name&gt;/files/latest/download</pre> <h4 id="some-providers-block-command-line-downloads">Some Providers Block Command-line Downloads</h4> <p>Some hosting providers actively block command-line HTTP clients. Such URLs cannot be used in Casks.</p> <p>Other providers may use URLs that change periodically, or even on each visit (example: FossHub). While some cases <a href="#using-a-block-to-defer-code-execution">could be circumvented</a>, they tend to occur when the vendor is actively trying to prevent automated downloads, so we prefer to not add those casks to the main repository.</p> <h4 id="using-a-block-to-defer-code-execution">Using a Block to Defer Code Execution</h4> <p>Some casks—notably nightlies—have versioned download URLs but are updated so often that they become impractical to keep current with the usual process. For those, we want to dynamically determine <code class="language-plaintext highlighter-rouge">url</code>.</p> <h5 id="the-problem">The Problem</h5> <p>In theory, one can write arbitrary Ruby code right in the Cask definition to fetch and construct a disposable URL.</p> <p>However, this typically involves an HTTP round trip to a landing site, which may take a long time. Because of the way Homebrew Cask loads and parses Casks, it is not acceptable that such expensive operations be performed directly in the body of a Cask definition.</p> <h5 id="writing-the-block">Writing the Block</h5> <p>Similar to the <code class="language-plaintext highlighter-rouge">preflight</code>, <code class="language-plaintext highlighter-rouge">postflight</code>, <code class="language-plaintext highlighter-rouge">uninstall_preflight</code>, and <code class="language-plaintext highlighter-rouge">uninstall_postflight</code> blocks, the <code class="language-plaintext highlighter-rouge">url</code> stanza offers an optional <em>block syntax</em>:</p> <pre data-language="rb">url "https://handbrake.fr/nightly.php" do |page|
  file_path = page[/href=["']?([^"' &gt;]*Handbrake[._-][^"' &gt;]+\.dmg)["' &gt;]/i, 1]
  file_path ? URI.join(page.url, file_path) : nil
end</pre> <p>You can also nest <code class="language-plaintext highlighter-rouge">url do</code> blocks inside <code class="language-plaintext highlighter-rouge">url do</code> blocks to follow a chain of URLs.</p> <p>The block is only evaluated when needed, for example on download time or when auditing a Cask. Inside a block, you may safely do things such as HTTP/S requests that may take a long time to execute. You may also refer to the <code class="language-plaintext highlighter-rouge">@cask</code> instance variable, and invoke any method available on <code class="language-plaintext highlighter-rouge">@cask</code>.</p> <p>The block will be called immediately before downloading; its result value will be assumed to be a <code class="language-plaintext highlighter-rouge">String</code> (or a pair of a <code class="language-plaintext highlighter-rouge">String</code> and <code class="language-plaintext highlighter-rouge">Hash</code> containing parameters) and subsequently used as a download URL.</p> <p>You can use the <code class="language-plaintext highlighter-rouge">url</code> stanza with either a direct argument or a block but not with both.</p> <p>Example for using the block syntax: <a href="https://github.com/Homebrew/homebrew-cask-versions/blob/2bf0f13dd49d263ebec0ca56e58ad8458633f789/Casks/vlc-nightly.rb#L5L10">vlc-nightly.rb</a></p> <h5 id="mixing-additional-url-parameters-with-the-block-syntax">Mixing Additional URL Parameters With the Block Syntax</h5> <p>In rare cases, you might need to set URL parameters like <code class="language-plaintext highlighter-rouge">cookies</code> or <code class="language-plaintext highlighter-rouge">referer</code> while also using the block syntax.</p> <p>This is possible by returning a two-element array as a block result. The first element of the array must be the download URL; the second element must be a <code class="language-plaintext highlighter-rouge">Hash</code> containing the parameters.</p> <h3 id="stanza-version">Stanza: <code class="language-plaintext highlighter-rouge">version</code>
</h3> <p><code class="language-plaintext highlighter-rouge">version</code>, while related to the app’s own versioning, doesn’t have to follow it exactly. It is common to change it slightly so it can be <a href="https://en.wikipedia.org/wiki/String_interpolation#Ruby_/_Crystal">interpolated</a> in other stanzas, usually in <code class="language-plaintext highlighter-rouge">url</code> to create a Cask that only needs <code class="language-plaintext highlighter-rouge">version</code> and <code class="language-plaintext highlighter-rouge">sha256</code> changes when updated. This can be taken further, when needed, with <a href="https://ruby-doc.org/core/String.html">ruby String methods</a>.</p> <p>For example:</p> <p>Instead of</p> <pre data-language="ruby">version "1.2.3"
url "https://example.com/file-version-123.dmg"</pre> <p>We can use</p> <pre data-language="ruby">version "1.2.3"
url "https://example.com/file-version-#{version.delete('.')}.dmg"</pre> <p>We can also leverage the power of regular expressions. So instead of</p> <pre data-language="ruby">version "1.2.3build4"
url "https://example.com/1.2.3/file-version-1.2.3build4.dmg"</pre> <p>We can use</p> <pre data-language="ruby">version "1.2.3build4"
url "https://example.com/#{version.sub(%r{build\d+}, '')}/file-version-#{version}.dmg"</pre> <h4 id="version-latest">version :latest</h4> <p>The special value <code class="language-plaintext highlighter-rouge">:latest</code> is used on casks which:</p> <ol> <li>
<code class="language-plaintext highlighter-rouge">url</code> doesn’t contain a version.</li> <li>Having a correct value to <code class="language-plaintext highlighter-rouge">version</code> is too difficult or impractical, even with our automated systems.</li> </ol> <p>Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/f56e8ba057687690e26a6502623aa9476ff4ac0e/Casks/spotify.rb#L2">spotify.rb</a></p> <h4 id="version-methods">version methods</h4> <p>The examples above can become hard to read, however. Since many of these changes are common, we provide a number of helpers to clearly interpret otherwise obtuse cases:</p> <table> <thead> <tr> <th>Method</th> <th>Input</th> <th>Output</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">major</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">1</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">minor</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">patch</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">3-a45</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">major_minor</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">1.2</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">major_minor_patch</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">minor_patch</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">2.3-a45</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">before_comma</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">after_comma</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">ccdd88</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">dots_to_hyphens</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">1-2-3-a45,ccdd88</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">no_dots</code></td> <td><code class="language-plaintext highlighter-rouge">1.2.3-a45,ccdd88</code></td> <td><code class="language-plaintext highlighter-rouge">123-a45,ccdd88</code></td> </tr> </tbody> </table> <p>Similar to <code class="language-plaintext highlighter-rouge">dots_to_hyphens</code>, we provide all logical permutations of <code class="language-plaintext highlighter-rouge">{dots,hyphens,underscores}_to_{dots,hyphens,underscores}</code>. The same applies to <code class="language-plaintext highlighter-rouge">no_dots</code> in the form of <code class="language-plaintext highlighter-rouge">no_{dots,hyphens,underscores}</code>, with an extra <code class="language-plaintext highlighter-rouge">no_dividers</code> that applies all of those at once.</p> <p>Finally, there is <code class="language-plaintext highlighter-rouge">csv</code> that returns an array of comma-separated values. <code class="language-plaintext highlighter-rouge">csv</code>, <code class="language-plaintext highlighter-rouge">before_comma</code> and <code class="language-plaintext highlighter-rouge">after_comma</code> are extra special to allow for otherwise complex cases, and should be used sparingly. There should be no more than two of <code class="language-plaintext highlighter-rouge">,</code> per <code class="language-plaintext highlighter-rouge">version</code>.</p> <h3 id="stanza-zap">Stanza: <code class="language-plaintext highlighter-rouge">zap</code>
</h3> <h4 id="zap-stanza-purpose">
<code class="language-plaintext highlighter-rouge">zap</code> Stanza Purpose</h4> <p>The <code class="language-plaintext highlighter-rouge">zap</code> stanza describes a more complete uninstallation of files associated with a Cask. The <code class="language-plaintext highlighter-rouge">zap</code> procedures will never be performed by default, but only if the user uses <code class="language-plaintext highlighter-rouge">--zap</code> on <code class="language-plaintext highlighter-rouge">uninstall</code>:</p> <pre data-language="bash">brew uninstall --zap firefox</pre> <p><code class="language-plaintext highlighter-rouge">zap</code> stanzas may remove:</p> <ul> <li>Preference files and caches stored within the user’s <code class="language-plaintext highlighter-rouge">~/Library</code> directory.</li> <li>Shared resources such as application updaters. Since shared resources may be removed, other applications may be affected by <code class="language-plaintext highlighter-rouge">brew uninstall --zap</code>. Understanding that is the responsibility of the end user.</li> </ul> <p><code class="language-plaintext highlighter-rouge">zap</code> stanzas should not remove:</p> <ul> <li>Files created by the user directly.</li> </ul> <p>Appending <code class="language-plaintext highlighter-rouge">--force</code> to the command will allow you to perform these actions even if the Cask is no longer installed:</p> <pre data-language="bash">brew uninstall --zap --force firefox</pre> <h4 id="zap-stanza-syntax">
<code class="language-plaintext highlighter-rouge">zap</code> Stanza Syntax</h4> <p>The form of <code class="language-plaintext highlighter-rouge">zap</code> stanza follows the <a href="#stanza-uninstall"><code class="language-plaintext highlighter-rouge">uninstall</code> stanza</a>. All of the same directives are available. The <code class="language-plaintext highlighter-rouge">trash:</code> key is preferred over <code class="language-plaintext highlighter-rouge">delete:</code>.</p> <p>Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/31cd96cc0e00dab1bff74d622e32d816bafd1f6f/Casks/dropbox.rb#L17-L35">dropbox.rb</a></p> <h4 id="zap-creation">
<code class="language-plaintext highlighter-rouge">zap</code> Creation</h4> <p>The simplest method is to use <a href="https://github.com/nrlquaker/homebrew-createzap">@nrlquaker’s CreateZap</a>, which can automatically generate the stanza. In a few instances it may fail to pick up anything and manual creation may be required.</p> <p>Manual creation can be facilitated with:</p> <ul> <li>Some of the developer tools are already available in Homebrew Cask.</li> <li><code class="language-plaintext highlighter-rouge">sudo find / -iname "*&lt;search item&gt;*"</code></li> <li>An uninstaller tool such as <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/appcleaner.rb">AppCleaner</a>.</li> <li>Inspecting the usual suspects, i.e. <code class="language-plaintext highlighter-rouge">/Library/{'Application Support',LaunchAgents,LaunchDaemons,Frameworks,Logs,Preferences,PrivilegedHelperTools}</code> and <code class="language-plaintext highlighter-rouge">~/Library/{'Application Support',Caches,Containers,LaunchAgents,Logs,Preferences,'Saved Application State'}</code>.</li> </ul> <hr> <h2 id="token-reference">Token reference</h2> <p>This section describes the algorithm implemented in the <code class="language-plaintext highlighter-rouge">generate_cask_token</code> script, and covers detailed rules and exceptions which are not needed in most cases.</p> <ul> <li><a href="#purpose">Purpose</a></li> <li><a href="#finding-the-simplified-name-of-the-vendors-distribution">Finding the Simplified Name of the Vendor’s Distribution</a></li> <li><a href="#converting-the-simplified-name-to-a-token">Converting the Simplified Name To a Token</a></li> <li><a href="#cask-filenames">Cask Filenames</a></li> <li><a href="#cask-headers">Cask Headers</a></li> <li><a href="#cask-token-examples">Cask Token Examples</a></li> <li><a href="#tap-specific-cask-token-examples">Tap Specific Cask Token Examples</a></li> <li><a href="#token-overlap">Token Overlap</a></li> </ul> <h2 id="purpose">Purpose</h2> <p>Software vendors are often inconsistent with their naming. By enforcing strict naming conventions we aim to:</p> <ul> <li>Prevent duplicate submissions</li> <li>Minimize renaming events</li> <li>Unambiguously boil down the name of the software into a unique identifier</li> </ul> <p>Details of software names and brands will inevitably be lost in the conversion to a minimal token. To capture the vendor’s full name for a distribution, use the <a href="#stanza-name"><code class="language-plaintext highlighter-rouge">name</code></a> within a Cask. <code class="language-plaintext highlighter-rouge">name</code> accepts an unrestricted UTF-8 string.</p> <h2 id="finding-the-simplified-name-of-the-vendors-distribution">Finding the Simplified Name of the Vendor’s Distribution</h2> <h3 id="simplified-names-of-apps">Simplified Names of Apps</h3> <ul> <li> <p>Start with the exact name of the Application bundle as it appears on disk, such as <code class="language-plaintext highlighter-rouge">Google Chrome.app</code>.</p> </li> <li> <p>If the name uses letters outside A-Z, convert it to ASCII as described in <a href="#converting-to-ascii">Converting to ASCII</a>.</p> </li> <li> <p>Remove <code class="language-plaintext highlighter-rouge">.app</code> from the end.</p> </li> <li> <p>Remove from the end: the string “app”, if the vendor styles the name like “Software App.app”. Exception: when “app” is an inseparable part of the name, without which the name would be inherently nonsensical, as in <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/whatsapp.rb">whatsapp.rb</a>.</p> </li> <li> <p>Remove from the end: version numbers or incremental release designations such as “alpha”, “beta”, or “release candidate”. Strings which distinguish different capabilities or codebases such as “Community Edition” are currently accepted. Exception: when a number is not an incremental release counter, but a differentiator for a different product from a different vendor, as in <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/kdiff3.rb">kdiff3.rb</a>.</p> </li> <li> <p>If the version number is arranged to occur in the middle of the App name, it should also be removed.</p> </li> <li> <p>Remove from the end: “Launcher”, “Quick Launcher”.</p> </li> <li> <p>Remove from the end: strings such as “Desktop”, “for Desktop”.</p> </li> <li> <p>Remove from the end: strings such as “Mac”, “for Mac”, “for OS X”, “macOS”, “for macOS”. These terms are generally added to ported software such as “MAME OS X.app”. Exception: when the software is not a port, and “Mac” is an inseparable part of the name, without which the name would be inherently nonsensical, as in <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/playonmac.rb">PlayOnMac.app</a>.</p> </li> <li> <p>Remove from the end: hardware designations such as “for x86”, “32-bit”, “ppc”.</p> </li> <li> <p>Remove from the end: software framework names such as “Cocoa”, “Qt”, “Gtk”, “Wx”, “Java”, “Oracle JVM”, etc. Exception: the framework is the product being Casked.</p> </li> <li> <p>Remove from the end: localization strings such as “en-US”.</p> </li> <li> <p>If the result of that process is a generic term, such as “Macintosh Installer”, try prepending the name of the vendor or developer, followed by a hyphen. If that doesn’t work, then just create the best name you can, based on the vendor’s web page.</p> </li> <li> <p>If the result conflicts with the name of an existing Cask, make yours unique by prepending the name of the vendor or developer, followed by a hyphen. Example: <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/unison.rb">unison.rb</a> and <a href="https://github.com/Homebrew/homebrew-cask/blob/HEAD/Casks/panic-unison.rb">panic-unison.rb</a>.</p> </li> <li> <p>Inevitably, there are a small number of exceptions not covered by the rules. Don’t hesitate to <a href="https://github.com/orgs/Homebrew/discussions">use the forum</a> if you have a problem.</p> </li> </ul> <h3 id="converting-to-ascii">Converting to ASCII</h3> <ul> <li> <p>If the vendor provides an English localization string, that is preferred. Here are the places it may be found, in order of preference:</p> <ul> <li>
<code class="language-plaintext highlighter-rouge">CFBundleDisplayName</code> in the main <code class="language-plaintext highlighter-rouge">Info.plist</code> file of the app bundle</li> <li>
<code class="language-plaintext highlighter-rouge">CFBundleName</code> in the main <code class="language-plaintext highlighter-rouge">Info.plist</code> file of the app bundle</li> <li>
<code class="language-plaintext highlighter-rouge">CFBundleDisplayName</code> in <code class="language-plaintext highlighter-rouge">InfoPlist.strings</code> of an <code class="language-plaintext highlighter-rouge">en.lproj</code> localization directory</li> <li>
<code class="language-plaintext highlighter-rouge">CFBundleName</code> in <code class="language-plaintext highlighter-rouge">InfoPlist.strings</code> of an <code class="language-plaintext highlighter-rouge">en.lproj</code> localization directory</li> <li>
<code class="language-plaintext highlighter-rouge">CFBundleDisplayName</code> in <code class="language-plaintext highlighter-rouge">InfoPlist.strings</code> of an <code class="language-plaintext highlighter-rouge">English.lproj</code> localization directory</li> <li>
<code class="language-plaintext highlighter-rouge">CFBundleName</code> in <code class="language-plaintext highlighter-rouge">InfoPlist.strings</code> of an <code class="language-plaintext highlighter-rouge">English.lproj</code> localization directory</li> </ul> </li> <li> <p>When there is no vendor localization string, romanize the name by transliteration or decomposition.</p> </li> <li> <p>As a last resort, translate the name of the app bundle into English.</p> </li> </ul> <h3 id="simplified-names-of-pkg-based-installers">Simplified Names of <code class="language-plaintext highlighter-rouge">pkg</code>-based Installers</h3> <ul> <li>The Simplified Name of a <code class="language-plaintext highlighter-rouge">pkg</code> may be more tricky to determine than that of an App. If a <code class="language-plaintext highlighter-rouge">pkg</code> installs an App, then use that App name with the rules above. If not, just create the best name you can, based on the vendor’s web page.</li> </ul> <h3 id="simplified-names-of-non-app-software">Simplified Names of non-App Software</h3> <ul> <li> <p>Currently, rules for generating a token are not well-defined for Preference Panes, QuickLook plugins, and several other types of software installable by Homebrew Cask. Just create the best name you can, based on the filename on disk or the vendor’s web page. Watch out for duplicates.</p> <p>Non-app tokens should become more standardized in the future.</p> </li> </ul> <h2 id="converting-the-simplified-name-to-a-token">Converting the Simplified Name To a Token</h2> <p>The token is the primary identifier for a package in our project. It’s the unique string users refer to when operating on the Cask.</p> <p>To convert the App’s Simplified Name (above) to a token:</p> <ul> <li>Convert all letters to lower case.</li> <li>Expand the <code class="language-plaintext highlighter-rouge">+</code> symbol into a separated English word: <code class="language-plaintext highlighter-rouge">-plus-</code>.</li> <li>Expand the <code class="language-plaintext highlighter-rouge">@</code> symbol into a separated English word: <code class="language-plaintext highlighter-rouge">-at-</code>.</li> <li>Spaces become hyphens.</li> <li>Underscores become hyphens.</li> <li>Middots/Interpuncts become hyphens.</li> <li>Hyphens stay hyphens.</li> <li>Digits stay digits.</li> <li>Delete any character which is not alphanumeric or a hyphen.</li> <li>Collapse a series of multiple hyphens into one hyphen.</li> <li>Delete a leading or trailing hyphen.</li> </ul> <h2 id="cask-filenames">Cask Filenames</h2> <p>Casks are stored in a Ruby file named after the token, with the file extension <code class="language-plaintext highlighter-rouge">.rb</code>.</p> <h2 id="cask-headers">Cask Headers</h2> <p>The token is also given in the header line for each Cask.</p> <h2 id="cask-token-examples">Cask Token Examples</h2> <p>These illustrate most of the rules for generating a token:</p> <table> <thead> <tr> <th>App Name on Disk</th> <th>Simplified App Name</th> <th>Cask Token</th> <th>Filename</th> </tr> </thead> <tbody> <tr> <td><code class="language-plaintext highlighter-rouge">Audio Hijack Pro.app</code></td> <td>Audio Hijack Pro</td> <td>audio-hijack-pro</td> <td><code class="language-plaintext highlighter-rouge">audio-hijack-pro.rb</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">VLC.app</code></td> <td>VLC</td> <td>vlc</td> <td><code class="language-plaintext highlighter-rouge">vlc.rb</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">BetterTouchTool.app</code></td> <td>BetterTouchTool</td> <td>bettertouchtool</td> <td><code class="language-plaintext highlighter-rouge">bettertouchtool.rb</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">LPK25 Editor.app</code></td> <td>LPK25 Editor</td> <td>lpk25-editor</td> <td><code class="language-plaintext highlighter-rouge">lpk25-editor.rb</code></td> </tr> <tr> <td><code class="language-plaintext highlighter-rouge">Sublime Text 2.app</code></td> <td>Sublime Text</td> <td>sublime-text</td> <td><code class="language-plaintext highlighter-rouge">sublime-text.rb</code></td> </tr> </tbody> </table> <h2 id="tap-specific-cask-token-examples">Tap Specific Cask Token Examples</h2> <p>Cask taps have naming conventions specific to each tap.</p> <p><a href="https://github.com/Homebrew/homebrew-cask-versions/blob/HEAD/CONTRIBUTING.md#naming-versions-casks">Homebrew/cask-versions</a></p> <p><a href="https://github.com/Homebrew/homebrew-cask-fonts/blob/HEAD/CONTRIBUTING.md#naming-font-casks">Homebrew/cask-fonts</a></p> <p><a href="https://github.com/Homebrew/homebrew-cask-drivers/blob/HEAD/CONTRIBUTING.md#naming-driver-casks">Homebrew/cask-drivers</a></p> <h1 id="special-affixes">Special Affixes</h1> <p>A few situations require a prefix or suffix to be added to the token.</p> <h2 id="token-overlap">Token Overlap</h2> <p>When the token for a new Cask would otherwise conflict with the token of an already existing Cask, the nature of that overlap dictates the token (for possibly both Casks). See <a href="acceptable-casks.html#forks-and-apps-with-conflicting-names">Forks and Apps with Conflicting Names</a> for information on how to proceed.</p> <h2 id="potentially-misleading-name">Potentially Misleading Name</h2> <p>If the token for a piece of unofficial software that interacts with a popular service would make it look official and the vendor is not authorised to use the name, <a href="acceptable-casks.html#forks-and-apps-with-conflicting-names">a prefix must be added</a> for disambiguation.</p> <p>In cases where the prefix is ambiguous and would make the app appear official, the <code class="language-plaintext highlighter-rouge">-unofficial</code> suffix may be used.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;present Homebrew contributors<br>Licensed under the BSD 2-Clause License.<br>
    <a href="https://docs.brew.sh/Cask-Cookbook" class="_attribution-link">https://docs.brew.sh/Cask-Cookbook</a>
  </p>
</div>
