<h1 class="type-name"> class Regex </h1> <ul class="superclass-hierarchy">
<li class="superclass"><a href="regex.html">Regex</a></li>
<li class="superclass"><a href="reference.html">Reference</a></li>
<li class="superclass"><a href="object.html">Object</a></li>
</ul> <h2>  Overview </h2> <p>A <code><a href="regex.html">Regex</a></code> represents a regular expression, a pattern that describes the contents of strings. A <code><a href="regex.html">Regex</a></code> can determine whether or not a string matches its description, and extract the parts of the string that match.</p> <p>A <code><a href="regex.html">Regex</a></code> can be created using the literal syntax, in which it is delimited by forward slashes (<code>/</code>):</p> <pre data-language="crystal">/hay/ =~ "haystack"   # =&gt; 0
/y/.match("haystack") # =&gt; Regex::MatchData("y")</pre> <p>See <a href="https://crystal-lang.org/reference/syntax_and_semantics/literals/regex.html"><code>Regex</code> literals</a> in the language reference.</p> <p>Interpolation works in regular expression literals just as it does in string literals. Be aware that using this feature will cause an exception to be raised at runtime, if the resulting string would not be a valid regular expression.</p> <pre data-language="crystal">x = "a"
/#{x}/.match("asdf") # =&gt; Regex::MatchData("a")
x = "("
/#{x}/ # raises ArgumentError</pre> <p>When we check to see if a particular regular expression describes a string, we can say that we are performing a match or matching one against the other. If we find that a regular expression does describe a string, we say that it matches, and we can refer to a part of the string that was described as a match.</p> <p>Here <code>"haystack"</code> does not contain the pattern <code>/needle/</code>, so it doesn't match:</p> <pre data-language="crystal">/needle/.match("haystack") # =&gt; nil</pre> <p>Here <code>"haystack"</code> contains the pattern <code>/hay/</code>, so it matches:</p> <pre data-language="crystal">/hay/.match("haystack") # =&gt; Regex::MatchData("hay")</pre> <p>Regex methods that perform a match usually return a truthy value if there was a match and <code>nil</code> if there was no match. After performing a match, the special variable <code>$~</code> will be an instance of <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if it matched, <code>nil</code> otherwise.</p> <p>When matching a regular expression using <code><a href="regex.html#%3D~%28other%3AString%29%3AInt32%7CNil-instance-method">#=~</a></code> (either <code><a href="string.html#%3D~%28regex%3ARegex%2C%2A%2Coptions%3ARegex%3A%3AMatchOptions%3DRegex%3A%3AMatchOptions%3A%3ANone%29%3AInt32%7CNil-instance-method">String#=~</a></code> or <code><a href="regex.html#%3D~%28other%3AString%29%3AInt32%7CNil-instance-method">Regex#=~</a></code>), the returned value will be the index of the first match in the string if the expression matched, <code>nil</code> otherwise.</p> <pre data-language="crystal">/stack/ =~ "haystack"  # =&gt; 3
"haystack" =~ /stack/  # =&gt; 3
$~                     # =&gt; Regex::MatchData("stack")
/needle/ =~ "haystack" # =&gt; nil
"haystack" =~ /needle/ # =&gt; nil
$~                     # raises Exception</pre> <p>When matching a regular expression using <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match</a></code> (either <code><a href="string.html#match%28regex%3ARegex%2Cpos%3D0%2C%2A%2Coptions%3ARegex%3A%3AMatchOptions%3DRegex%3A%3AMatchOptions%3A%3ANone%29%3ARegex%3A%3AMatchData%7CNil-instance-method">String#match</a></code> or <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">Regex#match</a></code>), the returned value will be a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if the expression matched, <code>nil</code> otherwise.</p> <pre data-language="crystal">/hay/.match("haystack")    # =&gt; Regex::MatchData("hay")
"haystack".match(/hay/)    # =&gt; Regex::MatchData("hay")
$~                         # =&gt; Regex::MatchData("hay")
/needle/.match("haystack") # =&gt; nil
"haystack".match(/needle/) # =&gt; nil
$~                         # raises Exception</pre> <p><a href="https://en.wikipedia.org/wiki/Regular_expression">Regular expressions</a> have their own language for describing strings.</p> <p>Many programming languages and tools implement their own regular expression language, but Crystal uses <a href="http://www.pcre.org/">PCRE2</a>, a popular C library, with <a href="http://www.pcre.org/current/doc/html/pcre2jit.html">JIT compilation</a> enabled for providing regular expressions. Here give a brief summary of the most basic features of regular expressions - grouping, repetition, and alternation - but the feature set of PCRE2 extends far beyond these, and we don't attempt to describe it in full here. For more information, refer to the PCRE2 documentation, especially the <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html">full pattern syntax</a> or <a href="http://www.pcre.org/current/doc/html/pcre2syntax.html">syntax quick reference</a>.</p> <p>NOTE Prior to Crystal 1.8 the compiler expected regex literals to follow the original <a href="https://www.pcre.org/original/doc/html/pcrepattern.html">PCRE pattern syntax</a>. The following summary applies to both PCRE and PCRE2.</p> <p>The regular expression language can be used to match much more than just the static substrings in the above examples. Certain characters, called <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC4">metacharacters</a>, are given special treatment in regular expressions, and can be used to describe more complex patterns. To match metacharacters literally in a regular expression, they must be escaped by being preceded with a backslash (<code>\</code>). <code><a href="regex.html#escape%28str%29%3AString-class-method">.escape</a></code> will do this automatically for a given String.</p> <p>A group of characters (often called a capture group or <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC14">subpattern</a>) can be identified by enclosing it in parentheses (<code>()</code>). The contents of each capture group can be extracted on a successful match:</p> <pre data-language="crystal">/a(sd)f/.match("_asdf_")                     # =&gt; Regex::MatchData("asdf" 1:"sd")
/a(sd)f/.match("_asdf_").try &amp;.[1]           # =&gt; "sd"
/a(?&lt;grp&gt;sd)f/.match("_asdf_")               # =&gt; Regex::MatchData("asdf" grp:"sd")
/a(?&lt;grp&gt;sd)f/.match("_asdf_").try &amp;.["grp"] # =&gt; "sd"</pre> <p>Capture groups are indexed starting from 1. Methods that accept a capture group index will usually also accept 0 to refer to the full match. Capture groups can also be given names, using the <code>(?&amp;lt;name&amp;gt;...)</code> syntax, as in the previous example.</p> <p>Following a match, the special variables $N (e.g., $1, $2, $3, ...) can be used to access a capture group. Trying to access an invalid capture group will raise an exception. Note that it is possible to have a successful match with a nil capture:</p> <pre data-language="crystal">/(spice)(s)?/.match("spice") # =&gt; Regex::MatchData("spice" 1:"spice" 2:nil)
$1                           # =&gt; "spice"
$2                           # =&gt; raises Exception</pre> <p>This can be mitigated by using the nilable version of the above: $N?, (e.g., $1? $2?, $3?, ...). Changing the above to use <code>$2?</code> instead of <code>$2</code> would return <code>nil</code>. <code>$2?.nil?</code> would return <code>true</code>.</p> <p>A character or group can be <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC17">repeated</a> or made optional using an asterisk (<code>*</code> - zero or more), a plus sign (<code><a href="regex.html#%2B%28other%29%3ARegex-instance-method">#+</a></code> - one or more), integer bounds in curly braces (<code>{n,m}</code>) (at least <code>n</code>, no more than <code>m</code>), or a question mark (<code>?</code>) (zero or one).</p> <pre data-language="crystal">/fo*/.match("_f_")         # =&gt; Regex::MatchData("f")
/fo+/.match("_f_")         # =&gt; nil
/fo*/.match("_foo_")       # =&gt; Regex::MatchData("foo")
/fo{3,}/.match("_foo_")    # =&gt; nil
/fo{1,3}/.match("_foo_")   # =&gt; Regex::MatchData("foo")
/fo*/.match("_foo_")       # =&gt; Regex::MatchData("foo")
/fo*/.match("_foooooooo_") # =&gt; Regex::MatchData("foooooooo")
/fo{,3}/.match("_foooo_")  # =&gt; nil
/f(op)*/.match("fopopo")   # =&gt; Regex::MatchData("fopop" 1:"op")
/foo?bar/.match("foobar")  # =&gt; Regex::MatchData("foobar")
/foo?bar/.match("fobar")   # =&gt; Regex::MatchData("fobar")</pre> <p>Alternatives can be separated using a <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC12">vertical bar</a> (<code>|</code>). Any single character can be represented by <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC7">dot</a> (<code>.</code>). When matching only one character, specific alternatives can be expressed as a <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC9">character class</a>, enclosed in square brackets (<code>[]</code>):</p> <pre data-language="crystal">/foo|bar/.match("foo")     # =&gt; Regex::MatchData("foo")
/foo|bar/.match("bar")     # =&gt; Regex::MatchData("bar")
/_(x|y)_/.match("_x_")     # =&gt; Regex::MatchData("_x_" 1:"x")
/_(x|y)_/.match("_y_")     # =&gt; Regex::MatchData("_y_" 1:"y")
/_(x|y)_/.match("_(x|y)_") # =&gt; nil
/_(x|y)_/.match("_(x|y)_") # =&gt; nil
/_._/.match("_x_")         # =&gt; Regex::MatchData("_x_")
/_[xyz]_/.match("_x_")     # =&gt; Regex::MatchData("_x_")
/_[a-z]_/.match("_x_")     # =&gt; Regex::MatchData("_x_")
/_[^a-z]_/.match("_x_")    # =&gt; nil
/_[^a-wy-z]_/.match("_x_") # =&gt; Regex::MatchData("_x_")</pre> <p>Regular expressions can be defined with these 3 <a href="http://www.pcre.org/current/doc/html/pcre2pattern.html#SEC13">optional flags</a>:</p> <ul> <li>
<code>i</code>: ignore case (<code><a href="regex/options.html#IGNORE_CASE">Regex::Options::IGNORE_CASE</a></code>)</li> <li>
<code>m</code>: multiline (<code><a href="regex/options.html#MULTILINE">Regex::Options::MULTILINE</a></code>)</li> <li>
<code>x</code>: extended (<code><a href="regex/options.html#EXTENDED">Regex::Options::EXTENDED</a></code>)</li> </ul> <pre data-language="crystal">/asdf/ =~ "ASDF"    # =&gt; nil
/asdf/i =~ "ASDF"   # =&gt; 0
/^z/i =~ "ASDF\nZ"  # =&gt; nil
/^z/im =~ "ASDF\nZ" # =&gt; 5</pre> <p>PCRE2 supports other encodings, but Crystal strings are UTF-8 only, so Crystal regular expressions are also UTF-8 only (by default). Crystal strings are expected to contain only valid UTF-8 encodings, but that's not guaranteed. There's a chance that a string <em>can</em> contain invalid bytes. Especially data read from external sources must not be trusted to be valid encoding. The regex engine demands valid UTF-8, so it checks the encoding for every match. This can be unnecessary if the string is already validated (for example via <code><a href="string.html#valid_encoding%3F%3ABool-instance-method">String#valid_encoding?</a></code> or because it has already been used in a previous regex match). If that's the case, it's profitable to skip UTF-8 validation via <code><a href="regex/matchoptions.html#NO_UTF_CHECK">MatchOptions::NO_UTF_CHECK</a></code> (or <code><a href="regex/options.html#NO_UTF_CHECK">CompileOptions::NO_UTF_CHECK</a></code> for the pattern).</p> <p>PCRE2 optionally permits named capture groups (named subpatterns) to not be unique. Crystal exposes the name table of a <code><a href="regex.html">Regex</a></code> as a <code><a href="hash.html">Hash</a></code> of <code><a href="string.html">String</a></code> =&gt; <code><a href="int32.html">Int32</a></code>, and therefore requires named capture groups to have unique names within a single <code><a href="regex.html">Regex</a></code>.</p> <h2>  Included Modules </h2> <ul class="other-types-list"> <li class="other-type">Regex::PCRE2</li> </ul> <h2>  Defined in: </h2> <a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/json/any.cr#L357" target="_blank"> json/any.cr </a> <br> <a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L211" target="_blank"> regex.cr </a> <br> <a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex/match_data.cr#L1" target="_blank"> regex/match_data.cr </a> <br> <a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/yaml/any.cr#L398" target="_blank"> yaml/any.cr </a> <br> <h2>  Constant Summary </h2> <dl> <dt class="entry-const" id="SPECIAL_CHARACTERS"> <strong>SPECIAL_CHARACTERS</strong> = <code>{' ', '.', '\\', '+', '*', '?', '[', '^', ']', '$', '(', ')', '{', '}', '=', '!', '&lt;', '&gt;', '|', ':', '-'}</code> </dt> <dd class="entry-const-doc"> <p>List of metacharacters that need to be escaped.</p> <p>See <code><a href="regex.html#needs_escape%3F%28char%3AChar%29%3ABool-class-method">Regex.needs_escape?</a></code> and <code><a href="regex.html#escape%28str%29%3AString-class-method">Regex.escape</a></code>.</p> </dd> </dl> <h2>  Constructors </h2> <ul class="list-summary"> <li class="entry-summary"> <a href="#literal%28pattern%3AString%2C%2A%2Ci%3ABool%3Dfalse%2Cm%3ABool%3Dfalse%2Cx%3ABool%3Dfalse%29%3Aself-class-method" class="signature"><strong>.literal</strong>(pattern : String, *, i : Bool = false, m : Bool = false, x : Bool = false) : self</a> <div class="summary"><p>Creates a new <code><a href="regex.html">Regex</a></code> instance from a literal consisting of a <em>pattern</em> and the named parameter modifiers.</p></div> </li> <li class="entry-summary"> <a href="#new%28source%3AString%2Coptions%3AOptions%3DOptions%3A%3ANone%29-class-method" class="signature"><strong>.new</strong>(source : String, options : Options = Options::None)</a> <div class="summary"><p>Creates a new <code><a href="regex.html">Regex</a></code> out of the given source <code><a href="string.html">String</a></code>.</p></div> </li> <li class="entry-summary"> <a href="#union%28patterns%3AEnumerable%28Regex%7CString%29%29%3Aself-class-method" class="signature"><strong>.union</strong>(patterns : Enumerable(Regex | String)) : self</a> <div class="summary"><p>Union.</p></div> </li> <li class="entry-summary"> <a href="#union%28%2Apatterns%3ARegex%7CString%29%3Aself-class-method" class="signature"><strong>.union</strong>(*patterns : Regex | String) : self</a> <div class="summary"><p>Union.</p></div> </li> </ul> <h2>  Class Method Summary </h2> <ul class="list-summary"> <li class="entry-summary"> <a href="#error%3F%28source%29%3AString%7CNil-class-method" class="signature"><strong>.error?</strong>(source) : String | Nil</a> <div class="summary"><p>Determines Regex's source validity.</p></div> </li> <li class="entry-summary"> <a href="#escape%28str%29%3AString-class-method" class="signature"><strong>.escape</strong>(str) : String</a> <div class="summary"><p>Returns a <code><a href="string.html">String</a></code> constructed by escaping any metacharacters in <em>str</em>.</p></div> </li> <li class="entry-summary"> <a href="#needs_escape%3F%28char%3AChar%29%3ABool-class-method" class="signature"><strong>.needs_escape?</strong>(char : Char) : Bool</a> <div class="summary"><p>Returns <code>true</code> if <em>char</em> need to be escaped, <code>false</code> otherwise.</p></div> </li> <li class="entry-summary"> <a href="#needs_escape%3F%28str%3AString%29%3ABool-class-method" class="signature"><strong>.needs_escape?</strong>(str : String) : Bool</a> <div class="summary"><p>Returns <code>true</code> if <em>str</em> need to be escaped, <code>false</code> otherwise.</p></div> </li> <li class="entry-summary"> <a href="#supports_compile_options%3F%28options%3ACompileOptions%29%3ABool-class-method" class="signature"><strong>.supports_compile_options?</strong>(options : CompileOptions) : Bool</a> <div class="summary"><p>Returns <code>true</code> if the regex engine supports all <em>options</em> flags when compiling a pattern.</p></div> </li> <li class="entry-summary"> <a href="#supports_match_options%3F%28options%3AMatchOptions%29%3ABool-class-method" class="signature"><strong>.supports_match_options?</strong>(options : MatchOptions) : Bool</a> <div class="summary"><p>Returns <code>true</code> if the regex engine supports all <em>options</em> flags when matching a pattern.</p></div> </li> </ul> <h2>  Instance Method Summary </h2> <ul class="list-summary"> <li class="entry-summary"> <a href="#%2B%28other%29%3ARegex-instance-method" class="signature"><strong>#+</strong>(other) : Regex</a> <div class="summary"><p>Union.</p></div> </li> <li class="entry-summary"> <a href="#%3D%3D%28other%3ARegex%29-instance-method" class="signature"><strong>#==</strong>(other : Regex)</a> <div class="summary"><p>Equality.</p></div> </li> <li class="entry-summary"> <a href="#%3D%3D%3D%28other%3AString%29-instance-method" class="signature"><strong>#===</strong>(other : String)</a> <div class="summary"><p>Case equality.</p></div> </li> <li class="entry-summary"> <a href="#%3D%3D%3D%28other%3AJSON%3A%3AAny%29-instance-method" class="signature"><strong>#===</strong>(other : JSON::Any)</a> </li> <li class="entry-summary"> <a href="#%3D%3D%3D%28other%3AYAML%3A%3AAny%29-instance-method" class="signature"><strong>#===</strong>(other : YAML::Any)</a> </li> <li class="entry-summary"> <a href="#%3D~%28other%3AString%29%3AInt32%7CNil-instance-method" class="signature"><strong>#=~</strong>(other : String) : Int32 | Nil</a> <div class="summary"><p>Match.</p></div> </li> <li class="entry-summary"> <a href="#%3D~%28other%29%3ANil-instance-method" class="signature"><strong>#=~</strong>(other) : Nil</a> <div class="summary"><p>Match.</p></div> </li> <li class="entry-summary"> <a href="#capture_count%3AInt32-instance-method" class="signature"><strong>#capture_count</strong> : Int32</a> <div class="summary"><p>Returns the number of (named &amp; non-named) capture groups.</p></div> </li> <li class="entry-summary"> <a href="#clone-instance-method" class="signature"><strong>#clone</strong></a> </li> <li class="entry-summary"> <a href="#dup-instance-method" class="signature"><strong>#dup</strong></a> <div class="summary"><p>Returns a shallow copy of this object.</p></div> </li> <li class="entry-summary"> <a href="#hash%28hasher%29-instance-method" class="signature"><strong>#hash</strong>(hasher)</a> <div class="summary"><p>See <code><a href="object.html#hash%28hasher%29-instance-method">Object#hash(hasher)</a></code></p></div> </li> <li class="entry-summary"> <a href="#inspect%28io%3AIO%29%3ANil-instance-method" class="signature"><strong>#inspect</strong>(io : IO) : Nil</a> <div class="summary"><p>Prints to <em>io</em> an unambiguous string representation of this regular expression object.</p></div> </li> <li class="entry-summary"> <a href="#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match</strong>(str : String, pos : Int32 = 0, options : Regex::MatchOptions = :none) : MatchData | Nil</a> <div class="summary"><p>Match at character index.</p></div> </li> <li class="entry-summary"> <a href="#match%28str%2Cpos%2C_options%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match</strong>(str, pos, _options) : MatchData | Nil</a> <div class="summary">
<p>Match at character index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#match%28str%2Cpos%3D0%2C%2A%2Coptions%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match</strong>(str, pos = 0, *, options) : MatchData | Nil</a> <div class="summary">
<p>Match at character index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#match%21%28str%3AString%2Cpos%3AInt32%3D0%2C%2A%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData-instance-method" class="signature"><strong>#match!</strong>(str : String, pos : Int32 = 0, *, options : Regex::MatchOptions = :none) : MatchData</a> <div class="summary"><p>Matches a regular expression against <em>str</em>.</p></div> </li> <li class="entry-summary"> <a href="#match_at_byte_index%28str%3AString%2Cbyte_index%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match_at_byte_index</strong>(str : String, byte_index : Int32 = 0, options : Regex::MatchOptions = :none) : MatchData | Nil</a> <div class="summary"><p>Match at byte index.</p></div> </li> <li class="entry-summary"> <a href="#match_at_byte_index%28str%2Cbyte_index%2C_options%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match_at_byte_index</strong>(str, byte_index, _options) : MatchData | Nil</a> <div class="summary">
<p>Match at byte index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#match_at_byte_index%28str%2Cbyte_index%3D0%2C%2A%2Coptions%29%3AMatchData%7CNil-instance-method" class="signature"><strong>#match_at_byte_index</strong>(str, byte_index = 0, *, options) : MatchData | Nil</a> <div class="summary">
<p>Match at byte index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#matches%3F%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3ABool-instance-method" class="signature"><strong>#matches?</strong>(str : String, pos : Int32 = 0, options : Regex::MatchOptions = :none) : Bool</a> <div class="summary"><p>Match at character index.</p></div> </li> <li class="entry-summary"> <a href="#matches%3F%28str%2Cpos%2C_options%29%3ABool-instance-method" class="signature"><strong>#matches?</strong>(str, pos, _options) : Bool</a> <div class="summary">
<p>Match at character index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#matches%3F%28str%2Cpos%3D0%2C%2A%2Coptions%29%3ABool-instance-method" class="signature"><strong>#matches?</strong>(str, pos = 0, *, options) : Bool</a> <div class="summary">
<p>Match at character index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#matches_at_byte_index%3F%28str%3AString%2Cbyte_index%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3ABool-instance-method" class="signature"><strong>#matches_at_byte_index?</strong>(str : String, byte_index : Int32 = 0, options : Regex::MatchOptions = :none) : Bool</a> <div class="summary"><p>Match at byte index.</p></div> </li> <li class="entry-summary"> <a href="#matches_at_byte_index%3F%28str%2Cbyte_index%2C_options%29%3ABool-instance-method" class="signature"><strong>#matches_at_byte_index?</strong>(str, byte_index, _options) : Bool</a> <div class="summary">
<p>Match at byte index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#matches_at_byte_index%3F%28str%2Cbyte_index%3D0%2C%2A%2Coptions%29%3ABool-instance-method" class="signature"><strong>#matches_at_byte_index?</strong>(str, byte_index = 0, *, options) : Bool</a> <div class="summary">
<p>Match at byte index.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p>
</div> </li> <li class="entry-summary"> <a href="#name_table%3AHash%28Int32%2CString%29-instance-method" class="signature"><strong>#name_table</strong> : Hash(Int32, String)</a> <div class="summary"><p>Returns a <code><a href="hash.html">Hash</a></code> where the values are the names of capture groups and the keys are their indexes.</p></div> </li> <li class="entry-summary"> <a href="#options%3AOptions-instance-method" class="signature"><strong>#options</strong> : Options</a> <div class="summary"><p>Returns a <code><a href="regex/compileoptions.html">Regex::CompileOptions</a></code> representing the optional flags applied to this <code><a href="regex.html">Regex</a></code>.</p></div> </li> <li class="entry-summary"> <a href="#source%3AString-instance-method" class="signature"><strong>#source</strong> : String</a> <div class="summary"><p>Returns the original <code><a href="string.html">String</a></code> representation of the <code><a href="regex.html">Regex</a></code> pattern.</p></div> </li> <li class="entry-summary"> <a href="#to_s%28io%3AIO%29%3ANil-instance-method" class="signature"><strong>#to_s</strong>(io : IO) : Nil</a> <div class="summary"><p>Convert to <code><a href="string.html">String</a></code> in subpattern format.</p></div> </li> </ul> <div class="methods-inherited"> <h3>Instance methods inherited from module <code>Regex::PCRE2</code>
</h3> <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#finalize-instance-method" class="tooltip"> finalize finalize</a> <h3>Class methods inherited from module <code>Regex::PCRE2</code>
</h3> <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#jit_stack-class-method" class="tooltip"> jit_stack jit_stack</a>, <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#match_context%3APointer%28LibPCRE2%3A%3AMatchContext%29-class-method" class="tooltip"> match_context : Pointer(LibPCRE2::MatchContext) match_context</a>, <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#supports_compile_flag%3F%28options%29-class-method" class="tooltip"> supports_compile_flag?(options) supports_compile_flag?</a>, <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#supports_match_flag%3F%28options%29-class-method" class="tooltip"> supports_match_flag?(options) supports_match_flag?</a>, <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#version%3AString-class-method" class="tooltip"> version : String version</a>, <a href="https://crystal-lang.org/api/1.15.1/Regex/PCRE2.html#version_number%3ATuple%28Int32%2CInt32%29-class-method" class="tooltip"> version_number : Tuple(Int32, Int32) version_number</a> <h3>Instance methods inherited from class <code><a href="reference.html">Reference</a></code>
</h3> <a href="reference.html#%3D%3D%28other%3Aself%29-instance-method" class="tooltip"> ==(other : self)<br>==(other : JSON::Any)<br>==(other : YAML::Any)<br>==(other) ==</a>, <a href="reference.html#dup-instance-method" class="tooltip"> dup dup</a>, <a href="reference.html#hash%28hasher%29-instance-method" class="tooltip"> hash(hasher) hash</a>, <a href="reference.html#initialize-instance-method" class="tooltip"> initialize initialize</a>, <a href="reference.html#inspect%28io%3AIO%29%3ANil-instance-method" class="tooltip"> inspect(io : IO) : Nil inspect</a>, <a href="reference.html#object_id%3AUInt64-instance-method" class="tooltip"> object_id : UInt64 object_id</a>, <a href="reference.html#pretty_print%28pp%29%3ANil-instance-method" class="tooltip"> pretty_print(pp) : Nil pretty_print</a>, <a href="reference.html#same%3F%28other%3AReference%29%3ABool-instance-method" class="tooltip"> same?(other : Reference) : Bool<br>same?(other : Nil) same?</a>, <a href="reference.html#to_s%28io%3AIO%29%3ANil-instance-method" class="tooltip"> to_s(io : IO) : Nil to_s</a> <h3>Constructor methods inherited from class <code><a href="reference.html">Reference</a></code>
</h3> <a href="reference.html#new-class-method" class="tooltip"> new new</a>, <a href="reference.html#unsafe_construct%28address%3APointer%2C%2Aargs%2C%2A%2Aopts%29%3Aself-class-method" class="tooltip"> unsafe_construct(address : Pointer, *args, **opts) : self unsafe_construct</a> <h3>Class methods inherited from class <code><a href="reference.html">Reference</a></code>
</h3> <a href="reference.html#pre_initialize%28address%3APointer%29-class-method" class="tooltip"> pre_initialize(address : Pointer) pre_initialize</a> <h3>Instance methods inherited from class <code><a href="object.html">Object</a></code>
</h3> <a href="object.html#%21%3ABool-instance-method" class="tooltip"> ! : Bool !</a>, <a href="object.html#%21%3D%28other%29-instance-method" class="tooltip"> !=(other) !=</a>, <a href="object.html#%21~%28other%29-instance-method" class="tooltip"> !~(other) !~</a>, <a href="object.html#%3D%3D%28other%29-instance-method" class="tooltip"> ==(other) ==</a>, <a href="object.html#%3D%3D%3D%28other%3AJSON%3A%3AAny%29-instance-method" class="tooltip"> ===(other : JSON::Any)<br>===(other : YAML::Any)<br>===(other) ===</a>, <a href="object.html#%3D~%28other%29-instance-method" class="tooltip"> =~(other) =~</a>, <a href="object.html#as%28type%3AClass%29-instance-method" class="tooltip"> as(type : Class) as</a>, <a href="object.html#as%3F%28type%3AClass%29-instance-method" class="tooltip"> as?(type : Class) as?</a>, <a href="object.html#class-instance-method" class="tooltip"> class class</a>, <a href="object.html#dup-instance-method" class="tooltip"> dup dup</a>, <a href="object.html#hash%28hasher%29-instance-method" class="tooltip"> hash(hasher)<br>hash hash</a>, <a href="object.html#in%3F%28collection%3AObject%29%3ABool-instance-method" class="tooltip"> in?(collection : Object) : Bool<br>in?(*values : Object) : Bool in?</a>, <a href="object.html#inspect%28io%3AIO%29%3ANil-instance-method" class="tooltip"> inspect(io : IO) : Nil<br>inspect : String inspect</a>, <a href="object.html#is_a%3F%28type%3AClass%29%3ABool-instance-method" class="tooltip"> is_a?(type : Class) : Bool is_a?</a>, <a href="object.html#itself-instance-method" class="tooltip"> itself itself</a>, <a href="object.html#nil%3F%3ABool-instance-method" class="tooltip"> nil? : Bool nil?</a>, <a href="object.html#not_nil%21%28message%29-instance-method" class="tooltip"> not_nil!(message)<br>not_nil! not_nil!</a>, <a href="object.html#pretty_inspect%28width%3D79%2Cnewline%3D%22%5Cn%22%2Cindent%3D0%29%3AString-instance-method" class="tooltip"> pretty_inspect(width = 79, newline = "\n", indent = 0) : String pretty_inspect</a>, <a href="object.html#pretty_print%28pp%3APrettyPrint%29%3ANil-instance-method" class="tooltip"> pretty_print(pp : PrettyPrint) : Nil pretty_print</a>, <a href="object.html#responds_to%3F%28name%3ASymbol%29%3ABool-instance-method" class="tooltip"> responds_to?(name : Symbol) : Bool responds_to?</a>, <a href="object.html#tap%28%26%29-instance-method" class="tooltip"> tap(&amp;) tap</a>, <a href="object.html#to_json%28io%3AIO%29%3ANil-instance-method" class="tooltip"> to_json(io : IO) : Nil<br>to_json : String to_json</a>, <a href="object.html#to_pretty_json%28indent%3AString%3D%22%22%29%3AString-instance-method" class="tooltip"> to_pretty_json(indent : String = " ") : String<br>to_pretty_json(io : IO, indent : String = " ") : Nil to_pretty_json</a>, <a href="object.html#to_s%28io%3AIO%29%3ANil-instance-method" class="tooltip"> to_s(io : IO) : Nil<br>to_s : String to_s</a>, <a href="object.html#to_yaml%28io%3AIO%29%3ANil-instance-method" class="tooltip"> to_yaml(io : IO) : Nil<br>to_yaml : String to_yaml</a>, <a href="object.html#try%28%26%29-instance-method" class="tooltip"> try(&amp;) try</a>, <a href="object.html#unsafe_as%28type%3AT.class%29forallT-instance-method" class="tooltip"> unsafe_as(type : T.class) forall T unsafe_as</a> <h3>Class methods inherited from class <code><a href="object.html">Object</a></code>
</h3> <a href="object.html#from_json%28string_or_io%2Croot%3AString%29-class-method" class="tooltip"> from_json(string_or_io, root : String)<br>from_json(string_or_io) from_json</a>, <a href="object.html#from_yaml%28string_or_io%3AString%7CIO%29-class-method" class="tooltip"> from_yaml(string_or_io : String | IO) from_yaml</a> <h3>Macros inherited from class <code><a href="object.html">Object</a></code>
</h3> <a href="object.html#class_getter%28%2Anames%2C%26block%29-macro" class="tooltip"> class_getter(*names, &amp;block) class_getter</a>, <a href="object.html#class_getter%21%28%2Anames%29-macro" class="tooltip"> class_getter!(*names) class_getter!</a>, <a href="object.html#class_getter%3F%28%2Anames%2C%26block%29-macro" class="tooltip"> class_getter?(*names, &amp;block) class_getter?</a>, <a href="object.html#class_property%28%2Anames%2C%26block%29-macro" class="tooltip"> class_property(*names, &amp;block) class_property</a>, <a href="object.html#class_property%21%28%2Anames%29-macro" class="tooltip"> class_property!(*names) class_property!</a>, <a href="object.html#class_property%3F%28%2Anames%2C%26block%29-macro" class="tooltip"> class_property?(*names, &amp;block) class_property?</a>, <a href="object.html#class_setter%28%2Anames%29-macro" class="tooltip"> class_setter(*names) class_setter</a>, <a href="object.html#def_clone-macro" class="tooltip"> def_clone def_clone</a>, <a href="object.html#def_equals%28%2Afields%29-macro" class="tooltip"> def_equals(*fields) def_equals</a>, <a href="object.html#def_equals_and_hash%28%2Afields%29-macro" class="tooltip"> def_equals_and_hash(*fields) def_equals_and_hash</a>, <a href="object.html#def_hash%28%2Afields%29-macro" class="tooltip"> def_hash(*fields) def_hash</a>, <a href="object.html#delegate%28%2Amethods%2Ctoobject%29-macro" class="tooltip"> delegate(*methods, to object) delegate</a>, <a href="object.html#forward_missing_to%28delegate%29-macro" class="tooltip"> forward_missing_to(delegate) forward_missing_to</a>, <a href="object.html#getter%28%2Anames%2C%26block%29-macro" class="tooltip"> getter(*names, &amp;block) getter</a>, <a href="object.html#getter%21%28%2Anames%29-macro" class="tooltip"> getter!(*names) getter!</a>, <a href="object.html#getter%3F%28%2Anames%2C%26block%29-macro" class="tooltip"> getter?(*names, &amp;block) getter?</a>, <a href="object.html#property%28%2Anames%2C%26block%29-macro" class="tooltip"> property(*names, &amp;block) property</a>, <a href="object.html#property%21%28%2Anames%29-macro" class="tooltip"> property!(*names) property!</a>, <a href="object.html#property%3F%28%2Anames%2C%26block%29-macro" class="tooltip"> property?(*names, &amp;block) property?</a>, <a href="object.html#setter%28%2Anames%29-macro" class="tooltip"> setter(*names) setter</a> </div> <h2>  Constructor Detail </h2> <div class="entry-detail" id="literal(pattern:String,*,i:Bool=false,m:Bool=false,x:Bool=false):self-class-method"> <h3 class="signature">def self.<strong>literal</strong>(pattern : <a href="string.html">String</a>, *, i : <a href="bool.html">Bool</a> = false, m : <a href="bool.html">Bool</a> = false, x : <a href="bool.html">Bool</a> = false) : self<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L418" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Creates a new <code><a href="regex.html">Regex</a></code> instance from a literal consisting of a <em>pattern</em> and the named parameter modifiers.</p> </div>   </div> <div class="entry-detail" id="new(source:String,options:Options=Options::None)-class-method"> <h3 class="signature">def self.<strong>new</strong>(source : <a href="string.html">String</a>, options : <a href="regex/options.html">Options</a> = Options::None)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L413" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Creates a new <code><a href="regex.html">Regex</a></code> out of the given source <code><a href="string.html">String</a></code>.</p> <pre data-language="crystal">Regex.new("^a-z+:\\s+\\w+")                          # =&gt; /^a-z+:\s+\w+/
Regex.new("cat", Regex::CompileOptions::IGNORE_CASE) # =&gt; /cat/i
options = Regex::CompileOptions::IGNORE_CASE | Regex::CompileOptions::EXTENDED
Regex.new("dog", options) # =&gt; /dog/ix</pre> </div>   </div> <div class="entry-detail" id="union(patterns:Enumerable(Regex|String)):self-class-method"> <h3 class="signature">def self.<strong>union</strong>(patterns : <a href="enumerable.html">Enumerable</a>(<a href="regex.html">Regex</a> | <a href="string.html">String</a>)) : self<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L493" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Union. Returns a <code><a href="regex.html">Regex</a></code> that matches any of <em>patterns</em>.</p> <p>All capture groups in the patterns after the first one will have their indexes offset.</p> <pre data-language="crystal">re = Regex.union([/skiing/i, "sledding"])
re.match("Skiing")   # =&gt; Regex::MatchData("Skiing")
re.match("sledding") # =&gt; Regex::MatchData("sledding")
re = Regex.union({/skiing/i, "sledding"})
re.match("Skiing")   # =&gt; Regex::MatchData("Skiing")
re.match("sledding") # =&gt; Regex::MatchData("sledding")</pre> </div>   </div> <div class="entry-detail" id="union(*patterns:Regex|String):self-class-method"> <h3 class="signature">def self.<strong>union</strong>(*patterns : <a href="regex.html">Regex</a> | <a href="string.html">String</a>) : self<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L507" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Union. Returns a <code><a href="regex.html">Regex</a></code> that matches any of <em>patterns</em>.</p> <p>All capture groups in the patterns after the first one will have their indexes offset.</p> <pre data-language="crystal">re = Regex.union(/skiing/i, "sledding")
re.match("Skiing")   # =&gt; Regex::MatchData("Skiing")
re.match("sledding") # =&gt; Regex::MatchData("sledding")</pre> </div>   </div> <h2>  Class Method Detail </h2> <div class="entry-detail" id="error?(source):String|Nil-class-method"> <h3 class="signature">def self.<strong>error?</strong>(source) : <a href="string.html">String</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L433" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Determines Regex's source validity. If it is, <code>nil</code> is returned. If it's not, a <code><a href="string.html">String</a></code> containing the error message is returned.</p> <pre data-language="crystal">Regex.error?("(foo|bar)") # =&gt; nil
Regex.error?("(foo|bar")  # =&gt; "missing ) at 8"</pre> </div>   </div> <div class="entry-detail" id="escape(str):String-class-method"> <h3 class="signature">def self.<strong>escape</strong>(str) : <a href="string.html">String</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L464" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns a <code><a href="string.html">String</a></code> constructed by escaping any metacharacters in <em>str</em>.</p> <pre data-language="crystal">string = Regex.escape("*?{}.") # =&gt; "\\*\\?\\{\\}\\."
/#{string}/                    # =&gt; /\*\?\{\}\./</pre> </div>   </div> <div class="entry-detail" id="needs_escape?(char:Char):Bool-class-method"> <h3 class="signature">def self.<strong>needs_escape?</strong>(char : <a href="char.html">Char</a>) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L443" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns <code>true</code> if <em>char</em> need to be escaped, <code>false</code> otherwise.</p> <pre data-language="crystal">Regex.needs_escape?('*') # =&gt; true
Regex.needs_escape?('@') # =&gt; false</pre> </div>   </div> <div class="entry-detail" id="needs_escape?(str:String):Bool-class-method"> <h3 class="signature">def self.<strong>needs_escape?</strong>(str : <a href="string.html">String</a>) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L453" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns <code>true</code> if <em>str</em> need to be escaped, <code>false</code> otherwise.</p> <pre data-language="crystal">Regex.needs_escape?("10$") # =&gt; true
Regex.needs_escape?("foo") # =&gt; false</pre> </div>   </div> <div class="entry-detail" id="supports_compile_options?(options:CompileOptions):Bool-class-method"> <h3 class="signature">def self.<strong>supports_compile_options?</strong>(options : <a href="regex/compileoptions.html">CompileOptions</a>) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L328" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns <code>true</code> if the regex engine supports all <em>options</em> flags when compiling a pattern.</p> </div>   </div> <div class="entry-detail" id="supports_match_options?(options:MatchOptions):Bool-class-method"> <h3 class="signature">def self.<strong>supports_match_options?</strong>(options : <a href="regex/matchoptions.html">MatchOptions</a>) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L383" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns <code>true</code> if the regex engine supports all <em>options</em> flags when matching a pattern.</p> </div>   </div> <h2>  Instance Method Detail </h2> <div class="entry-detail" id="+(other):Regex-instance-method"> <h3 class="signature">def <strong>+</strong>(other) : <a href="regex.html">Regex</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L529" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Union. Returns a <code><a href="regex.html">Regex</a></code> that matches either of the operands.</p> <p>All capture groups in the second operand will have their indexes offset.</p> <pre data-language="crystal">re = /skiing/i + /sledding/
re.match("Skiing")   # =&gt; Regex::MatchData("Skiing")
re.match("sledding") # =&gt; Regex::MatchData("sledding")</pre> </div>   </div> <div class="entry-detail" id="==(other:Regex)-instance-method"> <h3 class="signature">def <strong>==</strong>(other : <a href="regex.html">Regex</a>)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L540" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Equality. Two regexes are equal if their sources and options are the same.</p> <pre data-language="crystal">/abc/ == /abc/i  # =&gt; false
/abc/i == /ABC/i # =&gt; false
/abc/i == /abc/i # =&gt; true</pre> </div>   </div> <div class="entry-detail" id="===(other:String)-instance-method"> <h3 class="signature">def <strong>===</strong>(other : <a href="string.html">String</a>)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L567" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Case equality. This is equivalent to <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match</a></code> or <code><a href="regex.html#%3D~%28other%3AString%29%3AInt32%7CNil-instance-method">#=~</a></code> but only returns <code>true</code> or <code>false</code>. Used in <code>case</code> expressions. The special variable <code>$~</code> will contain a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if there was a match, <code>nil</code> otherwise.</p> <pre data-language="crystal">a = "HELLO"
b = case a
    when /^[a-z]*$/
      "Lower case"
    when /^[A-Z]*$/
      "Upper case"
    else
      "Mixed case"
    end
b # =&gt; "Upper case"</pre> </div>   </div> <div class="entry-detail" id="===(other:JSON::Any)-instance-method"> <h3 class="signature">def <strong>===</strong>(other : <a href="json/any.html">JSON::Any</a>)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/json/any.cr#L358" target="_blank" class="view-source">Source</a>
</h3>   </div> <div class="entry-detail" id="===(other:YAML::Any)-instance-method"> <h3 class="signature">def <strong>===</strong>(other : <a href="yaml/any.html">YAML::Any</a>)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/yaml/any.cr#L399" target="_blank" class="view-source">Source</a>
</h3>   </div> <div class="entry-detail" id="=~(other:String):Int32|Nil-instance-method"> <h3 class="signature">def <strong>=~</strong>(other : <a href="string.html">String</a>) : <a href="int32.html">Int32</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L582" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match. Matches a regular expression against <em>other</em> and returns the starting position of the match if <em>other</em> is a matching <code><a href="string.html">String</a></code>, otherwise <code>nil</code>. <code>$~</code> will contain a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if there was a match, <code>nil</code> otherwise.</p> <pre data-language="crystal">/at/ =~ "input data" # =&gt; 7
/ax/ =~ "input data" # =&gt; nil</pre> </div>   </div> <div class="entry-detail" id="=~(other):Nil-instance-method"> <h3 class="signature">def <strong>=~</strong>(other) : <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L594" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match. When the argument is not a <code><a href="string.html">String</a></code>, always returns <code>nil</code>.</p> <pre data-language="crystal">/at/ =~ "input data" # =&gt; 7
/ax/ =~ "input data" # =&gt; nil</pre> </div>   </div> <div class="entry-detail" id="capture_count:Int32-instance-method"> <h3 class="signature">def <strong>capture_count</strong> : <a href="int32.html">Int32</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L813" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns the number of (named &amp; non-named) capture groups.</p> <pre data-language="crystal">/(?:.+)/.capture_count     # =&gt; 0
/(?&lt;foo&gt;.+)/.capture_count # =&gt; 1
/(.)/.capture_count        # =&gt; 1
/(.)|(.)/.capture_count    # =&gt; 2</pre> </div>   </div> <div class="entry-detail" id="clone-instance-method"> <h3 class="signature">def <strong>clone</strong><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L865" target="_blank" class="view-source">Source</a>
</h3>   </div> <div class="entry-detail" id="dup-instance-method"> <h3 class="signature">def <strong>dup</strong><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L861" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <div class="doc-inherited"> Description copied from class <a href="reference.html">Reference</a> </div> <p>Returns a shallow copy of this object.</p> <p>This allocates a new object and copies the contents of <code>self</code> into it.</p> </div>   </div> <div class="entry-detail" id="hash(hasher)-instance-method"> <h3 class="signature">def <strong>hash</strong>(hasher)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L545" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>See <code><a href="object.html#hash%28hasher%29-instance-method">Object#hash(hasher)</a></code></p> </div>   </div> <div class="entry-detail" id="inspect(io:IO):Nil-instance-method"> <h3 class="signature">def <strong>inspect</strong>(io : <a href="io.html">IO</a>) : <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L607" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Prints to <em>io</em> an unambiguous string representation of this regular expression object.</p> <p>Uses the regex literal syntax with basic option flags if sufficient (i.e. no other options than <code>IGNORE_CASE</code>, <code>MULTILINE</code>, or <code>EXTENDED</code> are set). Otherwise the syntax presents a <code><a href="regex.html#new%28source%3AString%2Coptions%3AOptions%3DOptions%3A%3ANone%29-class-method">Regex.new</a></code> call.</p> <pre data-language="crystal">/ab+c/ix.inspect                     # =&gt; "/ab+c/ix"
Regex.new("ab+c", :anchored).inspect # =&gt; Regex.new("ab+c", Regex::Options::ANCHORED)</pre> </div>   </div> <div class="entry-detail" id="match(str:String,pos:Int32=0,options:Regex::MatchOptions=:none):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match</strong>(str : <a href="string.html">String</a>, pos : <a href="int32.html">Int32</a> = 0, options : <a href="regex/matchoptions.html">Regex::MatchOptions</a> = :none) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L662" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the character index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match("クリスタル", 3).try &amp;.[2] # =&gt; "ル"</pre> </div>   </div> <div class="entry-detail" id="match(str,pos,_options):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match</strong>(str, pos, _options) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L682" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the character index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match("クリスタル", 3).try &amp;.[2] # =&gt; "ル"</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="match(str,pos=0,*,options):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match</strong>(str, pos = 0, *, options) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L672" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the character index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match("クリスタル", 3).try &amp;.[2] # =&gt; "ル"</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="match!(str:String,pos:Int32=0,*,options:Regex::MatchOptions=:none):MatchData-instance-method"> <h3 class="signature">def <strong>match!</strong>(str : <a href="string.html">String</a>, pos : <a href="int32.html">Int32</a> = 0, *, options : <a href="regex/matchoptions.html">Regex::MatchOptions</a> = :none) : <a href="regex/matchdata.html">MatchData</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L696" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Matches a regular expression against <em>str</em>. This starts at the character index <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise raises <code><a href="regex/error.html">Regex::Error</a></code>. <code>$~</code> will contain the same value if matched.</p> <pre data-language="crystal">/(.)(.)(.)/.match!("abc")[2]   # =&gt; "b"
/(.)(.)/.match!("abc", 1)[2]   # =&gt; "c"
/(.)(タ)/.match!("クリスタル", 3)[2] # raises Exception</pre> </div>   </div> <div class="entry-detail" id="match_at_byte_index(str:String,byte_index:Int32=0,options:Regex::MatchOptions=:none):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match_at_byte_index</strong>(str : <a href="string.html">String</a>, byte_index : <a href="int32.html">Int32</a> = 0, options : <a href="regex/matchoptions.html">Regex::MatchOptions</a> = :none) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L711" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the byte index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match_at_byte_index("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match_at_byte_index("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match_at_byte_index("クリスタル", 3).try &amp;.[2] # =&gt; "ス"</pre> </div>   </div> <div class="entry-detail" id="match_at_byte_index(str,byte_index,_options):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match_at_byte_index</strong>(str, byte_index, _options) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L731" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the byte index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match_at_byte_index("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match_at_byte_index("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match_at_byte_index("クリスタル", 3).try &amp;.[2] # =&gt; "ス"</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="match_at_byte_index(str,byte_index=0,*,options):MatchData|Nil-instance-method"> <h3 class="signature">def <strong>match_at_byte_index</strong>(str, byte_index = 0, *, options) : <a href="regex/matchdata.html">MatchData</a> | <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L721" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. Matches a regular expression against <code><a href="string.html">String</a></code> <em>str</em>. Starts at the byte index given by <em>pos</em> if given, otherwise at the start of <em>str</em>. Returns a <code><a href="regex/matchdata.html">Regex::MatchData</a></code> if <em>str</em> matched, otherwise <code>nil</code>. <code>$~</code> will contain the same value that was returned.</p> <pre data-language="crystal">/(.)(.)(.)/.match_at_byte_index("abc").try &amp;.[2]   # =&gt; "b"
/(.)(.)/.match_at_byte_index("abc", 1).try &amp;.[2]   # =&gt; "c"
/(.)(.)/.match_at_byte_index("クリスタル", 3).try &amp;.[2] # =&gt; "ス"</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="matches?(str:String,pos:Int32=0,options:Regex::MatchOptions=:none):Bool-instance-method"> <h3 class="signature">def <strong>matches?</strong>(str : <a href="string.html">String</a>, pos : <a href="int32.html">Int32</a> = 0, options : <a href="regex/matchoptions.html">Regex::MatchOptions</a> = :none) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L745" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. It behaves like <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> <pre data-language="crystal">/foo/.matches?("bar") # =&gt; false
/foo/.matches?("foo") # =&gt; true

# `$~` is not set even if last match succeeds.
$~ # raises Exception</pre> </div>   </div> <div class="entry-detail" id="matches?(str,pos,_options):Bool-instance-method"> <h3 class="signature">def <strong>matches?</strong>(str, pos, _options) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L765" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. It behaves like <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> <pre data-language="crystal">/foo/.matches?("bar") # =&gt; false
/foo/.matches?("foo") # =&gt; true

# `$~` is not set even if last match succeeds.
$~ # raises Exception</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="matches?(str,pos=0,*,options):Bool-instance-method"> <h3 class="signature">def <strong>matches?</strong>(str, pos = 0, *, options) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L755" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at character index. It behaves like <code><a href="regex.html#match%28str%3AString%2Cpos%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> <pre data-language="crystal">/foo/.matches?("bar") # =&gt; false
/foo/.matches?("foo") # =&gt; true

# `$~` is not set even if last match succeeds.
$~ # raises Exception</pre> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="matches_at_byte_index?(str:String,byte_index:Int32=0,options:Regex::MatchOptions=:none):Bool-instance-method"> <h3 class="signature">def <strong>matches_at_byte_index?</strong>(str : <a href="string.html">String</a>, byte_index : <a href="int32.html">Int32</a> = 0, options : <a href="regex/matchoptions.html">Regex::MatchOptions</a> = :none) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L771" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. It behaves like <code><a href="regex.html#match_at_byte_index%28str%3AString%2Cbyte_index%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match_at_byte_index</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> </div>   </div> <div class="entry-detail" id="matches_at_byte_index?(str,byte_index,_options):Bool-instance-method"> <h3 class="signature">def <strong>matches_at_byte_index?</strong>(str, byte_index, _options) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L787" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. It behaves like <code><a href="regex.html#match_at_byte_index%28str%3AString%2Cbyte_index%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match_at_byte_index</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="matches_at_byte_index?(str,byte_index=0,*,options):Bool-instance-method"> <h3 class="signature">def <strong>matches_at_byte_index?</strong>(str, byte_index = 0, *, options) : <a href="bool.html">Bool</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L779" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Match at byte index. It behaves like <code><a href="regex.html#match_at_byte_index%28str%3AString%2Cbyte_index%3AInt32%3D0%2Coptions%3ARegex%3A%3AMatchOptions%3D%3Anone%29%3AMatchData%7CNil-instance-method">#match_at_byte_index</a></code>, however it returns <code><a href="bool.html">Bool</a></code> value. It neither returns <code><a href="regex/matchdata.html">MatchData</a></code> nor assigns it to the <code>$~</code> variable.</p> <p>DEPRECATED Use the overload with <code><a href="regex/matchoptions.html">Regex::MatchOptions</a></code> instead.</p> </div>   </div> <div class="entry-detail" id="name_table:Hash(Int32,String)-instance-method"> <h3 class="signature">def <strong>name_table</strong> : <a href="hash.html">Hash</a>(<a href="int32.html">Int32</a>, <a href="string.html">String</a>)<a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L801" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns a <code><a href="hash.html">Hash</a></code> where the values are the names of capture groups and the keys are their indexes. Non-named capture groups will not have entries in the <code><a href="hash.html">Hash</a></code>. Capture groups are indexed starting from <code>1</code>.</p> <pre data-language="crystal">/(.)/.name_table                         # =&gt; {}
/(?&lt;foo&gt;.)/.name_table                   # =&gt; {1 =&gt; "foo"}
/(?&lt;foo&gt;.)(?&lt;bar&gt;.)/.name_table          # =&gt; {2 =&gt; "bar", 1 =&gt; "foo"}
/(.)(?&lt;foo&gt;.)(.)(?&lt;bar&gt;.)(.)/.name_table # =&gt; {4 =&gt; "bar", 2 =&gt; "foo"}</pre> </div>   </div> <div class="entry-detail" id="options:Options-instance-method"> <h3 class="signature">def <strong>options</strong> : <a href="regex/options.html">Options</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L396" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns a <code><a href="regex/compileoptions.html">Regex::CompileOptions</a></code> representing the optional flags applied to this <code><a href="regex.html">Regex</a></code>.</p> <pre data-language="crystal">/ab+c/ix.options      # =&gt; Regex::CompileOptions::IGNORE_CASE | Regex::CompileOptions::EXTENDED
/ab+c/ix.options.to_s # =&gt; "IGNORE_CASE | EXTENDED"</pre> </div>   </div> <div class="entry-detail" id="source:String-instance-method"> <h3 class="signature">def <strong>source</strong> : <a href="string.html">String</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L403" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Returns the original <code><a href="string.html">String</a></code> representation of the <code><a href="regex.html">Regex</a></code> pattern.</p> <pre data-language="crystal">/ab+c/x.source # =&gt; "ab+c"</pre> </div>   </div> <div class="entry-detail" id="to_s(io:IO):Nil-instance-method"> <h3 class="signature">def <strong>to_s</strong>(io : <a href="io.html">IO</a>) : <a href="nil.html">Nil</a><a href="https://github.com/crystal-lang/crystal/blob/89944bf17/src/regex.cr#L828" target="_blank" class="view-source">Source</a>
</h3> <div class="doc"> <p>Convert to <code><a href="string.html">String</a></code> in subpattern format. Produces a <code><a href="string.html">String</a></code> which can be embedded in another <code><a href="regex.html">Regex</a></code> via interpolation, where it will be interpreted as a non-capturing subexpression in another regular expression.</p> <pre data-language="crystal">re = /A*/i                 # =&gt; /A*/i
re.to_s                    # =&gt; "(?i-msx:A*)"
"Crystal".match(/t#{re}l/) # =&gt; Regex::MatchData("tal")
re = /A*/                  # =&gt; "(?-imsx:A*)"
"Crystal".match(/t#{re}l/) # =&gt; nil</pre> </div>   </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2025 Manas Technology Solutions.<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://crystal-lang.org/api/1.15.1/Regex.html" class="_attribution-link">https://crystal-lang.org/api/1.15.1/Regex.html</a>
  </p>
</div>
