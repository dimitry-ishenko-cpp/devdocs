<header><h1>@babel/plugin-transform-typescript</h1></header><blockquote><p><strong>NOTE</strong>: This plugin is included in <code>@babel/preset-typescript</code></p></blockquote>
<p>This plugin adds support for the types syntax used by the <a href="https://www.typescriptlang.org" target="_blank" rel="noopener noreferrer">TypeScript programming language</a>. However, this plugin does not add the ability to type-check the JavaScript passed to it. For that, you will need to install and set up TypeScript.</p>
<p>Note that although the TypeScript compiler <code>tsc</code> actively supports certain JavaScript proposals such as optional chaining (<code>?.</code>), nullish coalescing (<code>??</code>) and class properties (<code>this.#x</code>), this preset does not include these features because they are not the types syntax available in TypeScript only. We recommend using <code>preset-env</code> with <code>preset-typescript</code> if you want to transpile these features.</p>
<h2 id="example">Example<a href="#example" aria-label="Direct link to Example" title="Direct link to Example">​</a>
</h2>
<p><strong>In</strong></p>
<div><div>
<pre tabindex="0" data-language="typescript">const x: number = 0;</pre>

</div></div>
<p><strong>Out</strong></p>
<div><div>
<pre tabindex="0" data-language="typescript">const x = 0;</pre>

</div></div>
<h2 id="installation">Installation<a href="#installation" aria-label="Direct link to Installation" title="Direct link to Installation">​</a>
</h2>
<div>
<ul role="tablist" aria-orientation="horizontal">
<li role="tab" tabindex="0" aria-selected="true">npm</li>
<li role="tab" tabindex="-1" aria-selected="false">Yarn</li>
<li role="tab" tabindex="-1" aria-selected="false">pnpm</li>
</ul>
<div>
<div role="tabpanel"><div><div>
<pre tabindex="0" data-language="shell">npm install --save-dev @babel/plugin-transform-typescript</pre>

</div></div></div>
<div role="tabpanel" hidden=""><div><div>
<pre tabindex="0" data-language="shell">yarn add --dev @babel/plugin-transform-typescript</pre>

</div></div></div>
<div role="tabpanel" hidden=""><div><div>
<pre tabindex="0" data-language="shell">pnpm add --save-dev @babel/plugin-transform-typescript</pre>

</div></div></div>
</div>
</div>
<h2 id="usage">Usage<a href="#usage" aria-label="Direct link to Usage" title="Direct link to Usage">​</a>
</h2>
<h3 id="with-a-configuration-file-recommended">With a configuration file (Recommended)<a href="#with-a-configuration-file-recommended" aria-label="Direct link to With a configuration file (Recommended)" title="Direct link to With a configuration file (Recommended)">​</a>
</h3>
<div><div>
<pre tabindex="0" data-language="json">{
  "plugins": ["@babel/plugin-transform-typescript"]
}</pre>

</div></div>
<h3 id="via-cli">Via CLI<a href="#via-cli" aria-label="Direct link to Via CLI" title="Direct link to Via CLI">​</a>
</h3>
<div><div>
<pre tabindex="0" data-language="sh">babel --plugins @babel/plugin-transform-typescript script.js</pre>

</div></div>
<h3 id="via-node-api">Via Node API<a href="#via-node-api" aria-label="Direct link to Via Node API" title="Direct link to Via Node API">​</a>
</h3>
<div><div>
<pre tabindex="0" data-language="js">require("@babel/core").transformSync("code", {
  plugins: ["@babel/plugin-transform-typescript"],
});</pre>

</div></div>
<h2 id="options">Options<a href="#options" aria-label="Direct link to Options" title="Direct link to Options">​</a>
</h2>
<h3 id="allowdeclarefields">
<code>allowDeclareFields</code><a href="#allowdeclarefields" aria-label="Direct link to allowdeclarefields" title="Direct link to allowdeclarefields">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Added in <code>v7.7.0</code></p>
<blockquote><p>NOTE: This will be enabled by default in Babel 8</p></blockquote>
<p>When enabled, type-only class fields are only removed if they are prefixed with the <code>declare</code> modifier:</p>
<div><div>
<pre tabindex="0" data-language="js">class A {
  declare foo: string; // Removed
  bar: string; // Initialized to undefined
}</pre>

</div></div>
<h3 id="allownamespaces">
<code>allowNamespaces</code><a href="#allownamespaces" aria-label="Direct link to allownamespaces" title="Direct link to allownamespaces">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>true</code>.</p>
<details data-collapsed="true"><summary>History</summary><div><div><table>
<thead><tr>
<th>Version</th>
<th>Changes</th>
</tr></thead>
<tbody>
<tr>
<td><code>v7.5.0</code></td>
<td>Added <code>allowNamespaces</code>, defaults to <code>false</code>
</td>
</tr>
<tr>
<td><code>v7.13.0</code></td>
<td>defaults to <code>true</code>
</td>
</tr>
</tbody>
</table></div></div></details><p>Enables compilation of TypeScript namespaces.</p>
<h3 id="disallowambiguousjsxlike">
<code>disallowAmbiguousJSXLike</code><a href="#disallowambiguousjsxlike" aria-label="Direct link to disallowambiguousjsxlike" title="Direct link to disallowambiguousjsxlike">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Added in: <code>v7.16.0</code></p>
<p>Even when JSX parsing is not enabled, this option disallows using syntax that would be ambiguous with JSX (<code>&lt;X&gt; y</code> type assertions and <code>&lt;X&gt;() =&gt; {}</code> type arguments). It matches the <code>tsc</code> behavior when parsing <code>.mts</code> and <code>.mjs</code> files.</p>
<h3 id="dts">
<code>dts</code><a href="#dts" aria-label="Direct link to dts" title="Direct link to dts">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Added in: <code>v7.20.0</code></p>
<p>This option will enable parsing within a TypeScript ambient context, where certain syntax have different rules (like <code>.d.ts</code> files and inside <code>declare module</code> blocks). Please see <a href="https://www.typescriptlang.org/docs/handbook/declaration-files/introduction.html" target="_blank" rel="noopener noreferrer">Official Handbook</a> and <a href="https://basarat.gitbook.io/typescript/type-system/intro" target="_blank" rel="noopener noreferrer">TypeScript Deep Dive</a> for more information about ambient contexts.</p>
<h3 id="istsx">
<code>isTSX</code><a href="#istsx" aria-label="Direct link to istsx" title="Direct link to istsx">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Forcibly enables <code>jsx</code> parsing. Otherwise angle brackets will be treated as TypeScript's legacy type assertion <code>var foo = &lt;string&gt;bar;</code>. Also, <code>isTSX: true</code> requires <code>allExtensions: true</code>.</p>
<h3 id="jsxpragma">
<code>jsxPragma</code><a href="#jsxpragma" aria-label="Direct link to jsxpragma" title="Direct link to jsxpragma">​</a>
</h3>
<p><code>string</code>, defaults to <code>React</code></p>
<p>Replace the function used when compiling JSX expressions. This is so that we know that the import is not a type import, and should not be removed.</p>
<h3 id="jsxpragmafrag">
<code>jsxPragmaFrag</code><a href="#jsxpragmafrag" aria-label="Direct link to jsxpragmafrag" title="Direct link to jsxpragmafrag">​</a>
</h3>
<p><code>string</code>, defaults to <code>React.Fragment</code></p>
<p>Replace the function used when compiling JSX fragment expressions. This is so that we know that the import is not a type import, and should not be removed.</p>
<h3 id="onlyremovetypeimports">
<code>onlyRemoveTypeImports</code><a href="#onlyremovetypeimports" aria-label="Direct link to onlyremovetypeimports" title="Direct link to onlyremovetypeimports">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Added in: <code>v7.9.0</code></p>
<p>When set to <code>true</code>, the transform will only remove <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-exports" target="_blank" rel="noopener noreferrer">type-only imports</a> (introduced in TypeScript 3.8). This should only be used if you are using TypeScript &gt;= 3.8.</p>
<div><div>
<pre tabindex="0" data-language="js">class A {
  declare foo: string; // Removed
  bar: string; // Initialized to undefined
  prop?: string; // Initialized to undefined
  prop1!: string // Initialized to undefined
}</pre>

</div></div>
<h3 id="optimizeconstenums">
<code>optimizeConstEnums</code><a href="#optimizeconstenums" aria-label="Direct link to optimizeconstenums" title="Direct link to optimizeconstenums">​</a>
</h3>
<p><code>boolean</code>, defaults to <code>false</code></p>
<p>Added in: <code>v7.15.0</code></p>
<p>When set to <code>true</code>, Babel will inline enum values rather than using the usual <code>enum</code> output:</p>
<div><div>
<pre tabindex="0" data-language="typescript">// Input
const enum Animals {
  Fish,
}
console.log(Animals.Fish);

// Default output
var Animals;

(function(Animals) {
  Animals[(Animals["Fish"] = 0)] = "Fish";
})(Animals || (Animals = {}));

console.log(Animals.Fish);

// `optimizeConstEnums` output
console.log(0);</pre>

</div></div>
<p>This option differs from TypeScript's <code>--isolatedModules</code> behavior, which ignores the <code>const</code> modifier and compiles them as normal enums, and aligns Babel's behavior with TypeScript's default behavior.</p>
<p>However, when <em>exporting</em> a <code>const enum</code> Babel will compile it to a plain object literal so that it doesn't need to rely on cross-file analysis when compiling it:</p>
<div><div>
<pre tabindex="0" data-language="typescript">// Input
export const enum Animals {
  Fish,
}

// `optimizeConstEnums` output
export var Animals = {
  Fish: 0,
};</pre>

</div></div>
<h2 id="typescript-compiler-options">TypeScript Compiler Options<a href="#typescript-compiler-options" aria-label="Direct link to TypeScript Compiler Options" title="Direct link to TypeScript Compiler Options">​</a>
</h2>
<p>The official TypeScript compiler has many <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer">options</a> for configuring how it compiles and type checks. While many don't apply, some behaviors might be useful and their equivalents in Babel can be enabled by some configuration options or plugins.</p>
<ul>
<li>
<p><code>--alwaysStrict</code> You can use the <code>strictMode</code> <a href="https://babeljs.io/docs/en/babel-parser#options" target="_blank" rel="noopener noreferrer">parser option</a>:</p>
<div><div>
<pre tabindex="0" data-language="js">module.exports = {
  parserOpts: { strictMode: true },
};</pre>

</div></div>
</li>
<li><p><code>--downlevelIteration</code> You can use the <code>@babel/plugin-transform-for-of</code> plugin. If you are using <code>@babel/preset-env</code>, <code>for...of</code> is already transpiled using iterators when it isn't supported by your compilation target(s).</p></li>
<li><p><code>--emitDecoratorMetadata</code> This option isn't supported by an official Babel package since it is a TypeScript-specific addition and not part of the decorators proposal. If you rely on this feature, you can use the community plugin <a href="https://github.com/leonardfactory/babel-plugin-transform-typescript-metadata#readme" target="_blank" rel="noopener noreferrer">babel-plugin-transform-typescript-metadata</a>.</p></li>
<li><p><code>--esModuleInterop</code> This is the default behavior of Babel when transpiling ECMAScript modules.</p></li>
<li>
<p><code>--experimentalDecorators</code> This option enables support for the "legacy" decorator proposal. You can enable it in Babel using the <code>@babel/plugin-proposal-decorators</code> plugin, but please be aware, there are some minor differences.</p>
<div><div>
<pre tabindex="0" data-language="js">module.exports = {
  plugins: [["@babel/plugin-proposal-decorators", { legacy: true }]],
};</pre>

</div></div>
</li>
<li><p><code>--importHelpers</code> This is the equivalent of the <code>@babel/plugin-transform-runtime</code> package.</p></li>
<li><p><code>---importsNotUsedAsValues</code> You can use the <code>onlyRemoveTypeImports</code> option to replicate this behavior. <code>onlyRemoveTypeImports: true</code> is equivalent to <code>importsNotUsedAsValues: preserve</code>, while <code>onlyRemoveTypeImports: false</code> is equivalent to <code>importsNotUsedAsValues: remove</code>. There is no equivalent for <code>importsNotUsedAsValues: error</code>.</p></li>
<li><p><code>--inlineSourceMap</code> You can set the <a href="https://babeljs.io/docs/en/options#sourcemaps" target="_blank" rel="noopener noreferrer"><code>sourceMaps: "inline"</code></a> option in your <code>babel.config.json</code> file.</p></li>
<li><p><code>--isolatedModules</code> This is the default Babel behavior, and it can't be turned off because Babel doesn't support cross-file analysis.</p></li>
<li><p><code>--jsx</code> JSX support is provided using another plugin. If you want your output to contains JSX code (i.e. <code>--jsx preserve</code>), you need the <code>@babel/plugin-syntax-jsx</code> plugin; if you want to transpile it to standard JavaScript (i.e. <code>--jsx react</code> or <code>--jsx react-native</code>), you should use the <code>@babel/plugin-transform-react-jsx</code> plugin.</p></li>
<li><p><code>--jsxFactory</code> It can be customized using the <a href="https://babeljs.io/docs/en/babel-plugin-transform-react-jsx#pragma" target="_blank" rel="noopener noreferrer"><code>pragma</code> option</a> of the <code>@babel/plugin-transform-react-jsx</code> package. You also need to set the <code>jsxPragma</code> option of this plugin.</p></li>
<li>
<p><code>--module</code>, <code>-m</code> If you are using a bundler (Webpack or Rollup), this option is set automatically. If you are using <code>@babel/preset-env</code>, you can use the <a href="https://babeljs.io/docs/en/babel-preset-env#modules" target="_blank" rel="noopener noreferrer"><code>modules</code> option</a>; otherwise you can load the specific plugin.</p>
<table>
<thead><tr>
<th align="center"><strong><code>--module</code> value</strong></th>
<th align="center"><strong><code>@babel/preset-env</code>'s <code>modules</code></strong></th>
<th align="center"><strong>Single plugin</strong></th>
</tr></thead>
<tbody>
<tr>
<td align="center"><code>None</code></td>
<td align="center"><code>false</code></td>
<td align="center">/</td>
</tr>
<tr>
<td align="center"><code>CommonJS</code></td>
<td align="center">
<code>"commonjs"</code> or <code>"cjs"</code>
</td>
<td align="center"><code>@babel/plugin-transform-modules-commonjs</code></td>
</tr>
<tr>
<td align="center"><code>AMD</code></td>
<td align="center"><code>"amd"</code></td>
<td align="center"><code>@babel/plugin-transform-modules-amd</code></td>
</tr>
<tr>
<td align="center"><code>System</code></td>
<td align="center"><code>"systemjs"</code></td>
<td align="center"><code>@babel/plugin-transform-modules-systemjs</code></td>
</tr>
<tr>
<td align="center"><code>UMD</code></td>
<td align="center"><code>"umd"</code></td>
<td align="center"><code>@babel/plugin-transform-modules-umd</code></td>
</tr>
<tr>
<td align="center">
<code>ES6</code> or <code>ES2015</code>
</td>
<td align="center"><code>false</code></td>
<td align="center">/</td>
</tr>
</tbody>
</table>
</li>
<li><p><code>--outDir</code> When using <code>@babel/cli</code>, you can set the <a href="https://babeljs.io/docs/en/babel-cli#compile-directories" target="_blank" rel="noopener noreferrer"><code>--out-dir</code> option</a>.</p></li>
<li><p><code>--outFile</code> Babel doesn't support concatenating output files: you should use a bundler (like Webpack, Rollup or Parcel) for that. When using <code>@babel/cli</code>, you can compile a single file using the <a href="https://babeljs.io/docs/en/babel-cli#compile-files" target="_blank" rel="noopener noreferrer"><code>--out-file</code> option</a>.</p></li>
<li><p><code>--sourceMap</code> You can use the top-level <a href="https://babeljs.io/docs/en/options#sourcemaps" target="_blank" rel="noopener noreferrer"><code>sourceMaps: true</code> option</a>.</p></li>
<li><p><code>--target</code> Babel doesn't support targeting a specific version of the language, but you can choose which engines you want to target using <a href="https://babeljs.io/docs/en/babel-preset-env" target="_blank" rel="noopener noreferrer"><code>@babel/preset-env</code></a>. If you prefer, you can enable <a href="https://babeljs.io/docs/en/plugins" target="_blank" rel="noopener noreferrer">individual plugins</a> for every ECMAScript feature.</p></li>
<li><p><code>--useDefineForClassFields</code> You can use the <code>onlyRemoveTypeImports</code> option to replicate this behavior.</p></li>
<li><p><code>--watch</code>, <code>-w</code> When using <code>@babel/cli</code>, you can specify the <a href="https://babeljs.io/docs/en/babel-cli#compile-files" target="_blank" rel="noopener noreferrer"><code>--watch</code> option</a>.</p></li>
</ul>
<h2 id="caveats">Caveats<a href="#caveats" aria-label="Direct link to Caveats" title="Direct link to Caveats">​</a>
</h2>
<p>Because there are features of the TypeScript language which rely on the full type-system to be available to make changes at runtime. This section of caveats is quite long, however, it's worth noting that a few of these features are only found in older TypeScript codebases and have modern JavaScript equivalents which you are probably already using.</p>
<ol>
<li><p>Since Babel does not type-check, code which is syntactically correct, but would fail the TypeScript type-checking may successfully get transformed, and often in unexpected or invalid ways.</p></li>
<li>
<p>This plugin does not support <a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require" target="_blank" rel="noopener noreferrer"><code>export =</code></a> and <a href="https://www.typescriptlang.org/docs/handbook/modules.html#export--and-import--require" target="_blank" rel="noopener noreferrer"><code>import =</code></a>, because those cannot be compiled to ES.next. These are a TypeScript only form of <code>import</code>/<code>export</code>.</p>
<p><strong>Workarounds</strong>:</p>
<ul>
<li>Use the plugin <a href="https://www.npmjs.com/package/babel-plugin-replace-ts-export-assignment" target="_blank" rel="noopener noreferrer">babel-plugin-replace-ts-export-assignment</a> to transform <code>export =</code>.</li>
<li>Convert to using <code>export default</code> and <code>export const</code>, and <code>import x, {y} from "z"</code>.</li>
</ul>
</li>
<li><p>Changes to your <code>tsconfig.json</code> are not reflected in babel. The build process will always behave as though <a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html" target="_blank" rel="noopener noreferrer"><code>isolatedModules</code></a> is turned on, there are Babel-native alternative ways to set a lot of the <a href="#typescript-compiler-options"><code>tsconfig.json</code> options</a> however.</p></li>
<li>
<p><strong>Q</strong>: Why doesn't Babel allow export of a <code>var</code> or <code>let</code>?</p>
<p><strong>A</strong>: The TypeScript compiler dynamically changes how these variables are used depending on whether or not the value is mutated. Ultimately, this depends on a type-model and is outside the scope of Babel. A best-effort implementation would transform context-dependent usages of the variable to always use the <code>Namespace.Value</code> version instead of <code>Value</code>, in case it was mutated outside of the current file. Allowing <code>var</code> or <code>let</code> from Babel (as the transform is not-yet-written) is therefore is more likely than not to present itself as a bug when used as-if it was not <code>const</code>.</p>
</li>
</ol>
<h3 id="impartial-namespace-support">Impartial Namespace Support<a href="#impartial-namespace-support" aria-label="Direct link to Impartial Namespace Support" title="Direct link to Impartial Namespace Support">​</a>
</h3>
<p>If you have existing code which uses the TypeScript-only <a href="https://www.typescriptlang.org/docs/handbook/namespaces.html" target="_blank" rel="noopener noreferrer">namespace</a> features. Babel supports a subset of TypeScript's namespace features. If you are considering writing new code which uses namespace, using the ES2015 <code>import</code>/<code>export</code> is recommended instead. It's <a href="https://github.com/microsoft/TypeScript/issues/30994#issuecomment-484150549" target="_blank" rel="noopener noreferrer">not going away</a>, but there are modern alternatives.</p>
<ul>
<li><p>Type-only <code>namespace</code>s should be marked with <code>declare</code> and will subsequently be safely removed.</p></li>
<li>
<p><code>export</code>ing a variable using <code>var</code> or <code>let</code> in a <code>namespace</code> will result in an error: <em>"Namespaces exporting non-const are not supported by Babel. Change to const or ..."</em></p>
<p><strong>Workaround</strong>: Use <code>const</code>. If some form of mutation is required, explicitly use an object with internal mutability.</p>
</li>
<li>
<p><code>namespace</code>s will not share their scope. In TypeScript, it is valid to refer to contextual items that a <code>namespace</code> extends without qualifying them, and the compiler will add the qualifier. In Babel, there is no type-model, and it is impossible to dynamically change references to match the established type of the parent object.</p>
<p>Consider this code:</p>
<div><div>
<pre tabindex="0" data-language="typescript">namespace N {
  export const V = 1;
}
namespace N {
  export const W = V;
}</pre>

</div></div>
<p>The TypeScript compiler compiles it to something like this:</p>
<div><div>
<pre tabindex="0" data-language="js">var N = {};
(function(N) {
  N.V = 1;
})(N);
(function(N) {
  N.W = N.V;
})(N);</pre>

</div></div>
<p>While Babel will transform it to something like this:</p>
<div><div>
<pre tabindex="0" data-language="js">var N;
(function(_N) {
  const V = (_N = 1);
})(N || (N = {}));
(function(_N) {
  const W = V;
})(N || (N = {}));</pre>

</div></div>
<p>As Babel doesn't understand the type of <code>N</code>, the reference to <code>V</code> will be <code>undefined</code> resulting in an error.</p>
<p><strong>Workaround</strong>: Explicitly refer to values not in the same namespace definition, even if they would be in the scope according to TypeScript. Examples:</p>
<div><div>
<pre tabindex="0" data-language="typescript">namespace N {
  export const V = 1;
}
namespace N {
  export const W = N.V;
}</pre>

</div></div>
<p>Or:</p>
<div><div>
<pre tabindex="0" data-language="typescript">namespace N {
  export const V = 1;
  export const W = V;
}</pre>

</div></div>
</li>
</ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014-present Sebastian McKenzie<br>Licensed under the MIT License.<br>
    <a href="https://babeljs.io/docs/babel-plugin-transform-typescript/" class="_attribution-link">https://babeljs.io/docs/babel-plugin-transform-typescript/</a>
  </p>
</div>
