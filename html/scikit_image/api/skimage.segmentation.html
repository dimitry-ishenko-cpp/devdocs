<h1 id="module-segmentation">Module: segmentation</h1> <table class="longtable docutils align-default" id="module-skimage.segmentation">   <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.active_contour" title="skimage.segmentation.active_contour"><code>skimage.segmentation.active_contour</code></a>(image, snake)</p></td> <td><p>Active contour model.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.chan_vese" title="skimage.segmentation.chan_vese"><code>skimage.segmentation.chan_vese</code></a>(image[, mu, …])</p></td> <td><p>Chan-Vese segmentation algorithm.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>skimage.segmentation.checkerboard_level_set</code></a>(…)</p></td> <td><p>Create a checkerboard level set with binary values.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.circle_level_set" title="skimage.segmentation.circle_level_set"><code>skimage.segmentation.circle_level_set</code></a>(…[, …])</p></td> <td><p>Create a circle level set with binary values.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.clear_border" title="skimage.segmentation.clear_border"><code>skimage.segmentation.clear_border</code></a>(labels[, …])</p></td> <td><p>Clear objects connected to the label image border.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.disk_level_set" title="skimage.segmentation.disk_level_set"><code>skimage.segmentation.disk_level_set</code></a>(…[, …])</p></td> <td><p>Create a disk level set with binary values.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.expand_labels" title="skimage.segmentation.expand_labels"><code>skimage.segmentation.expand_labels</code></a>(label_image)</p></td> <td><p>Expand labels in label image by <code>distance</code> pixels without overlapping.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.felzenszwalb" title="skimage.segmentation.felzenszwalb"><code>skimage.segmentation.felzenszwalb</code></a>(image[, …])</p></td> <td><p>Computes Felsenszwalb’s efficient graph based image segmentation.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.find_boundaries" title="skimage.segmentation.find_boundaries"><code>skimage.segmentation.find_boundaries</code></a>(label_img)</p></td> <td><p>Return bool array where boundaries between labeled regions are True.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.flood" title="skimage.segmentation.flood"><code>skimage.segmentation.flood</code></a>(image, seed_point, *)</p></td> <td><p>Mask corresponding to a flood fill.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.flood_fill" title="skimage.segmentation.flood_fill"><code>skimage.segmentation.flood_fill</code></a>(image, …)</p></td> <td><p>Perform flood filling on an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.inverse_gaussian_gradient" title="skimage.segmentation.inverse_gaussian_gradient"><code>skimage.segmentation.inverse_gaussian_gradient</code></a>(image)</p></td> <td><p>Inverse of gradient magnitude.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.join_segmentations" title="skimage.segmentation.join_segmentations"><code>skimage.segmentation.join_segmentations</code></a>(s1, s2)</p></td> <td><p>Return the join of the two input segmentations.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.mark_boundaries" title="skimage.segmentation.mark_boundaries"><code>skimage.segmentation.mark_boundaries</code></a>(image, …)</p></td> <td><p>Return image with boundaries between labeled regions highlighted.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.morphological_chan_vese" title="skimage.segmentation.morphological_chan_vese"><code>skimage.segmentation.morphological_chan_vese</code></a>(…)</p></td> <td><p>Morphological Active Contours without Edges (MorphACWE)</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.morphological_geodesic_active_contour" title="skimage.segmentation.morphological_geodesic_active_contour"><code>skimage.segmentation.morphological_geodesic_active_contour</code></a>(…)</p></td> <td><p>Morphological Geodesic Active Contours (MorphGAC).</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.quickshift" title="skimage.segmentation.quickshift"><code>skimage.segmentation.quickshift</code></a>(image[, …])</p></td> <td><p>Segments image using quickshift clustering in Color-(x,y) space.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code>skimage.segmentation.random_walker</code></a>(data, labels)</p></td> <td><p>Random walker algorithm for segmentation from markers.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.relabel_sequential" title="skimage.segmentation.relabel_sequential"><code>skimage.segmentation.relabel_sequential</code></a>(…)</p></td> <td><p>Relabel arbitrary labels to {<code>offset</code>, …</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.slic" title="skimage.segmentation.slic"><code>skimage.segmentation.slic</code></a>(image[, …])</p></td> <td><p>Segments image using k-means clustering in Color-(x,y,z) space.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.segmentation.watershed" title="skimage.segmentation.watershed"><code>skimage.segmentation.watershed</code></a>(image[, …])</p></td> <td><p>Find watershed basins in <code>image</code> flooded from given <code>markers</code>.</p></td> </tr>  </table>  <h2 id="active-contour">active_contour</h2> <dl class="function"> <dt id="skimage.segmentation.active_contour">
<code>skimage.segmentation.active_contour(image, snake, alpha=0.01, beta=0.1, w_line=0, w_edge=1, gamma=0.01, max_px_move=1.0, max_iterations=2500, convergence=0.1, *, boundary_condition='periodic', coordinates='rc')</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/active_contour_model.py#L7-L227"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Active contour model.</p> <p>Active contours by fitting snakes to features of images. Supports single and multichannel 2D images. Snakes can be periodic (for segmentation) or have fixed and/or free ends. The output snake has the same length as the input boundary. As the number of points is constant, make sure that the initial snake has enough points to capture the details of the final contour.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(N, M) or (N, M, 3) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>snake(N, 2) ndarray</code> </dt>
<dd>
<p>Initial snake coordinates. For periodic boundary conditions, endpoints must not be duplicated.</p> </dd> <dt>
<code>alphafloat, optional</code> </dt>
<dd>
<p>Snake length shape parameter. Higher values makes snake contract faster.</p> </dd> <dt>
<code>betafloat, optional</code> </dt>
<dd>
<p>Snake smoothness shape parameter. Higher values makes snake smoother.</p> </dd> <dt>
<code>w_linefloat, optional</code> </dt>
<dd>
<p>Controls attraction to brightness. Use negative values to attract toward dark regions.</p> </dd> <dt>
<code>w_edgefloat, optional</code> </dt>
<dd>
<p>Controls attraction to edges. Use negative values to repel snake from edges.</p> </dd> <dt>
<code>gammafloat, optional</code> </dt>
<dd>
<p>Explicit time stepping parameter.</p> </dd> <dt>
<code>max_px_movefloat, optional</code> </dt>
<dd>
<p>Maximum pixel distance to move per iteration.</p> </dd> <dt>
<code>max_iterationsint, optional</code> </dt>
<dd>
<p>Maximum iterations to optimize snake shape.</p> </dd> <dt>
<code>convergencefloat, optional</code> </dt>
<dd>
<p>Convergence criteria.</p> </dd> <dt>
<code>boundary_conditionstring, optional</code> </dt>
<dd>
<p>Boundary conditions for the contour. Can be one of ‘periodic’, ‘free’, ‘fixed’, ‘free-fixed’, or ‘fixed-free’. ‘periodic’ attaches the two ends of the snake, ‘fixed’ holds the end-points in place, and ‘free’ allows free movement of the ends. ‘fixed’ and ‘free’ can be combined by parsing ‘fixed-free’, ‘free-fixed’. Parsing ‘fixed-fixed’ or ‘free-free’ yields same behaviour as ‘fixed’ and ‘free’, respectively.</p> </dd> <dt>
<code>coordinates{‘rc’}, optional</code> </dt>
<dd>
<p>This option remains for compatibility purpose only and has no effect. It was introduced in 0.16 with the <code>'xy'</code> option, but since 0.18, only the <code>'rc'</code> option is valid. Coordinates must be set in a row-column format.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>snake(N, 2) ndarray</code> </dt>
<dd>
<p>Optimised snake, same shape as input parameter.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r094916d7e45d-1">
<code>1</code> </dt> <dd>
<p>Kass, M.; Witkin, A.; Terzopoulos, D. “Snakes: Active contour models”. International Journal of Computer Vision 1 (4): 321 (1988). <a class="reference external" href="https://doi.org/10.1007/BF00133570">DOI:10.1007/BF00133570</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle_perimeter
&gt;&gt;&gt; from skimage.filters import gaussian
</pre> <p>Create and smooth image:</p> <pre data-language="python">&gt;&gt;&gt; img = np.zeros((100, 100))
&gt;&gt;&gt; rr, cc = circle_perimeter(35, 45, 25)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img = gaussian(img, 2)
</pre> <p>Initialize spline:</p> <pre data-language="python">&gt;&gt;&gt; s = np.linspace(0, 2*np.pi, 100)
&gt;&gt;&gt; init = 50 * np.array([np.sin(s), np.cos(s)]).T + 50
</pre> <p>Fit spline to image:</p> <pre data-language="python">&gt;&gt;&gt; snake = active_contour(img, init, w_edge=0, w_line=1, coordinates='rc')  
&gt;&gt;&gt; dist = np.sqrt((45-snake[:, 0])**2 + (35-snake[:, 1])**2)  
&gt;&gt;&gt; int(np.mean(dist))  
25
</pre> </dd>
</dl>   <h2 id="chan-vese">chan_vese</h2> <dl class="function"> <dt id="skimage.segmentation.chan_vese">
<code>skimage.segmentation.chan_vese(image, mu=0.25, lambda1=1.0, lambda2=1.0, tol=0.001, max_iter=500, dt=0.5, init_level_set='checkerboard', extended_output=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_chan_vese.py#L170-L338"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Chan-Vese segmentation algorithm.</p> <p>Active contour model by evolving a level set. Can be used to segment objects without clearly defined boundaries.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Grayscale image to be segmented.</p> </dd> <dt>
<code>mufloat, optional</code> </dt>
<dd>
<p>‘edge length’ weight parameter. Higher <code>mu</code> values will produce a ‘round’ edge, while values closer to zero will detect smaller objects.</p> </dd> <dt>
<code>lambda1float, optional</code> </dt>
<dd>
<p>‘difference from average’ weight parameter for the output region with value ‘True’. If it is lower than <code>lambda2</code>, this region will have a larger range of values than the other.</p> </dd> <dt>
<code>lambda2float, optional</code> </dt>
<dd>
<p>‘difference from average’ weight parameter for the output region with value ‘False’. If it is lower than <code>lambda1</code>, this region will have a larger range of values than the other.</p> </dd> <dt>
<code>tolfloat, positive, optional</code> </dt>
<dd>
<p>Level set variation tolerance between iterations. If the L2 norm difference between the level sets of successive iterations normalized by the area of the image is below this value, the algorithm will assume that the solution was reached.</p> </dd> <dt>
<code>max_iteruint, optional</code> </dt>
<dd>
<p>Maximum number of iterations allowed before the algorithm interrupts itself.</p> </dd> <dt>
<code>dtfloat, optional</code> </dt>
<dd>
<p>A multiplication factor applied at calculations for each step, serves to accelerate the algorithm. While higher values may speed up the algorithm, they may also lead to convergence problems.</p> </dd> <dt>
<code>init_level_setstr or (M, N) ndarray, optional</code> </dt>
<dd>
<p>Defines the starting level set used by the algorithm. If a string is inputted, a level set that matches the image size will automatically be generated. Alternatively, it is possible to define a custom level set, which should be an array of float values, with the same shape as ‘image’. Accepted string values are as follows.</p> <dl class="simple"> <dt>‘checkerboard’</dt>
<dd>
<p>the starting level set is defined as sin(x/5*pi)*sin(y/5*pi), where x and y are pixel coordinates. This level set has fast convergence, but may fail to detect implicit edges.</p> </dd> <dt>‘disk’</dt>
<dd>
<p>the starting level set is defined as the opposite of the distance from the center of the image minus half of the minimum value between image width and image height. This is somewhat slower, but is more likely to properly detect implicit edges.</p> </dd> <dt>‘small disk’</dt>
<dd>
<p>the starting level set is defined as the opposite of the distance from the center of the image minus a quarter of the minimum value between image width and image height.</p> </dd> </dl> </dd> <dt>
<code>extended_outputbool, optional</code> </dt>
<dd>
<p>If set to True, the return value will be a tuple containing the three return values (see below). If set to False which is the default value, only the ‘segmentation’ array will be returned.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>segmentation(M, N) ndarray, bool</code> </dt>
<dd>
<p>Segmentation produced by the algorithm.</p> </dd> <dt>
<code>phi(M, N) ndarray of floats</code> </dt>
<dd>
<p>Final level set computed by the algorithm.</p> </dd> <dt>
<code>energieslist of floats</code> </dt>
<dd>
<p>Shows the evolution of the ‘energy’ for each step of the algorithm. This should allow to check whether the algorithm converged.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The Chan-Vese Algorithm is designed to segment objects without clearly defined boundaries. This algorithm is based on level sets that are evolved iteratively to minimize an energy, which is defined by weighted values corresponding to the sum of differences intensity from the average value outside the segmented region, the sum of differences from the average value inside the segmented region, and a term which is dependent on the length of the boundary of the segmented region.</p> <p>This algorithm was first proposed by Tony Chan and Luminita Vese, in a publication entitled “An Active Contour Model Without Edges” <a class="reference internal" href="#rb5da2c114fc8-1" id="id2">[1]</a>.</p> <p>This implementation of the algorithm is somewhat simplified in the sense that the area factor ‘nu’ described in the original paper is not implemented, and is only suitable for grayscale images.</p> <p>Typical values for <code>lambda1</code> and <code>lambda2</code> are 1. If the ‘background’ is very different from the segmented object in terms of distribution (for example, a uniform black image with figures of varying intensity), then these values should be different from each other.</p> <p>Typical values for mu are between 0 and 1, though higher values can be used when dealing with shapes with very ill-defined contours.</p> <p>The ‘energy’ which this algorithm tries to minimize is defined as the sum of the differences from the average within the region squared and weighed by the ‘lambda’ factors to which is added the length of the contour multiplied by the ‘mu’ factor.</p> <p>Supports 2D grayscale images only, and does not implement the area term described in the original article.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb5da2c114fc8-1">
<code>1</code> </dt> <dd>
<p>An Active Contour Model without Edges, Tony Chan and Luminita Vese, Scale-Space Theories in Computer Vision, 1999, <a class="reference external" href="https://doi.org/10.1007/3-540-48236-9_13">DOI:10.1007/3-540-48236-9_13</a></p> </dd> <dt class="label" id="rb5da2c114fc8-2">
<code>2</code> </dt> <dd>
<p>Chan-Vese Segmentation, Pascal Getreuer Image Processing On Line, 2 (2012), pp. 214-224, <a class="reference external" href="https://doi.org/10.5201/ipol.2012.g-cv">DOI:10.5201/ipol.2012.g-cv</a></p> </dd> <dt class="label" id="rb5da2c114fc8-3">
<code>3</code> </dt> <dd>
<p>The Chan-Vese Algorithm - Project Report, Rami Cohen, 2011 <a class="reference external" href="https://arxiv.org/abs/1107.2782">arXiv:1107.2782</a></p> </dd> </dl> </dd>
</dl>   <h2 id="checkerboard-level-set">checkerboard_level_set</h2> <dl class="function"> <dt id="skimage.segmentation.checkerboard_level_set">
<code>skimage.segmentation.checkerboard_level_set(image_shape, square_size=5)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L193-L221"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a checkerboard level set with binary values.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_shapetuple of positive integers</code> </dt>
<dd>
<p>Shape of the image.</p> </dd> <dt>
<code>square_sizeint, optional</code> </dt>
<dd>
<p>Size of the squares of the checkerboard. It defaults to 5.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outarray with shape image_shape</code> </dt>
<dd>
<p>Binary level set of the checkerboard.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.segmentation.circle_level_set" title="skimage.segmentation.circle_level_set"><code>circle_level_set</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="circle-level-set">circle_level_set</h2> <dl class="function"> <dt id="skimage.segmentation.circle_level_set">
<code>skimage.segmentation.circle_level_set(image_shape, center=None, radius=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L117-L153"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a circle level set with binary values.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_shapetuple of positive integers</code> </dt>
<dd>
<p>Shape of the image</p> </dd> <dt>
<code>centertuple of positive integers, optional</code> </dt>
<dd>
<p>Coordinates of the center of the circle given in (row, column). If not given, it defaults to the center of the image.</p> </dd> <dt>
<code>radiusfloat, optional</code> </dt>
<dd>
<p>Radius of the circle. If not given, it is set to the 75% of the smallest image dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outarray with shape image_shape</code> </dt>
<dd>
<p>Binary level set of the circle with the given <code>radius</code> and <code>center</code>.</p> </dd> </dl> </dd> <dt class="field-odd">Warns</dt> <dd class="field-odd">
<dl> <dt>Deprecated:</dt>
<dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span>This function is deprecated and will be removed in scikit-image 0.19. Please use the function named <code>disk_level_set</code> instead.</p> </div> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="clear-border">clear_border</h2> <dl class="function"> <dt id="skimage.segmentation.clear_border">
<code>skimage.segmentation.clear_border(labels, buffer_size=0, bgval=0, in_place=False, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_clear_border.py#L5-L106"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Clear objects connected to the label image border.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>labels(M[, N[, …, P]]) array of int or bool</code> </dt>
<dd>
<p>Imaging data labels.</p> </dd> <dt>
<code>buffer_sizeint, optional</code> </dt>
<dd>
<p>The width of the border examined. By default, only objects that touch the outside of the image are removed.</p> </dd> <dt>
<code>bgvalfloat or int, optional</code> </dt>
<dd>
<p>Cleared objects are set to this value.</p> </dd> <dt>
<code>in_placebool, optional</code> </dt>
<dd>
<p>Whether or not to manipulate the labels array in-place.</p> </dd> <dt>
<code>maskndarray of bool, same shape as image, optional.</code> </dt>
<dd>
<p>Image data mask. Objects in labels image overlapping with False pixels of mask will be removed. If defined, the argument buffer_size will be ignored.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(M[, N[, …, P]]) array</code> </dt>
<dd>
<p>Imaging data labels with cleared borders</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.segmentation import clear_border
&gt;&gt;&gt; labels = np.array([[0, 0, 0, 0, 0, 0, 0, 1, 0],
...                    [1, 1, 0, 0, 1, 0, 0, 1, 0],
...                    [1, 1, 0, 1, 0, 1, 0, 0, 0],
...                    [0, 0, 0, 1, 1, 1, 1, 0, 0],
...                    [0, 1, 1, 1, 1, 1, 1, 1, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; clear_border(labels)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 0, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]])
&gt;&gt;&gt; mask = np.array([[0, 0, 1, 1, 1, 1, 1, 1, 1],
...                  [0, 0, 1, 1, 1, 1, 1, 1, 1],
...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
...                  [1, 1, 1, 1, 1, 1, 1, 1, 1],
...                  [1, 1, 1, 1, 1, 1, 1, 1, 1]]).astype(bool)
&gt;&gt;&gt; clear_border(labels, mask=mask)
array([[0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0],
       [0, 0, 0, 1, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 0, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]])
</pre> </dd>
</dl>   <h2 id="disk-level-set">disk_level_set</h2> <dl class="function"> <dt id="skimage.segmentation.disk_level_set">
<code>skimage.segmentation.disk_level_set(image_shape, *, center=None, radius=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L156-L190"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Create a disk level set with binary values.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_shapetuple of positive integers</code> </dt>
<dd>
<p>Shape of the image</p> </dd> <dt>
<code>centertuple of positive integers, optional</code> </dt>
<dd>
<p>Coordinates of the center of the disk given in (row, column). If not given, it defaults to the center of the image.</p> </dd> <dt>
<code>radiusfloat, optional</code> </dt>
<dd>
<p>Radius of the disk. If not given, it is set to the 75% of the smallest image dimension.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outarray with shape image_shape</code> </dt>
<dd>
<p>Binary level set of the disk with the given <code>radius</code> and <code>center</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a>
</dt>
 </dl> </div> </dd>
</dl>   <h2 id="expand-labels">expand_labels</h2> <dl class="function"> <dt id="skimage.segmentation.expand_labels">
<code>skimage.segmentation.expand_labels(label_image, distance=1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_expand_labels.py#L16-L106"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Expand labels in label image by <code>distance</code> pixels without overlapping.</p> <p>Given a label image, <code>expand_labels</code> grows label regions (connected components) outwards by up to <code>distance</code> pixels without overflowing into neighboring regions. More specifically, each background pixel that is within Euclidean distance of &lt;= <code>distance</code> pixels of a connected component is assigned the label of that connected component. Where multiple connected components are within <code>distance</code> pixels of a background pixel, the label value of the closest connected component will be assigned (see Notes for the case of multiple labels at equal distance).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>label_imagendarray of dtype int</code> </dt>
<dd>
<p>label image</p> </dd> <dt>
<code>distancefloat</code> </dt>
<dd>
<p>Euclidean distance in pixels by which to grow the labels. Default is one.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>enlarged_labelsndarray of dtype int</code> </dt>
<dd>
<p>Labeled array, where all connected regions have been enlarged</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skimage.measure.label(), skimage.segmentation.watershed(),</code> <a class="reference internal" href="skimage.morphology.html#skimage.morphology.dilation" title="skimage.morphology.dilation"><code>skimage.morphology.dilation()</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>Where labels are spaced more than <code>distance</code> pixels are apart, this is equivalent to a morphological dilation with a disc or hyperball of radius <code>distance</code>. However, in contrast to a morphological dilation, <code>expand_labels</code> will not expand a label region into a neighboring region.</p> <p>This implementation of <code>expand_labels</code> is derived from CellProfiler <a class="reference internal" href="#r700ff08b53f4-1" id="id6">[1]</a>, where it is known as module “IdentifySecondaryObjects (Distance-N)” <a class="reference internal" href="#r700ff08b53f4-2" id="id7">[2]</a>.</p> <p>There is an important edge case when a pixel has the same distance to multiple regions, as it is not defined which region expands into that space. Here, the exact behavior depends on the upstream implementation of <code>scipy.ndimage.distance_transform_edt</code>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r700ff08b53f4-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://cellprofiler.org">https://cellprofiler.org</a></p> </dd> <dt class="label" id="r700ff08b53f4-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559">https://github.com/CellProfiler/CellProfiler/blob/082930ea95add7b72243a4fa3d39ae5145995e9c/cellprofiler/modules/identifysecondaryobjects.py#L559</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; labels = np.array([0, 1, 0, 0, 0, 0, 2])
&gt;&gt;&gt; expand_labels(labels, distance=1)
array([1, 1, 1, 0, 0, 2, 2])
</pre> <p>Labels will not overwrite each other:</p> <pre data-language="python">&gt;&gt;&gt; expand_labels(labels, distance=3)
array([1, 1, 1, 1, 2, 2, 2])
</pre> <p>In case of ties, behavior is undefined, but currently resolves to the label closest to <code>(0,) * ndim</code> in lexicographical order.</p> <pre data-language="python">&gt;&gt;&gt; labels_tied = np.array([0, 1, 0, 2, 0])
&gt;&gt;&gt; expand_labels(labels_tied, 1)
array([1, 1, 1, 2, 2])
&gt;&gt;&gt; labels2d = np.array(
...     [[0, 1, 0, 0],
...      [2, 0, 0, 0],
...      [0, 3, 0, 0]]
... )
&gt;&gt;&gt; expand_labels(labels2d, 1)
array([[2, 1, 1, 0],
       [2, 2, 0, 0],
       [2, 3, 3, 0]])
</pre> </dd>
</dl>   <h2 id="felzenszwalb">felzenszwalb</h2> <dl class="function"> <dt id="skimage.segmentation.felzenszwalb">
<code>skimage.segmentation.felzenszwalb(image, scale=1, sigma=0.8, min_size=20, multichannel=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_felzenszwalb.py#L6-L64"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Computes Felsenszwalb’s efficient graph based image segmentation.</p> <p>Produces an oversegmentation of a multichannel (i.e. RGB) image using a fast, minimum spanning tree based clustering on the image grid. The parameter <code>scale</code> sets an observation level. Higher scale means less and larger segments. <code>sigma</code> is the diameter of a Gaussian kernel, used for smoothing the image prior to segmentation.</p> <p>The number of produced segments as well as their size can only be controlled indirectly through <code>scale</code>. Segment size within an image can vary greatly depending on local contrast.</p> <p>For RGB images, the algorithm uses the euclidean distance between pixels in color space.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(width, height, 3) or (width, height) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>scalefloat</code> </dt>
<dd>
<p>Free parameter. Higher means larger clusters.</p> </dd> <dt>
<code>sigmafloat</code> </dt>
<dd>
<p>Width (standard deviation) of Gaussian kernel used in preprocessing.</p> </dd> <dt>
<code>min_sizeint</code> </dt>
<dd>
<p>Minimum component size. Enforced using postprocessing.</p> </dd> <dt>
<code>multichannelbool, optional (default: True)</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels. A value of False, for a 3D image, is not currently supported.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>segment_mask(width, height) ndarray</code> </dt>
<dd>
<p>Integer mask indicating segment labels.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The <code>k</code> parameter used in the original paper renamed to <code>scale</code> here.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r89864356f083-1">
<code>1</code> </dt> <dd>
<p>Efficient graph-based image segmentation, Felzenszwalb, P.F. and Huttenlocher, D.P. International Journal of Computer Vision, 2004</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.segmentation import felzenszwalb
&gt;&gt;&gt; from skimage.data import coffee
&gt;&gt;&gt; img = coffee()
&gt;&gt;&gt; segments = felzenszwalb(img, scale=3.0, sigma=0.95, min_size=5)
</pre> </dd>
</dl>   <h2 id="find-boundaries">find_boundaries</h2> <dl class="function"> <dt id="skimage.segmentation.find_boundaries">
<code>skimage.segmentation.find_boundaries(label_img, connectivity=1, mode='thick', background=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/boundaries.py#L48-L181"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return bool array where boundaries between labeled regions are True.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>label_imgarray of int or bool</code> </dt>
<dd>
<p>An array in which different regions are labeled with either different integers or boolean values.</p> </dd> <dt>
<code>connectivityint in {1, …, label_img.ndim}, optional</code> </dt>
<dd>
<p>A pixel is considered a boundary pixel if any of its neighbors has a different label. <code>connectivity</code> controls which pixels are considered neighbors. A connectivity of 1 (default) means pixels sharing an edge (in 2D) or a face (in 3D) will be considered neighbors. A connectivity of <code>label_img.ndim</code> means pixels sharing a corner will be considered neighbors.</p> </dd> <dt>
<code>modestring in {‘thick’, ‘inner’, ‘outer’, ‘subpixel’}</code> </dt>
<dd>
<p>How to mark the boundaries:</p> <ul class="simple"> <li>thick: any pixel not completely surrounded by pixels of the same label (defined by <code>connectivity</code>) is marked as a boundary. This results in boundaries that are 2 pixels thick.</li> <li>inner: outline the pixels <em>just inside</em> of objects, leaving background pixels untouched.</li> <li>outer: outline pixels in the background around object boundaries. When two objects touch, their boundary is also marked.</li> <li>subpixel: return a doubled image, with pixels <em>between</em> the original pixels marked as boundary where appropriate.</li> </ul> </dd> <dt>
<code>backgroundint, optional</code> </dt>
<dd>
<p>For modes ‘inner’ and ‘outer’, a definition of a background label is required. See <code>mode</code> for descriptions of these two.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>boundariesarray of bool, same shape as label_img</code> </dt>
<dd>
<p>A bool image where <code>True</code> represents a boundary pixel. For <code>mode</code> equal to ‘subpixel’, <code>boundaries.shape[i]</code> is equal to <code>2 * label_img.shape[i] - 1</code> for all <code>i</code> (a pixel is inserted in between all other pairs of pixels).</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; labels = np.array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 5, 5, 5, 0, 0],
...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
...                    [0, 0, 1, 1, 1, 5, 5, 5, 0, 0],
...                    [0, 0, 0, 0, 0, 5, 5, 5, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
...                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; find_boundaries(labels, mode='thick').astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 0, 1, 1, 0, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 0, 1, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; find_boundaries(labels, mode='inner').astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],
       [0, 0, 1, 0, 1, 1, 0, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; find_boundaries(labels, mode='outer').astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],
       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
       [0, 1, 0, 0, 1, 1, 0, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; labels_small = labels[::2, ::3]
&gt;&gt;&gt; labels_small
array([[0, 0, 0, 0],
       [0, 0, 5, 0],
       [0, 1, 5, 0],
       [0, 0, 5, 0],
       [0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; find_boundaries(labels_small, mode='subpixel').astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0],
       [0, 0, 0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0, 1, 0],
       [0, 1, 0, 1, 0, 1, 0],
       [0, 1, 1, 1, 0, 1, 0],
       [0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; bool_image = np.array([[False, False, False, False, False],
...                        [False, False, False, False, False],
...                        [False, False,  True,  True,  True],
...                        [False, False,  True,  True,  True],
...                        [False, False,  True,  True,  True]],
...                       dtype=bool)
&gt;&gt;&gt; find_boundaries(bool_image)
array([[False, False, False, False, False],
       [False, False,  True,  True,  True],
       [False,  True,  True,  True,  True],
       [False,  True,  True, False, False],
       [False,  True,  True, False, False]])
</pre> </dd>
</dl>   <h2 id="flood">flood</h2> <dl class="function"> <dt id="skimage.segmentation.flood">
<code>skimage.segmentation.flood(image, seed_point, *, selem=None, connectivity=None, tolerance=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_flood_fill.py#L124-L290"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Mask corresponding to a flood fill.</p> <p>Starting at a specific <code>seed_point</code>, connected points equal or within <code>tolerance</code> of the seed value are found.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>seed_pointtuple or int</code> </dt>
<dd>
<p>The point in <code>image</code> used as the starting point for the flood fill. If the image is 1D, this point may be given as an integer.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel. It must contain only 1’s and 0’s, have the same number of dimensions as <code>image</code>. If not given, all adjacent pixels are considered as part of the neighborhood (fully connected).</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is larger or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>tolerancefloat or int, optional</code> </dt>
<dd>
<p>If None (default), adjacent values must be strictly equal to the initial value of <code>image</code> at <code>seed_point</code>. This is fastest. If a value is given, a comparison will be done at every point and if within tolerance of the initial value will also be filled (inclusive).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>maskndarray</code> </dt>
<dd>
<p>A Boolean array with the same shape as <code>image</code> is returned, with True values for areas connected to and equal (or within tolerance of) the seed point. All other values are False.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many raster graphics programs. This function returns just the mask representing the fill.</p> <p>If indices are desired rather than masks for memory reasons, the user can simply run <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.19)"><code>numpy.nonzero</code></a> on the result, save the indices, and discard this mask.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import flood
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = 1
&gt;&gt;&gt; image[3, 0] = 1
&gt;&gt;&gt; image[1:3, 4:6] = 2
&gt;&gt;&gt; image[3, 6] = 3
&gt;&gt;&gt; image
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, with full connectivity (diagonals included):</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (1, 1))
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [5, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (1, 1), connectivity=1)
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill with a tolerance:</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (0, 0), tolerance=1)
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[5, 5, 5, 5, 5, 5, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 5, 5, 3]])
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-segmentation-flood">Examples using <code>skimage.segmentation.flood</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id32"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>   <h2 id="flood-fill">flood_fill</h2> <dl class="function"> <dt id="skimage.segmentation.flood_fill">
<code>skimage.segmentation.flood_fill(image, seed_point, new_value, *, selem=None, connectivity=None, tolerance=None, in_place=False, inplace=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_flood_fill.py#L15-L121"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform flood filling on an image.</p> <p>Starting at a specific <code>seed_point</code>, connected points equal or within <code>tolerance</code> of the seed value are found, then set to <code>new_value</code>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>seed_pointtuple or int</code> </dt>
<dd>
<p>The point in <code>image</code> used as the starting point for the flood fill. If the image is 1D, this point may be given as an integer.</p> </dd> <dt>
<code>new_valueimage type</code> </dt>
<dd>
<p>New value to set the entire fill. This must be chosen in agreement with the dtype of <code>image</code>.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel. It must contain only 1’s and 0’s, have the same number of dimensions as <code>image</code>. If not given, all adjacent pixels are considered as part of the neighborhood (fully connected).</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is less than or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>tolerancefloat or int, optional</code> </dt>
<dd>
<p>If None (default), adjacent values must be strictly equal to the value of <code>image</code> at <code>seed_point</code> to be filled. This is fastest. If a tolerance is provided, adjacent points with values within plus or minus tolerance from the seed point are filled (inclusive).</p> </dd> <dt>
<code>in_placebool, optional</code> </dt>
<dd>
<p>If True, flood filling is applied to <code>image</code> in place. If False, the flood filled result is returned without modifying the input <code>image</code> (default).</p> </dd> <dt>
<code>inplacebool, optional</code> </dt>
<dd>
<p>This parameter is deprecated and will be removed in version 0.19.0 in favor of in_place. If True, flood filling is applied to <code>image</code> inplace. If False, the flood filled result is returned without modifying the input <code>image</code> (default).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>filledndarray</code> </dt>
<dd>
<p>An array with the same shape as <code>image</code> is returned, with values in areas connected to and equal (or within tolerance of) the seed point replaced with <code>new_value</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many raster graphics programs.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import flood_fill
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = 1
&gt;&gt;&gt; image[3, 0] = 1
&gt;&gt;&gt; image[1:3, 4:6] = 2
&gt;&gt;&gt; image[3, 6] = 3
&gt;&gt;&gt; image
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, with full connectivity (diagonals included):</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (1, 1), 5)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [5, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (1, 1), 5, connectivity=1)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill with a tolerance:</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (0, 0), 5, tolerance=1)
array([[5, 5, 5, 5, 5, 5, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 5, 5, 3]])
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-segmentation-flood-fill">Examples using <code>skimage.segmentation.flood_fill</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id33"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>   <h2 id="inverse-gaussian-gradient">inverse_gaussian_gradient</h2> <dl class="function"> <dt id="skimage.segmentation.inverse_gaussian_gradient">
<code>skimage.segmentation.inverse_gaussian_gradient(image, alpha=100.0, sigma=5.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L224-L253"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Inverse of gradient magnitude.</p> <p>Compute the magnitude of the gradients in the image and then inverts the result in the range [0, 1]. Flat areas are assigned values close to 1, while areas close to borders are assigned values close to 0.</p> <p>This function or a similar one defined by the user should be applied over the image as a preprocessing step before calling <a class="reference internal" href="#skimage.segmentation.morphological_geodesic_active_contour" title="skimage.segmentation.morphological_geodesic_active_contour"><code>morphological_geodesic_active_contour</code></a>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Grayscale image or volume.</p> </dd> <dt>
<code>alphafloat, optional</code> </dt>
<dd>
<p>Controls the steepness of the inversion. A larger value will make the transition between the flat areas and border areas steeper in the resulting array.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Standard deviation of the Gaussian filter applied over the image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>gimage(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Preprocessed image (or volume) suitable for <a class="reference internal" href="#skimage.segmentation.morphological_geodesic_active_contour" title="skimage.segmentation.morphological_geodesic_active_contour"><code>morphological_geodesic_active_contour</code></a>.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="join-segmentations">join_segmentations</h2> <dl class="function"> <dt id="skimage.segmentation.join_segmentations">
<code>skimage.segmentation.join_segmentations(s1, s2)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_join.py#L5-L43"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the join of the two input segmentations.</p> <p>The join J of S1 and S2 is defined as the segmentation in which two voxels are in the same segment if and only if they are in the same segment in <em>both</em> S1 and S2.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>s1, s2numpy arrays</code> </dt>
<dd>
<p>s1 and s2 are label fields of the same shape.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>jnumpy array</code> </dt>
<dd>
<p>The join segmentation of s1 and s2.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.segmentation import join_segmentations
&gt;&gt;&gt; s1 = np.array([[0, 0, 1, 1],
...                [0, 2, 1, 1],
...                [2, 2, 2, 1]])
&gt;&gt;&gt; s2 = np.array([[0, 1, 1, 0],
...                [0, 1, 1, 0],
...                [0, 1, 1, 1]])
&gt;&gt;&gt; join_segmentations(s1, s2)
array([[0, 1, 3, 2],
       [0, 5, 3, 2],
       [4, 5, 5, 3]])
</pre> </dd>
</dl>   <h2 id="mark-boundaries">mark_boundaries</h2> <dl class="function"> <dt id="skimage.segmentation.mark_boundaries">
<code>skimage.segmentation.mark_boundaries(image, label_img, color=(1, 1, 0), outline_color=None, mode='outer', background_label=0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/boundaries.py#L184-L231"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return image with boundaries between labeled regions highlighted.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N[, 3]) array</code> </dt>
<dd>
<p>Grayscale or RGB image.</p> </dd> <dt>
<code>label_img(M, N) array of int</code> </dt>
<dd>
<p>Label array where regions are marked by different integer values.</p> </dd> <dt>
<code>colorlength-3 sequence, optional</code> </dt>
<dd>
<p>RGB color of boundaries in the output image.</p> </dd> <dt>
<code>outline_colorlength-3 sequence, optional</code> </dt>
<dd>
<p>RGB color surrounding boundaries in the output image. If None, no outline is drawn.</p> </dd> <dt>
<code>modestring in {‘thick’, ‘inner’, ‘outer’, ‘subpixel’}, optional</code> </dt>
<dd>
<p>The mode for finding boundaries.</p> </dd> <dt>
<code>background_labelint, optional</code> </dt>
<dd>
<p>Which label to consider background (this is only useful for modes <code>inner</code> and <code>outer</code>).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>marked(M, N, 3) array of float</code> </dt>
<dd>
<p>An image in which the boundaries between labels are superimposed on the original image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.segmentation.find_boundaries" title="skimage.segmentation.find_boundaries"><code>find_boundaries</code></a>
</dt>
 </dl> </div> </dd>
</dl>  <h3 id="examples-using-skimage-segmentation-mark-boundaries">Examples using <code>skimage.segmentation.mark_boundaries</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="A pixel-based segmentation is computed here using local features based on local intensity, edge...">
<div class="figure align-default" id="id34"> <img alt="Trainable segmentation using local features and random forests" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_trainable_segmentation.html#sphx-glr-auto-examples-segmentation-plot-trainable-segmentation-py"><span class="std std-ref">Trainable segmentation using local features and random forests</span></a></span></p> </div> </div>   <h2 id="morphological-chan-vese">morphological_chan_vese</h2> <dl class="function"> <dt id="skimage.segmentation.morphological_chan_vese">
<code>skimage.segmentation.morphological_chan_vese(image, iterations, init_level_set='checkerboard', smoothing=1, lambda1=1, lambda2=1, iter_callback=&lt;function &lt;lambda&gt;&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L256-L356"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Morphological Active Contours without Edges (MorphACWE)</p> <p>Active contours without edges implemented with morphological operators. It can be used to segment objects in images and volumes without well defined borders. It is required that the inside of the object looks different on average than the outside (i.e., the inner area of the object should be darker or lighter than the outer area on average).</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Grayscale image or volume to be segmented.</p> </dd> <dt>
<code>iterationsuint</code> </dt>
<dd>
<p>Number of iterations to run</p> </dd> <dt>
<code>init_level_setstr, (M, N) array, or (L, M, N) array</code> </dt>
<dd>
<p>Initial level set. If an array is given, it will be binarized and used as the initial level set. If a string is given, it defines the method to generate a reasonable initial level set with the shape of the <code>image</code>. Accepted values are ‘checkerboard’ and ‘circle’. See the documentation of <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a> and <a class="reference internal" href="#skimage.segmentation.circle_level_set" title="skimage.segmentation.circle_level_set"><code>circle_level_set</code></a> respectively for details about how these level sets are created.</p> </dd> <dt>
<code>smoothinguint, optional</code> </dt>
<dd>
<p>Number of times the smoothing operator is applied per iteration. Reasonable values are around 1-4. Larger values lead to smoother segmentations.</p> </dd> <dt>
<code>lambda1float, optional</code> </dt>
<dd>
<p>Weight parameter for the outer region. If <code>lambda1</code> is larger than <code>lambda2</code>, the outer region will contain a larger range of values than the inner region.</p> </dd> <dt>
<code>lambda2float, optional</code> </dt>
<dd>
<p>Weight parameter for the inner region. If <code>lambda2</code> is larger than <code>lambda1</code>, the inner region will contain a larger range of values than the outer region.</p> </dd> <dt>
<code>iter_callbackfunction, optional</code> </dt>
<dd>
<p>If given, this function is called once per iteration with the current level set as the only argument. This is useful for debugging or for plotting intermediate results during the evolution.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Final segmentation (i.e., the final level set)</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>circle_level_set,</code> <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This is a version of the Chan-Vese algorithm that uses morphological operators instead of solving a partial differential equation (PDE) for the evolution of the contour. The set of morphological operators used in this algorithm are proved to be infinitesimally equivalent to the Chan-Vese PDE (see <a class="reference internal" href="#r81c856a3d0d3-1" id="id11">[1]</a>). However, morphological operators are do not suffer from the numerical stability issues typically found in PDEs (it is not necessary to find the right time step for the evolution), and are computationally faster.</p> <p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#r81c856a3d0d3-1" id="id12">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r81c856a3d0d3-1">
<code>1(1,2)</code> </dt> <dd>
<p>A Morphological Approach to Curvature-based Evolution of Curves and Surfaces, Pablo Márquez-Neila, Luis Baumela, Luis Álvarez. In IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), 2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p> </dd> </dl> </dd>
</dl>   <h2 id="morphological-geodesic-active-contour">morphological_geodesic_active_contour</h2> <dl class="function"> <dt id="skimage.segmentation.morphological_geodesic_active_contour">
<code>skimage.segmentation.morphological_geodesic_active_contour(gimage, iterations, init_level_set='circle', smoothing=1, threshold='auto', balloon=0, iter_callback=&lt;function &lt;lambda&gt;&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/morphsnakes.py#L359-L482"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Morphological Geodesic Active Contours (MorphGAC).</p> <p>Geodesic active contours implemented with morphological operators. It can be used to segment objects with visible but noisy, cluttered, broken borders.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>gimage(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Preprocessed image or volume to be segmented. This is very rarely the original image. Instead, this is usually a preprocessed version of the original image that enhances and highlights the borders (or other structures) of the object to segment. <a class="reference internal" href="#skimage.segmentation.morphological_geodesic_active_contour" title="skimage.segmentation.morphological_geodesic_active_contour"><code>morphological_geodesic_active_contour</code></a> will try to stop the contour evolution in areas where <code>gimage</code> is small. See <code>morphsnakes.inverse_gaussian_gradient</code> as an example function to perform this preprocessing. Note that the quality of <a class="reference internal" href="#skimage.segmentation.morphological_geodesic_active_contour" title="skimage.segmentation.morphological_geodesic_active_contour"><code>morphological_geodesic_active_contour</code></a> might greatly depend on this preprocessing.</p> </dd> <dt>
<code>iterationsuint</code> </dt>
<dd>
<p>Number of iterations to run.</p> </dd> <dt>
<code>init_level_setstr, (M, N) array, or (L, M, N) array</code> </dt>
<dd>
<p>Initial level set. If an array is given, it will be binarized and used as the initial level set. If a string is given, it defines the method to generate a reasonable initial level set with the shape of the <code>image</code>. Accepted values are ‘checkerboard’ and ‘circle’. See the documentation of <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a> and <a class="reference internal" href="#skimage.segmentation.circle_level_set" title="skimage.segmentation.circle_level_set"><code>circle_level_set</code></a> respectively for details about how these level sets are created.</p> </dd> <dt>
<code>smoothinguint, optional</code> </dt>
<dd>
<p>Number of times the smoothing operator is applied per iteration. Reasonable values are around 1-4. Larger values lead to smoother segmentations.</p> </dd> <dt>
<code>thresholdfloat, optional</code> </dt>
<dd>
<p>Areas of the image with a value smaller than this threshold will be considered borders. The evolution of the contour will stop in this areas.</p> </dd> <dt>
<code>balloonfloat, optional</code> </dt>
<dd>
<p>Balloon force to guide the contour in non-informative areas of the image, i.e., areas where the gradient of the image is too small to push the contour towards a border. A negative value will shrink the contour, while a positive value will expand the contour in these areas. Setting this to zero will disable the balloon force.</p> </dd> <dt>
<code>iter_callbackfunction, optional</code> </dt>
<dd>
<p>If given, this function is called once per iteration with the current level set as the only argument. This is useful for debugging or for plotting intermediate results during the evolution.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>out(M, N) or (L, M, N) array</code> </dt>
<dd>
<p>Final segmentation (i.e., the final level set)</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>inverse_gaussian_gradient, circle_level_set,</code> <a class="reference internal" href="#skimage.segmentation.checkerboard_level_set" title="skimage.segmentation.checkerboard_level_set"><code>checkerboard_level_set</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This is a version of the Geodesic Active Contours (GAC) algorithm that uses morphological operators instead of solving partial differential equations (PDEs) for the evolution of the contour. The set of morphological operators used in this algorithm are proved to be infinitesimally equivalent to the GAC PDEs (see <a class="reference internal" href="#rb6daaf5d7730-1" id="id14">[1]</a>). However, morphological operators are do not suffer from the numerical stability issues typically found in PDEs (e.g., it is not necessary to find the right time step for the evolution), and are computationally faster.</p> <p>The algorithm and its theoretical derivation are described in <a class="reference internal" href="#rb6daaf5d7730-1" id="id15">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb6daaf5d7730-1">
<code>1(1,2)</code> </dt> <dd>
<p>A Morphological Approach to Curvature-based Evolution of Curves and Surfaces, Pablo Márquez-Neila, Luis Baumela, Luis Álvarez. In IEEE Transactions on Pattern Analysis and Machine Intelligence (PAMI), 2014, <a class="reference external" href="https://doi.org/10.1109/TPAMI.2013.106">DOI:10.1109/TPAMI.2013.106</a></p> </dd> </dl> </dd>
</dl>   <h2 id="quickshift">quickshift</h2> <dl class="function"> <dt id="skimage.segmentation.quickshift">
<code>skimage.segmentation.quickshift(image, ratio=1.0, kernel_size=5, max_dist=10, return_tree=False, sigma=0, convert2lab=True, random_seed=42)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_quickshift.py#L11-L74"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Segments image using quickshift clustering in Color-(x,y) space.</p> <p>Produces an oversegmentation of the image using the quickshift mode-seeking algorithm.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(width, height, channels) ndarray</code> </dt>
<dd>
<p>Input image.</p> </dd> <dt>
<code>ratiofloat, optional, between 0 and 1</code> </dt>
<dd>
<p>Balances color-space proximity and image-space proximity. Higher values give more weight to color-space.</p> </dd> <dt>
<code>kernel_sizefloat, optional</code> </dt>
<dd>
<p>Width of Gaussian kernel used in smoothing the sample density. Higher means fewer clusters.</p> </dd> <dt>
<code>max_distfloat, optional</code> </dt>
<dd>
<p>Cut-off point for data distances. Higher means fewer clusters.</p> </dd> <dt>
<code>return_treebool, optional</code> </dt>
<dd>
<p>Whether to return the full segmentation hierarchy tree and distances.</p> </dd> <dt>
<code>sigmafloat, optional</code> </dt>
<dd>
<p>Width for Gaussian smoothing as preprocessing. Zero means no smoothing.</p> </dd> <dt>
<code>convert2labbool, optional</code> </dt>
<dd>
<p>Whether the input should be converted to Lab colorspace prior to segmentation. For this purpose, the input is assumed to be RGB.</p> </dd> <dt>
<code>random_seedint, optional</code> </dt>
<dd>
<p>Random seed used for breaking ties.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>segment_mask(width, height) ndarray</code> </dt>
<dd>
<p>Integer mask indicating segment labels.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The authors advocate to convert the image to Lab color space prior to segmentation, though this is not strictly necessary. For this to work, the image must be given in RGB format.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r7604e01a2c85-1">
<code>1</code> </dt> <dd>
<p>Quick shift and kernel methods for mode seeking, Vedaldi, A. and Soatto, S. European Conference on Computer Vision, 2008</p> </dd> </dl> </dd>
</dl>   <h2 id="random-walker">random_walker</h2> <dl class="function"> <dt id="skimage.segmentation.random_walker">
<code>skimage.segmentation.random_walker(data, labels, beta=130, mode='cg_j', tol=0.001, copy=True, multichannel=False, return_full_prob=False, spacing=None, *, prob_tol=0.001)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/random_walker_segmentation.py#L266-L514"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Random walker algorithm for segmentation from markers.</p> <p>Random walker algorithm is implemented for gray-level or multichannel images.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>dataarray_like</code> </dt>
<dd>
<p>Image to be segmented in phases. Gray-level <code>data</code> can be two- or three-dimensional; multichannel data can be three- or four- dimensional (multichannel=True) with the highest dimension denoting channels. Data spacing is assumed isotropic unless the <code>spacing</code> keyword argument is used.</p> </dd> <dt>
<code>labelsarray of ints, of same shape as data without channels dimension</code> </dt>
<dd>
<p>Array of seed markers labeled with different positive integers for different phases. Zero-labeled pixels are unlabeled pixels. Negative labels correspond to inactive pixels that are not taken into account (they are removed from the graph). If labels are not consecutive integers, the labels array will be transformed so that labels are consecutive. In the multichannel case, <code>labels</code> should have the same shape as a single channel of <code>data</code>, i.e. without the final dimension denoting channels.</p> </dd> <dt>
<code>betafloat, optional</code> </dt>
<dd>
<p>Penalization coefficient for the random walker motion (the greater <code>beta</code>, the more difficult the diffusion).</p> </dd> <dt>
<code>modestring, available options {‘cg’, ‘cg_j’, ‘cg_mg’, ‘bf’}</code> </dt>
<dd>
<p>Mode for solving the linear system in the random walker algorithm.</p> <ul class="simple"> <li>‘bf’ (brute force): an LU factorization of the Laplacian is computed. This is fast for small images (&lt;1024x1024), but very slow and memory-intensive for large images (e.g., 3-D volumes).</li> <li>‘cg’ (conjugate gradient): the linear system is solved iteratively using the Conjugate Gradient method from scipy.sparse.linalg. This is less memory-consuming than the brute force method for large images, but it is quite slow.</li> <li>‘cg_j’ (conjugate gradient with Jacobi preconditionner): the Jacobi preconditionner is applyed during the Conjugate gradient method iterations. This may accelerate the convergence of the ‘cg’ method.</li> <li>‘cg_mg’ (conjugate gradient with multigrid preconditioner): a preconditioner is computed using a multigrid solver, then the solution is computed with the Conjugate Gradient method. This mode requires that the pyamg module is installed.</li> </ul> </dd> <dt>
<code>tolfloat, optional</code> </dt>
<dd>
<p>Tolerance to achieve when solving the linear system using the conjugate gradient based modes (‘cg’, ‘cg_j’ and ‘cg_mg’).</p> </dd> <dt>
<code>copybool, optional</code> </dt>
<dd>
<p>If copy is False, the <code>labels</code> array will be overwritten with the result of the segmentation. Use copy=False if you want to save on memory.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>If True, input data is parsed as multichannel data (see ‘data’ above for proper input format in this case).</p> </dd> <dt>
<code>return_full_probbool, optional</code> </dt>
<dd>
<p>If True, the probability that a pixel belongs to each of the labels will be returned, instead of only the most likely label.</p> </dd> <dt>
<code>spacingiterable of floats, optional</code> </dt>
<dd>
<p>Spacing between voxels in each spatial dimension. If <code>None</code>, then the spacing between pixels/voxels in each dimension is assumed 1.</p> </dd> <dt>
<code>prob_tolfloat, optional</code> </dt>
<dd>
<p>Tolerance on the resulting probability to be in the interval [0, 1]. If the tolerance is not satisfied, a warning is displayed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<ul class="simple"> <li>If <code>return_full_prob</code> is False, array of ints of same shape and data type as <code>labels</code>, in which each pixel has been labeled according to the marker that reached the pixel first by anisotropic diffusion.</li> <li>If <code>return_full_prob</code> is True, array of floats of shape <code>(nlabels, labels.shape)</code>. <code>output[label_nb, i, j]</code> is the probability that label <code>label_nb</code> reaches the pixel <code>(i, j)</code> first.</li> </ul> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="skimage.morphology.html#skimage.morphology.watershed" title="skimage.morphology.watershed"><code>skimage.morphology.watershed</code></a>
</dt>
<dd>
<p>watershed segmentation A segmentation algorithm based on mathematical morphology and “flooding” of regions from markers.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>Multichannel inputs are scaled with all channel data combined. Ensure all channels are separately normalized prior to running this algorithm.</p> <p>The <code>spacing</code> argument is specifically for anisotropic datasets, where data points are spaced differently in one or more spatial dimensions. Anisotropic data is commonly encountered in medical imaging.</p> <p>The algorithm was first proposed in <a class="reference internal" href="#raf7f6bdcab09-1" id="id18">[1]</a>.</p> <p>The algorithm solves the diffusion equation at infinite times for sources placed on markers of each phase in turn. A pixel is labeled with the phase that has the greatest probability to diffuse first to the pixel.</p> <p>The diffusion equation is solved by minimizing x.T L x for each phase, where L is the Laplacian of the weighted graph of the image, and x is the probability that a marker of the given phase arrives first at a pixel by diffusion (x=1 on markers of the phase, x=0 on the other markers, and the other coefficients are looked for). Each pixel is attributed the label for which it has a maximal value of x. The Laplacian L of the image is defined as:</p>  <ul class="simple"> <li>L_ii = d_i, the number of neighbors of pixel i (the degree of i)</li> <li>L_ij = -w_ij if i and j are adjacent pixels</li> </ul>  <p>The weight w_ij is a decreasing function of the norm of the local gradient. This ensures that diffusion is easier between pixels of similar values.</p> <p>When the Laplacian is decomposed into blocks of marked and unmarked pixels:</p> <pre data-language="python">L = M B.T
    B A
</pre> <p>with first indices corresponding to marked pixels, and then to unmarked pixels, minimizing x.T L x for one phase amount to solving:</p> <pre data-language="python">A x = - B x_m
</pre> <p>where x_m = 1 on markers of the given phase, and 0 on other markers. This linear system is solved in the algorithm using a direct method for small images, and an iterative method for larger images.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="raf7f6bdcab09-1">
<code>1</code> </dt> <dd>
<p>Leo Grady, Random walks for image segmentation, IEEE Trans Pattern Anal Mach Intell. 2006 Nov;28(11):1768-83. <a class="reference external" href="https://doi.org/10.1109/TPAMI.2006.233">DOI:10.1109/TPAMI.2006.233</a>.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; np.random.seed(0)
&gt;&gt;&gt; a = np.zeros((10, 10)) + 0.2 * np.random.rand(10, 10)
&gt;&gt;&gt; a[5:8, 5:8] += 1
&gt;&gt;&gt; b = np.zeros_like(a, dtype=np.int32)
&gt;&gt;&gt; b[3, 3] = 1  # Marker for first phase
&gt;&gt;&gt; b[6, 6] = 2  # Marker for second phase
&gt;&gt;&gt; random_walker(a, b)
array([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 2, 2, 2, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]], dtype=int32)
</pre> </dd>
</dl>   <h2 id="relabel-sequential">relabel_sequential</h2> <dl class="function"> <dt id="skimage.segmentation.relabel_sequential">
<code>skimage.segmentation.relabel_sequential(label_field, offset=1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_join.py#L46-L154"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Relabel arbitrary labels to {<code>offset</code>, … <code>offset</code> + number_of_labels}.</p> <p>This function also returns the forward map (mapping the original labels to the reduced labels) and the inverse map (mapping the reduced labels back to the original ones).</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>label_fieldnumpy array of int, arbitrary shape</code> </dt>
<dd>
<p>An array of labels, which must be non-negative integers.</p> </dd> <dt>
<code>offsetint, optional</code> </dt>
<dd>
<p>The return labels will start at <code>offset</code>, which should be strictly positive.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>relabelednumpy array of int, same shape as label_field</code> </dt>
<dd>
<p>The input label field with labels mapped to {offset, …, number_of_labels + offset - 1}. The data type will be the same as <code>label_field</code>, except when offset + number_of_labels causes overflow of the current data type.</p> </dd> <dt>
<code>forward_mapArrayMap</code> </dt>
<dd>
<p>The map from the original label space to the returned label space. Can be used to re-apply the same mapping. See examples for usage. The output data type will be the same as <code>relabeled</code>.</p> </dd> <dt>
<code>inverse_mapArrayMap</code> </dt>
<dd>
<p>The map from the new label space to the original space. This can be used to reconstruct the original label field from the relabeled one. The output data type will be the same as <code>label_field</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The label 0 is assumed to denote the background and is never remapped.</p> <p>The forward map can be extremely big for some inputs, since its length is given by the maximum of the label field. However, in most situations, <code>label_field.max()</code> is much smaller than <code>label_field.size</code>, and in these cases the forward map is guaranteed to be smaller than either the input or output images.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.segmentation import relabel_sequential
&gt;&gt;&gt; label_field = np.array([1, 1, 5, 5, 8, 99, 42])
&gt;&gt;&gt; relab, fw, inv = relabel_sequential(label_field)
&gt;&gt;&gt; relab
array([1, 1, 2, 2, 3, 5, 4])
&gt;&gt;&gt; print(fw)
ArrayMap:
  1 → 1
  5 → 2
  8 → 3
  42 → 4
  99 → 5
&gt;&gt;&gt; np.array(fw)
array([0, 1, 0, 0, 0, 2, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5])
&gt;&gt;&gt; np.array(inv)
array([ 0,  1,  5,  8, 42, 99])
&gt;&gt;&gt; (fw[label_field] == relab).all()
True
&gt;&gt;&gt; (inv[relab] == label_field).all()
True
&gt;&gt;&gt; relab, fw, inv = relabel_sequential(label_field, offset=5)
&gt;&gt;&gt; relab
array([5, 5, 6, 6, 7, 9, 8])
</pre> </dd>
</dl>   <h2 id="slic">slic</h2> <dl class="function"> <dt id="skimage.segmentation.slic">
<code>skimage.segmentation.slic(image, n_segments=100, compactness=10.0, max_iter=10, sigma=0, spacing=None, multichannel=True, convert2lab=None, enforce_connectivity=True, min_size_factor=0.5, max_size_factor=3, slic_zero=False, start_label=None, mask=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/slic_superpixels.py#L107-L333"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Segments image using k-means clustering in Color-(x,y,z) space.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image2D, 3D or 4D ndarray</code> </dt>
<dd>
<p>Input image, which can be 2D or 3D, and grayscale or multichannel (see <code>multichannel</code> parameter). Input image must either be NaN-free or the NaN’s must be masked out</p> </dd> <dt>
<code>n_segmentsint, optional</code> </dt>
<dd>
<p>The (approximate) number of labels in the segmented output image.</p> </dd> <dt>
<code>compactnessfloat, optional</code> </dt>
<dd>
<p>Balances color proximity and space proximity. Higher values give more weight to space proximity, making superpixel shapes more square/cubic. In SLICO mode, this is the initial compactness. This parameter depends strongly on image contrast and on the shapes of objects in the image. We recommend exploring possible values on a log scale, e.g., 0.01, 0.1, 1, 10, 100, before refining around a chosen value.</p> </dd> <dt>
<code>max_iterint, optional</code> </dt>
<dd>
<p>Maximum number of iterations of k-means.</p> </dd> <dt>
<code>sigmafloat or (3,) array-like of floats, optional</code> </dt>
<dd>
<p>Width of Gaussian smoothing kernel for pre-processing for each dimension of the image. The same sigma is applied to each dimension in case of a scalar value. Zero means no smoothing. Note, that <code>sigma</code> is automatically scaled if it is scalar and a manual voxel spacing is provided (see Notes section).</p> </dd> <dt>
<code>spacing(3,) array-like of floats, optional</code> </dt>
<dd>
<p>The voxel spacing along each image dimension. By default, <a class="reference internal" href="#skimage.segmentation.slic" title="skimage.segmentation.slic"><code>slic</code></a> assumes uniform spacing (same voxel resolution along z, y and x). This parameter controls the weights of the distances along z, y, and x during k-means clustering.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>Whether the last axis of the image is to be interpreted as multiple channels or another spatial dimension.</p> </dd> <dt>
<code>convert2labbool, optional</code> </dt>
<dd>
<p>Whether the input should be converted to Lab colorspace prior to segmentation. The input image <em>must</em> be RGB. Highly recommended. This option defaults to <code>True</code> when <code>multichannel=True</code> <em>and</em> <code>image.shape[-1] == 3</code>.</p> </dd> <dt>
<code>enforce_connectivitybool, optional</code> </dt>
<dd>
<p>Whether the generated segments are connected or not</p> </dd> <dt>
<code>min_size_factorfloat, optional</code> </dt>
<dd>
<p>Proportion of the minimum segment size to be removed with respect to the supposed segment size <code>`depth*width*height/n_segments`</code></p> </dd> <dt>
<code>max_size_factorfloat, optional</code> </dt>
<dd>
<p>Proportion of the maximum connected segment size. A value of 3 works in most of the cases.</p> </dd> <dt>
<code>slic_zerobool, optional</code> </dt>
<dd>
<p>Run SLIC-zero, the zero-parameter mode of SLIC. <a class="reference internal" href="#rbeb231216055-2" id="id20">[2]</a></p> </dd> <dt><strong>start_label: int, optional</strong></dt>
<dd>
<p>The labels’ index start. Should be 0 or 1.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span><code>start_label</code> was introduced in 0.17</p> </div> </dd> <dt>
<code>mask2D ndarray, optional</code> </dt>
<dd>
<p>If provided, superpixels are computed only where mask is True, and seed points are homogeneously distributed over the mask using a K-means clustering strategy.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span><code>mask</code> was introduced in 0.17</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>labels2D or 3D array</code> </dt>
<dd>
<p>Integer mask indicating segment labels.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>ValueError</dt>
<dd>
<p>If <code>convert2lab</code> is set to <code>True</code> but the last array dimension is not of length 3.</p> </dd> <dt>ValueError</dt>
<dd>
<p>If <code>start_label</code> is not 0 or 1.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <ul class="simple"> <li>If <code>sigma &gt; 0</code>, the image is smoothed using a Gaussian kernel prior to segmentation.</li> <li>If <code>sigma</code> is scalar and <code>spacing</code> is provided, the kernel width is divided along each dimension by the spacing. For example, if <code>sigma=1</code> and <code>spacing=[5, 1, 1]</code>, the effective <code>sigma</code> is <code>[0.2, 1, 1]</code>. This ensures sensible smoothing for anisotropic images.</li> <li>The image is rescaled to be in [0, 1] prior to processing.</li> <li>Images of shape (M, N, 3) are interpreted as 2D RGB images by default. To interpret them as 3D with the last dimension having length 3, use <code>multichannel=False</code>.</li> <li>
<code>start_label</code> is introduced to handle the issue <a class="reference internal" href="#rbeb231216055-4" id="id21">[4]</a>. The labels indexing starting at 0 will be deprecated in future versions. If <code>mask</code> is not <code>None</code> labels indexing starts at 1 and masked area is set to 0.</li> </ul> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rbeb231216055-1">
<code>1</code> </dt> <dd>
<p>Radhakrishna Achanta, Appu Shaji, Kevin Smith, Aurelien Lucchi, Pascal Fua, and Sabine Süsstrunk, SLIC Superpixels Compared to State-of-the-art Superpixel Methods, TPAMI, May 2012. <a class="reference external" href="https://doi.org/10.1109/TPAMI.2012.120">DOI:10.1109/TPAMI.2012.120</a></p> </dd> <dt class="label" id="rbeb231216055-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO">https://www.epfl.ch/labs/ivrl/research/slic-superpixels/#SLICO</a></p> </dd> <dt class="label" id="rbeb231216055-3">
<code>3</code> </dt> <dd>
<p>Irving, Benjamin. “maskSLIC: regional superpixel generation with application to local pathology characterisation in medical images.”, 2016, <a class="reference external" href="https://arxiv.org/abs/1606.09518">arXiv:1606.09518</a></p> </dd> <dt class="label" id="rbeb231216055-4">
<code>4</code> </dt> <dd>
<p><a class="reference external" href="https://github.com/scikit-image/scikit-image/issues/3722">https://github.com/scikit-image/scikit-image/issues/3722</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.segmentation import slic
&gt;&gt;&gt; from skimage.data import astronaut
&gt;&gt;&gt; img = astronaut()
&gt;&gt;&gt; segments = slic(img, n_segments=100, compactness=10)
</pre> <p>Increasing the compactness parameter yields more square regions:</p> <pre data-language="python">&gt;&gt;&gt; segments = slic(img, n_segments=100, compactness=20)
</pre> </dd>
</dl>   <h2 id="watershed">watershed</h2> <dl class="function"> <dt id="skimage.segmentation.watershed">
<code>skimage.segmentation.watershed(image, markers=None, connectivity=1, offset=None, mask=None, compactness=0, watershed_line=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/segmentation/_watershed.py#L94-L227"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find watershed basins in <code>image</code> flooded from given <code>markers</code>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray (2-D, 3-D, …) of integers</code> </dt>
<dd>
<p>Data array where the lowest value points are labeled first.</p> </dd> <dt>
<code>markersint, or ndarray of int, same shape as image, optional</code> </dt>
<dd>
<p>The desired number of markers, or an array marking the basins with the values to be assigned in the label matrix. Zero means not a marker. If <code>None</code> (no markers given), the local minima of the image are used as markers.</p> </dd> <dt>
<code>connectivityndarray, optional</code> </dt>
<dd>
<p>An array with the same number of dimensions as <code>image</code> whose non-zero elements indicate neighbors for connection. Following the scipy convention, default is a one-connected array of the dimension of the image.</p> </dd> <dt>
<code>offsetarray_like of shape image.ndim, optional</code> </dt>
<dd>
<p>offset of the connectivity (one offset per dimension)</p> </dd> <dt>
<code>maskndarray of bools or 0s and 1s, optional</code> </dt>
<dd>
<p>Array of same shape as <code>image</code>. Only points at which mask == True will be labeled.</p> </dd> <dt>
<code>compactnessfloat, optional</code> </dt>
<dd>
<p>Use compact watershed <a class="reference internal" href="#rc8002e235889-3" id="id26">[3]</a> with given compactness parameter. Higher values result in more regularly-shaped watershed basins.</p> </dd> <dt>
<code>watershed_linebool, optional</code> </dt>
<dd>
<p>If watershed_line is True, a one-pixel wide line separates the regions obtained by the watershed algorithm. The line has the label 0.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outndarray</code> </dt>
<dd>
<p>A labeled matrix of the same type and shape as markers</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code>skimage.segmentation.random_walker</code></a>
</dt>
<dd>
<p>random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This function implements a watershed algorithm <a class="reference internal" href="#rc8002e235889-1" id="id27">[1]</a> <a class="reference internal" href="#rc8002e235889-2" id="id28">[2]</a> that apportions pixels into marked basins. The algorithm uses a priority queue to hold the pixels with the metric for the priority queue being pixel value, then the time of entry into the queue - this settles ties in favor of the closest marker.</p> <p>Some ideas taken from Soille, “Automated Basin Delineation from Digital Elevation Models Using Mathematical Morphology”, Signal Processing 20 (1990) 171-182</p> <p>The most important insight in the paper is that entry time onto the queue solves two problems: a pixel should be assigned to the neighbor with the largest gradient or, if there is no gradient, pixels on a plateau should be split between markers on opposite sides.</p> <p>This implementation converts all arguments to specific, lowest common denominator types, then passes these to a C algorithm.</p> <p>Markers can be determined manually, or automatically using for example the local minima of the gradient of the image, or the local maxima of the distance function to the background for separating overlapping objects (see example).</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc8002e235889-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Watershed_%28image_processing%29">https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</a></p> </dd> <dt class="label" id="rc8002e235889-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="http://cmm.ensmp.fr/~beucher/wtshed.html">http://cmm.ensmp.fr/~beucher/wtshed.html</a></p> </dd> <dt class="label" id="rc8002e235889-3">
<code>3</code> </dt> <dd>
<p>Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation Algorithms. ICPR 2014, pp 996-1001. <a class="reference external" href="https://doi.org/10.1109/ICPR.2014.181">DOI:10.1109/ICPR.2014.181</a> <a class="reference external" href="https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf">https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>The watershed algorithm is useful to separate overlapping objects.</p> <p>We first generate an initial image with two overlapping circles:</p> <pre data-language="python">&gt;&gt;&gt; x, y = np.indices((80, 80))
&gt;&gt;&gt; x1, y1, x2, y2 = 28, 28, 44, 52
&gt;&gt;&gt; r1, r2 = 16, 20
&gt;&gt;&gt; mask_circle1 = (x - x1)**2 + (y - y1)**2 &lt; r1**2
&gt;&gt;&gt; mask_circle2 = (x - x2)**2 + (y - y2)**2 &lt; r2**2
&gt;&gt;&gt; image = np.logical_or(mask_circle1, mask_circle2)
</pre> <p>Next, we want to separate the two circles. We generate markers at the maxima of the distance to the background:</p> <pre data-language="python">&gt;&gt;&gt; from scipy import ndimage as ndi
&gt;&gt;&gt; distance = ndi.distance_transform_edt(image)
&gt;&gt;&gt; from skimage.feature import peak_local_max
&gt;&gt;&gt; local_maxi = peak_local_max(distance, labels=image,
...                             footprint=np.ones((3, 3)),
...                             indices=False)
&gt;&gt;&gt; markers = ndi.label(local_maxi)[0]
</pre> <p>Finally, we run the watershed on the image and markers:</p> <pre data-language="python">&gt;&gt;&gt; labels = watershed(-distance, markers, mask=image)
</pre> <p>The algorithm works also for 3-D images, and can be used for example to separate overlapping spheres.</p> </dd>
</dl>  <h3 id="examples-using-skimage-segmentation-watershed">Examples using <code>skimage.segmentation.watershed</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="The watershed is a classical algorithm used for **segmentation**, that is, for separating diffe...">
<div class="figure align-default" id="id35"> <img alt="Watershed segmentation" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_watershed.html#sphx-glr-auto-examples-segmentation-plot-watershed-py"><span class="std std-ref">Watershed segmentation</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="The watershed is a classical algorithm used for **segmentation**, that is, for separating diffe...">
<div class="figure align-default" id="id36"> <img alt="Markers for watershed transform" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAARgAAADECAMAAABz285eAAADAFBMVEUAAAB9bL8OABF5AIsGAAcJAAuBcMP///8iAKUDAAN1AIYEQ3J/bsE9PT1xAYLc3NxBQUHY2Ng2sTUMDAwUABdFRUXV1dUGB2Q4ODhJSUnj4+NsAHzh4eERERF3AJIBAL5YWFgICAhoaGhwAJRzAI1ra2sxK4AaACAMAKoeHx9mAHUxMTFwcHAAfd4wqy90dHRTU1N9ApBaWlrd3d2OHh4XGBdMTExpAZidkSKemyc9tjnf398lJSU1NTVsAIxgAG6FGxssADLt7e0jAChFszN5aLtfX19tbW01ADz39vcqKioKSHhGA1Cchx/u5vPb29usrKx6eXlcXF1jY2PT0dE7AEYuLi5gA5oyAJ5YAGVlZWannS1QUFDo6OhhYmGFc8ZVA5qDgYJiAY+Zdhs1nTYbF277+fukkiemhic4LoQLCB4oB1kiAKoRCCxPB6McBDlDBo8aDmM7rDtMtzcnA0gvBmnMzMxOAVpyY7ViAIC6urvDw8OUjxylpaWzsrRwqt9VAXUqAKmZJyCTgReJiYk/BHaidSOfnp+Pjo4/C6o+BFpdH2qYSRkXH345iQsUVHsYDE1OTk8sBH0lfidGAWhoW61fS58ZAaGZmZkwkzB8ExMdNootAY8RXmYTGjqiKCdOB4RIPo9Is0gpJXaPd5Lm1elArS2XZxiESUmUlJQXQ7wIYdKxQDuXQqgWKkw1JK/Z1fIdKWISZh6QpiuDVlYdYIiHMDABceBesDF5hhCCOjpNIplsJ3keMKdbQr3m8NwPTsx0rjE4gUIFbtgQeBOjqTEAguQgbj5RG1jHUlAyIJZHGGXYvr5/LCyEYWEQX09RoSKkYyUTQqkZAJOGdne+fEB+aWlNnIuEbm5fiRlDmVlkIZpqw2ZJXqS8q0EWPi59liLJw1ExcJrXZlvt4Npnn9OwYWC5sF9GG0xXrJ43hWc/ZXwyS5h3U6MnVFmdkc5hsblbsmWDaYdiP212eLuDQrSkl9TTfVJEfLGpwmFN+hJagphxhbI/0B1Zi8WnmNYd0qSrAAAgAElEQVR42uyX0WsaexbHZXaG7DzYccg4jHMVbJZUrELaDOY+jG5QWTOK4JiMaRMyEgsr3GaTWEiUKCMWKpqEfUgJFx9KCIQ++LCBPCf3veT+CfkH7vuy73vObyZpbfp0Kd5b6En8+Zvx17G/T77ne87PNfE9vhiu7wi+g/kzgKkq1YlsamLCrOJVKvV1Hpq9nfmrE6ZqT005+w2BqfbaVqul1usG3zQLRqv+VZ7qb08Y9WzLrJtWle+15BbXyhr9llyXjVZrUP0WwKQGE5VKa9Ae6D1Lbxbbxld5qtrM9qx+3Rz09Qmdb+kD8Q18gT6owI2e/q0oZtguWHpft0RrWNHFr/JUud8a9Kx2601fB8VYVr1ZGVj9tjWs64ZlVb8Nj+Gq2WpWH2ZhTJnZr/Sf5vwpc0LNyimwFdMP3yCTh8N1NSv/OcBkvxzV6scZTLkUjNXq3d3qx/iE4ciV/fDbVV96/N3D7m5V7y5Hvp98d/b3/lF+J5iid+1JcDaztLq6msmUy4uzs8Hg7FSxXylGV8vlaCU6HYWYiU4vLCwUizCJRhcWpqcXphfwfnRqdWp6KZPJLM6uzc15PV7102e/f3qFcXh4eHX4228fPsAL5jc3T5/eXB1++HD1l0MYD+EH5lc3h1c3uPb0hsTlJY4/X15eXl9e/nyJN/4xVjBRt9d3dDTn83m9czh6fF6fb6kSnVoM+iR3ZtErud2JRCKynMvFyRAPj0QsHI5jwAe55YikjIApaclkUtNg1EqlUj7fePxgfm9/f339xd7eyt56rXPcPbZfu7tvu51ut7u7e3zQ6RxjdOY78yudzvx84/Hjxz/88ODBf8YLRvJ43BLs3u2WEpFILgwbj+dykURCyuGe4Rr2HovFkUguEknAYg8wXCtPry5NzYCUosVKcWamiDETNT99dqGBNPIrnfzxSud4Zb4BcQC77uzV9lZWOqfdt+/mVzCA1/F8p7v3dwB2uv7sx/V//XW99vr1/tbW1v5zHLf297dq/xsrmCDZdiwWCARigRgBEF9ejrglLyTG2uL0LGTX0gLuvjIcDCzL0vV2u9lqNusiVPCmUfDLsimrCseLolGvj/Ro7xuNfL6UL5VQL5qWBz4ggeOVB3978WJ968etZ7Ddrde4+efP39Vq8HvaPX37are2++rVL7/88u/djZ2d7c1tiB0c/jtmMJgHkYjk9jxZjRaLfdj+sDfsD6FtQQCtVl0URZ7nCwUFQwUGwMIvm6ovviz5ZqN9wKOaMnyuKsYIGD6P6QMwuqentXfPn9eevTiF3QOBt7D1jd2NDdzw5vbmS0GgIBiKYSiafagx7MWvOzsbF2dnZxcXJyehkMDAx76xgnlTtmnozSYgMAxeNABE3TBEnlO5QoHjOPU2EIvqVxUZRGKmdNAYugxwldamRPyMHwXzfr1WW1+vgXUcbOykMUKCEEontWSIAgAMTTOsi2ZxwtL4YmkmxLhYgZ38KZlOE3/a2Tm7vE7DekEYLxiQv4HB8yKIghfhVeAUsQASUYCJUgAl+G9DtUfAAmCWAuhHMUjEcCQe1lOyrPLiCJjC9ib8sUENIASBCsE7KkNIh0KoDgp40AxwcYKAoQUAw7jOOyH4N5QQCqVLWuP0hKEZYcyK4QxUiGiQZOFVkAmoRAEocIV5o8AMeMgknHfCpZ4L50g9An9OBALTpl/2q/wIGJFBIRBp0FQS5MIwBBLNECzwyzCwhGVdLgIGXjRFgYjo6xKAwVUUVWoIxxcUEh03GHAQ20V4g1c4RRFh5Aocegr4iUISyE8s1mHjRzKpSgxqGEY8Hok/nEzUTdmvFEaaMNHODtw+FdKACy2EiE7wDvDC+ySNXBiEIU0JDMue1EqawJAQSiWX9mgTyNDesYJRUDAkkwAOx+O77bIFyCMCxf51NANgQFJ+M8W7w163TSaXCDycjA1Tpp9TPgMDUhBCQIZKp8FcMCibC014gT4QBmPnEsoGc46lHx3kk0mBKCpZElzC6TkCG69iVGRC0gl5iHUIkVNss/WrMPM7c2SCBgNGYvByahCT1rwStny5SG5ycjLwRE6ZKvc5GJYWBHQYFEcSDVWgbafF7GKcCX1nNERb9GatVEqXCBkhrwHc/Nn4PUaFJCIuA2arFAzkIhY4213Qem/BqH57Yq9RlLXwXPDIQ8hIMQAzGW+mTFMdBYNGStmGAjsDLGDANgYX3iBKQf8FfjQaDJoKZNvZQT4NpgtpR2l5AbIs/dMmJNnaWMH4SfYQkylwPAED/kLAoP9yJI8cMIrNpdVqFax4JDgbnHMnlnOJXAAVEygCGPlzj2GxtpCsoaHCQDlCd3ER76EcxbA063gv5AuwELavS3khBEVdYNINFIyLObiA0Td2MI75cgoPOYUOXCBNC1TqgmO+zsBBf1tvYceTCc9lMrNPvNLyshQOEDJuHsiMggFhQGoINHoslmohTRFGdjC0rRRSj5ARphxw3N3NJ2GpBv6rNQSExiYfQcczXvP1i+gxpIcBMDDDjHLsF6WjKCSvcA5LCBc4Eli55cVyJhOck5YTywEbTLh3DwzumAqRZCLSAWOFZLllw7COWFi7eCE79JgaVGhYm9SEUF6zvUf49cTFjh8MBoeNHdowpBE4CwqEIyUbK7itHlRWvd5sw2lpNexbWipnZo+kiBR3wARmzc/B3BZlwAFpAu4BWQGDk0Ekk+xihMqiscsBiBvdvAbaEbQS9MghQIelvHRBuzxjBSOTVEJB8PbmC4pjK0ADWNmnAsguXAYWBIKx9F4it7i0tJRZPJKkCDmAIplcK3UfjN2zoAXTxIRJ/28X50/qkctud1BOVFdrkFYZipim0ZBuSCb96OX4Uwl9F9TC2wlkK0Sx8wegKAiHI2AMA7nolrUQ9pTLS+UygPEc3YGJVe6BIa0Jg/0sQztCcWEmOYcA+uNxgCBEMNvdfIkwSifTFycsVi4Awxyc/wEeQwyE5xyj/QjHdl9Snj4KRrd6A3c8mClDLM5JC80wkiG55OXveYwL90zaOVJ+bDNhPwHjcvjQtmAYultq4FGKwdPmxTlCRMWw2tkf4jFIhsPGhfT/hA0pS7aKEBZpA6FSt/VebyYuLSKYTNAntVNHd2DCVupeg4cbZ2yNkF7l7o0cGXHCMC4nk8B86VBHK1HkLBBKn2+ebKLGMJtC3U3PuMt1gZBRnHBO0HYjw+NttTV8o4t3DjMYesNHGYzFoDsjp4ZOLsGwat4DcweEdlC4SOdLOjt4d7385/X1Bml0yBGcPjhopO1TUki7YF+ek+xDyRxceMbfx/C2wai3YKD9J20LkZFfl3LuTN+AikQE83/iza4njTaN42ResoGEEcNgwBGCvDwTBhIQgxyITqaTwIRMUhWH7hAlYLIHT92qT9I6oUbDAUTsUW3YxCND0uyBJ+563P0E28+wn2K/wF7XfQ8+j7Z7imOpQ0ubzC//63+93d5sQ3G3g2CKe+GtV/u7zanJRLNnf/ohXUPxSzAwtLjlSNXLuY0B//bXMhs7GJL+W4RsLfYtk6GNNTiMh7tnXDAe7ev1C4QSNpDIBX2GzBZw9IKSwT+NVGrh7N7oUTB7mdAOXNViPBBfgj67Gp1KpjT4EYzX7aAZqhyeVi60X/J47r+fHLHlzQ+Ui8iZ0D6SbpwRrQfI87e3U8Uwn/4zYzDUZJ6CwVhaQvsFwdxE63eJbKh9iTkJBNNtNgtFJBMvhC/3Fxf3L3+Ppcirn4DhXHelQwgaWjzNUG8fjKuj5IHdO+RFMnPpa1QwPK9/x5QEscTTqYTX+Nts6xg6zyWxRIyGgsFYooJZCAcrtUS46Y9fnJ6hYIqZQLxI9k+RAlSCc+sL2eg0lurrP8xjvKT2J/mYeOzUdAiYh2Ptr1dXY9s+egsOI0MLYGhkSsOLBghG1nkSS8R/xX/NvsAjBQs0QsRo1ten7otc9k8zy6CITKUe2PqIkdTdqOwV8YoX/DeLQHR1PxecKqb0+ikYwoGUMLzIkTIPQslD6xf04QeR//LZMR3n22/HqBhwGJFwYfQPt1Dj6cztrZeGktfz35cAM4cl7vw8CoCMpVzBrC99TOAjlzJ1f7GVv9m6vGtkwvE46iUeud7Ftmpp/6I0lUxp/imYaaNI+kMvlifMYxnDed/9MsQC1zJVZXJU/iQyWt+ypoL5Cg2lznPMPUdLPA+3Ntt5DMnWWMigYqYjOxfM66VBJRMt4bax7o8E9mqjy4E/E6JcCv4urpMAzGIg6IZSdP7ZzBe+SEWHT4vS4TjXdeDm9lfb5DXD0jTbdpRO55gZmzRXQ0o6vId2Upd57v4tSW1AJjDzrES768dyzp3BAJilc7KIwy1JpV4P+yONy1wFrJeAufZfzOPnFxdfDSgYQPMDGI6ED22YSCi5NuPl3n7FyRVQUS1HtZU3vQ963zSJqBjZ+PqO4UVdRPulWDwzbgnWF8giyQWDIyrSD5DmevU0TJ4WN5SlSqbSDAUGEbReQsZfPdt9Pb+7AHnptBKM0k8+A8OJDF2ToO3iNJdWwWSw+XBMJhG6DhbjWNbkzWTomAZHFKN/+gskb8vQAe09T0LJO2PFEDA0MaFi5sgYHIeauGlLBKkOMB8T1WTjzeZevIixtLcxODsFoGjVq4XlnyuGY2S3USKtpLs8Ih3C7WeG2Ikua6ZpW46pTibEegGXbPzyXpZFGefo8uE72hTMPJRoIUMkg90ktNNQ08xBT7kOQlheDi4HgyWy2a80S/WNSgCiCMGEQpdbH89OydrltBt0ES48DyWGRpG7G+Bx5AslC4C5l0XqxppmOiaoRlAdS6cpSTa/aIZm6TI5J/HgodesFUOxzNN5DFEMgoH7pQsiA2BDdo6VZhOSEwgGuRQLG+lLPJZ3dgbVzcetzPLPwGANQqo12iPypM/GN4Ari5HF4OhTswzNcBzJcdzijjGGh4ZhGaAkG4LsK+95AY9ZctVCW0l3CL6K2Xt18TJIwSwHS6CYSr0ZjVb8BQomtJHvDkY351vnWzihCfwUDOkFCA+GPDJtqMn+MXgvg3cwmMjJNtuwTVOlxR2jWxNLM0zI4xawUSe3LwaGxtG8O3ogA8359fX9EaUSpJkJwJQyzQiNpEI4lM53u4O7G5ANVDft/wNmqhPO1Y2Ib3BhFLyVocRhOFGma37THtq2TAWj2T3HtJVer9+31ZSv99tLhNIiLmhpIUMdeG4e90o4Bt/vLrtgMCthGGWaYTeSItlqu4oNUzuNZ4byidIyXs/A6PojFLqP5XFPi6Lg32XJPNjLyOCyhmxY45OJQ3UlG5OTyWQ4GY4/jU3TNLQPDKnxZg3mj+ZLJpjzcziq2l1YTaDzosWgYFAymTpaLySlQji7Ua/Xm1DaFKqtRC3fDXgRTPApGChDeJ6sFxmOzrpFAAPVrqE/3DM42vMyuFQxNF13NhWLw0MQooYwdLRd4xNc4+HJLQ68ZhxKi24Rg7ohRoPnQnDwAi3jHgmlZbeQAfstYU4qEsEEwv5AKFLYqSZy261GfnsPP8o9A8M/lr1Yz+Aq0rLANKSkak+OMUExoBgoZUTwGaeHYEAyuqHatiJJ/fGX/qRTPjrqdIZA+AW2BAsk4+L+GkdRH8/PzweDbv787GwNrRceOErr31KlFA1DW72zEw/74wU80Xi9FvD7w008D1KKBn9QDBEMx4CFgAIMC57XxwqK5EzeKN9J7a974G8hlqB0sezN97hHYDTIT6ogCVANS31VssfjsYMSkgszVswuznIvILnAtXVzM+rmc7V0Pp2/u/G7YIJY4KH9loJ+MtOMZCNr8BVZW7teC4VCEaATCIRxXbv6NF3joSjLFiRJ7akAhWVtco6z12G/vSeHIDxeXpNBT7pu2f1jPA+jG4qiKqqkqA58U4CQkPL5pH5/MttTm7sXWzj3v4TrZnA56pKzl9td0Mygmw26sVTKRLHDhnoP92xtEMwaCaR4vNouthvtVrvdSLcS6XTtyanNv0PUSFIqtsKyvlSyU95MxtQ+WMafr65OEAw4jocDw8HeCIqW4TFxXscnCAK8JIFVfPBPBR+7EluJxZKzBXNOjqEChcFg1L27uxuNRnf4bQCvcJRwAZOBOMETd8FoO9eqVkPhAjZL1Va7lU6nc4lWu5bAu8RzMD5W8iWPOkdHsWT56qpz0un1hpNe76A3Nifv8eQZg+dn8FSDBj3BSc/B9NRLsTF2JckCGwCy4hNWVgBPTEjNFsxNbhuIDADHiMiE/OpuQw7udv2/gylBl1iqeDPbeLI3XgUcaTwgnkgn8KbRarQSiUajuLP4x//7n/84OupN/n0wHDv9lKQKtqrY4L2qokjK5FCftpWyzPGG7ejffAIrKQflpMCugMR8yWS5HGNjMQjBlC8WY2cLZms0GCCKLgZRLp3Pb8MNnmiGmxDlgu5bwoapEvRvI5lcrlVL1NKNdC6XaCcgW6dbO41GIgG6eQJm7v2YBaeQbEUVBAWA4G/gq7YqqJPPspeCwZGmaEvKuIMB5AMSLJsEibDJWPJNMlbG9xCNK6nZHoA+Jxy28+QnAzAY8A5/ZiCfzkWegIF0Hb0mP1aAUFogEdAKGku13diJV5FM61koqYq0eQICgSeWfOCigEZQJcEXY4XkIUni0G9DhccZkJ4nB6AYNpZCT4r5SPywZYhBsJdYGXnNVjF3eYIFz7wjkFytBve1NDx/LX/9CCYKQRUEi6mma7laLpHOtRpVsNt2i0TQDrwgnNqNRu6Zx0hAwgYLRi5KCjzYJwAgyNnC5gcORzUeD6/LDMeYjn0CzoIqSbKpWBJ8BvzlYCUVe4Nc/sfL9bS2reXREKULX7AQxAILTYQiyYTYBksG+24SGRNwjMnGMo5ejDCqYDYv1C+LhOA3UDrQMklX4/IWs+gimy5mNvlA82XmnOvOMPEHUFPLsWMFdHLO+Z3f/aPU98uW0t+mW1wIDDDxZh6gaV/i2i8bFkE5UAlPjcpUThtL8KThgRvccgIdtek2kNSisZx5y11gQA8hWGAIkC4CDUXK1iKhNW3/yzuUabXkmauo5vOL1Uqi+FA2DlAIiIePWgT6OL7m47lkxjTIEsWXS7gEKm4b5uEtF7PGpQlctkkfsACYvVabSHB3BTjiUXhthWAHosLJAPWNx/ywoZ0o0u0mCUNFQU6UCyqxfOEy6Moel/0eML38tpJQje/HjhBxTOo4AdgDXQngo4vSgZmhutA52jMGkga4AM4AIFy8e/gTGNVh9472+h2wqQNoZsvEu6TcGrRrj5uYOkDH894CI5qkCGqQjTQCaEQQQE2owDjcDRUwar5g/93F8HYFMwEejirOLERKeDAahhk+lc2YjtpbA0tdcEsWniAnFUra7bPjg/8H5ng2bU8ZWTpbr24rJ1KbvEglAPq2Kv3QqKDBliwOycLshmIscdX5HF0Sl0OgueQ64G/wlYgPLWK+I70ITKSMSbcHwi4XmCdIBvrp0CuAzuWU0oDnwHDa03rlv8DAfk8PeyQWkstlm+UcT43t5rcFXQe+s9hljDJd21ZagiQ0Fh3U4jjGMb2vndQ4+3qwPz6pDS/uHFkAlUAodugsXXiFkwiQqmvlAvO5O0qYzjxGemAxpd/gYlGZLjvXlcrez3p9eHR6XPe4c6lNa2kwxQAcGI2H03Eu/Mnb9Rid1ttkr6MxBEdaM6AsBN/4929ccQfGoCk4qY3vV6mA+cJmNH4x+sKelJK2B1GylJ4SND+jUTdZzrpdlGAWauijrS4bwFT+B8ykjrLMQnS5WI48RDoFUpt0WSxgUIo1Ox4D8bAw2bBQXfNtzY4DG1UmCAK5ut9OxqIpGNeGn1awn0gi7EaCtsvAS8po5JkuQLGyt/69d5ezkVrtwvawwb1sMAyvc+mBPcbeoRpMYLN02l96yYL5jwUb9ustuzAWaFA1SnjQmd6WayBBsoAqkRB5AQIFAao2PBYIPAzHF2qD1snVySAt8rxZfCp8VmmJYCdjoUyYclI2Y5fMmPcZtJTMaBxtkoSRBpRB9e5MO5uzyUT1j0f104lpmHUzcxP20cSgoRIN8VC7atEQ4MVOwHPoJmgG1Z8d3zjbbpmRP727mQ8v9vfnF/O7R8ePCxkU9ipNkebYIEmA52zjL/+BZ2VLid7AHnC2bHALMd2UvoquwLOuAcwZE8xxnZtnJ73TM273A28IJHFhpmnMkuUSQWY2WzR2pRTTZOyI1cje2gUeoE9kf715HFyNa7Wr4fxZb94g8z3ePK6LIghisASlW67gNJEODDVmn7KT7xOU0FB/ejjHEg6i2uZFo+2F55MWt86qVUHorX/ONR71TluGyzMuO+wPVA7GmQv8gp3u+geuKID1+gXzmmAywRXGuMz4cX41vrmazzl5fTF/vDqZjwHSyfgKBb4pBOTksz5FkSPRFrA26WVLyZ0BkNFosWgsRh4dNHET8CestlpqwHI7XX90PbmecNPAdhTirJ5xyXyiHFepasbGaTnaYYyqL1EsYh/eig5IOLjMIBqgA7i5upoPh8MaYt7Dt28PD7f3H36FG3MmybaLXK5kxO4A3SQjHzNOucBMwyQM3S7a4yUuTQ1cjuA6Vr11hm766OfM0nErybocb3HN1umRmptsbUZJd7Z0Uajo3y66iGSZ/OktMD7Ti0A4geVGUYAOCJcYx4+Pj1fzMfeOcvZguPJXqS9XaX7357/fn7yrDR8HIkp9eE3s6IGWAlFf+kXJjAEsGzdJQh4Sl6OV3dA1gAr3CLRaqok8rJy7SXcEK1oki1FWnRwdHB+d1kMW+tlitFA/pBS7O1ISSjt+bMdSSwOm3th29Jv5/Go4vr27VXu5avcrsChP+eWn6ctDbW9/eFP4UFOUo49EO5nK/NlPS2bMZhNmAMfd4BFuMjfsZq4xUfMlhrsItw1B5bybjBI1p8TC3t1c9wBNrz9aeMQGYEKOqPc7wFA7EIIT6NIXayQZOsynx/lwPP5yJ+W3Sm0fwfdD7qfSz2WepjKVkUwffq3Uhi/PKaBRgw7ESOay3IGq9xvAEm7wPwvBmKSbbTIDdnJ4OAlhIuGRQubAwKW7+JEa/16GbmhNeofH9Y/TZLu8yg2XqG6J+1ZKjoidyNZ89kdRjGpkoxu6mV+M7++gHf977aJWqby7x9X7KTMxqPHXHMrJHz7sD//1uvJTUIZjD4GEBksGJgvV8qg+sMFVQ0ZhVue0Yx3vJ+6mp0zm2OwCun6/7xIaN+MxNM7Pln/pmEDV6pvmwuuCT2+BkWqYCVwBMP4K6kCqLW5u/vhSwFZBEkS8SmX/1vfhP4EIOOwC5gSxlOnLl9vXV0m66Cv5nK4gqZKB6WcZ8LAs4NLvkz1Z8tnqGVlm9S1QZKJG8Y5MziBZAGADR1KfIp7Zdfb7dON2s67bd6nI8C0wmhpiknEeQyM++kKU7OeXT5JpFm1B8VUB88VhIdfRLSDeRTBpP0aMSe35L6+ryE+LNAAucJ+Szdc0CUo/s6zNBg/L6j59rhqWZW42BsLuuarQPcMw+5ZphqZBxiTdEKQhu1rW758Tigxs2cCu3gITSDTSPvK9nqZFbIumJtJ8basR7zjXg0/ji4ODk7XWLCJdDxxdswER9BQDHcexx99fJZpJzQ8c6ZRdlaZVi7OK5gb4EAgz/Pxkmkadc4tVHLbAnLbODXwQEAK+jHzJthSyWubH6Qaohuq+OjtS0tcOW2s9aNqFjqinoxHgYKdtkySxLIbDSm2OlzECji1gNIguAmCKiB2EPfz+LDXbDmAzQi/KlVKnbvCGKAZgACvMqjn9h9nifGu9ypvK1K97XGs2UTcMwRtmvx+SW/3+BjiSba3+R4935bHwK+rVtzfW4Tgmx3lFcyBsxBmtWA2aKFWDwodG/CIfD2sXX/F2HItmEDyv/FiLcxyAnVhLH5x5lmsbSMXF2i79xjomlLOFBQ/vnwkRqQMFs07WoD6dTiZcNjSZTHgLHnzKIl1AGLhu2G+NPrqWpaayjR1gbD0ALFIHCWQRo+fJA9Uy2WiHRIzC/HU8t/O7OC/WL4MgEtIJAlahoEhFIdfCWQ9/eZUci8FbebnAzK6rRlXJyDLBkO5TYwuQUT1vnU3Am7PeNbhSP2/h6/y8fm7Uea8ZU9lQSN8xJyAZTsfLsP9WSgMbkuCAZiEpKB0O7NBmHV1fDwCXM2g6ms9cl8s0jguRonWAIw2CAh8KYl/+cf8f9q7gtW08C4fRliECaTVsPdhV8ZjIbYgUiJ0y9iGRBClkJiJMk3TWqoodZB0KvZicahTj4IIHxylzcOnBxwzbPSRz8NyzgR5Dcutf0cOc2n9gv++n7G6d2dPSeugyP2JJluW0+vLe977309NTv6FTJcrFCV+i/SYNRDLVkibcKV1aLA1ymXTaUpSKaLhjV7wEhLQCgFKptCj8wI6MlqlWB/Qmxe7VM/gVpWqpOt68C4kScoGI6SBINSIC/ZA2A/6QVZCH7kg6EiHfacCP+o2o0UfGAPJ1VIToCMg4zR/6fQT7yDGMyXLMvJIpKUqJvoQTTi3AeTIFbFuKxY5dtl2xbRIxgMMHhVxV1OAVwDKFKmIT/GmQSQ82SMqp1KBwFZi8aqp+njO/shr28waMIB9GUh5aVlVBLDEsA2o4CtVG38+WwTJGA6EdQQh5ggSakdd3Rp1YKjuSMWmOAc/SV9i8K9PdLOEEoWEU4GGzU5lteZYtWnspMI5SVWQQAxyBJTk4Q4Vj1fcXcwWO8ZQgDzZxzcA12ZcsCHG6kPbZ0AEUvgxfynZcU48dHMPQw2tsDuBgAsBJc2gaJAvxQb+RdfzImPB8zEwFoFhcwDJmjhBY4DmFFAM1u7yBaOZsr1Kp2KLzmaYxtAMg6GQqOqZXJeQQWvt+gbrmSrh2XZxycz3WzaaqdxpqEJcbDZiKIQec9lf1oBPrLsuEdKTeUDJSxLIYplcS52SkohQawc6oLIXl8oR1zLZXsbOMosEAACAASURBVOAyVhpskuo+rIBhPa1aSpNHNAW2VKnAZipeRdiUwuIpAAOTSbJOmA3Fj7fZhSMNctvjFsMyB/OvTYeX84MwYmM30AgMBOFXdeL4sPOTqsduoCOuu7ITmdB+al7M4sicDedVKEN9MWpIvhE+mCzHPPQsz2NvP+Bzv2tbXC9rJcQeT/QFTGtztkWYhDthRZfSMoPUILEdDcdoM5rWy5F2Clcv0cIa1nnp0XQ7O4Gjm64ZP+1Huq46TieOwzA8dCPQMwKy6AKoyxCCjsHpc7mI1ApfH43icIRoVQ4nC8wM/ITAABmtvg2ygZADMinPE7fieMuI2Ba4WEulRdAGFMgOBjlmnKtb92/xWsrDbndzrwci1rQxV/qzrtOZXFEWEx1iLWEzbhxyb7DedE2n0THLKtNvk9efjMgIG6EfNvyQXSXPT3796fT0+NXxV6MygPkdOIYEY9uLXQ0WYZFXQLmVyjL9ylZWrWWomlJh6+H9+Xq9O2Q12ka719tr7+3u7rbb3YVveIVgO8dSxSsc0zFjU3WMOHLcBhgVQOlBsAPjaLqyKptqFL04BAonJyePR6PROV4/v/71+NXPx69fjU7/9uPo1VfY1e83wL2T1jHzFjtNkUbshQWvNGOJhpIWRG0htz2zsFnfBwY9QsDR2m336vfnZ+ZXV3MzqzPb0DzVAoRQSojhUnXxShIZ5WPX1ZuISzs77vOdg/X1ZqcT+QIKgHE+enB7dHr79Hg0en364/nrU6yPXxMK/pxA2ZSzUmACQl2SJy3wKmnaCKhlcbiQmWF9VXc47B2193jvRLvdG7JR6/xWAcGnZDNfshCgwDoliLwcVQxyJ0LD1Kl0JbsGa7gBi1Jj5+n5zun5yfkIpnF8fP78+e2Tk+ePT87Pz4WdAIbRiX8YZZETqbIeliVeXjKyvmE4nB6N5ciZMDC3KkkBs1ep7wEQ4DAEEKtQ95m0t/z1skXSQTwn8Q5SVhpKr5Riilmi4oOOGXBerwphA2yqg6UrpWayZLqBGfyAP75/cjJ6DCMBCmxGu3O40w8pciUJYs+BrhMXZhv9ohE/8KWy3+d8hVHGEXAjyfCdCXOMZyk2NFwaAdkGqXiXrVi9ZQuIWSLHhrixIW/wIh0huaIcxjub2lAkWlqmAF0IbMaTSNYxByp7rz4+b4SkiuhFTKKVin6kSqqrisqzuKwHDnIlx3VUox+ZZj4y/AhHO4bvN3xO6kHlmJMFZqGCs7YqX0PI/WVu+f7WnOhYC4g8m9XeikLdm0o62yJke6QkmyklEEunUwpVTCajpAqQwGCaMVf6pdM0XQkkIcUHgRn7SJDyqiQhaDPFlnQdEMgsQ5Oga3zomkjWTfkwkPOhaoRRw3DyMpKCPFIsA59MeKLKoqK155bZtHauULIEHMiYlmkuGvNoMZgsIamCa0HogKn5QYYTNEpyFLABMONR6ZfIpHgD0wTNzoFpsmJT1bNZI9ZV1wV3ZPO6GrCKs1gMff9QD9VOoLqBUTRCp4GMHAlWHrlU2IiKwHPCHONZYo4lzWTaY/KYSjQc9RyNR/RBRjwX6GC3Rf+hJyUNkm1OzwAV+BGyyMzSODC8VQL5tS6FUaSCaxxZ3Bggw1DkwJUlWSRSMgyJJeRZ1e0Euuv4oBR4Gi/PmVKUL5Yb4OHshDnm1hzliiJmqrSMmMRLDISnrJBlsbBTbA+NveBdhqWKR1vRgJZG4DiBww7bUMLjwMQMSroLfmAJL+cZQClJUQfeBLAh3dQhcKEBWRRD1atLZhRKjgRhHHLiRhclVlkf35kw+QrZkoChpC5nei0r8RDFTpYaXMdmBn45D0xcgIjlcaZC05gz2CQdJTXuSo4bdFgiHwQ0EtNkwa/LuniQbhybuokkIQqh/nTm2Cx7lbKc0AKrZDuHT+Oo7IQ6C4/00IyDCXNMmhOb4uaaApcDsCgy5kKmpFWrpQxjTqma0grVlBgk2AIDdCaZvErDjcjCmWTiuHoFGFgKbAUBmzWHsJYi/v5FjLxsOOUi70oyRH2ZlJQjIkz5vILPyhg16/t+Ft8xzWK2GEmTrsFb4aitvD9q/95RW3l/XfvNPravxSJZiz1jrZgefZeM2uV65bvxcfX9f9tT+8/X1yYKzP//+AOY3wWYj/Doo0cT+nc+DjC1bq0L5qi1V9Zqj0AjH+w/Xuu11lY+57NgVtbwq2+s7WHjUav1qQBzY2FY3+3u9fbbG/X2/t5+7UP94qV9dtfrDY/2hxvDbnu/3d3t7reP9j4VYG4Oe0f7m+0v9o96w1Z75Wj3g/nm9wsLe+3do3ar1atvbDzZaLfqu729TwaYtZuf33vSurNy88691tLSyu4Hs5i13e/vtWr7w6VabelO62bt5pdfPPn+xt6NP6KSGK2Vj/9v/K/1MYtbi7mtrUWWYM6sij5uWw8Xk7ElbsvHmNnaSh68lPvXIml9kRwkBjvjYXvsL15beIvx8nK8FbfS8W19s/7y5eYmNrASn2CjLvZixWPrL7svr4y3b3sTBUabmv3s27uz1z67+6frs+xRN5W83h/T17CLzYOS/taz7Fg3e51NwKemk2d1XJu+PHTs4Xd/f8YHTYlxdnbGxdy3Z2fv3ikW37zhY6bO3ojNN2d8LBWX6+vrb5IXV2dsRrTeFB2J1t9OFJh319l54fr0XfbJEo3EZu9emxInOj2L97McfH4Jm6/x+SWARnQ+nJqanvrt+HIcmPFxcfHm4EIMbDaBwlnzrHlwsH5wwa4fWF7w5+KZeITXMz7L6x/vjwkD80/mzuC1bTyL47FxjUN8GfCuj2Yvki/5I4wRBFx2TgZdFsMyOtiSRtYiMb6lOvgwBmGhsRMGKSGt2YsNZRIwPmUxzZCB9hCID4GyvgRyaDY707JhKbR0973f7ydZTpx2TnGeZcmx3IA++b7ve7+fXIlcj6RsGOVyufW4UMabaGUyiZVFgRfRStAbdsCixldW+IJhaAaJImwL8tyVE//+ynzVkk3ZbMmzMHXzldmDx6sqgdXjuGq1+hRii8S/SQj4FGKwwFMQGg2h0f3tfsFsbCCNIqZTmEP0SoUZvOiNqpEDhwMyXQifhGiZpuUXWrJhbBiy6cIb/hNRserf/xT93V/rQUhSDwE8DSNg0CAhIABAAM90Eh+VRq/Xqz7d6jZiFYhkGt4U7hfMH/CC3OR/+fKaoeGf1HU7nQ2+UHbFlAWh3Iq6qCi+r8iFpms2W3j7qEI8U96rp1J1cQ7MT0iDoxi69Pjpn78hxOBQ4XBxlSQoyGt8C1aA4mmWEUU+3TR+/J7B/EemYvBT4veWJcKiAI2/tuqilbojLBFWisi3tvP57Ynrmp2OkTDgTVFMzYH5S7dLBUG1ADRwQ38IInkzUCGVtIRgsjqu7exVspK8d8X8I9ABHKzbeiLSYxdFJXVnEGKKWWzmaeTcsunE6b+cA/NnQaAmQXik2ZKOJcmWKAY2FYSBa3jiC4ytbCQLs3YD9943mO3ZAZcNAKLsianfEZZaLkwYGdPIT1ZdBQU3D4aIg3pHTCAYmFRwk6RsApUQQEwwFS4rSTouACabzU5xb2wJYAgKsdNx93y3Wf89YBQ3Uyg+EQmXSUvP5VTNQi3dAkN9VWCqid0CQxaCpVKhHgNcumDWBAvSATBeurIUMOIeMQgxpTRbzU7HVL6ERRQtrcjXH6PLgGA2tnM5KeGDK98GQ5mg2abBdgWBSIR6S/AkmmFbRFepVO1ez5YkohoEY3eXAyalsHyy9p50nojil7nU/WLBUTrFOgrGkHO5XP6RrKTEb2+AIXkk0DSKCaQsh34Lspk5bsAF4MUqDdvmuF6PgsliXKEhL8NjWAUS6/VO/QveQvbvGQ7vplrlDiSTWQbB5HJOBn6JuAgMK0METCwdui72LKRSh4EfgRqWfIpgPE4iQcB4Akjmv0vwmLAYWeKXLAYZWj6vF/282Cr4+e0NFEwuN0m4ys2qlJ55L4IRAjBJyiWdjJRrqqlGoyugYKpVzuuFgslK0+WCSVGr+SwX3G3Jjqrl8ymzUFeYYHK5mrYQDG1qKRhqvcl0JJJMP/SjjS60PiAYGCRUPS8UDEgmuRQwVAbkwL+d5zTvLcE+sSjFsVaLG6162aRccm7BvwkmxiIdAROLwGCUYkxZhEu3y6FgUDJQmxgXtN+lgLkN4C4wyE8xNUfGeuQ/hjHBhIHJF6CcLUqlGM0b8iqoQ7OWhoqFcgEwW10mGJAMCibIpavlgfldfR1Np6KcIc2d32m25FwQciH1OTBB6jCdRIYF6YALgtligqlyHDQzgWKyXuwBKOaLzZ3mOKS1E5t7LScfgJkUXGVBKkX7uWQkgW5yCQXjUcFwPWl6FSgma08rDw8MG0qFgtF0no0GmnvSqRtKpmZYnwUTZlFQrm8JBobh1RmY3sWnUDHZq/TDA+PLhhkZVfpFQ6NctjuPT0d6CEaPi3ekUjo9X5tn9TopdBsRwWyBYMJMmm5u2qFkSo3/PTAwionzV2pIRjGMuE7BuN+ZRyMvcN9cPmHeBpNeOMkQvjEdDs/fN2YOU0Uw2MZwPe5ic3MaKkaaPjQwYgbvegpk0J+hjfF5ObPNBFM+HY36UigZrbhQMbQaMTCVKJlkoz2EOG8EgtmySzjVyTHBbH6a2W/7t4cFRoFmjsx3Ghb7WZdJrd6GNsY5Go1G0sx+E1/dASYdgmFkAsGsnb9HzQRgUDAc4dLzQDCbm14Ixv74sMD42hjAPIqvrkCbgsMhfmJQweSfbJyOjvqDSC6pXy1KpXSkWM8pptItlYbvz4HMVKDWa9s9yoXrvUcukEuhZj4sD4y1yGGk4/1dNR7nE5pvpSxo7gyZcvE7+mB0aB4OZvYr/fG2Ylj5ic1PZFIw07W1NgYkU2i9HOHCtYlgNi9muTRdGhhs8W4Mri2X945PbYfckgIndi3NKAa12jwcjQ770VzKf70ATKQ4Y+NbCbkkhau1tRKgAcmcfyDNXcljXLxzgDKfS08fUCpZxmpi3Hd121NXtPgKZJPLlzViMPlUUxqMBk17MIq0MneX61g4ZReMCKAildZKVDDnw7NzFEwpFMynTRqfHiIYRc54zkB01YykqXi2KWNpGs9q9Z5sj8BiDseDI/0OMDE2uo6kUjrIpFhyWsKgqQRxOYXRQCAY7vyCKebCfghgRH+Oi1/srw+Oxn3PqKm8rgIbkzdY1yt2HEgj2/Egl2b2u2DaIRYxmmQ6PH+UbrTXIJFmZC7/tWW3ORal9xcXTDLTpYGxIsPH+WkqwzteX18/Pu33C05c1sz4SsIwjEAwcn98dGqfQsWW9LsUw2ZjgoRKzgZKwhDshaLZwRjuDKv2kGOpNPwEYC7mc+newdw1/aK4EnKBOJVkPqM5eEniJqvVYkfTTUk/HB96fUnT7kwlITpeYhvS13QJljVUzA4LrxQIxjt/+/Ytk8xb+6F5jNLsMzCHdceQubhTy6gZl5UkWdVVrehI/GoibhYmd3pMOFcVrU7gvFdrLHYYmJOdErVeUMzw7A3E2wvA8+bt+YMDYw7WWQz67sv2vqZK6iMqmEnHqe3va2UpzvNFnn+kf6YqpaPjgrBEIZhSoJn2zuXJyclOKJjhGcQbFmfLAXPH/B2ePpMHI6RyNAYyvgsctFpCC3qY+Kq2pvLqI75YfAQjqS+DmZ0fIP47DBRDShMI5uSk3WMW0768vDxj8ebszF4GmC35Jhjmv4piyUdUL/3xeMS9dAo89HkmGz46MEzAkcLKCsBxdG3ymT6GzmvOMolox4twKZVOdk5+Ofg1FMyLF5cvAM6L1yR+XQoY89ZpAPzqhyW6btNhYNZHg4H90vakoqZOmGDUguN53honG1rPMR3VWQTmmnkvM98woZLX1x/bUTBYsQ8O2kwww18OaPzwwwsSy0wlYJFSLEX03abZNA0tU9uvOWNMJHSY47EHo0W5pmrb1GF0R3ee7z7f3VVr9Iao8fxnFBMLLPf648fr62vh7N0/37UjiURK08EBK9XeDoFCsPwIyzev95divjhxaQEQX/RbJt4HCg/0TzVIkx4Wpf5gfdTvD8bH60e6E1eZYGp4lczV2vPdOH4BS3W0oiG727cnw4OvO1wDFKFx9g7iGSQHgCnNpRI0MwcHvUAwP0Ti54ODnw+yz7POfYMBIq7ZwlsnZOh3L1fVXfn5/u7KasLB7u5wAB2etz4+Pjo8dKj3Tr7TV/DGhvhxGFyC1dRqiZVEnNcyC0bXeLbow7uPZ++6H549+9s3GD8+e/Y6BIMPlAyAoaeTdhiSH4EKfRz8n7nzCW0by+O4MdJBhIWiuJRdCGwuY8oSnRKQTC9LdQu67NUwFzvIo6wJtdubTzHjw5K03hpaQohDO2CDbQyJD7EPYSP/ielcbGXxwWGwHWboQgOBPS3TmcL+fu9JtuyoSXux87Ml698rvI+/v+97enqpm/XDev9yujOqPBw7Pv3S8+ygWMSxKU7Lg2TOagDmSe00n/t+vVh89ncqGESCv9o3OXVzHMzvv+EDtFevXv329hxYRCKUC65HYFqoGmiUDg/pWO8LE8tEBIWfpgrmD5MzMxlm0QuWwXrBY47yxGNqx7mz06WTg+KDtPfpy9f//se6yz6L0V56DMyf3r69/BA5v3z16vJtJPJ2LIZgUC5zq3uQMYc2wVAWo9gJ8lMGcw9/Y5tj5sNe8jOVbrfmKYbpD7y7NnLHVqt0DJJZDzcf4iVeD+f6TIyD+VckGAEi//1wfm7iiJAFIQX3VsfB1A+v3ry5vHzxokqZCCMmSGhHmDKYD302XAx7wunHiy7Gg/nBkCxhXRy7kbPuCY5y+dM1xlXUXDfHBBhKwwfviC/CQyYhFBK+yAs7mLnDer3+AsBgtu1AQxQcyUWgZKYN5s9gm/jT3E6TndNHR7QnU8vn8nkwWS/7lWAAiA+Q+JBFULCgEER79lSaa7bq9e8QjABYdkZyEQReQAHtTB3MPVohL8mOiXqHa0sUDGTSUS2Z9G5wXwcGleHjCRkeIgJoeNjy4c44mNVWvfnd5eU5XBNEMEKEJJFAwmQ0ZTCce2SjE/VmzpZOKBj4ON1+1uy7vg6Mj6QQoCGy4eHrp1R8Y2Bo21Rvvrnk4QI5srMDMhEwf/B6nhdMPtMGQ2XCcSMsw7yywJyQpul7YeXrwYBCfBhQZx8RDVYaK9ycmxtpZm71sC6cB2VBluUMvDMCn4lEZMIFi0GBGaUS6cDg5Hm7yzBrRydLw6gdCLdZjIsZB8OTr5xgQRoC3Y+Qiqbm5uxo6nU5iiHLvkwG2NBNKIlgfATOLMB4GO+1SkK7FM6PsJyeHNRvshjOyWMwjXiaDySRqFiQi09ozdkHHg7rFhdY5Kgc9UWjRGmUDBaYBRgX5/iHOGHr9nrp+HjppHV4ExfWAQw/+r4JDjMrSHbxNjComB3CBbAQQPTTKkmLTxfMHx17sOax5NEQzG7tZjCOHkMSSLZqRrwmSrMD3GfPbjGr9cxQMVGf7CN4TI687JsBmPs3VfMgf0p7eKe5s/zaw3nrhPs6SLejYgCMLAvUcAVKhoCBCI55b+t5uSyXEYzMo/kSj6FYwIflOwYG7gnOjtFmTpfWzta468riblGMnBEEsFLa2gqmZizl2BWTypTL5WhZ132yTBomeAEYKhnYnwGYf94Exp18mj47WdrdPXGvux1wMLeAASakiSGpgFlEFjOaqVTLHAxPtTPldjsT1XXqvARPFJOIFJSJVd0hxWhub7h/UDtdS76GXg7L4eCL9jUeQ2qJK8GyGMtnotH2c4gW2steFba6sLQhQDfguySpQCoy6RUSD47qv86iVXKSS/jJD+mi52r76OzZ6+RjbaevFZs7zWLY/cVgsH5YxZKeMdGAdfBlSJhytw1kuqk9yKNWM/XcjC4cLmNEo6YXU3fiZb1UuhtguOJB8GE6mXx59fLkJH90vJ5ONZvNTx8/fuSvNjTmy8A0ysQy9EajoeukdcmUSuWy3h4MuhDNZooMPux1uwRLndIBNnIZS0ajGatF0xt3Bkza+zAd/tt2Llerwb1kkljKgrbST2WCTT7VZ78EjKSDxWTKDQydz2ADU4IalgaDyqBSsfq+q11V9fslONp9bqHRGzr4b4a3uoWzUAzj1MLM/6WY7n9zVd0+wva69qPdWrQ+KOdTn7kdTKmktxGMBDho2yQDllKFRLdqjcgMVD+QAXj+hmTCGUjgw1BUp8V4oTwDMNc7JSybrFav9oqay50nHZl8ePyChcNPH4MOw1bXwEh6u1TyS1Kp1Ib6tcvwxccol5jUuDLBiH6IhrWSKpBT3e6gBM1Z2e8v07usUkO6A6nEPN09qJJ6c7lcDiWjXbsDSH36WNVuAyOV2rokARipAV89SEeywEiAoGo+1Sdg4BrkYqKBaOhypi0hGCgqg5z+cwc8xru+XqRC2v1mG8cdHCyF6Rfvzd+mmAbFIkGO6DpsqVK8Ege5IAp/l4K58kMm4UV+ySIEGdUVL34S2v4BCCam8zocnw0YbiyhtOHeg+3tGtwRMNZw5xiHlebKzeYrYVUbpKror+glvUpFlAgG/8AEI6mqZIUfT0iIKha7+HWgShmhpIolKCrNUjHMNUretV0As2bZ84QhLZDnBp8F4xdFkSpGkoCGCq3PRS8mSuQFp+hdQVUkIUkxygSFhTyBzIXfXxpgMVjEGYGBKrNDQdh6/U9+rC0dhxnH4ReXa7H66AYwIhIgbwJCFNVeT5RiMdyMwYuM4rW6sZgyvBLRSMgQQSEZ1S+qiEVUZwIGu/yWXNweu2ge7OZz3y4yDvePdPy8+cimo0kwMXEYMSmmABegEoNQYrhxhc8HKvF4PBZXkA0VFhiRapYBMoSnKCpKfFapNEQxPmiV3j1eX2HoiLDTsM1ideVzivnFBKOIKAn46F2o8bgCVBQFQcSwJ9ONxxENBGEjkpRDGKqoomZ6ZBMifhdapWF2gQ+vs9dkMmY2C9XF4eEJxRBtKKRaSMLf8xM+IpBBEGKltbqHSAIUTBx1FCMXh4BGSIG0ky78igj/xNQ95v5Er/f6EItn7Bh7rRXj+n1u6NrjigEYClQJoIQoGKwf1F9RqEYq3coALoBdJQAHAwpJMygTSoTUkEpU1bggFjMLMIxtugPndWilbn7Mxi32H1qgJhQDagnRBVkAHcMIoVuYYGBNgITgFQcSCcABbTpsQcAKk0mEZFKI+c5AMRrDhtF6OdbrUG837emyzGfRzDcXHcH8ogQCgXgApQCvUC+kGltGKJQI4GGSQnA2kMCzCqBIGAmAQajQECGjSDKp6vSb6/sMmSqkaW7G7cKhFtaeVFBd9in+J3BuGxjumoQe9Z1bpQANwifR62QTCWMrkSBgAoglkEUy5kWKAadCtkAJJcCAez2VdGWmD8YVPqBmQjq91tMQnOwBFqvB/SOj/dUDJzg6XcihZWo5ewytcpasE70EbGRBMgkQCaGTzWbJ6SzKJpBFMBNsAI0SEy+wKxMKTRkMy3Bcmkyg8rD4cIg+IGI02jzjnBAX/sYw1hznTzEebnKoF7SkLTqCyZKgBDod3N7ayhoGHjDwoEFPI7ZAAsDAp50MiiubUEEyirG1v/9+umA4jfGw0Od1e7UNuEcK49wYFmcQMRyTLLrDnJVd+Fc5Hicnxsm+nDOYLSBBw+gkAMpwd2sZV4QUcEoY2YABe0giodj1YhhGJ9S7KGzub26+n3Y/hvGyHhf72JPWqIFwIBo3x2kah9YCjEazP1h7PxDvItML433DcTBbm/gi707HJLK5DHtby5sUl7G8iUmFQjEKRseK/9H4+ed3hQK8C4V9IDNtMJAabkbTWFeY49wL2kYybWuzGTL9m6ED4MxGMuyat09IXJgnaeXWHB/qA5jNZRr7ncLy/j7dBiabAMcwCoVOBxYEYMW7wjtKolB4//59Yf//7Z09a+NAEIaDWHFscRwhxpAiRSr/Abu7QnDVVZeAuF6NC0FIl8IBFybFtddu4bRbmFTLFvoHhkjVIrZPfsi9M6t1bOeLg0PX5EWyViMpMI9mZz8kxxst+q5KiJgRqBwl4FMmJ1/FKLxDJEsknnQpEglzchHb7Ne6gclLD/UfAwdaV+vFeEV+kstr6AELOLAoIjgmFuNs3KFcWFfcmMAEMQb1nmN4XJ2kg80seNhMTpKkjLOX8pXB9dszeAwmyzKlFuuH1Xq9wQB1sZR1oqLKNhyp4G5uChPjBRr3C+Y3sNDrq+XPSdkNgLivx01zchIHlKlItx9bi2/ifTDTRwQAuY6V7jtzUAqLUjUViEdY4koW1Vlt1RbFKlYkXN4vmGMeOCNJyOUdtcklNUgH8jIOE7ZmYlJKOQPKzvwI/4VJdFH+2I0YjoaORXYbNixtGUKIlYCMT1bZlqxuvA3RQlh7rkolOVguDwZ3ywGlX/l8wJg8dXoF9/rkpYhgxPYFcr8qdWBUB4a958pVU9mGcCIuFitOqQmc4uix1mZj3TinF7d8POu5KqWp5O5JirY5mUy4j9cxQd+GJhqOkH23a84FznxKMvKNHBNvfSBDMCp4Cy9txWGjA7mqsljGlbV1VncZxxoNq0MGbow22Lc9gzlOqe2JFUfuzrxgcCnjKCC2SJSSRt1UxDtvOzzWJHJZG6MJhvbeEJqKvK51YwHCYgfSlfONrugKhIvBBVobVxSF867wWjdVz821TJPBqExFNxISm25sKimZkHHE79LLZ43S6cXuswWE3e53CYyp4F6lmyB42rRG17j/mtR4U1cIEg0IxnsHGQswOE6MGAxs3p8XrmnMr17BfBbhP4S/0v7uTjbsPV06Fc9elMn3wIBJ27Stb13bwHdjsI8KhADRLSh5RIhSiI+W5AHHUKXKbFFQGBnHdnd+3uJP9Qvm+ow1P5vP57Sdh72o2VMxmmdne5rNZ9ez7ujO7wx8z6/yPB8Oh1gP6fMwv78/HN4HkSEPRT4t72kR8AAAAChJREFUz/kzWHI6le3BPMyvrr70CuZ/a/ppOn3B+A/18ftKH2D+Tn8ASnmqsboVzKUAAAAASUVORK5CYII="> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_marked_watershed.html#sphx-glr-auto-examples-segmentation-plot-marked-watershed-py"><span class="std std-ref">Markers for watershed transform</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo...">
<div class="figure align-default" id="id37"> <img alt="Segment human cells (in mitosis)" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></span></p> </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.segmentation.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.segmentation.html</a>
  </p>
</div>
