<h1 id="module-morphology">Module: morphology</h1> <table class="longtable docutils align-default" id="module-skimage.morphology">   <tr>
<td><p><a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code>skimage.morphology.area_closing</code></a>(image[, …])</p></td> <td><p>Perform an area closing of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code>skimage.morphology.area_opening</code></a>(image[, …])</p></td> <td><p>Perform an area opening of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.ball" title="skimage.morphology.ball"><code>skimage.morphology.ball</code></a>(radius[, dtype])</p></td> <td><p>Generates a ball-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.binary_closing" title="skimage.morphology.binary_closing"><code>skimage.morphology.binary_closing</code></a>(image[, …])</p></td> <td><p>Return fast binary morphological closing of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.binary_dilation" title="skimage.morphology.binary_dilation"><code>skimage.morphology.binary_dilation</code></a>(image[, …])</p></td> <td><p>Return fast binary morphological dilation of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.binary_erosion" title="skimage.morphology.binary_erosion"><code>skimage.morphology.binary_erosion</code></a>(image[, …])</p></td> <td><p>Return fast binary morphological erosion of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.binary_opening" title="skimage.morphology.binary_opening"><code>skimage.morphology.binary_opening</code></a>(image[, …])</p></td> <td><p>Return fast binary morphological opening of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code>skimage.morphology.black_tophat</code></a>(image[, …])</p></td> <td><p>Return black top hat of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.closing" title="skimage.morphology.closing"><code>skimage.morphology.closing</code></a>(image[, selem, out])</p></td> <td><p>Return greyscale morphological closing of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.convex_hull_image" title="skimage.morphology.convex_hull_image"><code>skimage.morphology.convex_hull_image</code></a>(image)</p></td> <td><p>Compute the convex hull image of a binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.convex_hull_object" title="skimage.morphology.convex_hull_object"><code>skimage.morphology.convex_hull_object</code></a>(image, *)</p></td> <td><p>Compute the convex hull image of individual objects in a binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.cube" title="skimage.morphology.cube"><code>skimage.morphology.cube</code></a>(width[, dtype])</p></td> <td><p>Generates a cube-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code>skimage.morphology.diameter_closing</code></a>(image[, …])</p></td> <td><p>Perform a diameter closing of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code>skimage.morphology.diameter_opening</code></a>(image[, …])</p></td> <td><p>Perform a diameter opening of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.diamond" title="skimage.morphology.diamond"><code>skimage.morphology.diamond</code></a>(radius[, dtype])</p></td> <td><p>Generates a flat, diamond-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.dilation" title="skimage.morphology.dilation"><code>skimage.morphology.dilation</code></a>(image[, selem, …])</p></td> <td><p>Return greyscale morphological dilation of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.disk" title="skimage.morphology.disk"><code>skimage.morphology.disk</code></a>(radius[, dtype])</p></td> <td><p>Generates a flat, disk-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.erosion" title="skimage.morphology.erosion"><code>skimage.morphology.erosion</code></a>(image[, selem, …])</p></td> <td><p>Return greyscale morphological erosion of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.flood" title="skimage.morphology.flood"><code>skimage.morphology.flood</code></a>(image, seed_point, *)</p></td> <td><p>Mask corresponding to a flood fill.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.flood_fill" title="skimage.morphology.flood_fill"><code>skimage.morphology.flood_fill</code></a>(image, …[, …])</p></td> <td><p>Perform flood filling on an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code>skimage.morphology.h_maxima</code></a>(image, h[, selem])</p></td> <td><p>Determine all maxima of the image with height &gt;= h.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code>skimage.morphology.h_minima</code></a>(image, h[, selem])</p></td> <td><p>Determine all minima of the image with depth &gt;= h.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.label" title="skimage.morphology.label"><code>skimage.morphology.label</code></a>(input[, …])</p></td> <td><p>Label connected regions of an integer array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code>skimage.morphology.local_maxima</code></a>(image[, …])</p></td> <td><p>Find local maxima of n-dimensional array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code>skimage.morphology.local_minima</code></a>(image[, …])</p></td> <td><p>Find local minima of n-dimensional array.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>(image[, …])</p></td> <td><p>Build the max tree from an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.max_tree_local_maxima" title="skimage.morphology.max_tree_local_maxima"><code>skimage.morphology.max_tree_local_maxima</code></a>(image)</p></td> <td><p>Determine all local maxima of the image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>skimage.morphology.medial_axis</code></a>(image[, …])</p></td> <td><p>Compute the medial axis transform of a binary image</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.octagon" title="skimage.morphology.octagon"><code>skimage.morphology.octagon</code></a>(m, n[, dtype])</p></td> <td><p>Generates an octagon shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.octahedron" title="skimage.morphology.octahedron"><code>skimage.morphology.octahedron</code></a>(radius[, dtype])</p></td> <td><p>Generates a octahedron-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.opening" title="skimage.morphology.opening"><code>skimage.morphology.opening</code></a>(image[, selem, out])</p></td> <td><p>Return greyscale morphological opening of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.reconstruction" title="skimage.morphology.reconstruction"><code>skimage.morphology.reconstruction</code></a>(seed, mask)</p></td> <td><p>Perform a morphological reconstruction of an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.rectangle" title="skimage.morphology.rectangle"><code>skimage.morphology.rectangle</code></a>(nrows, ncols[, …])</p></td> <td><p>Generates a flat, rectangular-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code>skimage.morphology.remove_small_holes</code></a>(ar[, …])</p></td> <td><p>Remove contiguous holes smaller than the specified size.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code>skimage.morphology.remove_small_objects</code></a>(ar)</p></td> <td><p>Remove objects smaller than the specified size.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skimage.morphology.skeletonize</code></a>(image, *[, …])</p></td> <td><p>Compute the skeleton of a binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.skeletonize_3d" title="skimage.morphology.skeletonize_3d"><code>skimage.morphology.skeletonize_3d</code></a>(image)</p></td> <td><p>Compute the skeleton of a binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.square" title="skimage.morphology.square"><code>skimage.morphology.square</code></a>(width[, dtype])</p></td> <td><p>Generates a flat, square-shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.star" title="skimage.morphology.star"><code>skimage.morphology.star</code></a>(a[, dtype])</p></td> <td><p>Generates a star shaped structuring element.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.thin" title="skimage.morphology.thin"><code>skimage.morphology.thin</code></a>(image[, max_iter])</p></td> <td><p>Perform morphological thinning of a binary image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.watershed" title="skimage.morphology.watershed"><code>skimage.morphology.watershed</code></a>(image[, …])</p></td> <td><p><strong>Deprecated function</strong>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code>skimage.morphology.white_tophat</code></a>(image[, …])</p></td> <td><p>Return white top hat of an image.</p></td> </tr>  </table>  <h2 id="area-closing">area_closing</h2> <dl class="function"> <dt id="skimage.morphology.area_closing">
<code>skimage.morphology.area_closing(image, area_threshold=64, connectivity=1, parent=None, tree_traverser=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L349-L472"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform an area closing of the image.</p> <p>Area closing removes all dark structures of an image with a surface smaller than area_threshold. The output image is larger than or equal to the input image for every pixel and all local minima have at least a surface of area_threshold pixels.</p> <p>Area closings are similar to morphological closings, but they do not use a fixed structuring element, but rather a deformable one, with surface = area_threshold.</p> <p>In the binary case, area closings are equivalent to remove_small_holes; this operator is thus extended to gray-level images.</p> <p>Technically, this operator is based on the max-tree representation of the image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the area_closing is to be calculated. This image can be of any type.</p> </dd> <dt>
<code>area_thresholdunsigned int</code> </dt>
<dd>
<p>The size parameter (number of pixels). The default value is arbitrarily chosen to be 64.</p> </dd> <dt>
<code>connectivityunsigned int, optional</code> </dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> <dt>
<code>parentndarray, int64, optional</code> </dt>
<dd>
<p>Parent image representing the max tree of the inverted image. The value of each pixel is the index of its parent in the ravelled array. See Note for further details.</p> </dd> <dt>
<code>tree_traverser1D array, int64, optional</code> </dt>
<dd>
<p>The ordered pixel indices (referring to the ravelled array). The pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<p>Output image of the same shape and type as input image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code>skimage.morphology.area_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code>skimage.morphology.diameter_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code>skimage.morphology.diameter_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code>skimage.morphology.remove_small_objects</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code>skimage.morphology.remove_small_holes</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>If a max-tree representation (parent and tree_traverser) are given to the function, they must be calculated from the inverted image for this function, i.e.: &gt;&gt;&gt; P, S = max_tree(invert(f)) &gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rce2615f30276-1">
<code>1</code> </dt> <dd>
<p>Vincent L., Proc. “Grayscale area openings and closings, their efficient implementation and applications”, EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, pp.22-27, May 1993.</p> </dd> <dt class="label" id="rce2615f30276-2">
<code>2</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883. <a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p> </dd> <dt class="label" id="rce2615f30276-3">
<code>3</code> </dt> <dd>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570. <a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p> </dd> <dt class="label" id="rce2615f30276-4">
<code>4</code> </dt> <dd>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539. <a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p> </dd> <dt class="label" id="rce2615f30276-5">
<code>5</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. <a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create an image (quadratic function with a minimum in the center and 4 additional local minima.</p> <pre data-language="python">&gt;&gt;&gt; w = 12
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 180 + 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:3,1:5] = 160; f[2:4,9:11] = 140; f[9:11,2:4] = 120
&gt;&gt;&gt; f[9:10,9:11] = 100; f[10,10] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate the area closing:</p> <pre data-language="python">&gt;&gt;&gt; closed = area_closing(f, 8, connectivity=1)
</pre> <p>All small minima are removed, and the remaining minima have at least a size of 8.</p> </dd>
</dl>   <h2 id="area-opening">area_opening</h2> <dl class="function"> <dt id="skimage.morphology.area_opening">
<code>skimage.morphology.area_opening(image, area_threshold=64, connectivity=1, parent=None, tree_traverser=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L146-L254"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform an area opening of the image.</p> <p>Area opening removes all bright structures of an image with a surface smaller than area_threshold. The output image is thus the largest image smaller than the input for which all local maxima have at least a surface of area_threshold pixels.</p> <p>Area openings are similar to morphological openings, but they do not use a fixed structuring element, but rather a deformable one, with surface = area_threshold. Consequently, the area_opening with area_threshold=1 is the identity.</p> <p>In the binary case, area openings are equivalent to remove_small_objects; this operator is thus extended to gray-level images.</p> <p>Technically, this operator is based on the max-tree representation of the image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the area_opening is to be calculated. This image can be of any type.</p> </dd> <dt>
<code>area_thresholdunsigned int</code> </dt>
<dd>
<p>The size parameter (number of pixels). The default value is arbitrarily chosen to be 64.</p> </dd> <dt>
<code>connectivityunsigned int, optional</code> </dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> <dt>
<code>parentndarray, int64, optional</code> </dt>
<dd>
<p>Parent image representing the max tree of the image. The value of each pixel is the index of its parent in the ravelled array.</p> </dd> <dt>
<code>tree_traverser1D array, int64, optional</code> </dt>
<dd>
<p>The ordered pixel indices (referring to the ravelled array). The pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<p>Output image of the same shape and type as the input image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code>skimage.morphology.area_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code>skimage.morphology.diameter_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code>skimage.morphology.diameter_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.remove_small_objects" title="skimage.morphology.remove_small_objects"><code>skimage.morphology.remove_small_objects</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.remove_small_holes" title="skimage.morphology.remove_small_holes"><code>skimage.morphology.remove_small_holes</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rab8157de4f2f-1">
<code>1</code> </dt> <dd>
<p>Vincent L., Proc. “Grayscale area openings and closings, their efficient implementation and applications”, EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, pp.22-27, May 1993.</p> </dd> <dt class="label" id="rab8157de4f2f-2">
<code>2</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883. :DOI:10.1007/978-3-662-05088-0</p> </dd> <dt class="label" id="rab8157de4f2f-3">
<code>3</code> </dt> <dd>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570. :DOI:10.1109/83.663500</p> </dd> <dt class="label" id="rab8157de4f2f-4">
<code>4</code> </dt> <dd>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539. :DOI:10.1109/TIP.2006.877518</p> </dd> <dt class="label" id="rab8157de4f2f-5">
<code>5</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. :DOI:10.1109/TIP.2014.2336551</p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create an image (quadratic function with a maximum in the center and 4 additional local maxima.</p> <pre data-language="python">&gt;&gt;&gt; w = 12
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:3,1:5] = 40; f[2:4,9:11] = 60; f[9:11,2:4] = 80
&gt;&gt;&gt; f[9:10,9:11] = 100; f[10,10] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate the area opening:</p> <pre data-language="python">&gt;&gt;&gt; open = area_opening(f, 8, connectivity=1)
</pre> <p>The peaks with a surface smaller than 8 are removed.</p> </dd>
</dl>   <h2 id="ball">ball</h2> <dl class="function"> <dt id="skimage.morphology.ball">
<code>skimage.morphology.ball(radius, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L231-L259"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a ball-shaped structuring element.</p> <p>This is the 3D equivalent of a disk. A pixel is within the neighborhood if the Euclidean distance between it and the origin is no greater than radius.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radiusint</code> </dt>
<dd>
<p>The radius of the ball-shaped structuring element.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-ball">Examples using <code>skimage.morphology.ball</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example enhances an image with low contrast, using a method called *local histogram equali...">
<div class="figure align-default" id="id53"> <img alt="Local Histogram Equalization" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/color_exposure/plot_local_equalize.html#sphx-glr-auto-examples-color-exposure-plot-local-equalize-py"><span class="std std-ref">Local Histogram Equalization</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val...">
<div class="figure align-default" id="id54"> <img alt="Rank filters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span></p> </div> </div>   <h2 id="binary-closing">binary_closing</h2> <dl class="function"> <dt id="skimage.morphology.binary_closing">
<code>skimage.morphology.binary_closing(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/binary.py#L115-L146"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological closing of an image.</p> <p>This function returns the same result as greyscale closing but performs faster for binary images.</p> <p>The morphological closing on an image is defined as a dilation followed by an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect small bright cracks. This tends to “close” up (dark) gaps between (bright) features.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Binary input image.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use a cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray of bool, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>closingndarray of bool</code> </dt>
<dd>
<p>The result of the morphological closing.</p> </dd> </dl> </dd> </dl> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-binary-closing">Examples using <code>skimage.morphology.binary_closing</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id55"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>   <h2 id="binary-dilation">binary_dilation</h2> <dl class="function"> <dt id="skimage.morphology.binary_dilation">
<code>skimage.morphology.binary_dilation(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/binary.py#L46-L78"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological dilation of an image.</p> <p>This function returns the same result as greyscale dilation but performs faster for binary images.</p> <p>Morphological dilation sets a pixel at <code>(i,j)</code> to the maximum over all pixels in the neighborhood centered at <code>(i,j)</code>. Dilation enlarges bright regions and shrinks dark regions.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Binary input image.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use a cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray of bool, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>dilatedndarray of bool or uint</code> </dt>
<dd>
<p>The result of the morphological dilation with values in <code>[False, True]</code>.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="binary-erosion">binary_erosion</h2> <dl class="function"> <dt id="skimage.morphology.binary_erosion">
<code>skimage.morphology.binary_erosion(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/binary.py#L11-L43"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological erosion of an image.</p> <p>This function returns the same result as greyscale erosion but performs faster for binary images.</p> <p>Morphological erosion sets a pixel at <code>(i,j)</code> to the minimum over all pixels in the neighborhood centered at <code>(i,j)</code>. Erosion shrinks bright regions and enlarges dark regions.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Binary input image.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use a cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray of bool, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>erodedndarray of bool or uint</code> </dt>
<dd>
<p>The result of the morphological erosion taking values in <code>[False, True]</code>.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="binary-opening">binary_opening</h2> <dl class="function"> <dt id="skimage.morphology.binary_opening">
<code>skimage.morphology.binary_opening(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/binary.py#L81-L112"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return fast binary morphological opening of an image.</p> <p>This function returns the same result as greyscale opening but performs faster for binary images.</p> <p>The morphological opening on an image is defined as an erosion followed by a dilation. Opening can remove small bright spots (i.e. “salt”) and connect small dark cracks. This tends to “open” up (dark) gaps between (bright) features.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Binary input image.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use a cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray of bool, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>openingndarray of bool</code> </dt>
<dd>
<p>The result of the morphological opening.</p> </dd> </dl> </dd> </dl> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-binary-opening">Examples using <code>skimage.morphology.binary_opening</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id56"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>   <h2 id="black-tophat">black_tophat</h2> <dl class="function"> <dt id="skimage.morphology.black_tophat">
<code>skimage.morphology.black_tophat(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L429-L489"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return black top hat of an image.</p> <p>The black top hat of an image is defined as its morphological closing minus the original image. This operation returns the dark spots of the image that are smaller than the structuring element. Note that dark spots in the original image are bright spots after the black top hat.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outarray, same shape and type as image</code> </dt>
<dd>
<p>The result of the morphological black top hat.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.white_tophat" title="skimage.morphology.white_tophat"><code>white_tophat</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd2d72f1c8811-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Change dark peak to bright peak and subtract background
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; dark_on_grey = np.array([[7, 6, 6, 6, 7],
...                          [6, 5, 4, 5, 6],
...                          [6, 4, 0, 4, 6],
...                          [6, 5, 4, 5, 6],
...                          [7, 6, 6, 6, 7]], dtype=np.uint8)
&gt;&gt;&gt; black_tophat(dark_on_grey, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="closing">closing</h2> <dl class="function"> <dt id="skimage.morphology.closing">
<code>skimage.morphology.closing(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L305-L352"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological closing of an image.</p> <p>The morphological closing on an image is defined as a dilation followed by an erosion. Closing can remove small dark spots (i.e. “pepper”) and connect small bright cracks. This tends to “close” up (dark) gaps between (bright) features.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>closingarray, same shape and type as image</code> </dt>
<dd>
<p>The result of the morphological closing.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Close a gap between two bright lines
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; broken_line = np.array([[0, 0, 0, 0, 0],
...                         [0, 0, 0, 0, 0],
...                         [1, 1, 0, 1, 1],
...                         [0, 0, 0, 0, 0],
...                         [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; closing(broken_line, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="convex-hull-image">convex_hull_image</h2> <dl class="function"> <dt id="skimage.morphology.convex_hull_image">
<code>skimage.morphology.convex_hull_image(image, offset_coordinates=True, tolerance=1e-10)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/convex_hull.py#L73-L145"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the convex hull image of a binary image.</p> <p>The convex hull is the set of pixels included in the smallest convex polygon that surround all white pixels in the input image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagearray</code> </dt>
<dd>
<p>Binary input image. This array is cast to bool before processing.</p> </dd> <dt>
<code>offset_coordinatesbool, optional</code> </dt>
<dd>
<p>If <code>True</code>, a pixel at coordinate, e.g., (4, 7) will be represented by coordinates (3.5, 7), (4.5, 7), (4, 6.5), and (4, 7.5). This adds some “extent” to a pixel when computing the hull.</p> </dd> <dt>
<code>tolerancefloat, optional</code> </dt>
<dd>
<p>Tolerance when determining whether a point is inside the hull. Due to numerical floating point errors, a tolerance of 0 can result in some points erroneously being classified as being outside the hull.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>hull(M, N) array of bool</code> </dt>
<dd>
<p>Binary image with pixels in convex hull set to True.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rf22b92a8225f-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/">https://blogs.mathworks.com/steve/2011/10/04/binary-image-convex-hull-algorithm-notes/</a></p> </dd> </dl> </dd>
</dl>   <h2 id="convex-hull-object">convex_hull_object</h2> <dl class="function"> <dt id="skimage.morphology.convex_hull_object">
<code>skimage.morphology.convex_hull_object(image, *, connectivity=2)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/convex_hull.py#L148-L197"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the convex hull image of individual objects in a binary image.</p> <p>The convex hull is the set of pixels included in the smallest convex polygon that surround all white pixels in the input image.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image(M, N) ndarray</code> </dt>
<dd>
<p>Binary input image.</p> </dd> <dt>
<code>connectivity{1, 2}, int, optional</code> </dt>
<dd>
<p>Determines the neighbors of each pixel. Adjacent elements within a squared distance of <code>connectivity</code> from pixel center are considered neighbors.:</p> <pre data-language="python">1-connectivity      2-connectivity
      [ ]           [ ]  [ ]  [ ]
       |               \  |  /
 [ ]--[x]--[ ]      [ ]--[x]--[ ]
       |               /  |  \
      [ ]           [ ]  [ ]  [ ]
</pre> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>hullndarray of bool</code> </dt>
<dd>
<p>Binary image with pixels inside convex hull set to <code>True</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function uses <code>skimage.morphology.label</code> to define unique objects, finds the convex hull of each using <code>convex_hull_image</code>, and combines these regions with logical OR. Be aware the convex hulls of unconnected objects may overlap in the result. If this is suspected, consider using convex_hull_image separately on each object or adjust <code>connectivity</code>.</p> </dd>
</dl>   <h2 id="cube">cube</h2> <dl class="function"> <dt id="skimage.morphology.cube">
<code>skimage.morphology.cube(width, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L170-L194"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a cube-shaped structuring element.</p> <p>This is the 3D equivalent of a square. Every pixel along the perimeter has a chessboard distance no greater than radius (radius=floor(width/2)) pixels.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>widthint</code> </dt>
<dd>
<p>The width, height and depth of the cube.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="diameter-closing">diameter_closing</h2> <dl class="function"> <dt id="skimage.morphology.diameter_closing">
<code>skimage.morphology.diameter_closing(image, diameter_threshold=8, connectivity=1, parent=None, tree_traverser=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L475-L579"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a diameter closing of the image.</p> <p>Diameter closing removes all dark structures of an image with maximal extension smaller than diameter_threshold. The maximal extension is defined as the maximal extension of the bounding box. The operator is also called Bounding Box Closing. In practice, the result is similar to a morphological closing, but long and thin structures are not removed.</p> <p>Technically, this operator is based on the max-tree representation of the image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the diameter_closing is to be calculated. This image can be of any type.</p> </dd> <dt>
<code>diameter_thresholdunsigned int</code> </dt>
<dd>
<p>The maximal extension parameter (number of pixels). The default value is 8.</p> </dd> <dt>
<code>connectivityunsigned int, optional</code> </dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> <dt>
<code>parentndarray, int64, optional</code> </dt>
<dd>
<p>Precomputed parent image representing the max tree of the inverted image. This function is fast, if precomputed parent and tree_traverser are provided. See Note for further details.</p> </dd> <dt>
<code>tree_traverser1D array, int64, optional</code> </dt>
<dd>
<p>Precomputed traverser, where the pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent). This function is fast, if precomputed parent and tree_traverser are provided. See Note for further details.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<p>Output image of the same shape and type as input image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code>skimage.morphology.area_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code>skimage.morphology.area_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_opening" title="skimage.morphology.diameter_opening"><code>skimage.morphology.diameter_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>If a max-tree representation (parent and tree_traverser) are given to the function, they must be calculated from the inverted image for this function, i.e.: &gt;&gt;&gt; P, S = max_tree(invert(f)) &gt;&gt;&gt; closed = diameter_closing(f, 3, parent=P, tree_traverser=S)</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r0f793839edcd-1">
<code>1</code> </dt> <dd>
<p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg. <a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p> </dd> <dt class="label" id="r0f793839edcd-2">
<code>2</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. <a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create an image (quadratic function with a minimum in the center and 4 additional local minima.</p> <pre data-language="python">&gt;&gt;&gt; w = 12
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 180 + 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:3,1:5] = 160; f[2:4,9:11] = 140; f[9:11,2:4] = 120
&gt;&gt;&gt; f[9:10,9:11] = 100; f[10,10] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate the diameter closing:</p> <pre data-language="python">&gt;&gt;&gt; closed = diameter_closing(f, 3, connectivity=1)
</pre> <p>All small minima with a maximal extension of 2 or less are removed. The remaining minima have all a maximal extension of at least 3.</p> </dd>
</dl>   <h2 id="diameter-opening">diameter_opening</h2> <dl class="function"> <dt id="skimage.morphology.diameter_opening">
<code>skimage.morphology.diameter_opening(image, diameter_threshold=8, connectivity=1, parent=None, tree_traverser=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L257-L346"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a diameter opening of the image.</p> <p>Diameter opening removes all bright structures of an image with maximal extension smaller than diameter_threshold. The maximal extension is defined as the maximal extension of the bounding box. The operator is also called Bounding Box Opening. In practice, the result is similar to a morphological opening, but long and thin structures are not removed.</p> <p>Technically, this operator is based on the max-tree representation of the image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the area_opening is to be calculated. This image can be of any type.</p> </dd> <dt>
<code>diameter_thresholdunsigned int</code> </dt>
<dd>
<p>The maximal extension parameter (number of pixels). The default value is 8.</p> </dd> <dt>
<code>connectivityunsigned int, optional</code> </dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> <dt>
<code>parentndarray, int64, optional</code> </dt>
<dd>
<p>Parent image representing the max tree of the image. The value of each pixel is the index of its parent in the ravelled array.</p> </dd> <dt>
<code>tree_traverser1D array, int64, optional</code> </dt>
<dd>
<p>The ordered pixel indices (referring to the ravelled array). The pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outputndarray</code> </dt>
<dd>
<p>Output image of the same shape and type as the input image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.area_opening" title="skimage.morphology.area_opening"><code>skimage.morphology.area_opening</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.area_closing" title="skimage.morphology.area_closing"><code>skimage.morphology.area_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.diameter_closing" title="skimage.morphology.diameter_closing"><code>skimage.morphology.diameter_closing</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rff2b90016d8e-1">
<code>1</code> </dt> <dd>
<p>Walter, T., &amp; Klein, J.-C. (2002). Automatic Detection of Microaneurysms in Color Fundus Images of the Human Retina by Means of the Bounding Box Closing. In A. Colosimo, P. Sirabella, A. Giuliani (Eds.), Medical Data Analysis. Lecture Notes in Computer Science, vol 2526, pp. 210-220. Springer Berlin Heidelberg. <a class="reference external" href="https://doi.org/10.1007/3-540-36104-9_23">DOI:10.1007/3-540-36104-9_23</a></p> </dd> <dt class="label" id="rff2b90016d8e-2">
<code>2</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. <a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create an image (quadratic function with a maximum in the center and 4 additional local maxima.</p> <pre data-language="python">&gt;&gt;&gt; w = 12
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:3,1:5] = 40; f[2:4,9:11] = 60; f[9:11,2:4] = 80
&gt;&gt;&gt; f[9:10,9:11] = 100; f[10,10] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate the diameter opening:</p> <pre data-language="python">&gt;&gt;&gt; open = diameter_opening(f, 3, connectivity=1)
</pre> <p>The peaks with a maximal extension of 2 or less are removed. The remaining peaks have all a maximal extension of at least 3.</p> </dd>
</dl>   <h2 id="diamond">diamond</h2> <dl class="function"> <dt id="skimage.morphology.diamond">
<code>skimage.morphology.diamond(radius, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L70-L97"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, diamond-shaped structuring element.</p> <p>A pixel is part of the neighborhood (i.e. labeled 1) if the city block/Manhattan distance between it and the center of the neighborhood is no greater than radius.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radiusint</code> </dt>
<dd>
<p>The radius of the diamond-shaped structuring element.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="dilation">dilation</h2> <dl class="function"> <dt id="skimage.morphology.dilation">
<code>skimage.morphology.dilation(image, selem=None, out=None, shift_x=False, shift_y=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L189-L252"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological dilation of an image.</p> <p>Morphological dilation sets a pixel at (i,j) to the maximum over all pixels in the neighborhood centered at (i,j). Dilation enlarges bright regions and shrinks dark regions.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as a 2-D array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None, is passed, a new array will be allocated.</p> </dd> <dt>
<code>shift_x, shift_ybool, optional</code> </dt>
<dd>
<p>shift structuring element about center point. This only affects eccentric structuring elements (i.e. selem with even numbered sides).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>dilateduint8 array, same shape and type as image</code> </dt>
<dd>
<p>The result of the morphological dilation.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>For <code>uint8</code> (and <code>uint16</code> up to a certain bit-depth) data, the lower algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.maximum" title="skimage.filters.rank.maximum"><code>skimage.filters.rank.maximum</code></a> function more efficient for larger images and structuring elements.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Dilation enlarges bright regions
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_pixel = np.array([[0, 0, 0, 0, 0],
...                          [0, 0, 0, 0, 0],
...                          [0, 0, 1, 0, 0],
...                          [0, 0, 0, 0, 0],
...                          [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; dilation(bright_pixel, square(3))
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-dilation">Examples using <code>skimage.morphology.dilation</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val...">
<div class="figure align-default" id="id57"> <img alt="Rank filters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span></p> </div> </div>   <h2 id="disk">disk</h2> <dl class="function"> <dt id="skimage.morphology.disk">
<code>skimage.morphology.disk(radius, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L100-L124"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, disk-shaped structuring element.</p> <p>A pixel is within the neighborhood if the Euclidean distance between it and the origin is no greater than radius.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radiusint</code> </dt>
<dd>
<p>The radius of the disk-shaped structuring element.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-disk">Examples using <code>skimage.morphology.disk</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example enhances an image with low contrast, using a method called *local histogram equali...">
<div class="figure align-default" id="id58"> <img alt="Local Histogram Equalization" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/color_exposure/plot_local_equalize.html#sphx-glr-auto-examples-color-exposure-plot-local-equalize-py"><span class="std std-ref">Local Histogram Equalization</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="In information theory, information entropy is the log-base-2 of the number of possible outcomes...">
<div class="figure align-default" id="id59"> <img alt="Entropy" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/filters/plot_entropy.html#sphx-glr-auto-examples-filters-plot-entropy-py"><span class="std std-ref">Entropy</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="The watershed is a classical algorithm used for **segmentation**, that is, for separating diffe...">
<div class="figure align-default" id="id60"> <img alt="Markers for watershed transform" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_marked_watershed.html#sphx-glr-auto-examples-segmentation-plot-marked-watershed-py"><span class="std std-ref">Markers for watershed transform</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Flood fill is an algorithm to identify and/or change adjacent values in an image based on their...">
<div class="figure align-default" id="id61"> <img alt="Flood Fill" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_floodfill.html#sphx-glr-auto-examples-segmentation-plot-floodfill-py"><span class="std std-ref">Flood Fill</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="In this example, we analyze a microscopy image of human cells. We use data provided by Jason Mo...">
<div class="figure align-default" id="id62"> <img alt="Segment human cells (in mitosis)" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_human_mitosis.html#sphx-glr-auto-examples-applications-plot-human-mitosis-py"><span class="std std-ref">Segment human cells (in mitosis)</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="Rank filters are non-linear filters using local gray-level ordering to compute the filtered val...">
<div class="figure align-default" id="id63"> <img alt="Rank filters" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/applications/plot_rank_filters.html#sphx-glr-auto-examples-applications-plot-rank-filters-py"><span class="std std-ref">Rank filters</span></a></span></p> </div> </div>   <h2 id="erosion">erosion</h2> <dl class="function"> <dt id="skimage.morphology.erosion">
<code>skimage.morphology.erosion(image, selem=None, out=None, shift_x=False, shift_y=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L130-L186"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological erosion of an image.</p> <p>Morphological erosion sets a pixel at (i,j) to the minimum over all pixels in the neighborhood centered at (i,j). Erosion shrinks bright regions and enlarges dark regions.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarrays, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> <dt>
<code>shift_x, shift_ybool, optional</code> </dt>
<dd>
<p>shift structuring element about center point. This only affects eccentric structuring elements (i.e. selem with even numbered sides).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>erodedarray, same shape as image</code> </dt>
<dd>
<p>The result of the morphological erosion.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>For <code>uint8</code> (and <code>uint16</code> up to a certain bit-depth) data, the lower algorithm complexity makes the <a class="reference internal" href="skimage.filters.rank.html#skimage.filters.rank.minimum" title="skimage.filters.rank.minimum"><code>skimage.filters.rank.minimum</code></a> function more efficient for larger images and structuring elements.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Erosion shrinks bright regions
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_square = np.array([[0, 0, 0, 0, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 1, 1, 1, 0],
...                           [0, 0, 0, 0, 0]], dtype=np.uint8)
&gt;&gt;&gt; erosion(bright_square, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="flood">flood</h2> <dl class="function"> <dt id="skimage.morphology.flood">
<code>skimage.morphology.flood(image, seed_point, *, selem=None, connectivity=None, tolerance=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_flood_fill.py#L124-L290"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Mask corresponding to a flood fill.</p> <p>Starting at a specific <code>seed_point</code>, connected points equal or within <code>tolerance</code> of the seed value are found.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>seed_pointtuple or int</code> </dt>
<dd>
<p>The point in <code>image</code> used as the starting point for the flood fill. If the image is 1D, this point may be given as an integer.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel. It must contain only 1’s and 0’s, have the same number of dimensions as <code>image</code>. If not given, all adjacent pixels are considered as part of the neighborhood (fully connected).</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is larger or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>tolerancefloat or int, optional</code> </dt>
<dd>
<p>If None (default), adjacent values must be strictly equal to the initial value of <code>image</code> at <code>seed_point</code>. This is fastest. If a value is given, a comparison will be done at every point and if within tolerance of the initial value will also be filled (inclusive).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>maskndarray</code> </dt>
<dd>
<p>A Boolean array with the same shape as <code>image</code> is returned, with True values for areas connected to and equal (or within tolerance of) the seed point. All other values are False.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many raster graphics programs. This function returns just the mask representing the fill.</p> <p>If indices are desired rather than masks for memory reasons, the user can simply run <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.nonzero.html#numpy.nonzero" title="(in NumPy v1.19)"><code>numpy.nonzero</code></a> on the result, save the indices, and discard this mask.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import flood
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = 1
&gt;&gt;&gt; image[3, 0] = 1
&gt;&gt;&gt; image[1:3, 4:6] = 2
&gt;&gt;&gt; image[3, 6] = 3
&gt;&gt;&gt; image
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, with full connectivity (diagonals included):</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (1, 1))
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [5, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (1, 1), connectivity=1)
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill with a tolerance:</p> <pre data-language="python">&gt;&gt;&gt; mask = flood(image, (0, 0), tolerance=1)
&gt;&gt;&gt; image_flooded = image.copy()
&gt;&gt;&gt; image_flooded[mask] = 5
&gt;&gt;&gt; image_flooded
array([[5, 5, 5, 5, 5, 5, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 5, 5, 3]])
</pre> </dd>
</dl>   <h2 id="flood-fill">flood_fill</h2> <dl class="function"> <dt id="skimage.morphology.flood_fill">
<code>skimage.morphology.flood_fill(image, seed_point, new_value, *, selem=None, connectivity=None, tolerance=None, in_place=False, inplace=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_flood_fill.py#L15-L121"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform flood filling on an image.</p> <p>Starting at a specific <code>seed_point</code>, connected points equal or within <code>tolerance</code> of the seed value are found, then set to <code>new_value</code>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>seed_pointtuple or int</code> </dt>
<dd>
<p>The point in <code>image</code> used as the starting point for the flood fill. If the image is 1D, this point may be given as an integer.</p> </dd> <dt>
<code>new_valueimage type</code> </dt>
<dd>
<p>New value to set the entire fill. This must be chosen in agreement with the dtype of <code>image</code>.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel. It must contain only 1’s and 0’s, have the same number of dimensions as <code>image</code>. If not given, all adjacent pixels are considered as part of the neighborhood (fully connected).</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is less than or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>tolerancefloat or int, optional</code> </dt>
<dd>
<p>If None (default), adjacent values must be strictly equal to the value of <code>image</code> at <code>seed_point</code> to be filled. This is fastest. If a tolerance is provided, adjacent points with values within plus or minus tolerance from the seed point are filled (inclusive).</p> </dd> <dt>
<code>in_placebool, optional</code> </dt>
<dd>
<p>If True, flood filling is applied to <code>image</code> in place. If False, the flood filled result is returned without modifying the input <code>image</code> (default).</p> </dd> <dt>
<code>inplacebool, optional</code> </dt>
<dd>
<p>This parameter is deprecated and will be removed in version 0.19.0 in favor of in_place. If True, flood filling is applied to <code>image</code> inplace. If False, the flood filled result is returned without modifying the input <code>image</code> (default).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>filledndarray</code> </dt>
<dd>
<p>An array with the same shape as <code>image</code> is returned, with values in areas connected to and equal (or within tolerance of) the seed point replaced with <code>new_value</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The conceptual analogy of this operation is the ‘paint bucket’ tool in many raster graphics programs.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import flood_fill
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = 1
&gt;&gt;&gt; image[3, 0] = 1
&gt;&gt;&gt; image[1:3, 4:6] = 2
&gt;&gt;&gt; image[3, 6] = 3
&gt;&gt;&gt; image
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, with full connectivity (diagonals included):</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (1, 1), 5)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [5, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill connected ones with 5, excluding diagonal points (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (1, 1), 5, connectivity=1)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [0, 5, 5, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Fill with a tolerance:</p> <pre data-language="python">&gt;&gt;&gt; flood_fill(image, (0, 0), 5, tolerance=1)
array([[5, 5, 5, 5, 5, 5, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 2, 2, 5],
       [5, 5, 5, 5, 5, 5, 3]])
</pre> </dd>
</dl>   <h2 id="h-maxima">h_maxima</h2> <dl class="function"> <dt id="skimage.morphology.h_maxima">
<code>skimage.morphology.h_maxima(image, h, selem=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/extrema.py#L48-L173"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine all maxima of the image with height &gt;= h.</p> <p>The local maxima are defined as connected sets of pixels with equal grey level strictly greater than the grey level of all pixels in direct neighborhood of the set.</p> <p>A local maximum M of height h is a local maximum for which there is at least one path joining M with an equal or higher local maximum on which the minimal value is f(M) - h (i.e. the values along the path are not decreasing by more than h with respect to the maximum’s value) and no path to an equal or higher local maximum for which the minimal value is greater.</p> <p>The global maxima of the image are also found by this function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the maxima are to be calculated.</p> </dd> <dt>
<code>hunsigned integer</code> </dt>
<dd>
<p>The minimal height of all extracted maxima.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an n-D array of 1’s and 0’s. Default is the ball of radius 1 according to the maximum norm (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>h_maxndarray</code> </dt>
<dd>
<p>The local maxima of height &gt;= h and the global maxima. The resulting image is a binary image, where pixels belonging to the determined maxima take value 1, the others take value 0.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skimage.morphology.extrema.h_minima</code> </dt>
 <dt>
<code>skimage.morphology.extrema.local_maxima</code> </dt>
 <dt>
<code>skimage.morphology.extrema.local_minima</code> </dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="reab74d5f60e7-1">
<code>1</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import extrema
</pre> <p>We create an image (quadratic function with a maximum in the center and 4 additional constant maxima. The heights of the maxima are: 1, 21, 41, 61, 81</p> <pre data-language="python">&gt;&gt;&gt; w = 10
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:4,2:4] = 40; f[2:4,7:9] = 60; f[7:9,2:4] = 80; f[7:9,7:9] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate all maxima with a height of at least 40:</p> <pre data-language="python">&gt;&gt;&gt; maxima = extrema.h_maxima(f, 40)
</pre> <p>The resulting image will contain 3 local maxima.</p> </dd>
</dl>   <h2 id="h-minima">h_minima</h2> <dl class="function"> <dt id="skimage.morphology.h_minima">
<code>skimage.morphology.h_minima(image, h, selem=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/extrema.py#L176-L269"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine all minima of the image with depth &gt;= h.</p> <p>The local minima are defined as connected sets of pixels with equal grey level strictly smaller than the grey levels of all pixels in direct neighborhood of the set.</p> <p>A local minimum M of depth h is a local minimum for which there is at least one path joining M with an equal or lower local minimum on which the maximal value is f(M) + h (i.e. the values along the path are not increasing by more than h with respect to the minimum’s value) and no path to an equal or lower local minimum for which the maximal value is smaller.</p> <p>The global minima of the image are also found by this function.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the minima are to be calculated.</p> </dd> <dt>
<code>hunsigned integer</code> </dt>
<dd>
<p>The minimal depth of all extracted minima.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an n-D array of 1’s and 0’s. Default is the ball of radius 1 according to the maximum norm (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>h_minndarray</code> </dt>
<dd>
<p>The local minima of depth &gt;= h and the global minima. The resulting image is a binary image, where pixels belonging to the determined minima take value 1, the others take value 0.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skimage.morphology.extrema.h_maxima</code> </dt>
 <dt>
<code>skimage.morphology.extrema.local_maxima</code> </dt>
 <dt>
<code>skimage.morphology.extrema.local_minima</code> </dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb2b2b247b9a8-1">
<code>1</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import extrema
</pre> <p>We create an image (quadratic function with a minimum in the center and 4 additional constant maxima. The depth of the minima are: 1, 21, 41, 61, 81</p> <pre data-language="python">&gt;&gt;&gt; w = 10
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 180 + 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:4,2:4] = 160; f[2:4,7:9] = 140; f[7:9,2:4] = 120; f[7:9,7:9] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate all minima with a depth of at least 40:</p> <pre data-language="python">&gt;&gt;&gt; minima = extrema.h_minima(f, 40)
</pre> <p>The resulting image will contain 3 local minima.</p> </dd>
</dl>   <h2 id="label">label</h2> <dl class="function"> <dt id="skimage.morphology.label">
<code>skimage.morphology.label(input, background=None, return_num=False, connectivity=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/measure/_label.py#L32-L120"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Label connected regions of an integer array.</p> <p>Two pixels are connected when they are neighbors and have the same value. In 2D, they can be neighbors either in a 1- or 2-connected sense. The value refers to the maximum number of orthogonal hops to consider a pixel/voxel a neighbor:</p> <pre data-language="python">1-connectivity     2-connectivity     diagonal connection close-up

     [ ]           [ ]  [ ]  [ ]             [ ]
      |               \  |  /                 |  &lt;- hop 2
[ ]--[x]--[ ]      [ ]--[x]--[ ]        [x]--[ ]
      |               /  |  \             hop 1
     [ ]           [ ]  [ ]  [ ]
</pre> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>inputndarray of dtype int</code> </dt>
<dd>
<p>Image to label.</p> </dd> <dt>
<code>backgroundint, optional</code> </dt>
<dd>
<p>Consider all pixels with this value as background pixels, and label them as 0. By default, 0-valued pixels are considered as background pixels.</p> </dd> <dt>
<code>return_numbool, optional</code> </dt>
<dd>
<p>Whether to return the number of assigned labels.</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>Maximum number of orthogonal hops to consider a pixel/voxel as a neighbor. Accepted values are ranging from 1 to input.ndim. If <code>None</code>, a full connectivity of <code>input.ndim</code> is used.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>labelsndarray of dtype int</code> </dt>
<dd>
<p>Labeled array, where all connected regions are assigned the same integer value.</p> </dd> <dt>
<code>numint, optional</code> </dt>
<dd>
<p>Number of labels, which equals the maximum label index and is only returned if return_num is <code>True</code>.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>regionprops</code> </dt>
 <dt>
<code>regionprops_table</code> </dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rfdcb8fe18c0f-1">
<code>1</code> </dt> <dd>
<p>Christophe Fiorio and Jens Gustedt, “Two linear time Union-Find strategies for image processing”, Theoretical Computer Science 154 (1996), pp. 165-181.</p> </dd> <dt class="label" id="rfdcb8fe18c0f-2">
<code>2</code> </dt> <dd>
<p>Kensheng Wu, Ekow Otoo and Arie Shoshani, “Optimizing connected component labeling algorithms”, Paper LBNL-56864, 2005, Lawrence Berkeley National Laboratory (University of California), <a class="reference external" href="http://repositories.cdlib.org/lbnl/LBNL-56864">http://repositories.cdlib.org/lbnl/LBNL-56864</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x = np.eye(3).astype(int)
&gt;&gt;&gt; print(x)
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, connectivity=1))
[[1 0 0]
 [0 2 0]
 [0 0 3]]
&gt;&gt;&gt; print(label(x, connectivity=2))
[[1 0 0]
 [0 1 0]
 [0 0 1]]
&gt;&gt;&gt; print(label(x, background=-1))
[[1 2 2]
 [2 1 2]
 [2 2 1]]
&gt;&gt;&gt; x = np.array([[1, 0, 0],
...               [1, 1, 5],
...               [0, 0, 0]])
&gt;&gt;&gt; print(label(x))
[[1 0 0]
 [1 1 2]
 [0 0 0]]
</pre> </dd>
</dl>   <h2 id="local-maxima">local_maxima</h2> <dl class="function"> <dt id="skimage.morphology.local_maxima">
<code>skimage.morphology.local_maxima(image, selem=None, connectivity=None, indices=False, allow_borders=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/extrema.py#L272-L432"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find local maxima of n-dimensional array.</p> <p>The local maxima are defined as connected sets of pixels with equal gray level (plateaus) strictly greater than the gray levels of all pixels in the neighborhood.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel (<code>True</code> denotes a connected pixel). It must be a boolean array and have the same number of dimensions as <code>image</code>. If neither <code>selem</code> nor <code>connectivity</code> are given, all adjacent pixels are considered as part of the neighborhood.</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is less than or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>indicesbool, optional</code> </dt>
<dd>
<p>If True, the output will be a tuple of one-dimensional arrays representing the indices of local maxima in each dimension. If False, the output will be a boolean array with the same shape as <code>image</code>.</p> </dd> <dt>
<code>allow_bordersbool, optional</code> </dt>
<dd>
<p>If true, plateaus that touch the image border are valid maxima.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>maximandarray or tuple[ndarray]</code> </dt>
<dd>
<p>If <code>indices</code> is false, a boolean array with the same shape as <code>image</code> is returned with <code>True</code> indicating the position of local maxima (<code>False</code> otherwise). If <code>indices</code> is true, a tuple of one-dimensional arrays containing the coordinates (indices) of all found maxima.</p> </dd> </dl> </dd> <dt class="field-odd">Warns</dt> <dd class="field-odd">
<dl class="simple"> <dt>UserWarning</dt>
<dd>
<p>If <code>allow_borders</code> is false and any dimension of the given <code>image</code> is shorter than 3 samples, maxima can’t exist and a warning is shown.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.local_minima" title="skimage.morphology.local_minima"><code>skimage.morphology.local_minima</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code>skimage.morphology.h_maxima</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code>skimage.morphology.h_minima</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This function operates on the following ideas:</p> <ol class="arabic simple"> <li>Make a first pass over the image’s last dimension and flag candidates for local maxima by comparing pixels in only one direction. If the pixels aren’t connected in the last dimension all pixels are flagged as candidates instead.</li> </ol> <p>For each candidate:</p> <ol class="arabic simple" start="2"> <li>Perform a flood-fill to find all connected pixels that have the same gray value and are part of the plateau.</li> <li>Consider the connected neighborhood of a plateau: if no bordering sample has a higher gray level, mark the plateau as a definite local maximum.</li> </ol> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import local_maxima
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = 1
&gt;&gt;&gt; image[3, 0] = 1
&gt;&gt;&gt; image[1:3, 4:6] = 2
&gt;&gt;&gt; image[3, 6] = 3
&gt;&gt;&gt; image
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [0, 1, 1, 0, 2, 2, 0],
       [1, 0, 0, 0, 0, 0, 3]])
</pre> <p>Find local maxima by comparing to all neighboring pixels (maximal connectivity):</p> <pre data-language="python">&gt;&gt;&gt; local_maxima(image)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False, False, False, False],
       [False,  True,  True, False, False, False, False],
       [ True, False, False, False, False, False,  True]])
&gt;&gt;&gt; local_maxima(image, indices=True)
(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))
</pre> <p>Find local maxima without comparing to diagonal pixels (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; local_maxima(image, connectivity=1)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False,  True,  True, False],
       [False,  True,  True, False,  True,  True, False],
       [ True, False, False, False, False, False,  True]])
</pre> <p>and exclude maxima that border the image edge:</p> <pre data-language="python">&gt;&gt;&gt; local_maxima(image, connectivity=1, allow_borders=False)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False,  True,  True, False],
       [False,  True,  True, False,  True,  True, False],
       [False, False, False, False, False, False, False]])
</pre> </dd>
</dl>   <h2 id="local-minima">local_minima</h2> <dl class="function"> <dt id="skimage.morphology.local_minima">
<code>skimage.morphology.local_minima(image, selem=None, connectivity=None, indices=False, allow_borders=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/extrema.py#L435-L542"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Find local minima of n-dimensional array.</p> <p>The local minima are defined as connected sets of pixels with equal gray level (plateaus) strictly smaller than the gray levels of all pixels in the neighborhood.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>An n-dimensional array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>A structuring element used to determine the neighborhood of each evaluated pixel (<code>True</code> denotes a connected pixel). It must be a boolean array and have the same number of dimensions as <code>image</code>. If neither <code>selem</code> nor <code>connectivity</code> are given, all adjacent pixels are considered as part of the neighborhood.</p> </dd> <dt>
<code>connectivityint, optional</code> </dt>
<dd>
<p>A number used to determine the neighborhood of each evaluated pixel. Adjacent pixels whose squared distance from the center is less than or equal to <code>connectivity</code> are considered neighbors. Ignored if <code>selem</code> is not None.</p> </dd> <dt>
<code>indicesbool, optional</code> </dt>
<dd>
<p>If True, the output will be a tuple of one-dimensional arrays representing the indices of local minima in each dimension. If False, the output will be a boolean array with the same shape as <code>image</code>.</p> </dd> <dt>
<code>allow_bordersbool, optional</code> </dt>
<dd>
<p>If true, plateaus that touch the image border are valid minima.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>minimandarray or tuple[ndarray]</code> </dt>
<dd>
<p>If <code>indices</code> is false, a boolean array with the same shape as <code>image</code> is returned with <code>True</code> indicating the position of local minima (<code>False</code> otherwise). If <code>indices</code> is true, a tuple of one-dimensional arrays containing the coordinates (indices) of all found minima.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code>skimage.morphology.local_maxima</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.h_maxima" title="skimage.morphology.h_maxima"><code>skimage.morphology.h_maxima</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.h_minima" title="skimage.morphology.h_minima"><code>skimage.morphology.h_minima</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This function operates on the following ideas:</p> <ol class="arabic simple"> <li>Make a first pass over the image’s last dimension and flag candidates for local minima by comparing pixels in only one direction. If the pixels aren’t connected in the last dimension all pixels are flagged as candidates instead.</li> </ol> <p>For each candidate:</p> <ol class="arabic simple" start="2"> <li>Perform a flood-fill to find all connected pixels that have the same gray value and are part of the plateau.</li> <li>Consider the connected neighborhood of a plateau: if no bordering sample has a smaller gray level, mark the plateau as a definite local minimum.</li> </ol> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.morphology import local_minima
&gt;&gt;&gt; image = np.zeros((4, 7), dtype=int)
&gt;&gt;&gt; image[1:3, 1:3] = -1
&gt;&gt;&gt; image[3, 0] = -1
&gt;&gt;&gt; image[1:3, 4:6] = -2
&gt;&gt;&gt; image[3, 6] = -3
&gt;&gt;&gt; image
array([[ 0,  0,  0,  0,  0,  0,  0],
       [ 0, -1, -1,  0, -2, -2,  0],
       [ 0, -1, -1,  0, -2, -2,  0],
       [-1,  0,  0,  0,  0,  0, -3]])
</pre> <p>Find local minima by comparing to all neighboring pixels (maximal connectivity):</p> <pre data-language="python">&gt;&gt;&gt; local_minima(image)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False, False, False, False],
       [False,  True,  True, False, False, False, False],
       [ True, False, False, False, False, False,  True]])
&gt;&gt;&gt; local_minima(image, indices=True)
(array([1, 1, 2, 2, 3, 3]), array([1, 2, 1, 2, 0, 6]))
</pre> <p>Find local minima without comparing to diagonal pixels (connectivity 1):</p> <pre data-language="python">&gt;&gt;&gt; local_minima(image, connectivity=1)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False,  True,  True, False],
       [False,  True,  True, False,  True,  True, False],
       [ True, False, False, False, False, False,  True]])
</pre> <p>and exclude minima that border the image edge:</p> <pre data-language="python">&gt;&gt;&gt; local_minima(image, connectivity=1, allow_borders=False)
array([[False, False, False, False, False, False, False],
       [False,  True,  True, False,  True,  True, False],
       [False,  True,  True, False,  True,  True, False],
       [False, False, False, False, False, False, False]])
</pre> </dd>
</dl>   <h2 id="max-tree">max_tree</h2> <dl class="function"> <dt id="skimage.morphology.max_tree">
<code>skimage.morphology.max_tree(image, connectivity=1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L53-L143"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Build the max tree from an image.</p> <p>Component trees represent the hierarchical structure of the connected components resulting from sequential thresholding operations applied to an image. A connected component at one level is parent of a component at a higher level if the latter is included in the first. A max-tree is an efficient representation of a component tree. A connected component at one level is represented by one reference pixel at this level, which is parent to all other pixels at that level and to the reference pixel at the level above. The max-tree is the basis for many morphological operators, namely connected operators.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the max-tree is to be calculated. This image can be of any type.</p> </dd> <dt>
<code>connectivityunsigned int, optional</code> </dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>parentndarray, int64</code> </dt>
<dd>
<p>Array of same shape as image. The value of each pixel is the index of its parent in the ravelled array.</p> </dd> <dt>
<code>tree_traverser1D array, int64</code> </dt>
<dd>
<p>The ordered pixel indices (referring to the ravelled array). The pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent).</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rd26fa56f6eaa-1">
<code>1</code> </dt> <dd>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570. <a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p> </dd> <dt class="label" id="rd26fa56f6eaa-2">
<code>2</code> </dt> <dd>
<p>Berger, C., Geraud, T., Levillain, R., Widynski, N., Baillard, A., Bertin, E. (2007). Effective Component Tree Computation with Application to Pattern Recognition in Astronomical Imaging. In International Conference on Image Processing (ICIP) (pp. 41-44). <a class="reference external" href="https://doi.org/10.1109/ICIP.2007.4379949">DOI:10.1109/ICIP.2007.4379949</a></p> </dd> <dt class="label" id="rd26fa56f6eaa-3">
<code>3</code> </dt> <dd>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539. <a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p> </dd> <dt class="label" id="rd26fa56f6eaa-4">
<code>4</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. <a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create a small sample image (Figure 1 from [4]) and build the max-tree.</p> <pre data-language="python">&gt;&gt;&gt; image = np.array([[15, 13, 16], [12, 12, 10], [16, 12, 14]])
&gt;&gt;&gt; P, S = max_tree(image, connectivity=2)
</pre> </dd>
</dl>   <h2 id="max-tree-local-maxima">max_tree_local_maxima</h2> <dl class="function"> <dt id="skimage.morphology.max_tree_local_maxima">
<code>skimage.morphology.max_tree_local_maxima(image, connectivity=1, parent=None, tree_traverser=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/max_tree.py#L582-L670"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Determine all local maxima of the image.</p> <p>The local maxima are defined as connected sets of pixels with equal gray level strictly greater than the gray levels of all pixels in direct neighborhood of the set. The function labels the local maxima.</p> <p>Technically, the implementation is based on the max-tree representation of an image. The function is very efficient if the max-tree representation has already been computed. Otherwise, it is preferable to use the function local_maxima.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>The input image for which the maxima are to be calculated.</p> </dd> <dt><strong>connectivity: unsigned int, optional</strong></dt>
<dd>
<p>The neighborhood connectivity. The integer represents the maximum number of orthogonal steps to reach a neighbor. In 2D, it is 1 for a 4-neighborhood and 2 for a 8-neighborhood. Default value is 1.</p> </dd> <dt><strong>parent: ndarray, int64, optional</strong></dt>
<dd>
<p>The value of each pixel is the index of its parent in the ravelled array.</p> </dd> <dt><strong>tree_traverser: 1D array, int64, optional</strong></dt>
<dd>
<p>The ordered pixel indices (referring to the ravelled array). The pixels are ordered such that every pixel is preceded by its parent (except for the root which has no parent).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>local_maxndarray, uint64</code> </dt>
<dd>
<p>Labeled local maxima of the image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.local_maxima" title="skimage.morphology.local_maxima"><code>skimage.morphology.local_maxima</code></a>
</dt>
 <dt>
 <a class="reference internal" href="#skimage.morphology.max_tree" title="skimage.morphology.max_tree"><code>skimage.morphology.max_tree</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r3593ae75839c-1">
<code>1</code> </dt> <dd>
<p>Vincent L., Proc. “Grayscale area openings and closings, their efficient implementation and applications”, EURASIP Workshop on Mathematical Morphology and its Applications to Signal Processing, Barcelona, Spain, pp.22-27, May 1993.</p> </dd> <dt class="label" id="r3593ae75839c-2">
<code>2</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications” (Chapter 6), 2nd edition (2003), ISBN 3540429883. <a class="reference external" href="https://doi.org/10.1007/978-3-662-05088-0">DOI:10.1007/978-3-662-05088-0</a></p> </dd> <dt class="label" id="r3593ae75839c-3">
<code>3</code> </dt> <dd>
<p>Salembier, P., Oliveras, A., &amp; Garrido, L. (1998). Antiextensive Connected Operators for Image and Sequence Processing. IEEE Transactions on Image Processing, 7(4), 555-570. <a class="reference external" href="https://doi.org/10.1109/83.663500">DOI:10.1109/83.663500</a></p> </dd> <dt class="label" id="r3593ae75839c-4">
<code>4</code> </dt> <dd>
<p>Najman, L., &amp; Couprie, M. (2006). Building the component tree in quasi-linear time. IEEE Transactions on Image Processing, 15(11), 3531-3539. <a class="reference external" href="https://doi.org/10.1109/TIP.2006.877518">DOI:10.1109/TIP.2006.877518</a></p> </dd> <dt class="label" id="r3593ae75839c-5">
<code>5</code> </dt> <dd>
<p>Carlinet, E., &amp; Geraud, T. (2014). A Comparative Review of Component Tree Computation Algorithms. IEEE Transactions on Image Processing, 23(9), 3885-3895. <a class="reference external" href="https://doi.org/10.1109/TIP.2014.2336551">DOI:10.1109/TIP.2014.2336551</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>We create an image (quadratic function with a maximum in the center and 4 additional constant maxima.</p> <pre data-language="python">&gt;&gt;&gt; w = 10
&gt;&gt;&gt; x, y = np.mgrid[0:w,0:w]
&gt;&gt;&gt; f = 20 - 0.2*((x - w/2)**2 + (y-w/2)**2)
&gt;&gt;&gt; f[2:4,2:4] = 40; f[2:4,7:9] = 60; f[7:9,2:4] = 80; f[7:9,7:9] = 100
&gt;&gt;&gt; f = f.astype(int)
</pre> <p>We can calculate all local maxima:</p> <pre data-language="python">&gt;&gt;&gt; maxima = max_tree_local_maxima(f)
</pre> <p>The resulting image contains the labeled local maxima.</p> </dd>
</dl>   <h2 id="medial-axis">medial_axis</h2> <dl class="function"> <dt id="skimage.morphology.medial_axis">
<code>skimage.morphology.medial_axis(image, mask=None, return_distance=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_skeletonize.py#L364-L510"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the medial axis transform of a binary image</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagebinary ndarray, shape (M, N)</code> </dt>
<dd>
<p>The image of the shape to be skeletonized.</p> </dd> <dt>
<code>maskbinary ndarray, shape (M, N), optional</code> </dt>
<dd>
<p>If a mask is given, only those elements in <code>image</code> with a true value in <code>mask</code> are used for computing the medial axis.</p> </dd> <dt>
<code>return_distancebool, optional</code> </dt>
<dd>
<p>If true, the distance transform is returned as well as the skeleton.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outndarray of bools</code> </dt>
<dd>
<p>Medial axis transform of the image</p> </dd> <dt>
<code>distndarray of ints, optional</code> </dt>
<dd>
<p>Distance transform of the image (only returned if <code>return_distance</code> is True)</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skeletonize</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This algorithm computes the medial axis transform of an image as the ridges of its distance transform.</p> <dl class="simple"> <dt>The different steps of the algorithm are as follows</dt>
<dd>
<ul class="simple"> <li>A lookup table is used, that assigns 0 or 1 to each configuration of the 3x3 binary square, whether the central pixel should be removed or kept. We want a point to be removed if it has more than one neighbor and if removing it does not change the number of connected components.</li> <li>The distance transform to the background is computed, as well as the cornerness of the pixel.</li> <li>The foreground (value of 1) points are ordered by the distance transform, then the cornerness.</li> <li>A cython function is called to reduce the image to its skeleton. It processes pixels in the order determined at the previous step, and removes or maintains a pixel according to the lookup table. Because of the ordering, it is possible to process all pixels in only one pass.</li> </ul> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; square = np.zeros((7, 7), dtype=np.uint8)
&gt;&gt;&gt; square[1:-1, 2:-2] = 1
&gt;&gt;&gt; square
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; medial_axis(square).astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 1, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="octagon">octagon</h2> <dl class="function"> <dt id="skimage.morphology.octagon">
<code>skimage.morphology.octagon(m, n, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L262-L300"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates an octagon shaped structuring element.</p> <p>For a given size of (m) horizontal and vertical sides and a given (n) height or width of slanted sides octagon is generated. The slanted sides are 45 or 135 degrees to the horizontal axis and hence the widths and heights are equal.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>mint</code> </dt>
<dd>
<p>The size of the horizontal and vertical sides.</p> </dd> <dt>
<code>nint</code> </dt>
<dd>
<p>The height or width of the slanted sides.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="octahedron">octahedron</h2> <dl class="function"> <dt id="skimage.morphology.octahedron">
<code>skimage.morphology.octahedron(radius, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L197-L228"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a octahedron-shaped structuring element.</p> <p>This is the 3D equivalent of a diamond. A pixel is part of the neighborhood (i.e. labeled 1) if the city block/Manhattan distance between it and the center of the neighborhood is no greater than radius.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>radiusint</code> </dt>
<dd>
<p>The radius of the octahedron-shaped structuring element.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="opening">opening</h2> <dl class="function"> <dt id="skimage.morphology.opening">
<code>skimage.morphology.opening(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L255-L302"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return greyscale morphological opening of an image.</p> <p>The morphological opening on an image is defined as an erosion followed by a dilation. Opening can remove small bright spots (i.e. “salt”) and connect small dark cracks. This tends to “open” up (dark) gaps between (bright) features.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>openingarray, same shape and type as image</code> </dt>
<dd>
<p>The result of the morphological opening.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Open up gap between two bright regions (but also shrink regions)
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bad_connection = np.array([[1, 0, 0, 0, 1],
...                            [1, 1, 0, 1, 1],
...                            [1, 1, 1, 1, 1],
...                            [1, 1, 0, 1, 1],
...                            [1, 0, 0, 0, 1]], dtype=np.uint8)
&gt;&gt;&gt; opening(bad_connection, square(3))
array([[0, 0, 0, 0, 0],
       [1, 1, 0, 1, 1],
       [1, 1, 0, 1, 1],
       [1, 1, 0, 1, 1],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="reconstruction">reconstruction</h2> <dl class="function"> <dt id="skimage.morphology.reconstruction">
<code>skimage.morphology.reconstruction(seed, mask, method='dilation', selem=None, offset=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/greyreconstruct.py#L17-L211"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform a morphological reconstruction of an image.</p> <p>Morphological reconstruction by dilation is similar to basic morphological dilation: high-intensity values will replace nearby low-intensity values. The basic dilation operator, however, uses a structuring element to determine how far a value in the input image can spread. In contrast, reconstruction uses two images: a “seed” image, which specifies the values that spread, and a “mask” image, which gives the maximum allowed value at each pixel. The mask image, like the structuring element, limits the spread of high-intensity values. Reconstruction by erosion is simply the inverse: low-intensity values spread from the seed image and are limited by the mask image, which represents the minimum allowed value.</p> <p>Alternatively, you can think of reconstruction as a way to isolate the connected regions of an image. For dilation, reconstruction connects regions marked by local maxima in the seed image: neighboring pixels less-than-or-equal-to those seeds are connected to the seeded region. Local maxima with values larger than the seed image will get truncated to the seed value.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>seedndarray</code> </dt>
<dd>
<p>The seed image (a.k.a. marker image), which specifies the values that are dilated or eroded.</p> </dd> <dt>
<code>maskndarray</code> </dt>
<dd>
<p>The maximum (dilation) / minimum (erosion) allowed value at each pixel.</p> </dd> <dt>
<code>method{‘dilation’|’erosion’}, optional</code> </dt>
<dd>
<p>Perform reconstruction by dilation or erosion. In dilation (or erosion), the seed image is dilated (or eroded) until limited by the mask image. For dilation, each seed value must be less than or equal to the corresponding mask value; for erosion, the reverse is true. Default is ‘dilation’.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an n-D array of 1’s and 0’s. Default is the n-D square of radius equal to 1 (i.e. a 3x3 square for 2D images, a 3x3x3 cube for 3D images, etc.)</p> </dd> <dt>
<code>offsetndarray, optional</code> </dt>
<dd>
<p>The coordinates of the center of the structuring element. Default is located on the geometrical center of the selem, in that case selem dimensions must be odd.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>reconstructedndarray</code> </dt>
<dd>
<p>The result of morphological reconstruction.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The algorithm is taken from <a class="reference internal" href="#r4e1a5d6f491d-1" id="id30">[1]</a>. Applications for greyscale reconstruction are discussed in <a class="reference internal" href="#r4e1a5d6f491d-2" id="id31">[2]</a> and <a class="reference internal" href="#r4e1a5d6f491d-3" id="id32">[3]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r4e1a5d6f491d-1">
<code>1</code> </dt> <dd>
<p>Robinson, “Efficient morphological reconstruction: a downhill filter”, Pattern Recognition Letters 25 (2004) 1759-1767.</p> </dd> <dt class="label" id="r4e1a5d6f491d-2">
<code>2</code> </dt> <dd>
<p>Vincent, L., “Morphological Grayscale Reconstruction in Image Analysis: Applications and Efficient Algorithms”, IEEE Transactions on Image Processing (1993)</p> </dd> <dt class="label" id="r4e1a5d6f491d-3">
<code>3</code> </dt> <dd>
<p>Soille, P., “Morphological Image Analysis: Principles and Applications”, Chapter 6, 2nd edition (2003), ISBN 3540429883.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import reconstruction
</pre> <p>First, we create a sinusoidal mask image with peaks at middle and ends.</p> <pre data-language="python">&gt;&gt;&gt; x = np.linspace(0, 4 * np.pi)
&gt;&gt;&gt; y_mask = np.cos(x)
</pre> <p>Then, we create a seed image initialized to the minimum mask value (for reconstruction by dilation, min-intensity values don’t spread) and add “seeds” to the left and right peak, but at a fraction of peak value (1).</p> <pre data-language="python">&gt;&gt;&gt; y_seed = y_mask.min() * np.ones_like(x)
&gt;&gt;&gt; y_seed[0] = 0.5
&gt;&gt;&gt; y_seed[-1] = 0
&gt;&gt;&gt; y_rec = reconstruction(y_seed, y_mask)
</pre> <p>The reconstructed image (or curve, in this case) is exactly the same as the mask image, except that the peaks are truncated to 0.5 and 0. The middle peak disappears completely: Since there were no seed values in this peak region, its reconstructed value is truncated to the surrounding value (-1).</p> <p>As a more practical example, we try to extract the bright features of an image by subtracting a background image created by reconstruction.</p> <pre data-language="python">&gt;&gt;&gt; y, x = np.mgrid[:20:0.5, :20:0.5]
&gt;&gt;&gt; bumps = np.sin(x) + np.sin(y)
</pre> <p>To create the background image, set the mask image to the original image, and the seed image to the original image with an intensity offset, <code>h</code>.</p> <pre data-language="python">&gt;&gt;&gt; h = 0.3
&gt;&gt;&gt; seed = bumps - h
&gt;&gt;&gt; background = reconstruction(seed, bumps)
</pre> <p>The resulting reconstructed image looks exactly like the original image, but with the peaks of the bumps cut off. Subtracting this reconstructed image from the original image leaves just the peaks of the bumps</p> <pre data-language="python">&gt;&gt;&gt; hdome = bumps - background
</pre> <p>This operation is known as the h-dome of the image and leaves features of height <code>h</code> in the subtracted image.</p> </dd>
</dl>   <h2 id="rectangle">rectangle</h2> <dl class="function"> <dt id="skimage.morphology.rectangle">
<code>skimage.morphology.rectangle(nrows, ncols, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L34-L67"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, rectangular-shaped structuring element.</p> <p>Every pixel in the rectangle generated for a given width and given height belongs to the neighborhood.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>nrowsint</code> </dt>
<dd>
<p>The number of rows of the rectangle.</p> </dd> <dt>
<code>ncolsint</code> </dt>
<dd>
<p>The number of columns of the rectangle.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <ul class="simple"> <li>The use of <code>width</code> and <code>height</code> has been deprecated in version 0.18.0. Use <code>nrows</code> and <code>ncols</code> instead.</li> </ul> </dd>
</dl>   <h2 id="remove-small-holes">remove_small_holes</h2> <dl class="function"> <dt id="skimage.morphology.remove_small_holes">
<code>skimage.morphology.remove_small_holes(ar, area_threshold=64, connectivity=1, in_place=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/misc.py#L142-L227"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove contiguous holes smaller than the specified size.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>arndarray (arbitrary shape, int or bool type)</code> </dt>
<dd>
<p>The array containing the connected components of interest.</p> </dd> <dt>
<code>area_thresholdint, optional (default: 64)</code> </dt>
<dd>
<p>The maximum area, in pixels, of a contiguous hole that will be filled. Replaces <code>min_size</code>.</p> </dd> <dt>
<code>connectivityint, {1, 2, …, ar.ndim}, optional (default: 1)</code> </dt>
<dd>
<p>The connectivity defining the neighborhood of a pixel.</p> </dd> <dt>
<code>in_placebool, optional (default: False)</code> </dt>
<dd>
<p>If <code>True</code>, remove the connected components in the input array itself. Otherwise, make a copy.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outndarray, same shape and type as input ar</code> </dt>
<dd>
<p>The input array with small holes within connected components removed.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>TypeError</dt>
<dd>
<p>If the input array is of an invalid type, such as float or string.</p> </dd> <dt>ValueError</dt>
<dd>
<p>If the input array contains negative values.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>If the array type is int, it is assumed that it contains already-labeled objects. The labels are not kept in the output image (this function always outputs a bool image). It is suggested that labeling is completed after using this function.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import morphology
&gt;&gt;&gt; a = np.array([[1, 1, 1, 1, 1, 0],
...               [1, 1, 1, 0, 1, 0],
...               [1, 0, 0, 1, 1, 0],
...               [1, 1, 1, 1, 1, 0]], bool)
&gt;&gt;&gt; b = morphology.remove_small_holes(a, 2)
&gt;&gt;&gt; b
array([[ True,  True,  True,  True,  True, False],
       [ True,  True,  True,  True,  True, False],
       [ True, False, False,  True,  True, False],
       [ True,  True,  True,  True,  True, False]])
&gt;&gt;&gt; c = morphology.remove_small_holes(a, 2, connectivity=2)
&gt;&gt;&gt; c
array([[ True,  True,  True,  True,  True, False],
       [ True,  True,  True, False,  True, False],
       [ True, False, False,  True,  True, False],
       [ True,  True,  True,  True,  True, False]])
&gt;&gt;&gt; d = morphology.remove_small_holes(a, 2, in_place=True)
&gt;&gt;&gt; d is a
True
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-remove-small-holes">Examples using <code>skimage.morphology.remove_small_holes</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id64"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="remove-small-objects">remove_small_objects</h2> <dl class="function"> <dt id="skimage.morphology.remove_small_objects">
<code>skimage.morphology.remove_small_objects(ar, min_size=64, connectivity=1, in_place=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/misc.py#L51-L139"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Remove objects smaller than the specified size.</p> <p>Expects ar to be an array with labeled objects, and removes objects smaller than min_size. If <code>ar</code> is bool, the image is first labeled. This leads to potentially different behavior for bool and 0-and-1 arrays.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>arndarray (arbitrary shape, int or bool type)</code> </dt>
<dd>
<p>The array containing the objects of interest. If the array type is int, the ints must be non-negative.</p> </dd> <dt>
<code>min_sizeint, optional (default: 64)</code> </dt>
<dd>
<p>The smallest allowable object size.</p> </dd> <dt>
<code>connectivityint, {1, 2, …, ar.ndim}, optional (default: 1)</code> </dt>
<dd>
<p>The connectivity defining the neighborhood of a pixel. Used during labelling if <code>ar</code> is bool.</p> </dd> <dt>
<code>in_placebool, optional (default: False)</code> </dt>
<dd>
<p>If <code>True</code>, remove the objects in the input array itself. Otherwise, make a copy.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outndarray, same shape and type as input ar</code> </dt>
<dd>
<p>The input array with small connected components removed.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>TypeError</dt>
<dd>
<p>If the input array is of an invalid type, such as float or string.</p> </dd> <dt>ValueError</dt>
<dd>
<p>If the input array contains negative values.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage import morphology
&gt;&gt;&gt; a = np.array([[0, 0, 0, 1, 0],
...               [1, 1, 1, 0, 0],
...               [1, 1, 1, 0, 1]], bool)
&gt;&gt;&gt; b = morphology.remove_small_objects(a, 6)
&gt;&gt;&gt; b
array([[False, False, False, False, False],
       [ True,  True,  True, False, False],
       [ True,  True,  True, False, False]])
&gt;&gt;&gt; c = morphology.remove_small_objects(a, 7, connectivity=2)
&gt;&gt;&gt; c
array([[False, False, False,  True, False],
       [ True,  True,  True, False, False],
       [ True,  True,  True, False, False]])
&gt;&gt;&gt; d = morphology.remove_small_objects(a, 6, in_place=True)
&gt;&gt;&gt; d is a
True
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-morphology-remove-small-objects">Examples using <code>skimage.morphology.remove_small_objects</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id65"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="skeletonize">skeletonize</h2> <dl class="function"> <dt id="skimage.morphology.skeletonize">
<code>skimage.morphology.skeletonize(image, *, method=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_skeletonize.py#L16-L90"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the skeleton of a binary image.</p> <p>Thinning is used to reduce each connected component in a binary image to a single-pixel wide skeleton.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray, 2D or 3D</code> </dt>
<dd>
<p>A binary image containing the objects to be skeletonized. Zeros represent background, nonzero values are foreground.</p> </dd> <dt>
<code>method{‘zhang’, ‘lee’}, optional</code> </dt>
<dd>
<p>Which algorithm to use. Zhang’s algorithm <a class="reference internal" href="#rc75910d539e3-zha84" id="id36">[Zha84]</a> only works for 2D images, and is the default for 2D. Lee’s algorithm <a class="reference internal" href="#rc75910d539e3-lee94" id="id37">[Lee94]</a> works for 2D or 3D images and is the default for 3D.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>skeletonndarray</code> </dt>
<dd>
<p>The thinned image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc75910d539e3-lee94">
<code>Lee94</code> </dt> <dd>
<p>T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models via 3-D medial surface/axis thinning algorithms. Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</p> </dd> <dt class="label" id="rc75910d539e3-zha84">
<code>Zha84</code> </dt> <dd>
<p>A fast parallel algorithm for thinning digital patterns, T. Y. Zhang and C. Y. Suen, Communications of the ACM, March 1984, Volume 27, Number 3.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; X, Y = np.ogrid[0:9, 0:9]
&gt;&gt;&gt; ellipse = (1./3 * (X - 4)**2 + (Y - 4)**2 &lt; 3**2).astype(np.uint8)
&gt;&gt;&gt; ellipse
array([[0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; skel = skeletonize(ellipse)
&gt;&gt;&gt; skel.astype(np.uint8)
array([[0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="skeletonize-3d">skeletonize_3d</h2> <dl class="function"> <dt id="skimage.morphology.skeletonize_3d">
<code>skimage.morphology.skeletonize_3d(image)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_skeletonize.py#L579-L647"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the skeleton of a binary image.</p> <p>Thinning is used to reduce each connected component in a binary image to a single-pixel wide skeleton.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray, 2D or 3D</code> </dt>
<dd>
<p>A binary image containing the objects to be skeletonized. Zeros represent background, nonzero values are foreground.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>skeletonndarray</code> </dt>
<dd>
<p>The thinned image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skeletonize,</code> <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>The method of <a class="reference internal" href="#rc9cdb497d267-lee94" id="id40">[Lee94]</a> uses an octree data structure to examine a 3x3x3 neighborhood of a pixel. The algorithm proceeds by iteratively sweeping over the image, and removing pixels at each iteration until the image stops changing. Each iteration consists of two steps: first, a list of candidates for removal is assembled; then pixels from this list are rechecked sequentially, to better preserve connectivity of the image.</p> <p>The algorithm this function implements is different from the algorithms used by either <a class="reference internal" href="#skimage.morphology.skeletonize" title="skimage.morphology.skeletonize"><code>skeletonize</code></a> or <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a>, thus for 2D images the results produced by this function are generally different.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc9cdb497d267-lee94">
<code>Lee94</code> </dt> <dd>
<p>T.-C. Lee, R.L. Kashyap and C.-N. Chu, Building skeleton models via 3-D medial surface/axis thinning algorithms. Computer Vision, Graphics, and Image Processing, 56(6):462-478, 1994.</p> </dd> </dl> </dd>
</dl>   <h2 id="square">square</h2> <dl class="function"> <dt id="skimage.morphology.square">
<code>skimage.morphology.square(width, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L8-L31"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a flat, square-shaped structuring element.</p> <p>Every pixel along the perimeter has a chessboard distance no greater than radius (radius=floor(width/2)) pixels.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>widthint</code> </dt>
<dd>
<p>The width and height of the square.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>A structuring element consisting only of ones, i.e. every pixel belongs to the neighborhood.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="star">star</h2> <dl class="function"> <dt id="skimage.morphology.star">
<code>skimage.morphology.star(a, dtype=&lt;class 'numpy.uint8'&gt;)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/selem.py#L303-L349"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates a star shaped structuring element.</p> <p>Start has 8 vertices and is an overlap of square of size <code>2*a + 1</code> with its 45 degree rotated version. The slanted sides are 45 or 135 degrees to the horizontal axis.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>aint</code> </dt>
<dd>
<p>Parameter deciding the size of the star structural element. The side of the square array returned is <code>2*a + 1 + 2*floor(a / 2)</code>.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>selemndarray</code> </dt>
<dd>
<p>The structuring element where elements of the neighborhood are 1 and 0 otherwise.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>dtypedata-type</code> </dt>
<dd>
<p>The data type of the structuring element.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="thin">thin</h2> <dl class="function"> <dt id="skimage.morphology.thin">
<code>skimage.morphology.thin(image, max_iter=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_skeletonize.py#L259-L356"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Perform morphological thinning of a binary image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagebinary (M, N) ndarray</code> </dt>
<dd>
<p>The image to be thinned.</p> </dd> <dt>
<code>max_iterint, number of iterations, optional</code> </dt>
<dd>
<p>Regardless of the value of this parameter, the thinned image is returned immediately if an iteration produces no change. If this parameter is specified it thus sets an upper bound on the number of iterations performed.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>outndarray of bool</code> </dt>
<dd>
<p>Thinned image.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<code>skeletonize,</code> <a class="reference internal" href="#skimage.morphology.medial_axis" title="skimage.morphology.medial_axis"><code>medial_axis</code></a>
</dt>
 </dl> </div> <h4 class="rubric">Notes</h4> <p>This algorithm <a class="reference internal" href="#r2b353e29d473-1" id="id42">[1]</a> works by making multiple passes over the image, removing pixels matching a set of criteria designed to thin connected regions while preserving eight-connected components and 2 x 2 squares <a class="reference internal" href="#r2b353e29d473-2" id="id43">[2]</a>. In each of the two sub-iterations the algorithm correlates the intermediate skeleton image with a neighborhood mask, then looks up each neighborhood in a lookup table indicating whether the central pixel should be deleted in that sub-iteration.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r2b353e29d473-1">
<code>1</code> </dt> <dd>
<p>Z. Guo and R. W. Hall, “Parallel thinning with two-subiteration algorithms,” Comm. ACM, vol. 32, no. 3, pp. 359-373, 1989. <a class="reference external" href="https://doi.org/10.1145/62065.62074">DOI:10.1145/62065.62074</a></p> </dd> <dt class="label" id="r2b353e29d473-2">
<code>2</code> </dt> <dd>
<p>Lam, L., Seong-Whan Lee, and Ching Y. Suen, “Thinning Methodologies-A Comprehensive Survey,” IEEE Transactions on Pattern Analysis and Machine Intelligence, Vol 14, No. 9, p. 879, 1992. <a class="reference external" href="https://doi.org/10.1109/34.161346">DOI:10.1109/34.161346</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; square = np.zeros((7, 7), dtype=np.uint8)
&gt;&gt;&gt; square[1:-1, 2:-2] = 1
&gt;&gt;&gt; square[0, 1] =  1
&gt;&gt;&gt; square
array([[0, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
&gt;&gt;&gt; skel = thin(square)
&gt;&gt;&gt; skel.astype(np.uint8)
array([[0, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="watershed">watershed</h2> <dl class="function"> <dt id="skimage.morphology.watershed">
<code>skimage.morphology.watershed(image, markers=None, connectivity=1, offset=None, mask=None, compactness=0, watershed_line=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/_deprecated.py#L4-L111"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p><strong>Deprecated function</strong>. Use <code>skimage.segmentation.watershed</code> instead.</p> <p>Find watershed basins in <code>image</code> flooded from given <code>markers</code>.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>imagendarray (2-D, 3-D, …) of integers</code> </dt>
<dd>
<p>Data array where the lowest value points are labeled first.</p> </dd> <dt>
<code>markersint, or ndarray of int, same shape as image, optional</code> </dt>
<dd>
<p>The desired number of markers, or an array marking the basins with the values to be assigned in the label matrix. Zero means not a marker. If <code>None</code> (no markers given), the local minima of the image are used as markers.</p> </dd> <dt>
<code>connectivityndarray, optional</code> </dt>
<dd>
<p>An array with the same number of dimensions as <code>image</code> whose non-zero elements indicate neighbors for connection. Following the scipy convention, default is a one-connected array of the dimension of the image.</p> </dd> <dt>
<code>offsetarray_like of shape image.ndim, optional</code> </dt>
<dd>
<p>offset of the connectivity (one offset per dimension)</p> </dd> <dt>
<code>maskndarray of bools or 0s and 1s, optional</code> </dt>
<dd>
<p>Array of same shape as <code>image</code>. Only points at which mask == True will be labeled.</p> </dd> <dt>
<code>compactnessfloat, optional</code> </dt>
<dd>
<p>Use compact watershed <a class="reference internal" href="#r91cba7b06893-3" id="id46">[3]</a> with given compactness parameter. Higher values result in more regularly-shaped watershed basins.</p> </dd> <dt>
<code>watershed_linebool, optional</code> </dt>
<dd>
<p>If watershed_line is True, a one-pixel wide line separates the regions obtained by the watershed algorithm. The line has the label 0.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>out: ndarray</dt>
<dd>
<p>A labeled matrix of the same type and shape as markers</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="skimage.segmentation.html#skimage.segmentation.random_walker" title="skimage.segmentation.random_walker"><code>skimage.segmentation.random_walker</code></a>
</dt>
<dd>
<p>random walker segmentation A segmentation algorithm based on anisotropic diffusion, usually slower than the watershed but with good results on noisy data and boundaries with holes.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This function implements a watershed algorithm <a class="reference internal" href="#r91cba7b06893-1" id="id47">[1]</a> <a class="reference internal" href="#r91cba7b06893-2" id="id48">[2]</a> that apportions pixels into marked basins. The algorithm uses a priority queue to hold the pixels with the metric for the priority queue being pixel value, then the time of entry into the queue - this settles ties in favor of the closest marker. Some ideas taken from Soille, “Automated Basin Delineation from Digital Elevation Models Using Mathematical Morphology”, Signal Processing 20 (1990) 171-182 The most important insight in the paper is that entry time onto the queue solves two problems: a pixel should be assigned to the neighbor with the largest gradient or, if there is no gradient, pixels on a plateau should be split between markers on opposite sides. This implementation converts all arguments to specific, lowest common denominator types, then passes these to a C algorithm. Markers can be determined manually, or automatically using for example the local minima of the gradient of the image, or the local maxima of the distance function to the background for separating overlapping objects (see example).</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r91cba7b06893-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Watershed_%28image_processing%29">https://en.wikipedia.org/wiki/Watershed_%28image_processing%29</a></p> </dd> <dt class="label" id="r91cba7b06893-2">
<code>2</code> </dt> <dd>
<p><a class="reference external" href="http://cmm.ensmp.fr/~beucher/wtshed.html">http://cmm.ensmp.fr/~beucher/wtshed.html</a></p> </dd> <dt class="label" id="r91cba7b06893-3">
<code>3</code> </dt> <dd>
<p>Peer Neubert &amp; Peter Protzel (2014). Compact Watershed and Preemptive SLIC: On Improving Trade-offs of Superpixel Segmentation Algorithms. ICPR 2014, pp 996-1001. <a class="reference external" href="https://doi.org/10.1109/ICPR.2014.181">DOI:10.1109/ICPR.2014.181</a> <a class="reference external" href="https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf">https://www.tu-chemnitz.de/etit/proaut/publications/cws_pSLIC_ICPR.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <p>The watershed algorithm is useful to separate overlapping objects.</p> <p>We first generate an initial image with two overlapping circles:</p> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; x, y = np.indices((80, 80))
&gt;&gt;&gt; x1, y1, x2, y2 = 28, 28, 44, 52
&gt;&gt;&gt; r1, r2 = 16, 20
&gt;&gt;&gt; mask_circle1 = (x - x1)**2 + (y - y1)**2 &lt; r1**2
&gt;&gt;&gt; mask_circle2 = (x - x2)**2 + (y - y2)**2 &lt; r2**2
&gt;&gt;&gt; image = np.logical_or(mask_circle1, mask_circle2)
</pre> <p>Next, we want to separate the two circles. We generate markers at the maxima of the distance to the background:</p> <pre data-language="python">&gt;&gt;&gt; from scipy import ndimage as ndi
&gt;&gt;&gt; distance = ndi.distance_transform_edt(image)
&gt;&gt;&gt; from skimage.feature import peak_local_max
&gt;&gt;&gt; local_maxi = peak_local_max(distance, labels=image,
...                             footprint=np.ones((3, 3)),
...                             indices=False)
&gt;&gt;&gt; markers = ndi.label(local_maxi)[0]
</pre> <p>Finally, we run the watershed on the image and markers:</p> <pre data-language="python">&gt;&gt;&gt; labels = watershed(-distance, markers, mask=image)  
</pre> <p>The algorithm works also for 3-D images, and can be used for example to separate overlapping spheres.</p> </dd>
</dl>   <h2 id="white-tophat">white_tophat</h2> <dl class="function"> <dt id="skimage.morphology.white_tophat">
<code>skimage.morphology.white_tophat(image, selem=None, out=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/morphology/grey.py#L355-L426"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return white top hat of an image.</p> <p>The white top hat of an image is defined as the image minus its morphological opening. This operation returns the bright spots of the image that are smaller than the structuring element.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>imagendarray</code> </dt>
<dd>
<p>Image array.</p> </dd> <dt>
<code>selemndarray, optional</code> </dt>
<dd>
<p>The neighborhood expressed as an array of 1’s and 0’s. If None, use cross-shaped structuring element (connectivity=1).</p> </dd> <dt>
<code>outndarray, optional</code> </dt>
<dd>
<p>The array to store the result of the morphology. If None is passed, a new array will be allocated.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl> <dt>
<code>outarray, same shape and type as image</code> </dt>
<dd>
<p>The result of the morphological white top hat.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
 <a class="reference internal" href="#skimage.morphology.black_tophat" title="skimage.morphology.black_tophat"><code>black_tophat</code></a>
</dt>
 </dl> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r9700090f0649-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Top-hat_transform">https://en.wikipedia.org/wiki/Top-hat_transform</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; # Subtract grey background from bright peak
&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.morphology import square
&gt;&gt;&gt; bright_on_grey = np.array([[2, 3, 3, 3, 2],
...                            [3, 4, 5, 4, 3],
...                            [3, 5, 9, 5, 3],
...                            [3, 4, 5, 4, 3],
...                            [2, 3, 3, 3, 2]], dtype=np.uint8)
&gt;&gt;&gt; white_tophat(bright_on_grey, square(3))
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 1, 5, 1, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.morphology.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.morphology.html</a>
  </p>
</div>
