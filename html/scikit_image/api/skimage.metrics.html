<h1 id="module-metrics">Module: metrics</h1> <table class="longtable docutils align-default" id="module-skimage.metrics">   <tr>
<td><p><a class="reference internal" href="#skimage.metrics.adapted_rand_error" title="skimage.metrics.adapted_rand_error"><code>skimage.metrics.adapted_rand_error</code></a>([…])</p></td> <td><p>Compute Adapted Rand error as defined by the SNEMI3D contest.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.contingency_table" title="skimage.metrics.contingency_table"><code>skimage.metrics.contingency_table</code></a>(im_true, …)</p></td> <td><p>Return the contingency table for all regions in matched segmentations.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.hausdorff_distance" title="skimage.metrics.hausdorff_distance"><code>skimage.metrics.hausdorff_distance</code></a>(image0, …)</p></td> <td><p>Calculate the Hausdorff distance between nonzero elements of given images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.mean_squared_error" title="skimage.metrics.mean_squared_error"><code>skimage.metrics.mean_squared_error</code></a>(image0, …)</p></td> <td><p>Compute the mean-squared error between two images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.normalized_root_mse" title="skimage.metrics.normalized_root_mse"><code>skimage.metrics.normalized_root_mse</code></a>(…[, …])</p></td> <td><p>Compute the normalized root mean-squared error (NRMSE) between two images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.peak_signal_noise_ratio" title="skimage.metrics.peak_signal_noise_ratio"><code>skimage.metrics.peak_signal_noise_ratio</code></a>(…)</p></td> <td><p>Compute the peak signal to noise ratio (PSNR) for an image.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.structural_similarity" title="skimage.metrics.structural_similarity"><code>skimage.metrics.structural_similarity</code></a>(im1, …)</p></td> <td><p>Compute the mean structural similarity index between two images.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.metrics.variation_of_information" title="skimage.metrics.variation_of_information"><code>skimage.metrics.variation_of_information</code></a>([…])</p></td> <td><p>Return symmetric conditional entropies associated with the VI.</p></td> </tr>  </table>  <h2 id="adapted-rand-error">adapted_rand_error</h2> <dl class="function"> <dt id="skimage.metrics.adapted_rand_error">
<code>skimage.metrics.adapted_rand_error(image_true=None, image_test=None, *, table=None, ignore_labels=(0, ))</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/_adapted_rand_error.py#L7-L76"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute Adapted Rand error as defined by the SNEMI3D contest. <a class="reference internal" href="#rc4bf0a102856-1" id="id1">[1]</a></p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_truendarray of int</code> </dt>
<dd>
<p>Ground-truth label image, same shape as im_test.</p> </dd> <dt>
<code>image_testndarray of int</code> </dt>
<dd>
<p>Test image.</p> </dd> <dt>
<code>tablescipy.sparse array in crs format, optional</code> </dt>
<dd>
<p>A contingency table built with skimage.evaluate.contingency_table. If None, it will be computed on the fly.</p> </dd> <dt>
<code>ignore_labelssequence of int, optional</code> </dt>
<dd>
<p>Labels to ignore. Any part of the true image labeled with any of these values will not be counted in the score.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>arefloat</code> </dt>
<dd>
<p>The adapted Rand error; equal to <span class="math notranslate nohighlight">\(1 - \frac{2pr}{p + r}\)</span>, where <code>p</code> and <code>r</code> are the precision and recall described below.</p> </dd> <dt>
<code>precfloat</code> </dt>
<dd>
<p>The adapted Rand precision: this is the number of pairs of pixels that have the same label in the test label image <em>and</em> in the true image, divided by the number in the test image.</p> </dd> <dt>
<code>recfloat</code> </dt>
<dd>
<p>The adapted Rand recall: this is the number of pairs of pixels that have the same label in the test label image <em>and</em> in the true image, divided by the number in the true image.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Pixels with label 0 in the true segmentation are ignored in the score.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rc4bf0a102856-1">
<code>1</code> </dt> <dd>
<p>Arganda-Carreras I, Turaga SC, Berger DR, et al. (2015) Crowdsourcing the creation of image segmentation algorithms for connectomics. Front. Neuroanat. 9:142. <a class="reference external" href="https://doi.org/10.3389/fnana.2015.00142">DOI:10.3389/fnana.2015.00142</a></p> </dd> </dl> </dd>
</dl>   <h2 id="contingency-table">contingency_table</h2> <dl class="function"> <dt id="skimage.metrics.contingency_table">
<code>skimage.metrics.contingency_table(im_true, im_test, *, ignore_labels=None, normalize=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/_contingency_table.py#L7-L39"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the contingency table for all regions in matched segmentations.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>im_truendarray of int</code> </dt>
<dd>
<p>Ground-truth label image, same shape as im_test.</p> </dd> <dt>
<code>im_testndarray of int</code> </dt>
<dd>
<p>Test image.</p> </dd> <dt>
<code>ignore_labelssequence of int, optional</code> </dt>
<dd>
<p>Labels to ignore. Any part of the true image labeled with any of these values will not be counted in the score.</p> </dd> <dt>
<code>normalizebool</code> </dt>
<dd>
<p>Determines if the contingency table is normalized by pixel count.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>contscipy.sparse.csr_matrix</code> </dt>
<dd>
<p>A contingency table. <code>cont[i, j]</code> will equal the number of voxels labeled <code>i</code> in <code>im_true</code> and <code>j</code> in <code>im_test</code>.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="hausdorff-distance">hausdorff_distance</h2> <dl class="function"> <dt id="skimage.metrics.hausdorff_distance">
<code>skimage.metrics.hausdorff_distance(image0, image1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/set_metrics.py#L4-L51"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculate the Hausdorff distance between nonzero elements of given images.</p> <p>The Hausdorff distance <a class="reference internal" href="#rda3116704e68-1" id="id3">[1]</a> is the maximum distance between any point on <code>image0</code> and its nearest point on <code>image1</code>, and vice-versa.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image0, image1ndarray</code> </dt>
<dd>
<p>Arrays where <code>True</code> represents a point that is included in a set of points. Both arrays must have the same shape.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>distancefloat</code> </dt>
<dd>
<p>The Hausdorff distance between coordinates of nonzero pixels in <code>image0</code> and <code>image1</code>, using the Euclidian distance.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rda3116704e68-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="http://en.wikipedia.org/wiki/Hausdorff_distance">http://en.wikipedia.org/wiki/Hausdorff_distance</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; points_a = (3, 0)
&gt;&gt;&gt; points_b = (6, 0)
&gt;&gt;&gt; shape = (7, 1)
&gt;&gt;&gt; image_a = np.zeros(shape, dtype=bool)
&gt;&gt;&gt; image_b = np.zeros(shape, dtype=bool)
&gt;&gt;&gt; image_a[points_a] = True
&gt;&gt;&gt; image_b[points_b] = True
&gt;&gt;&gt; hausdorff_distance(image_a, image_b)
3.0
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-metrics-hausdorff-distance">Examples using <code>skimage.metrics.hausdorff_distance</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="This example shows how to calculate the Hausdorff distance between two sets of points. The `Hau...">
<div class="figure align-default" id="id16"> <img alt="Hausdorff Distance" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_hausdorff_distance.html#sphx-glr-auto-examples-segmentation-plot-hausdorff-distance-py"><span class="std std-ref">Hausdorff Distance</span></a></span></p> </div> </div>   <h2 id="mean-squared-error">mean_squared_error</h2> <dl class="function"> <dt id="skimage.metrics.mean_squared_error">
<code>skimage.metrics.mean_squared_error(image0, image1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/simple_metrics.py#L21-L44"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the mean-squared error between two images.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image0, image1ndarray</code> </dt>
<dd>
<p>Images. Any dimensionality, must have same shape.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>msefloat</code> </dt>
<dd>
<p>The mean-squared error (MSE) metric.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code>skimage.measure.compare_mse</code> to <code>skimage.metrics.mean_squared_error</code>.</p> </div> </dd>
</dl>   <h2 id="normalized-root-mse">normalized_root_mse</h2> <dl class="function"> <dt id="skimage.metrics.normalized_root_mse">
<code>skimage.metrics.normalized_root_mse(image_true, image_test, *, normalization='euclidean')</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/simple_metrics.py#L47-L105"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the normalized root mean-squared error (NRMSE) between two images.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<code>image_truendarray</code> </dt>
<dd>
<p>Ground-truth image, same shape as im_test.</p> </dd> <dt>
<code>image_testndarray</code> </dt>
<dd>
<p>Test image.</p> </dd> <dt>
<code>normalization{‘euclidean’, ‘min-max’, ‘mean’}, optional</code> </dt>
<dd>
<p>Controls the normalization method to use in the denominator of the NRMSE. There is no standard method of normalization across the literature <a class="reference internal" href="#re6457782c209-1" id="id5">[1]</a>. The methods available here are as follows:</p> <ul> <li>
<p>‘euclidean’ : normalize by the averaged Euclidean norm of <code>im_true</code>:</p> <pre data-language="python">NRMSE = RMSE * sqrt(N) / || im_true ||
</pre> <p>where || . || denotes the Frobenius norm and <code>N = im_true.size</code>. This result is equivalent to:</p> <pre data-language="python">NRMSE = || im_true - im_test || / || im_true ||.
</pre> </li> <li>‘min-max’ : normalize by the intensity range of <code>im_true</code>.</li> <li>‘mean’ : normalize by the mean of <code>im_true</code>
</li> </ul> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>nrmsefloat</code> </dt>
<dd>
<p>The NRMSE metric.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code>skimage.measure.compare_nrmse</code> to <code>skimage.metrics.normalized_root_mse</code>.</p> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re6457782c209-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Root-mean-square_deviation">https://en.wikipedia.org/wiki/Root-mean-square_deviation</a></p> </dd> </dl> </dd>
</dl>   <h2 id="peak-signal-noise-ratio">peak_signal_noise_ratio</h2> <dl class="function"> <dt id="skimage.metrics.peak_signal_noise_ratio">
<code>skimage.metrics.peak_signal_noise_ratio(image_true, image_test, *, data_range=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/simple_metrics.py#L108-L160"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the peak signal to noise ratio (PSNR) for an image.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_truendarray</code> </dt>
<dd>
<p>Ground-truth image, same shape as im_test.</p> </dd> <dt>
<code>image_testndarray</code> </dt>
<dd>
<p>Test image.</p> </dd> <dt>
<code>data_rangeint, optional</code> </dt>
<dd>
<p>The data range of the input image (distance between minimum and maximum possible values). By default, this is estimated from the image data-type.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>psnrfloat</code> </dt>
<dd>
<p>The PSNR metric.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code>skimage.measure.compare_psnr</code> to <code>skimage.metrics.peak_signal_noise_ratio</code>.</p> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r9f72f2e8afda-1">
<code>1</code> </dt> <dd>
<p><a class="reference external" href="https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio">https://en.wikipedia.org/wiki/Peak_signal-to-noise_ratio</a></p> </dd> </dl> </dd>
</dl>   <h2 id="structural-similarity">structural_similarity</h2> <dl class="function"> <dt id="skimage.metrics.structural_similarity">
<code>skimage.metrics.structural_similarity(im1, im2, *, win_size=None, gradient=False, data_range=None, multichannel=False, gaussian_weights=False, full=False, **kwargs)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/_structural_similarity.py#L12-L232"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the mean structural similarity index between two images.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>im1, im2ndarray</code> </dt>
<dd>
<p>Images. Any dimensionality with same shape.</p> </dd> <dt>
<code>win_sizeint or None, optional</code> </dt>
<dd>
<p>The side-length of the sliding window used in comparison. Must be an odd value. If <code>gaussian_weights</code> is True, this is ignored and the window size will depend on <code>sigma</code>.</p> </dd> <dt>
<code>gradientbool, optional</code> </dt>
<dd>
<p>If True, also return the gradient with respect to im2.</p> </dd> <dt>
<code>data_rangefloat, optional</code> </dt>
<dd>
<p>The data range of the input image (distance between minimum and maximum possible values). By default, this is estimated from the image data-type.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>If True, treat the last dimension of the array as channels. Similarity calculations are done independently for each channel then averaged.</p> </dd> <dt>
<code>gaussian_weightsbool, optional</code> </dt>
<dd>
<p>If True, each patch has its mean and variance spatially weighted by a normalized Gaussian kernel of width sigma=1.5.</p> </dd> <dt>
<code>fullbool, optional</code> </dt>
<dd>
<p>If True, also return the full structural similarity image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>mssimfloat</code> </dt>
<dd>
<p>The mean structural similarity index over the image.</p> </dd> <dt>
<code>gradndarray</code> </dt>
<dd>
<p>The gradient of the structural similarity between im1 and im2 <a class="reference internal" href="#re0d1cfbcf329-2" id="id8">[2]</a>. This is only returned if <code>gradient</code> is set to True.</p> </dd> <dt>
<code>Sndarray</code> </dt>
<dd>
<p>The full SSIM image. This is only returned if <code>full</code> is set to True.</p> </dd> </dl> </dd> <dt class="field-odd">Other Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>use_sample_covariancebool</code> </dt>
<dd>
<p>If True, normalize covariances by N-1 rather than, N where N is the number of pixels within the sliding window.</p> </dd> <dt>
<code>K1float</code> </dt>
<dd>
<p>Algorithm parameter, K1 (small constant, see <a class="reference internal" href="#re0d1cfbcf329-1" id="id9">[1]</a>).</p> </dd> <dt>
<code>K2float</code> </dt>
<dd>
<p>Algorithm parameter, K2 (small constant, see <a class="reference internal" href="#re0d1cfbcf329-1" id="id10">[1]</a>).</p> </dd> <dt>
<code>sigmafloat</code> </dt>
<dd>
<p>Standard deviation for the Gaussian when <code>gaussian_weights</code> is True.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>To match the implementation of Wang et. al. <a class="reference internal" href="#re0d1cfbcf329-1" id="id11">[1]</a>, set <code>gaussian_weights</code> to True, <code>sigma</code> to 1.5, and <code>use_sample_covariance</code> to False.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 0.16: </span>This function was renamed from <code>skimage.measure.compare_ssim</code> to <code>skimage.metrics.structural_similarity</code>.</p> </div> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="re0d1cfbcf329-1">
<code>1(1,2,3)</code> </dt> <dd>
<p>Wang, Z., Bovik, A. C., Sheikh, H. R., &amp; Simoncelli, E. P. (2004). Image quality assessment: From error visibility to structural similarity. IEEE Transactions on Image Processing, 13, 600-612. <a class="reference external" href="https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf">https://ece.uwaterloo.ca/~z70wang/publications/ssim.pdf</a>, <a class="reference external" href="https://doi.org/10.1109/TIP.2003.819861">DOI:10.1109/TIP.2003.819861</a></p> </dd> <dt class="label" id="re0d1cfbcf329-2">
<code>2</code> </dt> <dd>
<p>Avanaki, A. N. (2009). Exact global histogram specification optimized for structural similarity. Optical Review, 16, 613-621. <a class="reference external" href="https://arxiv.org/abs/0901.0065">arXiv:0901.0065</a> <a class="reference external" href="https://doi.org/10.1007/s10043-009-0119-z">DOI:10.1007/s10043-009-0119-z</a></p> </dd> </dl> </dd>
</dl>   <h2 id="variation-of-information">variation_of_information</h2> <dl class="function"> <dt id="skimage.metrics.variation_of_information">
<code>skimage.metrics.variation_of_information(image0=None, image1=None, *, table=None, ignore_labels=())</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/metrics/_variation_of_information.py#L9-L46"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return symmetric conditional entropies associated with the VI. <a class="reference internal" href="#rb3845a1c7d1d-1" id="id14">[1]</a></p> <p>The variation of information is defined as VI(X,Y) = H(X|Y) + H(Y|X). If X is the ground-truth segmentation, then H(X|Y) can be interpreted as the amount of under-segmentation and H(X|Y) as the amount of over-segmentation. In other words, a perfect over-segmentation will have H(X|Y)=0 and a perfect under-segmentation will have H(Y|X)=0.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image0, image1ndarray of int</code> </dt>
<dd>
<p>Label images / segmentations, must have same shape.</p> </dd> <dt>
<code>tablescipy.sparse array in csr format, optional</code> </dt>
<dd>
<p>A contingency table built with skimage.evaluate.contingency_table. If None, it will be computed with skimage.evaluate.contingency_table. If given, the entropies will be computed from this table and any images will be ignored.</p> </dd> <dt>
<code>ignore_labelssequence of int, optional</code> </dt>
<dd>
<p>Labels to ignore. Any part of the true image labeled with any of these values will not be counted in the score.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>vindarray of float, shape (2,)</code> </dt>
<dd>
<p>The conditional entropies of image1|image0 and image0|image1.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="rb3845a1c7d1d-1">
<code>1</code> </dt> <dd>
<p>Marina Meilă (2007), Comparing clusterings—an information based distance, Journal of Multivariate Analysis, Volume 98, Issue 5, Pages 873-895, ISSN 0047-259X, <a class="reference external" href="https://doi.org/10.1016/j.jmva.2006.11.013">DOI:10.1016/j.jmva.2006.11.013</a>.</p> </dd> </dl> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.metrics.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.metrics.html</a>
  </p>
</div>
