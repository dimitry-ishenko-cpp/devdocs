<h1 id="module-draw">Module: draw</h1> <table class="longtable docutils align-default" id="module-skimage.draw">   <tr>
<td><p><a class="reference internal" href="#skimage.draw.bezier_curve" title="skimage.draw.bezier_curve"><code>skimage.draw.bezier_curve</code></a>(r0, c0, r1, c1, …)</p></td> <td><p>Generate Bezier curve coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.circle" title="skimage.draw.circle"><code>skimage.draw.circle</code></a>(r, c, radius[, shape])</p></td> <td><p>Generate coordinates of pixels within circle.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.circle_perimeter" title="skimage.draw.circle_perimeter"><code>skimage.draw.circle_perimeter</code></a>(r, c, radius)</p></td> <td><p>Generate circle perimeter coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.circle_perimeter_aa" title="skimage.draw.circle_perimeter_aa"><code>skimage.draw.circle_perimeter_aa</code></a>(r, c, radius)</p></td> <td><p>Generate anti-aliased circle perimeter coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.disk" title="skimage.draw.disk"><code>skimage.draw.disk</code></a>(center, radius, *[, shape])</p></td> <td><p>Generate coordinates of pixels within circle.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.ellipse" title="skimage.draw.ellipse"><code>skimage.draw.ellipse</code></a>(r, c, r_radius, c_radius)</p></td> <td><p>Generate coordinates of pixels within ellipse.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.ellipse_perimeter" title="skimage.draw.ellipse_perimeter"><code>skimage.draw.ellipse_perimeter</code></a>(r, c, …[, …])</p></td> <td><p>Generate ellipse perimeter coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.ellipsoid" title="skimage.draw.ellipsoid"><code>skimage.draw.ellipsoid</code></a>(a, b, c[, spacing, …])</p></td> <td><p>Generates ellipsoid with semimajor axes aligned with grid dimensions on grid with specified <code>spacing</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.ellipsoid_stats" title="skimage.draw.ellipsoid_stats"><code>skimage.draw.ellipsoid_stats</code></a>(a, b, c)</p></td> <td><p>Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified <code>spacing</code>.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.line" title="skimage.draw.line"><code>skimage.draw.line</code></a>(r0, c0, r1, c1)</p></td> <td><p>Generate line pixel coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.line_aa" title="skimage.draw.line_aa"><code>skimage.draw.line_aa</code></a>(r0, c0, r1, c1)</p></td> <td><p>Generate anti-aliased line pixel coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.line_nd" title="skimage.draw.line_nd"><code>skimage.draw.line_nd</code></a>(start, stop, *[, …])</p></td> <td><p>Draw a single-pixel thick line in n dimensions.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.polygon" title="skimage.draw.polygon"><code>skimage.draw.polygon</code></a>(r, c[, shape])</p></td> <td><p>Generate coordinates of pixels within polygon.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.polygon2mask" title="skimage.draw.polygon2mask"><code>skimage.draw.polygon2mask</code></a>(image_shape, polygon)</p></td> <td><p>Compute a mask from polygon.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.polygon_perimeter" title="skimage.draw.polygon_perimeter"><code>skimage.draw.polygon_perimeter</code></a>(r, c[, …])</p></td> <td><p>Generate polygon perimeter coordinates.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.random_shapes" title="skimage.draw.random_shapes"><code>skimage.draw.random_shapes</code></a>(image_shape, …)</p></td> <td><p>Generate an image with random shapes, labeled with bounding boxes.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.rectangle" title="skimage.draw.rectangle"><code>skimage.draw.rectangle</code></a>(start[, end, extent, …])</p></td> <td><p>Generate coordinates of pixels within a rectangle.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.rectangle_perimeter" title="skimage.draw.rectangle_perimeter"><code>skimage.draw.rectangle_perimeter</code></a>(start[, …])</p></td> <td><p>Generate coordinates of pixels that are exactly around a rectangle.</p></td> </tr> <tr>
<td><p><a class="reference internal" href="#skimage.draw.set_color" title="skimage.draw.set_color"><code>skimage.draw.set_color</code></a>(image, coords, color)</p></td> <td><p>Set pixel color in the image at the given coordinates.</p></td> </tr>  </table>  <h2 id="bezier-curve">bezier_curve</h2> <dl class="function"> <dt id="skimage.draw.bezier_curve">
<code>skimage.draw.bezier_curve(r0, c0, r1, c1, r2, c2, weight, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L697-L751"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate Bezier curve coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r0, c0int</code> </dt>
<dd>
<p>Coordinates of the first control point.</p> </dd> <dt>
<code>r1, c1int</code> </dt>
<dd>
<p>Coordinates of the middle control point.</p> </dd> <dt>
<code>r2, c2int</code> </dt>
<dd>
<p>Coordinates of the last control point.</p> </dd> <dt>
<code>weightdouble</code> </dt>
<dd>
<p>Middle control point weight, it describes the line tension.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for curves that exceed the image size. If None, the full extent of the curve is used.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc(N,) ndarray of int</code> </dt>
<dd>
<p>Indices of pixels that belong to the Bezier curve. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The algorithm is the rational quadratic algorithm presented in reference <a class="reference internal" href="#r275489368e51-1" id="id1">[1]</a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r275489368e51-1">
<code>1</code> </dt> <dd>
<p>A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf">http://members.chello.at/easyfilter/Bresenham.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.draw import bezier_curve
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = bezier_curve(1, 5, 5, -2, 8, 8, 2)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="circle">circle</h2> <dl class="function"> <dt id="skimage.draw.circle">
<code>skimage.draw.circle(r, c, radius, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L146-L180"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within circle.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r, cdouble</code> </dt>
<dd>
<p>Center coordinate of disk.</p> </dd> <dt>
<code>radiusdouble</code> </dt>
<dd>
<p>Radius of disk.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for disks that exceed the image size. If None, the full extent of the disk is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, ccndarray of int</code> </dt>
<dd>
<p>Pixel coordinates of disk. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> <dt class="field-odd">Warns</dt> <dd class="field-odd">
<dl> <dt>Deprecated:</dt>
<dd>
<div class="versionadded"> <p><span class="versionmodified added">New in version 0.17: </span>This function is deprecated and will be removed in scikit-image 0.19. Please use the function named <code>disk</code> instead.</p> </div> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="circle-perimeter">circle_perimeter</h2> <dl class="function"> <dt id="skimage.draw.circle_perimeter">
<code>skimage.draw.circle_perimeter(r, c, radius, method='bresenham', shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L502-L562"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate circle perimeter coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r, cint</code> </dt>
<dd>
<p>Centre coordinate of circle.</p> </dd> <dt>
<code>radiusint</code> </dt>
<dd>
<p>Radius of circle.</p> </dd> <dt>
<code>method{‘bresenham’, ‘andres’}, optional</code> </dt>
<dd>
<p>bresenham : Bresenham method (default) andres : Andres method</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for circles that exceed the image size. If None, the full extent of the circle is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc(N,) ndarray of int</code> </dt>
<dd>
<p>Bresenham and Andres’ method: Indices of pixels that belong to the circle perimeter. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Andres method presents the advantage that concentric circles create a disc whereas Bresenham can make holes. There is also less distortions when Andres circles are rotated. Bresenham method is also known as midpoint circle algorithm. Anti-aliased circle generator is available with <a class="reference internal" href="#skimage.draw.circle_perimeter_aa" title="skimage.draw.circle_perimeter_aa"><code>circle_perimeter_aa</code></a>.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1917606b9f32-1">
<code>1</code> </dt> <dd>
<p>J.E. Bresenham, “Algorithm for computer control of a digital plotter”, IBM Systems journal, 4 (1965) 25-30.</p> </dd> <dt class="label" id="r1917606b9f32-2">
<code>2</code> </dt> <dd>
<p>E. Andres, “Discrete circles, rings and spheres”, Computers &amp; Graphics, 18 (1994) 695-706.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = circle_perimeter(4, 4, 3)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="circle-perimeter-aa">circle_perimeter_aa</h2> <dl class="function"> <dt id="skimage.draw.circle_perimeter_aa">
<code>skimage.draw.circle_perimeter_aa(r, c, radius, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L565-L623"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate anti-aliased circle perimeter coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r, cint</code> </dt>
<dd>
<p>Centre coordinate of circle.</p> </dd> <dt>
<code>radiusint</code> </dt>
<dd>
<p>Radius of circle.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for circles that exceed the image size. If None, the full extent of the circle is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc, val(N,) ndarray (int, int, float)</code> </dt>
<dd>
<p>Indices of pixels (<code>rr</code>, <code>cc</code>) and intensity values (<code>val</code>). <code>img[rr, cc] = val</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Wu’s method draws anti-aliased circle. This implementation doesn’t use lookup table optimization.</p> <p>Use the function <code>draw.set_color</code> to apply <code>circle_perimeter_aa</code> results to color images.</p> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="ra3f820ec31b4-1">
<code>1</code> </dt> <dd>
<p>X. Wu, “An efficient antialiasing technique”, In ACM SIGGRAPH Computer Graphics, 25 (1991) 143-152.</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import circle_perimeter_aa
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc, val = circle_perimeter_aa(4, 4, 3)
&gt;&gt;&gt; img[rr, cc] = val * 255
&gt;&gt;&gt; img
array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
       [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
       [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
       [  0, 255,   0,   0,   0,   0,   0, 255,   0,   0],
       [  0, 211,  43,   0,   0,   0,  43, 211,   0,   0],
       [  0,  60, 194,  43,   0,  43, 194,  60,   0,   0],
       [  0,   0,  60, 211, 255, 211,  60,   0,   0,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
</pre> <pre data-language="python">&gt;&gt;&gt; from skimage import data, draw
&gt;&gt;&gt; image = data.chelsea()
&gt;&gt;&gt; rr, cc, val = draw.circle_perimeter_aa(r=100, c=100, radius=75)
&gt;&gt;&gt; draw.set_color(image, (rr, cc), [1, 0, 0], alpha=val)
</pre> </dd>
</dl>   <h2 id="disk">disk</h2> <dl class="function"> <dt id="skimage.draw.disk">
<code>skimage.draw.disk(center, radius, *, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L183-L225"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within circle.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>centertuple</code> </dt>
<dd>
<p>Center coordinate of disk.</p> </dd> <dt>
<code>radiusdouble</code> </dt>
<dd>
<p>Radius of disk.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for disks that exceed the image size. If None, the full extent of the disk is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, ccndarray of int</code> </dt>
<dd>
<p>Pixel coordinates of disk. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import disk
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = disk((4, 4), 5)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="ellipse">ellipse</h2> <dl class="function"> <dt id="skimage.draw.ellipse">
<code>skimage.draw.ellipse(r, c, r_radius, c_radius, shape=None, rotation=0.0)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L46-L143"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within ellipse.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r, cdouble</code> </dt>
<dd>
<p>Centre coordinate of ellipse.</p> </dd> <dt>
<code>r_radius, c_radiusdouble</code> </dt>
<dd>
<p>Minor and major semi-axes. <code>(r/r_radius)**2 + (c/c_radius)**2 = 1</code>.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for ellipses which exceed the image size. By default the full extent of the ellipse are used. Must be at least length 2. Only the first two values are used to determine the extent.</p> </dd> <dt>
<code>rotationfloat, optional (default 0.)</code> </dt>
<dd>
<p>Set the ellipse rotation (rotation) in range (-PI, PI) in contra clock wise direction, so PI/2 degree means swap ellipse axis</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, ccndarray of int</code> </dt>
<dd>
<p>Pixel coordinates of ellipse. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>The ellipse equation:</p> <pre data-language="python">((x * cos(alpha) + y * sin(alpha)) / x_radius) ** 2 +
((x * sin(alpha) - y * cos(alpha)) / y_radius) ** 2 = 1
</pre> <p>Note that the positions of <a class="reference internal" href="#skimage.draw.ellipse" title="skimage.draw.ellipse"><code>ellipse</code></a> without specified <code>shape</code> can have also, negative values, as this is correct on the plane. On the other hand using these ellipse positions for an image afterwards may lead to appearing on the other side of image, because <code>image[-1, -1] = image[end-1, end-1]</code></p> <pre data-language="python">&gt;&gt;&gt; rr, cc = ellipse(1, 2, 3, 6)
&gt;&gt;&gt; img = np.zeros((6, 12), dtype=np.uint8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1],
       [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1]], dtype=uint8)
</pre> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import ellipse
&gt;&gt;&gt; img = np.zeros((10, 12), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse(5, 6, 3, 5, rotation=np.deg2rad(30))
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>  <h3 id="examples-using-skimage-draw-ellipse">Examples using <code>skimage.draw.ellipse</code>
</h3> <div class="sphx-glr-thumbcontainer" tooltip="In this example, we use the masked normalized cross-correlation to identify the relative shift ...">
<div class="figure align-default" id="id8"> <img alt="Masked Normalized Cross-Correlation" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/registration/plot_masked_register_translation.html#sphx-glr-auto-examples-registration-plot-masked-register-translation-py"><span class="std std-ref">Masked Normalized Cross-Correlation</span></a></span></p> </div> </div>
<div class="sphx-glr-thumbcontainer" tooltip="This example shows how to measure properties of labelled image regions. We first analyze an ima...">
<div class="figure align-default" id="id9"> <img alt="Measure region properties" src="data:image/png;base64,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"> <p class="caption"><span class="caption-text"><a class="reference internal" href="https://scikit-image.org/docs/0.18.x/auto_examples/segmentation/plot_regionprops.html#sphx-glr-auto-examples-segmentation-plot-regionprops-py"><span class="std std-ref">Measure region properties</span></a></span></p> </div> </div>   <h2 id="ellipse-perimeter">ellipse_perimeter</h2> <dl class="function"> <dt id="skimage.draw.ellipse_perimeter">
<code>skimage.draw.ellipse_perimeter(r, c, r_radius, c_radius, orientation=0, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L626-L694"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate ellipse perimeter coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r, cint</code> </dt>
<dd>
<p>Centre coordinate of ellipse.</p> </dd> <dt>
<code>r_radius, c_radiusint</code> </dt>
<dd>
<p>Minor and major semi-axes. <code>(r/r_radius)**2 + (c/c_radius)**2 = 1</code>.</p> </dd> <dt>
<code>orientationdouble, optional</code> </dt>
<dd>
<p>Major axis orientation in clockwise direction as radians.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for ellipses that exceed the image size. If None, the full extent of the ellipse is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc(N,) ndarray of int</code> </dt>
<dd>
<p>Indices of pixels that belong to the ellipse perimeter. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r1d1f03d90c6e-1">
<code>1</code> </dt> <dd>
<p>A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf">http://members.chello.at/easyfilter/Bresenham.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import ellipse_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = ellipse_perimeter(5, 5, 3, 4)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> <p>Note that the positions of <a class="reference internal" href="#skimage.draw.ellipse" title="skimage.draw.ellipse"><code>ellipse</code></a> without specified <code>shape</code> can have also, negative values, as this is correct on the plane. On the other hand using these ellipse positions for an image afterwards may lead to appearing on the other side of image, because <code>image[-1, -1] = image[end-1, end-1]</code></p> <pre data-language="python">&gt;&gt;&gt; rr, cc = ellipse_perimeter(2, 3, 4, 5)
&gt;&gt;&gt; img = np.zeros((9, 12), dtype=np.uint8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
       [0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
       [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="ellipsoid">ellipsoid</h2> <dl class="function"> <dt id="skimage.draw.ellipsoid">
<code>skimage.draw.ellipsoid(a, b, c, spacing=(1.0, 1.0, 1.0), levelset=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw3d.py#L5-L63"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generates ellipsoid with semimajor axes aligned with grid dimensions on grid with specified <code>spacing</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>afloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with x-axis.</p> </dd> <dt>
<code>bfloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with y-axis.</p> </dd> <dt>
<code>cfloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with z-axis.</p> </dd> <dt>
<code>spacingtuple of floats, length 3</code> </dt>
<dd>
<p>Spacing in (x, y, z) spatial dimensions.</p> </dd> <dt>
<code>levelsetbool</code> </dt>
<dd>
<p>If True, returns the level set for this ellipsoid (signed level set about zero, with positive denoting interior) as np.float64. False returns a binarized version of said level set.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>ellip(N, M, P) array</code> </dt>
<dd>
<p>Ellipsoid centered in a correctly sized array for given <code>spacing</code>. Boolean dtype unless <code>levelset=True</code>, in which case a float array is returned with the level set above 0.0 representing the ellipsoid.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="ellipsoid-stats">ellipsoid_stats</h2> <dl class="function"> <dt id="skimage.draw.ellipsoid_stats">
<code>skimage.draw.ellipsoid_stats(a, b, c)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw3d.py#L66-L114"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Calculates analytical surface area and volume for ellipsoid with semimajor axes aligned with grid dimensions of specified <code>spacing</code>.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>afloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with x-axis.</p> </dd> <dt>
<code>bfloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with y-axis.</p> </dd> <dt>
<code>cfloat</code> </dt>
<dd>
<p>Length of semimajor axis aligned with z-axis.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>volfloat</code> </dt>
<dd>
<p>Calculated volume of ellipsoid.</p> </dd> <dt>
<code>surffloat</code> </dt>
<dd>
<p>Calculated surface area of ellipsoid.</p> </dd> </dl> </dd> </dl> </dd>
</dl>   <h2 id="line">line</h2> <dl class="function"> <dt id="skimage.draw.line">
<code>skimage.draw.line(r0, c0, r1, c1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L371-L410"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate line pixel coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r0, c0int</code> </dt>
<dd>
<p>Starting position (row, column).</p> </dd> <dt>
<code>r1, c1int</code> </dt>
<dd>
<p>End position (row, column).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc(N,) ndarray of int</code> </dt>
<dd>
<p>Indices of pixels that belong to the line. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>Anti-aliased line generator is available with <a class="reference internal" href="#skimage.draw.line_aa" title="skimage.draw.line_aa"><code>line_aa</code></a>.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = line(1, 1, 8, 8)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="line-aa">line_aa</h2> <dl class="function"> <dt id="skimage.draw.line_aa">
<code>skimage.draw.line_aa(r0, c0, r1, c1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L413-L452"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate anti-aliased line pixel coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r0, c0int</code> </dt>
<dd>
<p>Starting position (row, column).</p> </dd> <dt>
<code>r1, c1int</code> </dt>
<dd>
<p>End position (row, column).</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, cc, val(N,) ndarray (int, int, float)</code> </dt>
<dd>
<p>Indices of pixels (<code>rr</code>, <code>cc</code>) and intensity values (<code>val</code>). <code>img[rr, cc] = val</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r99ed5d9f4c57-1">
<code>1</code> </dt> <dd>
<p>A Rasterizing Algorithm for Drawing Curves, A. Zingl, 2012 <a class="reference external" href="http://members.chello.at/easyfilter/Bresenham.pdf">http://members.chello.at/easyfilter/Bresenham.pdf</a></p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line_aa
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc, val = line_aa(1, 1, 8, 8)
&gt;&gt;&gt; img[rr, cc] = val * 255
&gt;&gt;&gt; img
array([[  0,   0,   0,   0,   0,   0,   0,   0,   0,   0],
       [  0, 255,  74,   0,   0,   0,   0,   0,   0,   0],
       [  0,  74, 255,  74,   0,   0,   0,   0,   0,   0],
       [  0,   0,  74, 255,  74,   0,   0,   0,   0,   0],
       [  0,   0,   0,  74, 255,  74,   0,   0,   0,   0],
       [  0,   0,   0,   0,  74, 255,  74,   0,   0,   0],
       [  0,   0,   0,   0,   0,  74, 255,  74,   0,   0],
       [  0,   0,   0,   0,   0,   0,  74, 255,  74,   0],
       [  0,   0,   0,   0,   0,   0,   0,  74, 255,   0],
       [  0,   0,   0,   0,   0,   0,   0,   0,   0,   0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="line-nd">line_nd</h2> <dl class="function"> <dt id="skimage.draw.line_nd">
<code>skimage.draw.line_nd(start, stop, *, endpoint=False, integer=True)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw_nd.py#L54-L108"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Draw a single-pixel thick line in n dimensions.</p> <p>The line produced will be ndim-connected. That is, two subsequent pixels in the line will be either direct or diagonal neighbours in n dimensions.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>startarray-like, shape (N,)</code> </dt>
<dd>
<p>The start coordinates of the line.</p> </dd> <dt>
<code>stoparray-like, shape (N,)</code> </dt>
<dd>
<p>The end coordinates of the line.</p> </dd> <dt>
<code>endpointbool, optional</code> </dt>
<dd>
<p>Whether to include the endpoint in the returned line. Defaults to False, which allows for easy drawing of multi-point paths.</p> </dd> <dt>
<code>integerbool, optional</code> </dt>
<dd>
<p>Whether to round the coordinates to integer. If True (default), the returned coordinates can be used to directly index into an array. <code>False</code> could be used for e.g. vector drawing.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coordstuple of arrays</code> </dt>
<dd>
<p>The coordinates of points on the line.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; lin = line_nd((1, 1), (5, 2.5), endpoint=False)
&gt;&gt;&gt; lin
(array([1, 2, 3, 4]), array([1, 1, 2, 2]))
&gt;&gt;&gt; im = np.zeros((6, 5), dtype=int)
&gt;&gt;&gt; im[lin] = 1
&gt;&gt;&gt; im
array([[0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 1, 0, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0]])
&gt;&gt;&gt; line_nd([2, 1, 1], [5, 5, 2.5], endpoint=True)
(array([2, 3, 4, 4, 5]), array([1, 2, 3, 4, 5]), array([1, 1, 2, 2, 2]))
</pre> </dd>
</dl>   <h2 id="polygon">polygon</h2> <dl class="function"> <dt id="skimage.draw.polygon">
<code>skimage.draw.polygon(r, c, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L455-L499"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within polygon.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r(N,) ndarray</code> </dt>
<dd>
<p>Row coordinates of vertices of polygon.</p> </dd> <dt>
<code>c(N,) ndarray</code> </dt>
<dd>
<p>Column coordinates of vertices of polygon.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine the maximum extent of output pixel coordinates. This is useful for polygons that exceed the image size. If None, the full extent of the polygon is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, ccndarray of int</code> </dt>
<dd>
<p>Pixel coordinates of polygon. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import polygon
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; r = np.array([1, 2, 8])
&gt;&gt;&gt; c = np.array([1, 7, 4])
&gt;&gt;&gt; rr, cc = polygon(r, c)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 1, 0, 0],
       [0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="polygon2mask">polygon2mask</h2> <dl class="function"> <dt id="skimage.draw.polygon2mask">
<code>skimage.draw.polygon2mask(image_shape, polygon)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/_polygon2mask.py#L6-L41"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute a mask from polygon.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_shapetuple of size 2.</code> </dt>
<dd>
<p>The shape of the mask.</p> </dd> <dt>
<code>polygonarray_like.</code> </dt>
<dd>
<p>The polygon coordinates of shape (N, 2) where N is the number of points.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>mask2-D ndarray of type ‘bool’.</code> </dt>
<dd>
<p>The mask that corresponds to the input polygon.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function does not do any border checking, so that all the vertices need to be within the given shape.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; image_shape = (128, 128)
&gt;&gt;&gt; polygon = np.array([[60, 100], [100, 40], [40, 40]])
&gt;&gt;&gt; mask = polygon2mask(image_shape, polygon)
&gt;&gt;&gt; mask.shape
(128, 128)
</pre> </dd>
</dl>   <h2 id="polygon-perimeter">polygon_perimeter</h2> <dl class="function"> <dt id="skimage.draw.polygon_perimeter">
<code>skimage.draw.polygon_perimeter(r, c, shape=None, clip=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L228-L304"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate polygon perimeter coordinates.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>r(N,) ndarray</code> </dt>
<dd>
<p>Row coordinates of vertices of polygon.</p> </dd> <dt>
<code>c(N,) ndarray</code> </dt>
<dd>
<p>Column coordinates of vertices of polygon.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape which is used to determine maximum extents of output pixel coordinates. This is useful for polygons that exceed the image size. If None, the full extents of the polygon is used. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the polygon to the provided shape. If this is set to True, the drawn figure will always be a closed polygon with all edges visible.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>rr, ccndarray of int</code> </dt>
<dd>
<p>Pixel coordinates of polygon. May be used to directly index into an array, e.g. <code>img[rr, cc] = 1</code>.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import polygon_perimeter
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = polygon_perimeter([5, -1, 5, 10],
...                            [-1, 5, 11, 5],
...                            shape=img.shape, clip=True)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 1, 1, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 1, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [0, 1, 1, 0, 0, 0, 0, 0, 0, 1],
       [0, 0, 0, 1, 0, 0, 0, 1, 1, 0],
       [0, 0, 0, 0, 1, 1, 1, 0, 0, 0]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="random-shapes">random_shapes</h2> <dl class="function"> <dt id="skimage.draw.random_shapes">
<code>skimage.draw.random_shapes(image_shape, max_shapes, min_shapes=1, min_size=2, max_size=None, multichannel=True, num_channels=3, shape=None, intensity_range=None, allow_overlap=False, num_trials=100, random_seed=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/_random_shapes.py#L293-L437"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate an image with random shapes, labeled with bounding boxes.</p> <p>The image is populated with random shapes with random sizes, random locations, and random colors, with or without overlap.</p> <p>Shapes have random (row, col) starting coordinates and random sizes bounded by <code>min_size</code> and <code>max_size</code>. It can occur that a randomly generated shape will not fit the image at all. In that case, the algorithm will try again with new starting coordinates a certain number of times. However, it also means that some shapes may be skipped altogether. In that case, this function will generate fewer shapes than requested.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image_shapetuple</code> </dt>
<dd>
<p>The number of rows and columns of the image to generate.</p> </dd> <dt>
<code>max_shapesint</code> </dt>
<dd>
<p>The maximum number of shapes to (attempt to) fit into the shape.</p> </dd> <dt>
<code>min_shapesint, optional</code> </dt>
<dd>
<p>The minimum number of shapes to (attempt to) fit into the shape.</p> </dd> <dt>
<code>min_sizeint, optional</code> </dt>
<dd>
<p>The minimum dimension of each shape to fit into the image.</p> </dd> <dt>
<code>max_sizeint, optional</code> </dt>
<dd>
<p>The maximum dimension of each shape to fit into the image.</p> </dd> <dt>
<code>multichannelbool, optional</code> </dt>
<dd>
<p>If True, the generated image has <code>num_channels</code> color channels, otherwise generates grayscale image.</p> </dd> <dt>
<code>num_channelsint, optional</code> </dt>
<dd>
<p>Number of channels in the generated image. If 1, generate monochrome images, else color images with multiple channels. Ignored if <code>multichannel</code> is set to False.</p> </dd> <dt>
<code>shape{rectangle, circle, triangle, ellipse, None} str, optional</code> </dt>
<dd>
<p>The name of the shape to generate or <code>None</code> to pick random ones.</p> </dd> <dt>
<code>intensity_range{tuple of tuples of uint8, tuple of uint8}, optional</code> </dt>
<dd>
<p>The range of values to sample pixel values from. For grayscale images the format is (min, max). For multichannel - ((min, max),) if the ranges are equal across the channels, and ((min_0, max_0), … (min_N, max_N)) if they differ. As the function supports generation of uint8 arrays only, the maximum range is (0, 255). If None, set to (0, 254) for each channel reserving color of intensity = 255 for background.</p> </dd> <dt>
<code>allow_overlapbool, optional</code> </dt>
<dd>
<p>If <code>True</code>, allow shapes to overlap.</p> </dd> <dt>
<code>num_trialsint, optional</code> </dt>
<dd>
<p>How often to attempt to fit a shape into the image before skipping it.</p> </dd> <dt>
<code>random_seedint, optional</code> </dt>
<dd>
<p>Seed to initialize the random number generator. If <code>None</code>, a random seed from the operating system is used.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>imageuint8 array</code> </dt>
<dd>
<p>An image with the fitted shapes.</p> </dd> <dt>
<code>labelslist</code> </dt>
<dd>
<p>A list of labels, one per shape in the image. Each label is a (category, ((r0, r1), (c0, c1))) tuple specifying the category and bounding box coordinates of the shape.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import skimage.draw
&gt;&gt;&gt; image, labels = skimage.draw.random_shapes((32, 32), max_shapes=3)
&gt;&gt;&gt; image 
array([
   [[255, 255, 255],
    [255, 255, 255],
    [255, 255, 255],
    ...,
    [255, 255, 255],
    [255, 255, 255],
    [255, 255, 255]]], dtype=uint8)
&gt;&gt;&gt; labels 
[('circle', ((22, 18), (25, 21))),
 ('triangle', ((5, 6), (13, 13)))]
</pre> </dd>
</dl>   <h2 id="rectangle">rectangle</h2> <dl class="function"> <dt id="skimage.draw.rectangle">
<code>skimage.draw.rectangle(start, end=None, extent=None, shape=None)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L754-L847"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels within a rectangle.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>starttuple</code> </dt>
<dd>
<p>Origin point of the rectangle, e.g., <code>([plane,] row, column)</code>.</p> </dd> <dt>
<code>endtuple</code> </dt>
<dd>
<p>End point of the rectangle <code>([plane,] row, column)</code>. For a 2D matrix, the slice defined by the rectangle is <code>[start:(end+1)]</code>. Either <code>end</code> or <code>extent</code> must be specified.</p> </dd> <dt>
<code>extenttuple</code> </dt>
<dd>
<p>The extent (size) of the drawn rectangle. E.g., <code>([num_planes,] num_rows, num_cols)</code>. Either <code>end</code> or <code>extent</code> must be specified. A negative extent is valid, and will result in a rectangle going along the opposite direction. If extent is negative, the <code>start</code> point is not included.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape used to determine the maximum bounds of the output coordinates. This is useful for clipping rectangles that exceed the image size. By default, no clipping is done.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coordsarray of int, shape (Ndim, Npoints)</code> </dt>
<dd>
<p>The coordinates of all pixels in the rectangle.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Notes</h4> <p>This function can be applied to N-dimensional images, by passing <code>start</code> and <code>end</code> or <code>extent</code> as tuples of length N.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.draw import rectangle
&gt;&gt;&gt; img = np.zeros((5, 5), dtype=np.uint8)
&gt;&gt;&gt; start = (1, 1)
&gt;&gt;&gt; extent = (3, 3)
&gt;&gt;&gt; rr, cc = rectangle(start, extent=extent, shape=img.shape)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> <pre data-language="python">&gt;&gt;&gt; img = np.zeros((5, 5), dtype=np.uint8)
&gt;&gt;&gt; start = (0, 1)
&gt;&gt;&gt; end = (3, 3)
&gt;&gt;&gt; rr, cc = rectangle(start, end=end, shape=img.shape)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 1, 1, 1, 0],
       [0, 0, 0, 0, 0]], dtype=uint8)
</pre> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.draw import rectangle
&gt;&gt;&gt; img = np.zeros((6, 6), dtype=np.uint8)
&gt;&gt;&gt; start = (3, 3)
&gt;&gt;&gt;
&gt;&gt;&gt; rr, cc = rectangle(start, extent=(2, 2))
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; rr, cc = rectangle(start, extent=(-2, 2))
&gt;&gt;&gt; img[rr, cc] = 2
&gt;&gt;&gt; rr, cc = rectangle(start, extent=(-2, -2))
&gt;&gt;&gt; img[rr, cc] = 3
&gt;&gt;&gt; rr, cc = rectangle(start, extent=(2, -2))
&gt;&gt;&gt; img[rr, cc] = 4
&gt;&gt;&gt; print(img)
[[0 0 0 0 0 0]
 [0 3 3 2 2 0]
 [0 3 3 2 2 0]
 [0 4 4 1 1 0]
 [0 4 4 1 1 0]
 [0 0 0 0 0 0]]
</pre> </dd>
</dl>   <h2 id="rectangle-perimeter">rectangle_perimeter</h2> <dl class="function"> <dt id="skimage.draw.rectangle_perimeter">
<code>skimage.draw.rectangle_perimeter(start, end=None, extent=None, shape=None, clip=False)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L850-L920"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Generate coordinates of pixels that are exactly around a rectangle.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>starttuple</code> </dt>
<dd>
<p>Origin point of the inner rectangle, e.g., <code>(row, column)</code>.</p> </dd> <dt>
<code>endtuple</code> </dt>
<dd>
<p>End point of the inner rectangle <code>(row, column)</code>. For a 2D matrix, the slice defined by inner the rectangle is <code>[start:(end+1)]</code>. Either <code>end</code> or <code>extent</code> must be specified.</p> </dd> <dt>
<code>extenttuple</code> </dt>
<dd>
<p>The extent (size) of the inner rectangle. E.g., <code>(num_rows, num_cols)</code>. Either <code>end</code> or <code>extent</code> must be specified. Negative extents are permitted. See <a class="reference internal" href="#skimage.draw.rectangle" title="skimage.draw.rectangle"><code>rectangle</code></a> to better understand how they behave.</p> </dd> <dt>
<code>shapetuple, optional</code> </dt>
<dd>
<p>Image shape used to determine the maximum bounds of the output coordinates. This is useful for clipping perimeters that exceed the image size. By default, no clipping is done. Must be at least length 2. Only the first two values are used to determine the extent of the input image.</p> </dd> <dt>
<code>clipbool, optional</code> </dt>
<dd>
<p>Whether to clip the perimeter to the provided shape. If this is set to True, the drawn figure will always be a closed polygon with all edges visible.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<code>coordsarray of int, shape (2, Npoints)</code> </dt>
<dd>
<p>The coordinates of all pixels in the rectangle.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; import numpy as np
&gt;&gt;&gt; from skimage.draw import rectangle_perimeter
&gt;&gt;&gt; img = np.zeros((5, 6), dtype=np.uint8)
&gt;&gt;&gt; start = (2, 3)
&gt;&gt;&gt; end = (3, 4)
&gt;&gt;&gt; rr, cc = rectangle_perimeter(start, end=end, shape=img.shape)
&gt;&gt;&gt; img[rr, cc] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1, 1],
       [0, 0, 1, 0, 0, 1],
       [0, 0, 1, 0, 0, 1],
       [0, 0, 1, 1, 1, 1]], dtype=uint8)
</pre> <pre data-language="python">&gt;&gt;&gt; img = np.zeros((5, 5), dtype=np.uint8)
&gt;&gt;&gt; r, c = rectangle_perimeter(start, (10, 10), shape=img.shape, clip=True)
&gt;&gt;&gt; img[r, c] = 1
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0],
       [0, 0, 1, 1, 1],
       [0, 0, 1, 0, 1],
       [0, 0, 1, 0, 1],
       [0, 0, 1, 1, 1]], dtype=uint8)
</pre> </dd>
</dl>   <h2 id="set-color">set_color</h2> <dl class="function"> <dt id="skimage.draw.set_color">
<code>skimage.draw.set_color(image, coords, color, alpha=1)</code> <a class="reference external" href="https://github.com/scikit-image/scikit-image/blob/v0.18.0/skimage/draw/draw.py#L307-L368"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Set pixel color in the image at the given coordinates.</p> <p>Note that this function modifies the color of the image in-place. Coordinates that exceed the shape of the image will be ignored.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<code>image(M, N, D) ndarray</code> </dt>
<dd>
<p>Image</p> </dd> <dt>
<code>coordstuple of ((P,) ndarray, (P,) ndarray)</code> </dt>
<dd>
<p>Row and column coordinates of pixels to be colored.</p> </dd> <dt>
<code>color(D,) ndarray</code> </dt>
<dd>
<p>Color to be assigned to coordinates in the image.</p> </dd> <dt>
<code>alphascalar or (N,) ndarray</code> </dt>
<dd>
<p>Alpha values used to blend color with image. 0 is transparent, 1 is opaque.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from skimage.draw import line, set_color
&gt;&gt;&gt; img = np.zeros((10, 10), dtype=np.uint8)
&gt;&gt;&gt; rr, cc = line(1, 1, 20, 20)
&gt;&gt;&gt; set_color(img, (rr, cc), 1)
&gt;&gt;&gt; img
array([[0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]], dtype=uint8)
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2019 the scikit-image team<br>Licensed under the BSD 3-clause License.<br>
    <a href="https://scikit-image.org/docs/0.18.x/api/skimage.draw.html" class="_attribution-link">https://scikit-image.org/docs/0.18.x/api/skimage.draw.html</a>
  </p>
</div>
