<h1 id="security">Security</h1> <p>The Security Class contains methods that help protect your site against Cross-Site Request Forgery attacks.</p>  <ul class="simple"> <li><a class="reference internal" href="#loading-the-library" id="id1">Loading the Library</a></li> <li>
<a class="reference internal" href="#cross-site-request-forgery-csrf" id="id2">Cross-site request forgery (CSRF)</a><ul> <li><a class="reference internal" href="#csrf-protection-methods" id="id3">CSRF Protection Methods</a></li> <li><a class="reference internal" href="#enable-csrf-protection" id="id4">Enable CSRF Protection</a></li> <li><a class="reference internal" href="#html-forms" id="id5">HTML Forms</a></li> <li><a class="reference internal" href="#the-order-of-token-sent-by-users" id="id6">The Order of Token Sent by Users</a></li> <li><a class="reference internal" href="#token-regeneration" id="id7">Token Regeneration</a></li> <li><a class="reference internal" href="#redirection-on-failure" id="id8">Redirection on Failure</a></li> </ul> </li> <li><a class="reference internal" href="#other-helpful-methods" id="id9">Other Helpful Methods</a></li> </ul>   <h2 id="loading-the-library">Loading the Library</h2> <p>If your only interest in loading the library is to handle CSRF protection, then you will never need to load it, as it runs as a filter and has no manual interaction.</p> <p>If you find a case where you do need direct access though, you may load it through the Services file:</p> <pre data-language="php">$security = \Config\Services::security();
</pre>   <h2 id="cross-site-request-forgery-csrf">Cross-site request forgery (CSRF)</h2> <div class="admonition warning"> <p class="first admonition-title">Warning</p> <p class="last">The CSRF Protection is only available for <strong>POST/PUT/PATCH/DELETE</strong> requests. Requests for other methods are not protected.</p> </div>  <h3 id="csrf-protection-methods">CSRF Protection Methods</h3> <p>By default, the Cookie based CSRF Protection is used. It is <a class="reference external" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie">Double Submit Cookie</a> on OWASP Cross-Site Request Forgery Prevention Cheat Sheet.</p> <p>You can also use Session based CSRF Protection. It is <a class="reference external" href="https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#synchronizer-token-pattern">Synchronizer Token Pattern</a>.</p> <p>You can set to use the Session based CSRF protection by editing the following config parameter value in <strong>app/Config/Security.php</strong>:</p> <pre data-language="php">public $csrfProtection = 'session';
</pre>   <h3 id="enable-csrf-protection">Enable CSRF Protection</h3> <p>You can enable CSRF protection by altering your <strong>app/Config/Filters.php</strong> and enabling the <code>csrf</code> filter globally:</p> <pre data-language="php">public $globals = [
    'before' =&gt; [
        // 'honeypot',
        'csrf',
    ],
];
</pre> <p>Select URIs can be whitelisted from CSRF protection (for example API endpoints expecting externally POSTed content). You can add these URIs by adding them as exceptions in the filter:</p> <pre data-language="php">public $globals = [
    'before' =&gt; [
        'csrf' =&gt; ['except' =&gt; ['api/record/save']],
    ],
];
</pre> <p>Regular expressions are also supported (case-insensitive):</p> <pre data-language="php">public $globals = [
    'before' =&gt; [
        'csrf' =&gt; ['except' =&gt; ['api/record/[0-9]+']],
    ],
];
</pre> <p>It is also possible to enable the CSRF filter only for specific methods:</p> <pre data-language="php">public $methods = [
    'get'  =&gt; ['csrf'],
    'post' =&gt; ['csrf'],
];
</pre>   <h3 id="html-forms">HTML Forms</h3> <p>If you use the <a class="reference internal" href="../helpers/form_helper.html"><span class="doc">form helper</span></a>, then <code>form_open()</code> will automatically insert a hidden csrf field in your forms.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">To use auto-generation of CSRF field, you need to turn CSRF filter on to the form page. In most cases it is requested using the <code>GET</code> method.</p> </div> <p>If not, then you can use the always available <code>csrf_token()</code> and <code>csrf_hash()</code> functions</p> <pre data-language="php">&lt;input type="hidden" name="&lt;?= csrf_token() ?&gt;" value="&lt;?= csrf_hash() ?&gt;" /&gt;
</pre> <p>Additionally, you can use the <code>csrf_field()</code> method to generate this hidden input field for you:</p> <pre data-language="php">// Generates: &lt;input type="hidden" name="{csrf_token}" value="{csrf_hash}" /&gt;
&lt;?= csrf_field() ?&gt;
</pre> <p>When sending a JSON request the CSRF token can also be passed as one of the parameters. The next way to pass the CSRF token is a special Http header thatâ€™s name is available by <code>csrf_header()</code> function.</p> <p>Additionally, you can use the <code>csrf_meta()</code> method to generate this handy meta tag for you:</p> <pre data-language="php">// Generates: &lt;meta name="{csrf_header}" content="{csrf_hash}" /&gt;
&lt;?= csrf_meta() ?&gt;
</pre>   <h3 id="the-order-of-token-sent-by-users">The Order of Token Sent by Users</h3> <p>The order of checking the availability of the CSRF token is as follows:</p> <ol class="arabic simple"> <li>
<code>$_POST</code> array</li> <li>HTTP header</li> <li>
<code>php://input</code> (JSON request) - bear in mind that this approach is the slowest one since we have to decode JSON and then re-encode it</li> </ol>   <h3 id="token-regeneration">Token Regeneration</h3> <p>Tokens may be either regenerated on every submission (default) or kept the same throughout the life of the CSRF cookie. The default regeneration of tokens provides stricter security, but may result in usability concerns as other tokens become invalid (back/forward navigation, multiple tabs/windows, asynchronous actions, etc). You may alter this behavior by editing the following config parameter value in <strong>app/Config/Security.php</strong>:</p> <pre data-language="php">public $regenerate  = true;
</pre>   <h3 id="redirection-on-failure">Redirection on Failure</h3> <p>When a request fails the CSRF validation check, it will redirect to the previous page by default, setting an <code>error</code> flash message that you can display to the end user. This provides a nicer experience than simply crashing. This can be turned off by editing the following config parameter value in <strong>app/Config/Security.php</strong>:</p> <pre data-language="php">public $redirect = false;
</pre> <p>Even when the redirect value is <code>true</code>, AJAX calls will not redirect, but will throw an error.</p>    <h2 id="other-helpful-methods">Other Helpful Methods</h2> <p>You will never need to use most of the methods in the Security class directly. The following are methods that you might find helpful that are not related to the CSRF protection.</p> <p><strong>sanitizeFilename()</strong></p> <p>Tries to sanitize filenames in order to prevent directory traversal attempts and other security threats, which is particularly useful for files that were supplied via user input. The first parameter is the path to sanitize.</p> <p>If it is acceptable for the user input to include relative paths, e.g., <strong>file/in/some/approved/folder.txt</strong>, you can set the second optional parameter, <code>$relativePath</code> to <code>true</code>.</p> <pre data-language="php">$path = $security-&gt;sanitizeFilename($request-&gt;getVar('filepath'));
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2020 British Columbia Institute of Technology<br>Licensed under the MIT License.<br>
    <a href="https://codeigniter.com/user_guide/libraries/security.html" class="_attribution-link">https://codeigniter.com/user_guide/libraries/security.html</a>
  </p>
</div>
