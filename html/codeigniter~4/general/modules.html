<h1 id="code-modules">Code Modules</h1> <p>CodeIgniter supports a form of code modularization to help you create reusable code. Modules are typically centered around a specific subject, and can be thought of as mini-applications within your larger application. Any of the standard file types within the framework are supported, like controllers, models, views, config files, helpers, language files, etc. Modules may contain as few, or as many, of these as you like.</p>  <ul class="simple"> <li><a class="reference internal" href="#namespaces" id="id1">Namespaces</a></li> <li><a class="reference internal" href="#autoloading-non-class-files" id="id2">Autoloading Non-class Files</a></li> <li>
<a class="reference internal" href="#auto-discovery" id="id3">Auto-Discovery</a><ul> <li><a class="reference internal" href="#enable-disable-discover" id="id4">Enable/Disable Discover</a></li> <li><a class="reference internal" href="#specify-discovery-items" id="id5">Specify Discovery Items</a></li> <li><a class="reference internal" href="#discovery-and-composer" id="id6">Discovery and Composer</a></li> </ul> </li> <li>
<a class="reference internal" href="#working-with-files" id="id7">Working With Files</a><ul> <li><a class="reference internal" href="#routes" id="id8">Routes</a></li> <li><a class="reference internal" href="#filters" id="id9">Filters</a></li> <li><a class="reference internal" href="#controllers" id="id10">Controllers</a></li> <li><a class="reference internal" href="#config-files" id="id11">Config Files</a></li> <li><a class="reference internal" href="#migrations" id="id12">Migrations</a></li> <li><a class="reference internal" href="#seeds" id="id13">Seeds</a></li> <li><a class="reference internal" href="#helpers" id="id14">Helpers</a></li> <li><a class="reference internal" href="#language-files" id="id15">Language Files</a></li> <li><a class="reference internal" href="#libraries" id="id16">Libraries</a></li> <li><a class="reference internal" href="#models" id="id17">Models</a></li> <li><a class="reference internal" href="#views" id="id18">Views</a></li> </ul> </li> </ul>   <h2 id="namespaces">Namespaces</h2> <p>The core element of the modules functionality comes from the <a class="reference internal" href="../concepts/autoloader.html"><span class="doc">PSR4-compatible autoloading</span></a> that CodeIgniter uses. While any code can use the PSR4 autoloader and namespaces, the primary way to take full advantage of modules is to namespace your code and add it to <strong>app/Config/Autoload.php</strong>, in the <code>psr4</code> section.</p> <p>For example, let’s say we want to keep a simple blog module that we can re-use between applications. We might create folder with our company name, Acme, to store all of our modules within. We will put it right alongside our <strong>app</strong> directory in the main project root:</p> <pre data-language="php">/acme        // New modules directory
/app
/public
/system
/tests
/writable
</pre> <p>Open <strong>app/Config/Autoload.php</strong> and add the <strong>Acme</strong> namespace to the <code>psr4</code> array property:</p> <pre data-language="php">public $psr4 = [
    APP_NAMESPACE =&gt; APPPATH, // For custom namespace
    'Config'      =&gt; APPPATH . 'Config',
    'Acme'        =&gt; ROOTPATH . 'acme',
];
</pre> <p>Now that this is set up, we can access any file within the <strong>acme</strong> folder through the <code>Acme</code> namespace. This alone takes care of 80% of what is needed for modules to work, so you should be sure to familiarize yourself with namespaces and become comfortable with their use. Several file types will be scanned for automatically through all defined namespaces - a crucial ingredient for working with modules.</p> <p>A common directory structure within a module will mimic the main application folder:</p> <pre data-language="php">/acme
    /Blog
        /Config
        /Controllers
        /Database
            /Migrations
            /Seeds
        /Helpers
        /Language
            /en
        /Libraries
        /Models
        /Views
</pre> <p>Of course, there is nothing forcing you to use this exact structure, and you should organize it in the manner that best suits your module, leaving out directories you don’t need, creating new directories for Entities, Interfaces, or Repositories, etc.</p>   <h2 id="autoloading-non-class-files">Autoloading Non-class Files</h2> <p>More often than not that your module will not contain only PHP classes but also others like procedural functions, bootstrapping files, module constants files, etc. which are not normally loaded the way classes are loaded. One approach for this is using <code>require</code>-ing the file(s) at the start of the file where it would be used.</p> <p>Another approach provided by CodeIgniter is to autoload these <em>non-class</em> files like how you would autoload your classes. All we need to do is provide the list of paths to those files and include them in the <code>$files</code> property of your <strong>app/Config/Autoload.php</strong> file.</p> <pre data-language="php">public $files = [
    'path/to/my/functions.php',
    'path/to/my/constants.php',
    'path/to/my/bootstrap.php',
];
</pre>   <h2 id="auto-discovery">Auto-Discovery</h2> <p>Many times, you will need to specify the full namespace to files you want to include, but CodeIgniter can be configured to make integrating modules into your applications simpler by automatically discovering many different file types, including:</p> <ul class="simple"> <li><a class="reference internal" href="../extending/events.html"><span class="doc">Events</span></a></li> <li><a class="reference internal" href="configuration.html"><span class="doc">Registrars</span></a></li> <li><a class="reference internal" href="../incoming/routing.html"><span class="doc">Route files</span></a></li> <li><a class="reference internal" href="../concepts/services.html"><span class="doc">Services</span></a></li> </ul> <p>This is configured in the file <strong>app/Config/Modules.php</strong>.</p> <p>The auto-discovery system works by scanning for particular directories and files within psr4 namespaces that have been defined in <strong>Config/Autoload.php</strong>.</p> <p>To make auto-discovery work for our <strong>Blog</strong> namespace, we need to make one small adjustment. <strong>Acme</strong> needs to be changed to <strong>Acme\Blog</strong> because each “module” within the namespace needs to be fully defined.</p> <pre data-language="php">public $psr4 = [
    APP_NAMESPACE =&gt; APPPATH, // For custom namespace
    'Config'      =&gt; APPPATH . 'Config',
    'Acme\Blog'   =&gt; ROOTPATH . 'acme/Blog', // Change
];
</pre> <p>Once your module folder path is defined, the discovery process would look for discoverable items on that path and should, for example, find the routes file at <strong>/acme/Blog/Config/Routes.php</strong>.</p>  <h3 id="enable-disable-discover">Enable/Disable Discover</h3> <p>You can turn on or off all auto-discovery in the system with the <strong>$enabled</strong> class variable. False will disable all discovery, optimizing performance, but negating the special capabilities of your modules.</p>   <h3 id="specify-discovery-items">Specify Discovery Items</h3> <p>With the <strong>$aliases</strong> option, you can specify which items are automatically discovered. If the item is not present, then no auto-discovery will happen for that item, but the others in the array will still be discovered.</p>   <h3 id="discovery-and-composer">Discovery and Composer</h3> <p>Packages that were installed via Composer will also be discovered by default. This only requires that the namespace that Composer knows about is a PSR4 namespace. PSR0 namespaces will not be detected.</p> <p>If you do not want all of Composer’s known directories to be scanned when locating files, you can turn this off by editing the <code>$discoverInComposer</code> variable in <code>Config\Modules.php</code>:</p> <pre data-language="php">public $discoverInComposer = false;
</pre>    <h2 id="working-with-files">Working With Files</h2> <p>This section will take a look at each of the file types (controllers, views, language files, etc) and how they can be used within the module. Some of this information is described in more detail in the relevant location of the user guide, but is being reproduced here so that it’s easier to grasp how all of the pieces fit together.</p>  <h3 id="routes">Routes</h3> <p>By default, <a class="reference internal" href="../incoming/routing.html"><span class="doc">routes</span></a> are automatically scanned for within modules. It can be turned off in the <strong>Modules</strong> config file, described above.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Since the files are being included into the current scope, the <code>$routes</code> instance is already defined for you. It will cause errors if you attempt to redefine that class.</p> </div>   <h3 id="filters">Filters</h3> <p>By default, <a class="reference internal" href="../incoming/filters.html"><span class="doc">filters</span></a> are automatically scanned for within modules. It can be turned off in the <strong>Modules</strong> config file, described above.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">Since the files are being included into the current scope, the <code>$filters</code> instance is already defined for you. It will cause errors if you attempt to redefine that class.</p> </div> <p>In the module’s <strong>Config/Filters.php</strong> file, you need to define the aliases of the filters you use.:</p> <pre data-language="php">$filters-&gt;aliases['menus'] = MenusFilter::class;
</pre>   <h3 id="controllers">Controllers</h3> <p>Controllers outside of the main <strong>app/Controllers</strong> directory cannot be automatically routed by URI detection, but must be specified within the Routes file itself:</p> <pre data-language="php">// Routes.php
$routes-&gt;get('blog', 'Acme\Blog\Controllers\Blog::index');
</pre> <p>To reduce the amount of typing needed here, the <strong>group</strong> routing feature is helpful:</p> <pre data-language="php">$routes-&gt;group('blog', ['namespace' =&gt; 'Acme\Blog\Controllers'], function ($routes) {
    $routes-&gt;get('/', 'Blog::index');
});
</pre>   <h3 id="config-files">Config Files</h3> <p>No special change is needed when working with configuration files. These are still namespaced classes and loaded with the <code>new</code> command:</p> <pre data-language="php">$config = new \Acme\Blog\Config\Blog();
</pre> <p>Config files are automatically discovered whenever using the <strong>config()</strong> function that is always available.</p>   <h3 id="migrations">Migrations</h3> <p>Migration files will be automatically discovered within defined namespaces. All migrations found across all namespaces will be run every time.</p>   <h3 id="seeds">Seeds</h3> <p>Seed files can be used from both the CLI and called from within other seed files as long as the full namespace is provided. If calling on the CLI, you will need to provide double backslashes:</p> <pre data-language="php">&gt; php public/index.php migrations seed Acme\\Blog\\Database\\Seeds\\TestPostSeeder
</pre>   <h3 id="helpers">Helpers</h3> <p>Helpers will be located automatically from defined namespaces when using the <code>helper()</code> method, as long as it is within the namespaces <strong>Helpers</strong> directory:</p> <pre data-language="php">helper('blog');
</pre>   <h3 id="language-files">Language Files</h3> <p>Language files are located automatically from defined namespaces when using the <code>lang()</code> method, as long as the file follows the same directory structures as the main application directory.</p>   <h3 id="libraries">Libraries</h3> <p>Libraries are always instantiated by their fully-qualified class name, so no special access is provided:</p> <pre data-language="php">$lib = new \Acme\Blog\Libraries\BlogLib();
</pre>   <h3 id="models">Models</h3> <p>Models are always instantiated by their fully-qualified class name, so no special access is provided:</p> <pre data-language="php">$model = new \Acme\Blog\Models\PostModel();
</pre>   <h3 id="views">Views</h3> <p>Views can be loaded using the class namespace as described in the <a class="reference internal" href="../outgoing/views.html"><span class="doc">views</span></a> documentation:</p> <pre data-language="php">echo view('Acme\Blog\Views\index');
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014&ndash;2020 British Columbia Institute of Technology<br>Licensed under the MIT License.<br>
    <a href="https://codeigniter.com/user_guide/general/modules.html" class="_attribution-link">https://codeigniter.com/user_guide/general/modules.html</a>
  </p>
</div>
