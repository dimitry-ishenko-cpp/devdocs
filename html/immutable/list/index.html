<h1>List</h1>
<div>
<p>Lists are ordered indexed dense collections, much like a JavaScript Array.</p> </div>
<pre data-language="ts">type List&lt;T&gt; extends Collection.Indexed&lt;T&gt;</pre>
<h4>Discussion</h4>
<div>
<p>Lists are immutable and fully persistent with O(log32 N) gets and sets, and O(1) push and pop.</p> <p>Lists implement Deque, with efficient addition and removal from both the end (<code><a href="index.html#push()">push</a></code>, <code><a href="index.html#pop()">pop</a></code>) and beginning (<code><a href="index.html#unshift()">unshift</a></code>, <code><a href="index.html#shift()">shift</a></code>).</p> <p>Unlike a JavaScript Array, there is no distinction between an "unset" index and an index set to <code>undefined</code>. <code><a href="index.html#forEach()">List#forEach</a></code> visits all indices from 0 to size, regardless of whether they were explicitly defined.</p> </div>
<h3>Construction</h3>
<div id="List()">
<h4><a href="index.html#List()">List()</a></h4>
<div>
<div>
<p>Create a new immutable List containing the values of the provided collection-like.</p> </div>
<pre data-language="ts">List&lt;T&gt;(collection?: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html">List</a></code> is a factory function and not a class, and does not use the <code>new</code> keyword during construction.</p>  <pre data-language="ts">const { List, Set } = require('immutable')

const emptyList = List()
// List []

const plainArray = [ 1, 2, 3, 4 ]
const listFromPlainArray = List(plainArray)
// List [ 1, 2, 3, 4 ]

const plainSet = Set([ 1, 2, 3, 4 ])
const listFromPlainSet = List(plainSet)
// List [ 1, 2, 3, 4 ]

const arrayIterator = plainArray[Symbol.iterator]()
const listFromCollectionArray = List(arrayIterator)
// List [ 1, 2, 3, 4 ]

listFromPlainArray.equals(listFromCollectionArray) // true
listFromPlainSet.equals(listFromCollectionArray) // true
listFromPlainSet.equals(listFromPlainArray) // truerun it</pre>
</div>
</div>
</div>
<h3>Static methods</h3>
<div id="isList()">
<h4><a href="index.html#isList()">List.isList()</a></h4>
<div><pre data-language="ts">List.isList(maybeList: unknown): boolean
</pre></div>
</div>
<div id="of()">
<h4><a href="index.html#of()">List.of()</a></h4>
<div><pre data-language="ts">List.of&lt;T&gt;(...values: Array&lt;T&gt;): List&lt;T&gt;
</pre></div>
</div>
<h3>Members</h3>
<div id="size">
<h4><a href="index.html#size">size</a></h4>
<div>
<div>
<p>The number of items in this List.</p> </div>
<pre data-language="ts">size: number</pre>
</div>
</div>
<h3>Persistent changes</h3>
<div id="set()">
<h4><a href="index.html#set()">set()</a></h4>
<div>
<div>
<p>Returns a new List which includes <code>value</code> at <code>index</code>. If <code>index</code> already exists in this List, it will be replaced.</p> </div>
<pre data-language="ts">set(index: number, value: T): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p><code>index</code> may be a negative number, which indexes back from the end of the List. <code>v.set(-1, "value")</code> sets the last item in the List.</p> <p>If <code>index</code> larger than <code><a href="index.html#size">size</a></code>, the returned List's <code><a href="index.html#size">size</a></code> will be large enough to include the <code>index</code>.</p>  <pre data-language="ts">const originalList = List([ 0 ]);
// List [ 0 ]
originalList.set(1, 1);
// List [ 0, 1 ]
originalList.set(0, 'overwritten');
// List [ "overwritten" ]
originalList.set(2, 2);
// List [ 0, undefined, 2 ]

List().set(50000, 'value').size;
// 50001run it</pre>
<p>Note: <code><a href="index.html#set()">set</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="delete()">
<h4><a href="index.html#delete()">delete()</a></h4>
<div>
<div>
<p>Returns a new List which excludes this <code>index</code> and with a size 1 less than this List. Values at indices above <code>index</code> are shifted down by 1 to fill the position.</p> </div>
<pre data-language="ts">delete(index: number): List&lt;T&gt;
</pre>
<h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<div>
<p>This is synonymous with <code>list.splice(index, 1)</code>.</p> <p><code>index</code> may be a negative number, which indexes back from the end of the List. <code>v.delete(-1)</code> deletes the last item in the List.</p> <p>Note: <code><a href="index.html#delete()">delete</a></code> cannot be safely used in IE8</p>  <pre data-language="ts">List([ 0, 1, 2, 3, 4 ]).delete(0);
// List [ 1, 2, 3, 4 ]run it</pre>
<p>Since <code><a href="index.html#delete()">delete()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="index.html#delete()">delete</a></code> <em>cannot</em> be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="insert()">
<h4><a href="index.html#insert()">insert()</a></h4>
<div>
<div>
<p>Returns a new List with <code>value</code> at <code>index</code> with a size 1 more than this List. Values at indices above <code>index</code> are shifted over by 1.</p> </div>
<pre data-language="ts">insert(index: number, value: T): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>This is synonymous with <code>list.splice(index, 0, value)</code>.</p>  <pre data-language="ts">List([ 0, 1, 2, 3, 4 ]).insert(6, 5)
// List [ 0, 1, 2, 3, 4, 5 ]run it</pre>
<p>Since <code><a href="index.html#insert()">insert()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="index.html#insert()">insert</a></code> <em>cannot</em> be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="clear()">
<h4><a href="index.html#clear()">clear()</a></h4>
<div>
<div>
<p>Returns a new List with 0 size and no values in constant time.</p> </div>
<pre data-language="ts">clear(): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">List([ 1, 2, 3, 4 ]).clear()
// List []run it</pre>
<p>Note: <code><a href="index.html#clear()">clear</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="push()">
<h4><a href="index.html#push()">push()</a></h4>
<div>
<div>
<p>Returns a new List with the provided <code>values</code> appended, starting at this List's <code><a href="index.html#size">size</a></code>.</p> </div>
<pre data-language="ts">push(...values: Array&lt;T&gt;): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">List([ 1, 2, 3, 4 ]).push(5)
// List [ 1, 2, 3, 4, 5 ]run it</pre>
<p>Note: <code><a href="index.html#push()">push</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="pop()">
<h4><a href="index.html#pop()">pop()</a></h4>
<div>
<div>
<p>Returns a new List with a size ones less than this List, excluding the last index in this List.</p> </div>
<pre data-language="ts">pop(): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>Note: this differs from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/pop" rel="noopener">Array#pop</a></code> because it returns a new List rather than the removed value. Use <code><a href="index.html#last()">last()</a></code> to get the last value in this List.</p> <pre data-language="ts">List([ 1, 2, 3, 4 ]).pop()
// List[ 1, 2, 3 ]</pre>
<p>Note: <code><a href="index.html#pop()">pop</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="unshift()">
<h4><a href="index.html#unshift()">unshift()</a></h4>
<div>
<div>
<p>Returns a new List with the provided <code>values</code> prepended, shifting other values ahead to higher indices.</p> </div>
<pre data-language="ts">unshift(...values: Array&lt;T&gt;): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">List([ 2, 3, 4]).unshift(1);
// List [ 1, 2, 3, 4 ]run it</pre>
<p>Note: <code><a href="index.html#unshift()">unshift</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="shift()">
<h4><a href="index.html#shift()">shift()</a></h4>
<div>
<div>
<p>Returns a new List with a size ones less than this List, excluding the first index in this List, shifting all other values to a lower index.</p> </div>
<pre data-language="ts">shift(): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>Note: this differs from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/shift" rel="noopener">Array#shift</a></code> because it returns a new List rather than the removed value. Use <code><a href="index.html#first()">first()</a></code> to get the first value in this List.</p>  <pre data-language="ts">List([ 0, 1, 2, 3, 4 ]).shift();
// List [ 1, 2, 3, 4 ]run it</pre>
<p>Note: <code><a href="index.html#shift()">shift</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="update()">
<h4><a href="index.html#update()">update()</a></h4>
<div>
<pre data-language="ts">update(index: number, notSetValue: T, updater: (value: T) =&gt; T): this
update(index: number, updater: (value: T | undefined) =&gt; T): this
update&lt;R&gt;(updater: (value: this) =&gt; R): R
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#update()">Collection#update()</a></code>
</div>
</div>
<div id="setSize()">
<h4><a href="index.html#setSize()">setSize()</a></h4>
<div>
<div>
<p>Returns a new List with size <code>size</code>. If <code>size</code> is less than this List's size, the new List will exclude values at the higher indices. If <code>size</code> is greater than this List's size, the new List will have undefined values for the newly available indices.</p> </div>
<pre data-language="ts">setSize(size: number): List&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>When building a new List and the final size is known up front, <code><a href="index.html#setSize()">setSize</a></code> used in conjunction with <code><a href="index.html#withMutations()">withMutations</a></code> may result in the more performant construction.</p> </div>
</div>
</div>
<h3>Deep persistent changes</h3>
<div id="setIn()">
<h4><a href="index.html#setIn()">setIn()</a></h4>
<div>
<div>
<p>Returns a new List having set <code>value</code> at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, a new immutable Map will be created at that key.</p> </div>
<pre data-language="ts">setIn(keyPath: Iterable&lt;unknown&gt;, value: unknown): this
</pre>
<h4>Discussion</h4>
<div>
<p>Index numbers are used as keys to determine the path to follow in the List.</p>  <pre data-language="ts">const { List } = require('immutable')
const list = List([ 0, 1, 2, List([ 3, 4 ])])
list.setIn([3, 0], 999);
// List [ 0, 1, 2, List [ 999, 4 ] ]run it</pre>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.</p>  <pre data-language="ts">const { List } = require('immutable')
const list = List([ 0, 1, 2, { plain: 'object' }])
list.setIn([3, 'plain'], 'value');
// List([ 0, 1, 2, { plain: 'value' }])run it</pre>
<p>Note: <code><a href="index.html#setIn()">setIn</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="deleteIn()">
<h4><a href="index.html#deleteIn()">deleteIn()</a></h4>
<div>
<div>
<p>Returns a new List having removed the value at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, no change will occur.</p> </div>
<pre data-language="ts">deleteIn(keyPath: Iterable&lt;unknown&gt;): this
</pre>
<h4>alias</h4>
<code>removeIn()</code><h4>Discussion</h4>
<div> <pre data-language="ts">const { List } = require('immutable')
const list = List([ 0, 1, 2, List([ 3, 4 ])])
list.deleteIn([3, 0]);
// List [ 0, 1, 2, List [ 4 ] ]run it</pre>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and removeIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.</p>  <pre data-language="ts">const { List } = require('immutable')
const list = List([ 0, 1, 2, { plain: 'object' }])
list.removeIn([3, 'plain']);
// List([ 0, 1, 2, {}])run it</pre>
<p>Note: <code><a href="index.html#deleteIn()">deleteIn</a></code> <em>cannot</em> be safely used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="updateIn()">
<h4><a href="index.html#updateIn()">updateIn()</a></h4>
<div><pre data-language="ts">updateIn(keyPath: Iterable&lt;unknown&gt;,notSetValue: unknown,updater: (value: unknown) =&gt; unknown): this
updateIn(keyPath: Iterable&lt;unknown&gt;, updater: (value: unknown) =&gt; unknown): this
</pre></div>
</div>
<div id="mergeIn()">
<h4><a href="index.html#mergeIn()">mergeIn()</a></h4>
<div>
<div>
<p>Note: <code><a href="index.html#mergeIn()">mergeIn</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
<pre data-language="ts">mergeIn(keyPath: Iterable&lt;unknown&gt;, ...collections: Array&lt;unknown&gt;): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#mergeIn()">Map#mergeIn</a></code></p> </div>
</div>
</div>
<div id="mergeDeepIn()">
<h4><a href="index.html#mergeDeepIn()">mergeDeepIn()</a></h4>
<div>
<div>
<p>Note: <code><a href="index.html#mergeDeepIn()">mergeDeepIn</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
<pre data-language="ts">mergeDeepIn(keyPath: Iterable&lt;unknown&gt;, ...collections: Array&lt;unknown&gt;): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#mergeDeepIn()">Map#mergeDeepIn</a></code></p> </div>
</div>
</div>
<h3>Transient changes</h3>
<div id="withMutations()">
<h4><a href="index.html#withMutations()">withMutations()</a></h4>
<div>
<div>
<p>Note: Not all methods can be safely used on a mutable collection or within <code><a href="index.html#withMutations()">withMutations</a></code>! Check the documentation for each method to see if it allows being used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
<pre data-language="ts">withMutations(mutator: (mutable: this) =&gt; unknown): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#withMutations()">Map#withMutations</a></code></p> </div>
</div>
</div>
<div id="asMutable()">
<h4><a href="index.html#asMutable()">asMutable()</a></h4>
<div>
<div>
<p>An alternative API for withMutations()</p> </div>
<pre data-language="ts">asMutable(): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#asMutable()">Map#asMutable</a></code></p> </div>
<h4>Discussion</h4>
<div>
<p>Note: Not all methods can be safely used on a mutable collection or within <code><a href="index.html#withMutations()">withMutations</a></code>! Check the documentation for each method to see if it allows being used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="wasAltered()">
<h4><a href="index.html#wasAltered()">wasAltered()</a></h4>
<div>

<pre data-language="ts">wasAltered(): boolean
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#wasAltered()">Map#wasAltered</a></code></p> </div>
</div>
</div>
<div id="asImmutable()">
<h4><a href="index.html#asImmutable()">asImmutable()</a></h4>
<div>

<pre data-language="ts">asImmutable(): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#asImmutable()">Map#asImmutable</a></code></p> </div>
</div>
</div>
<h3>Sequence algorithms</h3>
<div id="concat()">
<h4><a href="index.html#concat()">concat()</a></h4>
<div>
<div>
<p>Returns a new List with other values or collections concatenated to this one.</p> </div>
<pre data-language="ts">concat&lt;C&gt;(...valuesOrCollections: Array&lt;Iterable&lt;C&gt; | C&gt;): List&lt;T | C&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#concat()">Collection.Indexed#concat()</a></code><h4>alias</h4>
<code>merge()</code><h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#concat()">concat</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="map()">
<h4><a href="index.html#map()">map()</a></h4>
<div>
<div>
<p>Returns a new List with values passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">map&lt;M&gt;(mapper: (value: T, key: number, iter: this) =&gt; M,context?: unknown): List&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#map()">Collection.Indexed#map()</a></code><h4>Discussion</h4>
<div> <pre data-language="ts">List([ 1, 2 ]).map(x =&gt; 10 * x)
// List [ 10, 20 ]run it</pre>
</div>
</div>
</div>
<div id="flatMap()">
<h4><a href="index.html#flatMap()">flatMap()</a></h4>
<div>
<div>
<p>Flat-maps the List, returning a new List.</p> </div>
<pre data-language="ts">flatMap&lt;M&gt;(mapper: (value: T, key: number, iter: this) =&gt; Iterable&lt;M&gt;,context?: unknown): List&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#flatMap()">Collection.Indexed#flatMap()</a></code><h4>Discussion</h4>
<div>
<p>Similar to <code>list.map(...).flatten(true)</code>.</p> </div>
</div>
</div>
<div id="filter()">
<h4><a href="index.html#filter()">filter()</a></h4>
<div>
<pre data-language="ts">filter&lt;F&gt;(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): List&lt;F&gt;
filter(predicate: (value: T, index: number, iter: this) =&gt; unknown,context?: unknown): this
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#filter()">Collection.Indexed#filter()</a></code>
</div>
</div>
<div id="partition()">
<h4><a href="index.html#partition()">partition()</a></h4>
<div>
<pre data-language="ts">partition&lt;F, C&gt;(predicate: (this: C, value: T, index: number, iter: this) =&gt; boolean,context?: C): [List&lt;T&gt;, List&lt;F&gt;]
partition&lt;C&gt;(predicate: (this: C, value: T, index: number, iter: this) =&gt; unknown,context?: C): [this, this]
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#partition()">Collection.Indexed#partition()</a></code>
</div>
</div>
<div id="zip()">
<h4><a href="index.html#zip()">zip()</a></h4>
<div>
<pre data-language="ts">zip&lt;U&gt;(other: Collection&lt;unknown, U&gt;): List&lt;[T, U]&gt;
zip&lt;U, V&gt;(other: Collection&lt;unknown, U&gt;,other2: Collection&lt;unknown, V&gt;): List&lt;[T, U, V]&gt;
zip(...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): List&lt;unknown&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zip()">Collection.Indexed#zip()</a></code>
</div>
</div>
<div id="zipAll()">
<h4><a href="index.html#zipAll()">zipAll()</a></h4>
<div>
<pre data-language="ts">zipAll&lt;U&gt;(other: Collection&lt;unknown, U&gt;): List&lt;[T, U]&gt;
zipAll&lt;U, V&gt;(other: Collection&lt;unknown, U&gt;,other2: Collection&lt;unknown, V&gt;): List&lt;[T, U, V]&gt;
zipAll(...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): List&lt;unknown&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zipAll()">Collection.Indexed#zipAll()</a></code>
</div>
</div>
<div id="zipWith()">
<h4><a href="index.html#zipWith()">zipWith()</a></h4>
<div>
<pre data-language="ts">zipWith&lt;U, Z&gt;(zipper: (value: T, otherValue: U) =&gt; Z,otherCollection: Collection&lt;unknown, U&gt;): List&lt;Z&gt;
zipWith&lt;U, V, Z&gt;(zipper: (value: T, otherValue: U, thirdValue: V) =&gt; Z,otherCollection: Collection&lt;unknown, U&gt;,thirdCollection: Collection&lt;unknown, V&gt;): List&lt;Z&gt;
zipWith&lt;Z&gt;(zipper: (...values: Array&lt;unknown&gt;) =&gt; Z,...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): List&lt;Z&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zipWith()">Collection.Indexed#zipWith()</a></code>
</div>
</div>
<div id="[Symbol.iterator]()">
<h4><a href="index.html#%5BSymbol.iterator%5D()">[Symbol.iterator]()</a></h4>
<div>
<pre data-language="ts">[Symbol.iterator](): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#%5BSymbol.iterator%5D()">Collection.Indexed#[Symbol.iterator]()</a></code>
</div>
</div>
<div id="filterNot()">
<h4><a href="index.html#filterNot()">filterNot()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type with only the entries for which the <code>predicate</code> function returns false.</p> </div>
<pre data-language="ts">filterNot(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#filterNot()">Collection#filterNot()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x =&gt; x % 2 === 0)
// Map { "a": 1, "c": 3 }run it</pre></p>
<p>Note: <code><a href="index.html#filterNot()">filterNot()</a></code> always returns a new instance, even if it results in not filtering out any values.</p> </div>
</div>
</div>
<div id="reverse()">
<h4><a href="index.html#reverse()">reverse()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type in reverse order.</p> </div>
<pre data-language="ts">reverse(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reverse()">Collection#reverse()</a></code>
</div>
</div>
<div id="sort()">
<h4><a href="index.html#sort()">sort()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> </div>
<pre data-language="ts">sort(comparator?: (valueA: T, valueB: T) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sort()">Collection#sort()</a></code><h4>Discussion</h4>
<div>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p>  <pre data-language="ts">const { Map } = require('immutable')
Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) =&gt; {
  if (a &lt; b) { return -1; }
  if (a &gt; b) { return 1; }
  if (a === b) { return 0; }
});
// OrderedMap { "a": 1, "b": 2, "c": 3 }run it</pre>
<p>Note: <code><a href="index.html#sort()">sort()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="sortBy()">
<h4><a href="index.html#sortBy()">sortBy()</a></h4>
<div>
<div>
<p>Like <code><a href="index.html#sort()">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> </div>
<pre data-language="ts">sortBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sortBy()">Collection#sortBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const beattles = Map({
  John: { name: "Lennon" },
  Paul: { name: "McCartney" },
  George: { name: "Harrison" },
  Ringo: { name: "Starr" },
});
beattles.sortBy(member =&gt; member.name);run it</pre></p>
<p>Note: <code><a href="index.html#sortBy()">sortBy()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="groupBy()">
<h4><a href="index.html#groupBy()">groupBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../collection.keyed/index.html">Collection.Keyed</a></code> of <code>Collection.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">groupBy&lt;G&gt;(grouper: (value: T, key: number, iter: this) =&gt; G,context?: unknown): Seq.Keyed&lt;G, Collection&lt;number, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#groupBy()">Collection#groupBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is always an eager operation.</p>  <pre data-language="ts">const { List, Map } = require('immutable')
const listOfMaps = List([
  Map({ v: 0 }),
  Map({ v: 1 }),
  Map({ v: 1 }),
  Map({ v: 0 }),
  Map({ v: 2 })
])
const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))
// Map {
//   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
//   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
//   2: List [ Map{ "v": 2 } ],
// }run it</pre>
</div>
</div>
</div>
<h3>Conversion to JavaScript types</h3>
<div id="toJS()">
<h4><a href="index.html#toJS()">toJS()</a></h4>
<div>
<div>
<p>Deeply converts this Indexed collection to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJS(): Array&lt;DeepCopy&lt;T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#toJS()">Collection.Indexed#toJS()</a></code>
</div>
</div>
<div id="toJSON()">
<h4><a href="index.html#toJSON()">toJSON()</a></h4>
<div>
<div>
<p>Shallowly converts this Indexed collection to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJSON(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#toJSON()">Collection.Indexed#toJSON()</a></code>
</div>
</div>
<div id="toArray()">
<h4><a href="index.html#toArray()">toArray()</a></h4>
<div>
<div>
<p>Shallowly converts this collection to an Array.</p> </div>
<pre data-language="ts">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#toArray()">Collection.Indexed#toArray()</a></code>
</div>
</div>
<div id="toObject()">
<h4><a href="index.html#toObject()">toObject()</a></h4>
<div>
<div>
<p>Shallowly converts this Collection to an Object.</p> </div>
<pre data-language="ts">toObject(): {[key: string]: T}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toObject()">Collection#toObject()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<h3>Reading values</h3>
<div id="get()">
<h4><a href="index.html#get()">get()</a></h4>
<div>
<pre data-language="ts">get&lt;NSV&gt;(index: number, notSetValue: NSV): T | NSV
get(index: number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#get()">Collection.Indexed#get()</a></code>
</div>
</div>
<div id="has()">
<h4><a href="index.html#has()">has()</a></h4>
<div>
<div>
<p>True if a key exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">has(key: number): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#has()">Collection#has()</a></code>
</div>
</div>
<div id="includes()">
<h4><a href="index.html#includes()">includes()</a></h4>
<div>
<div>
<p>True if a value exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#includes()">Collection#includes()</a></code><h4>alias</h4>
<code>contains()</code>
</div>
</div>
<div id="first()">
<h4><a href="index.html#first()">first()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the first element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">first&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#first()">Collection#first()</a></code>
</div>
</div>
<div id="last()">
<h4><a href="index.html#last()">last()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the last element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">last&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#last()">Collection#last()</a></code>
</div>
</div>
<h3>Conversion to Seq</h3>
<div id="toSeq()">
<h4><a href="index.html#toSeq()">toSeq()</a></h4>
<div>
<div>
<p>Returns Seq.Indexed.</p> </div>
<pre data-language="ts">toSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#toSeq()">Collection.Indexed#toSeq()</a></code>
</div>
</div>
<div id="fromEntrySeq()">
<h4><a href="index.html#fromEntrySeq()">fromEntrySeq()</a></h4>
<div>
<div>
<p>If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries.</p> </div>
<pre data-language="ts">fromEntrySeq(): Seq.Keyed&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#fromEntrySeq()">Collection.Indexed#fromEntrySeq()</a></code>
</div>
</div>
<div id="toKeyedSeq()">
<h4><a href="index.html#toKeyedSeq()">toKeyedSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Keyed from this Collection where indices are treated as keys.</p> </div>
<pre data-language="ts">toKeyedSeq(): Seq.Keyed&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toKeyedSeq()">Collection#toKeyedSeq()</a></code><h4>Discussion</h4>
<div>
<p>This is useful if you want to operate on an Collection.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Collection.</p>  <pre data-language="ts">const { Seq } = require('immutable')
const indexedSeq = Seq([ 'A', 'B', 'C' ])
// Seq [ "A", "B", "C" ]
indexedSeq.filter(v =&gt; v === 'B')
// Seq [ "B" ]
const keyedSeq = indexedSeq.toKeyedSeq()
// Seq { 0: "A", 1: "B", 2: "C" }
keyedSeq.filter(v =&gt; v === 'B')
// Seq { 1: "B" }run it</pre>
</div>
</div>
</div>
<div id="toIndexedSeq()">
<h4><a href="index.html#toIndexedSeq()">toIndexedSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toIndexedSeq()">Collection#toIndexedSeq()</a></code>
</div>
</div>
<div id="toSetSeq()">
<h4><a href="index.html#toSetSeq()">toSetSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Set of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSetSeq()">Collection#toSetSeq()</a></code>
</div>
</div>
<h3>Combination</h3>
<div id="interpose()">
<h4><a href="index.html#interpose()">interpose()</a></h4>
<div>
<div>
<p>Returns a Collection of the same type with <code>separator</code> between each item in this Collection.</p> </div>
<pre data-language="ts">interpose(separator: T): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#interpose()">Collection.Indexed#interpose()</a></code>
</div>
</div>
<div id="interleave()">
<h4><a href="index.html#interleave()">interleave()</a></h4>
<div>
<div>
<p>Returns a Collection of the same type with the provided <code>collections</code> interleaved into this collection.</p> </div>
<pre data-language="ts">interleave(...collections: Array&lt;Collection&lt;unknown, T&gt;&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#interleave()">Collection.Indexed#interleave()</a></code><h4>Discussion</h4>
<div>
<p>The resulting Collection includes the first item from each, then the second from each, etc.</p>  <pre data-language="ts">const { List } = require('immutable')
List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
// List [ 1, "A", 2, "B", 3, "C" ]run it</pre>
<p>The shortest Collection stops interleave.</p>  <pre data-language="ts">List([ 1, 2, 3 ]).interleave(
  List([ 'A', 'B' ]),
  List([ 'X', 'Y', 'Z' ])
)
// List [ 1, "A", "X", 2, "B", "Y" ]run it</pre>
<p>Since <code><a href="index.html#interleave()">interleave()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="index.html#interleave()">interleave</a></code> <em>cannot</em> be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="splice()">
<h4><a href="index.html#splice()">splice()</a></h4>
<div>
<div>
<p>Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.</p> </div>
<pre data-language="ts">splice(index: number, removeNum: number, ...values: Array&lt;T&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#splice()">Collection.Indexed#splice()</a></code><h4>Discussion</h4>
<div>
<p><code>index</code> may be a negative number, which indexes back from the end of the Collection. <code>s.splice(-2)</code> splices after the second to last item.</p>  <pre data-language="ts">const { List } = require('immutable')
List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
// List [ "a", "q", "r", "s", "d" ]run it</pre>
<p>Since <code><a href="index.html#splice()">splice()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="index.html#splice()">splice</a></code> <em>cannot</em> be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="flatten()">
<h4><a href="index.html#flatten()">flatten()</a></h4>
<div>
<pre data-language="ts">flatten(depth?: number): Collection&lt;unknown, unknown&gt;
flatten(shallow?: boolean): Collection&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#flatten()">Collection#flatten()</a></code>
</div>
</div>
<h3>Search for value</h3>
<div id="indexOf()">
<h4><a href="index.html#indexOf()">indexOf()</a></h4>
<div>
<div>
<p>Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.</p> </div>
<pre data-language="ts">indexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#indexOf()">Collection.Indexed#indexOf()</a></code>
</div>
</div>
<div id="lastIndexOf()">
<h4><a href="index.html#lastIndexOf()">lastIndexOf()</a></h4>
<div>
<div>
<p>Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.</p> </div>
<pre data-language="ts">lastIndexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#lastIndexOf()">Collection.Indexed#lastIndexOf()</a></code>
</div>
</div>
<div id="findIndex()">
<h4><a href="index.html#findIndex()">findIndex()</a></h4>
<div>
<div>
<p>Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> </div>
<pre data-language="ts">findIndex(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#findIndex()">Collection.Indexed#findIndex()</a></code>
</div>
</div>
<div id="findLastIndex()">
<h4><a href="index.html#findLastIndex()">findLastIndex()</a></h4>
<div>
<div>
<p>Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> </div>
<pre data-language="ts">findLastIndex(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#findLastIndex()">Collection.Indexed#findLastIndex()</a></code>
</div>
</div>
<div id="find()">
<h4><a href="index.html#find()">find()</a></h4>
<div>
<div>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">find(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#find()">Collection#find()</a></code>
</div>
</div>
<div id="findLast()">
<h4><a href="index.html#findLast()">findLast()</a></h4>
<div>
<div>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLast(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLast()">Collection#findLast()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findEntry()">
<h4><a href="index.html#findEntry()">findEntry()</a></h4>
<div>
<div>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findEntry(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findEntry()">Collection#findEntry()</a></code>
</div>
</div>
<div id="findLastEntry()">
<h4><a href="index.html#findLastEntry()">findLastEntry()</a></h4>
<div>
<div>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastEntry(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastEntry()">Collection#findLastEntry()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findKey()">
<h4><a href="index.html#findKey()">findKey()</a></h4>
<div>
<div>
<p>Returns the key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findKey(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findKey()">Collection#findKey()</a></code>
</div>
</div>
<div id="findLastKey()">
<h4><a href="index.html#findLastKey()">findLastKey()</a></h4>
<div>
<div>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastKey(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastKey()">Collection#findLastKey()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="keyOf()">
<h4><a href="index.html#keyOf()">keyOf()</a></h4>
<div>
<div>
<p>Returns the key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">keyOf(searchValue: T): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keyOf()">Collection#keyOf()</a></code>
</div>
</div>
<div id="lastKeyOf()">
<h4><a href="index.html#lastKeyOf()">lastKeyOf()</a></h4>
<div>
<div>
<p>Returns the last key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">lastKeyOf(searchValue: T): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#lastKeyOf()">Collection#lastKeyOf()</a></code>
</div>
</div>
<div id="max()">
<h4><a href="index.html#max()">max()</a></h4>
<div>
<div>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">max(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#max()">Collection#max()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="index.html#max()">max</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="maxBy()">
<h4><a href="index.html#maxBy()">maxBy()</a></h4>
<div>
<div>
<p>Like <code><a href="index.html#max()">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">maxBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#maxBy()">Collection#maxBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.maxBy(i =&gt; i.avgHit); // will output { name: 'Max', avgHit: 3 }run it</pre></p> </div>
</div>
</div>
<div id="min()">
<h4><a href="index.html#min()">min()</a></h4>
<div>
<div>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">min(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#min()">Collection#min()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="index.html#min()">min</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="minBy()">
<h4><a href="index.html#minBy()">minBy()</a></h4>
<div>
<div>
<p>Like <code><a href="index.html#min()">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">minBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#minBy()">Collection#minBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.minBy(i =&gt; i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it</pre></p> </div>
</div>
</div>
<h3>Value equality</h3>
<div id="equals()">
<h4><a href="index.html#equals()">equals()</a></h4>
<div>
<div>
<p>True if this and the other Collection have value equality, as defined by <code><a href="../is()/index.html">Immutable.is()</a></code>.</p> </div>
<pre data-language="ts">equals(other: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#equals()">Collection#equals()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="hashCode()">
<h4><a href="index.html#hashCode()">hashCode()</a></h4>
<div>
<div>
<p>Computes and returns the hashed identity for this Collection.</p> </div>
<pre data-language="ts">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hashCode()">Collection#hashCode()</a></code><h4>Discussion</h4>
<div>
<p>The <code><a href="index.html#hashCode()">hashCode</a></code> of a Collection is used to determine potential equality, and is used when adding this to a <code><a href="../set/index.html">Set</a></code> or as a key in a <code><a href="../map/index.html">Map</a></code>, enabling lookup via a different instance.</p>  <pre data-language="ts">const a = List([ 1, 2, 3 ]);
const b = List([ 1, 2, 3 ]);
assert.notStrictEqual(a, b); // different instances
const set = Set([ a ]);
assert.equal(set.has(b), true);run it</pre>
<p>If two values have the same <code><a href="index.html#hashCode()">hashCode</a></code>, they are <a href="https://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code><a href="index.html#hashCode()">hashCode</a></code>s, they must not be equal.</p> </div>
</div>
</div>
<h3>Reading deep values</h3>
<div id="getIn()">
<h4><a href="index.html#getIn()">getIn()</a></h4>
<div>
<div>
<p>Returns the value found by following a path of keys or indices through nested Collections.</p> </div>
<pre data-language="ts">getIn(searchKeyPath: Iterable&lt;unknown&gt;, notSetValue?: unknown): unknown
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#getIn()">Collection#getIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:</p>  <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: [ { y: 123 } ] });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p> </div>
</div>
</div>
<div id="hasIn()">
<h4><a href="index.html#hasIn()">hasIn()</a></h4>
<div>
<div>
<p>True if the result of following a path of keys or indices through nested Collections results in a set value.</p> </div>
<pre data-language="ts">hasIn(searchKeyPath: Iterable&lt;unknown&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hasIn()">Collection#hasIn()</a></code>
</div>
</div>
<h3>Conversion to Collections</h3>
<div id="toMap()">
<h4><a href="index.html#toMap()">toMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, Throws if keys are not hashable.</p> </div>
<pre data-language="ts">toMap(): Map&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toMap()">Collection#toMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedMap()">
<h4><a href="index.html#toOrderedMap()">toOrderedMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, maintaining the order of iteration.</p> </div>
<pre data-language="ts">toOrderedMap(): OrderedMap&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedMap()">Collection#toOrderedMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toSet()">
<h4><a href="index.html#toSet()">toSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSet()">Collection#toSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../set/index.html">Set(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedSet()">
<h4><a href="index.html#toOrderedSet()">toOrderedSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, maintaining the order of iteration and discarding keys.</p> </div>
<pre data-language="ts">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedSet()">Collection#toOrderedSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toList()">
<h4><a href="index.html#toList()">toList()</a></h4>
<div>
<div>
<p>Converts this Collection to a List, discarding keys.</p> </div>
<pre data-language="ts">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toList()">Collection#toList()</a></code><h4>Discussion</h4>
<div>
<p>This is similar to <code><a href="index.html">List(collection)</a></code>, but provided to allow for chained expressions. However, when called on <code><a href="../map/index.html">Map</a></code> or other keyed collections, <code>collection.toList()</code> discards the keys and creates a list of only the values, whereas <code><a href="index.html">List(collection)</a></code> creates a list of entry tuples.</p>  <pre data-language="ts">const { Map, List } = require('immutable')
var myMap = Map({ a: 'Apple', b: 'Banana' })
List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
myMap.toList() // List [ "Apple", "Banana" ]run it</pre>
</div>
</div>
</div>
<div id="toStack()">
<h4><a href="index.html#toStack()">toStack()</a></h4>
<div>
<div>
<p>Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toStack()">Collection#toStack()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../stack/index.html">Stack(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<h3>Iterators</h3>
<div id="keys()">
<h4><a href="index.html#keys()">keys()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s keys.</p> </div>
<pre data-language="ts">keys(): IterableIterator&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keys()">Collection#keys()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="index.html#keySeq()">keySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="values()">
<h4><a href="index.html#values()">values()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s values.</p> </div>
<pre data-language="ts">values(): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#values()">Collection#values()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="index.html#valueSeq()">valueSeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="entries()">
<h4><a href="index.html#entries()">entries()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s entries as <code>[ key, value ]</code> tuples.</p> </div>
<pre data-language="ts">entries(): IterableIterator&lt;[number, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entries()">Collection#entries()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="index.html#entrySeq()">entrySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<h3>Collections (Seq)</h3>
<div id="keySeq()">
<h4><a href="index.html#keySeq()">keySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of the keys of this Collection, discarding values.</p> </div>
<pre data-language="ts">keySeq(): Seq.Indexed&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keySeq()">Collection#keySeq()</a></code>
</div>
</div>
<div id="valueSeq()">
<h4><a href="index.html#valueSeq()">valueSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#valueSeq()">Collection#valueSeq()</a></code>
</div>
</div>
<div id="entrySeq()">
<h4><a href="index.html#entrySeq()">entrySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> </div>
<pre data-language="ts">entrySeq(): Seq.Indexed&lt;[number, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entrySeq()">Collection#entrySeq()</a></code>
</div>
</div>
<h3>Side effects</h3>
<div id="forEach()">
<h4><a href="index.html#forEach()">forEach()</a></h4>
<div>
<div>
<p>The <code>sideEffect</code> is executed for every entry in the Collection.</p> </div>
<pre data-language="ts">forEach(sideEffect: (value: T, key: number, iter: this) =&gt; unknown,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#forEach()">Collection#forEach()</a></code><h4>Discussion</h4>
<div>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> </div>
</div>
</div>
<h3>Creating subsets</h3>
<div id="slice()">
<h4><a href="index.html#slice()">slice()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.</p> </div>
<pre data-language="ts">slice(begin?: number, end?: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#slice()">Collection#slice()</a></code><h4>Discussion</h4>
<div>
<p>If begin is negative, it is offset from the end of the Collection. e.g. <code>slice(-2)</code> returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.</p> <p>If end is negative, it is offset from the end of the Collection. e.g. <code>slice(0, -1)</code> returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.</p> <p>If the requested slice is equivalent to the current Collection, then it will return itself.</p> </div>
</div>
</div>
<div id="rest()">
<h4><a href="index.html#rest()">rest()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the first.</p> </div>
<pre data-language="ts">rest(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#rest()">Collection#rest()</a></code>
</div>
</div>
<div id="butLast()">
<h4><a href="index.html#butLast()">butLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the last.</p> </div>
<pre data-language="ts">butLast(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#butLast()">Collection#butLast()</a></code>
</div>
</div>
<div id="skip()">
<h4><a href="index.html#skip()">skip()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skip(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skip()">Collection#skip()</a></code>
</div>
</div>
<div id="skipLast()">
<h4><a href="index.html#skipLast()">skipLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skipLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipLast()">Collection#skipLast()</a></code>
</div>
</div>
<div id="skipWhile()">
<h4><a href="index.html#skipWhile()">skipWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> </div>
<pre data-language="ts">skipWhile(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipWhile()">Collection#skipWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipWhile(x =&gt; x.match(/g/))
// List [ "cat", "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="skipUntil()">
<h4><a href="index.html#skipUntil()">skipUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> </div>
<pre data-language="ts">skipUntil(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipUntil()">Collection#skipUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipUntil(x =&gt; x.match(/hat/))
// List [ "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="take()">
<h4><a href="index.html#take()">take()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">take(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#take()">Collection#take()</a></code>
</div>
</div>
<div id="takeLast()">
<h4><a href="index.html#takeLast()">takeLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">takeLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeLast()">Collection#takeLast()</a></code>
</div>
</div>
<div id="takeWhile()">
<h4><a href="index.html#takeWhile()">takeWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">takeWhile(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeWhile()">Collection#takeWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeWhile(x =&gt; x.match(/o/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<div id="takeUntil()">
<h4><a href="index.html#takeUntil()">takeUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns false.</p> </div>
<pre data-language="ts">takeUntil(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeUntil()">Collection#takeUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeUntil(x =&gt; x.match(/at/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<h3>Reducing a value</h3>
<div id="reduce()">
<h4><a href="index.html#reduce()">reduce()</a></h4>
<div>
<pre data-language="ts">reduce&lt;R&gt;(reducer: (reduction: R, value: T, key: number, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduce&lt;R&gt;(reducer: (reduction: T | R, value: T, key: number, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduce()">Collection#reduce()</a></code>
</div>
</div>
<div id="reduceRight()">
<h4><a href="index.html#reduceRight()">reduceRight()</a></h4>
<div>
<pre data-language="ts">reduceRight&lt;R&gt;(reducer: (reduction: R, value: T, key: number, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduceRight&lt;R&gt;(reducer: (reduction: T | R, value: T, key: number, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduceRight()">Collection#reduceRight()</a></code>
</div>
</div>
<div id="every()">
<h4><a href="index.html#every()">every()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for all entries in the Collection.</p> </div>
<pre data-language="ts">every(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#every()">Collection#every()</a></code>
</div>
</div>
<div id="some()">
<h4><a href="index.html#some()">some()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for any entry in the Collection.</p> </div>
<pre data-language="ts">some(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#some()">Collection#some()</a></code>
</div>
</div>
<div id="join()">
<h4><a href="index.html#join()">join()</a></h4>
<div>
<div>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> </div>
<pre data-language="ts">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#join()">Collection#join()</a></code>
</div>
</div>
<div id="isEmpty()">
<h4><a href="index.html#isEmpty()">isEmpty()</a></h4>
<div>
<div>
<p>Returns true if this Collection includes no values.</p> </div>
<pre data-language="ts">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isEmpty()">Collection#isEmpty()</a></code><h4>Discussion</h4>
<div>
<p>For some lazy <code><a href="../seq/index.html">Seq</a></code>, <code><a href="index.html#isEmpty()">isEmpty</a></code> might need to iterate to determine emptiness. At most one iteration will occur.</p> </div>
</div>
</div>
<div id="count()">
<h4><a href="index.html#count()">count()</a></h4>
<div>
<pre data-language="ts">count(): number
count(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#count()">Collection#count()</a></code>
</div>
</div>
<div id="countBy()">
<h4><a href="index.html#countBy()">countBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../seq.keyed/index.html">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">countBy&lt;G&gt;(grouper: (value: T, key: number, iter: this) =&gt; G,context?: unknown): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#countBy()">Collection#countBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is not a lazy operation.</p> </div>
</div>
</div>
<h3>Comparison</h3>
<div id="isSubset()">
<h4><a href="index.html#isSubset()">isSubset()</a></h4>
<div>
<div>
<p>True if <code>iter</code> includes every value in this Collection.</p> </div>
<pre data-language="ts">isSubset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSubset()">Collection#isSubset()</a></code>
</div>
</div>
<div id="isSuperset()">
<h4><a href="index.html#isSuperset()">isSuperset()</a></h4>
<div>
<div>
<p>True if this Collection includes every value in <code>iter</code>.</p> </div>
<pre data-language="ts">isSuperset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSuperset()">Collection#isSuperset()</a></code>
</div>
</div>This documentation is generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts" rel="noopener">immutable.d.ts</a>. Pull requests and <a href="https://github.com/immutable-js/immutable-js/issues" rel="noopener">Issues</a> welcome.<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014–present, Lee Byron and other contributors<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://immutable-js.com/docs/v4.2.1/List/" class="_attribution-link">https://immutable-js.com/docs/v4.2.1/List/</a>
  </p>
</div>
