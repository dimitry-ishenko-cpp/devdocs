<h1>Collection.Keyed</h1>
<div>
<p>Keyed Collections have discrete keys tied to each value.</p> </div>
<pre data-language="ts">type Collection.Keyed&lt;K, V&gt; extends Collection&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<div>
<p>When iterating <code><a href="index.html">Collection.Keyed</a></code>, each iteration will yield a <code>[K, V]</code> tuple, in other words, <code><a href="../collection/index.html#entries()">Collection#entries</a></code> is the default iterator for Keyed Collections.</p> </div>
<h3>Construction</h3>
<div id="Collection.Keyed()">
<h4><a href="index.html#Collection.Keyed()">Collection.Keyed()</a></h4>
<div><pre data-language="ts">Collection.Keyed&lt;K, V&gt;(collection?: Iterable&lt;[K, V]&gt;): Collection.Keyed&lt;K, V&gt;
Collection.Keyed&lt;V&gt;(obj: {[key: string]: V}): Collection.Keyed&lt;string, V&gt;
</pre></div>
</div>
<h3>Conversion to JavaScript types</h3>
<div id="toJS()">
<h4><a href="index.html#toJS()">toJS()</a></h4>
<div>
<div>
<p>Deeply converts this Keyed collection to equivalent native JavaScript Object.</p> </div>
<pre data-language="ts">toJS(): {[key: string]: DeepCopy&lt;V&gt;}
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toJS()">Collection#toJS()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<div id="toJSON()">
<h4><a href="index.html#toJSON()">toJSON()</a></h4>
<div>
<div>
<p>Shallowly converts this Keyed collection to equivalent native JavaScript Object.</p> </div>
<pre data-language="ts">toJSON(): {[key: string]: V}
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toJSON()">Collection#toJSON()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<div id="toArray()">
<h4><a href="index.html#toArray()">toArray()</a></h4>
<div>
<div>
<p>Shallowly converts this collection to an Array.</p> </div>
<pre data-language="ts">toArray(): Array&lt;[K, V]&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toArray()">Collection#toArray()</a></code>
</div>
</div>
<div id="toObject()">
<h4><a href="index.html#toObject()">toObject()</a></h4>
<div>
<div>
<p>Shallowly converts this Collection to an Object.</p> </div>
<pre data-language="ts">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toObject()">Collection#toObject()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<h3>Conversion to Seq</h3>
<div id="toSeq()">
<h4><a href="index.html#toSeq()">toSeq()</a></h4>
<div>
<div>
<p>Returns Seq.Keyed.</p> </div>
<pre data-language="ts">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toSeq()">Collection#toSeq()</a></code>
</div>
</div>
<div id="toKeyedSeq()">
<h4><a href="index.html#toKeyedSeq()">toKeyedSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Keyed from this Collection where indices are treated as keys.</p> </div>
<pre data-language="ts">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toKeyedSeq()">Collection#toKeyedSeq()</a></code><h4>Discussion</h4>
<div>
<p>This is useful if you want to operate on an Collection.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Collection.</p>  <pre data-language="ts">const { Seq } = require('immutable')
const indexedSeq = Seq([ 'A', 'B', 'C' ])
// Seq [ "A", "B", "C" ]
indexedSeq.filter(v =&gt; v === 'B')
// Seq [ "B" ]
const keyedSeq = indexedSeq.toKeyedSeq()
// Seq { 0: "A", 1: "B", 2: "C" }
keyedSeq.filter(v =&gt; v === 'B')
// Seq { 1: "B" }run it</pre>
</div>
</div>
</div>
<div id="toIndexedSeq()">
<h4><a href="index.html#toIndexedSeq()">toIndexedSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toIndexedSeq()">Collection#toIndexedSeq()</a></code>
</div>
</div>
<div id="toSetSeq()">
<h4><a href="index.html#toSetSeq()">toSetSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Set of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSetSeq()">Collection#toSetSeq()</a></code>
</div>
</div>
<h3>Sequence functions</h3>
<div id="flip()">
<h4><a href="index.html#flip()">flip()</a></h4>
<div>
<div>
<p>Returns a new Collection.Keyed of the same type where the keys and values have been flipped.</p> </div>
<pre data-language="ts">flip(): Collection.Keyed&lt;V, K&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">const { Map } = require('immutable')
Map({ a: 'z', b: 'y' }).flip()
// Map { "z": "a", "y": "b" }run it</pre>
</div>
</div>
</div>
<div id="concat()">
<h4><a href="index.html#concat()">concat()</a></h4>
<div>
<pre data-language="ts">concat&lt;KC, VC&gt;(...collections: Array&lt;Iterable&lt;[KC, VC]&gt;&gt;): Collection.Keyed&lt;K | KC, V | VC&gt;
concat&lt;C&gt;(...collections: Array&lt;{[key: string]: C}&gt;): Collection.Keyed&lt;K | string, V | C&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#concat()">Collection#concat()</a></code>
</div>
</div>
<div id="map()">
<h4><a href="index.html#map()">map()</a></h4>
<div>
<div>
<p>Returns a new Collection.Keyed with values passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">map&lt;M&gt;(mapper: (value: V, key: K, iter: this) =&gt; M,context?: unknown): Collection.Keyed&lt;K, M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#map()">Collection#map()</a></code><h4>Example</h4>
<div>
<pre data-language="ts">const { Collection } = require('immutable')
Collection.Keyed({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// Seq { "a": 10, "b": 20 }</pre>
<p>Note: <code><a href="index.html#map()">map()</a></code> always returns a new instance, even if it produced the same value at every step.</p> </div>
</div>
</div>
<div id="mapKeys()">
<h4><a href="index.html#mapKeys()">mapKeys()</a></h4>
<div>
<div>
<p>Returns a new Collection.Keyed of the same type with keys passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">mapKeys&lt;M&gt;(mapper: (key: K, value: V, iter: this) =&gt; M,context?: unknown): Collection.Keyed&lt;M, V&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2 }).mapKeys(x =&gt; x.toUpperCase())
// Map { "A": 1, "B": 2 }run it</pre>
<p>Note: <code><a href="index.html#mapKeys()">mapKeys()</a></code> always returns a new instance, even if it produced the same key at every step.</p> </div>
</div>
</div>
<div id="mapEntries()">
<h4><a href="index.html#mapEntries()">mapEntries()</a></h4>
<div>
<div>
<p>Returns a new Collection.Keyed of the same type with entries ([key, value] tuples) passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">mapEntries&lt;KM, VM&gt;(mapper: (entry: [K, V], index: number, iter: this) =&gt; [KM, VM] | undefined,context?: unknown): Collection.Keyed&lt;KM, VM&gt;
</pre>
<h4>Discussion</h4>
<div> <pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2 })
  .mapEntries(([ k, v ]) =&gt; [ k.toUpperCase(), v * 2 ])
// Map { "A": 2, "B": 4 }run it</pre>
<p>Note: <code><a href="index.html#mapEntries()">mapEntries()</a></code> always returns a new instance, even if it produced the same entry at every step.</p> <p>If the mapper function returns <code>undefined</code>, then the entry will be filtered</p> </div>
</div>
</div>
<div id="flatMap()">
<h4><a href="index.html#flatMap()">flatMap()</a></h4>
<div>
<div>
<p>Flat-maps the Collection, returning a Collection of the same type.</p> </div>
<pre data-language="ts">flatMap&lt;KM, VM&gt;(mapper: (value: V, key: K, iter: this) =&gt; Iterable&lt;[KM, VM]&gt;,context?: unknown): Collection.Keyed&lt;KM, VM&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#flatMap()">Collection#flatMap()</a></code><h4>Discussion</h4>
<div>
<p>Similar to <code>collection.map(...).flatten(true)</code>.</p> </div>
</div>
</div>
<div id="filter()">
<h4><a href="index.html#filter()">filter()</a></h4>
<div>
<pre data-language="ts">filter&lt;F&gt;(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): Collection.Keyed&lt;K, F&gt;
filter(predicate: (value: V, key: K, iter: this) =&gt; unknown,context?: unknown): this
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#filter()">Collection#filter()</a></code>
</div>
</div>
<div id="partition()">
<h4><a href="index.html#partition()">partition()</a></h4>
<div>
<pre data-language="ts">partition&lt;F, C&gt;(predicate: (this: C, value: V, key: K, iter: this) =&gt; boolean,context?: C): [Collection.Keyed&lt;K, V&gt;, Collection.Keyed&lt;K, F&gt;]
partition&lt;C&gt;(predicate: (this: C, value: V, key: K, iter: this) =&gt; unknown,context?: C): [this, this]
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#partition()">Collection#partition()</a></code>
</div>
</div>
<div id="[Symbol.iterator]()">
<h4><a href="index.html#%5BSymbol.iterator%5D()">[Symbol.iterator]()</a></h4>
<div>
<pre data-language="ts">[Symbol.iterator](): IterableIterator&lt;[K, V]&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#%5BSymbol.iterator%5D()">Collection#[Symbol.iterator]()</a></code>
</div>
</div>
<h3>Value equality</h3>
<div id="equals()">
<h4><a href="index.html#equals()">equals()</a></h4>
<div>
<div>
<p>True if this and the other Collection have value equality, as defined by <code><a href="../is()/index.html">Immutable.is()</a></code>.</p> </div>
<pre data-language="ts">equals(other: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#equals()">Collection#equals()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="hashCode()">
<h4><a href="index.html#hashCode()">hashCode()</a></h4>
<div>
<div>
<p>Computes and returns the hashed identity for this Collection.</p> </div>
<pre data-language="ts">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hashCode()">Collection#hashCode()</a></code><h4>Discussion</h4>
<div>
<p>The <code><a href="../list/index.html#hashCode()">hashCode</a></code> of a Collection is used to determine potential equality, and is used when adding this to a <code><a href="../set/index.html">Set</a></code> or as a key in a <code><a href="../map/index.html">Map</a></code>, enabling lookup via a different instance.</p>  <pre data-language="ts">const a = List([ 1, 2, 3 ]);
const b = List([ 1, 2, 3 ]);
assert.notStrictEqual(a, b); // different instances
const set = Set([ a ]);
assert.equal(set.has(b), true);run it</pre>
<p>If two values have the same <code><a href="../list/index.html#hashCode()">hashCode</a></code>, they are <a href="https://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code><a href="../list/index.html#hashCode()">hashCode</a></code>s, they must not be equal.</p> </div>
</div>
</div>
<h3>Reading values</h3>
<div id="get()">
<h4><a href="index.html#get()">get()</a></h4>
<div>
<pre data-language="ts">get&lt;NSV&gt;(key: K, notSetValue: NSV): V | NSV
get(key: K): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#get()">Collection#get()</a></code>
</div>
</div>
<div id="has()">
<h4><a href="index.html#has()">has()</a></h4>
<div>
<div>
<p>True if a key exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#has()">Collection#has()</a></code>
</div>
</div>
<div id="includes()">
<h4><a href="index.html#includes()">includes()</a></h4>
<div>
<div>
<p>True if a value exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#includes()">Collection#includes()</a></code><h4>alias</h4>
<code>contains()</code>
</div>
</div>
<div id="first()">
<h4><a href="index.html#first()">first()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the first element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">first&lt;NSV&gt;(notSetValue?: NSV): V | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#first()">Collection#first()</a></code>
</div>
</div>
<div id="last()">
<h4><a href="index.html#last()">last()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the last element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">last&lt;NSV&gt;(notSetValue?: NSV): V | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#last()">Collection#last()</a></code>
</div>
</div>
<h3>Reading deep values</h3>
<div id="getIn()">
<h4><a href="index.html#getIn()">getIn()</a></h4>
<div>
<div>
<p>Returns the value found by following a path of keys or indices through nested Collections.</p> </div>
<pre data-language="ts">getIn(searchKeyPath: Iterable&lt;unknown&gt;, notSetValue?: unknown): unknown
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#getIn()">Collection#getIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:</p>  <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: [ { y: 123 } ] });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p> </div>
</div>
</div>
<div id="hasIn()">
<h4><a href="index.html#hasIn()">hasIn()</a></h4>
<div>
<div>
<p>True if the result of following a path of keys or indices through nested Collections results in a set value.</p> </div>
<pre data-language="ts">hasIn(searchKeyPath: Iterable&lt;unknown&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hasIn()">Collection#hasIn()</a></code>
</div>
</div>
<h3>Persistent changes</h3>
<div id="update()">
<h4><a href="index.html#update()">update()</a></h4>
<div>
<div>
<p>This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".</p> </div>
<pre data-language="ts">update&lt;R&gt;(updater: (value: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#update()">Collection#update()</a></code><h4>Discussion</h4>
<div>
<p>For example, to sum a Seq after mapping and filtering:</p>  <pre data-language="ts">const { Seq } = require('immutable')

function sum(collection) {
  return collection.reduce((sum, x) =&gt; sum + x, 0)
}
Seq([ 1, 2, 3 ])
  .map(x =&gt; x + 1)
  .filter(x =&gt; x % 2 === 0)
  .update(sum)
// 6run it</pre> </div>
</div>
</div>
<h3>Conversion to Collections</h3>
<div id="toMap()">
<h4><a href="index.html#toMap()">toMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, Throws if keys are not hashable.</p> </div>
<pre data-language="ts">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toMap()">Collection#toMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedMap()">
<h4><a href="index.html#toOrderedMap()">toOrderedMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, maintaining the order of iteration.</p> </div>
<pre data-language="ts">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedMap()">Collection#toOrderedMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toSet()">
<h4><a href="index.html#toSet()">toSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSet()">Collection#toSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../set/index.html">Set(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedSet()">
<h4><a href="index.html#toOrderedSet()">toOrderedSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, maintaining the order of iteration and discarding keys.</p> </div>
<pre data-language="ts">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedSet()">Collection#toOrderedSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toList()">
<h4><a href="index.html#toList()">toList()</a></h4>
<div>
<div>
<p>Converts this Collection to a List, discarding keys.</p> </div>
<pre data-language="ts">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toList()">Collection#toList()</a></code><h4>Discussion</h4>
<div>
<p>This is similar to <code><a href="../list/index.html">List(collection)</a></code>, but provided to allow for chained expressions. However, when called on <code><a href="../map/index.html">Map</a></code> or other keyed collections, <code>collection.toList()</code> discards the keys and creates a list of only the values, whereas <code><a href="../list/index.html">List(collection)</a></code> creates a list of entry tuples.</p>  <pre data-language="ts">const { Map, List } = require('immutable')
var myMap = Map({ a: 'Apple', b: 'Banana' })
List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
myMap.toList() // List [ "Apple", "Banana" ]run it</pre>
</div>
</div>
</div>
<div id="toStack()">
<h4><a href="index.html#toStack()">toStack()</a></h4>
<div>
<div>
<p>Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toStack()">Collection#toStack()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../stack/index.html">Stack(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<h3>Iterators</h3>
<div id="keys()">
<h4><a href="index.html#keys()">keys()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s keys.</p> </div>
<pre data-language="ts">keys(): IterableIterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keys()">Collection#keys()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#keySeq()">keySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="values()">
<h4><a href="index.html#values()">values()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s values.</p> </div>
<pre data-language="ts">values(): IterableIterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#values()">Collection#values()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#valueSeq()">valueSeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="entries()">
<h4><a href="index.html#entries()">entries()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s entries as <code>[ key, value ]</code> tuples.</p> </div>
<pre data-language="ts">entries(): IterableIterator&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entries()">Collection#entries()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#entrySeq()">entrySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<h3>Collections (Seq)</h3>
<div id="keySeq()">
<h4><a href="index.html#keySeq()">keySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of the keys of this Collection, discarding values.</p> </div>
<pre data-language="ts">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keySeq()">Collection#keySeq()</a></code>
</div>
</div>
<div id="valueSeq()">
<h4><a href="index.html#valueSeq()">valueSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#valueSeq()">Collection#valueSeq()</a></code>
</div>
</div>
<div id="entrySeq()">
<h4><a href="index.html#entrySeq()">entrySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> </div>
<pre data-language="ts">entrySeq(): Seq.Indexed&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entrySeq()">Collection#entrySeq()</a></code>
</div>
</div>
<h3>Sequence algorithms</h3>
<div id="filterNot()">
<h4><a href="index.html#filterNot()">filterNot()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type with only the entries for which the <code>predicate</code> function returns false.</p> </div>
<pre data-language="ts">filterNot(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#filterNot()">Collection#filterNot()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x =&gt; x % 2 === 0)
// Map { "a": 1, "c": 3 }run it</pre></p>
<p>Note: <code><a href="../list/index.html#filterNot()">filterNot()</a></code> always returns a new instance, even if it results in not filtering out any values.</p> </div>
</div>
</div>
<div id="reverse()">
<h4><a href="index.html#reverse()">reverse()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type in reverse order.</p> </div>
<pre data-language="ts">reverse(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reverse()">Collection#reverse()</a></code>
</div>
</div>
<div id="sort()">
<h4><a href="index.html#sort()">sort()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> </div>
<pre data-language="ts">sort(comparator?: (valueA: V, valueB: V) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sort()">Collection#sort()</a></code><h4>Discussion</h4>
<div>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p>  <pre data-language="ts">const { Map } = require('immutable')
Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) =&gt; {
  if (a &lt; b) { return -1; }
  if (a &gt; b) { return 1; }
  if (a === b) { return 0; }
});
// OrderedMap { "a": 1, "b": 2, "c": 3 }run it</pre>
<p>Note: <code><a href="../list/index.html#sort()">sort()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="sortBy()">
<h4><a href="index.html#sortBy()">sortBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#sort()">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> </div>
<pre data-language="ts">sortBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sortBy()">Collection#sortBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const beattles = Map({
  John: { name: "Lennon" },
  Paul: { name: "McCartney" },
  George: { name: "Harrison" },
  Ringo: { name: "Starr" },
});
beattles.sortBy(member =&gt; member.name);run it</pre></p>
<p>Note: <code><a href="../list/index.html#sortBy()">sortBy()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="groupBy()">
<h4><a href="index.html#groupBy()">groupBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="index.html">Collection.Keyed</a></code> of <code>Collection.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">groupBy&lt;G&gt;(grouper: (value: V, key: K, iter: this) =&gt; G,context?: unknown): Seq.Keyed&lt;G, Collection&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#groupBy()">Collection#groupBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is always an eager operation.</p>  <pre data-language="ts">const { List, Map } = require('immutable')
const listOfMaps = List([
  Map({ v: 0 }),
  Map({ v: 1 }),
  Map({ v: 1 }),
  Map({ v: 0 }),
  Map({ v: 2 })
])
const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))
// Map {
//   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
//   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
//   2: List [ Map{ "v": 2 } ],
// }run it</pre>
</div>
</div>
</div>
<h3>Side effects</h3>
<div id="forEach()">
<h4><a href="index.html#forEach()">forEach()</a></h4>
<div>
<div>
<p>The <code>sideEffect</code> is executed for every entry in the Collection.</p> </div>
<pre data-language="ts">forEach(sideEffect: (value: V, key: K, iter: this) =&gt; unknown,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#forEach()">Collection#forEach()</a></code><h4>Discussion</h4>
<div>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> </div>
</div>
</div>
<h3>Creating subsets</h3>
<div id="slice()">
<h4><a href="index.html#slice()">slice()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.</p> </div>
<pre data-language="ts">slice(begin?: number, end?: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#slice()">Collection#slice()</a></code><h4>Discussion</h4>
<div>
<p>If begin is negative, it is offset from the end of the Collection. e.g. <code>slice(-2)</code> returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.</p> <p>If end is negative, it is offset from the end of the Collection. e.g. <code>slice(0, -1)</code> returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.</p> <p>If the requested slice is equivalent to the current Collection, then it will return itself.</p> </div>
</div>
</div>
<div id="rest()">
<h4><a href="index.html#rest()">rest()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the first.</p> </div>
<pre data-language="ts">rest(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#rest()">Collection#rest()</a></code>
</div>
</div>
<div id="butLast()">
<h4><a href="index.html#butLast()">butLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the last.</p> </div>
<pre data-language="ts">butLast(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#butLast()">Collection#butLast()</a></code>
</div>
</div>
<div id="skip()">
<h4><a href="index.html#skip()">skip()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skip(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skip()">Collection#skip()</a></code>
</div>
</div>
<div id="skipLast()">
<h4><a href="index.html#skipLast()">skipLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skipLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipLast()">Collection#skipLast()</a></code>
</div>
</div>
<div id="skipWhile()">
<h4><a href="index.html#skipWhile()">skipWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> </div>
<pre data-language="ts">skipWhile(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipWhile()">Collection#skipWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipWhile(x =&gt; x.match(/g/))
// List [ "cat", "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="skipUntil()">
<h4><a href="index.html#skipUntil()">skipUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> </div>
<pre data-language="ts">skipUntil(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipUntil()">Collection#skipUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipUntil(x =&gt; x.match(/hat/))
// List [ "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="take()">
<h4><a href="index.html#take()">take()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">take(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#take()">Collection#take()</a></code>
</div>
</div>
<div id="takeLast()">
<h4><a href="index.html#takeLast()">takeLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">takeLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeLast()">Collection#takeLast()</a></code>
</div>
</div>
<div id="takeWhile()">
<h4><a href="index.html#takeWhile()">takeWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">takeWhile(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeWhile()">Collection#takeWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeWhile(x =&gt; x.match(/o/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<div id="takeUntil()">
<h4><a href="index.html#takeUntil()">takeUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns false.</p> </div>
<pre data-language="ts">takeUntil(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeUntil()">Collection#takeUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeUntil(x =&gt; x.match(/at/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<h3>Combination</h3>
<div id="flatten()">
<h4><a href="index.html#flatten()">flatten()</a></h4>
<div>
<pre data-language="ts">flatten(depth?: number): Collection&lt;unknown, unknown&gt;
flatten(shallow?: boolean): Collection&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#flatten()">Collection#flatten()</a></code>
</div>
</div>
<h3>Reducing a value</h3>
<div id="reduce()">
<h4><a href="index.html#reduce()">reduce()</a></h4>
<div>
<pre data-language="ts">reduce&lt;R&gt;(reducer: (reduction: R, value: V, key: K, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduce&lt;R&gt;(reducer: (reduction: V | R, value: V, key: K, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduce()">Collection#reduce()</a></code>
</div>
</div>
<div id="reduceRight()">
<h4><a href="index.html#reduceRight()">reduceRight()</a></h4>
<div>
<pre data-language="ts">reduceRight&lt;R&gt;(reducer: (reduction: R, value: V, key: K, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduceRight&lt;R&gt;(reducer: (reduction: V | R, value: V, key: K, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduceRight()">Collection#reduceRight()</a></code>
</div>
</div>
<div id="every()">
<h4><a href="index.html#every()">every()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for all entries in the Collection.</p> </div>
<pre data-language="ts">every(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#every()">Collection#every()</a></code>
</div>
</div>
<div id="some()">
<h4><a href="index.html#some()">some()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for any entry in the Collection.</p> </div>
<pre data-language="ts">some(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#some()">Collection#some()</a></code>
</div>
</div>
<div id="join()">
<h4><a href="index.html#join()">join()</a></h4>
<div>
<div>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> </div>
<pre data-language="ts">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#join()">Collection#join()</a></code>
</div>
</div>
<div id="isEmpty()">
<h4><a href="index.html#isEmpty()">isEmpty()</a></h4>
<div>
<div>
<p>Returns true if this Collection includes no values.</p> </div>
<pre data-language="ts">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isEmpty()">Collection#isEmpty()</a></code><h4>Discussion</h4>
<div>
<p>For some lazy <code><a href="../seq/index.html">Seq</a></code>, <code><a href="../list/index.html#isEmpty()">isEmpty</a></code> might need to iterate to determine emptiness. At most one iteration will occur.</p> </div>
</div>
</div>
<div id="count()">
<h4><a href="index.html#count()">count()</a></h4>
<div>
<pre data-language="ts">count(): number
count(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#count()">Collection#count()</a></code>
</div>
</div>
<div id="countBy()">
<h4><a href="index.html#countBy()">countBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../seq.keyed/index.html">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">countBy&lt;G&gt;(grouper: (value: V, key: K, iter: this) =&gt; G,context?: unknown): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#countBy()">Collection#countBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is not a lazy operation.</p> </div>
</div>
</div>
<h3>Search for value</h3>
<div id="find()">
<h4><a href="index.html#find()">find()</a></h4>
<div>
<div>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">find(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#find()">Collection#find()</a></code>
</div>
</div>
<div id="findLast()">
<h4><a href="index.html#findLast()">findLast()</a></h4>
<div>
<div>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLast(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLast()">Collection#findLast()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findEntry()">
<h4><a href="index.html#findEntry()">findEntry()</a></h4>
<div>
<div>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findEntry(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findEntry()">Collection#findEntry()</a></code>
</div>
</div>
<div id="findLastEntry()">
<h4><a href="index.html#findLastEntry()">findLastEntry()</a></h4>
<div>
<div>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastEntry(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastEntry()">Collection#findLastEntry()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findKey()">
<h4><a href="index.html#findKey()">findKey()</a></h4>
<div>
<div>
<p>Returns the key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findKey(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findKey()">Collection#findKey()</a></code>
</div>
</div>
<div id="findLastKey()">
<h4><a href="index.html#findLastKey()">findLastKey()</a></h4>
<div>
<div>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastKey(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastKey()">Collection#findLastKey()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="keyOf()">
<h4><a href="index.html#keyOf()">keyOf()</a></h4>
<div>
<div>
<p>Returns the key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">keyOf(searchValue: V): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keyOf()">Collection#keyOf()</a></code>
</div>
</div>
<div id="lastKeyOf()">
<h4><a href="index.html#lastKeyOf()">lastKeyOf()</a></h4>
<div>
<div>
<p>Returns the last key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">lastKeyOf(searchValue: V): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#lastKeyOf()">Collection#lastKeyOf()</a></code>
</div>
</div>
<div id="max()">
<h4><a href="index.html#max()">max()</a></h4>
<div>
<div>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">max(comparator?: (valueA: V, valueB: V) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#max()">Collection#max()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#max()">max</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="maxBy()">
<h4><a href="index.html#maxBy()">maxBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#max()">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">maxBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#maxBy()">Collection#maxBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.maxBy(i =&gt; i.avgHit); // will output { name: 'Max', avgHit: 3 }run it</pre></p> </div>
</div>
</div>
<div id="min()">
<h4><a href="index.html#min()">min()</a></h4>
<div>
<div>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">min(comparator?: (valueA: V, valueB: V) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#min()">Collection#min()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#min()">min</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="minBy()">
<h4><a href="index.html#minBy()">minBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#min()">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">minBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#minBy()">Collection#minBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.minBy(i =&gt; i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it</pre></p> </div>
</div>
</div>
<h3>Comparison</h3>
<div id="isSubset()">
<h4><a href="index.html#isSubset()">isSubset()</a></h4>
<div>
<div>
<p>True if <code>iter</code> includes every value in this Collection.</p> </div>
<pre data-language="ts">isSubset(iter: Iterable&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSubset()">Collection#isSubset()</a></code>
</div>
</div>
<div id="isSuperset()">
<h4><a href="index.html#isSuperset()">isSuperset()</a></h4>
<div>
<div>
<p>True if this Collection includes every value in <code>iter</code>.</p> </div>
<pre data-language="ts">isSuperset(iter: Iterable&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSuperset()">Collection#isSuperset()</a></code>
</div>
</div>This documentation is generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts" rel="noopener">immutable.d.ts</a>. Pull requests and <a href="https://github.com/immutable-js/immutable-js/issues" rel="noopener">Issues</a> welcome.<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014â€“present, Lee Byron and other contributors<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://immutable-js.com/docs/v4.2.1/Collection.Keyed/" class="_attribution-link">https://immutable-js.com/docs/v4.2.1/Collection.Keyed/</a>
  </p>
</div>
