<h1>OrderedMap</h1>
<div>
<p>A type of Map that has the additional guarantee that the iteration order of entries will be the order in which they were set().</p> </div>
<pre data-language="ts">type OrderedMap&lt;K, V&gt; extends Map&lt;K, V&gt;</pre>
<h4>Discussion</h4>
<div>
<p>The iteration behavior of OrderedMap is the same as native ES6 Map and JavaScript Object.</p> <p>Note that <code><a href="index.html">OrderedMap</a></code> are more expensive than non-ordered <code><a href="../map/index.html">Map</a></code> and may consume more memory. <code><a href="index.html#set()">OrderedMap#set</a></code> is amortized O(log32 N), but not stable.</p> </div>
<h3>Construction</h3>
<div id="OrderedMap()">
<h4><a href="index.html#OrderedMap()">OrderedMap()</a></h4>
<div><pre data-language="ts">OrderedMap&lt;K, V&gt;(collection?: Iterable&lt;[K, V]&gt;): OrderedMap&lt;K, V&gt;
OrderedMap&lt;V&gt;(obj: {[key: string]: V}): OrderedMap&lt;string, V&gt;
</pre></div>
</div>
<h3>Static methods</h3>
<div id="isOrderedMap()">
<h4><a href="index.html#isOrderedMap()">OrderedMap.isOrderedMap()</a></h4>
<div><pre data-language="ts">OrderedMap.isOrderedMap(maybeOrderedMap: unknown): boolean
</pre></div>
</div>
<h3>Members</h3>
<div id="size">
<h4><a href="index.html#size">size</a></h4>
<div>
<div>
<p>The number of entries in this OrderedMap.</p> </div>
<pre data-language="ts">size: number</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#size">Map#size</a></code>
</div>
</div>
<h3>Persistent changes</h3>
<div id="set()">
<h4><a href="index.html#set()">set()</a></h4>
<div>
<div>
<p>Returns a new OrderedMap also containing the new key, value pair. If an equivalent key already exists in this OrderedMap, it will be replaced while maintaining the existing order.</p> </div>
<pre data-language="ts">set(key: K, value: V): this
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#set()">Map#set()</a></code><h4>Discussion</h4>
<div> <pre data-language="ts">const { OrderedMap } = require('immutable')
const originalMap = OrderedMap({a:1, b:1, c:1})
const updatedMap = originalMap.set('b', 2)

originalMap
// OrderedMap {a: 1, b: 1, c: 1}
updatedMap
// OrderedMap {a: 1, b: 2, c: 1}run it</pre>
<p>Note: <code><a href="index.html#set()">set</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="merge()">
<h4><a href="index.html#merge()">merge()</a></h4>
<div>
<pre data-language="ts">merge&lt;KC, VC&gt;(...collections: Array&lt;Iterable&lt;[KC, VC]&gt;&gt;): OrderedMap&lt;K | KC, V | VC&gt;
merge&lt;C&gt;(...collections: Array&lt;{[key: string]: C}&gt;): OrderedMap&lt;K | string, V | C&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#merge()">Map#merge()</a></code>
</div>
</div>
<div id="delete()">
<h4><a href="index.html#delete()">delete()</a></h4>
<div>
<div>
<p>Returns a new Map which excludes this <code>key</code>.</p> </div>
<pre data-language="ts">delete(key: K): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#delete()">Map#delete()</a></code><h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<div>
<p>Note: <code><a href="../map/index.html#delete()">delete</a></code> cannot be safely used in IE8, but is provided to mirror the ES6 collection API.</p>  <pre data-language="ts">const { Map } = require('immutable')
const originalMap = Map({
  key: 'value',
  otherKey: 'other value'
})
// Map { "key": "value", "otherKey": "other value" }
originalMap.delete('otherKey')
// Map { "key": "value" }run it</pre>
<p>Note: <code><a href="../map/index.html#delete()">delete</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="deleteAll()">
<h4><a href="index.html#deleteAll()">deleteAll()</a></h4>
<div>
<div>
<p>Returns a new Map which excludes the provided <code>keys</code>.</p> </div>
<pre data-language="ts">deleteAll(keys: Iterable&lt;K&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#deleteAll()">Map#deleteAll()</a></code><h4>alias</h4>
<code>removeAll()</code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const names = Map({ a: "Aaron", b: "Barry", c: "Connor" })
names.deleteAll([ 'a', 'c' ])
// Map { "b": "Barry" }run it</pre></p>
<p>Note: <code><a href="../map/index.html#deleteAll()">deleteAll</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="clear()">
<h4><a href="index.html#clear()">clear()</a></h4>
<div>
<div>
<p>Returns a new Map containing no keys or values.</p> </div>
<pre data-language="ts">clear(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#clear()">Map#clear()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ key: 'value' }).clear()
// Map {}run it</pre></p>
<p>Note: <code><a href="../map/index.html#clear()">clear</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="update()">
<h4><a href="index.html#update()">update()</a></h4>
<div>
<pre data-language="ts">update(key: K, notSetValue: V, updater: (value: V) =&gt; V): this
update(key: K, updater: (value: V | undefined) =&gt; V): this
update&lt;R&gt;(updater: (value: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#update()">Map#update()</a></code>
</div>
</div>
<div id="mergeWith()">
<h4><a href="index.html#mergeWith()">mergeWith()</a></h4>
<div>
<div>
<p>Like <code><a href="../map/index.html#merge()">merge()</a></code>, <code><a href="../map/index.html#mergeWith()">mergeWith()</a></code> returns a new Map resulting from merging the provided Collections (or JS objects) into this Map, but uses the <code>merger</code> function for dealing with conflicts.</p> </div>
<pre data-language="ts">mergeWith(merger: (oldVal: V, newVal: V, key: K) =&gt; V,...collections: Array&lt;Iterable&lt;[K, V]&gt; | {[key: string]: V}&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#mergeWith()">Map#mergeWith()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const one = Map({ a: 10, b: 20, c: 30 })
const two = Map({ b: 40, a: 50, d: 60 })
one.mergeWith((oldVal, newVal) =&gt; oldVal / newVal, two)
// { "a": 0.2, "b": 0.5, "c": 30, "d": 60 }
two.mergeWith((oldVal, newVal) =&gt; oldVal / newVal, one)
// { "b": 2, "a": 5, "d": 60, "c": 30 }run it</pre></p>
<p>Note: <code><a href="../map/index.html#mergeWith()">mergeWith</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="mergeDeep()">
<h4><a href="index.html#mergeDeep()">mergeDeep()</a></h4>
<div>
<div>
<p>Like <code><a href="../map/index.html#merge()">merge()</a></code>, but when two compatible collections are encountered with the same key, it merges them as well, recursing deeply through the nested data. Two collections are considered to be compatible (and thus will be merged together) if they both fall into one of three categories: keyed (e.g., <code><a href="../map/index.html">Map</a></code>s, <code><a href="../record/index.html">Record</a></code>s, and objects), indexed (e.g., <code><a href="../list/index.html">List</a></code>s and arrays), or set-like (e.g., <code><a href="../set/index.html">Set</a></code>s). If they fall into separate categories, <code><a href="../map/index.html#mergeDeep()">mergeDeep</a></code> will replace the existing collection with the collection being merged in. This behavior can be customized by using <code><a href="../map/index.html#mergeDeepWith()">mergeDeepWith()</a></code>.</p> </div>
<pre data-language="ts">mergeDeep(...collections: Array&lt;Iterable&lt;[K, V]&gt; | {[key: string]: V}&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#mergeDeep()">Map#mergeDeep()</a></code><h4>Discussion</h4>
<div>
<p>Note: Indexed and set-like collections are merged using <code><a href="../map/index.html#concat()">concat()</a></code>/<code>union()</code> and therefore do not recurse.</p>  <pre data-language="ts">const { Map } = require('immutable')
const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
one.mergeDeep(two)
// Map {
//   "a": Map { "x": 2, "y": 10 },
//   "b": Map { "x": 20, "y": 5 },
//   "c": Map { "z": 3 }
// }run it</pre>
<p>Note: <code><a href="../map/index.html#mergeDeep()">mergeDeep</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="mergeDeepWith()">
<h4><a href="index.html#mergeDeepWith()">mergeDeepWith()</a></h4>
<div>
<div>
<p>Like <code><a href="../map/index.html#mergeDeep()">mergeDeep()</a></code>, but when two non-collections or incompatible collections are encountered at the same key, it uses the <code>merger</code> function to determine the resulting value. Collections are considered incompatible if they fall into separate categories between keyed, indexed, and set-like.</p> </div>
<pre data-language="ts">mergeDeepWith(merger: (oldVal: unknown, newVal: unknown, key: unknown) =&gt; unknown,...collections: Array&lt;Iterable&lt;[K, V]&gt; | {[key: string]: V}&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#mergeDeepWith()">Map#mergeDeepWith()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const one = Map({ a: Map({ x: 10, y: 10 }), b: Map({ x: 20, y: 50 }) })
const two = Map({ a: Map({ x: 2 }), b: Map({ y: 5 }), c: Map({ z: 3 }) })
one.mergeDeepWith((oldVal, newVal) =&gt; oldVal / newVal, two)
// Map {
//   "a": Map { "x": 5, "y": 10 },
//   "b": Map { "x": 20, "y": 10 },
//   "c": Map { "z": 3 }
// }run it</pre></p>
<p>Note: <code><a href="../map/index.html#mergeDeepWith()">mergeDeepWith</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<h3>Sequence algorithms</h3>
<div id="map()">
<h4><a href="index.html#map()">map()</a></h4>
<div>
<div>
<p>Returns a new OrderedMap with values passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">map&lt;M&gt;(mapper: (value: V, key: K, iter: this) =&gt; M,context?: unknown): OrderedMap&lt;K, M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#map()">Map#map()</a></code><h4>Example</h4>
<div>
<pre data-language="ts">OrderedMap({ a: 1, b: 2 }).map(x =&gt; 10 * x)
// OrderedMap { "a": 10, "b": 20 }</pre>
<p>Note: <code><a href="index.html#map()">map()</a></code> always returns a new instance, even if it produced the same value at every step.</p> </div>
</div>
</div>
<div id="mapKeys()">
<h4><a href="index.html#mapKeys()">mapKeys()</a></h4>
<div>

<pre data-language="ts">mapKeys&lt;M&gt;(mapper: (key: K, value: V, iter: this) =&gt; M,context?: unknown): OrderedMap&lt;M, V&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#mapKeys()">Map#mapKeys()</a></code><h4>see</h4>
<div>
<p>Collection.Keyed.mapKeys</p> </div>
</div>
</div>
<div id="mapEntries()">
<h4><a href="index.html#mapEntries()">mapEntries()</a></h4>
<div>

<pre data-language="ts">mapEntries&lt;KM, VM&gt;(mapper: (entry: [K, V], index: number, iter: this) =&gt; [KM, VM] | undefined,context?: unknown): OrderedMap&lt;KM, VM&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#mapEntries()">Map#mapEntries()</a></code><h4>see</h4>
<div>
<p>Collection.Keyed.mapEntries</p> </div>
</div>
</div>
<div id="flatMap()">
<h4><a href="index.html#flatMap()">flatMap()</a></h4>
<div>
<div>
<p>Flat-maps the OrderedMap, returning a new OrderedMap.</p> </div>
<pre data-language="ts">flatMap&lt;KM, VM&gt;(mapper: (value: V, key: K, iter: this) =&gt; Iterable&lt;[KM, VM]&gt;,context?: unknown): OrderedMap&lt;KM, VM&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#flatMap()">Map#flatMap()</a></code><h4>Discussion</h4>
<div>
<p>Similar to <code>data.map(...).flatten(true)</code>.</p> </div>
</div>
</div>
<div id="filter()">
<h4><a href="index.html#filter()">filter()</a></h4>
<div>
<pre data-language="ts">filter&lt;F&gt;(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): OrderedMap&lt;K, F&gt;
filter(predicate: (value: V, key: K, iter: this) =&gt; unknown,context?: unknown): this
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#filter()">Map#filter()</a></code>
</div>
</div>
<div id="partition()">
<h4><a href="index.html#partition()">partition()</a></h4>
<div>
<pre data-language="ts">partition&lt;F, C&gt;(predicate: (this: C, value: V, key: K, iter: this) =&gt; boolean,context?: C): [OrderedMap&lt;K, V&gt;, OrderedMap&lt;K, F&gt;]
partition&lt;C&gt;(predicate: (this: C, value: V, key: K, iter: this) =&gt; unknown,context?: C): [this, this]
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#partition()">Map#partition()</a></code>
</div>
</div>
<div id="flip()">
<h4><a href="index.html#flip()">flip()</a></h4>
<div>

<pre data-language="ts">flip(): OrderedMap&lt;V, K&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../map/index.html#flip()">Map#flip()</a></code><h4>see</h4>
<div>
<p>Collection.Keyed.flip</p> </div>
</div>
</div>
<div id="filterNot()">
<h4><a href="index.html#filterNot()">filterNot()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type with only the entries for which the <code>predicate</code> function returns false.</p> </div>
<pre data-language="ts">filterNot(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#filterNot()">Collection#filterNot()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x =&gt; x % 2 === 0)
// Map { "a": 1, "c": 3 }run it</pre></p>
<p>Note: <code><a href="../list/index.html#filterNot()">filterNot()</a></code> always returns a new instance, even if it results in not filtering out any values.</p> </div>
</div>
</div>
<div id="reverse()">
<h4><a href="index.html#reverse()">reverse()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type in reverse order.</p> </div>
<pre data-language="ts">reverse(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reverse()">Collection#reverse()</a></code>
</div>
</div>
<div id="sort()">
<h4><a href="index.html#sort()">sort()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> </div>
<pre data-language="ts">sort(comparator?: (valueA: V, valueB: V) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sort()">Collection#sort()</a></code><h4>Discussion</h4>
<div>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p>  <pre data-language="ts">const { Map } = require('immutable')
Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) =&gt; {
  if (a &lt; b) { return -1; }
  if (a &gt; b) { return 1; }
  if (a === b) { return 0; }
});
// OrderedMap { "a": 1, "b": 2, "c": 3 }run it</pre>
<p>Note: <code><a href="../list/index.html#sort()">sort()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="sortBy()">
<h4><a href="index.html#sortBy()">sortBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#sort()">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> </div>
<pre data-language="ts">sortBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sortBy()">Collection#sortBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const beattles = Map({
  John: { name: "Lennon" },
  Paul: { name: "McCartney" },
  George: { name: "Harrison" },
  Ringo: { name: "Starr" },
});
beattles.sortBy(member =&gt; member.name);run it</pre></p>
<p>Note: <code><a href="../list/index.html#sortBy()">sortBy()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="groupBy()">
<h4><a href="index.html#groupBy()">groupBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../collection.keyed/index.html">Collection.Keyed</a></code> of <code>Collection.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">groupBy&lt;G&gt;(grouper: (value: V, key: K, iter: this) =&gt; G,context?: unknown): Seq.Keyed&lt;G, Collection&lt;K, V&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#groupBy()">Collection#groupBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is always an eager operation.</p>  <pre data-language="ts">const { List, Map } = require('immutable')
const listOfMaps = List([
  Map({ v: 0 }),
  Map({ v: 1 }),
  Map({ v: 1 }),
  Map({ v: 0 }),
  Map({ v: 2 })
])
const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))
// Map {
//   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
//   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
//   2: List [ Map{ "v": 2 } ],
// }run it</pre>
</div>
</div>
</div>
<h3>Deep persistent changes</h3>
<div id="setIn()">
<h4><a href="index.html#setIn()">setIn()</a></h4>
<div>
<div>
<p>Returns a new Map having set <code>value</code> at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, a new immutable Map will be created at that key.</p> </div>
<pre data-language="ts">setIn(keyPath: Iterable&lt;unknown&gt;, value: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#setIn()">Map#setIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const originalMap = Map({
  subObject: Map({
    subKey: 'subvalue',
    subSubObject: Map({
      subSubKey: 'subSubValue'
    })
  })
})</pre></p> <p>const newMap = originalMap.setIn(['subObject', 'subKey'], 'ha ha!') // Map { // "subObject": Map { // "subKey": "ha ha!", // "subSubObject": Map { "subSubKey": "subSubValue" } // } // }  const newerMap = originalMap.setIn( ['subObject', 'subSubObject', 'subSubKey'], 'ha ha ha!' ) // Map { // "subObject": Map { // "subKey": "subvalue", // "subSubObject": Map { "subSubKey": "ha ha ha!" } // } // }<a data-options="%7B%7D" onclick="runIt(this,'v4.2.1')">run it</a></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and setIn() can update those values as well, treating them immutably by creating new copies of those values with the changes applied.</p>  <p><pre data-language="ts">const { Map } = require('immutable')
const originalMap = Map({
  subObject: {
    subKey: 'subvalue',
    subSubObject: {
      subSubKey: 'subSubValue'
    }
  }
})</pre></p> <p>originalMap.setIn(['subObject', 'subKey'], 'ha ha!') // Map { // "subObject": { // subKey: "ha ha!", // subSubObject: { subSubKey: "subSubValue" } // } // }<a data-options="%7B%7D" onclick="runIt(this,'v4.2.1')">run it</a></p>
<p>If any key in the path exists but cannot be updated (such as a primitive like number or a custom Object like Date), an error will be thrown.</p> <p>Note: <code><a href="../map/index.html#setIn()">setIn</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="deleteIn()">
<h4><a href="index.html#deleteIn()">deleteIn()</a></h4>
<div>
<div>
<p>Returns a new Map having removed the value at this <code>keyPath</code>. If any keys in <code>keyPath</code> do not exist, no change will occur.</p> </div>
<pre data-language="ts">deleteIn(keyPath: Iterable&lt;unknown&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#deleteIn()">Map#deleteIn()</a></code><h4>alias</h4>
<code>removeIn()</code><h4>Discussion</h4>
<div>
<p>Note: <code><a href="../map/index.html#deleteIn()">deleteIn</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="updateIn()">
<h4><a href="index.html#updateIn()">updateIn()</a></h4>
<div>
<pre data-language="ts">updateIn(keyPath: Iterable&lt;unknown&gt;,notSetValue: unknown,updater: (value: unknown) =&gt; unknown): this
updateIn(keyPath: Iterable&lt;unknown&gt;, updater: (value: unknown) =&gt; unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#updateIn()">Map#updateIn()</a></code>
</div>
</div>
<div id="mergeIn()">
<h4><a href="index.html#mergeIn()">mergeIn()</a></h4>
<div>
<div>
<p>A combination of <code><a href="../map/index.html#updateIn()">updateIn</a></code> and <code><a href="../map/index.html#merge()">merge</a></code>, returning a new Map, but performing the merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> </div>
<pre data-language="ts">mergeIn(keyPath: Iterable&lt;unknown&gt;, ...collections: Array&lt;unknown&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#mergeIn()">Map#mergeIn()</a></code><h4>Discussion</h4>
<div>
<p><pre data-language="ts">map.updateIn(['a', 'b', 'c'], abc =&gt; abc.merge(y))
map.mergeIn(['a', 'b', 'c'], y)</pre></p>
<p>Note: <code><a href="../map/index.html#mergeIn()">mergeIn</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="mergeDeepIn()">
<h4><a href="index.html#mergeDeepIn()">mergeDeepIn()</a></h4>
<div>
<div>
<p>A combination of <code><a href="../map/index.html#updateIn()">updateIn</a></code> and <code><a href="../map/index.html#mergeDeep()">mergeDeep</a></code>, returning a new Map, but performing the deep merge at a point arrived at by following the keyPath. In other words, these two lines are equivalent:</p> </div>
<pre data-language="ts">mergeDeepIn(keyPath: Iterable&lt;unknown&gt;, ...collections: Array&lt;unknown&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#mergeDeepIn()">Map#mergeDeepIn()</a></code><h4>Discussion</h4>
<div>
<p><pre data-language="ts">map.updateIn(['a', 'b', 'c'], abc =&gt; abc.mergeDeep(y))
map.mergeDeepIn(['a', 'b', 'c'], y)</pre></p>
<p>Note: <code><a href="../map/index.html#mergeDeepIn()">mergeDeepIn</a></code> can be used in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<h3>Transient changes</h3>
<div id="withMutations()">
<h4><a href="index.html#withMutations()">withMutations()</a></h4>
<div>
<div>
<p>Every time you call one of the above functions, a new immutable Map is created. If a pure function calls a number of these to produce a final return value, then a penalty on performance and memory has been paid by creating all of the intermediate immutable Maps.</p> </div>
<pre data-language="ts">withMutations(mutator: (mutable: this) =&gt; unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#withMutations()">Map#withMutations()</a></code><h4>Discussion</h4>
<div>
<p>If you need to apply a series of mutations to produce a new immutable Map, <code><a href="../map/index.html#withMutations()">withMutations()</a></code> creates a temporary mutable copy of the Map which can apply mutations in a highly performant manner. In fact, this is exactly how complex mutations like <code><a href="../map/index.html#merge()">merge</a></code> are done.</p> <p>As an example, this results in the creation of 2, not 4, new Maps:</p>  <pre data-language="ts">const { Map } = require('immutable')
const map1 = Map()
const map2 = map1.withMutations(map =&gt; {
  map.set('a', 1).set('b', 2).set('c', 3)
})
assert.equal(map1.size, 0)
assert.equal(map2.size, 3)run it</pre>
<p>Note: Not all methods can be used on a mutable collection or within <code><a href="../map/index.html#withMutations()">withMutations</a></code>! Read the documentation for each method to see if it is safe to use in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="asMutable()">
<h4><a href="index.html#asMutable()">asMutable()</a></h4>
<div>
<div>
<p>Another way to avoid creation of intermediate Immutable maps is to create a mutable copy of this collection. Mutable copies <em>always</em> return <code>this</code>, and thus shouldn't be used for equality. Your function should never return a mutable copy of a collection, only use it internally to create a new collection.</p> </div>
<pre data-language="ts">asMutable(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#asMutable()">Map#asMutable()</a></code><h4>see</h4>
<div>
<p><code><a href="../map/index.html#asImmutable()">Map#asImmutable</a></code></p> </div>
<h4>Discussion</h4>
<div>
<p>If possible, use <code><a href="../map/index.html#withMutations()">withMutations</a></code> to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.</p> <p>Note: if the collection is already mutable, <code><a href="../map/index.html#asMutable()">asMutable</a></code> returns itself.</p> <p>Note: Not all methods can be used on a mutable collection or within <code><a href="../map/index.html#withMutations()">withMutations</a></code>! Read the documentation for each method to see if it is safe to use in <code><a href="../map/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="wasAltered()">
<h4><a href="index.html#wasAltered()">wasAltered()</a></h4>
<div>
<div>
<p>Returns true if this is a mutable copy (see <code><a href="../map/index.html#asMutable()">asMutable()</a></code>) and mutative alterations have been applied.</p> </div>
<pre data-language="ts">wasAltered(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#wasAltered()">Map#wasAltered()</a></code><h4>see</h4>
<div>
<p><code><a href="../map/index.html#asMutable()">Map#asMutable</a></code></p> </div>
</div>
</div>
<div id="asImmutable()">
<h4><a href="index.html#asImmutable()">asImmutable()</a></h4>
<div>
<div>
<p>The yin to <code><a href="../map/index.html#asMutable()">asMutable</a></code>'s yang. Because it applies to mutable collections, this operation is <em>mutable</em> and may return itself (though may not return itself, i.e. if the result is an empty collection). Once performed, the original mutable copy must no longer be mutated since it may be the immutable result.</p> </div>
<pre data-language="ts">asImmutable(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../map/index.html#asImmutable()">Map#asImmutable()</a></code><h4>see</h4>
<div>
<p><code><a href="../map/index.html#asMutable()">Map#asMutable</a></code></p> </div>
<h4>Discussion</h4>
<div>
<p>If possible, use <code><a href="../map/index.html#withMutations()">withMutations</a></code> to work with temporary mutable copies as it provides an easier to use API and considers many common optimizations.</p> </div>
</div>
</div>
<h3>Conversion to JavaScript types</h3>
<div id="toJS()">
<h4><a href="index.html#toJS()">toJS()</a></h4>
<div>
<div>
<p>Deeply converts this Keyed collection to equivalent native JavaScript Object.</p> </div>
<pre data-language="ts">toJS(): {[key: string]: DeepCopy&lt;V&gt;}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#toJS()">Collection.Keyed#toJS()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<div id="toJSON()">
<h4><a href="index.html#toJSON()">toJSON()</a></h4>
<div>
<div>
<p>Shallowly converts this Keyed collection to equivalent native JavaScript Object.</p> </div>
<pre data-language="ts">toJSON(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#toJSON()">Collection.Keyed#toJSON()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<div id="toArray()">
<h4><a href="index.html#toArray()">toArray()</a></h4>
<div>
<div>
<p>Shallowly converts this collection to an Array.</p> </div>
<pre data-language="ts">toArray(): Array&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#toArray()">Collection.Keyed#toArray()</a></code>
</div>
</div>
<div id="toObject()">
<h4><a href="index.html#toObject()">toObject()</a></h4>
<div>
<div>
<p>Shallowly converts this Collection to an Object.</p> </div>
<pre data-language="ts">toObject(): {[key: string]: V}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toObject()">Collection#toObject()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<h3>Conversion to Seq</h3>
<div id="toSeq()">
<h4><a href="index.html#toSeq()">toSeq()</a></h4>
<div>
<div>
<p>Returns Seq.Keyed.</p> </div>
<pre data-language="ts">toSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#toSeq()">Collection.Keyed#toSeq()</a></code>
</div>
</div>
<div id="toKeyedSeq()">
<h4><a href="index.html#toKeyedSeq()">toKeyedSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Keyed from this Collection where indices are treated as keys.</p> </div>
<pre data-language="ts">toKeyedSeq(): Seq.Keyed&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toKeyedSeq()">Collection#toKeyedSeq()</a></code><h4>Discussion</h4>
<div>
<p>This is useful if you want to operate on an Collection.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Collection.</p>  <pre data-language="ts">const { Seq } = require('immutable')
const indexedSeq = Seq([ 'A', 'B', 'C' ])
// Seq [ "A", "B", "C" ]
indexedSeq.filter(v =&gt; v === 'B')
// Seq [ "B" ]
const keyedSeq = indexedSeq.toKeyedSeq()
// Seq { 0: "A", 1: "B", 2: "C" }
keyedSeq.filter(v =&gt; v === 'B')
// Seq { 1: "B" }run it</pre>
</div>
</div>
</div>
<div id="toIndexedSeq()">
<h4><a href="index.html#toIndexedSeq()">toIndexedSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toIndexedSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toIndexedSeq()">Collection#toIndexedSeq()</a></code>
</div>
</div>
<div id="toSetSeq()">
<h4><a href="index.html#toSetSeq()">toSetSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Set of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toSetSeq(): Seq.Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSetSeq()">Collection#toSetSeq()</a></code>
</div>
</div>
<h3>Sequence functions</h3>
<div id="concat()">
<h4><a href="index.html#concat()">concat()</a></h4>
<div>
<pre data-language="ts">concat&lt;KC, VC&gt;(...collections: Array&lt;Iterable&lt;[KC, VC]&gt;&gt;): Collection.Keyed&lt;K | KC, V | VC&gt;
concat&lt;C&gt;(...collections: Array&lt;{[key: string]: C}&gt;): Collection.Keyed&lt;K | string, V | C&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#concat()">Collection.Keyed#concat()</a></code>
</div>
</div>
<div id="[Symbol.iterator]()">
<h4><a href="index.html#%5BSymbol.iterator%5D()">[Symbol.iterator]()</a></h4>
<div>
<pre data-language="ts">[Symbol.iterator](): IterableIterator&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.keyed/index.html#%5BSymbol.iterator%5D()">Collection.Keyed#[Symbol.iterator]()</a></code>
</div>
</div>
<h3>Value equality</h3>
<div id="equals()">
<h4><a href="index.html#equals()">equals()</a></h4>
<div>
<div>
<p>True if this and the other Collection have value equality, as defined by <code><a href="../is()/index.html">Immutable.is()</a></code>.</p> </div>
<pre data-language="ts">equals(other: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#equals()">Collection#equals()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="hashCode()">
<h4><a href="index.html#hashCode()">hashCode()</a></h4>
<div>
<div>
<p>Computes and returns the hashed identity for this Collection.</p> </div>
<pre data-language="ts">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hashCode()">Collection#hashCode()</a></code><h4>Discussion</h4>
<div>
<p>The <code><a href="../list/index.html#hashCode()">hashCode</a></code> of a Collection is used to determine potential equality, and is used when adding this to a <code><a href="../set/index.html">Set</a></code> or as a key in a <code><a href="../map/index.html">Map</a></code>, enabling lookup via a different instance.</p>  <pre data-language="ts">const a = List([ 1, 2, 3 ]);
const b = List([ 1, 2, 3 ]);
assert.notStrictEqual(a, b); // different instances
const set = Set([ a ]);
assert.equal(set.has(b), true);run it</pre>
<p>If two values have the same <code><a href="../list/index.html#hashCode()">hashCode</a></code>, they are <a href="https://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code><a href="../list/index.html#hashCode()">hashCode</a></code>s, they must not be equal.</p> </div>
</div>
</div>
<h3>Reading values</h3>
<div id="get()">
<h4><a href="index.html#get()">get()</a></h4>
<div>
<pre data-language="ts">get&lt;NSV&gt;(key: K, notSetValue: NSV): V | NSV
get(key: K): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#get()">Collection#get()</a></code>
</div>
</div>
<div id="has()">
<h4><a href="index.html#has()">has()</a></h4>
<div>
<div>
<p>True if a key exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">has(key: K): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#has()">Collection#has()</a></code>
</div>
</div>
<div id="includes()">
<h4><a href="index.html#includes()">includes()</a></h4>
<div>
<div>
<p>True if a value exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">includes(value: V): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#includes()">Collection#includes()</a></code><h4>alias</h4>
<code>contains()</code>
</div>
</div>
<div id="first()">
<h4><a href="index.html#first()">first()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the first element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">first&lt;NSV&gt;(notSetValue?: NSV): V | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#first()">Collection#first()</a></code>
</div>
</div>
<div id="last()">
<h4><a href="index.html#last()">last()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the last element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">last&lt;NSV&gt;(notSetValue?: NSV): V | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#last()">Collection#last()</a></code>
</div>
</div>
<h3>Reading deep values</h3>
<div id="getIn()">
<h4><a href="index.html#getIn()">getIn()</a></h4>
<div>
<div>
<p>Returns the value found by following a path of keys or indices through nested Collections.</p> </div>
<pre data-language="ts">getIn(searchKeyPath: Iterable&lt;unknown&gt;, notSetValue?: unknown): unknown
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#getIn()">Collection#getIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:</p>  <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: [ { y: 123 } ] });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p> </div>
</div>
</div>
<div id="hasIn()">
<h4><a href="index.html#hasIn()">hasIn()</a></h4>
<div>
<div>
<p>True if the result of following a path of keys or indices through nested Collections results in a set value.</p> </div>
<pre data-language="ts">hasIn(searchKeyPath: Iterable&lt;unknown&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hasIn()">Collection#hasIn()</a></code>
</div>
</div>
<h3>Conversion to Collections</h3>
<div id="toMap()">
<h4><a href="index.html#toMap()">toMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, Throws if keys are not hashable.</p> </div>
<pre data-language="ts">toMap(): Map&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toMap()">Collection#toMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedMap()">
<h4><a href="index.html#toOrderedMap()">toOrderedMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, maintaining the order of iteration.</p> </div>
<pre data-language="ts">toOrderedMap(): OrderedMap&lt;K, V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedMap()">Collection#toOrderedMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toSet()">
<h4><a href="index.html#toSet()">toSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toSet(): Set&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSet()">Collection#toSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../set/index.html">Set(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedSet()">
<h4><a href="index.html#toOrderedSet()">toOrderedSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, maintaining the order of iteration and discarding keys.</p> </div>
<pre data-language="ts">toOrderedSet(): OrderedSet&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedSet()">Collection#toOrderedSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toList()">
<h4><a href="index.html#toList()">toList()</a></h4>
<div>
<div>
<p>Converts this Collection to a List, discarding keys.</p> </div>
<pre data-language="ts">toList(): List&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toList()">Collection#toList()</a></code><h4>Discussion</h4>
<div>
<p>This is similar to <code><a href="../list/index.html">List(collection)</a></code>, but provided to allow for chained expressions. However, when called on <code><a href="../map/index.html">Map</a></code> or other keyed collections, <code>collection.toList()</code> discards the keys and creates a list of only the values, whereas <code><a href="../list/index.html">List(collection)</a></code> creates a list of entry tuples.</p>  <pre data-language="ts">const { Map, List } = require('immutable')
var myMap = Map({ a: 'Apple', b: 'Banana' })
List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
myMap.toList() // List [ "Apple", "Banana" ]run it</pre>
</div>
</div>
</div>
<div id="toStack()">
<h4><a href="index.html#toStack()">toStack()</a></h4>
<div>
<div>
<p>Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toStack(): Stack&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toStack()">Collection#toStack()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../stack/index.html">Stack(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<h3>Iterators</h3>
<div id="keys()">
<h4><a href="index.html#keys()">keys()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s keys.</p> </div>
<pre data-language="ts">keys(): IterableIterator&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keys()">Collection#keys()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#keySeq()">keySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="values()">
<h4><a href="index.html#values()">values()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s values.</p> </div>
<pre data-language="ts">values(): IterableIterator&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#values()">Collection#values()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#valueSeq()">valueSeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="entries()">
<h4><a href="index.html#entries()">entries()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s entries as <code>[ key, value ]</code> tuples.</p> </div>
<pre data-language="ts">entries(): IterableIterator&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entries()">Collection#entries()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#entrySeq()">entrySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<h3>Collections (Seq)</h3>
<div id="keySeq()">
<h4><a href="index.html#keySeq()">keySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of the keys of this Collection, discarding values.</p> </div>
<pre data-language="ts">keySeq(): Seq.Indexed&lt;K&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keySeq()">Collection#keySeq()</a></code>
</div>
</div>
<div id="valueSeq()">
<h4><a href="index.html#valueSeq()">valueSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">valueSeq(): Seq.Indexed&lt;V&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#valueSeq()">Collection#valueSeq()</a></code>
</div>
</div>
<div id="entrySeq()">
<h4><a href="index.html#entrySeq()">entrySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> </div>
<pre data-language="ts">entrySeq(): Seq.Indexed&lt;[K, V]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entrySeq()">Collection#entrySeq()</a></code>
</div>
</div>
<h3>Side effects</h3>
<div id="forEach()">
<h4><a href="index.html#forEach()">forEach()</a></h4>
<div>
<div>
<p>The <code>sideEffect</code> is executed for every entry in the Collection.</p> </div>
<pre data-language="ts">forEach(sideEffect: (value: V, key: K, iter: this) =&gt; unknown,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#forEach()">Collection#forEach()</a></code><h4>Discussion</h4>
<div>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> </div>
</div>
</div>
<h3>Creating subsets</h3>
<div id="slice()">
<h4><a href="index.html#slice()">slice()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.</p> </div>
<pre data-language="ts">slice(begin?: number, end?: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#slice()">Collection#slice()</a></code><h4>Discussion</h4>
<div>
<p>If begin is negative, it is offset from the end of the Collection. e.g. <code>slice(-2)</code> returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.</p> <p>If end is negative, it is offset from the end of the Collection. e.g. <code>slice(0, -1)</code> returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.</p> <p>If the requested slice is equivalent to the current Collection, then it will return itself.</p> </div>
</div>
</div>
<div id="rest()">
<h4><a href="index.html#rest()">rest()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the first.</p> </div>
<pre data-language="ts">rest(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#rest()">Collection#rest()</a></code>
</div>
</div>
<div id="butLast()">
<h4><a href="index.html#butLast()">butLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the last.</p> </div>
<pre data-language="ts">butLast(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#butLast()">Collection#butLast()</a></code>
</div>
</div>
<div id="skip()">
<h4><a href="index.html#skip()">skip()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skip(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skip()">Collection#skip()</a></code>
</div>
</div>
<div id="skipLast()">
<h4><a href="index.html#skipLast()">skipLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skipLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipLast()">Collection#skipLast()</a></code>
</div>
</div>
<div id="skipWhile()">
<h4><a href="index.html#skipWhile()">skipWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> </div>
<pre data-language="ts">skipWhile(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipWhile()">Collection#skipWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipWhile(x =&gt; x.match(/g/))
// List [ "cat", "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="skipUntil()">
<h4><a href="index.html#skipUntil()">skipUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> </div>
<pre data-language="ts">skipUntil(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipUntil()">Collection#skipUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipUntil(x =&gt; x.match(/hat/))
// List [ "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="take()">
<h4><a href="index.html#take()">take()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">take(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#take()">Collection#take()</a></code>
</div>
</div>
<div id="takeLast()">
<h4><a href="index.html#takeLast()">takeLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">takeLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeLast()">Collection#takeLast()</a></code>
</div>
</div>
<div id="takeWhile()">
<h4><a href="index.html#takeWhile()">takeWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">takeWhile(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeWhile()">Collection#takeWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeWhile(x =&gt; x.match(/o/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<div id="takeUntil()">
<h4><a href="index.html#takeUntil()">takeUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns false.</p> </div>
<pre data-language="ts">takeUntil(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeUntil()">Collection#takeUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeUntil(x =&gt; x.match(/at/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<h3>Combination</h3>
<div id="flatten()">
<h4><a href="index.html#flatten()">flatten()</a></h4>
<div>
<pre data-language="ts">flatten(depth?: number): Collection&lt;unknown, unknown&gt;
flatten(shallow?: boolean): Collection&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#flatten()">Collection#flatten()</a></code>
</div>
</div>
<h3>Reducing a value</h3>
<div id="reduce()">
<h4><a href="index.html#reduce()">reduce()</a></h4>
<div>
<pre data-language="ts">reduce&lt;R&gt;(reducer: (reduction: R, value: V, key: K, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduce&lt;R&gt;(reducer: (reduction: V | R, value: V, key: K, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduce()">Collection#reduce()</a></code>
</div>
</div>
<div id="reduceRight()">
<h4><a href="index.html#reduceRight()">reduceRight()</a></h4>
<div>
<pre data-language="ts">reduceRight&lt;R&gt;(reducer: (reduction: R, value: V, key: K, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduceRight&lt;R&gt;(reducer: (reduction: V | R, value: V, key: K, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduceRight()">Collection#reduceRight()</a></code>
</div>
</div>
<div id="every()">
<h4><a href="index.html#every()">every()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for all entries in the Collection.</p> </div>
<pre data-language="ts">every(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#every()">Collection#every()</a></code>
</div>
</div>
<div id="some()">
<h4><a href="index.html#some()">some()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for any entry in the Collection.</p> </div>
<pre data-language="ts">some(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#some()">Collection#some()</a></code>
</div>
</div>
<div id="join()">
<h4><a href="index.html#join()">join()</a></h4>
<div>
<div>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> </div>
<pre data-language="ts">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#join()">Collection#join()</a></code>
</div>
</div>
<div id="isEmpty()">
<h4><a href="index.html#isEmpty()">isEmpty()</a></h4>
<div>
<div>
<p>Returns true if this Collection includes no values.</p> </div>
<pre data-language="ts">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isEmpty()">Collection#isEmpty()</a></code><h4>Discussion</h4>
<div>
<p>For some lazy <code><a href="../seq/index.html">Seq</a></code>, <code><a href="../list/index.html#isEmpty()">isEmpty</a></code> might need to iterate to determine emptiness. At most one iteration will occur.</p> </div>
</div>
</div>
<div id="count()">
<h4><a href="index.html#count()">count()</a></h4>
<div>
<pre data-language="ts">count(): number
count(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#count()">Collection#count()</a></code>
</div>
</div>
<div id="countBy()">
<h4><a href="index.html#countBy()">countBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../seq.keyed/index.html">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">countBy&lt;G&gt;(grouper: (value: V, key: K, iter: this) =&gt; G,context?: unknown): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#countBy()">Collection#countBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is not a lazy operation.</p> </div>
</div>
</div>
<h3>Search for value</h3>
<div id="find()">
<h4><a href="index.html#find()">find()</a></h4>
<div>
<div>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">find(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#find()">Collection#find()</a></code>
</div>
</div>
<div id="findLast()">
<h4><a href="index.html#findLast()">findLast()</a></h4>
<div>
<div>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLast(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLast()">Collection#findLast()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findEntry()">
<h4><a href="index.html#findEntry()">findEntry()</a></h4>
<div>
<div>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findEntry(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findEntry()">Collection#findEntry()</a></code>
</div>
</div>
<div id="findLastEntry()">
<h4><a href="index.html#findLastEntry()">findLastEntry()</a></h4>
<div>
<div>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastEntry(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown,notSetValue?: V): [K, V] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastEntry()">Collection#findLastEntry()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findKey()">
<h4><a href="index.html#findKey()">findKey()</a></h4>
<div>
<div>
<p>Returns the key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findKey(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findKey()">Collection#findKey()</a></code>
</div>
</div>
<div id="findLastKey()">
<h4><a href="index.html#findLastKey()">findLastKey()</a></h4>
<div>
<div>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastKey(predicate: (value: V, key: K, iter: this) =&gt; boolean,context?: unknown): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastKey()">Collection#findLastKey()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="keyOf()">
<h4><a href="index.html#keyOf()">keyOf()</a></h4>
<div>
<div>
<p>Returns the key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">keyOf(searchValue: V): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keyOf()">Collection#keyOf()</a></code>
</div>
</div>
<div id="lastKeyOf()">
<h4><a href="index.html#lastKeyOf()">lastKeyOf()</a></h4>
<div>
<div>
<p>Returns the last key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">lastKeyOf(searchValue: V): K | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#lastKeyOf()">Collection#lastKeyOf()</a></code>
</div>
</div>
<div id="max()">
<h4><a href="index.html#max()">max()</a></h4>
<div>
<div>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">max(comparator?: (valueA: V, valueB: V) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#max()">Collection#max()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#max()">max</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="maxBy()">
<h4><a href="index.html#maxBy()">maxBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#max()">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">maxBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#maxBy()">Collection#maxBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.maxBy(i =&gt; i.avgHit); // will output { name: 'Max', avgHit: 3 }run it</pre></p> </div>
</div>
</div>
<div id="min()">
<h4><a href="index.html#min()">min()</a></h4>
<div>
<div>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">min(comparator?: (valueA: V, valueB: V) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#min()">Collection#min()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#min()">min</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="minBy()">
<h4><a href="index.html#minBy()">minBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#min()">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">minBy&lt;C&gt;(comparatorValueMapper: (value: V, key: K, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): V | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#minBy()">Collection#minBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.minBy(i =&gt; i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it</pre></p> </div>
</div>
</div>
<h3>Comparison</h3>
<div id="isSubset()">
<h4><a href="index.html#isSubset()">isSubset()</a></h4>
<div>
<div>
<p>True if <code>iter</code> includes every value in this Collection.</p> </div>
<pre data-language="ts">isSubset(iter: Iterable&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSubset()">Collection#isSubset()</a></code>
</div>
</div>
<div id="isSuperset()">
<h4><a href="index.html#isSuperset()">isSuperset()</a></h4>
<div>
<div>
<p>True if this Collection includes every value in <code>iter</code>.</p> </div>
<pre data-language="ts">isSuperset(iter: Iterable&lt;V&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSuperset()">Collection#isSuperset()</a></code>
</div>
</div>This documentation is generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts" rel="noopener">immutable.d.ts</a>. Pull requests and <a href="https://github.com/immutable-js/immutable-js/issues" rel="noopener">Issues</a> welcome.<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014–present, Lee Byron and other contributors<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://immutable-js.com/docs/v4.2.1/OrderedMap/" class="_attribution-link">https://immutable-js.com/docs/v4.2.1/OrderedMap/</a>
  </p>
</div>
