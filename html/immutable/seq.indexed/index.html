<h1>Seq.Indexed</h1>
<div>
<p><code><a href="../seq/index.html">Seq</a></code> which represents an ordered indexed list of values.</p> </div>
<pre data-language="ts">type Seq.Indexed&lt;T&gt; extends Seq&lt;number, T&gt;, Collection.Indexed&lt;T&gt;</pre>
<h3>Construction</h3>
<div id="Seq.Indexed()">
<h4><a href="index.html#Seq.Indexed()">Seq.Indexed()</a></h4>
<div>
<div>
<p>Always returns Seq.Indexed, discarding associated keys and supplying incrementing indices.</p> </div>
<pre data-language="ts">Seq.Indexed&lt;T&gt;(collection?: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;): Seq.Indexed&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html">Seq.Indexed</a></code> is a conversion function and not a class, and does not use the <code>new</code> keyword during construction.</p> </div>
</div>
</div>
<h3>Static methods</h3>
<div id="of()">
<h4><a href="index.html#of()">Seq.Indexed.of()</a></h4>
<div><pre data-language="ts">Seq.Indexed.of&lt;T&gt;(...values: Array&lt;T&gt;): Seq.Indexed&lt;T&gt;
</pre></div>
</div>
<h3>Conversion to JavaScript types</h3>
<div id="toJS()">
<h4><a href="index.html#toJS()">toJS()</a></h4>
<div>
<div>
<p>Deeply converts this Indexed Seq to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJS(): Array&lt;DeepCopy&lt;T&gt;&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toJS()">Collection#toJS()</a></code>
</div>
</div>
<div id="toJSON()">
<h4><a href="index.html#toJSON()">toJSON()</a></h4>
<div>
<div>
<p>Shallowly converts this Indexed Seq to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJSON(): Array&lt;T&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toJSON()">Collection#toJSON()</a></code>
</div>
</div>
<div id="toArray()">
<h4><a href="index.html#toArray()">toArray()</a></h4>
<div>
<div>
<p>Shallowly converts this collection to an Array.</p> </div>
<pre data-language="ts">toArray(): Array&lt;T&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toArray()">Collection#toArray()</a></code>
</div>
</div>
<div id="toObject()">
<h4><a href="index.html#toObject()">toObject()</a></h4>
<div>
<div>
<p>Shallowly converts this Collection to an Object.</p> </div>
<pre data-language="ts">toObject(): {[key: string]: T}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toObject()">Collection#toObject()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<h3>Conversion to Seq</h3>
<div id="toSeq()">
<h4><a href="index.html#toSeq()">toSeq()</a></h4>
<div>
<div>
<p>Returns itself</p> </div>
<pre data-language="ts">toSeq(): this
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#toSeq()">Collection#toSeq()</a></code>
</div>
</div>
<div id="toKeyedSeq()">
<h4><a href="index.html#toKeyedSeq()">toKeyedSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Keyed from this Collection where indices are treated as keys.</p> </div>
<pre data-language="ts">toKeyedSeq(): Seq.Keyed&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toKeyedSeq()">Collection#toKeyedSeq()</a></code><h4>Discussion</h4>
<div>
<p>This is useful if you want to operate on an Collection.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Collection.</p>  <pre data-language="ts">const { Seq } = require('immutable')
const indexedSeq = Seq([ 'A', 'B', 'C' ])
// Seq [ "A", "B", "C" ]
indexedSeq.filter(v =&gt; v === 'B')
// Seq [ "B" ]
const keyedSeq = indexedSeq.toKeyedSeq()
// Seq { 0: "A", 1: "B", 2: "C" }
keyedSeq.filter(v =&gt; v === 'B')
// Seq { 1: "B" }run it</pre>
</div>
</div>
</div>
<div id="toIndexedSeq()">
<h4><a href="index.html#toIndexedSeq()">toIndexedSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toIndexedSeq()">Collection#toIndexedSeq()</a></code>
</div>
</div>
<div id="toSetSeq()">
<h4><a href="index.html#toSetSeq()">toSetSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Set of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSetSeq()">Collection#toSetSeq()</a></code>
</div>
</div>
<div id="fromEntrySeq()">
<h4><a href="index.html#fromEntrySeq()">fromEntrySeq()</a></h4>
<div>
<div>
<p>If this is a collection of [key, value] entry tuples, it will return a Seq.Keyed of those entries.</p> </div>
<pre data-language="ts">fromEntrySeq(): Seq.Keyed&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#fromEntrySeq()">Collection.Indexed#fromEntrySeq()</a></code>
</div>
</div>
<h3>Combination</h3>
<div id="concat()">
<h4><a href="index.html#concat()">concat()</a></h4>
<div>
<div>
<p>Returns a new Seq with other collections concatenated to this one.</p> </div>
<pre data-language="ts">concat&lt;C&gt;(...valuesOrCollections: Array&lt;Iterable&lt;C&gt; | C&gt;): Seq.Indexed&lt;T | C&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#concat()">Collection#concat()</a></code>
</div>
</div>
<div id="zip()">
<h4><a href="index.html#zip()">zip()</a></h4>
<div>
<pre data-language="ts">zip&lt;U&gt;(other: Collection&lt;unknown, U&gt;): Seq.Indexed&lt;[T, U]&gt;
zip&lt;U, V&gt;(other: Collection&lt;unknown, U&gt;,other2: Collection&lt;unknown, V&gt;): Seq.Indexed&lt;[T, U, V]&gt;
zip(...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): Seq.Indexed&lt;unknown&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zip()">Collection.Indexed#zip()</a></code>
</div>
</div>
<div id="zipAll()">
<h4><a href="index.html#zipAll()">zipAll()</a></h4>
<div>
<pre data-language="ts">zipAll&lt;U&gt;(other: Collection&lt;unknown, U&gt;): Seq.Indexed&lt;[T, U]&gt;
zipAll&lt;U, V&gt;(other: Collection&lt;unknown, U&gt;,other2: Collection&lt;unknown, V&gt;): Seq.Indexed&lt;[T, U, V]&gt;
zipAll(...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): Seq.Indexed&lt;unknown&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zipAll()">Collection.Indexed#zipAll()</a></code>
</div>
</div>
<div id="zipWith()">
<h4><a href="index.html#zipWith()">zipWith()</a></h4>
<div>
<pre data-language="ts">zipWith&lt;U, Z&gt;(zipper: (value: T, otherValue: U) =&gt; Z,otherCollection: Collection&lt;unknown, U&gt;): Seq.Indexed&lt;Z&gt;
zipWith&lt;U, V, Z&gt;(zipper: (value: T, otherValue: U, thirdValue: V) =&gt; Z,otherCollection: Collection&lt;unknown, U&gt;,thirdCollection: Collection&lt;unknown, V&gt;): Seq.Indexed&lt;Z&gt;
zipWith&lt;Z&gt;(zipper: (...values: Array&lt;unknown&gt;) =&gt; Z,...collections: Array&lt;Collection&lt;unknown, unknown&gt;&gt;): Seq.Indexed&lt;Z&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.indexed/index.html#zipWith()">Collection.Indexed#zipWith()</a></code>
</div>
</div>
<div id="flatten()">
<h4><a href="index.html#flatten()">flatten()</a></h4>
<div>
<pre data-language="ts">flatten(depth?: number): Collection&lt;unknown, unknown&gt;
flatten(shallow?: boolean): Collection&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#flatten()">Collection#flatten()</a></code>
</div>
</div>
<div id="interpose()">
<h4><a href="index.html#interpose()">interpose()</a></h4>
<div>
<div>
<p>Returns a Collection of the same type with <code>separator</code> between each item in this Collection.</p> </div>
<pre data-language="ts">interpose(separator: T): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#interpose()">Collection.Indexed#interpose()</a></code>
</div>
</div>
<div id="interleave()">
<h4><a href="index.html#interleave()">interleave()</a></h4>
<div>
<div>
<p>Returns a Collection of the same type with the provided <code>collections</code> interleaved into this collection.</p> </div>
<pre data-language="ts">interleave(...collections: Array&lt;Collection&lt;unknown, T&gt;&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#interleave()">Collection.Indexed#interleave()</a></code><h4>Discussion</h4>
<div>
<p>The resulting Collection includes the first item from each, then the second from each, etc.</p>  <pre data-language="ts">const { List } = require('immutable')
List([ 1, 2, 3 ]).interleave(List([ 'A', 'B', 'C' ]))
// List [ 1, "A", 2, "B", 3, "C" ]run it</pre>
<p>The shortest Collection stops interleave.</p>  <pre data-language="ts">List([ 1, 2, 3 ]).interleave(
  List([ 'A', 'B' ]),
  List([ 'X', 'Y', 'Z' ])
)
// List [ 1, "A", "X", 2, "B", "Y" ]run it</pre>
<p>Since <code><a href="../list/index.html#interleave()">interleave()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="../list/index.html#interleave()">interleave</a></code> <em>cannot</em> be used in <code><a href="../list/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="splice()">
<h4><a href="index.html#splice()">splice()</a></h4>
<div>
<div>
<p>Splice returns a new indexed Collection by replacing a region of this Collection with new values. If values are not provided, it only skips the region to be removed.</p> </div>
<pre data-language="ts">splice(index: number, removeNum: number, ...values: Array&lt;T&gt;): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#splice()">Collection.Indexed#splice()</a></code><h4>Discussion</h4>
<div>
<p><code>index</code> may be a negative number, which indexes back from the end of the Collection. <code>s.splice(-2)</code> splices after the second to last item.</p>  <pre data-language="ts">const { List } = require('immutable')
List([ 'a', 'b', 'c', 'd' ]).splice(1, 2, 'q', 'r', 's')
// List [ "a", "q", "r", "s", "d" ]run it</pre>
<p>Since <code><a href="../list/index.html#splice()">splice()</a></code> re-indexes values, it produces a complete copy, which has <code>O(N)</code> complexity.</p> <p>Note: <code><a href="../list/index.html#splice()">splice</a></code> <em>cannot</em> be used in <code><a href="../list/index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<h3>Sequence algorithms</h3>
<div id="map()">
<h4><a href="index.html#map()">map()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed with values passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">map&lt;M&gt;(mapper: (value: T, key: number, iter: this) =&gt; M,context?: unknown): Seq.Indexed&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../seq/index.html#map()">Seq#map()</a></code><h4>Example</h4>
<div>
<pre data-language="ts">const { Seq } = require('immutable')
Seq.Indexed([ 1, 2 ]).map(x =&gt; 10 * x)
// Seq [ 10, 20 ]</pre>
<p>Note: <code><a href="index.html#map()">map()</a></code> always returns a new instance, even if it produced the same value at every step.</p> </div>
</div>
</div>
<div id="flatMap()">
<h4><a href="index.html#flatMap()">flatMap()</a></h4>
<div>
<div>
<p>Flat-maps the Seq, returning a a Seq of the same type.</p> </div>
<pre data-language="ts">flatMap&lt;M&gt;(mapper: (value: T, key: number, iter: this) =&gt; Iterable&lt;M&gt;,context?: unknown): Seq.Indexed&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../seq/index.html#flatMap()">Seq#flatMap()</a></code><h4>Discussion</h4>
<div>
<p>Similar to <code>seq.map(...).flatten(true)</code>.</p> </div>
</div>
</div>
<div id="filter()">
<h4><a href="index.html#filter()">filter()</a></h4>
<div>
<pre data-language="ts">filter&lt;F&gt;(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): Seq.Indexed&lt;F&gt;
filter(predicate: (value: T, index: number, iter: this) =&gt; unknown,context?: unknown): this
</pre>
<h4>Overrides</h4>
<code><a href="../seq/index.html#filter()">Seq#filter()</a></code>
</div>
</div>
<div id="partition()">
<h4><a href="index.html#partition()">partition()</a></h4>
<div>
<pre data-language="ts">partition&lt;F, C&gt;(predicate: (this: C, value: T, index: number, iter: this) =&gt; boolean,context?: C): [Seq.Indexed&lt;T&gt;, Seq.Indexed&lt;F&gt;]
partition&lt;C&gt;(predicate: (this: C, value: T, index: number, iter: this) =&gt; unknown,context?: C): [this, this]
</pre>
<h4>Overrides</h4>
<code><a href="../seq/index.html#partition()">Seq#partition()</a></code>
</div>
</div>
<div id="filterNot()">
<h4><a href="index.html#filterNot()">filterNot()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type with only the entries for which the <code>predicate</code> function returns false.</p> </div>
<pre data-language="ts">filterNot(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#filterNot()">Collection#filterNot()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x =&gt; x % 2 === 0)
// Map { "a": 1, "c": 3 }run it</pre></p>
<p>Note: <code><a href="../list/index.html#filterNot()">filterNot()</a></code> always returns a new instance, even if it results in not filtering out any values.</p> </div>
</div>
</div>
<div id="reverse()">
<h4><a href="index.html#reverse()">reverse()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type in reverse order.</p> </div>
<pre data-language="ts">reverse(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reverse()">Collection#reverse()</a></code>
</div>
</div>
<div id="sort()">
<h4><a href="index.html#sort()">sort()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> </div>
<pre data-language="ts">sort(comparator?: (valueA: T, valueB: T) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sort()">Collection#sort()</a></code><h4>Discussion</h4>
<div>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p>  <pre data-language="ts">const { Map } = require('immutable')
Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) =&gt; {
  if (a &lt; b) { return -1; }
  if (a &gt; b) { return 1; }
  if (a === b) { return 0; }
});
// OrderedMap { "a": 1, "b": 2, "c": 3 }run it</pre>
<p>Note: <code><a href="../list/index.html#sort()">sort()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="sortBy()">
<h4><a href="index.html#sortBy()">sortBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#sort()">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> </div>
<pre data-language="ts">sortBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sortBy()">Collection#sortBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const beattles = Map({
  John: { name: "Lennon" },
  Paul: { name: "McCartney" },
  George: { name: "Harrison" },
  Ringo: { name: "Starr" },
});
beattles.sortBy(member =&gt; member.name);run it</pre></p>
<p>Note: <code><a href="../list/index.html#sortBy()">sortBy()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="groupBy()">
<h4><a href="index.html#groupBy()">groupBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../collection.keyed/index.html">Collection.Keyed</a></code> of <code>Collection.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">groupBy&lt;G&gt;(grouper: (value: T, key: number, iter: this) =&gt; G,context?: unknown): Seq.Keyed&lt;G, Collection&lt;number, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#groupBy()">Collection#groupBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is always an eager operation.</p>  <pre data-language="ts">const { List, Map } = require('immutable')
const listOfMaps = List([
  Map({ v: 0 }),
  Map({ v: 1 }),
  Map({ v: 1 }),
  Map({ v: 0 }),
  Map({ v: 2 })
])
const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))
// Map {
//   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
//   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
//   2: List [ Map{ "v": 2 } ],
// }run it</pre>
</div>
</div>
</div>
<h3>Iterators</h3>
<div id="[Symbol.iterator]()">
<h4><a href="index.html#%5BSymbol.iterator%5D()">[Symbol.iterator]()</a></h4>
<div>
<pre data-language="ts">[Symbol.iterator](): IterableIterator&lt;T&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection/index.html#%5BSymbol.iterator%5D()">Collection#[Symbol.iterator]()</a></code>
</div>
</div>
<div id="keys()">
<h4><a href="index.html#keys()">keys()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s keys.</p> </div>
<pre data-language="ts">keys(): IterableIterator&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keys()">Collection#keys()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#keySeq()">keySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="values()">
<h4><a href="index.html#values()">values()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s values.</p> </div>
<pre data-language="ts">values(): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#values()">Collection#values()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#valueSeq()">valueSeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="entries()">
<h4><a href="index.html#entries()">entries()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s entries as <code>[ key, value ]</code> tuples.</p> </div>
<pre data-language="ts">entries(): IterableIterator&lt;[number, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entries()">Collection#entries()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#entrySeq()">entrySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<h3>Members</h3>
<div id="size">
<h4><a href="index.html#size">size</a></h4>
<div>
<div>
<p>Some Seqs can describe their size lazily. When this is the case, size will be an integer. Otherwise it will be undefined.</p> </div>
<pre data-language="ts">size: number | undefined</pre>
<h4>Inherited from</h4>
<code><a href="../seq/index.html#size">Seq#size</a></code><h4>Discussion</h4>
<div>
<p>For example, Seqs returned from <code><a href="../seq/index.html#map()">map()</a></code> or <code><a href="../seq/index.html#reverse()">reverse()</a></code> preserve the size of the original <code><a href="../seq/index.html">Seq</a></code> while <code><a href="../seq/index.html#filter()">filter()</a></code> does not.</p> <p>Note: <code><a href="../range()/index.html">Range</a></code>, <code><a href="../repeat()/index.html">Repeat</a></code> and <code><a href="../seq/index.html">Seq</a></code>s made from <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array" rel="noopener">Array</a></code>s and <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" rel="noopener">Object</a></code>s will always have a size.</p> </div>
</div>
</div>
<h3>Force evaluation</h3>
<div id="cacheResult()">
<h4><a href="index.html#cacheResult()">cacheResult()</a></h4>
<div>
<div>
<p>Because Sequences are lazy and designed to be chained together, they do not cache their results. For example, this map function is called a total of 6 times, as each <code><a href="../seq/index.html#join()">join</a></code> iterates the Seq of three values.</p> </div>
<pre data-language="ts">cacheResult(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../seq/index.html#cacheResult()">Seq#cacheResult()</a></code><h4>Discussion</h4>
<div>
<p><pre data-language="ts">var squares = Seq([ 1, 2, 3 ]).map(x =&gt; x  x)
squares.join() + squares.join()</pre></p>
<p>If you know a <code><a href="../seq/index.html">Seq</a></code> will be used multiple times, it may be more efficient to first cache it in memory. Here, the map function is called only 3 times.</p> <pre data-language="ts">var squares = Seq([ 1, 2, 3 ]).map(x =&gt; x  x).cacheResult()
squares.join() + squares.join()</pre>
<p>Use this method judiciously, as it must fully evaluate a Seq which can be a burden on memory and possibly performance.</p> <p>Note: after calling <code><a href="../seq/index.html#cacheResult()">cacheResult</a></code>, a Seq will always have a <code><a href="../seq/index.html#size">size</a></code>.</p> </div>
</div>
</div>
<h3>Value equality</h3>
<div id="equals()">
<h4><a href="index.html#equals()">equals()</a></h4>
<div>
<div>
<p>True if this and the other Collection have value equality, as defined by <code><a href="../is()/index.html">Immutable.is()</a></code>.</p> </div>
<pre data-language="ts">equals(other: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#equals()">Collection#equals()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="hashCode()">
<h4><a href="index.html#hashCode()">hashCode()</a></h4>
<div>
<div>
<p>Computes and returns the hashed identity for this Collection.</p> </div>
<pre data-language="ts">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hashCode()">Collection#hashCode()</a></code><h4>Discussion</h4>
<div>
<p>The <code><a href="../list/index.html#hashCode()">hashCode</a></code> of a Collection is used to determine potential equality, and is used when adding this to a <code><a href="../set/index.html">Set</a></code> or as a key in a <code><a href="../map/index.html">Map</a></code>, enabling lookup via a different instance.</p>  <pre data-language="ts">const a = List([ 1, 2, 3 ]);
const b = List([ 1, 2, 3 ]);
assert.notStrictEqual(a, b); // different instances
const set = Set([ a ]);
assert.equal(set.has(b), true);run it</pre>
<p>If two values have the same <code><a href="../list/index.html#hashCode()">hashCode</a></code>, they are <a href="https://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code><a href="../list/index.html#hashCode()">hashCode</a></code>s, they must not be equal.</p> </div>
</div>
</div>
<h3>Reading values</h3>
<div id="get()">
<h4><a href="index.html#get()">get()</a></h4>
<div>
<pre data-language="ts">get&lt;NSV&gt;(key: number, notSetValue: NSV): T | NSV
get(key: number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#get()">Collection#get()</a></code>
</div>
</div>
<div id="has()">
<h4><a href="index.html#has()">has()</a></h4>
<div>
<div>
<p>True if a key exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">has(key: number): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#has()">Collection#has()</a></code>
</div>
</div>
<div id="includes()">
<h4><a href="index.html#includes()">includes()</a></h4>
<div>
<div>
<p>True if a value exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#includes()">Collection#includes()</a></code><h4>alias</h4>
<code>contains()</code>
</div>
</div>
<div id="first()">
<h4><a href="index.html#first()">first()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the first element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">first&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#first()">Collection#first()</a></code>
</div>
</div>
<div id="last()">
<h4><a href="index.html#last()">last()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the last element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">last&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#last()">Collection#last()</a></code>
</div>
</div>
<h3>Reading deep values</h3>
<div id="getIn()">
<h4><a href="index.html#getIn()">getIn()</a></h4>
<div>
<div>
<p>Returns the value found by following a path of keys or indices through nested Collections.</p> </div>
<pre data-language="ts">getIn(searchKeyPath: Iterable&lt;unknown&gt;, notSetValue?: unknown): unknown
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#getIn()">Collection#getIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:</p>  <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: [ { y: 123 } ] });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p> </div>
</div>
</div>
<div id="hasIn()">
<h4><a href="index.html#hasIn()">hasIn()</a></h4>
<div>
<div>
<p>True if the result of following a path of keys or indices through nested Collections results in a set value.</p> </div>
<pre data-language="ts">hasIn(searchKeyPath: Iterable&lt;unknown&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hasIn()">Collection#hasIn()</a></code>
</div>
</div>
<h3>Persistent changes</h3>
<div id="update()">
<h4><a href="index.html#update()">update()</a></h4>
<div>
<div>
<p>This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".</p> </div>
<pre data-language="ts">update&lt;R&gt;(updater: (value: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#update()">Collection#update()</a></code><h4>Discussion</h4>
<div>
<p>For example, to sum a Seq after mapping and filtering:</p>  <pre data-language="ts">const { Seq } = require('immutable')

function sum(collection) {
  return collection.reduce((sum, x) =&gt; sum + x, 0)
}
Seq([ 1, 2, 3 ])
  .map(x =&gt; x + 1)
  .filter(x =&gt; x % 2 === 0)
  .update(sum)
// 6run it</pre> </div>
</div>
</div>
<h3>Conversion to Collections</h3>
<div id="toMap()">
<h4><a href="index.html#toMap()">toMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, Throws if keys are not hashable.</p> </div>
<pre data-language="ts">toMap(): Map&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toMap()">Collection#toMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedMap()">
<h4><a href="index.html#toOrderedMap()">toOrderedMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, maintaining the order of iteration.</p> </div>
<pre data-language="ts">toOrderedMap(): OrderedMap&lt;number, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedMap()">Collection#toOrderedMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toSet()">
<h4><a href="index.html#toSet()">toSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSet()">Collection#toSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../set/index.html">Set(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedSet()">
<h4><a href="index.html#toOrderedSet()">toOrderedSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, maintaining the order of iteration and discarding keys.</p> </div>
<pre data-language="ts">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedSet()">Collection#toOrderedSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toList()">
<h4><a href="index.html#toList()">toList()</a></h4>
<div>
<div>
<p>Converts this Collection to a List, discarding keys.</p> </div>
<pre data-language="ts">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toList()">Collection#toList()</a></code><h4>Discussion</h4>
<div>
<p>This is similar to <code><a href="../list/index.html">List(collection)</a></code>, but provided to allow for chained expressions. However, when called on <code><a href="../map/index.html">Map</a></code> or other keyed collections, <code>collection.toList()</code> discards the keys and creates a list of only the values, whereas <code><a href="../list/index.html">List(collection)</a></code> creates a list of entry tuples.</p>  <pre data-language="ts">const { Map, List } = require('immutable')
var myMap = Map({ a: 'Apple', b: 'Banana' })
List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
myMap.toList() // List [ "Apple", "Banana" ]run it</pre>
</div>
</div>
</div>
<div id="toStack()">
<h4><a href="index.html#toStack()">toStack()</a></h4>
<div>
<div>
<p>Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toStack()">Collection#toStack()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../stack/index.html">Stack(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<h3>Collections (Seq)</h3>
<div id="keySeq()">
<h4><a href="index.html#keySeq()">keySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of the keys of this Collection, discarding values.</p> </div>
<pre data-language="ts">keySeq(): Seq.Indexed&lt;number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keySeq()">Collection#keySeq()</a></code>
</div>
</div>
<div id="valueSeq()">
<h4><a href="index.html#valueSeq()">valueSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#valueSeq()">Collection#valueSeq()</a></code>
</div>
</div>
<div id="entrySeq()">
<h4><a href="index.html#entrySeq()">entrySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> </div>
<pre data-language="ts">entrySeq(): Seq.Indexed&lt;[number, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entrySeq()">Collection#entrySeq()</a></code>
</div>
</div>
<h3>Side effects</h3>
<div id="forEach()">
<h4><a href="index.html#forEach()">forEach()</a></h4>
<div>
<div>
<p>The <code>sideEffect</code> is executed for every entry in the Collection.</p> </div>
<pre data-language="ts">forEach(sideEffect: (value: T, key: number, iter: this) =&gt; unknown,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#forEach()">Collection#forEach()</a></code><h4>Discussion</h4>
<div>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> </div>
</div>
</div>
<h3>Creating subsets</h3>
<div id="slice()">
<h4><a href="index.html#slice()">slice()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.</p> </div>
<pre data-language="ts">slice(begin?: number, end?: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#slice()">Collection#slice()</a></code><h4>Discussion</h4>
<div>
<p>If begin is negative, it is offset from the end of the Collection. e.g. <code>slice(-2)</code> returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.</p> <p>If end is negative, it is offset from the end of the Collection. e.g. <code>slice(0, -1)</code> returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.</p> <p>If the requested slice is equivalent to the current Collection, then it will return itself.</p> </div>
</div>
</div>
<div id="rest()">
<h4><a href="index.html#rest()">rest()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the first.</p> </div>
<pre data-language="ts">rest(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#rest()">Collection#rest()</a></code>
</div>
</div>
<div id="butLast()">
<h4><a href="index.html#butLast()">butLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the last.</p> </div>
<pre data-language="ts">butLast(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#butLast()">Collection#butLast()</a></code>
</div>
</div>
<div id="skip()">
<h4><a href="index.html#skip()">skip()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skip(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skip()">Collection#skip()</a></code>
</div>
</div>
<div id="skipLast()">
<h4><a href="index.html#skipLast()">skipLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skipLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipLast()">Collection#skipLast()</a></code>
</div>
</div>
<div id="skipWhile()">
<h4><a href="index.html#skipWhile()">skipWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> </div>
<pre data-language="ts">skipWhile(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipWhile()">Collection#skipWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipWhile(x =&gt; x.match(/g/))
// List [ "cat", "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="skipUntil()">
<h4><a href="index.html#skipUntil()">skipUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> </div>
<pre data-language="ts">skipUntil(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipUntil()">Collection#skipUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipUntil(x =&gt; x.match(/hat/))
// List [ "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="take()">
<h4><a href="index.html#take()">take()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">take(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#take()">Collection#take()</a></code>
</div>
</div>
<div id="takeLast()">
<h4><a href="index.html#takeLast()">takeLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">takeLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeLast()">Collection#takeLast()</a></code>
</div>
</div>
<div id="takeWhile()">
<h4><a href="index.html#takeWhile()">takeWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">takeWhile(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeWhile()">Collection#takeWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeWhile(x =&gt; x.match(/o/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<div id="takeUntil()">
<h4><a href="index.html#takeUntil()">takeUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns false.</p> </div>
<pre data-language="ts">takeUntil(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeUntil()">Collection#takeUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeUntil(x =&gt; x.match(/at/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<h3>Reducing a value</h3>
<div id="reduce()">
<h4><a href="index.html#reduce()">reduce()</a></h4>
<div>
<pre data-language="ts">reduce&lt;R&gt;(reducer: (reduction: R, value: T, key: number, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduce&lt;R&gt;(reducer: (reduction: T | R, value: T, key: number, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduce()">Collection#reduce()</a></code>
</div>
</div>
<div id="reduceRight()">
<h4><a href="index.html#reduceRight()">reduceRight()</a></h4>
<div>
<pre data-language="ts">reduceRight&lt;R&gt;(reducer: (reduction: R, value: T, key: number, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduceRight&lt;R&gt;(reducer: (reduction: T | R, value: T, key: number, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduceRight()">Collection#reduceRight()</a></code>
</div>
</div>
<div id="every()">
<h4><a href="index.html#every()">every()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for all entries in the Collection.</p> </div>
<pre data-language="ts">every(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#every()">Collection#every()</a></code>
</div>
</div>
<div id="some()">
<h4><a href="index.html#some()">some()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for any entry in the Collection.</p> </div>
<pre data-language="ts">some(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#some()">Collection#some()</a></code>
</div>
</div>
<div id="join()">
<h4><a href="index.html#join()">join()</a></h4>
<div>
<div>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> </div>
<pre data-language="ts">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#join()">Collection#join()</a></code>
</div>
</div>
<div id="isEmpty()">
<h4><a href="index.html#isEmpty()">isEmpty()</a></h4>
<div>
<div>
<p>Returns true if this Collection includes no values.</p> </div>
<pre data-language="ts">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isEmpty()">Collection#isEmpty()</a></code><h4>Discussion</h4>
<div>
<p>For some lazy <code><a href="../seq/index.html">Seq</a></code>, <code><a href="../list/index.html#isEmpty()">isEmpty</a></code> might need to iterate to determine emptiness. At most one iteration will occur.</p> </div>
</div>
</div>
<div id="count()">
<h4><a href="index.html#count()">count()</a></h4>
<div>
<pre data-language="ts">count(): number
count(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#count()">Collection#count()</a></code>
</div>
</div>
<div id="countBy()">
<h4><a href="index.html#countBy()">countBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../seq.keyed/index.html">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">countBy&lt;G&gt;(grouper: (value: T, key: number, iter: this) =&gt; G,context?: unknown): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#countBy()">Collection#countBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is not a lazy operation.</p> </div>
</div>
</div>
<h3>Search for value</h3>
<div id="find()">
<h4><a href="index.html#find()">find()</a></h4>
<div>
<div>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">find(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#find()">Collection#find()</a></code>
</div>
</div>
<div id="findLast()">
<h4><a href="index.html#findLast()">findLast()</a></h4>
<div>
<div>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLast(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLast()">Collection#findLast()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findEntry()">
<h4><a href="index.html#findEntry()">findEntry()</a></h4>
<div>
<div>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findEntry(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findEntry()">Collection#findEntry()</a></code>
</div>
</div>
<div id="findLastEntry()">
<h4><a href="index.html#findLastEntry()">findLastEntry()</a></h4>
<div>
<div>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastEntry(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [number, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastEntry()">Collection#findLastEntry()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findKey()">
<h4><a href="index.html#findKey()">findKey()</a></h4>
<div>
<div>
<p>Returns the key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findKey(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findKey()">Collection#findKey()</a></code>
</div>
</div>
<div id="findLastKey()">
<h4><a href="index.html#findLastKey()">findLastKey()</a></h4>
<div>
<div>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastKey(predicate: (value: T, key: number, iter: this) =&gt; boolean,context?: unknown): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastKey()">Collection#findLastKey()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="keyOf()">
<h4><a href="index.html#keyOf()">keyOf()</a></h4>
<div>
<div>
<p>Returns the key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">keyOf(searchValue: T): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keyOf()">Collection#keyOf()</a></code>
</div>
</div>
<div id="lastKeyOf()">
<h4><a href="index.html#lastKeyOf()">lastKeyOf()</a></h4>
<div>
<div>
<p>Returns the last key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">lastKeyOf(searchValue: T): number | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#lastKeyOf()">Collection#lastKeyOf()</a></code>
</div>
</div>
<div id="max()">
<h4><a href="index.html#max()">max()</a></h4>
<div>
<div>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">max(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#max()">Collection#max()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#max()">max</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="maxBy()">
<h4><a href="index.html#maxBy()">maxBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#max()">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">maxBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#maxBy()">Collection#maxBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.maxBy(i =&gt; i.avgHit); // will output { name: 'Max', avgHit: 3 }run it</pre></p> </div>
</div>
</div>
<div id="min()">
<h4><a href="index.html#min()">min()</a></h4>
<div>
<div>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">min(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#min()">Collection#min()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#min()">min</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="minBy()">
<h4><a href="index.html#minBy()">minBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#min()">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">minBy&lt;C&gt;(comparatorValueMapper: (value: T, key: number, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#minBy()">Collection#minBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.minBy(i =&gt; i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it</pre></p> </div>
</div>
</div>
<div id="indexOf()">
<h4><a href="index.html#indexOf()">indexOf()</a></h4>
<div>
<div>
<p>Returns the first index at which a given value can be found in the Collection, or -1 if it is not present.</p> </div>
<pre data-language="ts">indexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#indexOf()">Collection.Indexed#indexOf()</a></code>
</div>
</div>
<div id="lastIndexOf()">
<h4><a href="index.html#lastIndexOf()">lastIndexOf()</a></h4>
<div>
<div>
<p>Returns the last index at which a given value can be found in the Collection, or -1 if it is not present.</p> </div>
<pre data-language="ts">lastIndexOf(searchValue: T): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#lastIndexOf()">Collection.Indexed#lastIndexOf()</a></code>
</div>
</div>
<div id="findIndex()">
<h4><a href="index.html#findIndex()">findIndex()</a></h4>
<div>
<div>
<p>Returns the first index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> </div>
<pre data-language="ts">findIndex(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#findIndex()">Collection.Indexed#findIndex()</a></code>
</div>
</div>
<div id="findLastIndex()">
<h4><a href="index.html#findLastIndex()">findLastIndex()</a></h4>
<div>
<div>
<p>Returns the last index in the Collection where a value satisfies the provided predicate function. Otherwise -1 is returned.</p> </div>
<pre data-language="ts">findLastIndex(predicate: (value: T, index: number, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.indexed/index.html#findLastIndex()">Collection.Indexed#findLastIndex()</a></code>
</div>
</div>
<h3>Comparison</h3>
<div id="isSubset()">
<h4><a href="index.html#isSubset()">isSubset()</a></h4>
<div>
<div>
<p>True if <code>iter</code> includes every value in this Collection.</p> </div>
<pre data-language="ts">isSubset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSubset()">Collection#isSubset()</a></code>
</div>
</div>
<div id="isSuperset()">
<h4><a href="index.html#isSuperset()">isSuperset()</a></h4>
<div>
<div>
<p>True if this Collection includes every value in <code>iter</code>.</p> </div>
<pre data-language="ts">isSuperset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSuperset()">Collection#isSuperset()</a></code>
</div>
</div>This documentation is generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts" rel="noopener">immutable.d.ts</a>. Pull requests and <a href="https://github.com/immutable-js/immutable-js/issues" rel="noopener">Issues</a> welcome.<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014–present, Lee Byron and other contributors<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://immutable-js.com/docs/v4.2.1/Seq.Indexed/" class="_attribution-link">https://immutable-js.com/docs/v4.2.1/Seq.Indexed/</a>
  </p>
</div>
