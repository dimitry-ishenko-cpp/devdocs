<h1>Set</h1>
<div>
<p>A Collection of unique values with <code>O(log32 N)</code> adds and has.</p> </div>
<pre data-language="ts">type Set&lt;T&gt; extends Collection.Set&lt;T&gt;</pre>
<h4>Discussion</h4>
<div>
<p>When iterating a Set, the entries will be (value, value) pairs. Iteration order of a Set is undefined, however is stable. Multiple iterations of the same Set will iterate in the same order.</p> <p>Set values, like Map keys, may be of any type. Equality is determined using <code><a href="../is()/index.html">Immutable.is</a></code>, enabling Sets to uniquely include other Immutable collections, custom value types, and NaN.</p> </div>
<h3>Construction</h3>
<div id="Set()">
<h4><a href="index.html#Set()">Set()</a></h4>
<div>
<div>
<p>Create a new immutable Set containing the values of the provided collection-like.</p> </div>
<pre data-language="ts">Set&lt;T&gt;(collection?: Iterable&lt;T&gt; | ArrayLike&lt;T&gt;): Set&lt;T&gt;
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html">Set</a></code> is a factory function and not a class, and does not use the <code>new</code> keyword during construction.</p> </div>
</div>
</div>
<h3>Static methods</h3>
<div id="isSet()">
<h4><a href="index.html#isSet()">Set.isSet()</a></h4>
<div><pre data-language="ts">Set.isSet(maybeSet: unknown): boolean
</pre></div>
</div>
<div id="of()">
<h4><a href="index.html#of()">Set.of()</a></h4>
<div><pre data-language="ts">Set.of&lt;T&gt;(...values: Array&lt;T&gt;): Set&lt;T&gt;
</pre></div>
</div>
<div id="fromKeys()">
<h4><a href="index.html#fromKeys()">Set.fromKeys()</a></h4>
<div><pre data-language="ts">Set.fromKeys&lt;T&gt;(iter: Collection&lt;T, unknown&gt;): Set&lt;T&gt;
Set.fromKeys(obj: {[key: string]: unknown}): Set&lt;string&gt;
</pre></div>
</div>
<div id="intersect()">
<h4><a href="index.html#intersect()">Set.intersect()</a></h4>
<div><pre data-language="ts">Set.intersect&lt;T&gt;(sets: Iterable&lt;Iterable&lt;T&gt;&gt;): Set&lt;T&gt;
</pre></div>
</div>
<div id="union()">
<h4><a href="index.html#union()">Set.union()</a></h4>
<div><pre data-language="ts">Set.union&lt;T&gt;(sets: Iterable&lt;Iterable&lt;T&gt;&gt;): Set&lt;T&gt;
</pre></div>
</div>
<h3>Members</h3>
<div id="size">
<h4><a href="index.html#size">size</a></h4>
<div>
<div>
<p>The number of items in this Set.</p> </div>
<pre data-language="ts">size: number</pre>
</div>
</div>
<h3>Persistent changes</h3>
<div id="add()">
<h4><a href="index.html#add()">add()</a></h4>
<div>
<div>
<p>Returns a new Set which also includes this value.</p> </div>
<pre data-language="ts">add(value: T): this
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#add()">add</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="delete()">
<h4><a href="index.html#delete()">delete()</a></h4>
<div>
<div>
<p>Returns a new Set which excludes this value.</p> </div>
<pre data-language="ts">delete(value: T): this
</pre>
<h4>alias</h4>
<code>remove()</code><h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#delete()">delete</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> <p>Note: <code><a href="index.html#delete()">delete</a></code> <strong>cannot</strong> be safely used in IE8, use <code><a href="../remove()/index.html">remove</a></code> if supporting old browsers.</p> </div>
</div>
</div>
<div id="clear()">
<h4><a href="index.html#clear()">clear()</a></h4>
<div>
<div>
<p>Returns a new Set containing no values.</p> </div>
<pre data-language="ts">clear(): this
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#clear()">clear</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="union()">
<h4><a href="index.html#union()">union()</a></h4>
<div>
<div>
<p>Returns a Set including any value from <code>collections</code> that does not already exist in this Set.</p> </div>
<pre data-language="ts">union&lt;C&gt;(...collections: Array&lt;Iterable&lt;C&gt;&gt;): Set&lt;T | C&gt;
</pre>
<h4>alias</h4>
<code>merge()</code><h4>alias</h4>
<code>concat()</code><h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#union()">union</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="intersect()">
<h4><a href="index.html#intersect()">intersect()</a></h4>
<div>
<div>
<p>Returns a Set which has removed any values not also contained within <code>collections</code>.</p> </div>
<pre data-language="ts">intersect(...collections: Array&lt;Iterable&lt;T&gt;&gt;): this
</pre>
<h4>Discussion</h4>
<div>
<p>Note: <code><a href="index.html#intersect()">intersect</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="subtract()">
<h4><a href="index.html#subtract()">subtract()</a></h4>
<div>
<div>
<p>Returns a Set excluding any values contained within <code>collections</code>.</p> </div>
<pre data-language="ts">subtract(...collections: Array&lt;Iterable&lt;T&gt;&gt;): this
</pre>
<h4>Discussion</h4>
<div> <p><pre data-language="ts">const { OrderedSet } = require('immutable')
OrderedSet([ 1, 2, 3 ]).subtract([1, 3])
// OrderedSet [2]run it</pre></p>
<p>Note: <code><a href="index.html#subtract()">subtract</a></code> can be used in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
</div>
</div>
<div id="update()">
<h4><a href="index.html#update()">update()</a></h4>
<div>
<div>
<p>This can be very useful as a way to "chain" a normal function into a sequence of methods. RxJS calls this "let" and lodash calls it "thru".</p> </div>
<pre data-language="ts">update&lt;R&gt;(updater: (value: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#update()">Collection#update()</a></code><h4>Discussion</h4>
<div>
<p>For example, to sum a Seq after mapping and filtering:</p>  <pre data-language="ts">const { Seq } = require('immutable')

function sum(collection) {
  return collection.reduce((sum, x) =&gt; sum + x, 0)
}
Seq([ 1, 2, 3 ])
  .map(x =&gt; x + 1)
  .filter(x =&gt; x % 2 === 0)
  .update(sum)
// 6run it</pre> </div>
</div>
</div>
<h3>Transient changes</h3>
<div id="withMutations()">
<h4><a href="index.html#withMutations()">withMutations()</a></h4>
<div>
<div>
<p>Note: Not all methods can be used on a mutable collection or within <code><a href="index.html#withMutations()">withMutations</a></code>! Check the documentation for each method to see if it mentions being safe to use in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
<pre data-language="ts">withMutations(mutator: (mutable: this) =&gt; unknown): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#withMutations()">Map#withMutations</a></code></p> </div>
</div>
</div>
<div id="asMutable()">
<h4><a href="index.html#asMutable()">asMutable()</a></h4>
<div>
<div>
<p>Note: Not all methods can be used on a mutable collection or within <code><a href="index.html#withMutations()">withMutations</a></code>! Check the documentation for each method to see if it mentions being safe to use in <code><a href="index.html#withMutations()">withMutations</a></code>.</p> </div>
<pre data-language="ts">asMutable(): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#asMutable()">Map#asMutable</a></code></p> </div>
</div>
</div>
<div id="wasAltered()">
<h4><a href="index.html#wasAltered()">wasAltered()</a></h4>
<div>

<pre data-language="ts">wasAltered(): boolean
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#wasAltered()">Map#wasAltered</a></code></p> </div>
</div>
</div>
<div id="asImmutable()">
<h4><a href="index.html#asImmutable()">asImmutable()</a></h4>
<div>

<pre data-language="ts">asImmutable(): this
</pre>
<h4>see</h4>
<div>
<p><code><a href="../map/index.html#asImmutable()">Map#asImmutable</a></code></p> </div>
</div>
</div>
<h3>Sequence algorithms</h3>
<div id="map()">
<h4><a href="index.html#map()">map()</a></h4>
<div>
<div>
<p>Returns a new Set with values passed through a <code>mapper</code> function.</p> </div>
<pre data-language="ts">map&lt;M&gt;(mapper: (value: T, key: T, iter: this) =&gt; M, context?: unknown): Set&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.set/index.html#map()">Collection.Set#map()</a></code><h4>Example</h4>
<div><pre data-language="ts">Set([1,2]).map(x =&gt; 10 * x)
// Set [10,20]</pre></div>
</div>
</div>
<div id="flatMap()">
<h4><a href="index.html#flatMap()">flatMap()</a></h4>
<div>
<div>
<p>Flat-maps the Set, returning a new Set.</p> </div>
<pre data-language="ts">flatMap&lt;M&gt;(mapper: (value: T, key: T, iter: this) =&gt; Iterable&lt;M&gt;,context?: unknown): Set&lt;M&gt;
</pre>
<h4>Overrides</h4>
<code><a href="../collection.set/index.html#flatMap()">Collection.Set#flatMap()</a></code><h4>Discussion</h4>
<div>
<p>Similar to <code>set.map(...).flatten(true)</code>.</p> </div>
</div>
</div>
<div id="filter()">
<h4><a href="index.html#filter()">filter()</a></h4>
<div>
<pre data-language="ts">filter&lt;F&gt;(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): Set&lt;F&gt;
filter(predicate: (value: T, key: T, iter: this) =&gt; unknown,context?: unknown): this
</pre>
<h4>Overrides</h4>
<code><a href="../collection.set/index.html#filter()">Collection.Set#filter()</a></code>
</div>
</div>
<div id="partition()">
<h4><a href="index.html#partition()">partition()</a></h4>
<div>
<pre data-language="ts">partition&lt;F, C&gt;(predicate: (this: C, value: T, key: T, iter: this) =&gt; boolean,context?: C): [Set&lt;T&gt;, Set&lt;F&gt;]
partition&lt;C&gt;(predicate: (this: C, value: T, key: T, iter: this) =&gt; unknown,context?: C): [this, this]
</pre>
<h4>Overrides</h4>
<code><a href="../collection.set/index.html#partition()">Collection.Set#partition()</a></code>
</div>
</div>
<div id="concat()">
<h4><a href="index.html#concat()">concat()</a></h4>
<div>
<div>
<p>Returns a new Collection with other collections concatenated to this one.</p> </div>
<pre data-language="ts">concat&lt;U&gt;(...collections: Array&lt;Iterable&lt;U&gt;&gt;): Collection.Set&lt;T | U&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#concat()">Collection.Set#concat()</a></code>
</div>
</div>
<div id="[Symbol.iterator]()">
<h4><a href="index.html#%5BSymbol.iterator%5D()">[Symbol.iterator]()</a></h4>
<div>
<pre data-language="ts">[Symbol.iterator](): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#%5BSymbol.iterator%5D()">Collection.Set#[Symbol.iterator]()</a></code>
</div>
</div>
<div id="filterNot()">
<h4><a href="index.html#filterNot()">filterNot()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type with only the entries for which the <code>predicate</code> function returns false.</p> </div>
<pre data-language="ts">filterNot(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#filterNot()">Collection#filterNot()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
Map({ a: 1, b: 2, c: 3, d: 4}).filterNot(x =&gt; x % 2 === 0)
// Map { "a": 1, "c": 3 }run it</pre></p>
<p>Note: <code><a href="../list/index.html#filterNot()">filterNot()</a></code> always returns a new instance, even if it results in not filtering out any values.</p> </div>
</div>
</div>
<div id="reverse()">
<h4><a href="index.html#reverse()">reverse()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type in reverse order.</p> </div>
<pre data-language="ts">reverse(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reverse()">Collection#reverse()</a></code>
</div>
</div>
<div id="sort()">
<h4><a href="index.html#sort()">sort()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the same entries, stably sorted by using a <code>comparator</code>.</p> </div>
<pre data-language="ts">sort(comparator?: (valueA: T, valueB: T) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sort()">Collection#sort()</a></code><h4>Discussion</h4>
<div>
<p>If a <code>comparator</code> is not provided, a default comparator uses <code>&lt;</code> and <code>&gt;</code>.</p> <p><code>comparator(valueA, valueB)</code>:</p> <ul> <li>Returns <code>0</code> if the elements should not be swapped.</li> <li>Returns <code>-1</code> (or any negative number) if <code>valueA</code> comes before <code>valueB</code>
</li> <li>Returns <code>1</code> (or any positive number) if <code>valueA</code> comes after <code>valueB</code>
</li> <li>Is pure, i.e. it must always return the same value for the same pair of values.</li> </ul> <p>When sorting collections which have no defined order, their ordered equivalents will be returned. e.g. <code>map.sort()</code> returns OrderedMap.</p>  <pre data-language="ts">const { Map } = require('immutable')
Map({ "c": 3, "a": 1, "b": 2 }).sort((a, b) =&gt; {
  if (a &lt; b) { return -1; }
  if (a &gt; b) { return 1; }
  if (a === b) { return 0; }
});
// OrderedMap { "a": 1, "b": 2, "c": 3 }run it</pre>
<p>Note: <code><a href="../list/index.html#sort()">sort()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="sortBy()">
<h4><a href="index.html#sortBy()">sortBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#sort()">sort</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for sorting by more sophisticated means:</p> </div>
<pre data-language="ts">sortBy&lt;C&gt;(comparatorValueMapper: (value: T, key: T, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#sortBy()">Collection#sortBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map } = require('immutable')
const beattles = Map({
  John: { name: "Lennon" },
  Paul: { name: "McCartney" },
  George: { name: "Harrison" },
  Ringo: { name: "Starr" },
});
beattles.sortBy(member =&gt; member.name);run it</pre></p>
<p>Note: <code><a href="../list/index.html#sortBy()">sortBy()</a></code> Always returns a new instance, even if the original was already sorted.</p> <p>Note: This is always an eager operation.</p> </div>
</div>
</div>
<div id="groupBy()">
<h4><a href="index.html#groupBy()">groupBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../collection.keyed/index.html">Collection.Keyed</a></code> of <code>Collection.Keyeds</code>, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">groupBy&lt;G&gt;(grouper: (value: T, key: T, iter: this) =&gt; G,context?: unknown): Seq.Keyed&lt;G, Collection&lt;T, T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#groupBy()">Collection#groupBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is always an eager operation.</p>  <pre data-language="ts">const { List, Map } = require('immutable')
const listOfMaps = List([
  Map({ v: 0 }),
  Map({ v: 1 }),
  Map({ v: 1 }),
  Map({ v: 0 }),
  Map({ v: 2 })
])
const groupsOfMaps = listOfMaps.groupBy(x =&gt; x.get('v'))
// Map {
//   0: List [ Map{ "v": 0 }, Map { "v": 0 } ],
//   1: List [ Map{ "v": 1 }, Map { "v": 1 } ],
//   2: List [ Map{ "v": 2 } ],
// }run it</pre>
</div>
</div>
</div>
<h3>Conversion to JavaScript types</h3>
<div id="toJS()">
<h4><a href="index.html#toJS()">toJS()</a></h4>
<div>
<div>
<p>Deeply converts this Set collection to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJS(): Array&lt;DeepCopy&lt;T&gt;&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#toJS()">Collection.Set#toJS()</a></code>
</div>
</div>
<div id="toJSON()">
<h4><a href="index.html#toJSON()">toJSON()</a></h4>
<div>
<div>
<p>Shallowly converts this Set collection to equivalent native JavaScript Array.</p> </div>
<pre data-language="ts">toJSON(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#toJSON()">Collection.Set#toJSON()</a></code>
</div>
</div>
<div id="toArray()">
<h4><a href="index.html#toArray()">toArray()</a></h4>
<div>
<div>
<p>Shallowly converts this collection to an Array.</p> </div>
<pre data-language="ts">toArray(): Array&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#toArray()">Collection.Set#toArray()</a></code>
</div>
</div>
<div id="toObject()">
<h4><a href="index.html#toObject()">toObject()</a></h4>
<div>
<div>
<p>Shallowly converts this Collection to an Object.</p> </div>
<pre data-language="ts">toObject(): {[key: string]: T}
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toObject()">Collection#toObject()</a></code><h4>Discussion</h4>
<div>
<p>Converts keys to Strings.</p> </div>
</div>
</div>
<h3>Conversion to Seq</h3>
<div id="toSeq()">
<h4><a href="index.html#toSeq()">toSeq()</a></h4>
<div>
<div>
<p>Returns Seq.Set.</p> </div>
<pre data-language="ts">toSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection.set/index.html#toSeq()">Collection.Set#toSeq()</a></code>
</div>
</div>
<div id="toKeyedSeq()">
<h4><a href="index.html#toKeyedSeq()">toKeyedSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Keyed from this Collection where indices are treated as keys.</p> </div>
<pre data-language="ts">toKeyedSeq(): Seq.Keyed&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toKeyedSeq()">Collection#toKeyedSeq()</a></code><h4>Discussion</h4>
<div>
<p>This is useful if you want to operate on an Collection.Indexed and preserve the [index, value] pairs.</p> <p>The returned Seq will have identical iteration order as this Collection.</p>  <pre data-language="ts">const { Seq } = require('immutable')
const indexedSeq = Seq([ 'A', 'B', 'C' ])
// Seq [ "A", "B", "C" ]
indexedSeq.filter(v =&gt; v === 'B')
// Seq [ "B" ]
const keyedSeq = indexedSeq.toKeyedSeq()
// Seq { 0: "A", 1: "B", 2: "C" }
keyedSeq.filter(v =&gt; v === 'B')
// Seq { 1: "B" }run it</pre>
</div>
</div>
</div>
<div id="toIndexedSeq()">
<h4><a href="index.html#toIndexedSeq()">toIndexedSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toIndexedSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toIndexedSeq()">Collection#toIndexedSeq()</a></code>
</div>
</div>
<div id="toSetSeq()">
<h4><a href="index.html#toSetSeq()">toSetSeq()</a></h4>
<div>
<div>
<p>Returns a Seq.Set of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">toSetSeq(): Seq.Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSetSeq()">Collection#toSetSeq()</a></code>
</div>
</div>
<h3>Value equality</h3>
<div id="equals()">
<h4><a href="index.html#equals()">equals()</a></h4>
<div>
<div>
<p>True if this and the other Collection have value equality, as defined by <code><a href="../is()/index.html">Immutable.is()</a></code>.</p> </div>
<pre data-language="ts">equals(other: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#equals()">Collection#equals()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Immutable.is(this, other)</code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="hashCode()">
<h4><a href="index.html#hashCode()">hashCode()</a></h4>
<div>
<div>
<p>Computes and returns the hashed identity for this Collection.</p> </div>
<pre data-language="ts">hashCode(): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hashCode()">Collection#hashCode()</a></code><h4>Discussion</h4>
<div>
<p>The <code><a href="../list/index.html#hashCode()">hashCode</a></code> of a Collection is used to determine potential equality, and is used when adding this to a <code><a href="index.html">Set</a></code> or as a key in a <code><a href="../map/index.html">Map</a></code>, enabling lookup via a different instance.</p>  <pre data-language="ts">const a = List([ 1, 2, 3 ]);
const b = List([ 1, 2, 3 ]);
assert.notStrictEqual(a, b); // different instances
const set = Set([ a ]);
assert.equal(set.has(b), true);run it</pre>
<p>If two values have the same <code><a href="../list/index.html#hashCode()">hashCode</a></code>, they are <a href="https://en.wikipedia.org/wiki/Collision_(computer_science)">not guaranteed to be equal</a>. If two values have different <code><a href="../list/index.html#hashCode()">hashCode</a></code>s, they must not be equal.</p> </div>
</div>
</div>
<h3>Reading values</h3>
<div id="get()">
<h4><a href="index.html#get()">get()</a></h4>
<div>
<pre data-language="ts">get&lt;NSV&gt;(key: T, notSetValue: NSV): T | NSV
get(key: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#get()">Collection#get()</a></code>
</div>
</div>
<div id="has()">
<h4><a href="index.html#has()">has()</a></h4>
<div>
<div>
<p>True if a key exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">has(key: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#has()">Collection#has()</a></code>
</div>
</div>
<div id="includes()">
<h4><a href="index.html#includes()">includes()</a></h4>
<div>
<div>
<p>True if a value exists within this <code><a href="../collection/index.html">Collection</a></code>, using <code><a href="../is()/index.html">Immutable.is</a></code> to determine equality</p> </div>
<pre data-language="ts">includes(value: T): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#includes()">Collection#includes()</a></code><h4>alias</h4>
<code>contains()</code>
</div>
</div>
<div id="first()">
<h4><a href="index.html#first()">first()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the first element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">first&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#first()">Collection#first()</a></code>
</div>
</div>
<div id="last()">
<h4><a href="index.html#last()">last()</a></h4>
<div>
<div>
<p>In case the <code><a href="../collection/index.html">Collection</a></code> is not empty returns the last element of the <code><a href="../collection/index.html">Collection</a></code>. In case the <code><a href="../collection/index.html">Collection</a></code> is empty returns the optional default value if provided, if no default value is provided returns undefined.</p> </div>
<pre data-language="ts">last&lt;NSV&gt;(notSetValue?: NSV): T | NSV
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#last()">Collection#last()</a></code>
</div>
</div>
<h3>Reading deep values</h3>
<div id="getIn()">
<h4><a href="index.html#getIn()">getIn()</a></h4>
<div>
<div>
<p>Returns the value found by following a path of keys or indices through nested Collections.</p> </div>
<pre data-language="ts">getIn(searchKeyPath: Iterable&lt;unknown&gt;, notSetValue?: unknown): unknown
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#getIn()">Collection#getIn()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: List([ Map({ y: 123 }) ]) });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p>
<p>Plain JavaScript Object or Arrays may be nested within an Immutable.js Collection, and getIn() can access those values as well:</p>  <p><pre data-language="ts">const { Map, List } = require('immutable')
const deepData = Map({ x: [ { y: 123 } ] });
deepData.getIn(['x', 0, 'y']) // 123run it</pre></p> </div>
</div>
</div>
<div id="hasIn()">
<h4><a href="index.html#hasIn()">hasIn()</a></h4>
<div>
<div>
<p>True if the result of following a path of keys or indices through nested Collections results in a set value.</p> </div>
<pre data-language="ts">hasIn(searchKeyPath: Iterable&lt;unknown&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#hasIn()">Collection#hasIn()</a></code>
</div>
</div>
<h3>Conversion to Collections</h3>
<div id="toMap()">
<h4><a href="index.html#toMap()">toMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, Throws if keys are not hashable.</p> </div>
<pre data-language="ts">toMap(): Map&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toMap()">Collection#toMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>Map(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedMap()">
<h4><a href="index.html#toOrderedMap()">toOrderedMap()</a></h4>
<div>
<div>
<p>Converts this Collection to a Map, maintaining the order of iteration.</p> </div>
<pre data-language="ts">toOrderedMap(): OrderedMap&lt;T, T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedMap()">Collection#toOrderedMap()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedMap(this.toKeyedSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toSet()">
<h4><a href="index.html#toSet()">toSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toSet(): Set&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toSet()">Collection#toSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="index.html">Set(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toOrderedSet()">
<h4><a href="index.html#toOrderedSet()">toOrderedSet()</a></h4>
<div>
<div>
<p>Converts this Collection to a Set, maintaining the order of iteration and discarding keys.</p> </div>
<pre data-language="ts">toOrderedSet(): OrderedSet&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toOrderedSet()">Collection#toOrderedSet()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code>OrderedSet(this.valueSeq())</code>, but provided for convenience and to allow for chained expressions.</p> </div>
</div>
</div>
<div id="toList()">
<h4><a href="index.html#toList()">toList()</a></h4>
<div>
<div>
<p>Converts this Collection to a List, discarding keys.</p> </div>
<pre data-language="ts">toList(): List&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toList()">Collection#toList()</a></code><h4>Discussion</h4>
<div>
<p>This is similar to <code><a href="../list/index.html">List(collection)</a></code>, but provided to allow for chained expressions. However, when called on <code><a href="../map/index.html">Map</a></code> or other keyed collections, <code>collection.toList()</code> discards the keys and creates a list of only the values, whereas <code><a href="../list/index.html">List(collection)</a></code> creates a list of entry tuples.</p>  <pre data-language="ts">const { Map, List } = require('immutable')
var myMap = Map({ a: 'Apple', b: 'Banana' })
List(myMap) // List [ [ "a", "Apple" ], [ "b", "Banana" ] ]
myMap.toList() // List [ "Apple", "Banana" ]run it</pre>
</div>
</div>
</div>
<div id="toStack()">
<h4><a href="index.html#toStack()">toStack()</a></h4>
<div>
<div>
<p>Converts this Collection to a Stack, discarding keys. Throws if values are not hashable.</p> </div>
<pre data-language="ts">toStack(): Stack&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#toStack()">Collection#toStack()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is equivalent to <code><a href="../stack/index.html">Stack(this)</a></code>, but provided to allow for chained expressions.</p> </div>
</div>
</div>
<h3>Iterators</h3>
<div id="keys()">
<h4><a href="index.html#keys()">keys()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s keys.</p> </div>
<pre data-language="ts">keys(): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keys()">Collection#keys()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#keySeq()">keySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="values()">
<h4><a href="index.html#values()">values()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s values.</p> </div>
<pre data-language="ts">values(): IterableIterator&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#values()">Collection#values()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#valueSeq()">valueSeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<div id="entries()">
<h4><a href="index.html#entries()">entries()</a></h4>
<div>
<div>
<p>An iterator of this <code><a href="../collection/index.html">Collection</a></code>'s entries as <code>[ key, value ]</code> tuples.</p> </div>
<pre data-language="ts">entries(): IterableIterator&lt;[T, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entries()">Collection#entries()</a></code><h4>Discussion</h4>
<div>
<p>Note: this will return an ES6 iterator which does not support Immutable.js sequence algorithms. Use <code><a href="../list/index.html#entrySeq()">entrySeq</a></code> instead, if this is what you want.</p> </div>
</div>
</div>
<h3>Collections (Seq)</h3>
<div id="keySeq()">
<h4><a href="index.html#keySeq()">keySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of the keys of this Collection, discarding values.</p> </div>
<pre data-language="ts">keySeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keySeq()">Collection#keySeq()</a></code>
</div>
</div>
<div id="valueSeq()">
<h4><a href="index.html#valueSeq()">valueSeq()</a></h4>
<div>
<div>
<p>Returns an Seq.Indexed of the values of this Collection, discarding keys.</p> </div>
<pre data-language="ts">valueSeq(): Seq.Indexed&lt;T&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#valueSeq()">Collection#valueSeq()</a></code>
</div>
</div>
<div id="entrySeq()">
<h4><a href="index.html#entrySeq()">entrySeq()</a></h4>
<div>
<div>
<p>Returns a new Seq.Indexed of [key, value] tuples.</p> </div>
<pre data-language="ts">entrySeq(): Seq.Indexed&lt;[T, T]&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#entrySeq()">Collection#entrySeq()</a></code>
</div>
</div>
<h3>Side effects</h3>
<div id="forEach()">
<h4><a href="index.html#forEach()">forEach()</a></h4>
<div>
<div>
<p>The <code>sideEffect</code> is executed for every entry in the Collection.</p> </div>
<pre data-language="ts">forEach(sideEffect: (value: T, key: T, iter: this) =&gt; unknown,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#forEach()">Collection#forEach()</a></code><h4>Discussion</h4>
<div>
<p>Unlike <code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach" rel="noopener">Array#forEach</a></code>, if any call of <code>sideEffect</code> returns <code>false</code>, the iteration will stop. Returns the number of entries iterated (including the last iteration which returned false).</p> </div>
</div>
</div>
<h3>Creating subsets</h3>
<div id="slice()">
<h4><a href="index.html#slice()">slice()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type representing a portion of this Collection from start up to but not including end.</p> </div>
<pre data-language="ts">slice(begin?: number, end?: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#slice()">Collection#slice()</a></code><h4>Discussion</h4>
<div>
<p>If begin is negative, it is offset from the end of the Collection. e.g. <code>slice(-2)</code> returns a Collection of the last two entries. If it is not provided the new Collection will begin at the beginning of this Collection.</p> <p>If end is negative, it is offset from the end of the Collection. e.g. <code>slice(0, -1)</code> returns a Collection of everything but the last entry. If it is not provided, the new Collection will continue through the end of this Collection.</p> <p>If the requested slice is equivalent to the current Collection, then it will return itself.</p> </div>
</div>
</div>
<div id="rest()">
<h4><a href="index.html#rest()">rest()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the first.</p> </div>
<pre data-language="ts">rest(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#rest()">Collection#rest()</a></code>
</div>
</div>
<div id="butLast()">
<h4><a href="index.html#butLast()">butLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type containing all entries except the last.</p> </div>
<pre data-language="ts">butLast(): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#butLast()">Collection#butLast()</a></code>
</div>
</div>
<div id="skip()">
<h4><a href="index.html#skip()">skip()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skip(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skip()">Collection#skip()</a></code>
</div>
</div>
<div id="skipLast()">
<h4><a href="index.html#skipLast()">skipLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which excludes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">skipLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipLast()">Collection#skipLast()</a></code>
</div>
</div>
<div id="skipWhile()">
<h4><a href="index.html#skipWhile()">skipWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns false.</p> </div>
<pre data-language="ts">skipWhile(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipWhile()">Collection#skipWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipWhile(x =&gt; x.match(/g/))
// List [ "cat", "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="skipUntil()">
<h4><a href="index.html#skipUntil()">skipUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries starting from when <code>predicate</code> first returns true.</p> </div>
<pre data-language="ts">skipUntil(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#skipUntil()">Collection#skipUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .skipUntil(x =&gt; x.match(/hat/))
// List [ "hat", "god" ]run it</pre></p> </div>
</div>
</div>
<div id="take()">
<h4><a href="index.html#take()">take()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the first <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">take(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#take()">Collection#take()</a></code>
</div>
</div>
<div id="takeLast()">
<h4><a href="index.html#takeLast()">takeLast()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes the last <code>amount</code> entries from this Collection.</p> </div>
<pre data-language="ts">takeLast(amount: number): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeLast()">Collection#takeLast()</a></code>
</div>
</div>
<div id="takeWhile()">
<h4><a href="index.html#takeWhile()">takeWhile()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">takeWhile(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeWhile()">Collection#takeWhile()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeWhile(x =&gt; x.match(/o/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<div id="takeUntil()">
<h4><a href="index.html#takeUntil()">takeUntil()</a></h4>
<div>
<div>
<p>Returns a new Collection of the same type which includes entries from this Collection as long as the <code>predicate</code> returns false.</p> </div>
<pre data-language="ts">takeUntil(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): this
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#takeUntil()">Collection#takeUntil()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List } = require('immutable')
List([ 'dog', 'frog', 'cat', 'hat', 'god' ])
  .takeUntil(x =&gt; x.match(/at/))
// List [ "dog", "frog" ]run it</pre></p> </div>
</div>
</div>
<h3>Combination</h3>
<div id="flatten()">
<h4><a href="index.html#flatten()">flatten()</a></h4>
<div>
<pre data-language="ts">flatten(depth?: number): Collection&lt;unknown, unknown&gt;
flatten(shallow?: boolean): Collection&lt;unknown, unknown&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#flatten()">Collection#flatten()</a></code>
</div>
</div>
<h3>Reducing a value</h3>
<div id="reduce()">
<h4><a href="index.html#reduce()">reduce()</a></h4>
<div>
<pre data-language="ts">reduce&lt;R&gt;(reducer: (reduction: R, value: T, key: T, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduce&lt;R&gt;(reducer: (reduction: T | R, value: T, key: T, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduce()">Collection#reduce()</a></code>
</div>
</div>
<div id="reduceRight()">
<h4><a href="index.html#reduceRight()">reduceRight()</a></h4>
<div>
<pre data-language="ts">reduceRight&lt;R&gt;(reducer: (reduction: R, value: T, key: T, iter: this) =&gt; R,initialReduction: R,context?: unknown): R
reduceRight&lt;R&gt;(reducer: (reduction: T | R, value: T, key: T, iter: this) =&gt; R): R
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#reduceRight()">Collection#reduceRight()</a></code>
</div>
</div>
<div id="every()">
<h4><a href="index.html#every()">every()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for all entries in the Collection.</p> </div>
<pre data-language="ts">every(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#every()">Collection#every()</a></code>
</div>
</div>
<div id="some()">
<h4><a href="index.html#some()">some()</a></h4>
<div>
<div>
<p>True if <code>predicate</code> returns true for any entry in the Collection.</p> </div>
<pre data-language="ts">some(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#some()">Collection#some()</a></code>
</div>
</div>
<div id="join()">
<h4><a href="index.html#join()">join()</a></h4>
<div>
<div>
<p>Joins values together as a string, inserting a separator between each. The default separator is <code>","</code>.</p> </div>
<pre data-language="ts">join(separator?: string): string
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#join()">Collection#join()</a></code>
</div>
</div>
<div id="isEmpty()">
<h4><a href="index.html#isEmpty()">isEmpty()</a></h4>
<div>
<div>
<p>Returns true if this Collection includes no values.</p> </div>
<pre data-language="ts">isEmpty(): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isEmpty()">Collection#isEmpty()</a></code><h4>Discussion</h4>
<div>
<p>For some lazy <code><a href="../seq/index.html">Seq</a></code>, <code><a href="../list/index.html#isEmpty()">isEmpty</a></code> might need to iterate to determine emptiness. At most one iteration will occur.</p> </div>
</div>
</div>
<div id="count()">
<h4><a href="index.html#count()">count()</a></h4>
<div>
<pre data-language="ts">count(): number
count(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): number
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#count()">Collection#count()</a></code>
</div>
</div>
<div id="countBy()">
<h4><a href="index.html#countBy()">countBy()</a></h4>
<div>
<div>
<p>Returns a <code><a href="../seq.keyed/index.html">Seq.Keyed</a></code> of counts, grouped by the return value of the <code>grouper</code> function.</p> </div>
<pre data-language="ts">countBy&lt;G&gt;(grouper: (value: T, key: T, iter: this) =&gt; G,context?: unknown): Map&lt;G, number&gt;
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#countBy()">Collection#countBy()</a></code><h4>Discussion</h4>
<div>
<p>Note: This is not a lazy operation.</p> </div>
</div>
</div>
<h3>Search for value</h3>
<div id="find()">
<h4><a href="index.html#find()">find()</a></h4>
<div>
<div>
<p>Returns the first value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">find(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#find()">Collection#find()</a></code>
</div>
</div>
<div id="findLast()">
<h4><a href="index.html#findLast()">findLast()</a></h4>
<div>
<div>
<p>Returns the last value for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLast(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLast()">Collection#findLast()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findEntry()">
<h4><a href="index.html#findEntry()">findEntry()</a></h4>
<div>
<div>
<p>Returns the first [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findEntry(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findEntry()">Collection#findEntry()</a></code>
</div>
</div>
<div id="findLastEntry()">
<h4><a href="index.html#findLastEntry()">findLastEntry()</a></h4>
<div>
<div>
<p>Returns the last [key, value] entry for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastEntry(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown,notSetValue?: T): [T, T] | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastEntry()">Collection#findLastEntry()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="findKey()">
<h4><a href="index.html#findKey()">findKey()</a></h4>
<div>
<div>
<p>Returns the key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findKey(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findKey()">Collection#findKey()</a></code>
</div>
</div>
<div id="findLastKey()">
<h4><a href="index.html#findLastKey()">findLastKey()</a></h4>
<div>
<div>
<p>Returns the last key for which the <code>predicate</code> returns true.</p> </div>
<pre data-language="ts">findLastKey(predicate: (value: T, key: T, iter: this) =&gt; boolean,context?: unknown): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#findLastKey()">Collection#findLastKey()</a></code><h4>Discussion</h4>
<div>
<p>Note: <code>predicate</code> will be called for each entry in reverse.</p> </div>
</div>
</div>
<div id="keyOf()">
<h4><a href="index.html#keyOf()">keyOf()</a></h4>
<div>
<div>
<p>Returns the key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">keyOf(searchValue: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#keyOf()">Collection#keyOf()</a></code>
</div>
</div>
<div id="lastKeyOf()">
<h4><a href="index.html#lastKeyOf()">lastKeyOf()</a></h4>
<div>
<div>
<p>Returns the last key associated with the search value, or undefined.</p> </div>
<pre data-language="ts">lastKeyOf(searchValue: T): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#lastKeyOf()">Collection#lastKeyOf()</a></code>
</div>
</div>
<div id="max()">
<h4><a href="index.html#max()">max()</a></h4>
<div>
<div>
<p>Returns the maximum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">max(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#max()">Collection#max()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&gt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#max()">max</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&gt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="maxBy()">
<h4><a href="index.html#maxBy()">maxBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#max()">max</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">maxBy&lt;C&gt;(comparatorValueMapper: (value: T, key: T, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#maxBy()">Collection#maxBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.maxBy(i =&gt; i.avgHit); // will output { name: 'Max', avgHit: 3 }run it</pre></p> </div>
</div>
</div>
<div id="min()">
<h4><a href="index.html#min()">min()</a></h4>
<div>
<div>
<p>Returns the minimum value in this collection. If any values are comparatively equivalent, the first one found will be returned.</p> </div>
<pre data-language="ts">min(comparator?: (valueA: T, valueB: T) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#min()">Collection#min()</a></code><h4>Discussion</h4>
<div>
<p>The <code>comparator</code> is used in the same way as <code><a href="../collection/index.html#sort()">Collection#sort</a></code>. If it is not provided, the default comparator is <code>&lt;</code>.</p> <p>When two values are considered equivalent, the first encountered will be returned. Otherwise, <code><a href="../list/index.html#min()">min</a></code> will operate independent of the order of input as long as the comparator is commutative. The default comparator <code>&lt;</code> is commutative <em>only</em> when types do not differ.</p> <p>If <code>comparator</code> returns 0 and either value is NaN, undefined, or null, that value will be returned.</p> </div>
</div>
</div>
<div id="minBy()">
<h4><a href="index.html#minBy()">minBy()</a></h4>
<div>
<div>
<p>Like <code><a href="../list/index.html#min()">min</a></code>, but also accepts a <code>comparatorValueMapper</code> which allows for comparing by more sophisticated means:</p> </div>
<pre data-language="ts">minBy&lt;C&gt;(comparatorValueMapper: (value: T, key: T, iter: this) =&gt; C,comparator?: (valueA: C, valueB: C) =&gt; number): T | undefined
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#minBy()">Collection#minBy()</a></code><h4>Discussion</h4>
<div> <p><pre data-language="ts">const { List, } = require('immutable');
const l = List([
  { name: 'Bob', avgHit: 1 },
  { name: 'Max', avgHit: 3 },
  { name: 'Lili', avgHit: 2 } ,
]);
l.minBy(i =&gt; i.avgHit); // will output { name: 'Bob', avgHit: 1 }run it</pre></p> </div>
</div>
</div>
<h3>Comparison</h3>
<div id="isSubset()">
<h4><a href="index.html#isSubset()">isSubset()</a></h4>
<div>
<div>
<p>True if <code>iter</code> includes every value in this Collection.</p> </div>
<pre data-language="ts">isSubset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSubset()">Collection#isSubset()</a></code>
</div>
</div>
<div id="isSuperset()">
<h4><a href="index.html#isSuperset()">isSuperset()</a></h4>
<div>
<div>
<p>True if this Collection includes every value in <code>iter</code>.</p> </div>
<pre data-language="ts">isSuperset(iter: Iterable&lt;T&gt;): boolean
</pre>
<h4>Inherited from</h4>
<code><a href="../collection/index.html#isSuperset()">Collection#isSuperset()</a></code>
</div>
</div>This documentation is generated from <a href="https://github.com/immutable-js/immutable-js/blob/main/type-definitions/immutable.d.ts" rel="noopener">immutable.d.ts</a>. Pull requests and <a href="https://github.com/immutable-js/immutable-js/issues" rel="noopener">Issues</a> welcome.<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2014–present, Lee Byron and other contributors<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://immutable-js.com/docs/v4.2.1/Set/" class="_attribution-link">https://immutable-js.com/docs/v4.2.1/Set/</a>
  </p>
</div>
