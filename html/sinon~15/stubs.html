<h1 class="post-title">Stubs</h1>    <h3 id="what-are-stubs">What are stubs?</h3> <p>Test stubs are functions (spies) with pre-programmed behavior.</p> <p>They support the full <a href="spies.html">test spy API</a> in addition to methods which can be used to alter the stub’s behavior.</p> <p>As spies, stubs can be either anonymous, or wrap existing functions. When wrapping an existing function with a stub, the original function is not called.</p> <h3 id="when-to-use-stubs">When to use stubs?</h3> <p>Use a stub when you want to:</p> <ol> <li> <p>Control a method’s behavior from a test to force the code down a specific path. Examples include forcing a method to throw an error in order to test error handling.</p> </li> <li> <p>When you want to prevent a specific method from being called directly (possibly because it triggers undesired behavior, such as a <code>XMLHttpRequest</code> or similar).</p> </li> </ol> <p>The following example is yet another test from <a href="https://github.com/mroderick/pubsubjs">PubSubJS</a> which shows how to create an anonymous stub that throws an exception when called.</p>  <p>Note how the stub also implements the spy interface. The test verifies that all callbacks were called, and also that the exception throwing stub was called before one of the other callbacks.</p> <h3 id="defining-stub-behavior-on-consecutive-calls">Defining stub behavior on consecutive calls</h3> <p>Calling behavior defining methods like <code>returns</code> or <code>throws</code> multiple times overrides the behavior of the stub. As of Sinon version 1.8, you can use the <a href="#stuboncalln-added-in-v18"><code>onCall</code></a> method to make a stub respond differently on consecutive calls.</p> <p>Note that in Sinon version 1.5 to version 1.7, multiple calls to the <code>yields*</code> and <code>callsArg*</code> family of methods define a sequence of behaviors for consecutive calls. As of 1.8, this functionality has been removed in favor of the <a href="#stuboncalln-added-in-v18"><code>onCall</code></a> API.</p> <h3 id="stub-api">Stub API</h3> <h3 id="properties">Properties</h3> <h4 id="var-stub--sinonstub"><code>var stub = sinon.stub();</code></h4> <p>Creates an anonymous stub function</p> <h4 id="var-stub--sinonstubobject-method"><code>var stub = sinon.stub(object, "method");</code></h4> <p>Replaces <code>object.method</code> with a stub function. An exception is thrown if the property is not already a function.</p> <p>The original function can be restored by calling <code>object.method.restore();</code> (or <code>stub.restore();</code>).</p> <h4 id="var-stub--sinonstubobject-method-func"><del><code>var stub = sinon.stub(object, "method", func);</code></del></h4> <p>This has been removed from <code>v3.0.0</code>. Instead you should use</p> <p><code>stub(obj, 'meth').callsFake(fn)</code></p> <p>A <a href="https://github.com/hurrymaplelad/sinon-codemod">codemod is available</a> to upgrade your code</p> <h4 id="var-stub--sinonstubobj"><code>var stub = sinon.stub(obj);</code></h4> <p>Stubs all the object’s methods.</p> <p>Note that it’s usually better practice to stub individual methods, particularly on objects that you don’t understand or control all the methods for (e.g. library dependencies).</p> <p>Stubbing individual methods tests intent more precisely and is less susceptible to unexpected behavior as the object’s code evolves.</p> <p>If you want to create a stub object of <code>MyConstructor</code>, but don’t want the constructor to be invoked, use this utility function.</p> <pre data-language="javascript">var stub = sinon.createStubInstance(MyConstructor, overrides);
</pre> <p><code>overrides</code> is an optional map overriding created stubs, for example:</p> <pre data-language="javascript">var stub = sinon.createStubInstance(MyConstructor, {
  foo: sinon.stub().returnsThis(),
});
</pre> <p>is the same as:</p> <pre data-language="javascript">var stub = sinon.createStubInstance(MyConstructor);
stub.foo.returnsThis();
</pre> <p>If provided value is not a stub, it will be used as the returned value:</p> <pre data-language="javascript">var stub = sinon.createStubInstance(MyConstructor, {
  foo: 3,
});
</pre> <p>is the same as:</p> <pre data-language="javascript">var stub = sinon.createStubInstance(MyConstructor);
stub.foo.returns(3);
</pre> <h4 id="stubwithargsarg1-arg2-"><code>stub.withArgs(arg1[, arg2, ...]);</code></h4> <p>Stubs the method only for the provided arguments.</p> <p>This is useful to be more expressive in your assertions, where you can access the spy with the same call. It is also useful to create a stub that can act differently in response to different arguments.</p> <p>Uses deep comparison for objects and arrays. Use <code>stub.withArgs(sinon.match.same(obj))</code> for strict comparison (see <a href="matchers.html">matchers</a>).</p>  <h4 id="stuboncalln-added-in-v18">
<code>stub.onCall(n);</code> <em>Added in v1.8</em>
</h4> <p>Defines the behavior of the stub on the <em>nth</em> call. Useful for testing sequential interactions.</p>  <p>There are methods <code>onFirstCall</code>, <code>onSecondCall</code>,<code>onThirdCall</code> to make stub definitions read more naturally.</p> <p><code>onCall</code> can be combined with all of the behavior defining methods in this section. In particular, it can be used together with <code>withArgs</code>.</p>  <p>Note how the behavior of the stub for argument <code>42</code> falls back to the default behavior once no more calls have been defined.</p> <h4 id="stubonfirstcall"><code>stub.onFirstCall();</code></h4> <p>Alias for <code>stub.onCall(0);</code></p> <h4 id="stubonsecondcall"><code>stub.onSecondCall();</code></h4> <p>Alias for <code>stub.onCall(1);</code></p> <h4 id="stubonthirdcall"><code>stub.onThirdCall();</code></h4> <p>Alias for <code>stub.onCall(2);</code></p> <h4 id="stubreset"><code>stub.reset();</code></h4> <p>Resets both behaviour and history of the stub.</p> <p>This is equivalent to calling both <code>stub.resetBehavior()</code> and <code>stub.resetHistory()</code></p> <p><em>Updated in <code>sinon@2.0.0</code></em></p> <p><em>Since <code>sinon@5.0.0</code></em></p> <p>As a convenience, you can apply <code>stub.reset()</code> to all stubs using <code>sinon.reset()</code></p> <h4 id="stubresetbehavior"><code>stub.resetBehavior();</code></h4> <p>Resets the stub’s behaviour to the default behaviour</p>  <p><em>Since <code>sinon@5.0.0</code></em></p> <p>You can reset behaviour of all stubs using <code>sinon.resetBehavior()</code></p> <h4 id="stubresethistory"><code>stub.resetHistory();</code></h4> <p><em>Since <code>sinon@2.0.0</code></em></p> <p>Resets the stub’s history</p>  <p><em>Since <code>sinon@5.0.0</code></em></p> <p>You can reset history of all stubs using <code>sinon.resetHistory()</code></p> <h4 id="stubcallsfakefakefunction"><code>stub.callsFake(fakeFunction);</code></h4> <p>Makes the stub call the provided <code>fakeFunction</code> when invoked.</p>  <h4 id="stubreturnsobj"><code>stub.returns(obj);</code></h4> <p>Makes the stub return the provided value.</p> <h4 id="stubreturnsargindex"><code>stub.returnsArg(index);</code></h4> <p>Causes the stub to return the argument at the provided index.</p> <p><code>stub.returnsArg(0);</code> causes the stub to return the first argument.</p> <p>If the argument at the provided index is not available, prior to <code>sinon@6.1.2</code>, an <code>undefined</code> value will be returned; starting from <code>sinon@6.1.2</code>, a <code>TypeError</code> will be thrown.</p> <h4 id="stubreturnsthis"><code>stub.returnsThis();</code></h4> <p>Causes the stub to return its <code>this</code> value.</p> <p>Useful for stubbing jQuery-style fluent APIs.</p> <h4 id="stubresolvesvalue"><code>stub.resolves(value);</code></h4> <p>Causes the stub to return a Promise which resolves to the provided value.</p> <p>When constructing the Promise, sinon uses the <code>Promise.resolve</code> method. You are responsible for providing a polyfill in environments which do not provide <code>Promise</code>. The Promise library can be overwritten using the <code>usingPromise</code> method.</p> <p><em>Since <code>sinon@2.0.0</code></em></p> <h4 id="stubresolvesargindex"><code>stub.resolvesArg(index);</code></h4> <p>Causes the stub to return a Promise which resolves to the argument at the provided index.</p> <p><code>stub.resolvesArg(0);</code> causes the stub to return a Promise which resolves to the first argument.</p> <p>If the argument at the provided index is not available, a <code>TypeError</code> will be thrown.</p> <p><em>Since <code>sinon@6.1.1</code></em></p> <h4 id="stubthrows"><code>stub.throws();</code></h4> <p>Causes the stub to throw an exception (<code>Error</code>).</p> <h4 id="stubthrowsname-optional-message"><code>stub.throws("name"[, "optional message"]);</code></h4> <p>Causes the stub to throw an exception with the <code>name</code> property set to the provided string. The message parameter is optional and will set the <code>message</code> property of the exception.</p> <h4 id="stubthrowsobj"><code>stub.throws(obj);</code></h4> <p>Causes the stub to throw the provided exception object.</p> <h4 id="stubthrowsfunction--return-new-error-"><code>stub.throws(function() { return new Error(); });</code></h4> <p>Causes the stub to throw the exception returned by the function.</p> <h4 id="stubthrowsargindex"><code>stub.throwsArg(index);</code></h4> <p>Causes the stub to throw the argument at the provided index.</p> <p><code>stub.throwsArg(0);</code> causes the stub to throw the first argument as the exception.</p> <p>If the argument at the provided index is not available, a <code>TypeError</code> will be thrown.</p> <p><em>Since <code>sinon@2.3.0</code></em></p> <h4 id="stubrejects"><code>stub.rejects();</code></h4> <p>Causes the stub to return a Promise which rejects with an exception (<code>Error</code>).</p> <p>When constructing the Promise, sinon uses the <code>Promise.reject</code> method. You are responsible for providing a polyfill in environments which do not provide <code>Promise</code>. The Promise library can be overwritten using the <code>usingPromise</code> method.</p> <p><em>Since <code>sinon@2.0.0</code></em></p> <h4 id="stubrejectstypeerror"><code>stub.rejects("TypeError");</code></h4> <p>Causes the stub to return a Promise which rejects with an exception of the provided type.</p> <p><em>Since <code>sinon@2.0.0</code></em></p> <h4 id="stubrejectsvalue"><code>stub.rejects(value);</code></h4> <p>Causes the stub to return a Promise which rejects with the provided exception object.</p> <p><em>Since <code>sinon@2.0.0</code></em></p> <h4 id="stubcallsargindex"><code>stub.callsArg(index);</code></h4> <p>Causes the stub to call the argument at the provided index as a callback function.</p> <p><code>stub.callsArg(0);</code> causes the stub to call the first argument as a callback.</p> <p>If the argument at the provided index is not available or is not a function, a <code>TypeError</code> will be thrown.</p> <h4 id="stubcallthrough"><code>stub.callThrough();</code></h4> <p>Causes the original method wrapped into the stub to be called when none of the conditional stubs are matched.</p>  <h4 id="stubcallthroughwithnew"><code>stub.callThroughWithNew();</code></h4> <p>Causes the original method wrapped into the stub to be called using the <code>new</code> operator when none of the conditional stubs are matched.</p>  <h4 id="stubcallsargonindex-context"><code>stub.callsArgOn(index, context);</code></h4> <p>Like <code>stub.callsArg(index);</code> but with an additional parameter to pass the <code>this</code> context.</p> <h4 id="stubcallsargwithindex-arg1-arg2-"><code>stub.callsArgWith(index, arg1, arg2, ...);</code></h4> <p>Like <code>callsArg</code>, but with arguments to pass to the callback.</p> <h4 id="stubcallsargonwithindex-context-arg1-arg2-"><code>stub.callsArgOnWith(index, context, arg1, arg2, ...);</code></h4> <p>Like above but with an additional parameter to pass the <code>this</code> context.</p> <h4 id="stubusingpromisepromiselibrary"><code>stub.usingPromise(promiseLibrary);</code></h4> <p>Causes the stub to return promises using a specific Promise library instead of the global one when using <code>stub.rejects</code> or <code>stub.resolves</code>. Returns the stub to allow chaining.</p>  <p><em>Since <code>sinon@2.0.0</code></em></p> <h4 id="stubyieldsarg1-arg2-"><code>stub.yields([arg1, arg2, ...])</code></h4> <p>Similar to <code>callsArg</code>.</p> <p>Causes the stub to call the first callback it receives with the provided arguments (if any).</p> <p>If a method accepts more than one callback, you need to use <code>yieldsRight</code> to call the last callback or <code>callsArg</code> to have the stub invoke other callbacks than the first or last one.</p> <h4 id="stubyieldsrightarg1-arg2-"><code>stub.yieldsRight([arg1, arg2, ...])</code></h4> <p>Like <code>yields</code> but calls the last callback it receives.</p> <h4 id="stubyieldsoncontext-arg1-arg2-"><code>stub.yieldsOn(context, [arg1, arg2, ...])</code></h4> <p>Like <code>yields</code> but with an additional parameter to pass the <code>this</code> context.</p> <h4 id="stubyieldstoproperty-arg1-arg2-"><code>stub.yieldsTo(property, [arg1, arg2, ...])</code></h4> <p>Causes the spy to invoke a callback passed as a property of an object to the spy.</p> <p>Like <code>yields</code>, <code>yieldsTo</code> grabs the first matching argument, finds the callback and calls it with the (optional) arguments.</p> <pre data-language="javascript">"test should fake successful ajax request": function () {
    sinon.stub(jQuery, "ajax").yieldsTo("success", [1, 2, 3]);

    jQuery.ajax({
        success: function (data) {
            assertEquals([1, 2, 3], data);
        }
    });
}
</pre> <h4 id="stubyieldstoonproperty-context-arg1-arg2-"><code>stub.yieldsToOn(property, context, [arg1, arg2, ...])</code></h4> <p>Like above but with an additional parameter to pass the <code>this</code> context.</p> <h4 id="stubyieldarg1-arg2-"><code>stub.yield([arg1, arg2, ...])</code></h4> <p>Invoke callbacks passed to the <code>stub</code> with the given arguments.</p> <p>If the stub was never called with a function argument, <code>yield</code> throws an error.</p> <p>Returns an Array with all callbacks return values in the order they were called, if no error is thrown.</p> <p>Also aliased as <code>invokeCallback</code>.</p> <h4 id="stubyieldtocallback-arg1-arg2-"><code>stub.yieldTo(callback, [arg1, arg2, ...])</code></h4> <p>Invokes callbacks passed as a property of an object to the stub.</p> <p>Like <code>yield</code>, <code>yieldTo</code> grabs the first matching argument, finds the callback and calls it with the (optional) arguments.</p>  <h4 id="stubcallargargnum"><code>stub.callArg(argNum)</code></h4> <p>Like <code>yield</code>, but with an explicit argument number specifying which callback to call.</p> <p>Useful if a function is called with more than one callback, and calling the first callback is not desired.</p> <pre data-language="javascript">"calling the last callback": function () {
    var callback = sinon.stub();
    callback(function () {
        console.log("Success!");
    }, function () {
        console.log("Oh noes!");
    });

    callback.callArg(1); // Logs "Oh noes!"
}
</pre> <h4 id="stubcallargwithargnum-arg1-arg2-"><code>stub.callArgWith(argNum, [arg1, arg2, ...])</code></h4> <p>Like <code>callArg</code>, but with arguments.</p> <h4 id="asynchronous-calls">Asynchronous calls</h4> <p>Same as their corresponding non-Async counterparts, but with callback being deferred at called after all instructions in the current call stack are processed.</p> <ul> <li>In Node environment the callback is deferred with <code>process.nextTick</code>.</li> <li>In a browser the callback is deferred with <code>setTimeout(callback, 0)</code>.</li> </ul> <p>More information:</p> <ul> <li>
<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick">https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick</a>,</li> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop">https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop</a>,</li> <li>
<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout">https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout</a>.</li> </ul> <h5 id="stubcallsargasyncindex"><code>stub.callsArgAsync(index);</code></h5> <p>Async version of <a href="#stubcallsargindex">stub.callsArg(index)</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubcallsargonasyncindex-context"><code>stub.callsArgOnAsync(index, context);</code></h5> <p>Async version of <a href="#stubcallsargonindex-context">stub.callsArgOn(index, context)</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubcallsargwithasyncindex-arg1-arg2-"><code>stub.callsArgWithAsync(index, arg1, arg2, ...);</code></h5> <p>Async version of <a href="#stubcallsargwithindex-arg1-arg2-">stub.callsArgWith(index, arg1, arg2, …)</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubcallsargonwithasyncindex-context-arg1-arg2-"><code>stub.callsArgOnWithAsync(index, context, arg1, arg2, ...);</code></h5> <p>Async version of <a href="#stubcallsargonwithindex-context-arg1-arg2-">stub.callsArgOnWith(index, context, arg1, arg2, …)</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubyieldsasyncarg1-arg2-"><code>stub.yieldsAsync([arg1, arg2, ...]);</code></h5> <p>Async version of <a href="#stubyieldsarg1-arg2-">stub.yields([arg1, arg2, …])</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubyieldsonasynccontext-arg1-arg2-"><code>stub.yieldsOnAsync(context, [arg1, arg2, ...]);</code></h5> <p>Async version of <a href="#stubyieldsoncontext-arg1-arg2-">stub.yieldsOn(context, [arg1, arg2, …])</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubyieldstoasyncproperty-arg1-arg2-"><code>stub.yieldsToAsync(property, [arg1, arg2, ...]);</code></h5> <p>Async version of <a href="#stubyieldstoproperty-arg1-arg2-">stub.yieldsTo(property, [arg1, arg2, …])</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h5 id="stubyieldstoonasyncproperty-context-arg1-arg2-"><code>stub.yieldsToOnAsync(property, context, [arg1, arg2, ...])</code></h5> <p>Async version of <a href="#stubyieldstoonproperty-context-arg1-arg2-">stub.yieldsToOn(property, context, [arg1, arg2, …])</a>. See also <a href="#asynchronous-calls">Asynchronous calls</a>.</p> <h4 id="sinonaddbehaviorname-fn"><code>sinon.addBehavior(name, fn);</code></h4> <p>Add a custom behavior. The name will be available as a function on stubs, and the chaining mechanism will be set up for you (e.g. no need to return anything from your function, its return value will be ignored). The <code>fn</code> will be passed the fake instance as its first argument, and then the user’s arguments.</p>  <h4 id="stubgetgetterfn"><code>stub.get(getterFn)</code></h4> <p>Replaces a new getter for this stub.</p>  <h4 id="stubsetsetterfn"><code>stub.set(setterFn)</code></h4> <p>Defines a new setter for this stub.</p>  <h4 id="stubvaluenewval"><code>stub.value(newVal)</code></h4> <p>Defines a new value for this stub.</p>  <p>You can restore values by calling the <code>restore</code> method:</p>  <h4 id="stubwrappedmethod"><code>stub.wrappedMethod</code></h4> <p>Holds a reference to the original method/function this stub has wrapped.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010&ndash;2022 Christian Johansen<br>Licensed under the BSD License.<br>
    <a href="https://sinonjs.org/releases/v15/stubs" class="_attribution-link">https://sinonjs.org/releases/v15/stubs</a>
  </p>
</div>
