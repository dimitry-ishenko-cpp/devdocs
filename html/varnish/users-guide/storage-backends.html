<h1 id="guide-storage">Storage backends</h1> <section id="intro"> <h2>Intro</h2> <p>Varnish has pluggable storage backends. It can store data in various backends which can have different performance characteristics. The default configuration is to use the malloc backend with a limited size. For a serious Varnish deployment you probably would want to adjust the storage settings.</p> </section> <section id="default"> <h2>default</h2> <p>syntax: default[,size]</p> <p>The default storage backend is an alias to umem, where available, or malloc otherwise.</p> </section> <section id="malloc"> <h2>malloc</h2> <p>syntax: malloc[,size]</p> <p>Malloc is a memory based backend. Each object will be allocated from memory. If your system runs low on memory swap will be used.</p> <p>Be aware that the size limitation only limits the actual storage and that the approximately 1k of memory per object, used for various internal structures, is included in the actual storage as well.</p> <p>The size parameter specifies the maximum amount of memory <code>varnishd</code> will allocate. The size is assumed to be in bytes, unless followed by one of the following suffixes:</p>  <p>K, k The size is expressed in kibibytes.</p> <p>M, m The size is expressed in mebibytes.</p> <p>G, g The size is expressed in gibibytes.</p> <p>T, t The size is expressed in tebibytes.</p>  <p>The default size is unlimited.</p> <p>malloc’s performance is bound to memory speed so it is very fast. If the dataset is bigger than available memory performance will depend on the operating systems ability to page effectively.</p> </section> <section id="umem"> <h2 id="guide-storage-umem">umem</h2> <p>syntax: umem[,size]</p> <p>Umem is a better alternative to the malloc backend where <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> is available. All other configuration aspects are considered equal to malloc.</p> <p><a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> implements a slab allocator similar to the kernel memory allocator used in virtually all modern operating systems and is considered more efficient and scalable than classical implementations. In particular, <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> is included in the family of OpenSolaris descendent operating systems where jemalloc(3) is not commonly available.</p> <p>If <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> is not used otherwise, Varnish will only use it for storage allocations and keep the default libc allocator for all other Varnish memory allocation purposes.</p> <p>If <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> is already loaded when Varnish initializes, this message is output:</p> <pre data-language="python">notice: libumem was already found to be loaded
        and will likely be used for all allocations
</pre> <p>to indicate that <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> will not only be used for storage. Likely reasons for this to be the case are:</p> <ul class="simple"> <li>some library <code>varnishd</code> is linked against was linked against <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> (most likely <code>libpcre2-8</code>, check with <code>ldd</code>)</li> <li>
<code>LD_PRELOAD_64=/usr/lib/amd64/libumem.so.1</code>, <code>LD_PRELOAD_32=/usr/lib/libumem.so.1</code> or <code>LD_PRELOAD=/usr/lib/libumem.so.1</code> is set</li> </ul> <p>Varnish will also output this message to recommend settings for using <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> for all allocations:</p> <pre data-language="python">it is recommended to set UMEM_OPTIONS=perthread_cache=0,backend=mmap
before starting varnish
</pre> <p>This recommendation should be followed to achieve an optimal <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> configuration for Varnish. Setting this environment variable before starting Varnish is required because <a class="reference external" href="http://dtrace.org/blogs/ahl/2004/07/13/number-11-of-20-libumem/">libumem</a> cannot be reconfigured once loaded.</p> </section> <section id="file"> <h2>file</h2> <p>syntax: file,path[,size[,granularity[,advice]]]</p> <p>The file backend stores objects in virtual memory backed by an unlinked file on disk with <code>mmap</code>, relying on the kernel to handle paging as parts of the file are being accessed.</p> <p>This implies that sufficient <em>virtual</em> memory needs to be available to accomodate the file size in addition to any memory Varnish requires anyway. Traditionally, the virtual memory limit is configured with <code>ulimit -v</code>, but modern operating systems have other abstractions for this limit like control groups (Linux) or resource controls (Solaris).</p> <p>The ‘path’ parameter specifies either the path to the backing file or the path to a directory in which <code>varnishd</code> will create the backing file.</p> <p>The size parameter specifies the size of the backing file. The size is assumed to be in bytes, unless followed by one of the following suffixes:</p>  <p>K, k The size is expressed in kibibytes.</p> <p>M, m The size is expressed in mebibytes.</p> <p>G, g The size is expressed in gibibytes.</p> <p>T, t The size is expressed in tebibytes.</p>  <p>If ‘path’ points to an existing file and no size is specified, the size of the existing file will be used. If ‘path’ does not point to an existing file it is an error to not specify the size.</p> <p>If the backing file already exists, it will be truncated or expanded to the specified size.</p> <p>Note that if <code>varnishd</code> has to create or expand the file, it will not pre-allocate the added space, leading to fragmentation, which may adversely impact performance on rotating hard drives. Pre-creating the storage file using <code>dd(1)</code> will reduce fragmentation to a minimum.</p> <p>The ‘granularity’ parameter specifies the granularity of allocation. All allocations are rounded up to this size. The granularity is assumed to be expressed in bytes, unless followed by one of the suffixes described for size.</p> <p>The default granularity is the VM page size. The size should be reduced if you have many small objects.</p> <p>File performance is typically limited to the write speed of the device, and depending on use, the seek time.</p> <p>The ‘advice’ parameter tells the kernel how <code>varnishd</code> expects to use this mapped region so that the kernel can choose the appropriate read-ahead and caching techniques. Possible values are <code>normal</code>, <code>random</code> and <code>sequential</code>, corresponding to MADV_NORMAL, MADV_RANDOM and MADV_SEQUENTIAL madvise() advice argument, respectively. Defaults to <code>random</code>.</p> <p>On Linux, large objects and rotational disk should benefit from “sequential”.</p> </section> <section id="deprecated-persistent"> <h2>deprecated_persistent</h2> <p>syntax: deprecated_persistent,path,size {experimental}</p> <p><em>Before using, read</em> <a class="reference internal" href="https://varnish-cache.org/docs/7.4/phk/persistent.html#phk-persistent"><span class="std std-ref">A persistent message</span></a><em>!</em></p> <p>Persistent storage. Varnish will store objects in a file in a manner that will secure the survival of <em>most</em> of the objects in the event of a planned or unplanned shutdown of Varnish.</p> <p>The ‘path’ parameter specifies the path to the backing file. If the file doesn’t exist Varnish will create it.</p> <p>The ‘size’ parameter specifies the size of the backing file. The size is expressed in bytes, unless followed by one of the following suffixes:</p>  <p>K, k The size is expressed in kibibytes.</p> <p>M, m The size is expressed in mebibytes.</p> <p>G, g The size is expressed in gibibytes.</p> <p>T, t The size is expressed in tebibytes.</p>  <p>Varnish will split the file into logical <em>silos</em> and write to the silos in the manner of a circular buffer. Only one silo will be kept open at any given point in time. Full silos are <em>sealed</em>. When Varnish starts after a shutdown it will discard the content of any silo that isn’t sealed.</p> <p>Note that taking persistent silos offline and at the same time using bans can cause problems. This is due to the fact that bans added while the silo was offline will not be applied to the silo when it reenters the cache. Consequently enabling previously banned objects to reappear.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2006 Verdens Gang AS<br>Copyright &copy; 2006&ndash;2020 Varnish Software AS<br>Licensed under the BSD-2-Clause License.<br>
    <a href="https://varnish-cache.org/docs/7.4/users-guide/storage-backends.html" class="_attribution-link">https://varnish-cache.org/docs/7.4/users-guide/storage-backends.html</a>
  </p>
</div>
