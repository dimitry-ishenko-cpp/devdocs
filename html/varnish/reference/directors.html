<h1 id="ref-writing-a-director">Writing a Director</h1> <p>Varnish already provides a set of general-purpose directors, and since Varnish 4, it is bundled in the built-in <a class="reference internal" href="vmod_directors.html#vmod-directors-3"><span class="std std-ref">VMOD directors - Varnish Directors Module</span></a>. Writing a director boils down to writing a VMOD, using the proper data structures and APIs. Not only can you write your own director if none of the built-ins fit your needs, but since Varnish 4.1 you can even write your own backends.</p> <p>Backends can be categorized as such:</p> <ul class="simple"> <li>static: native backends declared in VCL</li> <li>dynamic: native backends created by VMODs</li> <li>custom: backends created and fully managed by VMODs</li> </ul> <section id="backends-vs-directors"> <h2>Backends vs Directors</h2> <p>The intuitive classification for backend and director is an endpoint for the former and a loadbalancer for the latter, but the actual implementation is a bit more subtle. VMODs can accept backend arguments and return backends in VCL (see <a class="reference internal" href="vmod.html#ref-vmod-vcl-c-types"><span class="std std-ref">VCL and C data types</span></a>), but the underlying C type is <code>struct director</code> aka the <code>VCL_BACKEND</code> typedef. Under the hood director is a generic concept, and a backend is a kind of director.</p> <p>The line between the two is somewhat blurry at this point, let’s look at some code instead:</p> <pre data-language="python">// VRT interface from vrt.h

struct vdi_methods {
    unsigned                        magic;
#define VDI_METHODS_MAGIC           0x4ec0c4bb
    const char                      *type;
    vdi_http1pipe_f                 *http1pipe;
    vdi_healthy_f                   *healthy;
    vdi_resolve_f                   *resolve;
    vdi_gethdrs_f                   *gethdrs;
    vdi_getip_f                     *getip;
    vdi_finish_f                    *finish;
    vdi_event_f                     *event;
    vdi_release_f                   *release;
    vdi_destroy_f                   *destroy;
    vdi_panic_f                     *panic;
    vdi_list_f                      *list;
};

struct director {
    unsigned                        magic;
#define DIRECTOR_MAGIC              0x3336351d
    void                            *priv;
    char                            *vcl_name;
    struct vcldir                   *vdir;
    struct lock                     *mtx;
};
</pre> <p>A director can be summed up as:</p> <ul class="simple"> <li>being of a specific <code>type</code> with a set of operations which is identical for all instances of that particular type</li> <li>some instance specific attributes such as a <code>vcl_name</code> and <code>type</code>-specific private data</li> </ul> <p>The difference between a <em>load balancing</em> director and a <em>backend</em> director is mainly the functions they will implement.</p> <p>The fundamental steps towards a director implementation are:</p> <ul> <li>implement the required functions</li> <li>
<p>fill a <code>struct vdi_methods</code> with the name of your director type and your function pointers</p> <p>Existence of a <code>healthy</code> callback signifies that the director has some means of dynamically determining its health state.</p> </li> <li>in your constructor or other initialization routine, allocate and initialize your director-specific configuration state (aka private data) and call <code>VRT_AddDirector()</code> with your <code>struct
vdi_methods</code>, the pointer to your state and a printf format for the name of your director instance</li> <li>implement methods or functions returning <code>VCL_BACKEND</code>
</li> <li>in your destructor or other finalizer, call <code>VRT_DelDirector()</code>
</li> <li>implement a <code>destroy</code> callback to destroy the actual director private state. It will be called when all references to the director are gone, until then the private state must remain intact and <code>vdi_methods</code> functions callable (but they may return errors).</li> </ul> <p>While vmods can implement functions returning directors, <a class="reference internal" href="vmod.html#ref-vmod-vcl-c-objects"><span class="std std-ref">Objects and methods</span></a> are usually a more natural representation with vmod object instances being or referring to the director private data.</p> </section> <section id="load-balancing-directors"> <h2>Load Balancing Directors</h2> <p>As in <a class="reference internal" href="vmod_directors.html#vmod-directors-3"><span class="std std-ref">VMOD directors - Varnish Directors Module</span></a>, you can write directors that will group backends sharing the same role, and pick them according to a strategy. If you need more than the built-in strategies (round-robin, hash, …), even though they can be stacked, it is always possible to write your own.</p> <p>In this case you simply need to implement the <code>resolve</code> function for the director. Directors are walked until a leaf director is found. A leaf director doesn’t have a <code>resolve</code> function and is used to actually make the backend request, just like the backends you declare in VCL.</p> <p><em>load balancing</em> directors use <code>VRT_Assign_Backend()</code> to take references to other directors. They <em>must</em> implement a <code>release</code> callback which has to release all references to other directors and ensure that none are gained after it returns.</p> </section> <section id="static-directors"> <h2>Static Directors</h2> <p>As opposed to dynamic backends covered below, directors which are guaranteed to have VCL lifetime (that is, they do not get destroyed before the VCL goes cold) can call <code>VRT_StaticDirector()</code> to avoid reference counting overhead.</p> </section> <section id="dynamic-backends"> <h2>Dynamic Backends</h2> <p>If you want to speak HTTP/1 over TCP or UDS, but for some reason VCL does not fit the bill, you can instead reuse the whole backend facility. It allows you for instance to add and remove backends on-demand without the need to reload your VCL. You can then leverage your provisioning system.</p> <p>Consider the following snippet:</p> <pre data-language="python">backend default {
    .host = "localhost";
}
</pre> <p>The VCL compiler turns this declaration into a <code>struct
vrt_backend</code>. When the VCL is loaded, Varnish calls <code>VRT_new_backend</code> (or rather <code>VRT_new_backend_clustered</code> for VSM efficiency) in order to create the director. Varnish doesn’t expose its data structure for actual backends, only the director abstraction and dynamic backends are built just like static backends, one <em>struct</em> at a time. You can get rid of the <code>struct vrt_backend</code> as soon as you have the <code>struct director</code>.</p> <p>A (dynamic) backend can’t exceed its VCL’s lifespan, because native backends are <em>owned</em> by VCLs. Though a dynamic backend can’t outlive its VCL, it can be deleted any time with <code>VRT_delete_backend</code>. The VCL will delete the remaining backends once discarded, you don’t need to take care of it.</p> <p>Reference counting is used to ensure that backends which are no longer referenced are destroyed.</p> <p>Finally, Varnish will take care of event propagation for <em>all</em> native backends, but dynamic backends can only be created when the VCL is warm. If your backends are created by an independent thread (basically outside of VCL scope) you must subscribe to VCL events and watch for VCL state (see <a class="reference internal" href="vmod.html#ref-vmod-event-functions"><span class="std std-ref">Event functions</span></a>). Varnish will panic if you try to create a backend on a cold VCL, and <code>VRT_new_backend</code> will return <code>NULL</code> if the VCL is cooling. You are also encouraged to comply with the <a class="reference internal" href="varnish-cli.html#ref-vcl-temperature"><span class="std std-ref">VCL Temperature</span></a> in general.</p> </section> <section id="health-probes"> <h2 id="ref-writing-a-director-loadbalancer">Health Probes</h2> <p>It is possible in a VCL program to query the health of a director (see <a class="reference internal" href="vmod_std.html#std-healthy"><span class="std std-ref">BOOL healthy(BACKEND be)</span></a>). A director can report its health if it implements the <code>healthy</code> function, it is otherwise always considered healthy.</p> <p>Unless you are making a dynamic backend, you need to take care of the health probes yourselves. For <em>load balancing</em> directors, being healthy typically means having at least one healthy underlying backend or director.</p> <p>For dynamic backends, it is just a matter of assigning the <code>probe</code> field in the <code>struct vrt_backend</code>. Once the director is created, the probe definition too is no longer needed. It is then Varnish that will take care of the health probe and disable the feature on a cold VCL (see <a class="reference internal" href="vmod.html#ref-vmod-event-functions"><span class="std std-ref">Event functions</span></a>).</p> <p>Instead of initializing your own probe definition, you can get a <code>VCL_PROBE</code> directly built from VCL (see <a class="reference internal" href="vmod.html#ref-vmod-vcl-c-types"><span class="std std-ref">VCL and C data types</span></a>).</p> </section> <section id="custom-backends"> <h2>Custom Backends</h2> <p>If you want to implement a custom backend, have a look at how Varnish implements native backends. It is the canonical implementation, and though it provides other services like connection pooling or statistics, it is essentially a director which state is a <code>struct
backend</code>. Varnish native backends currently speak HTTP/1 over TCP or UDS, and as such, you need to make your own custom backend if you want Varnish to do otherwise such as connect over UDP or speak a different protocol.</p> <p>If you want to leverage probes declarations in VCL, which have the advantage of being reusable since they are only specifications, you can. However, you need to implement the whole probing infrastructure from scratch.</p> <p>You may also consider making your custom backend compliant with regards to the VCL state (see <a class="reference internal" href="vmod.html#ref-vmod-event-functions"><span class="std std-ref">Event functions</span></a>).</p> <p>If you are implementing the <code>gethdrs</code> method of your backend (i.e. your backend is able to generate a backend response to be manipulated in <code>vcl_backend_response</code>), you will want to log the response code, protocol and the various headers it’ll create for easier debugging. For this, you can look at the <code>VSL*</code> family of functions, listed in <code>cache/cache.h</code>.</p> <section id="data-structure-considerations"> <h3>Data structure considerations</h3> <p>When you are creating a custom backend, you may want to provide the semantics of the native backends. In this case, instead of repeating the redundant fields between data structures, you can use the macros <code>VRT_BACKEND_FIELDS</code> and <code>VRT_BACKEND_PROBE_FIELDS</code> to declare them all at once. This is the little dance Varnish uses to copy data between the <code>struct vrt_backend</code> and its internal data structure for example.</p> <p>The copy can be automated with the macros <code>VRT_BACKEND_HANDLE</code> and <code>VRT_BACKEND_PROBE_HANDLE</code>. You can look at how they can be used in the Varnish code base.</p> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2006 Verdens Gang AS<br>Copyright &copy; 2006&ndash;2020 Varnish Software AS<br>Licensed under the BSD-2-Clause License.<br>
    <a href="https://varnish-cache.org/docs/7.4/reference/directors.html" class="_attribution-link">https://varnish-cache.org/docs/7.4/reference/directors.html</a>
  </p>
</div>
