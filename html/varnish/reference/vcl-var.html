<h1 id="vcl-var-7">VCL-Variables</h1> <section id="the-complete-album"> <h2>The complete album</h2> <dl class="field-list simple"> <dt class="field-odd">Manual section<span class="colon">:</span>
</dt> <dd class="field-odd">
<p>7</p> </dd> </dl> <section id="description"> <h3>DESCRIPTION</h3> <p>This is a list of all variables in the VCL language.</p> <p>Variable names take the form <code>scope.variable[.index]</code>, for instance:</p> <pre data-language="python">req.url
beresp.http.date
client.ip
</pre> <p>Which operations are possible on each variable is described below, often with the shorthand “backend” which covers the <code>vcl_backend_* {}</code> subroutines and “client” which covers the rest, except <code>vcl_init {}</code> and <code>vcl_fini {}</code>.</p> <section id="local-server-remote-and-client"> <h4 id="id1">local, server, remote and client</h4> <p>These variables describe the network connection between the client and varnishd.</p> <p>Without PROXY protocol:</p> <pre data-language="python">     client    server
     remote    local
       v          v
CLIENT ------------ VARNISHD
</pre> <p>With PROXY protocol:</p> <pre data-language="python">     client    server   remote     local
       v          v       v          v
CLIENT ------------ PROXY ------------ VARNISHD
</pre> <p id="client-identity">client.identity</p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>Writable from: client</p> <p>Identification of the client, used to load balance in the client director. Defaults to <code>client.ip</code></p> <p>This variable can be overwritten with more precise information, for instance extracted from a <code>Cookie:</code> header.</p>  <p id="client-ip">client.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The client’s IP address, either the same as <code>remote.ip</code> or what the PROXY protocol told us.</p>  <p id="server-hostname">server.hostname</p>  <p>Type: STRING</p> <p>Readable from: all</p> <p>The host name of the server, as returned by the <code>gethostname(3)</code> system function.</p>  <p id="server-identity">server.identity</p>  <p>Type: STRING</p> <p>Readable from: all</p> <p>The identity of the server, as set by the <code>-i</code> parameter.</p> <p>If an <code>-i</code> parameter is not passed to varnishd, the return value from <code>gethostname(3)</code> system function will be used.</p>  <p id="server-ip">server.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address of the socket on which the client connection was received, either the same as <code>server.ip</code> or what the PROXY protocol told us.</p>  <p id="remote-ip">remote.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address of the other end of the TCP connection. This can either be the clients IP, or the outgoing IP of a proxy server.</p> <p>If the connection is a UNIX domain socket, the value will be <code>0.0.0.0:0</code></p>  <p id="local-endpoint">local.endpoint <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>The address of the ‘-a’ socket the session was accepted on.</p> <p>If the argument was <code>-a foo=:81</code> this would be “:81”</p>  <p id="local-ip">local.ip</p>  <p>Type: IP</p> <p>Readable from: client, backend</p> <p>The IP address (and port number) of the local end of the TCP connection, for instance <code>192.168.1.1:81</code></p> <p>If the connection is a UNIX domain socket, the value will be <code>0.0.0.0:0</code></p>  <p id="local-socket">local.socket <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client, backend</p> <p>The name of the ‘-a’ socket the session was accepted on.</p> <p>If the argument was <code>-a foo=:81</code> this would be “foo”.</p> <p>Note that all ‘-a’ gets a default name on the form <code>a%d</code> if no name is provided.</p>  </section> <section id="req-and-req-top"> <h4>req and req_top</h4> <p>These variables describe the present request, and when ESI:include requests are being processed, req_top points to the request received from the client.</p> <p id="req">req</p>  <p>Type: HTTP</p> <p>Readable from: client</p> <p>The entire request HTTP data structure. Mostly useful for passing to VMODs.</p>  <p id="req-backend-hint">req.backend_hint</p>  <p>Type: BACKEND</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Set bereq.backend to this if we attempt to fetch. When set to a director, reading this variable returns an actual backend if the director has resolved immediately, or the director otherwise. When used in string context, returns the name of the director or backend, respectively.</p>  <p id="req-can-gzip">req.can_gzip</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>True if the client provided <code>gzip</code> or <code>x-gzip</code> in the <code>Accept-Encoding</code> header.</p>  <p>req.esi <code>VCL &lt;= 4.0</code></p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Set to <code>false</code> to disable ESI processing regardless of any value in beresp.do_esi. Defaults to <code>true</code>. This variable is replaced by <code>resp.do_esi</code> in VCL 4.1.</p>  <p id="req-esi-level">req.esi_level</p>  <p>Type: INT</p> <p>Readable from: client</p> <p>A count of how many levels of ESI requests we’re currently at.</p>  <p id="req-grace">req.grace</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Upper limit on the object grace.</p> <p>During lookup the minimum of req.grace and the object’s stored grace value will be used as the object’s grace.</p>  <p id="req-hash">req.hash</p>  <p>Type: BLOB</p> <p>Readable from: vcl_hit, vcl_miss, vcl_pass, vcl_purge, vcl_deliver</p> <p>The hash key of this request. Mostly useful for passing to VMODs, but can also be useful for debugging hit/miss status.</p>  <p id="req-hash-always-miss">req.hash_always_miss</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Default: <code>false</code>.</p> <p>Force a cache miss for this request, even if perfectly good matching objects are in the cache.</p> <p>This is useful to force-update the cache without invalidating existing entries in case the fetch fails.</p>  <p id="req-hash-ignore-busy">req.hash_ignore_busy</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Default: <code>false</code>.</p> <p>Ignore any busy object during cache lookup.</p> <p>You only want to do this when you have two server looking up content sideways from each other to avoid deadlocks.</p>  <p id="req-hash-ignore-vary">req.hash_ignore_vary</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Default: <code>false</code>.</p> <p>Ignore objects vary headers during cache lookup.</p> <p>This returns the very first match regardless of the object compatibility with the client request. This is useful when variants are irrelevant to certain clients, and differences in the way the resouce is presented don’t change how the client will interpret it.</p> <p>Use with caution.</p>  <p id="req-http">req.http.*</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Unsetable from: client</p> <p>The headers of request, things like <code>req.http.date</code>.</p> <p>The RFCs allow multiple headers with the same name, and both <code>set</code> and <code>unset</code> will remove <em>all</em> headers with the name given.</p> <p>The header name <code>*</code> is a VCL symbol and as such cannot, for example, start with a numeral. To work with valid header that can’t be represented as VCL symbols it is possible to quote the name, like <code>req.http."grammatically.valid"</code>. None of the HTTP headers present in IANA registries need to be quoted, so the quoted syntax is discouraged but available for interoperability.</p> <p>Some headers that cannot be tampered with for proper HTTP fetch or delivery are read-only.</p>  <p>req.http.content-length</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>The content-length header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p>req.http.transfer-encoding</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>The transfer-encoding header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p id="req-is-hitmiss">req.is_hitmiss</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>If this request resulted in a hitmiss</p>  <p id="req-is-hitpass">req.is_hitpass</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>If this request resulted in a hitpass</p>  <p id="req-method">req.method</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The request method (e.g. “GET”, “HEAD”, …)</p>  <p>req.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The HTTP protocol version used by the client, usually “HTTP/1.1” or “HTTP/2.0”.</p>  <p id="req-proto">req.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The HTTP protocol version used by the client, usually “HTTP/1.1” or “HTTP/2.0”.</p>  <p id="req-restarts">req.restarts</p>  <p>Type: INT</p> <p>Readable from: client</p> <p>A count of how many times this request has been restarted.</p>  <p id="req-storage">req.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The storage backend to use to save this request body.</p>  <p id="req-time">req.time</p>  <p>Type: TIME</p> <p>Readable from: client</p> <p>The time when the request was fully received, remains constant across restarts.</p>  <p id="req-trace">req.trace</p>  <p>Type: BOOL</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Controls if <code>VCL_trace</code> VSL records are emitted for the current request, see <a class="reference internal" href="vsl.html#vsl-7"><span class="std std-ref">VSL</span></a>.</p> <p>Defaults to the setting of the <code>feature trace</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>. Does not get reset by a rollback.</p>  <p id="req-transport">req.transport</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The transport protocol which brought this request.</p>  <p id="req-ttl">req.ttl</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Upper limit on the object age for cache lookups to return hit.</p>  <p id="req-url">req.url</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>The requested URL, for instance “/robots.txt”.</p>  <p id="req-xid">req.xid</p>  <p>Type: INT</p> <p>Readable from: client</p> <p>Unique ID of this request.</p>  <p id="req-top-http">req_top.http.*</p>  <p>Type: HEADER</p> <p>Readable from: client</p> <p>HTTP headers of the top-level request in a tree of ESI requests. Identical to req.http. in non-ESI requests.</p> <p>See <a class="reference internal" href="#req-http">req.http</a> for general notes.</p>  <p id="req-top-method">req_top.method</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The request method of the top-level request in a tree of ESI requests. (e.g. “GET”, “HEAD”). Identical to req.method in non-ESI requests.</p>  <p id="req-top-proto">req_top.proto</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>HTTP protocol version of the top-level request in a tree of ESI requests. Identical to req.proto in non-ESI requests.</p>  <p id="req-top-time">req_top.time</p>  <p>Type: TIME</p> <p>Readable from: client</p> <p>The time when the top-level request was fully received, remains constant across restarts.</p>  <p id="req-top-url">req_top.url</p>  <p>Type: STRING</p> <p>Readable from: client</p> <p>The requested URL of the top-level request in a tree of ESI requests. Identical to req.url in non-ESI requests.</p>  </section> <section id="bereq"> <h4>bereq</h4> <p>This is the request we send to the backend, it is built from the clients <code>req.*</code> fields by filtering out “per-hop” fields which should not be passed along (<code>Connection:</code>, <code>Range:</code> and similar).</p> <p>Slightly more fields are allowed through for <code>pass` fetches
than for `miss` fetches, for instance ``Range</code>.</p> <p>bereq</p>  <p>Type: HTTP</p> <p>Readable from: backend</p> <p>The entire backend request HTTP data structure. Mostly useful as argument to VMODs.</p>  <p id="bereq-backend">bereq.backend</p>  <p>Type: BACKEND</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>This is the backend or director we attempt to fetch from. When set to a director, reading this variable returns an actual backend if the director has resolved immediately, or the director otherwise. When used in string context, returns the name of the director or backend, respectively.</p>  <p id="bereq-between-bytes-timeout">bereq.between_bytes_timeout</p>  <p>Type: DURATION</p> <p>Readable from: backend</p> <p>Writable from: backend</p> <p>Default: <code>.between_bytes_timeout</code> attribute from the <a class="reference internal" href="vcl-backend.html#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>between_bytes_timeout</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait between each received byte from the backend. Not available in pipe mode.</p>  <p id="bereq-body">bereq.body</p>  <p>Type: BODY</p> <p>Unsetable from: vcl_backend_fetch</p> <p>The request body.</p> <p>Unset will also remove <a class="reference internal" href="#bereq-http-content-length">bereq.http.content-length</a>.</p>  <p id="bereq-connect-timeout">bereq.connect_timeout</p>  <p>Type: DURATION</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>Default: <code>.connect_timeout</code> attribute from the <a class="reference internal" href="vcl-backend.html#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>connect_timeout</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait for a backend connection to be established.</p>  <p id="bereq-first-byte-timeout">bereq.first_byte_timeout</p>  <p>Type: DURATION</p> <p>Readable from: backend</p> <p>Writable from: backend</p> <p>Default: <code>.first_byte_timeout</code> attribute from the <a class="reference internal" href="vcl-backend.html#backend-definition"><span class="std std-ref">Backend definition</span></a>, which defaults to the <code>first_byte_timeout</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The time in seconds to wait getting the first byte back from the backend. Not available in pipe mode.</p>  <p id="bereq-hash">bereq.hash</p>  <p>Type: BLOB</p> <p>Readable from: vcl_pipe, backend</p> <p>The hash key of this request, a copy of <code>req.hash</code>.</p>  <p id="bereq-http">bereq.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>Unsetable from: vcl_pipe, backend</p> <p>The headers to be sent to the backend.</p> <p>See <a class="reference internal" href="#req-http">req.http</a> for general notes.</p>  <p id="bereq-http-content-length">bereq.http.content-length</p>  <p>Type: HEADER</p> <p>Readable from: backend</p> <p>The content-length header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p>bereq.http.transfer-encoding</p>  <p>Type: HEADER</p> <p>Readable from: backend</p> <p>The transfer-encoding header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p id="bereq-is-bgfetch">bereq.is_bgfetch</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>True for fetches where the client got a hit on an object in grace, and this fetch was kicked of in the background to get a fresh copy.</p>  <p id="bereq-is-hitmiss">bereq.is_hitmiss</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>If this backend request was caused by a hitmiss.</p>  <p id="bereq-is-hitpass">bereq.is_hitpass</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>If this backend request was caused by a hitpass.</p>  <p id="bereq-method">bereq.method</p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The request type (e.g. “GET”, “HEAD”).</p> <p>Regular (non-pipe, non-pass) fetches are always “GET”</p>  <p>bereq.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The HTTP protocol version, “HTTP/1.1” unless a pass or pipe request has “HTTP/1.0” in <code>req.proto</code></p>  <p id="bereq-proto">bereq.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>The HTTP protocol version, “HTTP/1.1” unless a pass or pipe request has “HTTP/1.0” in <code>req.proto</code></p>  <p id="bereq-retries">bereq.retries</p>  <p>Type: INT</p> <p>Readable from: backend</p> <p>A count of how many times this request has been retried.</p>  <p id="bereq-time">bereq.time</p>  <p>Type: TIME</p> <p>Readable from: vcl_pipe, backend</p> <p>The time when we started preparing the first backend request, remains constant across retries.</p>  <p id="bereq-trace">bereq.trace</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>Writable from: backend</p> <p>Controls if <code>VCL_trace</code> VSL records are emitted for the current request, see <a class="reference internal" href="vsl.html#vsl-7"><span class="std std-ref">VSL</span></a>.</p> <p>Inherits the value of <code>req.trace</code> when the backend request is created. Does not get reset by a rollback.</p>  <p id="bereq-uncacheable">bereq.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: backend</p> <p>Indicates whether this request is uncacheable due to a <code>pass</code> in the client side or a hit on an hit-for-pass object.</p>  <p id="bereq-url">bereq.url</p>  <p>Type: STRING</p> <p>Readable from: vcl_pipe, backend</p> <p>Writable from: vcl_pipe, backend</p> <p>The requested URL, copied from <code>req.url</code></p>  <p id="bereq-xid">bereq.xid</p>  <p>Type: INT</p> <p>Readable from: vcl_pipe, backend</p> <p>Unique ID of this request.</p>  </section> <section id="beresp"> <h4>beresp</h4> <p>The response received from the backend, one cache misses, the store object is built from <code>beresp</code>.</p> <p>beresp</p>  <p>Type: HTTP</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The entire backend response HTTP data structure, useful as argument to VMOD functions.</p>  <p id="beresp-age">beresp.age</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Age header, or zero.</p> <p>The age of the object.</p>  <p id="beresp-backend">beresp.backend</p>  <p>Type: BACKEND</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>This is the backend we fetched from. If bereq.backend was set to a director, this will be the backend selected by the director. When used in string context, returns its name.</p>  <p>beresp.backend.ip <code>VCL &lt;= 4.0</code></p>  <p>Type: IP</p> <p>Readable from: vcl_backend_response</p> <p>IP of the backend this response was fetched from.</p>  <p id="beresp-backend-name">beresp.backend.name</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Name of the backend this response was fetched from. Same as beresp.backend.</p>  <p id="beresp-body">beresp.body</p>  <p>Type: BODY</p> <p>Writable from: vcl_backend_error</p> <p>For producing a synthetic body.</p>  <p id="beresp-do-esi">beresp.do_esi</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set it to true to parse the object for ESI directives. This is necessary for later ESI processing on the client side. If beresp.do_esi is false when an object enters the cache, client side ESI processing will not be possible (obj.can_esi will be false).</p> <p>It is a VCL error to use beresp.do_esi after setting beresp.filters.</p>  <p id="beresp-do-gunzip">beresp.do_gunzip</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set to <code>true</code> to gunzip the object while storing it in the cache.</p> <p>If <code>http_gzip_support</code> is disabled, setting this variable has no effect.</p> <p>It is a VCL error to use beresp.do_gunzip after setting beresp.filters.</p>  <p id="beresp-do-gzip">beresp.do_gzip</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>false</code>.</p> <p>Set to <code>true</code> to gzip the object while storing it.</p> <p>If <code>http_gzip_support</code> is disabled, setting this variable has no effect.</p> <p>It is a VCL error to use beresp.do_gzip after setting beresp.filters.</p>  <p id="beresp-do-stream">beresp.do_stream</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>true</code>.</p> <p>Deliver the object to the client while fetching the whole object into varnish.</p> <p>For uncacheable objects, storage for parts of the body which have been sent to the client may get freed early, depending on the storage engine used.</p> <p>This variable has no effect if beresp.do_esi is true or when the response body is empty.</p>  <p id="beresp-filters">beresp.filters</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response</p> <p>Writable from: vcl_backend_response</p> <p>List of Varnish Fetch Processor (VFP) filters the beresp.body will be pulled through. The order left to right signifies processing from backend to cache, iow the leftmost filter is run first on the body as received from the backend after decoding of any transfer encodings.</p> <p>VFP Filters change the body before going into the cache and/or being handed to the client side, where it may get processed again by resp.filters.</p> <p>The following VFP filters exist in varnish-cache:</p> <ul> <li>
<code>gzip</code>: compress a body using gzip</li> <li>
<code>testgunzip</code>: Test if a body is valid gzip and refuse it otherwise</li> <li>
<code>gunzip</code>: Uncompress gzip content</li> <li>
<code>esi</code>: ESI-process plain text content</li> <li>
<p><code>esi_gzip</code>: Save gzipped snippets for efficient ESI-processing</p> <p>This filter enables stitching together ESI from individually gzipped fragments, saving processing power for re-compression on the client side at the expense of some compression efficiency.</p> </li> </ul> <p>Additional VFP filters are available from VMODs.</p> <p>By default, beresp.filters is constructed as follows:</p> <ul class="simple"> <li>
<code>gunzip</code> gets added for gzipped content if <code>beresp.do_gunzip</code> or <code>beresp.do_esi</code> are true.</li> <li>
<code>esi_gzip</code> gets added if <code>beresp.do_esi</code> is true together with <code>beresp.do_gzip</code> or content is already compressed.</li> <li>
<code>esi</code> gets added if <code>beresp.do_esi</code> is true</li> <li>
<code>gzip</code> gets added for uncompressed content if <code>beresp.do_gzip</code> is true</li> <li>
<code>testgunzip</code> gets added for compressed content if <code>beresp.do_gunzip</code> is false.</li> </ul> <p>After beresp.filters is set, using any of the beforementioned <code>beresp.do_*</code> switches is a VCL error.</p>  <p id="beresp-grace">beresp.grace</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Cache-Control <code>stale-while-revalidate</code> directive, or <code>default_grace</code> parameter.</p> <p>Set to a period to enable grace.</p>  <p id="beresp-http">beresp.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Unsetable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP headers returned from the server.</p> <p>See <a class="reference internal" href="#req-http">req.http</a> for general notes.</p>  <p>beresp.http.content-length</p>  <p>Type: HEADER</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The content-length header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p>beresp.http.transfer-encoding</p>  <p>Type: HEADER</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The transfer-encoding header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p id="beresp-keep">beresp.keep</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: <code>default_keep</code> parameter.</p> <p>Set to a period to enable conditional backend requests.</p> <p>The keep time is cache lifetime in addition to the ttl.</p> <p>Objects with ttl expired but with keep time left may be used to issue conditional (If-Modified-Since / If-None-Match) requests to the backend to refresh them.</p>  <p>beresp.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP protocol version the backend replied with.</p>  <p id="beresp-proto">beresp.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP protocol version the backend replied with.</p>  <p id="beresp-reason">beresp.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP status message returned by the server.</p>  <p id="beresp-status">beresp.status</p>  <p>Type: INT</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The HTTP status code returned by the server.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p>  <p id="beresp-storage">beresp.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>The storage backend to use to save this object.</p>  <p>beresp.storage_hint <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Deprecated since varnish 5.1 and discontinued since VCL 4.1 (varnish 6.0). Use beresp.storage instead.</p> <p>Hint to Varnish that you want to save this object to a particular storage backend.</p>  <p id="beresp-time">beresp.time</p>  <p>Type: TIME</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>When the backend headers were fully received just before <code>vcl_backend_response {}</code> was entered, or when <code>vcl_backend_error {}</code> was entered.</p>  <p id="beresp-transit-buffer">beresp.transit_buffer</p>  <p>Type: BYTES</p> <p>Readable from: vcl_backend_response</p> <p>Writable from: vcl_backend_response</p> <p>Default: <code>transit_buffer</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p> <p>The maximum number of bytes the client can be ahead of the backend during a streaming pass if <code>beresp</code> is uncacheable. See also <code>transit_buffer</code> parameter documentation in <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a>.</p>  <p id="beresp-ttl">beresp.ttl</p>  <p>Type: DURATION</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Default: Cache-Control <code>s-maxage</code> or <code>max-age</code> directives, or a value computed from the Expires header’s deadline, or the <code>default_ttl</code> parameter.</p> <p>The object’s remaining time to live, in seconds.</p>  <p id="beresp-uncacheable">beresp.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>Writable from: vcl_backend_response, vcl_backend_error</p> <p>Inherited from bereq.uncacheable, see there.</p> <p>Setting this variable makes the object uncacheable.</p> <p>This may may produce a hit-for-miss object in the cache.</p> <p>Clearing the variable has no effect and will log the warning “Ignoring attempt to reset beresp.uncacheable”.</p>  <p id="beresp-was-304">beresp.was_304</p>  <p>Type: BOOL</p> <p>Readable from: vcl_backend_response, vcl_backend_error</p> <p>When <code>true</code> this indicates that we got a 304 response to our conditional fetch from the backend and turned that into <code>beresp.status = 200</code></p>  </section> <section id="obj"> <h4>obj</h4> <p>This is the object we found in cache. It cannot be modified.</p> <p id="obj-age">obj.age</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The age of the object.</p>  <p id="obj-can-esi">obj.can_esi</p>  <p>Type: BOOL</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>If the object can be ESI processed, that is if setting <code>resp.do_esi</code> or adding <code>esi</code> to <code>resp.filters</code> in <code>vcl_deliver {}</code> would cause the response body to be ESI processed.</p>  <p id="obj-grace">obj.grace</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s grace period in seconds.</p>  <p id="obj-hits">obj.hits</p>  <p>Type: INT</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The count of cache-hits on this object.</p> <p>In <code>vcl_deliver</code> a value of 0 indicates a cache miss.</p>  <p id="obj-http">obj.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_hit</p> <p>The HTTP headers stored in the object.</p> <p>See <a class="reference internal" href="#req-http">req.http</a> for general notes.</p>  <p id="obj-keep">obj.keep</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s keep period in seconds.</p>  <p id="obj-proto">obj.proto</p>  <p>Type: STRING</p> <p>Readable from: vcl_hit</p> <p>The HTTP protocol version stored in the object.</p>  <p id="obj-reason">obj.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_hit</p> <p>The HTTP reason phrase stored in the object.</p>  <p id="obj-status">obj.status</p>  <p>Type: INT</p> <p>Readable from: vcl_hit</p> <p>The HTTP status code stored in the object.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p>  <p id="obj-storage">obj.storage</p>  <p>Type: STEVEDORE</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The storage backend where this object is stored.</p>  <p id="obj-time">obj.time</p>  <p>Type: TIME</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The time the object was created from the perspective of the server which generated it. This will roughly be equivalent to <code>now</code> - <code>obj.age</code>.</p>  <p id="obj-ttl">obj.ttl</p>  <p>Type: DURATION</p> <p>Readable from: vcl_hit, vcl_deliver</p> <p>The object’s remaining time to live, in seconds.</p>  <p id="obj-uncacheable">obj.uncacheable</p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver</p> <p>Whether the object is uncacheable (pass, hit-for-pass or hit-for-miss).</p>  </section> <section id="resp"> <h4>resp</h4> <p>This is the response we send to the client, it is built from either <code>beresp</code> (pass/miss), <code>obj</code> (hits) or created from whole cloth (synth).</p> <p>With the exception of <code>resp.body</code> all <code>resp.*</code> variables available in both <code>vcl_deliver{}</code> and <code>vcl_synth{}</code> as a matter of symmetry.</p> <p>resp</p>  <p>Type: HTTP</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The entire response HTTP data structure, useful as argument to VMODs.</p>  <p id="resp-body">resp.body</p>  <p>Type: BODY</p> <p>Writable from: vcl_synth</p> <p>To produce a synthetic response body, for instance for errors.</p>  <p id="resp-do-esi">resp.do_esi <code>VCL &gt;= 4.1</code></p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>Default: obj.can_esi</p> <p>This can be used to selectively disable ESI processing, even though ESI parsing happened during fetch (see beresp.do_esi). This is useful when Varnish caches peer with each other.</p> <p>It is a VCL error to use resp.do_esi after setting resp.filters.</p>  <p id="resp-filters">resp.filters</p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>List of VDP filters the resp.body will be pushed through.</p> <p>Before resp.filters is set, the value read will be the default filter list as determined by varnish based on resp.do_esi and request headers.</p> <p>After resp.filters is set, changing any of the conditions which otherwise determine the filter selection will have no effiect. Using resp.do_esi is an error once resp.filters is set.</p>  <p id="resp-http">resp.http.*</p>  <p>Type: HEADER</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>Unsetable from: vcl_deliver, vcl_synth</p> <p>The HTTP headers that will be returned.</p> <p>See <a class="reference internal" href="#req-http">req.http</a> for general notes.</p>  <p>resp.http.content-length</p>  <p>Type: HEADER</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The content-length header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p>resp.http.transfer-encoding</p>  <p>Type: HEADER</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The transfer-encoding header field is protected, see <a class="reference internal" href="#protected-headers">protected_headers</a>.</p>  <p id="resp-is-streaming">resp.is_streaming</p>  <p>Type: BOOL</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Returns true when the response will be streamed while being fetched from the backend.</p>  <p>resp.proto <code>VCL &lt;= 4.0</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP protocol version to use for the response.</p>  <p id="resp-proto">resp.proto <code>VCL &gt;= 4.1</code></p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The HTTP protocol version to use for the response.</p>  <p id="resp-reason">resp.reason</p>  <p>Type: STRING</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP status message that will be returned.</p>  <p id="resp-status">resp.status</p>  <p>Type: INT</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>Writable from: vcl_deliver, vcl_synth</p> <p>The HTTP status code that will be returned.</p> <p>More information in the <a class="reference internal" href="#http-response-status">HTTP response status</a> section.</p> <p>resp.status 200 will get changed into 304 by core code after a return(deliver) from vcl_deliver for conditional requests to cached content if validation succeeds.</p> <p>For the validation, first <code>req.http.If-None-Match</code> is compared against <code>resp.http.Etag</code>. If they compare equal according to the rules for weak validation (see RFC7232), a 304 is sent.</p> <p>Secondly, <code>req.http.If-Modified-Since</code> is compared against <code>resp.http.Last-Modified</code> or, if it is unset or weak, against the point in time when the object was last modified based on the <code>Date</code> and <code>Age</code> headers received with the backend response which created the object. If the object has not been modified based on that comparison, a 304 is sent.</p>  <p id="resp-time">resp.time</p>  <p>Type: TIME</p> <p>Readable from: vcl_deliver, vcl_synth</p> <p>The time when we started preparing the response, just before entering <code>vcl_synth {}</code> or <code>vcl_deliver {}</code>.</p>  </section> <section id="special-variables"> <h4>Special variables</h4> <p id="now">now</p>  <p>Type: TIME</p> <p>Readable from: all</p> <p>The current time, in seconds since the UNIX epoch.</p> <p>When converted to STRING in expressions it returns a formatted timestamp like <code>Tue, 20 Feb 2018 09:30:31 GMT</code></p> <p><code>now</code> remains stable for the duration of any built-in VCL subroutine to make time-based calculations predictable and avoid edge cases.</p> <p>In other words, even if considerable amounts of time are spent in VCL, <code>now</code> will always represent the point in time when the respective built-in VCL subroutine was entered. <code>now</code> is thus not suitable for any kind of time measurements. See <a class="reference internal" href="vmod_std.html#std-timestamp"><span class="std std-ref">VOID timestamp(STRING s)</span></a>, <a class="reference internal" href="vmod_std.html#std-now"><span class="std std-ref">TIME now()</span></a> and <a class="reference internal" href="vmod_std.html#std-timed-call"><span class="std std-ref">DURATION timed_call(SUB)</span></a> in <a class="reference internal" href="vmod_std.html#vmod-std-3"><span class="std std-ref">VMOD std - Varnish Standard Module</span></a>.</p>  </section> <section id="sess"> <h4>sess</h4> <p>A session corresponds to the “conversation” that Varnish has with a single client connection, over which one or more request/response transactions may take place. It may comprise the traffic over an HTTP/1 keep-alive connection, or the multiplexed traffic over an HTTP/2 connection.</p> <p id="sess-idle-send-timeout">sess.idle_send_timeout</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Send timeout for individual pieces of data on client connections, defaults to the <code>idle_send_timeout</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p id="sess-send-timeout">sess.send_timeout</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Total timeout for ordinary HTTP1 responses, defaults to the <code>send_timeout</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p id="sess-timeout-idle">sess.timeout_idle</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Idle timeout for this session, defaults to the <code>timeout_idle</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p id="sess-timeout-linger">sess.timeout_linger</p>  <p>Type: DURATION</p> <p>Readable from: client</p> <p>Writable from: client</p> <p>Linger timeout for this session, defaults to the <code>timeout_linger</code> parameter, see <a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a></p>  <p id="sess-xid">sess.xid <code>VCL &gt;= 4.1</code></p>  <p>Type: INT</p> <p>Readable from: client, backend</p> <p>Unique ID of this session.</p>  </section> <section id="storage"> <h4>storage</h4> <p id="storage-free-space">storage.&lt;name&gt;.free_space</p>  <p>Type: BYTES</p> <p>Readable from: client, backend</p> <p>Free space available in the named stevedore. Only available for the malloc stevedore.</p>  <p id="storage-happy">storage.&lt;name&gt;.happy</p>  <p>Type: BOOL</p> <p>Readable from: client, backend</p> <p>Health status for the named stevedore. Not available in any of the current stevedores.</p>  <p id="storage-used-space">storage.&lt;name&gt;.used_space</p>  <p>Type: BYTES</p> <p>Readable from: client, backend</p> <p>Used space in the named stevedore. Only available for the malloc stevedore.</p>  </section> <section id="protected-header-fields"> <h4 id="protected-headers">Protected header fields</h4> <p>The <code>content-length</code> and <code>transfer-encoding</code> headers are read-only. They must be preserved to ensure HTTP/1 framing remains consistent and maintain a proper request and response synchronization with both clients and backends.</p> <p>VMODs can still update these headers, when there is a reason to change the framing, such as a transformation of a request or response body.</p> </section> <section id="http-response-status"> <h4>HTTP response status</h4> <p>A HTTP status code has 3 digits XYZ where X must be between 1 and 5 included. Since it is not uncommon to see HTTP clients or servers relying on non-standard or even invalid status codes, Varnish can work with any status between 100 and 999.</p> <p>Within VCL code it is even possible to use status codes in the form VWXYZ as long as the overall value is lower than 65536, but only the XYZ part will be sent to the client, by which time the X must also have become non-zero.</p> <p>The VWXYZ form of status codes can be communicate extra information in <code>resp.status</code> and <code>beresp.status</code> to <code>return(synth(...))</code> and <code>return(error(...))</code>, to indicate which synthetic content to produce:</p> <pre data-language="python">sub vcl_recv {
    if ([...]) {
        return synth(12404);
    }
}

sub vcl_synth {
    if (resp.status == 12404) {
        [...]       // this specific 404
    } else if (resp.status % 1000 == 404) {
        [...]       // all other 404's
    }
}
</pre> <p>The <code>obj.status</code> variable will inherit the VWXYZ form, but in a ban expression only the XYZ part will be available. The VWXYZ form is strictly limited to VCL execution.</p> <p>Assigning an HTTP standardized code to <code>resp.status</code> or <code>beresp.status</code> will also set <code>resp.reason</code> or <code>beresp.reason</code> to the corresponding status message.</p> <section id="handling"> <h5>304 handling</h5> <p>For a 304 response, Varnish core code amends <code>beresp</code> before calling <code>vcl_backend_response</code>:</p> <ul class="simple"> <li>If the gzip status changed, <code>Content-Encoding</code> is unset and any <code>Etag</code> is weakened</li> <li>Any headers not present in the 304 response are copied from the existing cache object. <code>Content-Length</code> is copied if present in the existing cache object and discarded otherwise.</li> <li>The status gets set to 200.</li> </ul> <p><code>beresp.was_304</code> marks that this conditional response processing has happened.</p> <p>Note: Backend conditional requests are independent of client conditional requests, so clients may receive 304 responses no matter if a backend request was conditional.</p> </section> <section id="beresp-ttl-beresp-grace-beresp-keep"> <h5>beresp.ttl / beresp.grace / beresp.keep</h5> <p>Before calling <code>vcl_backend_response</code>, core code sets <code>beresp.ttl</code> based on the response status and the response headers <code>Age</code>, <code>Cache-Control</code> or <code>Expires</code> and <code>Date</code> as follows:</p> <ul class="simple"> <li>If present and valid, the value of the <code>Age</code> header is effectively deduced from all ttl calculations.</li> <li>
<p>For status codes 200, 203, 204, 300, 301, 304, 404, 410 and 414:</p> <ul> <li>If <code>Cache-Control</code> contains an <code>s-maxage</code> or <code>max-age</code> field (in that order of preference), the ttl is set to the respective non-negative value or 0 if negative.</li> <li>Otherwise, if no <code>Expires</code> header exists, the default ttl is used.</li> <li>Otherwise, if <code>Expires</code> contains a time stamp before <code>Date</code>, the ttl is set to 0.</li> <li>
<p>Otherwise, if no <code>Date</code> header is present or the <code>Date</code> header timestamp differs from the local clock by no more than the <code>clock_skew</code> parameter, the ttl is set to</p> <ul> <li>0 if <code>Expires</code> denotes a past timestamp or</li> <li>the difference between the local clock and the <code>Expires</code> header otherwise.</li> </ul> </li> <li>Otherwise, the ttl is set to the difference between <code>Expires</code> and <code>Date</code>
</li> </ul> </li> <li>For status codes 302 and 307, the calculation is identical except that the default ttl is not used and -1 is returned if neither <code>Cache-Control</code> nor <code>Expires</code> exists.</li> <li>For all other status codes, ttl -1 is returned.</li> </ul> <p><code>beresp.grace</code> defaults to the <code>default_grace</code> parameter.</p> <p>For a non-negative ttl, if <code>Cache-Control</code> contains a <code>stale-while-revalidate</code> field value, <code>beresp.grace</code> is set to that value if non-negative or 0 otherwise.</p> <p><code>beresp.keep</code> defaults to the <code>default_keep</code> parameter.</p> </section> </section> </section> <section id="see-also"> <h3>SEE ALSO</h3> <ul class="simple"> <li><a class="reference internal" href="varnishd.html#varnishd-1"><span class="std std-ref">varnishd</span></a></li> <li><a class="reference internal" href="vcl.html#vcl-7"><span class="std std-ref">VCL</span></a></li> </ul> </section> <section id="history"> <h3>HISTORY</h3> <p>VCL was developed by Poul-Henning Kamp in cooperation with Verdens Gang AS, Redpill Linpro and Varnish Software. This manual page is written by Per Buer, Poul-Henning Kamp, Martin Blix Grydeland, Kristian Lyngstøl, Lasse Karstensen and others.</p> </section> <section id="copyright"> <h3>COPYRIGHT</h3> <p>This document is licensed under the same license as Varnish itself. See LICENSE for details.</p> <ul class="simple"> <li>Copyright (c) 2006 Verdens Gang AS</li> <li>Copyright (c) 2006-2021 Varnish Software AS</li> </ul> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2006 Verdens Gang AS<br>Copyright &copy; 2006&ndash;2020 Varnish Software AS<br>Licensed under the BSD-2-Clause License.<br>
    <a href="https://varnish-cache.org/docs/7.4/reference/vcl-var.html" class="_attribution-link">https://varnish-cache.org/docs/7.4/reference/vcl-var.html</a>
  </p>
</div>
