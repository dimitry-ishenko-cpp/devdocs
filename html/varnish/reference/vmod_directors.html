<h1 id="vmod-directors-3">VMOD directors - Varnish Directors Module</h1> <section id="synopsis"> <h2>SYNOPSIS</h2> <pre class="literal-block">import directors [as name] [from "path"]

<a class="reference internal" href="#directors-round-robin"><span class="std std-ref">new xround_robin = directors.round_robin()</span></a>

    <a class="reference internal" href="#xround-robin-add-backend"><span class="std std-ref">VOID xround_robin.add_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xround-robin-remove-backend"><span class="std std-ref">VOID xround_robin.remove_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xround-robin-backend"><span class="std std-ref">BACKEND xround_robin.backend()</span></a>

<a class="reference internal" href="#directors-fallback"><span class="std std-ref">new xfallback = directors.fallback(BOOL sticky=0)</span></a>

    <a class="reference internal" href="#xfallback-add-backend"><span class="std std-ref">VOID xfallback.add_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xfallback-remove-backend"><span class="std std-ref">VOID xfallback.remove_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xfallback-backend"><span class="std std-ref">BACKEND xfallback.backend()</span></a>

<a class="reference internal" href="#directors-random"><span class="std std-ref">new xrandom = directors.random()</span></a>

    <a class="reference internal" href="#xrandom-add-backend"><span class="std std-ref">VOID xrandom.add_backend(BACKEND, REAL)</span></a>

    <a class="reference internal" href="#xrandom-remove-backend"><span class="std std-ref">VOID xrandom.remove_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xrandom-backend"><span class="std std-ref">BACKEND xrandom.backend()</span></a>

<a class="reference internal" href="#directors-hash"><span class="std std-ref">new xhash = directors.hash()</span></a>

    <a class="reference internal" href="#xhash-add-backend"><span class="std std-ref">VOID xhash.add_backend(BACKEND, REAL weight=1.0)</span></a>

    <a class="reference internal" href="#xhash-remove-backend"><span class="std std-ref">VOID xhash.remove_backend(BACKEND)</span></a>

    <a class="reference internal" href="#xhash-backend"><span class="std std-ref">BACKEND xhash.backend(STRING)</span></a>

<a class="reference internal" href="#directors-shard"><span class="std std-ref">new xshard = directors.shard()</span></a>

    <a class="reference internal" href="#xshard-set-warmup"><span class="std std-ref">VOID xshard.set_warmup(REAL probability=0.0)</span></a>

    <a class="reference internal" href="#xshard-set-rampup"><span class="std std-ref">VOID xshard.set_rampup(DURATION duration=0)</span></a>

    <a class="reference internal" href="#xshard-associate"><span class="std std-ref">VOID xshard.associate(BLOB param=0)</span></a>

    <a class="reference internal" href="#xshard-add-backend"><span class="std std-ref">BOOL xshard.add_backend(BACKEND backend, [STRING ident], [DURATION rampup], [REAL weight])</span></a>

    <a class="reference internal" href="#xshard-remove-backend"><span class="std std-ref">BOOL xshard.remove_backend([BACKEND backend], [STRING ident])</span></a>

    <a class="reference internal" href="#xshard-clear"><span class="std std-ref">BOOL xshard.clear()</span></a>

    <a class="reference internal" href="#xshard-reconfigure"><span class="std std-ref">BOOL xshard.reconfigure(INT replicas=67)</span></a>

    <a class="reference internal" href="#xshard-key"><span class="std std-ref">INT xshard.key(STRING)</span></a>

    <a class="reference internal" href="#xshard-backend"><span class="std std-ref">BACKEND xshard.backend([ENUM by], [INT key], [BLOB key_blob], [INT alt], [REAL warmup], [BOOL rampup], [ENUM healthy], [BLOB param], [ENUM resolve])</span></a>

    <a class="reference internal" href="#xshard-debug"><span class="std std-ref">VOID xshard.debug(INT)</span></a>

<a class="reference internal" href="#directors-shard-param"><span class="std std-ref">new xshard_param = directors.shard_param()</span></a>

    <a class="reference internal" href="#xshard-param-clear"><span class="std std-ref">VOID xshard_param.clear()</span></a>

    <a class="reference internal" href="#xshard-param-set"><span class="std std-ref">VOID xshard_param.set([ENUM by], [INT key], [BLOB key_blob], [INT alt], [REAL warmup], [BOOL rampup], [ENUM healthy])</span></a>

    <a class="reference internal" href="#xshard-param-get-by"><span class="std std-ref">STRING xshard_param.get_by()</span></a>

    <a class="reference internal" href="#xshard-param-get-key"><span class="std std-ref">INT xshard_param.get_key()</span></a>

    <a class="reference internal" href="#xshard-param-get-alt"><span class="std std-ref">INT xshard_param.get_alt()</span></a>

    <a class="reference internal" href="#xshard-param-get-warmup"><span class="std std-ref">REAL xshard_param.get_warmup()</span></a>

    <a class="reference internal" href="#xshard-param-get-rampup"><span class="std std-ref">BOOL xshard_param.get_rampup()</span></a>

    <a class="reference internal" href="#xshard-param-get-healthy"><span class="std std-ref">STRING xshard_param.get_healthy()</span></a>

    <a class="reference internal" href="#xshard-param-use"><span class="std std-ref">BLOB xshard_param.use()</span></a>

<a class="reference internal" href="#directors-lookup"><span class="std std-ref">BACKEND lookup(STRING)</span></a></pre> </section> <section id="description"> <h2>DESCRIPTION</h2> <p><em>vmod_directors</em> enables backend load balancing in Varnish.</p> <p>The module implements load balancing techniques, and also serves as an example on how one could extend the load balancing capabilities of Varnish.</p> <p>To enable load balancing you must import this vmod (directors).</p> <p>Then you define your backends. Once you have the backends declared you can add them to a director. This happens in executed VCL code. If you want to emulate the previous behavior of Varnish 3.0 you can just initialize the directors in <code>vcl_init{}</code>, like this:</p> <pre data-language="python">sub vcl_init {
    new vdir = directors.round_robin();
    vdir.add_backend(backend1);
    vdir.add_backend(backend2);
}
</pre> <p>As you can see there is nothing keeping you from manipulating the directors elsewhere in VCL. So, you could have VCL code that would add more backends to a director when a certain URL is called.</p> <p>Note that directors can use other directors as backends.</p> <section id="new-xround-robin-directors-round-robin"> <h3 id="directors-round-robin">new xround_robin = directors.round_robin()</h3> <p>Create a round robin director.</p> <p>This director will pick backends in a round robin fashion.</p> <p>Example:</p> <pre data-language="python">new vdir = directors.round_robin();
</pre> </section> <section id="void-xround-robin-add-backend-backend"> <h3 id="xround-robin-add-backend">VOID xround_robin.add_backend(BACKEND)</h3> <p>Add a backend to the round-robin director.</p> <p>Example:</p> <pre data-language="python">vdir.add_backend(backend1);
</pre> </section> <section id="void-xround-robin-remove-backend-backend"> <h3 id="xround-robin-remove-backend">VOID xround_robin.remove_backend(BACKEND)</h3> <p>Remove a backend from the round-robin director.</p> <p>Example:</p> <pre data-language="python">vdir.remove_backend(backend1);
</pre> </section> <section id="backend-xround-robin-backend"> <h3 id="xround-robin-backend">BACKEND xround_robin.backend()</h3> <p>Pick a backend from the director.</p> <p>Example:</p> <pre data-language="python">set req.backend_hint = vdir.backend();
</pre> </section> <section id="new-xfallback-directors-fallback-bool-sticky-0"> <h3 id="directors-fallback">new xfallback = directors.fallback(BOOL sticky=0)</h3> <p>Create a fallback director.</p> <p>A fallback director will try each of the added backends in turn, and return the first one that is healthy.</p> <p>If <em>sticky</em> is set to <code>true</code>, the director will keep using the healthy backend, even if a higher-priority backend becomes available. Once the whole backend list is exhausted, it’ll start over at the beginning.</p> <p>Example:</p> <pre data-language="python">new vdir = directors.fallback();
</pre> </section> <section id="void-xfallback-add-backend-backend"> <h3 id="xfallback-add-backend">VOID xfallback.add_backend(BACKEND)</h3> <p>Add a backend to the director.</p> <p>Note that the order in which this is done matters for the fallback director.</p> <p>Example:</p> <pre data-language="python">vdir.add_backend(backend1);
</pre> </section> <section id="void-xfallback-remove-backend-backend"> <h3 id="xfallback-remove-backend">VOID xfallback.remove_backend(BACKEND)</h3> <p>Remove a backend from the director.</p> <p>Example:</p> <pre data-language="python">vdir.remove_backend(backend1);
</pre> </section> <section id="backend-xfallback-backend"> <h3 id="xfallback-backend">BACKEND xfallback.backend()</h3> <p>Pick a backend from the director.</p> <p>Example:</p> <pre data-language="python">set req.backend_hint = vdir.backend();
</pre> </section> <section id="new-xrandom-directors-random"> <h3 id="directors-random">new xrandom = directors.random()</h3> <p>Create a random backend director.</p> <p>The random director distributes load over the backends using a weighted random probability distribution.</p> <p>The “testable” random generator in varnishd is used, which enables deterministic tests to be run (See: <code>d00004.vtc</code>).</p> <p>Example:</p> <pre data-language="python">new vdir = directors.random();
</pre> </section> <section id="void-xrandom-add-backend-backend-real"> <h3 id="xrandom-add-backend">VOID xrandom.add_backend(BACKEND, REAL)</h3> <p>Add a backend to the director with a given weight.</p> <p>Each backend will receive approximately 100 * (weight / (sum(all_added_weights))) per cent of the traffic sent to this director.</p> <p>Example:</p> <pre data-language="python"># 2/3 to backend1, 1/3 to backend2.
vdir.add_backend(backend1, 10.0);
vdir.add_backend(backend2, 5.0);
</pre> </section> <section id="void-xrandom-remove-backend-backend"> <h3 id="xrandom-remove-backend">VOID xrandom.remove_backend(BACKEND)</h3> <p>Remove a backend from the director.</p> <p>Example:</p> <pre data-language="python">vdir.remove_backend(backend1);
</pre> </section> <section id="backend-xrandom-backend"> <h3 id="xrandom-backend">BACKEND xrandom.backend()</h3> <p>Pick a backend from the director.</p> <p>Example:</p> <pre data-language="python">set req.backend_hint = vdir.backend();
</pre> </section> <section id="new-xhash-directors-hash"> <h3 id="directors-hash">new xhash = directors.hash()</h3> <p>Create a hashing backend director.</p> <p>The director chooses the backend server by computing a hash/digest of the string given to <a class="reference internal" href="#xhash-backend">xhash.backend()</a>.</p> <p>Commonly used with <code>client.ip</code> or a session cookie to get sticky sessions.</p> <p>Example:</p> <pre data-language="python">new vdir = directors.hash();
</pre> </section> <section id="void-xhash-add-backend-backend-real-weight-1-0"> <h3 id="xhash-add-backend">VOID xhash.add_backend(BACKEND, REAL weight=1.0)</h3> <p>Add a backend to the director with a certain weight.</p> <p>Weight is used as in the random director. Recommended and default value is 1.0 unless you have special needs.</p> <p>Example:</p> <pre data-language="python">vdir.add_backend(normal_backend);
vdir.add_backend(larger_backend, 1.5);
</pre> </section> <section id="void-xhash-remove-backend-backend"> <h3 id="xhash-remove-backend">VOID xhash.remove_backend(BACKEND)</h3> <p>Remove a backend from the director.</p> <dl class="simple"> <dt>Example::</dt>
<dd>
<p>vdir.remove_backend(larger_backend);</p> </dd> </dl> </section> <section id="backend-xhash-backend-string"> <h3 id="xhash-backend">BACKEND xhash.backend(STRING)</h3> <p>Pick a backend from the hash director.</p> <p>Use the string or list of strings provided to pick the backend.</p> <dl class="simple"> <dt>Example::</dt>
<dd>
<p># pick a backend based on the cookie header from the client set req.backend_hint = vdir.backend(req.http.cookie);</p> </dd> </dl> </section> <section id="new-xshard-directors-shard"> <h3 id="directors-shard">new xshard = directors.shard()</h3> <p>Create a shard director.</p> <section id="introduction"> <h4>Introduction</h4> <p>The shard director selects backends by a key, which can be provided directly or derived from strings. For the same key, the shard director will always return the same backend, unless the backend configuration or health state changes. Conversely, for differing keys, the shard director will likely choose different backends. In the default configuration, unhealthy backends are not selected.</p> <p>The shard director resembles the hash director, but its main advantage is that, when the backend configuration or health states change, the association of keys to backends remains as stable as possible.</p> <p>In addition, the rampup and warmup features can help to further improve user-perceived response times.</p> </section> <section id="sharding"> <h4>Sharding</h4> <p>This basic technique allows for numerous applications like optimizing backend server cache efficiency, Varnish clustering or persisting sessions to servers without keeping any state, and, in particular, without the need to synchronize state between nodes of a cluster of Varnish servers:</p> <ul> <li>
<p>Many applications use caches for data objects, so, in a cluster of application servers, requesting similar objects from the same server may help to optimize efficiency of such caches.</p> <p>For example, sharding by URL or some <em>id</em> component of the url has been shown to drastically improve the efficiency of many content management systems.</p> </li> <li>
<p>As special case of the previous example, in clusters of Varnish servers without additional request distribution logic, each cache will need store all hot objects, so the effective cache size is approximately the smallest cache size of any server in the cluster.</p> <p>Sharding allows to segregate objects within the cluster such that each object is only cached on one of the servers (or on one primary and one backup, on a primary for long and others for short etc…). Effectively, this will lead to a cache size in the order of the sum of all individual caches, with the potential to drastically increase efficiency (scales by the number of servers).</p> </li> <li>Another application is to implement persistence of backend requests, such that all requests sharing a certain criterion (such as an IP address or session ID) get forwarded to the same backend server.</li> </ul> <p>When used with clusters of varnish servers, the shard director will, if otherwise configured equally, make the same decision on all servers. In other words, requests sharing a common criterion used as the shard key will be balanced onto the same backend server(s) no matter which Varnish server handles the request.</p> <p>The drawbacks are:</p> <ul class="simple"> <li>the distribution of requests depends on the number of requests per key and the uniformity of the distribution of key values. In short, while this technique may lead to much better efficiency overall, it may also lead to less good load balancing for specific cases.</li> <li>When a backend server becomes unavailable, every persistence technique has to reselect a new backend server, but this technique will also switch back to the preferred server once it becomes healthy again, so when used for persistence, it is generally less stable compared to stateful techniques (which would continue to use a selected server for as long as possible (or dictated by a TTL)).</li> </ul> </section> <section id="method"> <h4>Method</h4> <p>When <a class="reference internal" href="#xshard-reconfigure">xshard.reconfigure()</a> is called explicitly (or implicitly at the end of any task containing reconfigurations like <a class="reference internal" href="#xshard-add-backend">xshard.add_backend()</a>), a consistent hashing circular data structure gets built from the last 32 bits of SHA256 hash values of <em>&lt;ident&gt;</em><em>&lt;n&gt;</em> (default <em>ident</em> being the backend name) for each backend and for a running number <em>n</em> from 1 to the <em>replicas</em> argument to <a class="reference internal" href="#xshard-reconfigure">xshard.reconfigure()</a>. Hashing creates the seemingly random order for placement of backends on the consistent hashing ring. When <a class="reference internal" href="#xshard-add-backend">xshard.add_backend()</a> was called with a <em>weight</em> argument, <em>replicas</em> is scaled by that weight to add proportionally more copies of the that backend on the ring.</p> <p>When <a class="reference internal" href="#xshard-backend">xshard.backend()</a> is called, a load balancing key gets generated unless provided. The smallest hash value in the circle is looked up that is larger than the key (searching clockwise and wrapping around as necessary). The backend for this hash value is the preferred backend for the given key.</p> <p>If a healthy backend is requested, the search is continued linearly on the ring as long as backends found are unhealthy or all backends have been checked. The order of these “alternative backends” on the ring is likely to differ for different keys. Alternative backends can also be selected explicitly.</p> <p>On consistent hashing see:</p> <ul class="simple"> <li><a class="reference external" href="http://www8.org/w8-papers/2a-webserver/caching/paper2.html">http://www8.org/w8-papers/2a-webserver/caching/paper2.html</a></li> <li><a class="reference external" href="http://www.audioscrobbler.net/development/ketama/">http://www.audioscrobbler.net/development/ketama/</a></li> <li>svn://svn.audioscrobbler.net/misc/ketama</li> <li><a class="reference external" href="http://en.wikipedia.org/wiki/Consistent_hashing">http://en.wikipedia.org/wiki/Consistent_hashing</a></li> </ul> </section> <section id="error-reporting"> <h4>Error Reporting</h4> <p>Failing methods should report errors to VSL with the Error tag, so when configuring the shard director, you are advised to check:</p> <pre data-language="python">varnishlog -I Error:^vmod_directors.shard
</pre> <p>Additional information may be provided as Notices, which can be checked using</p>  <p>varnishlog -I Notice:^vmod_directors.shard</p>  </section> </section> <section id="void-xshard-set-warmup-real-probability-0-0"> <h3 id="xshard-set-warmup">VOID xshard.set_warmup(REAL probability=0.0)</h3> <p>Set the default warmup probability. See the <em>warmup</em> parameter of <a class="reference internal" href="#xshard-backend">xshard.backend()</a>. If <em>probability</em> is 0.0 (default), warmup is disabled.</p> </section> <section id="void-xshard-set-rampup-duration-duration-0"> <h3 id="xshard-set-rampup">VOID xshard.set_rampup(DURATION duration=0)</h3> <p>Set the default rampup duration. See <em>rampup</em> parameter of <a class="reference internal" href="#xshard-backend">xshard.backend()</a>. If <em>duration</em> is 0 (default), rampup is disabled.</p> </section> <section id="void-xshard-associate-blob-param-0"> <h3 id="xshard-associate">VOID xshard.associate(BLOB param=0)</h3> <p>Associate a default <a class="reference internal" href="#directors-shard-param">directors.shard_param()</a> object or clear an association.</p> <p>The value of the <em>param</em> argument must be a call to the <a class="reference internal" href="#xshard-param-use">xshard_param.use()</a> method. No argument clears the association.</p> <p>The association can be changed per backend request using the <em>param</em> argument of <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="bool-xshard-add-backend-backend-backend-string-ident-duration-rampup-real-weight"> <h3 id="xshard-add-backend">BOOL xshard.add_backend(BACKEND backend, [STRING ident], [DURATION rampup], [REAL weight])</h3> <pre data-language="python">BOOL xshard.add_backend(
      BACKEND backend,
      [STRING ident],
      [DURATION rampup],
      [REAL weight]
)
</pre> <p>Add a backend <em>backend</em> to the director.</p> <p><em>ident</em>: Optionally specify an identification string for this backend, which will be hashed by <a class="reference internal" href="#xshard-reconfigure">xshard.reconfigure()</a> to construct the consistent hashing ring. The identification string defaults to the backend name.</p> <p><em>ident</em> allows to add multiple instances of the same backend.</p> <p><em>rampup</em>: Optionally specify a specific rampup time for this backend. Otherwise, the per-director rampup time is used (see <a class="reference internal" href="#xshard-set-rampup">xshard.set_rampup()</a>).</p> <p><em>weight</em>: Optionally specify a weight to scale the <a class="reference internal" href="#xshard-reconfigure">xshard.reconfigure()</a> <em>replicas</em> parameter. <em>weight</em> is limited to at least 1. Values above 10 probably do not make much sense. The effect of <em>weight</em> is also capped such that the total number of replicas does not exceed <code>UINT32_MAX</code>.</p> </section> <section id="bool-xshard-remove-backend-backend-backend-string-ident"> <h3 id="xshard-remove-backend">BOOL xshard.remove_backend([BACKEND backend], [STRING ident])</h3> <pre data-language="python">BOOL xshard.remove_backend(
      [BACKEND backend=0],
      [STRING ident=0]
)
</pre> <p>Remove backend(s) from the director. Either <em>backend</em> or <em>ident</em> must be specified. <em>ident</em> removes a specific instance. If <em>backend</em> is given without <em>ident</em>, all instances of this backend are removed.</p> </section> <section id="bool-xshard-clear"> <h3 id="xshard-clear">BOOL xshard.clear()</h3> <p>Remove all backends from the director.</p> </section> <section id="bool-xshard-reconfigure-int-replicas-67"> <h3 id="xshard-reconfigure">BOOL xshard.reconfigure(INT replicas=67)</h3> <p>Explicitly reconfigure the consistent hashing ring to reflect backend changes to become effective immediately.</p> <p>If this method is not called explicitly, reconfiguration happens at the end of the current task (after <code>vcl_init {}</code> or when the current client or backend task is finished).</p> </section> <section id="int-xshard-key-string"> <h3 id="xshard-key">INT xshard.key(STRING)</h3> <p>Convenience method to generate a sharding key for use with the <em>key</em> argument to the <a class="reference internal" href="#xshard-backend">xshard.backend()</a> method by hashing the given string with SHA256.</p> <p>To generate sharding keys using other hashes, use a custom vmod like <a class="reference external" href="https://code.uplex.de/uplex-varnish/libvmod-blobdigest/blob/master/README.rst">vmod blobdigest</a> with the <em>key_blob</em> argument of the <a class="reference internal" href="#xshard-backend">xshard.backend()</a> method.</p> </section> <section id="backend-xshard-backend-enum-by-int-key-blob-key-blob-int-alt-real-warmup-bool-rampup-enum-healthy-blob-param-enum-resolve"> <h3 id="xshard-backend">BACKEND xshard.backend([ENUM by], [INT key], [BLOB key_blob], [INT alt], [REAL warmup], [BOOL rampup], [ENUM healthy], [BLOB param], [ENUM resolve])</h3> <pre data-language="python">BACKEND xshard.backend(
      [ENUM {HASH, URL, KEY, BLOB} by=HASH],
      [INT key],
      [BLOB key_blob],
      [INT alt=0],
      [REAL warmup=-1],
      [BOOL rampup=1],
      [ENUM {CHOSEN, IGNORE, ALL} healthy=CHOSEN],
      [BLOB param],
      [ENUM {NOW, LAZY} resolve]
)
</pre> <p>Lookup a backend on the consistent hashing ring.</p> <p>This documentation uses the notion of an order of backends for a particular shard key. This order is deterministic but seemingly random as determined by the consistent hashing algorithm and is likely to differ for different keys, depending on the number of backends and the number of replicas. In particular, the backend order referred to here is _not_ the order given when backends are added.</p> <ul> <li>
<p><em>by</em> how to determine the sharding key</p> <ul class="simple"> <li>
<p><code>HASH</code>:</p> <ul> <li>when called in backend context and in <code>vcl_pipe {}</code>: Use the varnish hash value as set by <code>vcl_hash{}</code>
</li> <li>when called in client context other than <code>vcl_pipe {}</code>: hash <code>req.url</code>
</li> </ul> </li> <li>
<code>URL</code>: hash req.url / bereq.url</li> <li>
<code>KEY</code>: use the <em>key</em> argument</li> <li>
<code>BLOB</code>: use the <em>key_blob</em> argument</li> </ul> </li> <li>
<p><em>key</em> lookup key with <code>by=KEY</code></p> <p>the <a class="reference internal" href="#xshard-key">xshard.key()</a> method may come handy to generate a sharding key from custom strings.</p> </li> <li>
<p><em>key_blob</em> lookup key with <code>by=BLOB</code></p> <p>Currently, this uses the first 4 bytes from the given blob in network byte order (big endian), left-padded with zeros for blobs smaller than 4 bytes.</p> </li> <li>
<p><em>alt</em> alternative backend selection</p> <p>Select the <em>alt</em>-th alternative backend for the given <em>key</em>.</p> <p>This is particularly useful for retries / restarts due to backend errors: By setting <code>alt=req.restarts</code> or <code>alt=bereq.retries</code> with healthy=ALL, another server gets selected.</p> <p>The rampup and warmup features are only active for <code>alt==0</code></p> </li> <li>
<p><em>rampup</em> slow start for servers which just went healthy</p> <p>If <code>alt==0</code> and the chosen backend is in its rampup period, with a probability proportional to the fraction of time since the backup became healthy to the rampup period, return the next alternative backend, unless this is also in its rampup period.</p> <p>The default rampup interval can be set per shard director using the <a class="reference internal" href="#xshard-set-rampup">xshard.set_rampup()</a> method or specifically per backend with the <a class="reference internal" href="#xshard-add-backend">xshard.add_backend()</a> method.</p> </li> <li>
<p><em>warmup</em> probabilistic alternative server selection</p> <p>possible values: -1, 0..1</p> <p><code>-1</code>: use the warmup probability from the director definition</p> <p>Only used for <code>alt==0</code>: Sets the ratio of requests (0.0 to 1.0) that goes to the next alternate backend to warm it up when the preferred backend is healthy. Not active if any of the preferred or alternative backend are in rampup.</p> <p><code>warmup=0.5</code> is a convenient way to spread the load for each key over two backends under normal operating conditions.</p> </li> <li>
<p><em>healthy</em></p> <ul> <li>
<p>CHOSEN: Return a healthy backend if possible.</p> <p>For <code>alt==0</code>, return the first healthy backend or none.</p> <p>For <code>alt &gt; 0</code>, ignore the health state of backends skipped for alternative backend selection, then return the next healthy backend. If this does not exist, return the last healthy backend of those skipped or none.</p> </li> <li>
<p>IGNORE: Completely ignore backend health state</p> <p>Just return the first or <em>alt</em>-th alternative backend, ignoring health state, <em>rampup</em> and <em>warmup</em>.</p> </li> <li>
<p>ALL: Check health state also for alternative backend selection</p> <p>For <code>alt &gt; 0</code>, return the <em>alt</em>-th alternative backend of all those healthy, the last healthy backend found or none.</p> </li> </ul> </li> <li>
<p><em>resolve</em></p> <p>default: <code>LAZY</code> in <code>vcl_init{}</code>, <code>NOW</code> otherwise</p> <ul> <li>
<p><code>NOW</code>: look up a backend and return it.</p> <p>Can not be used in <code>vcl_init{}</code>.</p> </li> <li>
<p><code>LAZY</code>: return an instance of this director for later backend resolution.</p> <p><code>LAZY</code> mode is required for referencing shard director instances, for example as backends for other directors (director layering).</p> <p>In <code>vcl_init{}</code> and on the client side, <code>LAZY</code> mode can not be used with any other argument.</p> <p>On the backend side and in <code>vcl_pipe {}</code>, parameters from arguments or an associated parameter set affect the shard director instance for the backend request irrespective of where it is referenced.</p> </li> </ul> </li> <li>
<p><em>param</em></p> <p>Use or associate a parameter set. The value of the <em>param</em> argument must be a call to the <a class="reference internal" href="#xshard-param-use">xshard_param.use()</a> method.</p> <p>default: as set by <a class="reference internal" href="#xshard-associate">xshard.associate()</a> or unset.</p> <ul> <li>for <code>resolve=NOW</code> take parameter defaults from the <a class="reference internal" href="#directors-shard-param">directors.shard_param()</a> parameter set</li> <li>
<p>for <code>resolve=LAZY</code> associate the <a class="reference internal" href="#directors-shard-param">directors.shard_param()</a> parameter set for this backend request</p> <p>Implementation notes for use of parameter sets with <code>resolve=LAZY</code>:</p> <ul class="simple"> <li>A <em>param</em> argument remains associated and any changes to the associated parameter set affect the sharding decision once the director resolves to an actual backend.</li> <li>If other parameter arguments are also given, they have preference and are kept even if the parameter set given by the <em>param</em> argument is subsequently changed within the same backend request.</li> <li>Each call to <a class="reference internal" href="#xshard-backend">xshard.backend()</a> overrides any previous call.</li> </ul> </li> </ul> </li> </ul> </section> <section id="void-xshard-debug-int"> <h3 id="xshard-debug">VOID xshard.debug(INT)</h3> <p><em>intentionally undocumented</em></p> </section> <section id="new-xshard-param-directors-shard-param"> <h3 id="directors-shard-param">new xshard_param = directors.shard_param()</h3> <p>Create a shard parameter set.</p> <p>A parameter set allows for re-use of <a class="reference internal" href="#xshard-backend">xshard.backend()</a> arguments across many shard director instances and simplifies advanced use cases (e.g. shard director with custom parameters layered below other directors).</p> <p>Parameter sets have two scopes:</p> <ul class="simple"> <li>per-VCL scope defined in <code>vcl_init{}</code>
</li> <li>per backend request scope</li> </ul> <p>The per-VCL scope defines defaults for the per backend scope. Any changes to a parameter set in backend context and in <code>vcl_pipe {}</code> only affect the respective backend request.</p> <p>Parameter sets can not be used in client context except for <code>vcl_pipe {}</code>.</p> <p>The following example is a typical use case: A parameter set is associated with several directors. Director choice happens on the client side and parameters are changed on the backend side to implement retries on alternative backends:</p> <pre data-language="python">sub vcl_init {
  new shard_param = directors.shard_param();

  new dir_A = directors.shard();
  dir_A.add_backend(...);
  dir_A.reconfigure();
  dir_A.associate(shard_param.use()); # &lt;-- !

  new dir_B = directors.shard();
  dir_B.add_backend(...);
  dir_B.reconfigure();
  dir_B.associate(shard_param.use()); # &lt;-- !
}

sub vcl_recv {
  if (...) {
    set req.backend_hint = dir_A.backend(resolve=LAZY);
  } else {
    set req.backend_hint = dir_B.backend(resolve=LAZY);
  }
}

sub vcl_backend_fetch {
  # changes dir_A and dir_B behaviour
  shard_param.set(alt=bereq.retries, by=URL);
}
</pre> </section> <section id="void-xshard-param-clear"> <h3 id="xshard-param-clear">VOID xshard_param.clear()</h3> <p>Reset the parameter set to default values as documented for <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> <ul class="simple"> <li>in <code>vcl_init{}</code>, resets the parameter set default for this VCL in</li> <li>backend context and in <code>vcl_pipe {}</code>, resets the parameter set for this backend request to the VCL defaults</li> </ul> <p>Restricted to: <code>vcl_pipe</code>, <code>backend</code>, <code>housekeeping</code>.</p> </section> <section id="void-xshard-param-set-enum-by-int-key-blob-key-blob-int-alt-real-warmup-bool-rampup-enum-healthy"> <h3 id="xshard-param-set">VOID xshard_param.set([ENUM by], [INT key], [BLOB key_blob], [INT alt], [REAL warmup], [BOOL rampup], [ENUM healthy])</h3> <pre data-language="python">VOID xshard_param.set(
      [ENUM {HASH, URL, KEY, BLOB} by],
      [INT key],
      [BLOB key_blob],
      [INT alt],
      [REAL warmup],
      [BOOL rampup],
      [ENUM {CHOSEN, IGNORE, ALL} healthy]
)
</pre> <p>Change the given parameters of a parameter set as documented for <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> <ul class="simple"> <li>in <code>vcl_init{}</code>, changes the parameter set default for this VCL</li> <li>in backend context and in <code>vcl_pipe {}</code>, changes the parameter set for this backend request, keeping the defaults set for this VCL for unspecified arguments.</li> </ul> <p>Restricted to: <code>vcl_pipe</code>, <code>backend</code>, <code>housekeeping</code>.</p> </section> <section id="string-xshard-param-get-by"> <h3 id="xshard-param-get-by">STRING xshard_param.get_by()</h3> <p>Get a string representation of the <em>by</em> enum argument which denotes how a shard director using this parameter object would derive the shard key. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="int-xshard-param-get-key"> <h3 id="xshard-param-get-key">INT xshard_param.get_key()</h3> <p>Get the key which a shard director using this parameter object would use. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="int-xshard-param-get-alt"> <h3 id="xshard-param-get-alt">INT xshard_param.get_alt()</h3> <p>Get the <em>alt</em> parameter which a shard director using this parameter object would use. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="real-xshard-param-get-warmup"> <h3 id="xshard-param-get-warmup">REAL xshard_param.get_warmup()</h3> <p>Get the <em>warmup</em> parameter which a shard director using this parameter object would use. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="bool-xshard-param-get-rampup"> <h3 id="xshard-param-get-rampup">BOOL xshard_param.get_rampup()</h3> <p>Get the <em>rampup</em> parameter which a shard director using this parameter object would use. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="string-xshard-param-get-healthy"> <h3 id="xshard-param-get-healthy">STRING xshard_param.get_healthy()</h3> <p>Get a string representation of the <em>healthy</em> enum argument which a shard director using this parameter object would use. See <a class="reference internal" href="#xshard-backend">xshard.backend()</a>.</p> </section> <section id="blob-xshard-param-use"> <h3 id="xshard-param-use">BLOB xshard_param.use()</h3> <p>For use with the <em>param</em> argument of <a class="reference internal" href="#xshard-backend">xshard.backend()</a> to associate this shard parameter set with a shard director.</p> <p>Restricted to: <code>vcl_pipe</code>, <code>backend</code>, <code>housekeeping</code>.</p> </section> <section id="backend-lookup-string"> <h3 id="directors-lookup">BACKEND lookup(STRING)</h3> <p>Lookup a backend by its name.</p> <p>Restricted to: <code>housekeeping</code>.</p> </section> </section> <section id="acknowledgements"> <h2>ACKNOWLEDGEMENTS</h2> <p>Development of a previous version of the shard director was partly sponsored by Deutsche Telekom AG - Products &amp; Innovation.</p> <p>Development of a previous version of the shard director was partly sponsored by BILD GmbH &amp; Co KG.</p> </section> <section id="copyright"> <h2>COPYRIGHT</h2> <pre data-language="python">This document is licensed under the same licence as Varnish
itself. See LICENCE for details.

SPDX-License-Identifier: BSD-2-Clause

Copyright (c) 2013-2015 Varnish Software AS
Copyright 2009-2020 UPLEX - Nils Goroll Systemoptimierung
All rights reserved.

Authors: Poul-Henning Kamp &lt;phk@FreeBSD.org&gt;
         Julian Wiesener &lt;jw@uplex.de&gt;
         Nils Goroll &lt;slink@uplex.de&gt;
         Geoffrey Simmons &lt;geoff@uplex.de&gt;

SPDX-License-Identifier: BSD-2-Clause

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE
FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
SUCH DAMAGE.
</pre> </section><div class="_attribution">
  <p class="_attribution-p">
    Copyright &copy; 2006 Verdens Gang AS<br>Copyright &copy; 2006&ndash;2020 Varnish Software AS<br>Licensed under the BSD-2-Clause License.<br>
    <a href="https://varnish-cache.org/docs/7.4/reference/vmod_directors.html" class="_attribution-link">https://varnish-cache.org/docs/7.4/reference/vmod_directors.html</a>
  </p>
</div>
