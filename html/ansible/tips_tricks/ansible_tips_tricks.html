<section id="general-tips"> <h1 id="tips-and-tricks">General tips</h1> <p>These concepts apply to all Ansible activities and artifacts.</p> <section id="keep-it-simple"> <h2>Keep it simple</h2> <p>Whenever you can, do things simply.</p> <p>Use advanced features only when necessary, and select the feature that best matches your use case. For example, you will probably not need <code>vars</code>, <code>vars_files</code>, <code>vars_prompt</code> and <code>--extra-vars</code> all at once, while also using an external inventory file.</p> <p>If something feels complicated, it probably is. Take the time to look for a simpler solution.</p> </section> <section id="use-version-control"> <h2>Use version control</h2> <p>Keep your playbooks, roles, inventory, and variables files in <code>git</code> or another version control system and make commits with meaningful comments to the repository when you make changes. Version control gives you an audit trail describing when and why you changed the rules that automate your infrastructure.</p> </section> <section id="customize-the-cli-output"> <h2>Customize the CLI output</h2> <p>You can change the output from Ansible CLI commands using <a class="reference internal" href="../plugins/callback.html#callback-plugins"><span class="std std-ref">Callback plugins</span></a>.</p> </section> <section id="avoid-configuration-dependent-content"> <h2>Avoid configuration-dependent content</h2> <p>To ensure that your automation project is easy to understand, modify, and share with others, you should avoid configuration-dependent content. For example, rather than referencing an <code>ansible.cfg</code> as the root of a project, you can use magic variables such as <code>playbook_dir</code> or <code>role_name</code> to determine paths relative to known locations within your project directory. This can help to keep automation content flexible, reusable, and easy to maintain. For more information, see <a class="reference internal" href="../reference_appendices/special_variables.html#special-variables"><span class="std std-ref">special variables</span></a>.</p> </section> </section> <section id="playbook-tips"> <h1 id="id1">Playbook tips</h1> <p>These tips help make playbooks and roles easier to read, maintain, and debug.</p> <section id="use-whitespace"> <h2>Use whitespace</h2> <p>Generous use of whitespace, for example, a blank line before each block or task, makes a playbook easy to scan.</p> </section> <section id="always-name-plays-tasks-and-blocks"> <h2>Always name plays, tasks, and blocks</h2> <p>Play, task, and block <code>- name:</code>’s are optional, but extremely useful. In its output, Ansible shows you the name of each named entity it runs. Choose names that describe what each play, task, and block does and why.</p> </section> <section id="always-mention-the-state"> <h2>Always mention the state</h2> <p>For many modules, the <code>state</code> parameter is optional.</p> <p>Different modules have different default settings for <code>state</code>, and some modules support several <code>state</code> settings. Explicitly setting <code>state: present</code> or <code>state: absent</code> makes playbooks and roles clearer.</p> </section> <section id="use-comments"> <h2>Use comments</h2> <p>Even with task names and explicit states, sometimes a part of a playbook or role (or inventory/variable file) needs more explanation. Adding a comment (any line starting with <code>#</code>) helps others (and possibly yourself in the future) understand what a play or task (or variable setting) does, how it does it, and why.</p> </section> <section id="use-fully-qualified-collection-names"> <h2>Use fully qualified collection names</h2> <p>Use <a class="reference external" href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html#term-Fully-Qualified-Collection-Name-FQCN">fully qualified collection names (FQCN)</a> to avoid ambiguity in which collection to search for the correct module or plugin for each task.</p> <p>For <a class="reference external" href="../collections/ansible/builtin/index.html#plugin-index">builtin modules and plugins</a>, use the <code>ansible.builtin</code> collection name as a prefix, for example, <code>ansible.builtin.copy</code>.</p> </section> </section> <section id="inventory-tips"> <h1 id="id2">Inventory tips</h1> <p>These tips help keep your inventory well organized.</p> <section id="use-dynamic-inventory-with-clouds"> <h2>Use dynamic inventory with clouds</h2> <p>With cloud providers and other systems that maintain canonical lists of your infrastructure, use <a class="reference internal" href="../inventory_guide/intro_dynamic_inventory.html#intro-dynamic-inventory"><span class="std std-ref">dynamic inventory</span></a> to retrieve those lists instead of manually updating static inventory files. With cloud resources, you can use tags to differentiate production and staging environments.</p> </section> <section id="group-inventory-by-function"> <h2>Group inventory by function</h2> <p>A system can be in multiple groups. See <a class="reference internal" href="../inventory_guide/intro_inventory.html#intro-inventory"><span class="std std-ref">How to build your inventory</span></a> and <a class="reference internal" href="../inventory_guide/intro_patterns.html#intro-patterns"><span class="std std-ref">Patterns: targeting hosts and groups</span></a>. If you create groups named for the function of the nodes in the group, for example, <code>webservers</code> or <code>dbservers</code>, your playbooks can target machines based on function. You can assign function-specific variables using the group variable system, and design Ansible roles to handle function-specific use cases. See <a class="reference internal" href="../playbook_guide/playbooks_reuse_roles.html#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a>.</p> </section> <section id="separate-production-and-staging-inventory"> <h2>Separate production and staging inventory</h2> <p>You can keep your production environment separate from development, test, and staging environments by using separate inventory files or directories for each environment. This way you pick with -i what you are targeting. Keeping all your environments in one file can lead to surprises! For example, all vault passwords used in an inventory need to be available when using that inventory. If an inventory contains both production and development environments, developers using that inventory would be able to access production secrets.</p> </section> <section id="keep-vaulted-variables-safely-visible"> <h2 id="tip-for-variables-and-vaults">Keep vaulted variables safely visible</h2> <p>You should encrypt sensitive or secret variables with Ansible Vault. However, encrypting the variable names as well as the variable values makes it hard to find the source of the values. To circumvent this, you can encrypt the variables individually using <code>ansible-vault encrypt_string</code>, or add the following layer of indirection to keep the names of your variables accessible (by <code>grep</code>, for example) without exposing any secrets:</p> <ol class="arabic simple"> <li>Create a <code>group_vars/</code> subdirectory named after the group.</li> <li>Inside this subdirectory, create two files named <code>vars</code> and <code>vault</code>.</li> <li>In the <code>vars</code> file, define all of the variables needed, including any sensitive ones.</li> <li>Copy all of the sensitive variables over to the <code>vault</code> file and prefix these variables with <code>vault_</code>.</li> <li>Adjust the variables in the <code>vars</code> file to point to the matching <code>vault_</code> variables using jinja2 syntax: <code>db_password: "{{ vault_db_password }}"</code>.</li> <li>Encrypt the <code>vault</code> file to protect its contents.</li> <li>Use the variable name from the <code>vars</code> file in your playbooks.</li> </ol> <p>When running a playbook, Ansible finds the variables in the unencrypted file, which pulls the sensitive variable values from the encrypted file. There is no limit to the number of variable and vault files or their names.</p> <p>Note that using this strategy in your inventory still requires <em>all vault passwords to be available</em> (for example for <code>ansible-playbook</code> or <a class="reference external" href="https://github.com/ansible/awx/issues/223#issuecomment-768386089">AWX/Ansible Tower</a>) when run with that inventory.</p> </section> </section> <section id="execution-tricks"> <h1 id="execution-tips">Execution tricks</h1> <p>These tips apply to using Ansible, rather than to Ansible artifacts.</p> <section id="use-execution-environments"> <h2>Use Execution Environments</h2> <p>Reduce complexity with portable container images known as <a class="reference internal" href="../getting_started_ee/index.html#getting-started-ee-index"><span class="std std-ref">Execution Environments</span></a>.</p> </section> <section id="try-it-in-staging-first"> <h2>Try it in staging first</h2> <p>Testing changes in a staging environment before rolling them out in production is always a great idea. Your environments need not be the same size, and you can use group variables to control the differences between environments. You can also check for any syntax errors in the staging environment using the flag <code>--syntax-check</code> such as in the following example:</p> <pre data-language="yaml">ansible-playbook --syntax-check
</pre> </section> <section id="update-in-batches"> <h2>Update in batches</h2> <p>Use the <code>serial</code> keyword to control how many machines you update at once in the batch. See <a class="reference internal" href="../playbook_guide/playbooks_delegation.html#playbooks-delegation"><span class="std std-ref">Controlling where tasks run: delegation and local actions</span></a>.</p> </section> <section id="handling-os-and-distro-differences"> <h2 id="os-variance">Handling OS and distro differences</h2> <p>Group variables files and the <code>group_by</code> module work together to help Ansible execute across a range of operating systems and distributions that require different settings, packages, and tools. The <code>group_by</code> module creates a dynamic group of hosts that match certain criteria. This group does not need to be defined in the inventory file. This approach lets you execute different tasks on different operating systems or distributions.</p> <p>For example, the following play categorizes all systems into dynamic groups based on the operating system name:</p> <pre data-language="yaml">- name: Talk to all hosts just so we can learn about them
  hosts: all
  tasks:

    - name: Classify hosts depending on their OS distribution
      ansible.builtin.group_by:
        key: os_{{ ansible_facts['distribution'] }}
</pre> <p>Subsequent plays can use these groups as patterns on the <code>hosts</code> line as follows:</p> <pre data-language="yaml">- hosts: os_CentOS
  gather_facts: False
  tasks:

    # Tasks for CentOS hosts only go in this play.
    - name: Ping my CentOS hosts
      ansible.builtin.ping:
</pre> <p>You can also add group-specific settings in group vars files. In the following example, CentOS machines get the value of ‘42’ for <code>asdf</code> but other machines get ‘10’. You can also use group vars files to apply roles to systems as well as set variables.</p> <pre data-language="yaml">---
# file: group_vars/all
asdf: 10

---
# file: group_vars/os_CentOS.yml
asdf: 42
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>All three names must match: the name created by the <code>group_by</code> task, the name of the pattern in subsequent plays, and the name of the group vars file.</p> </div> <p>You can use the same setup with <code>include_vars</code> when you only need OS-specific variables, not tasks:</p> <pre data-language="yaml">- name: Use include_vars to include OS-specific variables and print them
  hosts: all
  tasks:

    - name: Set OS distribution dependent variables
      ansible.builtin.include_vars: "os_{{ ansible_facts['distribution'] }}.yml"

    - name: Print the variable
      ansible.builtin.debug:
        var: asdf
</pre> <p>This pulls in variables from the <code>group_vars/os_CentOS.yml</code> file.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="../reference_appendices/yamlsyntax.html#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a></dt>
<dd>
<p>Learn about YAML syntax</p> </dd> <dt><a class="reference internal" href="../playbook_guide/playbooks.html#working-with-playbooks"><span class="std std-ref">Working with playbooks</span></a></dt>
<dd>
<p>Review the basic playbook features</p> </dd> <dt><a class="reference internal" href="../collections/index.html#list-of-collections"><span class="std std-ref">Collection Index</span></a></dt>
<dd>
<p>Browse existing collections, modules, and plugins</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html#developing-modules"><span class="std std-ref">Should you develop a module?</span></a></dt>
<dd>
<p>Learn how to extend Ansible by writing your own modules</p> </dd> <dt><a class="reference internal" href="../inventory_guide/intro_patterns.html#intro-patterns"><span class="std std-ref">Patterns: targeting hosts and groups</span></a></dt>
<dd>
<p>Learn about how to select hosts</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Communication</span></a></dt>
<dd>
<p>Got questions? Need help? Want to share your ideas? Visit the Ansible communication guide</p> </dd> </dl> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/tips_tricks/ansible_tips_tricks.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/tips_tricks/ansible_tips_tricks.html</a>
  </p>
</div>
