<h1 id="community-general-deploy-helper-manages-some-of-the-steps-common-in-deploying-projects">community.general.deploy_helper – Manages some of the steps common in deploying projects.</h1> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This plugin is part of the <a class="reference external" href="https://galaxy.ansible.com/community/general">community.general collection</a> (version 3.8.1).</p> <p>You might already have this collection installed if you are using the <code>ansible</code> package. It is not included in <code>ansible-core</code>. To check whether it is installed, run <code>ansible-galaxy collection list</code>.</p> <p>To install it, use: <code>ansible-galaxy collection install community.general</code>.</p> <p>To use it in a playbook, specify: <code>community.general.deploy_helper</code>.</p> </div>  <ul class="simple"> <li><a class="reference internal" href="#synopsis" id="id1">Synopsis</a></li> <li><a class="reference internal" href="#parameters" id="id2">Parameters</a></li> <li><a class="reference internal" href="#notes" id="id3">Notes</a></li> <li><a class="reference internal" href="#examples" id="id4">Examples</a></li> </ul>   <h2 id="synopsis">Synopsis</h2> <ul class="simple"> <li>The Deploy Helper manages some of the steps common in deploying software. It creates a folder structure, manages a symlink for the current release and cleans up old releases.</li> <li>Running it with the <code>state=query</code> or <code>state=present</code> will return the <code>deploy_helper</code> fact. <code>project_path</code>, whatever you set in the path parameter, <code>current_path</code>, the path to the symlink that points to the active release, <code>releases_path</code>, the path to the folder to keep releases in, <code>shared_path</code>, the path to the folder to keep shared resources in, <code>unfinished_filename</code>, the file to check for to recognize unfinished builds, <code>previous_release</code>, the release the ‘current’ symlink is pointing to, <code>previous_release_path</code>, the full path to the ‘current’ symlink target, <code>new_release</code>, either the ‘release’ parameter or a generated timestamp, <code>new_release_path</code>, the path to the new release folder (not created by the module).</li> </ul>   <h2 id="parameters">Parameters</h2> <table class="documentation-table"> <tr> <th colspan="1">Parameter</th> <th>Choices/Defaults</th> <th width="100%">Comments</th> </tr> <tr> <td colspan="1">  <b>attributes</b>  <div> <span>string</span> </div> <div> added in 2.3 of ansible.builtin </div> </td> <td> </td> <td> <div>The attributes the resulting file or directory should have.</div> <div>To get supported flags look at the man page for <em>chattr</em> on the target system.</div> <div>This string should contain the attributes in the same order as the one displayed by <em>lsattr</em>.</div> <div>The <code>=</code> operator is assumed as default, otherwise <code>+</code> or <code>-</code> operators need to be included in the string.</div> <div>
<br>aliases: attr</div> </td> </tr> <tr> <td colspan="1">  <b>clean</b>  <div> <span>boolean</span> </div> </td> <td> <ul>
<b>Choices:</b> <li>no</li> <li><div>
<b>yes</b> ←</div></li> </ul> </td> <td> <div>Whether to run the clean procedure in case of <code>state=finalize</code>.</div> </td> </tr> <tr> <td colspan="1">  <b>current_path</b>  <div> <span>path</span> </div> </td> <td> <b>Default:</b><br><div>"current"</div> </td> <td> <div>the name of the symlink that is created when the deploy is finalized. Used in <code>finalize</code> and <code>clean</code>. Returned in the <code>deploy_helper.current_path</code> fact.</div> </td> </tr> <tr> <td colspan="1">  <b>group</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>Name of the group that should own the file/directory, as would be fed to <em>chown</em>.</div> </td> </tr> <tr> <td colspan="1">  <b>keep_releases</b>  <div> <span>integer</span> </div> </td> <td> <b>Default:</b><br><div>5</div> </td> <td> <div>the number of old releases to keep when cleaning. Used in <code>finalize</code> and <code>clean</code>. Any unfinished builds will be deleted first, so only correct releases will count. The current version will not count.</div> </td> </tr> <tr> <td colspan="1">  <b>mode</b>  <div> <span>raw</span> </div> </td> <td> </td> <td> <div>The permissions the resulting file or directory should have.</div> <div>For those used to <em>/usr/bin/chmod</em> remember that modes are actually octal numbers. You must either add a leading zero so that Ansible's YAML parser knows it is an octal number (like <code>0644</code> or <code>01777</code>) or quote it (like <code>'644'</code> or <code>'1777'</code>) so Ansible receives a string and can do its own conversion from string into number.</div> <div>Giving Ansible a number without following one of these rules will end up with a decimal number which will have unexpected results.</div> <div>As of Ansible 1.8, the mode may be specified as a symbolic mode (for example, <code>u+rwx</code> or <code>u=rw,g=r,o=r</code>).</div> <div>If <code>mode</code> is not specified and the destination file <b>does not</b> exist, the default <code>umask</code> on the system will be used when setting the mode for the newly created file.</div> <div>If <code>mode</code> is not specified and the destination file <b>does</b> exist, the mode of the existing file will be used.</div> <div>Specifying <code>mode</code> is the best way to ensure files are created with the correct permissions. See CVE-2020-1736 for further details.</div> </td> </tr> <tr> <td colspan="1">  <b>owner</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>Name of the user that should own the file/directory, as would be fed to <em>chown</em>.</div> </td> </tr> <tr> <td colspan="1">  <b>path</b>  <div> <span>path</span> / <span>required</span> </div> </td> <td> </td> <td> <div>the root path of the project. Alias <em>dest</em>. Returned in the <code>deploy_helper.project_path</code> fact.</div> <div>
<br>aliases: dest</div> </td> </tr> <tr> <td colspan="1">  <b>release</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>the release version that is being deployed. Defaults to a timestamp format %Y%m%d%H%M%S (i.e. '20141119223359'). This parameter is optional during <code>state=present</code>, but needs to be set explicitly for <code>state=finalize</code>. You can use the generated fact <code>release={{ deploy_helper.new_release }}</code>.</div> </td> </tr> <tr> <td colspan="1">  <b>releases_path</b>  <div> <span>string</span> </div> </td> <td> <b>Default:</b><br><div>"releases"</div> </td> <td> <div>the name of the folder that will hold the releases. This can be relative to <code>path</code> or absolute. Returned in the <code>deploy_helper.releases_path</code> fact.</div> </td> </tr> <tr> <td colspan="1">  <b>selevel</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>The level part of the SELinux file context.</div> <div>This is the MLS/MCS attribute, sometimes known as the <code>range</code>.</div> <div>When set to <code>_default</code>, it will use the <code>level</code> portion of the policy if available.</div> </td> </tr> <tr> <td colspan="1">  <b>serole</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>The role part of the SELinux file context.</div> <div>When set to <code>_default</code>, it will use the <code>role</code> portion of the policy if available.</div> </td> </tr> <tr> <td colspan="1">  <b>setype</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>The type part of the SELinux file context.</div> <div>When set to <code>_default</code>, it will use the <code>type</code> portion of the policy if available.</div> </td> </tr> <tr> <td colspan="1">  <b>seuser</b>  <div> <span>string</span> </div> </td> <td> </td> <td> <div>The user part of the SELinux file context.</div> <div>By default it uses the <code>system</code> policy, where applicable.</div> <div>When set to <code>_default</code>, it will use the <code>user</code> portion of the policy if available.</div> </td> </tr> <tr> <td colspan="1">  <b>shared_path</b>  <div> <span>path</span> </div> </td> <td> <b>Default:</b><br><div>"shared"</div> </td> <td> <div>the name of the folder that will hold the shared resources. This can be relative to <code>path</code> or absolute. If this is set to an empty string, no shared folder will be created. Returned in the <code>deploy_helper.shared_path</code> fact.</div> </td> </tr> <tr> <td colspan="1">  <b>state</b>  <div> <span>string</span> </div> </td> <td> <ul>
<b>Choices:</b> <li><div>
<b>present</b> ←</div></li> <li>finalize</li> <li>absent</li> <li>clean</li> <li>query</li> </ul> </td> <td> <div>the state of the project. <code>query</code> will only gather facts, <code>present</code> will create the project <em>root</em> folder, and in it the <em>releases</em> and <em>shared</em> folders, <code>finalize</code> will remove the unfinished_filename file, create a symlink to the newly deployed release and optionally clean old releases, <code>clean</code> will remove failed &amp; old releases, <code>absent</code> will remove the project folder (synonymous to the <a href="../../ansible/builtin/file_module.html" class="module">ansible.builtin.file</a> module with <code>state=absent</code>)</div> </td> </tr> <tr> <td colspan="1">  <b>unfinished_filename</b>  <div> <span>string</span> </div> </td> <td> <b>Default:</b><br><div>"DEPLOY_UNFINISHED"</div> </td> <td> <div>the name of the file that indicates a deploy has not finished. All folders in the releases_path that contain this file will be deleted on <code>state=finalize</code> with clean=True, or <code>state=clean</code>. This file is automatically deleted from the <em>new_release_path</em> during <code>state=finalize</code>.</div> </td> </tr> <tr> <td colspan="1">  <b>unsafe_writes</b>  <div> <span>boolean</span> </div> <div> added in 2.2 of ansible.builtin </div> </td> <td> <ul>
<b>Choices:</b> <li><div>
<b>no</b> ←</div></li> <li>yes</li> </ul> </td> <td> <div>Influence when to use atomic operation to prevent data corruption or inconsistent reads from the target file.</div> <div>By default this module uses atomic operations to prevent data corruption or inconsistent reads from the target files, but sometimes systems are configured or just broken in ways that prevent this. One example is docker mounted files, which cannot be updated atomically from inside the container and can only be written in an unsafe manner.</div> <div>This option allows Ansible to fall back to unsafe methods of updating files when atomic operations fail (however, it doesn't force Ansible to perform unsafe writes).</div> <div>IMPORTANT! Unsafe writes are subject to race conditions and can lead to data corruption.</div> </td> </tr> </table> <br>  <h2 id="notes">Notes</h2> <div class="admonition note"> <p class="admonition-title">Note</p> <ul class="simple"> <li>Facts are only returned for <code>state=query</code> and <code>state=present</code>. If you use both, you should pass any overridden parameters to both calls, otherwise the second call will overwrite the facts of the first one.</li> <li>When using <code>state=clean</code>, the releases are ordered by <em>creation date</em>. You should be able to switch to a new naming strategy without problems.</li> <li>Because of the default behaviour of generating the <em>new_release</em> fact, this module will not be idempotent unless you pass your own release name with <code>release</code>. Due to the nature of deploying software, this should not be much of a problem.</li> </ul> </div>   <h2 id="examples">Examples</h2> <pre data-language="yaml+jinja"># General explanation, starting with an example folder structure for a project:

# root:
#     releases:
#         - 20140415234508
#         - 20140415235146
#         - 20140416082818
#
#     shared:
#         - sessions
#         - uploads
#
#     current: releases/20140416082818


# The 'releases' folder holds all the available releases. A release is a complete build of the application being
# deployed. This can be a clone of a repository for example, or a sync of a local folder on your filesystem.
# Having timestamped folders is one way of having distinct releases, but you could choose your own strategy like
# git tags or commit hashes.
#
# During a deploy, a new folder should be created in the releases folder and any build steps required should be
# performed. Once the new build is ready, the deploy procedure is 'finalized' by replacing the 'current' symlink
# with a link to this build.
#
# The 'shared' folder holds any resource that is shared between releases. Examples of this are web-server
# session files, or files uploaded by users of your application. It's quite common to have symlinks from a release
# folder pointing to a shared/subfolder, and creating these links would be automated as part of the build steps.
#
# The 'current' symlink points to one of the releases. Probably the latest one, unless a deploy is in progress.
# The web-server's root for the project will go through this symlink, so the 'downtime' when switching to a new
# release is reduced to the time it takes to switch the link.
#
# To distinguish between successful builds and unfinished ones, a file can be placed in the folder of the release
# that is currently in progress. The existence of this file will mark it as unfinished, and allow an automated
# procedure to remove it during cleanup.


# Typical usage
- name: Initialize the deploy root and gather facts
  community.general.deploy_helper:
    path: /path/to/root
- name: Clone the project to the new release folder
  ansible.builtin.git:
    repo: ansible.builtin.git://foosball.example.org/path/to/repo.git
    dest: '{{ deploy_helper.new_release_path }}'
    version: v1.1.1
- name: Add an unfinished file, to allow cleanup on successful finalize
  ansible.builtin.file:
    path: '{{ deploy_helper.new_release_path }}/{{ deploy_helper.unfinished_filename }}'
    state: touch
- name: Perform some build steps, like running your dependency manager for example
  composer:
    command: install
    working_dir: '{{ deploy_helper.new_release_path }}'
- name: Create some folders in the shared folder
  ansible.builtin.file:
    path: '{{ deploy_helper.shared_path }}/{{ item }}'
    state: directory
  with_items:
    - sessions
    - uploads
- name: Add symlinks from the new release to the shared folder
  ansible.builtin.file:
    path: '{{ deploy_helper.new_release_path }}/{{ item.path }}'
    src: '{{ deploy_helper.shared_path }}/{{ item.src }}'
    state: link
  with_items:
      - path: app/sessions
        src: sessions
      - path: web/uploads
        src: uploads
- name: Finalize the deploy, removing the unfinished file and switching the symlink
  community.general.deploy_helper:
    path: /path/to/root
    release: '{{ deploy_helper.new_release }}'
    state: finalize

# Retrieving facts before running a deploy
- name: Run 'state=query' to gather facts without changing anything
  community.general.deploy_helper:
    path: /path/to/root
    state: query
# Remember to set the 'release' parameter when you actually call 'state=present' later
- name: Initialize the deploy root
  community.general.deploy_helper:
    path: /path/to/root
    release: '{{ deploy_helper.new_release }}'
    state: present

# all paths can be absolute or relative (to the 'path' parameter)
- community.general.deploy_helper:
    path: /path/to/root
    releases_path: /var/www/project/releases
    shared_path: /var/www/shared
    current_path: /var/www/active

# Using your own naming strategy for releases (a version tag in this case):
- community.general.deploy_helper:
    path: /path/to/root
    release: v1.1.1
    state: present
- community.general.deploy_helper:
    path: /path/to/root
    release: '{{ deploy_helper.new_release }}'
    state: finalize

# Using a different unfinished_filename:
- community.general.deploy_helper:
    path: /path/to/root
    unfinished_filename: README.md
    release: '{{ deploy_helper.new_release }}'
    state: finalize

# Postponing the cleanup of older builds:
- community.general.deploy_helper:
    path: /path/to/root
    release: '{{ deploy_helper.new_release }}'
    state: finalize
    clean: False
- community.general.deploy_helper:
    path: /path/to/root
    state: clean
# Or running the cleanup ahead of the new deploy
- community.general.deploy_helper:
    path: /path/to/root
    state: clean
- community.general.deploy_helper:
    path: /path/to/root
    state: present

# Keeping more old releases:
- community.general.deploy_helper:
    path: /path/to/root
    release: '{{ deploy_helper.new_release }}'
    state: finalize
    keep_releases: 10
# Or, if you use 'clean=false' on finalize:
- community.general.deploy_helper:
    path: /path/to/root
    state: clean
    keep_releases: 10

# Removing the entire project root folder
- community.general.deploy_helper:
    path: /path/to/root
    state: absent

# Debugging the facts returned by the module
- community.general.deploy_helper:
    path: /path/to/root
- ansible.builtin.debug:
    var: deploy_helper
</pre>  <h3 id="authors">Authors</h3> <ul class="simple"> <li>Ramon de la Fuente (@ramondelafuente)</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2021 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/collections/community/general/deploy_helper_module.html</a>
  </p>
</div>
