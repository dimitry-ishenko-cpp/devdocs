<section id="controlling-how-ansible-behaves-precedence-rules"> <h1 id="general-precedence-rules">Controlling how Ansible behaves: precedence rules</h1> <p>To give you maximum flexibility in managing your environments, Ansible offers many ways to control how Ansible behaves: how it connects to managed nodes, how it works once it has connected. If you use Ansible to manage a large number of servers, network devices, and cloud resources, you may define Ansible behavior in several different places and pass that information to Ansible in several different ways. This flexibility is convenient, but it can backfire if you do not understand the precedence rules.</p> <p>These precedence rules apply to any setting that can be defined in multiple ways (by configuration settings, command-line options, playbook keywords, variables).</p>  <ul> <li><a class="reference internal" href="#configuration-settings" id="id2">Configuration settings</a></li> <li><a class="reference internal" href="#command-line-options" id="id3">Command-line options</a></li> <li><a class="reference internal" href="#playbook-keywords" id="id4">Playbook keywords</a></li> <li>
<p><a class="reference internal" href="#variables" id="id5">Variables</a></p> <ul> <li><a class="reference internal" href="#variable-scope-how-long-is-a-value-available" id="id6">Variable scope: how long is a value available?</a></li> <li><a class="reference internal" href="#using-e-extra-variables-at-the-command-line" id="id7">Using <code>-e</code> extra variables at the command line</a></li> </ul> </li> <li><a class="reference internal" href="#direct-assignment" id="id8">Direct Assignment</a></li> </ul>
  <section id="precedence-categories"> <h2>Precedence categories</h2> <p>Ansible offers four sources for controlling its behavior. In order of precedence from lowest (most easily overridden) to highest (overrides all others), the categories are:</p>  <ul class="simple"> <li>Configuration settings</li> <li>Command-line options</li> <li>Playbook keywords</li> <li>Variables</li> <li>Direct Assignment</li> </ul>  <p>Each category overrides any information from all lower-precedence categories. For example, a playbook keyword will override any configuration setting.</p> <p>Within each precedence category, specific rules apply. However, generally speaking, ‘last defined’ wins and overrides any previous definitions.</p> <section id="configuration-settings"> <h3>Configuration settings</h3> <p><a class="reference internal" href="config.html#ansible-configuration-settings"><span class="std std-ref">Configuration settings</span></a> include both values from the <code>ansible.cfg</code> file and environment variables. Within this category, values set in configuration files have lower precedence. Ansible uses the first <code>ansible.cfg</code> file it finds, ignoring all others. Ansible searches for <code>ansible.cfg</code> in these locations in order:</p>  <ul class="simple"> <li>
<code>ANSIBLE_CONFIG</code> (environment variable if set)</li> <li>
<code>ansible.cfg</code> (in the current directory)</li> <li>
<code>~/.ansible.cfg</code> (in the home directory)</li> <li><code>/etc/ansible/ansible.cfg</code></li> </ul>  <p>Environment variables have a higher precedence than entries in <code>ansible.cfg</code>. If you have environment variables set on your control node, they override the settings in whichever <code>ansible.cfg</code> file Ansible loads. The value of any given environment variable follows normal shell precedence: the last value defined overwrites previous values.</p> </section> <section id="command-line-options"> <h3>Command-line options</h3> <p>Any command-line option will override any configuration setting.</p> <p>When you type something directly at the command line, you may feel that your hand-crafted values should override all others, but Ansible does not work that way. Command-line options have low precedence - they override configuration only. They do not override playbook keywords, variables from inventory or variables from playbooks.</p> <p>You can override all other settings from all other sources in all other precedence categories at the command line by <a class="reference internal" href="#general-precedence-extra-vars"><span class="std std-ref">Using -e extra variables at the command line</span></a>, but that is not a command-line option, it is a way of passing a <a class="reference internal" href="#general-precedence-variables"><span class="std std-ref">variable</span></a>.</p> <p>At the command line, if you pass multiple values for a parameter that accepts only a single value, the last defined value wins. For example, this <a class="reference internal" href="../command_guide/intro_adhoc.html#intro-adhoc"><span class="std std-ref">ad hoc task</span></a> will connect as <code>carol</code>, not as <code>mike</code>:</p> <pre data-language="shell">ansible -u mike -m ping myhost -u carol
</pre> <p>Some parameters allow multiple values. In this case, Ansible will append all values from the hosts listed in inventory files inventory1 and inventory2:</p> <pre data-language="shell">ansible -i /path/inventory1 -i /path/inventory2 -m ping all
</pre> <p>The help for each <a class="reference internal" href="../command_guide/command_line_tools.html#command-line-tools"><span class="std std-ref">command-line tool</span></a> lists available options for that tool.</p> </section> <section id="playbook-keywords"> <h3>Playbook keywords</h3> <p>Any <a class="reference internal" href="playbooks_keywords.html#playbook-keywords"><span class="std std-ref">playbook keyword</span></a> will override any command-line option and any configuration setting.</p> <p>Within playbook keywords, precedence flows with the playbook itself; the more specific wins against the more general:</p> <ul class="simple"> <li>play (most general)</li> <li>blocks/includes/imports/roles (optional and can contain tasks and each other)</li> <li>tasks (most specific)</li> </ul> <p>A simple example:</p> <pre data-language="yaml">- hosts: all
  connection: ssh
  tasks:
    - name: This task uses ssh.
      ping:

    - name: This task uses paramiko.
      connection: paramiko
      ping:
</pre> <p>In this example, the <code>connection</code> keyword is set to <code>ssh</code> at the play level. The first task inherits that value, and connects using <code>ssh</code>. The second task inherits that value, overrides it, and connects using <code>paramiko</code>. The same logic applies to blocks and roles as well. All tasks, blocks, and roles within a play inherit play-level keywords; any task, block, or role can override any keyword by defining a different value for that keyword within the task, block, or role.</p> <p>Remember that these are KEYWORDS, not variables. Both playbooks and variable files are defined in YAML but they have different significance. Playbooks are the command or ‘state description’ structure for Ansible, variables are data we use to help make playbooks more dynamic.</p> </section> <section id="variables"> <h3 id="general-precedence-variables">Variables</h3> <p>Ansible variables are very high on the precedence stack. They will override any playbook keyword, any command-line option, environment variable and any configuration file setting.</p> <p>Variables that have equivalent playbook keywords, command-line options, and configuration settings are known as <a class="reference internal" href="special_variables.html#connection-variables"><span class="std std-ref">Connection variables</span></a>. Originally designed for connection parameters, this category has expanded to include other core variables like the temporary directory and the python interpreter.</p> <p>Connection variables, like all variables, can be set in multiple ways and places. You can define variables for hosts and groups in <a class="reference internal" href="../inventory_guide/intro_inventory.html#intro-inventory"><span class="std std-ref">inventory</span></a>. You can define variables for tasks and plays in <code>vars:</code> blocks in <a class="reference internal" href="../playbook_guide/playbooks_intro.html#about-playbooks"><span class="std std-ref">playbooks</span></a>. However, they are still variables - they are data, not keywords or configuration settings. Variables that override playbook keywords, command-line options, and configuration settings follow the same rules of <a class="reference internal" href="../playbook_guide/playbooks_variables.html#ansible-variable-precedence"><span class="std std-ref">variable precedence</span></a> as any other variables.</p> <p>When set in a playbook, variables follow the same inheritance rules as playbook keywords. You can set a value for the play, then override it in a task, block, or role:</p> <pre data-language="yaml">- hosts: cloud
  gather_facts: false
  become: true
  vars:
    ansible_become_user: admin
  tasks:
    - name: This task uses admin as the become user.
      dnf:
        name: some-service
        state: latest
    - block:
        - name: This task uses service-admin as the become user.
          # a task to configure the new service
        - name: This task also uses service-admin as the become user, defined in the block.
          # second task to configure the service
      vars:
        ansible_become_user: service-admin
    - name: This task (outside of the block) uses admin as the become user again.
      service:
        name: some-service
        state: restarted
</pre> <section id="variable-scope-how-long-is-a-value-available"> <h4>Variable scope: how long is a value available?</h4> <p>Variable values set in a playbook exist only within the playbook object that defines them. These ‘playbook object scope’ variables are not available to subsequent objects, including other plays.</p> <p>Variable values associated directly with a host or group, including variables defined in inventory, by vars plugins, or using modules like <a class="reference internal" href="../collections/ansible/builtin/set_fact_module.html#set-fact-module"><span class="std std-ref">set_fact</span></a> and <a class="reference internal" href="../collections/ansible/builtin/include_vars_module.html#include-vars-module"><span class="std std-ref">include_vars</span></a>, are available to all plays. These ‘host scope’ variables are also available through the <code>hostvars[]</code> dictionary.</p> <p>Variables set through <code>extra vars</code> have a global scope for the current run and will be present both as ‘playbook object vars’ and ‘hostvars’.</p> </section> <section id="using-e-extra-variables-at-the-command-line"> <h4 id="general-precedence-extra-vars">Using <code>-e</code> extra variables at the command line</h4> <p>To override all other variables, you can use extra variables: <code>--extra-vars</code> or <code>-e</code> at the command line. Values passed with <code>-e</code>, while still a command-line option itself, have the highest precedence among variables and will, a bit counter intuitively, be of the higher precedence among most configuration sources, since variables themselves have high precedence. For example, this task will connect as <code>brian</code> not as <code>carol</code>:</p> <pre data-language="shell">ansible -u carol -e 'ansible_user=brian' -a whoami all
</pre> <p>You must specify both the variable name and the value with <code>--extra-vars</code>.</p> </section> </section> <section id="direct-assignment"> <h3>Direct Assignment</h3> <p>This category only applies to things that take direct options, generally modules and some plugin types. Most modules and action plugins do not have any other way to assign settings so precedence rarely comes up in that context, but it still possible for some of them to do so and should be reflected in the documentation.</p> <pre data-language="yaml">- debug: msg='this is a direct assignment option to an action plugin'

- ping:
    data: also a direct assignment
</pre> <p>Outside of task actions, the most recognizable ‘direct assignments’ are with lookup, filter and test plugins:</p> <pre data-language="YAML+Jinja">lookup('plugin', direct1='value', direct2='value2')

'value_directly_assigned'|filter('another directly assigned')

'direct value' is testplugin
</pre> <p>Though most of these are not configured in other ways, specially tests, it is possible for plugins and filters to use input from other configuration sources if specified in their documentation.</p> <p>Inventory plugins are a bit tricky as they use ‘inventory sources’ and these sometimes can look like a configuration file and are passed in as a command line option, yet it is still considered ‘direct assignment’. It is a bit clearer when using an inline source <code>-i host1, host2, host3</code> than when using a file source <code>-i /path/to/inventory_source</code>, but they both have the same precedence.</p> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/reference_appendices/general_precedence.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/reference_appendices/general_precedence.html</a>
  </p>
</div>
