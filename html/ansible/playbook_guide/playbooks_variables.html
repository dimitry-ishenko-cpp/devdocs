<section id="using-variables"> <h1 id="playbooks-variables">Using Variables</h1> <p>Ansible uses variables to manage differences between systems. With Ansible, you can execute tasks and playbooks on multiple different systems with a single command. To represent the variations among those different systems, you can create variables with standard YAML syntax, including lists and dictionaries. You can define these variables in your playbooks, in your <a class="reference internal" href="../inventory_guide/intro_inventory.html#intro-inventory"><span class="std std-ref">inventory</span></a>, in reusable <a class="reference internal" href="playbooks_reuse.html#playbooks-reuse"><span class="std std-ref">files</span></a> or <a class="reference internal" href="playbooks_reuse_roles.html#playbooks-reuse-roles"><span class="std std-ref">roles</span></a>, or at the command line. You can also create variables during a playbook run by registering the return value or values of a task as a new variable.</p> <p>After you create variables, either by defining them in a file, passing them at the command line, or registering the return value or values of a task as a new variable, you can use those variables in module arguments, in <a class="reference internal" href="playbooks_conditionals.html#playbooks-conditionals"><span class="std std-ref">conditional “when” statements</span></a>, in <a class="reference internal" href="playbooks_templating.html#playbooks-templating"><span class="std std-ref">templates</span></a>, and in <a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">loops</span></a>.</p> <p>Once you understand the concepts and examples on this page, read about <a class="reference internal" href="playbooks_vars_facts.html#vars-and-facts"><span class="std std-ref">Ansible facts</span></a>, which are variables you retrieve from remote systems.</p>  <ul class="simple"> <li><a class="reference internal" href="#creating-valid-variable-names" id="id18">Creating valid variable names</a></li> <li>
<p><a class="reference internal" href="#simple-variables" id="id19">Simple variables</a></p> <ul> <li><a class="reference internal" href="#defining-simple-variables" id="id20">Defining simple variables</a></li> <li><a class="reference internal" href="#referencing-simple-variables" id="id21">Referencing simple variables</a></li> </ul> </li> <li><a class="reference internal" href="#when-to-quote-variables-a-yaml-gotcha" id="id22">When to quote variables (a YAML gotcha)</a></li> <li><a class="reference internal" href="#boolean-variables" id="id23">Boolean variables</a></li> <li>
<p><a class="reference internal" href="#list-variables" id="id24">List variables</a></p> <ul> <li><a class="reference internal" href="#defining-variables-as-lists" id="id25">Defining variables as lists</a></li> <li><a class="reference internal" href="#referencing-list-variables" id="id26">Referencing list variables</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#dictionary-variables" id="id27">Dictionary variables</a></p> <ul> <li><a class="reference internal" href="#defining-variables-as-key-value-dictionaries" id="id28">Defining variables as key:value dictionaries</a></li> <li><a class="reference internal" href="#referencing-key-value-dictionary-variables" id="id29">Referencing key:value dictionary variables</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#combining-variables" id="id30">Combining variables</a></p> <ul> <li><a class="reference internal" href="#combining-list-variables" id="id31">Combining list variables</a></li> <li><a class="reference internal" href="#combining-dictionary-variables" id="id32">Combining dictionary variables</a></li> <li><a class="reference internal" href="#using-the-merge-variables-lookup" id="id33">Using the merge_variables lookup</a></li> </ul> </li> <li><a class="reference internal" href="#registering-variables" id="id34">Registering variables</a></li> <li><a class="reference internal" href="#referencing-nested-variables" id="id35">Referencing nested variables</a></li> <li><a class="reference internal" href="#transforming-variables-with-jinja2-filters" id="id36">Transforming variables with Jinja2 filters</a></li> <li>
<p><a class="reference internal" href="#where-to-set-variables" id="id37">Where to set variables</a></p> <ul> <li><a class="reference internal" href="#defining-variables-in-inventory" id="id38">Defining variables in inventory</a></li> <li><a class="reference internal" href="#defining-variables-in-a-play" id="id39">Defining variables in a play</a></li> <li><a class="reference internal" href="#defining-variables-in-included-files-and-roles" id="id40">Defining variables in included files and roles</a></li> <li>
<p><a class="reference internal" href="#defining-variables-at-runtime" id="id41">Defining variables at runtime</a></p> <ul> <li><a class="reference internal" href="#key-value-format" id="id42">key=value format</a></li> <li><a class="reference internal" href="#json-string-format" id="id43">JSON string format</a></li> <li><a class="reference internal" href="#vars-from-a-json-or-yaml-file" id="id44">vars from a JSON or YAML file</a></li> </ul> </li> </ul> </li> <li>
<p><a class="reference internal" href="#variable-precedence-where-should-i-put-a-variable" id="id45">Variable precedence: Where should I put a variable?</a></p> <ul> <li><a class="reference internal" href="#understanding-variable-precedence" id="id46">Understanding variable precedence</a></li> <li><a class="reference internal" href="#scoping-variables" id="id47">Scoping variables</a></li> <li><a class="reference internal" href="#tips-on-where-to-set-variables" id="id48">Tips on where to set variables</a></li> </ul> </li> <li><a class="reference internal" href="#using-advanced-variable-syntax" id="id49">Using advanced variable syntax</a></li> </ul>  <section id="creating-valid-variable-names"> <h2 id="valid-variable-names">Creating valid variable names</h2> <p>Not all strings are valid Ansible variable names. A variable name can only include letters, numbers, and underscores. <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">Python keywords</a> or <a class="reference internal" href="../reference_appendices/playbooks_keywords.html#playbook-keywords"><span class="std std-ref">playbook keywords</span></a> are not valid variable names. A variable name cannot begin with a number.</p> <p>Variable names can begin with an underscore. In many programming languages, variables that begin with an underscore are private. This is not true in Ansible. Variables that begin with an underscore are treated exactly the same as any other variable. Do not rely on this convention for privacy or security.</p> <p>This table gives examples of valid and invalid variable names:</p> <table class="documentation-table docutils align-default"> <thead> <tr>
<th class="head"><p>Valid variable names</p></th> <th class="head"><p>Not valid</p></th> </tr> </thead>  <tr>
<td><p><code>foo</code></p></td> <td><p><code>*foo</code>, <a class="reference external" href="https://docs.python.org/3/reference/lexical_analysis.html#keywords">Python keywords</a> such as <code>async</code> and <code>lambda</code></p></td> </tr> <tr>
<td><p><code>foo_env</code></p></td> <td><p><a class="reference internal" href="../reference_appendices/playbooks_keywords.html#playbook-keywords"><span class="std std-ref">playbook keywords</span></a> such as <code>environment</code></p></td> </tr> <tr>
<td><p><code>foo_port</code></p></td> <td><p><code>foo-port</code>, <code>foo port</code>, <code>foo.port</code></p></td> </tr> <tr>
<td><p><code>foo5</code>, <code>_foo</code></p></td> <td><p><code>5foo</code>, <code>12</code></p></td> </tr>  </table> </section> <section id="simple-variables"> <h2>Simple variables</h2> <p>Simple variables combine a variable name with a single value. You can use this syntax (and the syntax for lists and dictionaries shown below) in a variety of places. For details about setting variables in inventory, in playbooks, in reusable files, in roles, or at the command line, see <a class="reference internal" href="#setting-variables"><span class="std std-ref">Where to set variables</span></a>.</p> <section id="defining-simple-variables"> <h3>Defining simple variables</h3> <p>You can define a simple variable using standard YAML syntax. For example:</p> <pre data-language="text">remote_install_path: /opt/my_app_config
</pre> </section> <section id="referencing-simple-variables"> <h3>Referencing simple variables</h3> <p>After you define a variable, use Jinja2 syntax to reference it. Jinja2 variables use double curly braces. For example, the expression <code>My amp goes to {{ max_amp_value }}</code> demonstrates the most basic form of variable substitution. You can use Jinja2 syntax in playbooks. For example:</p> <pre data-language="yaml+jinja">ansible.builtin.template:
  src: foo.cfg.j2
  dest: '{{ remote_install_path }}/foo.cfg'
</pre> <p>In this example, the variable defines the location of a file, which can vary from one system to another.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Ansible allows Jinja2 loops and conditionals in <a class="reference internal" href="playbooks_templating.html#playbooks-templating"><span class="std std-ref">templates</span></a> but not in playbooks. You cannot create a loop of tasks. Ansible playbooks are pure machine-parseable YAML.</p> </div> </section> </section> <section id="when-to-quote-variables-a-yaml-gotcha"> <h2 id="yaml-gotchas">When to quote variables (a YAML gotcha)</h2> <p>If you start a value with <code>{{ foo }}</code>, you must quote the whole expression to create valid YAML syntax. If you do not quote the whole expression, the YAML parser cannot interpret the syntax - it might be a variable or it might be the start of a YAML dictionary. For guidance on writing YAML, see the <a class="reference internal" href="../reference_appendices/yamlsyntax.html#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a> documentation.</p> <p>If you use a variable without quotes like this:</p> <pre data-language="yaml+jinja">- hosts: app_servers
  vars:
      app_path: {{ base_path }}/22
</pre> <p>You will see: <code>ERROR! Syntax Error while loading YAML.</code> If you add quotes, Ansible works correctly:</p> <pre data-language="yaml+jinja">- hosts: app_servers
  vars:
       app_path: "{{ base_path }}/22"
</pre> </section> <section id="boolean-variables"> <h2 id="id1">Boolean variables</h2> <p>Ansible accepts a broad range of values for boolean variables: <code>true/false</code>, <code>1/0</code>, <code>yes/no</code>, <code>True/False</code> and so on. The matching of valid strings is case insensitive. While documentation examples focus on <code>true/false</code> to be compatible with <code>ansible-lint</code> default settings, you can use any of the following:</p> <table class="documentation-table docutils align-default"> <thead> <tr>
<th class="head"><p>Valid values</p></th> <th class="head"><p>Description</p></th> </tr> </thead>  <tr>
<td><p><code>True</code> , <code>'true'</code> , <code>'t'</code> , <code>'yes'</code> , <code>'y'</code> , <code>'on'</code> , <code>'1'</code> , <code>1</code> , <code>1.0</code></p></td> <td><p>Truthy values</p></td> </tr> <tr>
<td><p><code>False</code> , <code>'false'</code> , <code>'f'</code> , <code>'no'</code> , <code>'n'</code> , <code>'off'</code> , <code>'0'</code> , <code>0</code> , <code>0.0</code></p></td> <td><p>Falsy values</p></td> </tr>  </table> </section> <section id="list-variables"> <h2 id="id2">List variables</h2> <p>A list variable combines a variable name with multiple values. The multiple values can be stored as an itemized list or in square brackets <code>[]</code>, separated with commas.</p> <section id="defining-variables-as-lists"> <h3>Defining variables as lists</h3> <p>You can define variables with multiple values using YAML lists. For example:</p> <pre data-language="yaml">region:
  - northeast
  - southeast
  - midwest
</pre> </section> <section id="referencing-list-variables"> <h3>Referencing list variables</h3> <p>When you use variables defined as a list (also called an array), you can use individual, specific fields from that list. The first item in a list is item 0, the second item is item 1. For example:</p> <pre data-language="yaml+jinja">region: "{{ region[0] }}"
</pre> <p>The value of this expression would be “northeast”.</p> </section> </section> <section id="dictionary-variables"> <h2 id="id3">Dictionary variables</h2> <p>A dictionary stores the data in key-value pairs. Usually, dictionaries are used to store related data, such as the information contained in an ID or a user profile.</p> <section id="defining-variables-as-key-value-dictionaries"> <h3>Defining variables as key:value dictionaries</h3> <p>You can define more complex variables using YAML dictionaries. A YAML dictionary maps keys to values. For example:</p> <pre data-language="yaml">foo:
  field1: one
  field2: two
</pre> </section> <section id="referencing-key-value-dictionary-variables"> <h3>Referencing key:value dictionary variables</h3> <p>When you use variables defined as a key:value dictionary (also called a hash), you can use individual, specific fields from that dictionary using either bracket notation or dot notation:</p> <pre data-language="yaml">foo['field1']
foo.field1
</pre> <p>Both of these examples reference the same value (“one”). Bracket notation always works. Dot notation can cause problems because some keys collide with attributes and methods of python dictionaries. Use bracket notation if you use keys which start and end with two underscores (which are reserved for special meanings in python) or are any of the known public attributes:</p> <p><code>add</code>, <code>append</code>, <code>as_integer_ratio</code>, <code>bit_length</code>, <code>capitalize</code>, <code>center</code>, <code>clear</code>, <code>conjugate</code>, <code>copy</code>, <code>count</code>, <code>decode</code>, <code>denominator</code>, <code>difference</code>, <code>difference_update</code>, <code>discard</code>, <code>encode</code>, <code>endswith</code>, <code>expandtabs</code>, <code>extend</code>, <code>find</code>, <code>format</code>, <code>fromhex</code>, <code>fromkeys</code>, <code>get</code>, <code>has_key</code>, <code>hex</code>, <code>imag</code>, <code>index</code>, <code>insert</code>, <code>intersection</code>, <code>intersection_update</code>, <code>isalnum</code>, <code>isalpha</code>, <code>isdecimal</code>, <code>isdigit</code>, <code>isdisjoint</code>, <code>is_integer</code>, <code>islower</code>, <code>isnumeric</code>, <code>isspace</code>, <code>issubset</code>, <code>issuperset</code>, <code>istitle</code>, <code>isupper</code>, <code>items</code>, <code>iteritems</code>, <code>iterkeys</code>, <code>itervalues</code>, <code>join</code>, <code>keys</code>, <code>ljust</code>, <code>lower</code>, <code>lstrip</code>, <code>numerator</code>, <code>partition</code>, <code>pop</code>, <code>popitem</code>, <code>real</code>, <code>remove</code>, <code>replace</code>, <code>reverse</code>, <code>rfind</code>, <code>rindex</code>, <code>rjust</code>, <code>rpartition</code>, <code>rsplit</code>, <code>rstrip</code>, <code>setdefault</code>, <code>sort</code>, <code>split</code>, <code>splitlines</code>, <code>startswith</code>, <code>strip</code>, <code>swapcase</code>, <code>symmetric_difference</code>, <code>symmetric_difference_update</code>, <code>title</code>, <code>translate</code>, <code>union</code>, <code>update</code>, <code>upper</code>, <code>values</code>, <code>viewitems</code>, <code>viewkeys</code>, <code>viewvalues</code>, <code>zfill</code>.</p> </section> </section> <section id="combining-variables"> <h2>Combining variables</h2> <p>To merge variables that contain lists or dictionaries, you can use the following approaches.</p> <section id="combining-list-variables"> <h3>Combining list variables</h3> <p>You can use the <code>set_fact</code> module to combine lists into a new <code>merged_list</code> variable as follows:</p> <pre data-language="yaml">vars:
  list1:
  - apple
  - banana
  - fig

  list2:
  - peach
  - plum
  - pear

tasks:
- name: Combine list1 and list2 into a merged_list var
  ansible.builtin.set_fact:
    merged_list: "{{ list1 + list2 }}"
</pre> </section> <section id="combining-dictionary-variables"> <h3>Combining dictionary variables</h3> <p>To merge dictionaries use the <code>combine</code> filter, for example:</p> <pre data-language="yaml">vars:
  dict1:
    name: Leeroy Jenkins
    age: 25
    occupation: Astronaut

  dict2:
    location: Galway
    country: Ireland
    postcode: H71 1234

tasks:
- name: Combine dict1 and dict2 into a merged_dict var
  ansible.builtin.set_fact:
    merged_dict: "{{ dict1 | ansible.builtin.combine(dict2) }}"
</pre> <p>For more details, see <a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter"><span class="std std-ref">ansible.builtin.combine</span></a> .</p> </section> <section id="using-the-merge-variables-lookup"> <h3>Using the merge_variables lookup</h3> <p>To merge variables that match the given prefixes, suffixes, or regular expressions, you can use the <code>community.general.merge_variables</code> lookup, for example:</p> <pre data-language="yaml">merged_variable: "{{ lookup('community.general.merge_variables', '__my_pattern', pattern_type='suffix') }}"
</pre> <p>For more details and example usage, refer to the <a class="reference external" href="../collections/community/general/merge_variables_lookup.html">community.general.merge_variables lookup documentation</a>.</p> </section> </section> <section id="registering-variables"> <h2 id="registered-variables">Registering variables</h2> <p>You can create variables from the output of an Ansible task with the task keyword <code>register</code>. You can use registered variables in any later tasks in your play. For example:</p> <pre data-language="yaml">- hosts: web_servers

  tasks:

     - name: Run a shell command and register its output as a variable
       ansible.builtin.shell: /usr/bin/foo
       register: foo_result
       ignore_errors: true

     - name: Run a shell command using output of the previous task
       ansible.builtin.shell: /usr/bin/bar
       when: foo_result.rc == 5
</pre> <p>For more examples of using registered variables in conditions on later tasks, see <a class="reference internal" href="playbooks_conditionals.html#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a>. Registered variables may be simple variables, list variables, dictionary variables, or complex nested data structures. The documentation for each module includes a <code>RETURN</code> section describing the return values for that module. To see the values for a particular task, run your playbook with <code>-v</code>.</p> <p>Registered variables are stored in memory. You cannot cache registered variables for use in future playbook runs. Registered variables are only valid on the host for the rest of the current playbook run, including subsequent plays within the same playbook run.</p> <p>Registered variables are host-level variables. When you register a variable in a task with a loop, the registered variable contains a value for each item in the loop. The data structure placed in the variable during the loop will contain a <code>results</code> attribute, that is a list of all responses from the module. For a more in-depth example of how this works, see the <a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">Loops</span></a> section on using register with a loop.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If a task fails or is skipped, Ansible still registers a variable with a failure or skipped status, unless the task is skipped based on tags. See <a class="reference internal" href="playbooks_tags.html#tags"><span class="std std-ref">Tags</span></a> for information on adding and using tags.</p> </div> </section> <section id="referencing-nested-variables"> <h2 id="accessing-complex-variable-data">Referencing nested variables</h2> <p>Many registered variables (and <a class="reference internal" href="playbooks_vars_facts.html#vars-and-facts"><span class="std std-ref">facts</span></a>) are nested YAML or JSON data structures. You cannot access values from these nested data structures with the simple <code>{{ foo }}</code> syntax. You must use either bracket notation or dot notation. For example, to reference an IP address from your facts using the bracket notation:</p> <pre data-language="yaml+jinja">{{ ansible_facts["eth0"]["ipv4"]["address"] }}
</pre> <p>To reference an IP address from your facts using the dot notation:</p> <pre data-language="yaml+jinja">{{ ansible_facts.eth0.ipv4.address }}
</pre> </section> <section id="transforming-variables-with-jinja2-filters"> <h2 id="about-jinja2">Transforming variables with Jinja2 filters</h2> <p>Jinja2 filters let you transform the value of a variable within a template expression. For example, the <code>capitalize</code> filter capitalizes any value passed to it; the <code>to_yaml</code> and <code>to_json</code> filters change the format of your variable values. Jinja2 includes many <a class="reference external" href="https://jinja.palletsprojects.com/templates/#builtin-filters">built-in filters</a> and Ansible supplies many more filters. To find more examples of filters, see <a class="reference internal" href="playbooks_filters.html#playbooks-filters"><span class="std std-ref">Using filters to manipulate data</span></a>.</p> </section> <section id="where-to-set-variables"> <h2 id="setting-variables">Where to set variables</h2> <p>You can define variables in a variety of places, such as in inventory, in playbooks, in reusable files, in roles, and at the command line. Ansible loads every possible variable it finds, then chooses the variable to apply based on <a class="reference internal" href="#ansible-variable-precedence"><span class="std std-ref">variable precedence rules</span></a>.</p> <section id="defining-variables-in-inventory"> <h3 id="define-variables-in-inventory">Defining variables in inventory</h3> <p>You can define different variables for each host individually, or set shared variables for a group of hosts in your inventory. For example, if all machines in the <code>[Boston]</code> group use ‘boston.ntp.example.com’ as an NTP server, you can set a group variable. The <a class="reference internal" href="../inventory_guide/intro_inventory.html#intro-inventory"><span class="std std-ref">How to build your inventory</span></a> page has details on setting <a class="reference internal" href="../inventory_guide/intro_inventory.html#host-variables"><span class="std std-ref">host variables</span></a> and <a class="reference internal" href="../inventory_guide/intro_inventory.html#group-variables"><span class="std std-ref">group variables</span></a> in inventory.</p> </section> <section id="defining-variables-in-a-play"> <h3 id="playbook-variables">Defining variables in a play</h3> <p>You can define variables directly in a playbook play:</p> <pre data-language="yaml">- hosts: webservers
  vars:
    http_port: 80
</pre> <p>When you define variables in a play, they are only visible to tasks executed in that play.</p> </section> <section id="defining-variables-in-included-files-and-roles"> <h3 id="included-variables">Defining variables in included files and roles</h3> <p>You can define variables in reusable variables files and/or in reusable roles. When you define variables in reusable variable files, the sensitive variables are separated from playbooks. This separation enables you to store your playbooks in a source control software and even share the playbooks, without the risk of exposing passwords or other sensitive and personal data. For information about creating reusable files and roles, see <a class="reference internal" href="playbooks_reuse.html#playbooks-reuse"><span class="std std-ref">Re-using Ansible artifacts</span></a>.</p> <p>This example shows how you can include variables defined in an external file:</p> <pre data-language="yaml">---

- hosts: all
  remote_user: root
  vars:
    favcolor: blue
  vars_files:
    - /vars/external_vars.yml

  tasks:

  - name: This is just a placeholder
    ansible.builtin.command: /bin/echo foo
</pre> <p>The contents of each variables file is a simple YAML dictionary. For example:</p> <pre data-language="yaml">---
# in the above example, this would be vars/external_vars.yml
somevar: somevalue
password: magic
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You can keep per-host and per-group variables in similar files. To learn about organizing your variables, see <a class="reference internal" href="../inventory_guide/intro_inventory.html#splitting-out-vars"><span class="std std-ref">Organizing host and group variables</span></a>.</p> </div> </section> <section id="defining-variables-at-runtime"> <h3 id="passing-variables-on-the-command-line">Defining variables at runtime</h3> <p>You can define variables when you run your playbook by passing variables at the command line using the <code>--extra-vars</code> (or <code>-e</code>) argument. You can also request user input with a <code>vars_prompt</code> (see <a class="reference internal" href="playbooks_prompts.html#playbooks-prompts"><span class="std std-ref">Interactive input: prompts</span></a>). When you pass variables at the command line, use a single quoted string, that contains one or more variables, in one of the formats below.</p> <section id="key-value-format"> <h4>key=value format</h4> <p>Values passed in using the <code>key=value</code> syntax are interpreted as strings. Use the JSON format if you need to pass non-string values such as Booleans, integers, floats, lists, and so on.</p> <pre data-language="text">ansible-playbook release.yml --extra-vars "version=1.23.45 other_variable=foo"
</pre> </section> <section id="json-string-format"> <h4>JSON string format</h4> <pre data-language="shell">ansible-playbook release.yml --extra-vars '{"version":"1.23.45","other_variable":"foo"}'
ansible-playbook arcade.yml --extra-vars '{"pacman":"mrs","ghosts":["inky","pinky","clyde","sue"]}'
</pre> <p>When passing variables with <code>--extra-vars</code>, you must escape quotes and other special characters appropriately for both your markup (for example, JSON) and for your shell:</p> <pre data-language="shell">ansible-playbook arcade.yml --extra-vars "{\"name\":\"Conan O\'Brien\"}"
ansible-playbook arcade.yml --extra-vars '{"name":"Conan O'\\\''Brien"}'
ansible-playbook script.yml --extra-vars "{\"dialog\":\"He said \\\"I just can\'t get enough of those single and double-quotes"\!"\\\"\"}"
</pre> </section> <section id="vars-from-a-json-or-yaml-file"> <h4>vars from a JSON or YAML file</h4> <p>If you have a lot of special characters, use a JSON or YAML file containing the variable definitions. Prepend both JSON and YAML file names with <code>@</code>.</p> <pre data-language="text">ansible-playbook release.yml --extra-vars "@some_file.json"
ansible-playbook release.yml --extra-vars "@some_file.yaml"
</pre> </section> </section> </section> <section id="variable-precedence-where-should-i-put-a-variable"> <h2 id="ansible-variable-precedence">Variable precedence: Where should I put a variable?</h2> <p>You can set multiple variables with the same name in many different places. When you do this, Ansible loads every possible variable it finds, and then chooses the variable to apply based on variable precedence. In other words, the different variables will override each other in a certain order.</p> <p>Teams and projects that agree on guidelines for defining variables (where to define certain types of variables) usually avoid variable precedence concerns. We suggest that you define each variable in one place: figure out where to define a variable, and keep it simple. For examples, see <a class="reference internal" href="#variable-examples"><span class="std std-ref">Tips on where to set variables</span></a>.</p> <p>Some behavioral parameters that you can set in variables you can also set in Ansible configuration, as command-line options, and using playbook keywords. For example, you can define the user Ansible uses to connect to remote devices as a variable with <code>ansible_user</code>, in a configuration file with <code>DEFAULT_REMOTE_USER</code>, as a command-line option with <code>-u</code>, and with the playbook keyword <code>remote_user</code>. If you define the same parameter in a variable and by another method, the variable overrides the other setting. This approach allows host-specific settings to override more general settings. For examples and more details on the precedence of these various settings, see <a class="reference internal" href="../reference_appendices/general_precedence.html#general-precedence-rules"><span class="std std-ref">Controlling how Ansible behaves: precedence rules</span></a>.</p> <section id="understanding-variable-precedence"> <h3>Understanding variable precedence</h3> <p>Ansible does apply variable precedence, and you might have a use for it. Here is the order of precedence from least to greatest (the last listed variables override all other variables):</p>  <ol class="arabic simple"> <li>command line values (for example, <code>-u my_user</code>, these are not variables)</li> <li>role defaults (as defined in <a class="reference internal" href="playbooks_reuse_roles.html#role-directory-structure"><span class="std std-ref">Role directory structure</span></a>) <a class="footnote-reference brackets" href="#id14" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a>
</li> <li>inventory file or script group vars <a class="footnote-reference brackets" href="#id15" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
</li> <li>inventory group_vars/all <a class="footnote-reference brackets" href="#id16" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>playbook group_vars/all <a class="footnote-reference brackets" href="#id16" id="id7" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>inventory group_vars/* <a class="footnote-reference brackets" href="#id16" id="id8" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>playbook group_vars/* <a class="footnote-reference brackets" href="#id16" id="id9" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>inventory file or script host vars <a class="footnote-reference brackets" href="#id15" id="id10" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a>
</li> <li>inventory host_vars/* <a class="footnote-reference brackets" href="#id16" id="id11" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>playbook host_vars/* <a class="footnote-reference brackets" href="#id16" id="id12" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a>
</li> <li>host facts / cached set_facts <a class="footnote-reference brackets" href="#id17" id="id13" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a>
</li> <li>play vars</li> <li>play vars_prompt</li> <li>play vars_files</li> <li>role vars (as defined in <a class="reference internal" href="playbooks_reuse_roles.html#role-directory-structure"><span class="std std-ref">Role directory structure</span></a>)</li> <li>block vars (only for tasks in block)</li> <li>task vars (only for the task)</li> <li>include_vars</li> <li>set_facts / registered vars</li> <li>role (and include_role) params</li> <li>include params</li> <li>extra vars (for example, <code>-e "user=my_user"</code>)(always win precedence)</li> </ol>  <p>In general, Ansible gives precedence to variables that were defined more recently, more actively, and with more explicit scope. Variables in the defaults folder inside a role are easily overridden. Anything in the vars directory of the role overrides previous versions of that variable in the namespace. Host and/or inventory variables override role defaults, but explicit includes such as the vars directory or an <code>include_vars</code> task override inventory variables.</p> <p>Ansible merges different variables set in inventory so that more specific settings override more generic settings. For example, <code>ansible_ssh_user</code> specified as a group_var is overridden by <code>ansible_user</code> specified as a host_var. For details about the precedence of variables set in inventory, see <a class="reference internal" href="../inventory_guide/intro_inventory.html#how-we-merge"><span class="std std-ref">How variables are merged</span></a>.</p> <h4 class="rubric">Footnotes</h4> <aside class="footnote-list brackets"> <aside class="footnote brackets" id="id14" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">1</a><span class="fn-bracket">]</span></span> <p>Tasks in each role see their own role’s defaults. Tasks defined outside of a role see the last role’s defaults.</p> </aside> <aside class="footnote brackets" id="id15" role="note"> <span class="label"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id5">1</a>,<a role="doc-backlink" href="#id10">2</a>)</span> <p>Variables defined in inventory file or provided by dynamic inventory.</p> </aside> <aside class="footnote brackets" id="id16" role="note"> <span class="label"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></span> <span class="backrefs">(<a role="doc-backlink" href="#id6">1</a>,<a role="doc-backlink" href="#id7">2</a>,<a role="doc-backlink" href="#id8">3</a>,<a role="doc-backlink" href="#id9">4</a>,<a role="doc-backlink" href="#id11">5</a>,<a role="doc-backlink" href="#id12">6</a>)</span> <p>Includes vars added by ‘vars plugins’ as well as host_vars and group_vars which are added by the default vars plugin shipped with Ansible.</p> </aside> <aside class="footnote brackets" id="id17" role="note"> <span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id13">4</a><span class="fn-bracket">]</span></span> <p>When created with set_facts’s cacheable option, variables have the high precedence in the play, but are the same as a host facts precedence when they come from the cache.</p> </aside> </aside> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Within any section, redefining a var overrides the previous instance. If multiple groups have the same variable, the last one loaded wins. If you define a variable twice in a play’s <code>vars:</code> section, the second one wins.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The previous describes the default config <code>hash_behaviour=replace</code>, switch to <code>merge</code> to only partially overwrite.</p> </div> </section> <section id="scoping-variables"> <h3 id="variable-scopes">Scoping variables</h3> <p>You can decide where to set a variable based on the scope you want that value to have. Ansible has three main scopes:</p>  <ul class="simple"> <li>Global: this is set by config, environment variables and the command line</li> <li>Play: each play and contained structures, vars entries (vars; vars_files; vars_prompt), role defaults and vars.</li> <li>Host: variables directly associated to a host, like inventory, include_vars, facts or registered task outputs</li> </ul>  <p>Inside a template, you automatically have access to all variables that are in scope for a host, plus any registered variables, facts, and magic variables.</p> </section> <section id="tips-on-where-to-set-variables"> <h3 id="variable-examples">Tips on where to set variables</h3> <p>You should choose where to define a variable based on the kind of control you might want over values.</p> <p>Set variables in inventory that deal with geography or behavior. Since groups are frequently the entity that maps roles onto hosts, you can often set variables on the group instead of defining them on a role. Remember: child groups override parent groups, and host variables override group variables. See <a class="reference internal" href="#define-variables-in-inventory"><span class="std std-ref">Defining variables in inventory</span></a> for details on setting host and group variables.</p> <p>Set common defaults in a <code>group_vars/all</code> file. See <a class="reference internal" href="../inventory_guide/intro_inventory.html#splitting-out-vars"><span class="std std-ref">Organizing host and group variables</span></a> for details on how to organize host and group variables in your inventory. Group variables are generally placed alongside your inventory file, but they can also be returned by dynamic inventory (see <a class="reference internal" href="../inventory_guide/intro_dynamic_inventory.html#intro-dynamic-inventory"><span class="std std-ref">Working with dynamic inventory</span></a>) or defined in AWX or on <a class="reference internal" href="https://docs.ansible.com/ansible/latest/reference_appendices/tower.html#ansible-platform"><span class="std std-ref">Red Hat Ansible Automation Platform</span></a> from the UI or API:</p> <pre data-language="yaml">---
# file: /etc/ansible/group_vars/all
# this is the site wide default
ntp_server: default-time.example.com
</pre> <p>Set location-specific variables in <code>group_vars/my_location</code> files. All groups are children of the <code>all</code> group, so variables set here override those set in <code>group_vars/all</code>:</p> <pre data-language="yaml">---
# file: /etc/ansible/group_vars/boston
ntp_server: boston-time.example.com
</pre> <p>If one host used a different NTP server, you could set that in a host_vars file, which would override the group variable:</p> <pre data-language="yaml">---
# file: /etc/ansible/host_vars/xyz.boston.example.com
ntp_server: override.example.com
</pre> <p>Set defaults in roles to avoid undefined-variable errors. If you share your roles, other users can rely on the reasonable defaults you added in the <code>roles/x/defaults/main.yml</code> file, or they can easily override those values in inventory or at the command line. See <a class="reference internal" href="playbooks_reuse_roles.html#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a> for more info. For example:</p> <pre data-language="yaml">---
# file: roles/x/defaults/main.yml
# if no other value is supplied in inventory or as a parameter, this value will be used
http_port: 80
</pre> <p>Set variables in roles to ensure a value is used in that role, and is not overridden by inventory variables. If you are not sharing your role with others, you can define app-specific behaviors like ports this way, in <code>roles/x/vars/main.yml</code>. If you are sharing roles with others, putting variables here makes them harder to override, although they still can by passing a parameter to the role or setting a variable with <code>-e</code>:</p> <pre data-language="yaml">---
# file: roles/x/vars/main.yml
# this will absolutely be used in this role
http_port: 80
</pre> <p>Pass variables as parameters when you call roles for maximum clarity, flexibility, and visibility. This approach overrides any defaults that exist for a role. For example:</p> <pre data-language="yaml">roles:
   - role: apache
     vars:
        http_port: 8080
</pre> <p>When you read this playbook it is clear that you have chosen to set a variable or override a default. You can also pass multiple values, which allows you to run the same role multiple times. See <a class="reference internal" href="playbooks_reuse_roles.html#run-role-twice"><span class="std std-ref">Running a role multiple times in one play</span></a> for more details. For example:</p> <pre data-language="yaml">roles:
   - role: app_user
     vars:
        myname: Ian
   - role: app_user
     vars:
       myname: Terry
   - role: app_user
     vars:
       myname: Graham
   - role: app_user
     vars:
       myname: John
</pre> <p>Variables set in one role are available to later roles. You can set variables in the role’s <code>vars</code> directory (as defined in <a class="reference internal" href="playbooks_reuse_roles.html#role-directory-structure"><span class="std std-ref">Role directory structure</span></a>) and use them in other roles and elsewhere in your playbook:</p> <pre data-language="yaml">roles:
   - role: common_settings
   - role: something
     vars:
       foo: 12
   - role: something_else
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>There are some protections in place to avoid the need to namespace variables. In this example, variables defined in ‘common_settings’ are available to ‘something’ and ‘something_else’ tasks, but tasks in ‘something’ have foo set at 12, even if ‘common_settings’ sets foo to 20.</p> </div> <p>Instead of worrying about variable precedence, we encourage you to think about how easily or how often you want to override a variable when deciding where to set it. If you are not sure what other variables are defined, and you need a particular value, use <code>--extra-vars</code> (<code>-e</code>) to override all other variables.</p> </section> </section> <section id="using-advanced-variable-syntax"> <h2>Using advanced variable syntax</h2> <p>For information about advanced YAML syntax used to declare variables and have more control over the data placed in YAML files used by Ansible, see <a class="reference internal" href="playbooks_advanced_syntax.html#playbooks-advanced-syntax"><span class="std std-ref">Advanced playbook syntax</span></a>.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="playbooks_intro.html#about-playbooks"><span class="std std-ref">Ansible playbooks</span></a></dt>
<dd>
<p>An introduction to playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_conditionals.html#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a></dt>
<dd>
<p>Conditional statements in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_filters.html#playbooks-filters"><span class="std std-ref">Using filters to manipulate data</span></a></dt>
<dd>
<p>Jinja2 filters and their uses</p> </dd> <dt><a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">Loops</span></a></dt>
<dd>
<p>Looping in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_reuse_roles.html#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a></dt>
<dd>
<p>Playbook organization by roles</p> </dd> <dt><a class="reference internal" href="../tips_tricks/ansible_tips_tricks.html#tips-and-tricks"><span class="std std-ref">General tips</span></a></dt>
<dd>
<p>Tips and tricks for playbooks</p> </dd> <dt><a class="reference internal" href="../reference_appendices/special_variables.html#special-variables"><span class="std std-ref">Special Variables</span></a></dt>
<dd>
<p>List of special variables</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Communication</span></a></dt>
<dd>
<p>Got questions? Need help? Want to share your ideas? Visit the Ansible communication guide</p> </dd> </dl> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_variables.html</a>
  </p>
</div>
