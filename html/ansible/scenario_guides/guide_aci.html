<h1 id="aci-guide">Cisco ACI Guide</h1>  <h2 id="aci-guide-intro">What is Cisco ACI ?</h2>  <h3 id="cisco-aci-guide">Application Centric Infrastructure (ACI)</h3> <p>The Cisco Application Centric Infrastructure (ACI) allows application requirements to define the network. This architecture simplifies, optimizes, and accelerates the entire application deployment life cycle.</p>   <h3 id="application-policy-infrastructure-controller-apic">Application Policy Infrastructure Controller (APIC)</h3> <p>The APIC manages the scalable ACI multi-tenant fabric. The APIC provides a unified point of automation and management, policy programming, application deployment, and health monitoring for the fabric. The APIC, which is implemented as a replicated synchronized clustered controller, optimizes performance, supports any application anywhere, and provides unified operation of the physical and virtual infrastructure.</p> <p>The APIC enables network administrators to easily define the optimal network for applications. Data center operators can clearly see how applications consume network resources, easily isolate and troubleshoot application and infrastructure problems, and monitor and profile resource usage patterns.</p> <p>The Cisco Application Policy Infrastructure Controller (APIC) API enables applications to directly connect with a secure, shared, high-performance resource pool that includes network, compute, and storage capabilities.</p>   <h3 id="aci-fabric">ACI Fabric</h3> <p>The Cisco Application Centric Infrastructure (ACI) Fabric includes Cisco Nexus 9000 Series switches with the APIC to run in the leaf/spine ACI fabric mode. These switches form a “fat-tree” network by connecting each leaf node to each spine node; all other devices connect to the leaf nodes. The APIC manages the ACI fabric.</p> <p>The ACI fabric provides consistent low-latency forwarding across high-bandwidth links (40 Gbps, with a 100-Gbps future capability). Traffic with the source and destination on the same leaf switch is handled locally, and all other traffic travels from the ingress leaf to the egress leaf through a spine switch. Although this architecture appears as two hops from a physical perspective, it is actually a single Layer 3 hop because the fabric operates as a single Layer 3 switch.</p> <p>The ACI fabric object-oriented operating system (OS) runs on each Cisco Nexus 9000 Series node. It enables programming of objects for each configurable element of the system. The ACI fabric OS renders policies from the APIC into a concrete model that runs in the physical infrastructure. The concrete model is analogous to compiled software; it is the form of the model that the switch operating system can execute.</p> <p>All the switch nodes contain a complete copy of the concrete model. When an administrator creates a policy in the APIC that represents a configuration, the APIC updates the logical model. The APIC then performs the intermediate step of creating a fully elaborated policy that it pushes into all the switch nodes where the concrete model is updated.</p> <p>The APIC is responsible for fabric activation, switch firmware management, network policy configuration, and instantiation. While the APIC acts as the centralized policy and network management engine for the fabric, it is completely removed from the data path, including the forwarding topology. Therefore, the fabric can still forward traffic even when communication with the APIC is lost.</p>   <h3 id="more-information">More information</h3> <p>Various resources exist to start learning ACI, here is a list of interesting articles from the community.</p> <ul class="simple"> <li><a class="reference external" href="https://adamraffe.com/learning-aci/">Adam Raffe: Learning ACI</a></li> <li><a class="reference external" href="https://lucarelandini.blogspot.be/2015/03/aci-for-dummies.html">Luca Relandini: ACI for dummies</a></li> <li><a class="reference external" href="https://learninglabs.cisco.com/labs/tags/ACI">Cisco DevNet Learning Labs about ACI</a></li> </ul>    <h2 id="aci-guide-modules">Using the ACI modules</h2> <p id="using-the-aci-modules">The Ansible ACI modules provide a user-friendly interface to managing your ACI environment using Ansible playbooks.</p> <p>For instance ensuring that a specific tenant exists, is done using the following Ansible task using the aci_tenant module:</p> <pre data-language="yaml">- name: Ensure tenant customer-xyz exists
  aci_tenant:
    host: my-apic-1
    username: admin
    password: my-password

    tenant: customer-xyz
    description: Customer XYZ
    state: present
</pre> <p>A complete list of existing ACI modules is available on the content tab of the <a class="reference external" href="https://galaxy.ansible.com/cisco/aci">ACI collection on Ansible Galaxy</a>.</p> <p>If you want to learn how to write your own ACI modules to contribute, look at the <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general_aci.html#aci-dev-guide"><span class="std std-ref">Developing Cisco ACI modules</span></a> section.</p>  <h3 id="querying-aci-configuration">Querying ACI configuration</h3> <p>A module can also be used to query a specific object.</p> <pre data-language="yaml">- name: Query tenant customer-xyz
  aci_tenant:
    host: my-apic-1
    username: admin
    password: my-password

    tenant: customer-xyz
    state: query
  register: my_tenant
</pre> <p>Or query all objects.</p> <pre data-language="yaml">- name: Query all tenants
  aci_tenant:
    host: my-apic-1
    username: admin
    password: my-password

    state: query
  register: all_tenants
</pre> <p>After registering the return values of the aci_tenant task as shown above, you can access all tenant information from variable <code>all_tenants</code>.</p>   <h3 id="running-on-the-controller-locally">Running on the controller locally</h3> <p>As originally designed, Ansible modules are shipped to and run on the remote target(s), however the ACI modules (like most network-related modules) do not run on the network devices or controller (in this case the APIC), but they talk directly to the APIC’s REST interface.</p> <p>For this very reason, the modules need to run on the local Ansible controller (or are delegated to another system that <em>can</em> connect to the APIC).</p>  <h4 id="gathering-facts">Gathering facts</h4> <p>Because we run the modules on the Ansible controller gathering facts will not work. That is why when using these ACI modules it is mandatory to disable facts gathering. You can do this globally in your <code>ansible.cfg</code> or by adding <code>gather_facts: no</code> to every play.</p> <pre data-language="yaml"> - name: Another play in my playbook
   hosts: my-apic-1
   gather_facts: no
   tasks:
   - name: Create a tenant
     aci_tenant:
       ...
</pre>   <h4 id="delegating-to-localhost">Delegating to localhost</h4> <p>So let us assume we have our target configured in the inventory using the FQDN name as the <code>ansible_host</code> value, as shown below.</p> <pre data-language="yaml"> apics:
   my-apic-1:
     ansible_host: apic01.fqdn.intra
     ansible_user: admin
     ansible_password: my-password
</pre> <p>One way to set this up is to add to every task the directive: <code>delegate_to: localhost</code>.</p> <pre data-language="yaml"> - name: Query all tenants
   aci_tenant:
     host: '{{ ansible_host }}'
     username: '{{ ansible_user }}'
     password: '{{ ansible_password }}'

     state: query
   delegate_to: localhost
   register: all_tenants
</pre> <p>If one would forget to add this directive, Ansible will attempt to connect to the APIC using SSH and attempt to copy the module and run it remotely. This will fail with a clear error, yet may be confusing to some.</p>   <h4 id="using-the-local-connection-method">Using the local connection method</h4> <p>Another option frequently used, is to tie the <code>local</code> connection method to this target so that every subsequent task for this target will use the local connection method (hence run it locally, rather than use SSH).</p> <p>In this case the inventory may look like this:</p> <pre data-language="yaml"> apics:
   my-apic-1:
     ansible_host: apic01.fqdn.intra
     ansible_user: admin
     ansible_password: my-password
     ansible_connection: local
</pre> <p>But used tasks do not need anything special added.</p> <pre data-language="yaml">- name: Query all tenants
  aci_tenant:
    host: '{{ ansible_host }}'
    username: '{{ ansible_user }}'
    password: '{{ ansible_password }}'

    state: query
  register: all_tenants
</pre> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>For clarity we have added <code>delegate_to: localhost</code> to all the examples in the module documentation. This helps to ensure first-time users can easily copy&amp;paste parts and make them work with a minimum of effort.</p> </div>    <h3 id="common-parameters">Common parameters</h3> <p>Every Ansible ACI module accepts the following parameters that influence the module’s communication with the APIC REST API:</p>  <dl class="simple"> <dt>host</dt>
<dd>
<p>Hostname or IP address of the APIC.</p> </dd> <dt>port</dt>
<dd>
<p>Port to use for communication. (Defaults to <code>443</code> for HTTPS, and <code>80</code> for HTTP)</p> </dd> <dt>username</dt>
<dd>
<p>User name used to log on to the APIC. (Defaults to <code>admin</code>)</p> </dd> <dt>password</dt>
<dd>
<p>Password for <code>username</code> to log on to the APIC, using password-based authentication.</p> </dd> <dt>private_key</dt>
<dd>
<p>Private key for <code>username</code> to log on to APIC, using signature-based authentication. This could either be the raw private key content (include header/footer) or a file that stores the key content. <em>New in version 2.5</em></p> </dd> <dt>certificate_name</dt>
<dd>
<p>Name of the certificate in the ACI Web GUI. This defaults to either the <code>username</code> value or the <code>private_key</code> file base name). <em>New in version 2.5</em></p> </dd> <dt>timeout</dt>
<dd>
<p>Timeout value for socket-level communication.</p> </dd> <dt>use_proxy</dt>
<dd>
<p>Use system proxy settings. (Defaults to <code>yes</code>)</p> </dd> <dt>use_ssl</dt>
<dd>
<p>Use HTTPS or HTTP for APIC REST communication. (Defaults to <code>yes</code>)</p> </dd> <dt>validate_certs</dt>
<dd>
<p>Validate certificate when using HTTPS communication. (Defaults to <code>yes</code>)</p> </dd> <dt>output_level</dt>
<dd>
<p>Influence the level of detail ACI modules return to the user. (One of <code>normal</code>, <code>info</code> or <code>debug</code>) <em>New in version 2.5</em></p> </dd> </dl>    <h3 id="proxy-support">Proxy support</h3> <p>By default, if an environment variable <code>&lt;protocol&gt;_proxy</code> is set on the target host, requests will be sent through that proxy. This behaviour can be overridden by setting a variable for this task (see <a class="reference internal" href="../user_guide/playbooks_environment.html#playbooks-environment"><span class="std std-ref">Setting the remote environment</span></a>), or by using the <code>use_proxy</code> module parameter.</p> <p>HTTP redirects can redirect from HTTP to HTTPS so ensure that the proxy environment for both protocols is correctly configured.</p> <p>If proxy support is not needed, but the system may have it configured nevertheless, use the parameter <code>use_proxy: no</code> to avoid accidental system proxy usage.</p> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>Selective proxy support using the <code>no_proxy</code> environment variable is also supported.</p> </div>   <h3 id="return-values">Return values</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> <p>The following values are always returned:</p>  <dl class="simple"> <dt>current</dt>
<dd>
<p>The resulting state of the managed object, or results of your query.</p> </dd> </dl>  <p>The following values are returned when <code>output_level: info</code>:</p>  <dl class="simple"> <dt>previous</dt>
<dd>
<p>The original state of the managed object (before any change was made).</p> </dd> <dt>proposed</dt>
<dd>
<p>The proposed config payload, based on user-supplied values.</p> </dd> <dt>sent</dt>
<dd>
<p>The sent config payload, based on user-supplied values and the existing configuration.</p> </dd> </dl>  <p>The following values are returned when <code>output_level: debug</code> or <code>ANSIBLE_DEBUG=1</code>:</p>  <dl class="simple"> <dt>filter_string</dt>
<dd>
<p>The filter used for specific APIC queries.</p> </dd> <dt>method</dt>
<dd>
<p>The HTTP method used for the sent payload. (Either <code>GET</code> for queries, <code>DELETE</code> or <code>POST</code> for changes)</p> </dd> <dt>response</dt>
<dd>
<p>The HTTP response from the APIC.</p> </dd> <dt>status</dt>
<dd>
<p>The HTTP status code for the request.</p> </dd> <dt>url</dt>
<dd>
<p>The url used for the request.</p> </dd> </dl>  <div class="admonition note"> <p class="admonition-title">Note</p> <p>The module return values are documented in detail as part of each module’s documentation.</p> </div>   <h3 id="id1">More information</h3> <p>Various resources exist to start learn more about ACI programmability, we recommend the following links:</p> <ul class="simple"> <li><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general_aci.html#aci-dev-guide"><span class="std std-ref">Developing Cisco ACI modules</span></a></li> <li><a class="reference external" href="https://blogs.cisco.com/developer/automating-cisco-aci-with-ansible-eliminates-repetitive-day-to-day-tasks">Jacob McGill: Automating Cisco ACI with Ansible</a></li> <li><a class="reference external" href="https://learninglabs.cisco.com/labs/tags/ACI,Ansible">Cisco DevNet Learning Labs about ACI and Ansible</a></li> </ul>    <h2 id="aci-guide-auth">ACI authentication</h2>  <h3 id="aci-authentication">Password-based authentication</h3> <p>If you want to log on using a username and password, you can use the following parameters with your ACI modules:</p> <pre data-language="yaml">username: admin
password: my-password
</pre> <p>Password-based authentication is very simple to work with, but it is not the most efficient form of authentication from ACI’s point-of-view as it requires a separate login-request and an open session to work. To avoid having your session time-out and requiring another login, you can use the more efficient Signature-based authentication.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Password-based authentication also may trigger anti-DoS measures in ACI v3.1+ that causes session throttling and results in HTTP 503 errors and login failures.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Never store passwords in plain text.</p> </div> <p>The “Vault” feature of Ansible allows you to keep sensitive data such as passwords or keys in encrypted files, rather than as plain text in your playbooks or roles. These vault files can then be distributed or placed in source control. See <a class="reference internal" href="../user_guide/vault.html#playbooks-vault"><span class="std std-ref">Using encrypted variables and files</span></a> for more information.</p>   <h3 id="signature-based-authentication-using-certificates">Signature-based authentication using certificates</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> <p>Using signature-based authentication is more efficient and more reliable than password-based authentication.</p>  <h4 id="generate-certificate-and-private-key">Generate certificate and private key</h4> <p>Signature-based authentication requires a (self-signed) X.509 certificate with private key, and a configuration step for your AAA user in ACI. To generate a working X.509 certificate and private key, use the following procedure:</p> <pre data-language="bash">$ openssl req -new -newkey rsa:1024 -days 36500 -nodes -x509 -keyout admin.key -out admin.crt -subj '/CN=Admin/O=Your Company/C=US'
</pre>   <h4 id="configure-your-local-user">Configure your local user</h4> <p>Perform the following steps:</p> <ul class="simple"> <li>Add the X.509 certificate to your ACI AAA local user at <span class="guilabel">ADMIN</span> » <span class="guilabel">AAA</span>
</li> <li>Click <span class="guilabel">AAA Authentication</span>
</li> <li>Check that in the <span class="guilabel">Authentication</span> field the <span class="guilabel">Realm</span> field displays <span class="guilabel">Local</span>
</li> <li>Expand <span class="guilabel">Security Management</span> » <span class="guilabel">Local Users</span>
</li> <li>Click the name of the user you want to add a certificate to, in the <span class="guilabel">User Certificates</span> area</li> <li>
<p>Click the <span class="guilabel">+</span> sign and in the <span class="guilabel">Create X509 Certificate</span> enter a certificate name in the <span class="guilabel">Name</span> field</p> <ul> <li>If you use the basename of your private key here, you don’t need to enter <code>certificate_name</code> in Ansible</li> </ul> </li> <li>Copy and paste your X.509 certificate in the <span class="guilabel">Data</span> field.</li> </ul> <p>You can automate this by using the following Ansible task:</p> <pre data-language="yaml">- name: Ensure we have a certificate installed
  aci_aaa_user_certificate:
    host: my-apic-1
    username: admin
    password: my-password

    aaa_user: admin
    certificate_name: admin
    certificate: "{{ lookup('file', 'pki/admin.crt') }}"  # This will read the certificate data from a local file
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Signature-based authentication only works with local users.</p> </div>   <h4 id="use-signature-based-authentication-with-ansible">Use signature-based authentication with Ansible</h4> <p>You need the following parameters with your ACI module(s) for it to work:</p> <pre data-language="yaml"> username: admin
 private_key: pki/admin.key
 certificate_name: admin  # This could be left out !
</pre> <p>or you can use the private key content:</p> <pre data-language="yaml"> username: admin
 private_key: |
     -----BEGIN PRIVATE KEY-----
     &lt;&lt;your private key content&gt;&gt;
     -----END PRIVATE KEY-----
 certificate_name: admin  # This could be left out !
</pre> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>If you use a certificate name in ACI that matches the private key’s basename, you can leave out the <code>certificate_name</code> parameter like the example above.</p> </div>   <h4 id="using-ansible-vault-to-encrypt-the-private-key">Using Ansible Vault to encrypt the private key</h4> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> <p>To start, encrypt the private key and give it a strong password.</p> <pre data-language="bash">ansible-vault encrypt admin.key
</pre> <p>Use a text editor to open the private-key. You should have an encrypted cert now.</p> <pre data-language="bash">$ANSIBLE_VAULT;1.1;AES256
56484318584354658465121889743213151843149454864654151618131547984132165489484654
45641818198456456489479874513215489484843614848456466655432455488484654848489498
....
</pre> <p>Copy and paste the new encrypted cert into your playbook as a new variable.</p> <pre data-language="yaml">private_key: !vault |
      $ANSIBLE_VAULT;1.1;AES256
      56484318584354658465121889743213151843149454864654151618131547984132165489484654
      45641818198456456489479874513215489484843614848456466655432455488484654848489498
      ....
</pre> <p>Use the new variable for the private_key:</p> <pre data-language="yaml">username: admin
private_key: "{{ private_key }}"
certificate_name: admin  # This could be left out !
</pre> <p>When running the playbook, use “–ask-vault-pass” to decrypt the private key.</p> <pre data-language="bash">ansible-playbook site.yaml --ask-vault-pass
</pre>   <h4 id="id2">More information</h4> <ul class="simple"> <li>Detailed information about Signature-based Authentication is available from <a class="reference external" href="https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/kb/b_KB_Signature_Based_Transactions.html">Cisco APIC Signature-Based Transactions</a>.</li> <li>More information on Ansible Vault can be found on the <a class="reference internal" href="../user_guide/vault.html#vault"><span class="std std-ref">Ansible Vault</span></a> page.</li> </ul>     <h2 id="aci-guide-rest">Using ACI REST with Ansible</h2> <p id="using-aci-rest-with-ansible">While already a lot of ACI modules exists in the Ansible distribution, and the most common actions can be performed with these existing modules, there’s always something that may not be possible with off-the-shelf modules.</p> <p>The aci_rest module provides you with direct access to the APIC REST API and enables you to perform any task not already covered by the existing modules. This may seem like a complex undertaking, but you can generate the needed REST payload for any action performed in the ACI web interface effortlessly.</p>  <h3 id="built-in-idempotency">Built-in idempotency</h3> <p>Because the APIC REST API is intrinsically idempotent and can report whether a change was made, the aci_rest module automatically inherits both capabilities and is a first-class solution for automating your ACI infrastructure. As a result, users that require more powerful low-level access to their ACI infrastructure don’t have to give up on idempotency and don’t have to guess whether a change was performed when using the aci_rest module.</p>   <h3 id="using-the-aci-rest-module">Using the aci_rest module</h3> <p>The aci_rest module accepts the native XML and JSON payloads, but additionally accepts inline YAML payload (structured like JSON). The XML payload requires you to use a path ending with <code>.xml</code> whereas JSON or YAML require the path to end with <code>.json</code>.</p> <p>When you’re making modifications, you can use the POST or DELETE methods, whereas doing just queries require the GET method.</p> <p>For instance, if you would like to ensure a specific tenant exists on ACI, these below four examples are functionally identical:</p> <p><strong>XML</strong> (Native ACI REST)</p> <pre data-language="yaml">- aci_rest:
    host: my-apic-1
    private_key: pki/admin.key

    method: post
    path: /api/mo/uni.xml
    content: |
      &lt;fvTenant name="customer-xyz" descr="Customer XYZ"/&gt;
</pre> <p><strong>JSON</strong> (Native ACI REST)</p> <pre data-language="yaml">- aci_rest:
    host: my-apic-1
    private_key: pki/admin.key

    method: post
    path: /api/mo/uni.json
    content:
      {
        "fvTenant": {
          "attributes": {
            "name": "customer-xyz",
            "descr": "Customer XYZ"
          }
        }
      }
</pre> <p><strong>YAML</strong> (Ansible-style REST)</p> <pre data-language="yaml">- aci_rest:
    host: my-apic-1
    private_key: pki/admin.key

    method: post
    path: /api/mo/uni.json
    content:
      fvTenant:
        attributes:
          name: customer-xyz
          descr: Customer XYZ
</pre> <p><strong>Ansible task</strong> (Dedicated module)</p> <pre data-language="yaml">- aci_tenant:
    host: my-apic-1
    private_key: pki/admin.key

    tenant: customer-xyz
    description: Customer XYZ
    state: present
</pre> <div class="admonition hint"> <p class="admonition-title">Hint</p> <p>The XML format is more practical when there is a need to template the REST payload (inline), but the YAML format is more convenient for maintaining your infrastructure-as-code and feels more naturally integrated with Ansible playbooks. The dedicated modules offer a more simple, abstracted, but also a more limited experience. Use what feels best for your use-case.</p> </div>   <h3 id="id3">More information</h3> <p>Plenty of resources exist to learn about ACI’s APIC REST interface, we recommend the links below:</p> <ul class="simple"> <li><a class="reference external" href="https://galaxy.ansible.com/cisco/aci">The ACI collection on Ansible Galaxy</a></li> <li>
<a class="reference external" href="https://www.cisco.com/c/en/us/td/docs/switches/datacenter/aci/apic/sw/2-x/rest_cfg/2_1_x/b_Cisco_APIC_REST_API_Configuration_Guide.html">APIC REST API Configuration Guide</a> – Detailed guide on how the APIC REST API is designed and used, incl. many examples</li> <li>
<a class="reference external" href="https://developer.cisco.com/docs/apic-mim-ref/">APIC Management Information Model reference</a> – Complete reference of the APIC object model</li> <li><a class="reference external" href="https://learninglabs.cisco.com/labs/tags/ACI,REST">Cisco DevNet Learning Labs about ACI and REST</a></li> </ul>    <h2 id="aci-guide-ops">Operational examples</h2> <p id="operational-examples">Here is a small overview of useful operational tasks to reuse in your playbooks.</p> <p>Feel free to contribute more useful snippets.</p>  <h3 id="waiting-for-all-controllers-to-be-ready">Waiting for all controllers to be ready</h3> <p>You can use the below task after you started to build your APICs and configured the cluster to wait until all the APICs have come online. It will wait until the number of controllers equals the number listed in the <code>apic</code> inventory group.</p> <pre data-language="yaml">- name: Waiting for all controllers to be ready
  aci_rest:
    host: my-apic-1
    private_key: pki/admin.key
    method: get
    path: /api/node/class/topSystem.json?query-target-filter=eq(topSystem.role,"controller")
  register: topsystem
  until: topsystem|success and topsystem.totalCount|int &gt;= groups['apic']|count &gt;= 3
  retries: 20
  delay: 30
</pre>   <h3 id="waiting-for-cluster-to-be-fully-fit">Waiting for cluster to be fully-fit</h3> <p>The below example waits until the cluster is fully-fit. In this example you know the number of APICs in the cluster and you verify each APIC reports a ‘fully-fit’ status.</p> <pre data-language="yaml">- name: Waiting for cluster to be fully-fit
  aci_rest:
    host: my-apic-1
    private_key: pki/admin.key
    method: get
    path: /api/node/class/infraWiNode.json?query-target-filter=wcard(infraWiNode.dn,"topology/pod-1/node-1/av")
  register: infrawinode
  until: &gt;
    infrawinode|success and
    infrawinode.totalCount|int &gt;= groups['apic']|count &gt;= 3 and
    infrawinode.imdata[0].infraWiNode.attributes.health == 'fully-fit' and
    infrawinode.imdata[1].infraWiNode.attributes.health == 'fully-fit' and
    infrawinode.imdata[2].infraWiNode.attributes.health == 'fully-fit'
  retries: 30
  delay: 30
</pre>    <h2 id="aci-guide-errors">APIC error messages</h2> <p id="apic-error-messages">The following error messages may occur and this section can help you understand what exactly is going on and how to fix/avoid them.</p>  <dl class="simple"> <dt>APIC Error 122: unknown managed object class ‘polUni’</dt>
<dd>
<p>In case you receive this error while you are certain your aci_rest payload and object classes are seemingly correct, the issue might be that your payload is not in fact correct JSON (for example, the sent payload is using single quotes, rather than double quotes), and as a result the APIC is not correctly parsing your object classes from the payload. One way to avoid this is by using a YAML or an XML formatted payload, which are easier to construct correctly and modify later.</p> </dd> <dt>APIC Error 400: invalid data at line ‘1’. Attributes are missing, tag ‘attributes’ must be specified first, before any other tag</dt>
<dd>
<p>Although the JSON specification allows unordered elements, the APIC REST API requires that the JSON <code>attributes</code> element precede the <code>children</code> array or other elements. So you need to ensure that your payload conforms to this requirement. Sorting your dictionary keys will do the trick just fine. If you don’t have any attributes, it may be necessary to add: <code>attributes: {}</code> as the APIC does expect the entry to precede any <code>children</code>.</p> </dd> <dt>APIC Error 801: property descr of uni/tn-TENANT/ap-AP failed validation for value ‘A “legacy” network’</dt>
<dd>
<p>Some values in the APIC have strict format-rules to comply to, and the internal APIC validation check for the provided value failed. In the above case, the <code>description</code> parameter (internally known as <code>descr</code>) only accepts values conforming to <a class="reference external" href="https://pubhub-prod.s3.amazonaws.com/media/apic-mim-ref/docs/MO-fvAp.html#descr">Regex: [a-zA-Z0-9\!#$%()*,-./:;@ _{|}~?&amp;+]+</a>, in general it must not include quotes or square brackets.</p> </dd> </dl>    <h2 id="aci-guide-known-issues">Known issues</h2> <p id="known-issues">The aci_rest module is a wrapper around the APIC REST API. As a result any issues related to the APIC will be reflected in the use of this module.</p> <p>All below issues either have been reported to the vendor, and most can simply be avoided.</p>  <dl> <dt>Too many consecutive API calls may result in connection throttling</dt>
<dd>
<p>Starting with ACI v3.1 the APIC will actively throttle password-based authenticated connection rates over a specific threshold. This is as part of an anti-DDOS measure but can act up when using Ansible with ACI using password-based authentication. Currently, one solution is to increase this threshold within the nginx configuration, but using signature-based authentication is recommended.</p> <p><strong>NOTE:</strong> It is advisable to use signature-based authentication with ACI as it not only prevents connection-throttling, but also improves general performance when using the ACI modules.</p> </dd> <dt>Specific requests may not reflect changes correctly (<a class="reference external" href="https://github.com/ansible/ansible/issues/35041">#35401</a>)</dt>
<dd>
<p>There is a known issue where specific requests to the APIC do not properly reflect changed in the resulting output, even when we request those changes explicitly from the APIC. In one instance using the path <code>api/node/mo/uni/infra.xml</code> fails, where <code>api/node/mo/uni/infra/.xml</code> does work correctly.</p> <p><strong>NOTE:</strong> A workaround is to register the task return values (for example, <code>register: this</code>) and influence when the task should report a change by adding: <code>changed_when: this.imdata != []</code>.</p> </dd> <dt>Specific requests are known to not be idempotent (<a class="reference external" href="https://github.com/ansible/ansible/issues/35050">#35050</a>)</dt>
<dd>
<p>The behaviour of the APIC is inconsistent to the use of <code>status="created"</code> and <code>status="deleted"</code>. The result is that when you use <code>status="created"</code> in your payload the resulting tasks are not idempotent and creation will fail when the object was already created. However this is not the case with <code>status="deleted"</code> where such call to an non-existing object does not cause any failure whatsoever.</p> <p><strong>NOTE:</strong> A workaround is to avoid using <code>status="created"</code> and instead use <code>status="modified"</code> when idempotency is essential to your workflow..</p> </dd> <dt>Setting user password is not idempotent (<a class="reference external" href="https://github.com/ansible/ansible/issues/35544">#35544</a>)</dt>
<dd>
<p>Due to an inconsistency in the APIC REST API, a task that sets the password of a locally-authenticated user is not idempotent. The APIC will complain with message <code>Password history check: user dag should not use previous 5 passwords</code>.</p> <p><strong>NOTE:</strong> There is no workaround for this issue.</p> </dd> </dl>    <h2 id="aci-guide-community">ACI Ansible community</h2> <p id="aci-ansible-community">If you have specific issues with the ACI modules, or a feature request, or you like to contribute to the ACI project by proposing changes or documentation updates, look at the Ansible Community wiki ACI page at: <a class="reference external" href="https://github.com/ansible/community/wiki/Network:-ACI">https://github.com/ansible/community/wiki/Network:-ACI</a></p> <p>You will find our roadmap, an overview of open ACI issues and pull-requests, and more information about who we are. If you have an interest in using ACI with Ansible, feel free to join! We occasionally meet online to track progress and prepare for new Ansible releases.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://galaxy.ansible.com/cisco/aci">ACI collection on Ansible Galaxy</a></dt>
<dd>
<p>View the content tab for a complete list of supported ACI modules.</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general_aci.html#aci-dev-guide"><span class="std std-ref">Developing Cisco ACI modules</span></a></dt>
<dd>
<p>A walkthrough on how to develop new Cisco ACI modules to contribute back.</p> </dd> <dt><a class="reference external" href="https://github.com/ansible/community/wiki/Network:-ACI">ACI community</a></dt>
<dd>
<p>The Ansible ACI community wiki page, includes roadmap, ideas and development documentation.</p> </dd> <dt><a class="reference internal" href="../network/index.html#network-guide"><span class="std std-ref">Ansible for Network Automation</span></a></dt>
<dd>
<p>A detailed guide on how to use Ansible for automating network infrastructure.</p> </dd> <dt><a class="reference external" href="https://github.com/ansible/community/tree/master/group-network">Network Working Group</a></dt>
<dd>
<p>The Ansible Network community page, includes contact information and meeting information.</p> </dd> <dt>
<code>#ansible-network on</code> <a class="reference external" href="https://libera.chat/">irc.libera.chat</a>
</dt>
<dd>
<p>The #ansible-network IRC chat channel on libera.chat.</p> </dd> <dt><a class="reference external" href="https://groups.google.com/group/ansible-project">User Mailing List</a></dt>
<dd>
<p>Have a question? Stop by the google group!</p> </dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2021 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/scenario_guides/guide_aci.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/scenario_guides/guide_aci.html</a>
  </p>
</div>
