<section id="using-filters-to-manipulate-data"> <h1 id="playbooks-filters">Using filters to manipulate data</h1> <p>Filters let you transform JSON data into YAML data, split a URL to extract the hostname, get the SHA1 hash of a string, add or multiply integers, and much more. You can use the Ansible-specific filters documented here to manipulate your data, or use any of the standard filters shipped with Jinja2 - see the list of <a class="reference external" href="https://jinja.palletsprojects.com/en/3.1.x/templates/#builtin-filters" title="(in Jinja v3.1.x)"><span class="xref std std-ref">built-in filters</span></a> in the official Jinja2 template documentation. You can also use <a class="reference external" href="https://jinja.palletsprojects.com/en/3.1.x/templates/#python-methods" title="(in Jinja v3.1.x)"><span class="xref std std-ref">Python methods</span></a> to transform data. You can <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-filter-plugins"><span class="std std-ref">create custom Ansible filters as plugins</span></a>, though we generally welcome new filters into the ansible-core repo so everyone can use them.</p> <p>Because templating happens on the Ansible control node, <strong>not</strong> on the target host, filters execute on the control node and transform data locally.</p>  <ul class="simple"> <li>
<p><a class="reference internal" href="#handling-undefined-variables" id="id2">Handling undefined variables</a></p> <ul> <li><a class="reference internal" href="#providing-default-values" id="id3">Providing default values</a></li> <li><a class="reference internal" href="#making-variables-optional" id="id4">Making variables optional</a></li> <li><a class="reference internal" href="#defining-mandatory-values" id="id5">Defining mandatory values</a></li> </ul> </li> <li><a class="reference internal" href="#defining-different-values-for-true-false-null-ternary" id="id6">Defining different values for true/false/null (ternary)</a></li> <li>
<p><a class="reference internal" href="#managing-data-types" id="id7">Managing data types</a></p> <ul> <li><a class="reference internal" href="#discovering-the-data-type" id="id8">Discovering the data type</a></li> <li><a class="reference internal" href="#transforming-strings-into-lists" id="id9">Transforming strings into lists</a></li> <li><a class="reference internal" href="#transforming-dictionaries-into-lists" id="id10">Transforming dictionaries into lists</a></li> <li><a class="reference internal" href="#transforming-lists-into-dictionaries" id="id11">Transforming lists into dictionaries</a></li> <li><a class="reference internal" href="#forcing-the-data-type" id="id12">Forcing the data type</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#formatting-data-yaml-and-json" id="id13">Formatting data: YAML and JSON</a></p> <ul> <li><a class="reference internal" href="#filter-to-json-and-unicode-support" id="id14">Filter <code>to_json</code> and Unicode support</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#combining-and-selecting-data" id="id15">Combining and selecting data</a></p> <ul> <li><a class="reference internal" href="#combining-items-from-multiple-lists-zip-and-zip-longest" id="id16">Combining items from multiple lists: zip and zip_longest</a></li> <li><a class="reference internal" href="#combining-objects-and-subelements" id="id17">Combining objects and subelements</a></li> <li><a class="reference internal" href="#combining-hashes-dictionaries" id="id18">Combining hashes/dictionaries</a></li> <li><a class="reference internal" href="#selecting-values-from-arrays-or-hashtables" id="id19">Selecting values from arrays or hashtables</a></li> <li>
<p><a class="reference internal" href="#combining-lists" id="id20">Combining lists</a></p> <ul> <li><a class="reference internal" href="#permutations" id="id21">permutations</a></li> <li><a class="reference internal" href="#combinations" id="id22">combinations</a></li> <li><a class="reference internal" href="#products" id="id23">products</a></li> </ul> </li> <li><a class="reference internal" href="#selecting-json-data-json-queries" id="id24">Selecting JSON data: JSON queries</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#randomizing-data" id="id25">Randomizing data</a></p> <ul> <li><a class="reference internal" href="#random-mac-addresses" id="id26">Random MAC addresses</a></li> <li><a class="reference internal" href="#random-items-or-numbers" id="id27">Random items or numbers</a></li> <li><a class="reference internal" href="#shuffling-a-list" id="id28">Shuffling a list</a></li> </ul> </li> <li><a class="reference internal" href="#managing-list-variables" id="id29">Managing list variables</a></li> <li><a class="reference internal" href="#selecting-from-sets-or-lists-set-theory" id="id30">Selecting from sets or lists (set theory)</a></li> <li><a class="reference internal" href="#calculating-numbers-math" id="id31">Calculating numbers (math)</a></li> <li>
<p><a class="reference internal" href="#managing-network-interactions" id="id32">Managing network interactions</a></p> <ul> <li><a class="reference internal" href="#ip-address-filters" id="id33">IP address filters</a></li> <li><a class="reference internal" href="#network-cli-filters" id="id34">Network CLI filters</a></li> <li><a class="reference internal" href="#network-xml-filters" id="id35">Network XML filters</a></li> <li><a class="reference internal" href="#network-vlan-filters" id="id36">Network VLAN filters</a></li> </ul> </li> <li><a class="reference internal" href="#hashing-and-encrypting-strings-and-passwords" id="id37">Hashing and encrypting strings and passwords</a></li> <li>
<p><a class="reference internal" href="#manipulating-text" id="id38">Manipulating text</a></p> <ul> <li><a class="reference internal" href="#adding-comments-to-files" id="id39">Adding comments to files</a></li> <li><a class="reference internal" href="#urlencode-variables" id="id40">URLEncode Variables</a></li> <li><a class="reference internal" href="#splitting-urls" id="id41">Splitting URLs</a></li> <li><a class="reference internal" href="#searching-strings-with-regular-expressions" id="id42">Searching strings with regular expressions</a></li> <li><a class="reference internal" href="#managing-file-names-and-path-names" id="id43">Managing file names and path names</a></li> </ul> </li> <li><a class="reference internal" href="#manipulating-strings" id="id44">Manipulating strings</a></li> <li><a class="reference internal" href="#managing-uuids" id="id45">Managing UUIDs</a></li> <li><a class="reference internal" href="#handling-dates-and-times" id="id46">Handling dates and times</a></li> <li><a class="reference internal" href="#getting-kubernetes-resource-names" id="id47">Getting Kubernetes resource names</a></li> </ul>  <section id="handling-undefined-variables"> <h2>Handling undefined variables</h2> <p>Filters can help you manage missing or undefined variables by providing defaults or making some variables optional. If you configure Ansible to ignore most undefined variables, you can mark some variables as requiring values with the <code>mandatory</code> filter.</p> <section id="providing-default-values"> <h3 id="defaulting-undefined-variables">Providing default values</h3> <p>You can provide default values for variables directly in your templates using the Jinja2 ‘default’ filter. This is often a better approach than failing if a variable is not defined:</p> <pre data-language="yaml+jinja">{{ some_variable | default(5) }}
</pre> <p>In the above example, if the variable ‘some_variable’ is not defined, Ansible uses the default value 5, rather than raising an “undefined variable” error and failing. If you are working within a role, you can also add role defaults to define the default values for variables in your role. To learn more about role defaults see <a class="reference internal" href="playbooks_reuse_roles.html#role-directory-structure"><span class="std std-ref">Role directory structure</span></a>.</p> <p>Beginning in version 2.8, attempting to access an attribute of an Undefined value in Jinja will return another Undefined value, rather than throwing an error immediately. This means that you can now simply use a default with a value in a nested data structure (in other words, <code>{{ foo.bar.baz | default('DEFAULT') }}</code>) when you do not know if the intermediate values are defined.</p> <p>If you want to use the default value when variables evaluate to false or an empty string you have to set the second parameter to <code>true</code>:</p> <pre data-language="yaml+jinja">{{ lookup('env', 'MY_USER') | default('admin', true) }}
</pre> </section> <section id="making-variables-optional"> <h3 id="omitting-undefined-variables">Making variables optional</h3> <p>By default, Ansible requires values for all variables in a templated expression. However, you can make specific module variables optional. For example, you might want to use a system default for some items and control the value for others. To make a module variable optional, set the default value to the special variable <code>omit</code>:</p> <pre data-language="yaml+jinja">- name: Touch files with an optional mode
  ansible.builtin.file:
    dest: "{{ item.path }}"
    state: touch
    mode: "{{ item.mode | default(omit) }}"
  loop:
    - path: /tmp/foo
    - path: /tmp/bar
    - path: /tmp/baz
      mode: "0444"
</pre> <p>In this example, the default mode for the files <code>/tmp/foo</code> and <code>/tmp/bar</code> is determined by the umask of the system. Ansible does not send a value for <code>mode</code>. Only the third file, <code>/tmp/baz</code>, receives the <code>mode=0444</code> option.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you are “chaining” additional filters after the <code>default(omit)</code> filter, you should instead do something like this: <code>"{{ foo | default(None) | some_filter or omit }}"</code>. In this example, the default <code>None</code> (Python null) value will cause the later filters to fail, which will trigger the <code>or omit</code> portion of the logic. Using <code>omit</code> in this manner is very specific to the later filters you are chaining though, so be prepared for some trial and error if you do this.</p> </div> </section> <section id="defining-mandatory-values"> <h3 id="forcing-variables-to-be-defined">Defining mandatory values</h3> <p>If you configure Ansible to ignore undefined variables, you may want to define some values as mandatory. By default, Ansible fails if a variable in your playbook or command is undefined. You can configure Ansible to allow undefined variables by setting <a class="reference internal" href="../reference_appendices/config.html#default-undefined-var-behavior"><span class="std std-ref">DEFAULT_UNDEFINED_VAR_BEHAVIOR</span></a> to <code>false</code>. In that case, you may want to require some variables to be defined. You can do this with:</p> <pre data-language="yaml+jinja">{{ variable | mandatory }}
</pre> <p>The variable value will be used as is, but the template evaluation will raise an error if it is undefined.</p> <p>A convenient way of requiring a variable to be overridden is to give it an undefined value using the <a class="reference internal" href="playbooks_templating_undef.html#templating-undef"><span class="std std-ref">undef()</span></a> function.</p> <pre data-language="yaml+jinja">galaxy_url: "https://galaxy.ansible.com"
galaxy_api_key: "{{ undef(hint='You must specify your Galaxy API key') }}"
</pre> </section> </section> <section id="defining-different-values-for-true-false-null-ternary"> <h2>Defining different values for true/false/null (ternary)</h2> <p>You can create a test, then define one value to use when the test returns true and another when the test returns false (new in version 1.9):</p> <pre data-language="yaml+jinja">{{ (status == 'needs_restart') | ternary('restart', 'continue') }}
</pre> <p>In addition, you can define one value to use on true, one value on false and a third value on null (new in version 2.8):</p> <pre data-language="yaml+jinja">{{ enabled | ternary('no shutdown', 'shutdown', omit) }}
</pre> </section> <section id="managing-data-types"> <h2>Managing data types</h2> <p>You might need to know, change, or set the data type on a variable. For example, a registered variable might contain a dictionary when your next task needs a list, or a user <a class="reference internal" href="playbooks_prompts.html#playbooks-prompts"><span class="std std-ref">prompt</span></a> might return a string when your playbook needs a boolean value. Use the <a class="reference internal" href="../collections/ansible/builtin/type_debug_filter.html#ansible-collections-ansible-builtin-type-debug-filter"><span class="std std-ref">ansible.builtin.type_debug</span></a>, <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a>, and <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filters to manage data types. You can also use the data type itself to cast a value as a specific data type.</p> <section id="discovering-the-data-type"> <h3>Discovering the data type</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <p>If you are unsure of the underlying Python type of a variable, you can use the <a class="reference internal" href="../collections/ansible/builtin/type_debug_filter.html#ansible-collections-ansible-builtin-type-debug-filter"><span class="std std-ref">ansible.builtin.type_debug</span></a> filter to display it. This is useful in debugging when you need a particular type of variable:</p> <pre data-language="yaml+jinja">{{ myvar | type_debug }}
</pre> <p>You should note that, while this may seem like a useful filter for checking that you have the right type of data in a variable, you should often prefer <a class="reference internal" href="playbooks_tests.html#type-tests"><span class="std std-ref">type tests</span></a>, which will allow you to test for specific data types.</p> </section> <section id="transforming-strings-into-lists"> <h3>Transforming strings into lists</h3> <p>Use the <a class="reference internal" href="../collections/ansible/builtin/split_filter.html#ansible-collections-ansible-builtin-split-filter"><span class="std std-ref">ansible.builtin.split</span></a> filter to transform a character/string delimited string into a list of items suitable for <a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">looping</span></a>. For example, if you want to split a string variable <code>fruits</code> by commas, you can use:</p> <pre data-language="yaml+jinja">{{ fruits | split(',') }}
</pre> <p>String data (before applying the <a class="reference internal" href="../collections/ansible/builtin/split_filter.html#ansible-collections-ansible-builtin-split-filter"><span class="std std-ref">ansible.builtin.split</span></a> filter):</p> <pre data-language="yaml">fruits: apple,banana,orange
</pre> <p>List data (after applying the <a class="reference internal" href="../collections/ansible/builtin/split_filter.html#ansible-collections-ansible-builtin-split-filter"><span class="std std-ref">ansible.builtin.split</span></a> filter):</p> <pre data-language="yaml">- apple
- banana
- orange
</pre> </section> <section id="transforming-dictionaries-into-lists"> <h3 id="dict-filter">Transforming dictionaries into lists</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <p>Use the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter to transform a dictionary into a list of items suitable for <a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">looping</span></a>:</p> <pre data-language="yaml+jinja">{{ dict | dict2items }}
</pre> <p>Dictionary data (before applying the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter):</p> <pre data-language="yaml">tags:
  Application: payment
  Environment: dev
</pre> <p>List data (after applying the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter):</p> <pre data-language="yaml">- key: Application
  value: payment
- key: Environment
  value: dev
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> <p>The <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter is the reverse of the <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter.</p> <p>If you want to configure the names of the keys, the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter accepts 2 keyword arguments. Pass the <code><strong><a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter-parameter-key-name"><span class="std std-ref">key_name</span></a></strong></code> and <code><strong><a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter-parameter-value-name"><span class="std std-ref">value_name</span></a></strong></code> arguments to configure the names of the keys in the list output:</p> <pre data-language="yaml+jinja">{{ files | dict2items(key_name='file', value_name='path') }}
</pre> <p>Dictionary data (before applying the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter):</p> <pre data-language="yaml">files:
  users: /etc/passwd
  groups: /etc/group
</pre> <p>List data (after applying the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter):</p> <pre data-language="yaml">- file: users
  path: /etc/passwd
- file: groups
  path: /etc/group
</pre> </section> <section id="transforming-lists-into-dictionaries"> <h3>Transforming lists into dictionaries</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>Use the <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter to transform a list into a dictionary, mapping the content into <code>key: value</code> pairs:</p> <pre data-language="yaml+jinja">{{ tags | items2dict }}
</pre> <p>List data (before applying the <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter):</p> <pre data-language="yaml">tags:
  - key: Application
    value: payment
  - key: Environment
    value: dev
</pre> <p>Dictionary data (after applying the <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter):</p> <pre data-language="text">Application: payment
Environment: dev
</pre> <p>The <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter is the reverse of the <a class="reference internal" href="../collections/ansible/builtin/dict2items_filter.html#ansible-collections-ansible-builtin-dict2items-filter"><span class="std std-ref">ansible.builtin.dict2items</span></a> filter.</p> <p>Not all lists use <code>key</code> to designate keys and <code>value</code> to designate values. For example:</p> <pre data-language="yaml">fruits:
  - fruit: apple
    color: red
  - fruit: pear
    color: yellow
  - fruit: grapefruit
    color: yellow
</pre> <p>In this example, you must pass the <code><strong><a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter-parameter-key-name"><span class="std std-ref">key_name</span></a></strong></code> and <code><strong><a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter-parameter-value-name"><span class="std std-ref">value_name</span></a></strong></code> arguments to configure the transformation. For example:</p> <pre data-language="yaml+jinja">{{ fruits | items2dict(key_name='fruit', value_name='color') }}
</pre> <p>If you do not pass these arguments, or do not pass the correct values for your list, you will see <code>KeyError: key</code> or <code>KeyError: my_typo</code>.</p> </section> <section id="forcing-the-data-type"> <h3>Forcing the data type</h3> <p>You can cast values as certain types. For example, if you expect the input “True” from a <a class="reference internal" href="playbooks_prompts.html#playbooks-prompts"><span class="std std-ref">vars_prompt</span></a> and you want Ansible to recognize it as a boolean value instead of a string:</p> <pre data-language="yaml">- ansible.builtin.debug:
     msg: test
  when: some_string_value | bool
</pre> <p>If you want to perform a mathematical comparison on a fact and you want Ansible to recognize it as an integer instead of a string:</p> <pre data-language="yaml">- shell: echo "only on Red Hat 6, derivatives, and later"
  when: ansible_facts['os_family'] == "RedHat" and ansible_facts['lsb']['major_release'] | int &gt;= 6
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.</span></p> </div> </section> </section> <section id="formatting-data-yaml-and-json"> <h2 id="filters-for-formatting-data">Formatting data: YAML and JSON</h2> <p>You can switch a data structure in a template from or to JSON or YAML format, with options for formatting, indenting, and loading data. The basic filters are occasionally useful for debugging:</p> <pre data-language="yaml+jinja">{{ some_variable | to_json }}
{{ some_variable | to_yaml }}
</pre> <p>See <a class="reference internal" href="../collections/ansible/builtin/to_json_filter.html#ansible-collections-ansible-builtin-to-json-filter"><span class="std std-ref">ansible.builtin.to_json</span></a> and <a class="reference internal" href="../collections/ansible/builtin/to_yaml_filter.html#ansible-collections-ansible-builtin-to-yaml-filter"><span class="std std-ref">ansible.builtin.to_yaml</span></a> for documentation on these filters.</p> <p>For human readable output, you can use:</p> <pre data-language="yaml+jinja">{{ some_variable | to_nice_json }}
{{ some_variable | to_nice_yaml }}
</pre> <p>See <a class="reference internal" href="../collections/ansible/builtin/to_nice_json_filter.html#ansible-collections-ansible-builtin-to-nice-json-filter"><span class="std std-ref">ansible.builtin.to_nice_json</span></a> and <a class="reference internal" href="../collections/ansible/builtin/to_nice_yaml_filter.html#ansible-collections-ansible-builtin-to-nice-yaml-filter"><span class="std std-ref">ansible.builtin.to_nice_yaml</span></a> for documentation on these filters.</p> <p>You can change the indentation of either format:</p> <pre data-language="yaml+jinja">{{ some_variable | to_nice_json(indent=2) }}
{{ some_variable | to_nice_yaml(indent=8) }}
</pre> <p>The <a class="reference internal" href="../collections/ansible/builtin/to_yaml_filter.html#ansible-collections-ansible-builtin-to-yaml-filter"><span class="std std-ref">ansible.builtin.to_yaml</span></a> and <a class="reference internal" href="../collections/ansible/builtin/to_nice_yaml_filter.html#ansible-collections-ansible-builtin-to-nice-yaml-filter"><span class="std std-ref">ansible.builtin.to_nice_yaml</span></a> filters use the <a class="reference external" href="https://pyyaml.org/">PyYAML library</a> which has a default 80 symbol string length limit. That causes an unexpected line break after 80th symbol (if there is a space after 80th symbol) To avoid such behavior and generate long lines, use the <code><strong><span>width</span></strong></code> option. You must use a hardcoded number to define the width, instead of a construction like <code>float("inf")</code>, because the filter does not support proxying Python functions. For example:</p> <pre data-language="yaml+jinja">{{ some_variable | to_yaml(indent=8, width=1337) }}
{{ some_variable | to_nice_yaml(indent=8, width=1337) }}
</pre> <p>The filter does support passing through other YAML parameters. For a full list, see the <a class="reference external" href="https://pyyaml.org/wiki/PyYAMLDocumentation">PyYAML documentation</a> for <code>dump()</code>.</p> <p>If you are reading in some already formatted data:</p> <pre data-language="yaml+jinja">{{ some_variable | from_json }}
{{ some_variable | from_yaml }}
</pre> <p>for example:</p> <pre data-language="yaml+jinja">tasks:
  - name: Register JSON output as a variable
    ansible.builtin.shell: cat /some/path/to/file.json
    register: result

  - name: Set a variable
    ansible.builtin.set_fact:
      myvar: "{{ result.stdout | from_json }}"
</pre> <section id="filter-to-json-and-unicode-support"> <h3>Filter <code>to_json</code> and Unicode support</h3> <p>By default <a class="reference internal" href="../collections/ansible/builtin/to_json_filter.html#ansible-collections-ansible-builtin-to-json-filter"><span class="std std-ref">ansible.builtin.to_json</span></a> and <a class="reference internal" href="../collections/ansible/builtin/to_nice_json_filter.html#ansible-collections-ansible-builtin-to-nice-json-filter"><span class="std std-ref">ansible.builtin.to_nice_json</span></a> will convert data received to ASCII, so:</p> <pre data-language="yaml+jinja">{{ 'München'| to_json }}
</pre> <p>will return:</p> <pre data-language="text">'M\u00fcnchen'
</pre> <p>To keep Unicode characters, pass the parameter <code><a class="reference internal" href="../collections/ansible/builtin/to_json_filter.html#ansible-collections-ansible-builtin-to-json-filter-parameter-ensure-ascii"><span class="std std-ref">ensure_ascii=False</span></a></code> to the filter:</p> <pre data-language="yaml+jinja">{{ 'München'| to_json(ensure_ascii=False) }}

'München'
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>To parse multi-document YAML strings, the <a class="reference internal" href="../collections/ansible/builtin/from_yaml_all_filter.html#ansible-collections-ansible-builtin-from-yaml-all-filter"><span class="std std-ref">ansible.builtin.from_yaml_all</span></a> filter is provided. The <a class="reference internal" href="../collections/ansible/builtin/from_yaml_all_filter.html#ansible-collections-ansible-builtin-from-yaml-all-filter"><span class="std std-ref">ansible.builtin.from_yaml_all</span></a> filter will return a generator of parsed YAML documents.</p> <p>for example:</p> <pre data-language="yaml+jinja">tasks:
  - name: Register a file content as a variable
    ansible.builtin.shell: cat /some/path/to/multidoc-file.yaml
    register: result

  - name: Print the transformed variable
    ansible.builtin.debug:
      msg: '{{ item }}'
    loop: '{{ result.stdout | from_yaml_all | list }}'
</pre> </section> </section> <section id="combining-and-selecting-data"> <h2>Combining and selecting data</h2> <p>You can combine data from multiple sources and types, and select values from large data structures, giving you precise control over complex data.</p> <section id="combining-items-from-multiple-lists-zip-and-zip-longest"> <h3 id="zip-filter-example">Combining items from multiple lists: zip and zip_longest</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.3.</span></p> </div> <p>To get a list combining the elements of other lists use <a class="reference internal" href="../collections/ansible/builtin/zip_filter.html#ansible-collections-ansible-builtin-zip-filter"><span class="std std-ref">ansible.builtin.zip</span></a>:</p> <pre data-language="yaml+jinja">- name: Give me list combo of two lists
  ansible.builtin.debug:
    msg: "{{ [1,2,3,4,5,6] | zip(['a','b','c','d','e','f']) | list }}"

# =&gt; [[1, "a"], [2, "b"], [3, "c"], [4, "d"], [5, "e"], [6, "f"]]

- name: Give me the shortest combo of two lists
  ansible.builtin.debug:
    msg: "{{ [1,2,3] | zip(['a','b','c','d','e','f']) | list }}"

# =&gt; [[1, "a"], [2, "b"], [3, "c"]]
</pre> <p>To always exhaust all lists use <a class="reference internal" href="../collections/ansible/builtin/zip_longest_filter.html#ansible-collections-ansible-builtin-zip-longest-filter"><span class="std std-ref">ansible.builtin.zip_longest</span></a>:</p> <pre data-language="yaml+jinja">- name: Give me the longest combo of three lists, fill with X
  ansible.builtin.debug:
    msg: "{{ [1,2,3] | zip_longest(['a','b','c','d','e','f'], [21, 22, 23], fillvalue='X') | list }}"

# =&gt; [[1, "a", 21], [2, "b", 22], [3, "c", 23], ["X", "d", "X"], ["X", "e", "X"], ["X", "f", "X"]]
</pre> <p>Similarly to the output of the <a class="reference internal" href="../collections/ansible/builtin/items2dict_filter.html#ansible-collections-ansible-builtin-items2dict-filter"><span class="std std-ref">ansible.builtin.items2dict</span></a> filter mentioned above, these filters can be used to construct a <code>dict</code>:</p> <pre data-language="yaml+jinja">{{ dict(keys_list | zip(values_list)) }}
</pre> <p>List data (before applying the <a class="reference internal" href="../collections/ansible/builtin/zip_filter.html#ansible-collections-ansible-builtin-zip-filter"><span class="std std-ref">ansible.builtin.zip</span></a> filter):</p> <pre data-language="yaml">keys_list:
  - one
  - two
values_list:
  - apple
  - orange
</pre> <p>Dictionary data (after applying the <a class="reference internal" href="../collections/ansible/builtin/zip_filter.html#ansible-collections-ansible-builtin-zip-filter"><span class="std std-ref">ansible.builtin.zip</span></a> filter):</p> <pre data-language="yaml">one: apple
two: orange
</pre> </section> <section id="combining-objects-and-subelements"> <h3>Combining objects and subelements</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>The <a class="reference internal" href="../collections/ansible/builtin/subelements_filter.html#ansible-collections-ansible-builtin-subelements-filter"><span class="std std-ref">ansible.builtin.subelements</span></a> filter produces a product of an object and the subelement values of that object, similar to the <a class="reference internal" href="../collections/ansible/builtin/subelements_lookup.html#ansible-collections-ansible-builtin-subelements-lookup"><span class="std std-ref">ansible.builtin.subelements</span></a> lookup. This lets you specify individual subelements to use in a template. For example, this expression:</p> <pre data-language="yaml+jinja">{{ users | subelements('groups', skip_missing=True) }}
</pre> <p>Data before applying the <a class="reference internal" href="../collections/ansible/builtin/subelements_filter.html#ansible-collections-ansible-builtin-subelements-filter"><span class="std std-ref">ansible.builtin.subelements</span></a> filter:</p> <pre data-language="yaml">users:
- name: alice
  authorized:
  - /tmp/alice/onekey.pub
  - /tmp/alice/twokey.pub
  groups:
  - wheel
  - docker
- name: bob
  authorized:
  - /tmp/bob/id_rsa.pub
  groups:
  - docker
</pre> <p>Data after applying the <a class="reference internal" href="../collections/ansible/builtin/subelements_filter.html#ansible-collections-ansible-builtin-subelements-filter"><span class="std std-ref">ansible.builtin.subelements</span></a> filter:</p> <pre data-language="yaml">-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - wheel
-
  - name: alice
    groups:
    - wheel
    - docker
    authorized:
    - /tmp/alice/onekey.pub
    - /tmp/alice/twokey.pub
  - docker
-
  - name: bob
    authorized:
    - /tmp/bob/id_rsa.pub
    groups:
    - docker
  - docker
</pre> <p>You can use the transformed data with <code>loop</code> to iterate over the same subelement for multiple objects:</p> <pre data-language="yaml+jinja">- name: Set authorized ssh key, extracting just that data from 'users'
  ansible.posix.authorized_key:
    user: "{{ item.0.name }}"
    key: "{{ lookup('file', item.1) }}"
  loop: "{{ users | subelements('authorized') }}"
</pre> </section> <section id="combining-hashes-dictionaries"> <h3 id="combine-filter">Combining hashes/dictionaries</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> <p>The <a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter"><span class="std std-ref">ansible.builtin.combine</span></a> filter allows hashes to be merged. For example, the following would override keys in one hash:</p> <pre data-language="yaml+jinja">{{ {'a':1, 'b':2} | combine({'b':3}) }}
</pre> <p>The resulting hash would be:</p> <pre data-language="text">{'a':1, 'b':3}
</pre> <p>The filter can also take multiple arguments to merge:</p> <pre data-language="yaml+jinja">{{ a | combine(b, c, d) }}
{{ [a, b, c, d] | combine }}
</pre> <p>In this case, keys in <code>d</code> would override those in <code>c</code>, which would override those in <code>b</code>, and so on.</p> <p>The filter also accepts two optional parameters: <code><strong><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-recursive"><span class="std std-ref">recursive</span></a></strong></code> and <code><strong><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge</span></a></strong></code>.</p> <dl class="simple"> <dt>recursive</dt>
<dd>
<p>Is a boolean, default to <code>False</code>. Should the <a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter"><span class="std std-ref">ansible.builtin.combine</span></a> recursively merge nested hashes. Note: It does <strong>not</strong> depend on the value of the <code>hash_behaviour</code> setting in <code>ansible.cfg</code>.</p> </dd> <dt>list_merge</dt>
<dd>
<p>Is a string, its possible values are <code>replace</code> (default), <code>keep</code>, <code>append</code>, <code>prepend</code>, <code>append_rp</code> or <code>prepend_rp</code>. It modifies the behavior of <a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter"><span class="std std-ref">ansible.builtin.combine</span></a> when the hashes to merge contain arrays/lists.</p> </dd> </dl> <pre data-language="yaml">default:
  a:
    x: default
    y: default
  b: default
  c: default
patch:
  a:
    y: patch
    z: patch
  b: patch
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-recursive"><span class="std std-ref">recursive=False</span></a></code> (the default), nested hash aren’t merged:</p> <pre data-language="yaml+jinja">{{ default | combine(patch) }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  y: patch
  z: patch
b: patch
c: default
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-recursive"><span class="std std-ref">recursive=True</span></a></code>, recurse into a nested hash and merge their keys:</p> <pre data-language="yaml+jinja">{{ default | combine(patch, recursive=True) }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  x: default
  y: patch
  z: patch
b: patch
c: default
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='replace'</span></a></code> (the default), arrays from the right hash will “replace” the ones in the left hash:</p> <pre data-language="yaml">default:
  a:
    - default
patch:
  a:
    - patch
</pre> <pre data-language="yaml+jinja">{{ default | combine(patch) }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - patch
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='keep'</span></a></code>, arrays from the left hash will be kept:</p> <pre data-language="yaml+jinja">{{ default | combine(patch, list_merge='keep') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - default
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='append'</span></a></code>, arrays from the right hash will be appended to the ones in the left hash:</p> <pre data-language="yaml+jinja">{{ default | combine(patch, list_merge='append') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - default
  - patch
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='prepend'</span></a></code>, arrays from the right hash will be prepended to the ones in the left hash:</p> <pre data-language="yaml+jinja">{{ default | combine(patch, list_merge='prepend') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - patch
  - default
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='append_rp'</span></a></code>, arrays from the right hash will be appended to the ones in the left hash. Elements of arrays in the left hash that are also in the corresponding array of the right hash will be removed (“rp” stands for “remove present”). Duplicate elements that aren’t in both hashes are kept:</p> <pre data-language="yaml">default:
  a:
    - 1
    - 1
    - 2
    - 3
patch:
  a:
    - 3
    - 4
    - 5
    - 5
</pre> <pre data-language="yaml+jinja">{{ default | combine(patch, list_merge='append_rp') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - 1
  - 1
  - 2
  - 3
  - 4
  - 5
  - 5
</pre> <p>If <code><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge='prepend_rp'</span></a></code>, the behavior is similar to the one for <code>append_rp</code>, but elements of arrays in the right hash are prepended:</p> <pre data-language="yaml+jinja">{{ default | combine(patch, list_merge='prepend_rp') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  - 3
  - 4
  - 5
  - 5
  - 1
  - 1
  - 2
</pre> <p><code><strong><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-recursive"><span class="std std-ref">recursive</span></a></strong></code> and <code><strong><a class="reference internal" href="../collections/ansible/builtin/combine_filter.html#ansible-collections-ansible-builtin-combine-filter-parameter-list-merge"><span class="std std-ref">list_merge</span></a></strong></code> can be used together:</p> <pre data-language="yaml">default:
  a:
    a':
      x: default_value
      y: default_value
      list:
        - default_value
  b:
    - 1
    - 1
    - 2
    - 3
patch:
  a:
    a':
      y: patch_value
      z: patch_value
      list:
        - patch_value
  b:
    - 3
    - 4
    - 4
    - key: value
</pre> <pre data-language="yaml+jinja">{{ default | combine(patch, recursive=True, list_merge='append_rp') }}
</pre> <p>This would result in:</p> <pre data-language="yaml">a:
  a':
    x: default_value
    y: patch_value
    z: patch_value
    list:
      - default_value
      - patch_value
b:
  - 1
  - 1
  - 2
  - 3
  - 4
  - 4
  - key: value
</pre> </section> <section id="selecting-values-from-arrays-or-hashtables"> <h3 id="extract-filter">Selecting values from arrays or hashtables</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.1.</span></p> </div> <p>The <code>extract</code> filter is used to map from a list of indices to a list of values from a container (hash or array):</p> <pre data-language="yaml+jinja">{{ [0,2] | map('extract', ['x','y','z']) | list }}
{{ ['x','y'] | map('extract', {'x': 42, 'y': 31}) | list }}
</pre> <p>The results of the above expressions would be:</p> <pre data-language="none">['x', 'z']
[42, 31]
</pre> <p>The filter can take another argument:</p> <pre data-language="yaml+jinja">{{ groups['x'] | map('extract', hostvars, 'ec2_ip_address') | list }}
</pre> <p>This takes the list of hosts in group ‘x’, looks them up in <code>hostvars</code>, and then looks up the <code>ec2_ip_address</code> of the result. The final result is a list of IP addresses for the hosts in group ‘x’.</p> <p>The third argument to the filter can also be a list, for a recursive lookup inside the container:</p> <pre data-language="yaml+jinja">{{ ['a'] | map('extract', b, ['x','y']) | list }}
</pre> <p>This would return a list containing the value of <code>b[‘a’][‘x’][‘y’]</code>.</p> </section> <section id="combining-lists"> <h3>Combining lists</h3> <p>This set of filters returns a list of combined lists.</p> <section id="permutations"> <h4>permutations</h4> <p>To get permutations of a list:</p> <pre data-language="yaml+jinja">- name: Give me the largest permutations (order matters)
  ansible.builtin.debug:
    msg: "{{ [1,2,3,4,5] | ansible.builtin.permutations | list }}"

- name: Give me permutations of sets of three
  ansible.builtin.debug:
    msg: "{{ [1,2,3,4,5] | ansible.builtin.permutations(3) | list }}"
</pre> </section> <section id="combinations"> <h4>combinations</h4> <p>Combinations always require a set size:</p> <pre data-language="yaml+jinja">- name: Give me combinations for sets of two
  ansible.builtin.debug:
    msg: "{{ [1,2,3,4,5] | ansible.builtin.combinations(2) | list }}"
</pre> <p>Also see the <a class="reference external" href="https://docs.ansible.com/ansible/9/collections/ansible/builtin/zip_filter.html#zip-filter" title="(in Ansible v9)"><span class="xref std std-ref">zip_filter</span></a></p> </section> <section id="products"> <h4>products</h4> <p>The product filter returns the <a class="reference external" href="https://docs.python.org/3/library/itertools.html#itertools.product">cartesian product</a> of the input iterables. This is roughly equivalent to nested for-loops in a generator expression.</p> <p>For example:</p> <pre data-language="yaml+jinja">- name: Generate multiple hostnames
  ansible.builtin.debug:
    msg: "{{ ['foo', 'bar'] | product(['com']) | map('join', '.') | join(',') }}"
</pre> <p>This would result in:</p> <pre data-language="json">{ "msg": "foo.com,bar.com" }
</pre> </section> </section> <section id="selecting-json-data-json-queries"> <h3>Selecting JSON data: JSON queries</h3> <p>To select a single element or a data subset from a complex data structure in JSON format (for example, Ansible facts), use the <a class="reference internal" href="../collections/community/general/json_query_filter.html#ansible-collections-community-general-json-query-filter"><span class="std std-ref">community.general.json_query</span></a> filter. The <a class="reference internal" href="../collections/community/general/json_query_filter.html#ansible-collections-community-general-json-query-filter"><span class="std std-ref">community.general.json_query</span></a> filter lets you query a complex JSON structure and iterate over it using a loop structure.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This filter has migrated to the <a class="reference external" href="https://galaxy.ansible.com/community/general">community.general</a> collection. Follow the installation instructions to install that collection.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You must manually install the <strong>jmespath</strong> dependency on the Ansible control node before using this filter. This filter is built upon <strong>jmespath</strong>, and you can use the same syntax. For examples, see <a class="reference external" href="https://jmespath.org/examples.html">jmespath examples</a>.</p> </div> <p>Consider this data structure:</p> <pre data-language="json">{
    "domain": {
        "cluster": [
            {
                "name": "cluster1"
            },
            {
                "name": "cluster2"
            }
        ],
        "server": [
            {
                "name": "server11",
                "cluster": "cluster1",
                "port": "8080"
            },
            {
                "name": "server12",
                "cluster": "cluster1",
                "port": "8090"
            },
            {
                "name": "server21",
                "cluster": "cluster2",
                "port": "9080"
            },
            {
                "name": "server22",
                "cluster": "cluster2",
                "port": "9090"
            }
        ],
        "library": [
            {
                "name": "lib1",
                "target": "cluster1"
            },
            {
                "name": "lib2",
                "target": "cluster2"
            }
        ]
    }
}
</pre> <p>To extract all clusters from this structure, you can use the following query:</p> <pre data-language="yaml+jinja">- name: Display all cluster names
  ansible.builtin.debug:
    var: item
  loop: "{{ domain_definition | community.general.json_query('domain.cluster[*].name') }}"
</pre> <p>To extract all server names:</p> <pre data-language="yaml+jinja">- name: Display all server names
  ansible.builtin.debug:
    var: item
  loop: "{{ domain_definition | community.general.json_query('domain.server[*].name') }}"
</pre> <p>To extract ports from cluster1:</p> <pre data-language="yaml+jinja">- name: Display all ports from cluster1
  ansible.builtin.debug:
    var: item
  loop: "{{ domain_definition | community.general.json_query(server_name_cluster1_query) }}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster1'].port"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>You can use a variable to make the query more readable.</p> </div> <p>To print out the ports from cluster1 in a comma-separated string:</p> <pre data-language="yaml+jinja">- name: Display all ports from cluster1 as a string
  ansible.builtin.debug:
    msg: "{{ domain_definition | community.general.json_query('domain.server[?cluster==`cluster1`].port') | join(', ') }}"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>In the example above, quoting literals using backticks avoids escaping quotes and maintains readability.</p> </div> <p>You can use YAML <a class="reference external" href="https://yaml.org/spec/current.html#id2534365">single quote escaping</a>:</p> <pre data-language="yaml+jinja">- name: Display all ports from cluster1
  ansible.builtin.debug:
    var: item
  loop: "{{ domain_definition | community.general.json_query('domain.server[?cluster==''cluster1''].port') }}"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Escaping single quotes within single quotes in YAML is done by doubling the single quote.</p> </div> <p>To get a hash map with all ports and names of a cluster:</p> <pre data-language="yaml+jinja">- name: Display all server ports and names from cluster1
  ansible.builtin.debug:
    var: item
  loop: "{{ domain_definition | community.general.json_query(server_name_cluster1_query) }}"
  vars:
    server_name_cluster1_query: "domain.server[?cluster=='cluster1'].{name: name, port: port}"
</pre> <p>To extract ports from all clusters with the name starting with ‘server1’:</p> <pre data-language="yaml+jinja">- name: Display ports from all clusters with the name starting with 'server1'
  ansible.builtin.debug:
    msg: "{{ domain_definition | to_json | from_json | community.general.json_query(server_name_query) }}"
  vars:
    server_name_query: "domain.server[?starts_with(name,'server1')].port"
</pre> <p>To extract ports from all clusters with the name containing ‘server1’:</p> <pre data-language="yaml+jinja">- name: Display ports from all clusters with the name containing 'server1'
  ansible.builtin.debug:
    msg: "{{ domain_definition | to_json | from_json | community.general.json_query(server_name_query) }}"
  vars:
    server_name_query: "domain.server[?contains(name,'server1')].port"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>while using <code>starts_with</code> and <code>contains</code>, you have to use `` to_json | from_json `` filter for correct parsing of data structure.</p> </div> </section> </section> <section id="randomizing-data"> <h2>Randomizing data</h2> <p>When you need a randomly generated value, use one of these filters.</p> <section id="random-mac-addresses"> <h3 id="random-mac-filter">Random MAC addresses</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <p>This filter can be used to generate a random MAC address from a string prefix.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This filter has migrated to the <a class="reference external" href="https://galaxy.ansible.com/community/general">community.general</a> collection. Follow the installation instructions to install that collection.</p> </div> <p>To get a random MAC address from a string prefix starting with ‘52:54:00’:</p> <pre data-language="yaml+jinja">"{{ '52:54:00' | community.general.random_mac }}"
# =&gt; '52:54:00:ef:1c:03'
</pre> <p>Note that if anything is wrong with the prefix string, the filter will issue an error.</p>  <div class="versionadded"> <p><span class="versionmodified added">New in version 2.9.</span></p> </div>  <p>As of Ansible version 2.9, you can also initialize the random number generator from a seed to create random-but-idempotent MAC addresses:</p> <pre data-language="yaml+jinja">"{{ '52:54:00' | community.general.random_mac(seed=inventory_hostname) }}"
</pre> </section> <section id="random-items-or-numbers"> <h3 id="random-filter-example">Random items or numbers</h3> <p>The <a class="reference internal" href="../collections/ansible/builtin/random_filter.html#ansible-collections-ansible-builtin-random-filter"><span class="std std-ref">ansible.builtin.random</span></a> filter in Ansible is an extension of the default Jinja2 random filter, and can be used to return a random item from a sequence of items or to generate a random number based on a range.</p> <p>To get a random item from a list:</p> <pre data-language="yaml+jinja">"{{ ['a','b','c'] | random }}"
# =&gt; 'c'
</pre> <p>To get a random number between 0 (inclusive) and a specified integer (exclusive):</p> <pre data-language="yaml+jinja">"{{ 60 | random }} * * * * root /script/from/cron"
# =&gt; '21 * * * * root /script/from/cron'
</pre> <p>To get a random number from 0 to 100 but in steps of 10:</p> <pre data-language="yaml+jinja">{{ 101 | random(step=10) }}
# =&gt; 70
</pre> <p>To get a random number from 1 to 100 but in steps of 10:</p> <pre data-language="yaml+jinja">{{ 101 | random(1, 10) }}
# =&gt; 31
{{ 101 | random(start=1, step=10) }}
# =&gt; 51
</pre> <p>You can initialize the random number generator from a seed to create random-but-idempotent numbers:</p> <pre data-language="yaml+jinja">"{{ 60 | random(seed=inventory_hostname) }} * * * * root /script/from/cron"
</pre> </section> <section id="shuffling-a-list"> <h3>Shuffling a list</h3> <p>The <a class="reference internal" href="../collections/ansible/builtin/shuffle_filter.html#ansible-collections-ansible-builtin-shuffle-filter"><span class="std std-ref">ansible.builtin.shuffle</span></a> filter randomizes an existing list, giving a different order for every invocation.</p> <p>To get a random list from an existing list:</p> <pre data-language="yaml+jinja">{{ ['a','b','c'] | shuffle }}
# =&gt; ['c','a','b']
{{ ['a','b','c'] | shuffle }}
# =&gt; ['b','c','a']
</pre> <p>You can initialize the shuffle generator from a seed to generate a random-but-idempotent order:</p> <pre data-language="yaml+jinja">{{ ['a','b','c'] | shuffle(seed=inventory_hostname) }}
# =&gt; ['b','a','c']
</pre> <p>The shuffle filter returns a list whenever possible. If you use it with a non ‘listable’ item, the filter does nothing.</p> </section> </section> <section id="managing-list-variables"> <h2 id="list-filters">Managing list variables</h2> <p>You can search for the minimum or maximum value in a list, or flatten a multi-level list.</p> <p>To get the minimum value from the list of numbers:</p> <pre data-language="yaml+jinja">{{ list1 | min }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.</span></p> </div> <p>To get the minimum value in a list of objects:</p> <pre data-language="yaml+jinja">{{ [{'val': 1}, {'val': 2}] | min(attribute='val') }}
</pre> <p>To get the maximum value from a list of numbers:</p> <pre data-language="yaml+jinja">{{ [3, 4, 2] | max }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.</span></p> </div> <p>To get the maximum value in a list of objects:</p> <pre data-language="yaml+jinja">{{ [{'val': 1}, {'val': 2}] | max(attribute='val') }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> <p>Flatten a list (same thing the <code>flatten</code> lookup does):</p> <pre data-language="yaml+jinja">{{ [3, [4, 2] ] | flatten }}
# =&gt; [3, 4, 2]
</pre> <p>Flatten only the first level of a list (akin to the <code>items</code> lookup):</p> <pre data-language="yaml+jinja">{{ [3, [4, [2]] ] | flatten(levels=1) }}
# =&gt; [3, 4, [2]]
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.</span></p> </div> <p>Preserve nulls in a list, by default flatten removes them. :</p> <pre data-language="yaml+jinja">{{ [3, None, [4, [2]] ] | flatten(levels=1, skip_nulls=False) }}
# =&gt; [3, None, 4, [2]]
</pre> </section> <section id="selecting-from-sets-or-lists-set-theory"> <h2 id="set-theory-filters">Selecting from sets or lists (set theory)</h2> <p>You can select or combine items from sets or lists.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.4.</span></p> </div> <p>To get a unique set from a list:</p> <pre data-language="yaml+jinja"># list1: [1, 2, 5, 1, 3, 4, 10]
{{ list1 | unique }}
# =&gt; [1, 2, 5, 3, 4, 10]
</pre> <p>To get a union of two lists:</p> <pre data-language="yaml+jinja"># list1: [1, 2, 5, 1, 3, 4, 10]
# list2: [1, 2, 3, 4, 5, 11, 99]
{{ list1 | union(list2) }}
# =&gt; [1, 2, 5, 1, 3, 4, 10, 11, 99]
</pre> <p>To get the intersection of 2 lists (unique list of all items in both):</p> <pre data-language="yaml+jinja"># list1: [1, 2, 5, 3, 4, 10]
# list2: [1, 2, 3, 4, 5, 11, 99]
{{ list1 | intersect(list2) }}
# =&gt; [1, 2, 5, 3, 4]
</pre> <p>To get the difference of 2 lists (items in 1 that don’t exist in 2):</p> <pre data-language="yaml+jinja"># list1: [1, 2, 5, 1, 3, 4, 10]
# list2: [1, 2, 3, 4, 5, 11, 99]
{{ list1 | difference(list2) }}
# =&gt; [10]
</pre> <p>To get the symmetric difference of 2 lists (items exclusive to each list):</p> <pre data-language="yaml+jinja"># list1: [1, 2, 5, 1, 3, 4, 10]
# list2: [1, 2, 3, 4, 5, 11, 99]
{{ list1 | symmetric_difference(list2) }}
# =&gt; [10, 11, 99]
</pre> </section> <section id="calculating-numbers-math"> <h2 id="math-stuff">Calculating numbers (math)</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.</span></p> </div> <p>You can calculate logs, powers, and roots of numbers with Ansible filters. Jinja2 provides other mathematical functions like abs() and round().</p> <p>Get the logarithm (default is e):</p> <pre data-language="yaml+jinja">{{ 8 | log }}
# =&gt; 2.0794415416798357
</pre> <p>Get the base 10 logarithm:</p> <pre data-language="yaml+jinja">{{ 8 | log(10) }}
# =&gt; 0.9030899869919435
</pre> <p>Give me the power of 2! (or 5):</p> <pre data-language="yaml+jinja">{{ 8 | pow(5) }}
# =&gt; 32768.0
</pre> <p>Square root, or the 5th:</p> <pre data-language="yaml+jinja">{{ 8 | root }}
# =&gt; 2.8284271247461903

{{ 8 | root(5) }}
# =&gt; 1.5157165665103982
</pre> </section> <section id="managing-network-interactions"> <h2>Managing network interactions</h2> <p>These filters help you with common network tasks.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These filters have migrated to the <a class="reference external" href="https://galaxy.ansible.com/ansible/utils">ansible.utils</a> collection. Follow the installation instructions to install that collection.</p> </div> <section id="ip-address-filters"> <h3 id="ipaddr-filter">IP address filters</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.</span></p> </div> <p>To test if a string is a valid IP address:</p> <pre data-language="yaml+jinja">{{ myvar | ansible.utils.ipaddr }}
</pre> <p>You can also require a specific IP protocol version:</p> <pre data-language="yaml+jinja">{{ myvar | ansible.utils.ipv4 }}
{{ myvar | ansible.utils.ipv6 }}
</pre> <p>IP address filter can also be used to extract specific information from an IP address. For example, to get the IP address itself from a CIDR, you can use:</p> <pre data-language="yaml+jinja">{{ '192.0.2.1/24' | ansible.utils.ipaddr('address') }}
# =&gt; 192.0.2.1
</pre> <p>More information about <a class="reference internal" href="../collections/ansible/utils/ipaddr_filter.html#ansible-collections-ansible-utils-ipaddr-filter"><span class="std std-ref">ansible.utils.ipaddr</span></a> filter and complete usage guide can be found in <a class="reference internal" href="../collections/ansible/utils/index.html#plugins-in-ansible-utils"><span class="std std-ref">Ansible.Utils</span></a>.</p> </section> <section id="network-cli-filters"> <h3 id="network-filters">Network CLI filters</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> <p>To convert the output of a network device CLI command into structured JSON output, use the <a class="reference internal" href="../collections/ansible/netcommon/parse_cli_filter.html#ansible-collections-ansible-netcommon-parse-cli-filter"><span class="std std-ref">ansible.netcommon.parse_cli</span></a> filter:</p> <pre data-language="yaml+jinja">{{ output | ansible.netcommon.parse_cli('path/to/spec') }}
</pre> <p>The <a class="reference internal" href="../collections/ansible/netcommon/parse_cli_filter.html#ansible-collections-ansible-netcommon-parse-cli-filter"><span class="std std-ref">ansible.netcommon.parse_cli</span></a> filter will load the spec file and pass the command output through it, returning JSON output. The YAML spec file defines how to parse the CLI output.</p> <p>The spec file should be valid formatted YAML. It defines how to parse the CLI output and return JSON data. Below is an example of a valid spec file that will parse the output from the <code>show vlan</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    vlan_id: "{{ item.vlan_id }}"
    name: "{{ item.name }}"
    enabled: "{{ item.state != 'act/lshut' }}"
    state: "{{ item.state }}"

keys:
  vlans:
    value: "{{ vlan }}"
    items: "^(?P&lt;vlan_id&gt;\\d+)\\s+(?P&lt;name&gt;\\w+)\\s+(?P&lt;state&gt;active|act/lshut|suspended)"
  state_static:
    value: present
</pre> <p>The spec file above will return a JSON data structure that is a list of hashes with the parsed VLAN information.</p> <p>The same command could be parsed into a hash by using the key and values directives. Here is an example of how to parse the output into a hash value using the same <code>show vlan</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    key: "{{ item.vlan_id }}"
    values:
      vlan_id: "{{ item.vlan_id }}"
      name: "{{ item.name }}"
      enabled: "{{ item.state != 'act/lshut' }}"
      state: "{{ item.state }}"

keys:
  vlans:
    value: "{{ vlan }}"
    items: "^(?P&lt;vlan_id&gt;\\d+)\\s+(?P&lt;name&gt;\\w+)\\s+(?P&lt;state&gt;active|act/lshut|suspended)"
  state_static:
    value: present
</pre> <p>Another common use case for parsing CLI commands is to break a large command into blocks that can be parsed. This can be done using the <code>start_block</code> and <code>end_block</code> directives to break the command into blocks that can be parsed.</p> <pre data-language="yaml">---
vars:
  interface:
    name: "{{ item[0].match[0] }}"
    state: "{{ item[1].state }}"
    mode: "{{ item[2].match[0] }}"

keys:
  interfaces:
    value: "{{ interface }}"
    start_block: "^Ethernet.*$"
    end_block: "^$"
    items:
      - "^(?P&lt;name&gt;Ethernet\\d\\/\\d*)"
      - "admin state is (?P&lt;state&gt;.+),"
      - "Port mode is (.+)"
</pre> <p>The example above will parse the output of <code>show interface</code> into a list of hashes.</p> <p>The network filters also support parsing the output of a CLI command using the TextFSM library. To parse the CLI output with TextFSM use the following filter:</p> <pre data-language="yaml+jinja">{{ output.stdout[0] | ansible.netcommon.parse_cli_textfsm('path/to/fsm') }}
</pre> <p>Use of the TextFSM filter requires the TextFSM library to be installed.</p> </section> <section id="network-xml-filters"> <h3>Network XML filters</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.5.</span></p> </div> <p>To convert the XML output of a network device command into structured JSON output, use the <a class="reference internal" href="../collections/ansible/netcommon/parse_xml_filter.html#ansible-collections-ansible-netcommon-parse-xml-filter"><span class="std std-ref">ansible.netcommon.parse_xml</span></a> filter:</p> <pre data-language="yaml+jinja">{{ output | ansible.netcommon.parse_xml('path/to/spec') }}
</pre> <p>The <a class="reference internal" href="../collections/ansible/netcommon/parse_xml_filter.html#ansible-collections-ansible-netcommon-parse-xml-filter"><span class="std std-ref">ansible.netcommon.parse_xml</span></a> filter will load the spec file and pass the command output through formatted as JSON.</p> <p>The spec file should be valid formatted YAML. It defines how to parse the XML output and return JSON data.</p> <p>Below is an example of a valid spec file that will parse the output from the <code>show vlan | display xml</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    vlan_id: "{{ item.vlan_id }}"
    name: "{{ item.name }}"
    desc: "{{ item.desc }}"
    enabled: "{{ item.state.get('inactive') != 'inactive' }}"
    state: "{% if item.state.get('inactive') == 'inactive'%} inactive {% else %} active {% endif %}"

keys:
  vlans:
    value: "{{ vlan }}"
    top: configuration/vlans/vlan
    items:
      vlan_id: vlan-id
      name: name
      desc: description
      state: ".[@inactive='inactive']"
</pre> <p>The spec file above will return a JSON data structure that is a list of hashes with the parsed VLAN information.</p> <p>The same command could be parsed into a hash by using the key and values directives. Here is an example of how to parse the output into a hash value using the same <code>show vlan | display xml</code> command.</p> <pre data-language="yaml">---
vars:
  vlan:
    key: "{{ item.vlan_id }}"
    values:
        vlan_id: "{{ item.vlan_id }}"
        name: "{{ item.name }}"
        desc: "{{ item.desc }}"
        enabled: "{{ item.state.get('inactive') != 'inactive' }}"
        state: "{% if item.state.get('inactive') == 'inactive'%} inactive {% else %} active {% endif %}"

keys:
  vlans:
    value: "{{ vlan }}"
    top: configuration/vlans/vlan
    items:
      vlan_id: vlan-id
      name: name
      desc: description
      state: ".[@inactive='inactive']"
</pre> <p>The value of <code>top</code> is the XPath relative to the XML root node. In the example, XML output given below, the value of <code>top</code> is <code>configuration/vlans/vlan</code>, which is an XPath expression relative to the root node (&lt;rpc-reply&gt;). <code>configuration</code> in the value of <code>top</code> is the outermost container node, and <code>vlan</code> is the innermost container node.</p> <p><code>items</code> is a dictionary of key-value pairs that map user-defined names to XPath expressions that select elements. The Xpath expression is relative to the value of the XPath value contained in <code>top</code>. For example, the <code>vlan_id</code> in the spec file is a user-defined name and its value <code>vlan-id</code> is the relative to the value of XPath in <code>top</code></p> <p>Attributes of XML tags can be extracted using XPath expressions. The value of <code>state</code> in the spec is an XPath expression used to get the attributes of the <code>vlan</code> tag in output XML.:</p> <pre data-language="none">&lt;rpc-reply&gt;
  &lt;configuration&gt;
    &lt;vlans&gt;
      &lt;vlan inactive="inactive"&gt;
       &lt;name&gt;vlan-1&lt;/name&gt;
       &lt;vlan-id&gt;200&lt;/vlan-id&gt;
       &lt;description&gt;This is vlan-1&lt;/description&gt;
      &lt;/vlan&gt;
    &lt;/vlans&gt;
  &lt;/configuration&gt;
&lt;/rpc-reply&gt;
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For more information on supported XPath expressions, see <a class="reference external" href="https://docs.python.org/3/library/xml.etree.elementtree.html#xpath-support">XPath Support</a>.</p> </div> </section> <section id="network-vlan-filters"> <h3>Network VLAN filters</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> <p>Use the <a class="reference internal" href="../collections/ansible/netcommon/vlan_parser_filter.html#ansible-collections-ansible-netcommon-vlan-parser-filter"><span class="std std-ref">ansible.netcommon.vlan_parser</span></a> filter to transform an unsorted list of VLAN integers into a sorted string list of integers according to IOS-like VLAN list rules. This list has the following properties:</p> <ul class="simple"> <li>Vlans are listed in ascending order.</li> <li>Three or more consecutive VLANs are listed with a dash.</li> <li>The first line of the list can be first_line_len characters long.</li> <li>Subsequent list lines can be other_line_len characters.</li> </ul> <p>To sort a VLAN list:</p> <pre data-language="yaml+jinja">{{ [3003, 3004, 3005, 100, 1688, 3002, 3999] | ansible.netcommon.vlan_parser }}
</pre> <p>This example renders the following sorted list:</p> <pre data-language="text">['100,1688,3002-3005,3999']
</pre> <p>Another example Jinja template:</p> <pre data-language="yaml+jinja">{% set parsed_vlans = vlans | ansible.netcommon.vlan_parser %}
switchport trunk allowed vlan {{ parsed_vlans[0] }}
{% for i in range (1, parsed_vlans | count) %}
switchport trunk allowed vlan add {{ parsed_vlans[i] }}
{% endfor %}
</pre> <p>This allows for the dynamic generation of VLAN lists on a Cisco IOS tagged interface. You can store an exhaustive raw list of the exact VLANs required for an interface and then compare that to the parsed IOS output that would actually be generated for the configuration.</p> </section> </section> <section id="hashing-and-encrypting-strings-and-passwords"> <h2 id="hash-filters">Hashing and encrypting strings and passwords</h2> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.</span></p> </div> <p>To get the sha1 hash of a string:</p> <pre data-language="yaml+jinja">{{ 'test1' | hash('sha1') }}
# =&gt; "b444ac06613fc8d63795be9ad0beaf55011936ac"
</pre> <p>To get the md5 hash of a string:</p> <pre data-language="yaml+jinja">{{ 'test1' | hash('md5') }}
# =&gt; "5a105e8b9d40e1329780d62ea2265d8a"
</pre> <p>Get a string checksum:</p> <pre data-language="yaml+jinja">{{ 'test2' | checksum }}
# =&gt; "109f4b3c50d7b0df729d299bc6f8e9ef9066971f"
</pre> <p>Other hashes (platform dependent):</p> <pre data-language="yaml+jinja">{{ 'test2' | hash('blowfish') }}
</pre> <p>To get a sha512 password hash (random salt):</p> <pre data-language="yaml+jinja">{{ 'passwordsaresecret' | password_hash('sha512') }}
# =&gt; "$6$UIv3676O/ilZzWEE$ktEfFF19NQPF2zyxqxGkAceTnbEgpEKuGBtk6MlU4v2ZorWaVQUMyurgmHCh2Fr4wpmQ/Y.AlXMJkRnIS4RfH/"
</pre> <p>To get a sha256 password hash with a specific salt:</p> <pre data-language="yaml+jinja">{{ 'secretpassword' | password_hash('sha256', 'mysecretsalt') }}
# =&gt; "$5$mysecretsalt$ReKNyDYjkKNqRVwouShhsEqZ3VOE8eoVO4exihOfvG4"
</pre> <p>An idempotent method to generate unique hashes per system is to use a salt that is consistent between runs:</p> <pre data-language="yaml+jinja">{{ 'secretpassword' | password_hash('sha512', 65534 | random(seed=inventory_hostname) | string) }}
# =&gt; "$6$43927$lQxPKz2M2X.NWO.gK.t7phLwOKQMcSq72XxDZQ0XzYV6DlL1OD72h417aj16OnHTGxNzhftXJQBcjbunLEepM0"
</pre> <p>Hash types available depend on the control system running Ansible, <a class="reference internal" href="../collections/ansible/builtin/hash_filter.html#ansible-collections-ansible-builtin-hash-filter"><span class="std std-ref">ansible.builtin.hash</span></a> depends on <a class="reference external" href="https://docs.python.org/3.8/library/hashlib.html">hashlib</a>, <a class="reference internal" href="../collections/ansible/builtin/password_hash_filter.html#ansible-collections-ansible-builtin-password-hash-filter"><span class="std std-ref">ansible.builtin.password_hash</span></a> depends on <a class="reference external" href="https://passlib.readthedocs.io/en/stable/lib/passlib.hash.html">passlib</a>. The <a class="reference external" href="https://docs.python.org/3.8/library/crypt.html">crypt</a> is used as a fallback if <code>passlib</code> is not installed.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.7.</span></p> </div> <p>Some hash types allow providing a rounds parameter:</p> <pre data-language="yaml+jinja">{{ 'secretpassword' | password_hash('sha256', 'mysecretsalt', rounds=10000) }}
# =&gt; "$5$rounds=10000$mysecretsalt$Tkm80llAxD4YHll6AgNIztKn0vzAACsuuEfYeGP7tm7"
</pre> <p>The filter <code>password_hash</code> produces different results depending on whether you installed <code>passlib</code> or not.</p> <p>To ensure idempotency, specify <code>rounds</code> to be neither <code>crypt</code>’s nor <code>passlib</code>’s default, which is <code>5000</code> for <code>crypt</code> and a variable value (<code>535000</code> for sha256, <code>656000</code> for sha512) for <code>passlib</code>:</p> <pre data-language="yaml+jinja">{{ 'secretpassword' | password_hash('sha256', 'mysecretsalt', rounds=5001) }}
# =&gt; "$5$rounds=5001$mysecretsalt$wXcTWWXbfcR8er5IVf7NuquLvnUA6s8/qdtOhAZ.xN."
</pre> <p>Hash type ‘blowfish’ (BCrypt) provides the facility to specify the version of the BCrypt algorithm.</p> <pre data-language="yaml+jinja">{{ 'secretpassword' | password_hash('blowfish', '1234567890123456789012', ident='2b') }}
# =&gt; "$2b$12$123456789012345678901uuJ4qFdej6xnWjOQT.FStqfdoY8dYUPC"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The parameter is only available for <a class="reference external" href="https://passlib.readthedocs.io/en/stable/lib/passlib.hash.bcrypt.html#passlib.hash.bcrypt">blowfish (BCrypt)</a>. Other hash types will simply ignore this parameter. Valid values for this parameter are: [‘2’, ‘2a’, ‘2y’, ‘2b’]</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.12.</span></p> </div> <p>You can also use the Ansible <a class="reference internal" href="../collections/ansible/builtin/vault_filter.html#ansible-collections-ansible-builtin-vault-filter"><span class="std std-ref">ansible.builtin.vault</span></a> filter to encrypt data:</p> <pre data-language="yaml+jinja"># simply encrypt my key in a vault
vars:
  myvaultedkey: "{{ keyrawdata|vault(passphrase) }}"

- name: save templated vaulted data
  template: src=dump_template_data.j2 dest=/some/key/vault.txt
  vars:
    mysalt: '{{ 2**256|random(seed=inventory_hostname) }}'
    template_data: '{{ secretdata|vault(vaultsecret, salt=mysalt) }}'
</pre> <p>And then decrypt it using the unvault filter:</p> <pre data-language="yaml+jinja"># simply decrypt my key from a vault
vars:
  mykey: "{{ myvaultedkey|unvault(passphrase) }}"

- name: save templated unvaulted data
  template: src=dump_template_data.j2 dest=/some/key/clear.txt
  vars:
    template_data: '{{ secretdata|unvault(vaultsecret) }}'
</pre> </section> <section id="manipulating-text"> <h2 id="other-useful-filters">Manipulating text</h2> <p>Several filters work with text, including URLs, file names, and path names.</p> <section id="adding-comments-to-files"> <h3 id="comment-filter">Adding comments to files</h3> <p>The <a class="reference internal" href="../collections/ansible/builtin/comment_filter.html#ansible-collections-ansible-builtin-comment-filter"><span class="std std-ref">ansible.builtin.comment</span></a> filter lets you create comments in a file from text in a template, with a variety of comment styles. By default, Ansible uses <code>#</code> to start a comment line and adds a blank comment line above and below your comment text. For example the following:</p> <pre data-language="yaml+jinja">{{ "Plain style (default)" | comment }}
</pre> <p>produces this output:</p> <pre data-language="text">#
# Plain style (default)
#
</pre> <p>Ansible offers styles for comments in C (<code>//...</code>), C block (<code>/*...*/</code>), Erlang (<code>%...</code>) and XML (<code>&lt;!--...--&gt;</code>):</p> <pre data-language="yaml+jinja">{{ "C style" | comment('c') }}
{{ "C block style" | comment('cblock') }}
{{ "Erlang style" | comment('erlang') }}
{{ "XML style" | comment('xml') }}
</pre> <p>You can define a custom comment character. This filter:</p> <pre data-language="yaml+jinja">{{ "My Special Case" | comment(decoration="! ") }}
</pre> <p>produces:</p> <pre data-language="text">!
! My Special Case
!
</pre> <p>You can fully customize the comment style:</p> <pre data-language="yaml+jinja">{{ "Custom style" | comment('plain', prefix='#######\n#', postfix='#\n#######\n   ###\n    #') }}
</pre> <p>That creates the following output:</p> <pre data-language="text">#######
#
# Custom style
#
#######
   ###
    #
</pre> <p>The filter can also be applied to any Ansible variable. For example, to make the output of the <code>ansible_managed</code> variable more readable, we can change the definition in the <code>ansible.cfg</code> file to this:</p> <pre data-language="ini">[defaults]

ansible_managed = This file is managed by Ansible.%n
  template: {file}
  date: %Y-%m-%d %H:%M:%S
  user: {uid}
  host: {host}
</pre> <p>and then use the variable with the <code>comment</code> filter:</p> <pre data-language="yaml+jinja">{{ ansible_managed | comment }}
</pre> <p>which produces this output:</p> <pre data-language="sh">#
# This file is managed by Ansible.
#
# template: /home/ansible/env/dev/ansible_managed/roles/role1/templates/test.j2
# date: 2015-09-10 11:02:58
# user: ansible
# host: myhost
#
</pre> </section> <section id="urlencode-variables"> <h3>URLEncode Variables</h3> <p>The <code>urlencode</code> filter quotes data for use in a URL path or query using UTF-8:</p> <pre data-language="yaml+jinja">{{ 'Trollhättan' | urlencode }}
# =&gt; 'Trollh%C3%A4ttan'
</pre> </section> <section id="splitting-urls"> <h3>Splitting URLs</h3> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> <p>The <a class="reference internal" href="../collections/ansible/builtin/urlsplit_filter.html#ansible-collections-ansible-builtin-urlsplit-filter"><span class="std std-ref">ansible.builtin.urlsplit</span></a> filter extracts the fragment, hostname, netloc, password, path, port, query, scheme, and username from an URL. With no arguments, returns a dictionary of all the fields:</p> <pre data-language="yaml+jinja">{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('hostname') }}
# =&gt; 'www.acme.com'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('netloc') }}
# =&gt; 'user:password@www.acme.com:9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('username') }}
# =&gt; 'user'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('password') }}
# =&gt; 'password'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('path') }}
# =&gt; '/dir/index.html'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('port') }}
# =&gt; '9000'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('scheme') }}
# =&gt; 'http'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('query') }}
# =&gt; 'query=term'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit('fragment') }}
# =&gt; 'fragment'

{{ "http://user:password@www.acme.com:9000/dir/index.html?query=term#fragment" | urlsplit }}
# =&gt;
#   {
#       "fragment": "fragment",
#       "hostname": "www.acme.com",
#       "netloc": "user:password@www.acme.com:9000",
#       "password": "password",
#       "path": "/dir/index.html",
#       "port": 9000,
#       "query": "query=term",
#       "scheme": "http",
#       "username": "user"
#   }
</pre> </section> <section id="searching-strings-with-regular-expressions"> <h3>Searching strings with regular expressions</h3> <p>To search in a string or extract parts of a string with a regular expression, use the <a class="reference internal" href="../collections/ansible/builtin/regex_search_filter.html#ansible-collections-ansible-builtin-regex-search-filter"><span class="std std-ref">ansible.builtin.regex_search</span></a> filter:</p> <pre data-language="yaml+jinja"># Extracts the database name from a string
{{ 'server1/database42' | regex_search('database[0-9]+') }}
# =&gt; 'database42'

# Example for a case insensitive search in multiline mode
{{ 'foo\nBAR' | regex_search('^bar', multiline=True, ignorecase=True) }}
# =&gt; 'BAR'

# Example for a case insensitive search in multiline mode using inline regex flags
{{ 'foo\nBAR' | regex_search('(?im)^bar') }}
# =&gt; 'BAR'

# Extracts server and database id from a string
{{ 'server1/database42' | regex_search('server([0-9]+)/database([0-9]+)', '\\1', '\\2') }}
# =&gt; ['1', '42']

# Extracts dividend and divisor from a division
{{ '21/42' | regex_search('(?P&lt;dividend&gt;[0-9]+)/(?P&lt;divisor&gt;[0-9]+)', '\\g&lt;dividend&gt;', '\\g&lt;divisor&gt;') }}
# =&gt; ['21', '42']
</pre> <p>The <a class="reference internal" href="../collections/ansible/builtin/regex_search_filter.html#ansible-collections-ansible-builtin-regex-search-filter"><span class="std std-ref">ansible.builtin.regex_search</span></a> filter returns an empty string if it cannot find a match:</p> <pre data-language="yaml+jinja">{{ 'ansible' | regex_search('foobar') }}
# =&gt; ''
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <a class="reference internal" href="../collections/ansible/builtin/regex_search_filter.html#ansible-collections-ansible-builtin-regex-search-filter"><span class="std std-ref">ansible.builtin.regex_search</span></a> filter returns <code>None</code> when used in a Jinja expression (for example in conjunction with operators, other filters, and so on). See the two examples below.</p> <pre data-language="Jinja">{{ 'ansible' | regex_search('foobar') == '' }}
# =&gt; False
{{ 'ansible' | regex_search('foobar') is none }}
# =&gt; True
</pre> <p>This is due to historic behavior and the custom re-implementation of some of the Jinja internals in Ansible. Enable the <code>jinja2_native</code> setting if you want the <a class="reference internal" href="../collections/ansible/builtin/regex_search_filter.html#ansible-collections-ansible-builtin-regex-search-filter"><span class="std std-ref">ansible.builtin.regex_search</span></a> filter to always return <code>None</code> if it cannot find a match. See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/reference_appendices/faq.html#jinja2-faqs"><span class="std std-ref">Why does the regex_search filter return None instead of an empty string?</span></a> for details.</p> </div> <p>To extract all occurrences of regex matches in a string, use the <a class="reference internal" href="../collections/ansible/builtin/regex_findall_filter.html#ansible-collections-ansible-builtin-regex-findall-filter"><span class="std std-ref">ansible.builtin.regex_findall</span></a> filter:</p> <pre data-language="yaml+jinja"># Returns a list of all IPv4 addresses in the string
{{ 'Some DNS servers are 8.8.8.8 and 8.8.4.4' | regex_findall('\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b') }}
# =&gt; ['8.8.8.8', '8.8.4.4']

# Returns all lines that end with "ar"
{{ 'CAR\ntar\nfoo\nbar\n' | regex_findall('^.ar$', multiline=True, ignorecase=True) }}
# =&gt; ['CAR', 'tar', 'bar']

# Returns all lines that end with "ar" using inline regex flags for multiline and ignorecase
{{ 'CAR\ntar\nfoo\nbar\n' | regex_findall('(?im)^.ar$') }}
# =&gt; ['CAR', 'tar', 'bar']
</pre> <p>To replace text in a string with regex, use the <a class="reference internal" href="../collections/ansible/builtin/regex_replace_filter.html#ansible-collections-ansible-builtin-regex-replace-filter"><span class="std std-ref">ansible.builtin.regex_replace</span></a> filter:</p> <pre data-language="yaml+jinja"># Convert "ansible" to "able"
{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\1') }}
# =&gt; 'able'

# Convert "foobar" to "bar"
{{ 'foobar' | regex_replace('^f.*o(.*)$', '\\1') }}
# =&gt; 'bar'

# Convert "localhost:80" to "localhost, 80" using named groups
{{ 'localhost:80' | regex_replace('^(?P&lt;host&gt;.+):(?P&lt;port&gt;\\d+)$', '\\g&lt;host&gt;, \\g&lt;port&gt;') }}
# =&gt; 'localhost, 80'

# Convert "localhost:80" to "localhost"
{{ 'localhost:80' | regex_replace(':80') }}
# =&gt; 'localhost'

# Comment all lines that end with "ar"
{{ 'CAR\ntar\nfoo\nbar\n' | regex_replace('^(.ar)$', '#\\1', multiline=True, ignorecase=True) }}
# =&gt; '#CAR\n#tar\nfoo\n#bar\n'

# Comment all lines that end with "ar" using inline regex flags for multiline and ignorecase
{{ 'CAR\ntar\nfoo\nbar\n' | regex_replace('(?im)^(.ar)$', '#\\1') }}
# =&gt; '#CAR\n#tar\nfoo\n#bar\n'
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you want to match the whole string and you are using <code>*</code> make sure to always wraparound your regular expression with the start/end anchors. For example <code>^(.*)$</code> will always match only one result, while <code>(.*)</code> on some Python versions will match the whole string and an empty string at the end, which means it will make two replacements:</p> </div> <pre data-language="yaml+jinja"># add "https://" prefix to each item in a list
GOOD:
{{ hosts | map('regex_replace', '^(.*)$', 'https://\\1') | list }}
{{ hosts | map('regex_replace', '(.+)', 'https://\\1') | list }}
{{ hosts | map('regex_replace', '^', 'https://') | list }}

BAD:
{{ hosts | map('regex_replace', '(.*)', 'https://\\1') | list }}

# append ':80' to each item in a list
GOOD:
{{ hosts | map('regex_replace', '^(.*)$', '\\1:80') | list }}
{{ hosts | map('regex_replace', '(.+)', '\\1:80') | list }}
{{ hosts | map('regex_replace', '$', ':80') | list }}

BAD:
{{ hosts | map('regex_replace', '(.*)', '\\1:80') | list }}
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Prior to ansible 2.0, if <a class="reference internal" href="../collections/ansible/builtin/regex_replace_filter.html#ansible-collections-ansible-builtin-regex-replace-filter"><span class="std std-ref">ansible.builtin.regex_replace</span></a> filter was used with variables inside YAML arguments (as opposed to simpler ‘key=value’ arguments), then you needed to escape backreferences (for example, <code>\\1</code>) with 4 backslashes (<code>\\\\</code>) instead of 2 (<code>\\</code>).</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.0.</span></p> </div> <p>To escape special characters within a standard Python regex, use the <a class="reference internal" href="../collections/ansible/builtin/regex_escape_filter.html#ansible-collections-ansible-builtin-regex-escape-filter"><span class="std std-ref">ansible.builtin.regex_escape</span></a> filter (using the default <code><a class="reference internal" href="../collections/ansible/builtin/regex_escape_filter.html#ansible-collections-ansible-builtin-regex-escape-filter-parameter-re-type"><span class="std std-ref">re_type='python'</span></a></code> option):</p> <pre data-language="yaml+jinja"># convert '^f.*o(.*)$' to '\^f\.\*o\(\.\*\)\$'
{{ '^f.*o(.*)$' | regex_escape() }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> <p>To escape special characters within a POSIX basic regex, use the <a class="reference internal" href="../collections/ansible/builtin/regex_escape_filter.html#ansible-collections-ansible-builtin-regex-escape-filter"><span class="std std-ref">ansible.builtin.regex_escape</span></a> filter with the <code><a class="reference internal" href="../collections/ansible/builtin/regex_escape_filter.html#ansible-collections-ansible-builtin-regex-escape-filter-parameter-re-type"><span class="std std-ref">re_type='posix_basic'</span></a></code> option:</p> <pre data-language="yaml+jinja"># convert '^f.*o(.*)$' to '\^f\.\*o(\.\*)\$'
{{ '^f.*o(.*)$' | regex_escape('posix_basic') }}
</pre> </section> <section id="managing-file-names-and-path-names"> <h3>Managing file names and path names</h3> <p>To get the last name of a file path, like ‘foo.txt’ out of ‘/etc/asdf/foo.txt’:</p> <pre data-language="yaml+jinja">{{ path | basename }}
</pre> <p>To get the last name of a Windows style file path (new in version 2.0):</p> <pre data-language="yaml+jinja">{{ path | win_basename }}
</pre> <p>To separate the Windows drive letter from the rest of a file path (new in version 2.0):</p> <pre data-language="yaml+jinja">{{ path | win_splitdrive }}
</pre> <p>To get only the Windows drive letter:</p> <pre data-language="yaml+jinja">{{ path | win_splitdrive | first }}
</pre> <p>To get the rest of the path without the drive letter:</p> <pre data-language="yaml+jinja">{{ path | win_splitdrive | last }}
</pre> <p>To get the directory from a path:</p> <pre data-language="yaml+jinja">{{ path | dirname }}
</pre> <p>To get the directory from a Windows path (new version 2.0):</p> <pre data-language="yaml+jinja">{{ path | win_dirname }}
</pre> <p>To expand a path containing a tilde (<code>~</code>) character (new in version 1.5):</p> <pre data-language="yaml+jinja">{{ path | expanduser }}
</pre> <p>To expand a path containing environment variables:</p> <pre data-language="yaml+jinja">{{ path | expandvars }}
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>expandvars</code> expands local variables; using it on remote paths can lead to errors.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> <p>To get the real path of a link (new in version 1.8):</p> <pre data-language="yaml+jinja">{{ path | realpath }}
</pre> <p>To get the relative path of a link, from a start point (new in version 1.7):</p> <pre data-language="yaml+jinja">{{ path | relpath('/etc') }}
</pre> <p>To get the root and extension of a path or file name (new in version 2.0):</p> <pre data-language="yaml+jinja"># with path == 'nginx.conf' the return would be ('nginx', '.conf')
{{ path | splitext }}
</pre> <p>The <a class="reference internal" href="../collections/ansible/builtin/splitext_filter.html#ansible-collections-ansible-builtin-splitext-filter"><span class="std std-ref">ansible.builtin.splitext</span></a> filter always returns a pair of strings. The individual components can be accessed by using the <code>first</code> and <code>last</code> filters:</p> <pre data-language="yaml+jinja"># with path == 'nginx.conf' the return would be 'nginx'
{{ path | splitext | first }}

# with path == 'nginx.conf' the return would be '.conf'
{{ path | splitext | last }}
</pre> <p>To join one or more path components:</p> <pre data-language="yaml+jinja">{{ ('/etc', path, 'subdir', file) | path_join }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.10.</span></p> </div> </section> </section> <section id="manipulating-strings"> <h2>Manipulating strings</h2> <p>To add quotes for shell usage:</p> <pre data-language="yaml+jinja">- name: Run a shell command
  ansible.builtin.shell: echo {{ string_value | quote }}
</pre> <p>(Documentation: <a class="reference internal" href="../collections/ansible/builtin/quote_filter.html#ansible-collections-ansible-builtin-quote-filter"><span class="std std-ref">ansible.builtin.quote</span></a>)</p> <p>To concatenate a list into a string:</p> <pre data-language="yaml+jinja">{{ list | join(" ") }}
</pre> <p>To split a string into a list:</p> <pre data-language="yaml+jinja">{{ csv_string | split(",") }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.11.</span></p> </div> <p>To work with Base64 encoded strings:</p> <pre data-language="yaml+jinja">{{ encoded | b64decode }}
{{ decoded | string | b64encode }}
</pre> <p>(Documentation: <a class="reference internal" href="../collections/ansible/builtin/b64encode_filter.html#ansible-collections-ansible-builtin-b64encode-filter"><span class="std std-ref">ansible.builtin.b64encode</span></a>)</p> <p>As of version 2.6, you can define the type of encoding to use, the default is <code>utf-8</code>:</p> <pre data-language="yaml+jinja">{{ encoded | b64decode(encoding='utf-16-le') }}
{{ decoded | string | b64encode(encoding='utf-16-le') }}
</pre> <p>(Documentation: <a class="reference internal" href="../collections/ansible/builtin/b64decode_filter.html#ansible-collections-ansible-builtin-b64decode-filter"><span class="std std-ref">ansible.builtin.b64decode</span></a>)</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>string</code> filter is only required for Python 2 and ensures that the text to encode is a unicode string. Without that filter before b64encode the wrong value will be encoded.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The return value of b64decode is a string. If you decrypt a binary blob using b64decode and then try to use it (for example by using <a class="reference internal" href="../collections/ansible/builtin/copy_module.html#copy-module"><span class="std std-ref">copy</span></a> to write it to a file) you will most likely find that your binary has been corrupted. If you need to take a base64 encoded binary and write it to disk, it is best to use the system <code>base64</code> command with the <a class="reference internal" href="../collections/ansible/builtin/shell_module.html#shell-module"><span class="std std-ref">shell module</span></a>, piping in the encoded data using the <code>stdin</code> parameter. For example: <code>shell: cmd="base64 --decode &gt; myfile.bin" stdin="{{ encoded }}"</code></p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.6.</span></p> </div> </section> <section id="managing-uuids"> <h2>Managing UUIDs</h2> <p>To create a namespaced UUIDv5:</p> <pre data-language="yaml+jinja">{{ string | to_uuid(namespace='11111111-2222-3333-4444-555555555555') }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.10.</span></p> </div> <p>To create a namespaced UUIDv5 using the default Ansible namespace ‘361E6D51-FAEC-444A-9079-341386DA8E2E’:</p> <pre data-language="yaml+jinja">{{ string | to_uuid }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.</span></p> </div> <p>To make use of one attribute from each item in a list of complex variables, use the <a class="reference external" href="https://jinja.palletsprojects.com/en/3.1.x/templates/#jinja-filters.map" title="(in Jinja v3.1.x)"><code>Jinja2 map filter</code></a>:</p> <pre data-language="yaml+jinja"># get a comma-separated list of the mount points (for example, "/,/mnt/stuff") on a host
{{ ansible_mounts | map(attribute='mount') | join(',') }}
</pre> </section> <section id="handling-dates-and-times"> <h2>Handling dates and times</h2> <p>To get a date object from a string use the <code>to_datetime</code> filter:</p> <pre data-language="yaml+jinja"># Get the total amount of seconds between two dates. Default date format is %Y-%m-%d %H:%M:%S but you can pass your own format
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).total_seconds()  }}

# Get remaining seconds after delta has been calculated. NOTE: This does NOT convert years, days, hours, and so on to seconds. For that, use total_seconds()
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2016-08-14 18:00:00" | to_datetime)).seconds  }}
# This expression evaluates to "12" and not "132". Delta is 2 hours, 12 seconds

# get amount of days between two dates. This returns only the number of days and discards remaining hours, minutes, and seconds
{{ (("2016-08-14 20:00:12" | to_datetime) - ("2015-12-25" | to_datetime('%Y-%m-%d'))).days  }}
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>For a full list of format codes for working with Python date format strings, see the <a class="reference external" href="https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior">python datetime documentation</a>.</p> </div> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.4.</span></p> </div> <p>To format a date using a string (like with the shell date command), use the “strftime” filter:</p> <pre data-language="yaml+jinja"># Display year-month-day
{{ '%Y-%m-%d' | strftime }}
# =&gt; "2021-03-19"

# Display hour:min:sec
{{ '%H:%M:%S' | strftime }}
# =&gt; "21:51:04"

# Use ansible_date_time.epoch fact
{{ '%Y-%m-%d %H:%M:%S' | strftime(ansible_date_time.epoch) }}
# =&gt; "2021-03-19 21:54:09"

# Use arbitrary epoch value
{{ '%Y-%m-%d' | strftime(0) }}          # =&gt; 1970-01-01
{{ '%Y-%m-%d' | strftime(1441357287) }} # =&gt; 2015-09-04
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.13.</span></p> </div> <p>strftime takes an optional utc argument, defaulting to False, meaning times are in the local timezone:</p> <pre data-language="yaml+jinja">{{ '%H:%M:%S' | strftime }}           # time now in local timezone
{{ '%H:%M:%S' | strftime(utc=True) }} # time now in UTC
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To get all string possibilities, check <a class="reference external" href="https://docs.python.org/3/library/time.html#time.strftime">https://docs.python.org/3/library/time.html#time.strftime</a></p> </div> </section> <section id="getting-kubernetes-resource-names"> <h2>Getting Kubernetes resource names</h2> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These filters have migrated to the <a class="reference external" href="https://galaxy.ansible.com/kubernetes/core">kubernetes.core</a> collection. Follow the installation instructions to install that collection.</p> </div> <p>Use the “k8s_config_resource_name” filter to obtain the name of a Kubernetes ConfigMap or Secret, including its hash:</p> <pre data-language="yaml+jinja">{{ configmap_resource_definition | kubernetes.core.k8s_config_resource_name }}
</pre> <p>This can then be used to reference hashes in Pod specifications:</p> <pre data-language="yaml+jinja">my_secret:
  kind: Secret
  metadata:
    name: my_secret_name

deployment_resource:
  kind: Deployment
  spec:
    template:
      spec:
        containers:
        - envFrom:
            - secretRef:
                name: {{ my_secret | kubernetes.core.k8s_config_resource_name }}
</pre> <div class="versionadded"> <p><span class="versionmodified added">New in version 2.8.</span></p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="playbooks_intro.html#about-playbooks"><span class="std std-ref">Ansible playbooks</span></a></dt>
<dd>
<p>An introduction to playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_conditionals.html#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a></dt>
<dd>
<p>Conditional statements in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_variables.html#playbooks-variables"><span class="std std-ref">Using Variables</span></a></dt>
<dd>
<p>All about variables</p> </dd> <dt><a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">Loops</span></a></dt>
<dd>
<p>Looping in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_reuse_roles.html#playbooks-reuse-roles"><span class="std std-ref">Roles</span></a></dt>
<dd>
<p>Playbook organization by roles</p> </dd> <dt><a class="reference internal" href="../tips_tricks/ansible_tips_tricks.html#tips-and-tricks"><span class="std std-ref">General tips</span></a></dt>
<dd>
<p>Tips and tricks for playbooks</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Communication</span></a></dt>
<dd>
<p>Got questions? Need help? Want to share your ideas? Visit the Ansible communication guide</p> </dd> <dt><a class="reference external" href="https://docs.python.org/3/library/re.html">Python 3 Regular expression operations</a></dt>
<dd>
<p>How to use inline regular expression flags</p> </dd> </dl> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/user_guide/playbooks_filters.html</a>
  </p>
</div>
