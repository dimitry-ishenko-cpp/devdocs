<h1 id="become">Understanding privilege escalation: become</h1> <p id="understanding-privilege-escalation-become">Ansible uses existing privilege escalation systems to execute tasks with root privileges or with another user’s permissions. Because this feature allows you to ‘become’ another user, different from the user that logged into the machine (remote user), we call it <code>become</code>. The <code>become</code> keyword leverages existing privilege escalation tools like <code>sudo</code>, <code>su</code>, <code>pfexec</code>, <code>doas</code>, <code>pbrun</code>, <code>dzdo</code>, <code>ksu</code>, <code>runas</code>, <code>machinectl</code> and others.</p>  <ul class="simple"> <li>
<p><a class="reference internal" href="#using-become" id="id1">Using become</a></p> <ul> <li><a class="reference internal" href="#become-directives" id="id2">Become directives</a></li> <li><a class="reference internal" href="#become-connection-variables" id="id3">Become connection variables</a></li> <li><a class="reference internal" href="#become-command-line-options" id="id4">Become command-line options</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#risks-and-limitations-of-become" id="id5">Risks and limitations of become</a></p> <ul> <li><a class="reference internal" href="#risks-of-becoming-an-unprivileged-user" id="id6">Risks of becoming an unprivileged user</a></li> <li><a class="reference internal" href="#not-supported-by-all-connection-plugins" id="id7">Not supported by all connection plugins</a></li> <li><a class="reference internal" href="#only-one-method-may-be-enabled-per-host" id="id8">Only one method may be enabled per host</a></li> <li><a class="reference internal" href="#privilege-escalation-must-be-general" id="id9">Privilege escalation must be general</a></li> <li><a class="reference internal" href="#may-not-access-environment-variables-populated-by-pamd-systemd" id="id10">May not access environment variables populated by pamd_systemd</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#become-and-network-automation" id="id11">Become and network automation</a></p> <ul> <li>
<p><a class="reference internal" href="#setting-enable-mode-for-all-tasks" id="id12">Setting enable mode for all tasks</a></p> <ul> <li><a class="reference internal" href="#passwords-for-enable-mode" id="id13">Passwords for enable mode</a></li> </ul> </li> <li><a class="reference internal" href="#authorize-and-auth-pass" id="id14">authorize and auth_pass</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#become-and-windows" id="id15">Become and Windows</a></p> <ul> <li><a class="reference internal" href="#administrative-rights" id="id16">Administrative rights</a></li> <li><a class="reference internal" href="#local-service-accounts" id="id17">Local service accounts</a></li> <li><a class="reference internal" href="#become-without-setting-a-password" id="id18">Become without setting a password</a></li> <li><a class="reference internal" href="#accounts-without-a-password" id="id19">Accounts without a password</a></li> <li><a class="reference internal" href="#become-flags-for-windows" id="id20">Become flags for Windows</a></li> <li><a class="reference internal" href="#limitations-of-become-on-windows" id="id21">Limitations of become on Windows</a></li> </ul> </li> </ul>   <h2 id="using-become">Using become</h2> <p>You can control the use of <code>become</code> with play or task directives, connection variables, or at the command line. If you set privilege escalation properties in multiple ways, review the <a class="reference internal" href="../reference_appendices/general_precedence.html#general-precedence-rules"><span class="std std-ref">general precedence rules</span></a> to understand which settings will be used.</p> <p>A full list of all become plugins that are included in Ansible can be found in the <a class="reference internal" href="../plugins/become.html#become-plugin-list"><span class="std std-ref">Plugin List</span></a>.</p>  <h3 id="become-directives">Become directives</h3> <p>You can set the directives that control <code>become</code> at the play or task level. You can override these by setting connection variables, which often differ from one host to another. These variables and directives are independent. For example, setting <code>become_user</code> does not set <code>become</code>.</p> <dl class="simple"> <dt>become</dt>
<dd>
<p>set to <code>yes</code> to activate privilege escalation.</p> </dd> <dt>become_user</dt>
<dd>
<p>set to user with desired privileges — the user you <code>become</code>, NOT the user you login as. Does NOT imply <code>become: yes</code>, to allow it to be set at host level. Default value is <code>root</code>.</p> </dd> <dt>become_method</dt>
<dd>
<p>(at play or task level) overrides the default method set in ansible.cfg, set to use any of the <a class="reference internal" href="../plugins/become.html#become-plugins"><span class="std std-ref">Become Plugins</span></a>.</p> </dd> <dt>become_flags</dt>
<dd>
<p>(at play or task level) permit the use of specific flags for the tasks or role. One common use is to change the user to nobody when the shell is set to nologin. Added in Ansible 2.2.</p> </dd> </dl> <p>For example, to manage a system service (which requires <code>root</code> privileges) when connected as a non-<code>root</code> user, you can use the default value of <code>become_user</code> (<code>root</code>):</p> <pre data-language="yaml">- name: Ensure the httpd service is running
  service:
    name: httpd
    state: started
  become: yes
</pre> <p>To run a command as the <code>apache</code> user:</p> <pre data-language="yaml">- name: Run a command as the apache user
  command: somecommand
  become: yes
  become_user: apache
</pre> <p>To do something as the <code>nobody</code> user when the shell is nologin:</p> <pre data-language="yaml">- name: Run a command as nobody
  command: somecommand
  become: yes
  become_method: su
  become_user: nobody
  become_flags: '-s /bin/sh'
</pre> <p>To specify a password for sudo, run <code>ansible-playbook</code> with <code>--ask-become-pass</code> (<code>-K</code> for short). If you run a playbook utilizing <code>become</code> and the playbook seems to hang, most likely it is stuck at the privilege escalation prompt. Stop it with <code>CTRL-c</code>, then execute the playbook with <code>-K</code> and the appropriate password.</p>   <h3 id="become-connection-variables">Become connection variables</h3> <p>You can define different <code>become</code> options for each managed node or group. You can define these variables in inventory or use them as normal variables.</p> <dl class="simple"> <dt>ansible_become</dt>
<dd>
<p>overrides the <code>become</code> directive, decides if privilege escalation is used or not.</p> </dd> <dt>ansible_become_method</dt>
<dd>
<p>which privilege escalation method should be used</p> </dd> <dt>ansible_become_user</dt>
<dd>
<p>set the user you become through privilege escalation; does not imply <code>ansible_become: yes</code></p> </dd> <dt>ansible_become_password</dt>
<dd>
<p>set the privilege escalation password. See <a class="reference internal" href="vault.html#playbooks-vault"><span class="std std-ref">Using encrypted variables and files</span></a> for details on how to avoid having secrets in plain text</p> </dd> <dt>ansible_common_remote_group</dt>
<dd>
<p>determines if Ansible should try to <code>chgrp</code> its temporary files to a group if <code>setfacl</code> and <code>chown</code> both fail. See <a class="reference internal" href="#risks-of-becoming-an-unprivileged-user">Risks of becoming an unprivileged user</a> for more information. Added in version 2.10.</p> </dd> </dl> <p>For example, if you want to run all tasks as <code>root</code> on a server named <code>webserver</code>, but you can only connect as the <code>manager</code> user, you could use an inventory entry like this:</p> <pre data-language="text">webserver ansible_user=manager ansible_become=yes
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The variables defined above are generic for all become plugins but plugin specific ones can also be set instead. Please see the documentation for each plugin for a list of all options the plugin has and how they can be defined. A full list of become plugins in Ansible can be found at <a class="reference internal" href="../plugins/become.html#become-plugins"><span class="std std-ref">Become Plugins</span></a>.</p> </div>   <h3 id="become-command-line-options">Become command-line options</h3> <dl class="option-list"> <dt><kbd><span class="option">--ask-become-pass</span>, <span class="option">-K</span></kbd></dt> <dd>
<p>ask for privilege escalation password; does not imply become will be used. Note that this password will be used for all hosts.</p> </dd> <dt><kbd><span class="option">--become</span>, <span class="option">-b</span></kbd></dt> <dd>
<p>run operations with become (no password implied)</p> </dd> <dt><kbd><span class="option">--become-method=<var>BECOME_METHOD</var></span></kbd></dt> <dd>
<p>privilege escalation method to use (default=sudo), valid choices: [ sudo | su | pbrun | pfexec | doas | dzdo | ksu | runas | machinectl ]</p> </dd> <dt><kbd><span class="option">--become-user=<var>BECOME_USER</var></span></kbd></dt> <dd>
<p>run operations as this user (default=root), does not imply –become/-b</p> </dd> </dl>    <h2 id="risks-and-limitations-of-become">Risks and limitations of become</h2> <p>Although privilege escalation is mostly intuitive, there are a few limitations on how it works. Users should be aware of these to avoid surprises.</p>  <h3 id="risks-of-becoming-an-unprivileged-user">Risks of becoming an unprivileged user</h3> <p>Ansible modules are executed on the remote machine by first substituting the parameters into the module file, then copying the file to the remote machine, and finally executing it there.</p> <p>Everything is fine if the module file is executed without using <code>become</code>, when the <code>become_user</code> is root, or when the connection to the remote machine is made as root. In these cases Ansible creates the module file with permissions that only allow reading by the user and root, or only allow reading by the unprivileged user being switched to.</p> <p>However, when both the connection user and the <code>become_user</code> are unprivileged, the module file is written as the user that Ansible connects as (the <code>remote_user</code>), but the file needs to be readable by the user Ansible is set to <code>become</code>. The details of how Ansible solves this can vary based on platform. However, on POSIX systems, Ansible solves this problem in the following way:</p> <p>First, if <strong class="command">setfacl</strong> is installed and available in the remote <code>PATH</code>, and the temporary directory on the remote host is mounted with POSIX.1e filesystem ACL support, Ansible will use POSIX ACLs to share the module file with the second unprivileged user.</p> <p>Next, if POSIX ACLs are <strong>not</strong> available or <strong class="command">setfacl</strong> could not be run, Ansible will attempt to change ownership of the module file using <strong class="command">chown</strong> for systems which support doing so as an unprivileged user.</p> <p>New in Ansible 2.11, at this point, Ansible will try <strong class="command">chmod +a</strong> which is a macOS-specific way of setting ACLs on files.</p> <p>New in Ansible 2.10, if all of the above fails, Ansible will then check the value of the configuration setting <code>ansible_common_remote_group</code>. Many systems will allow a given user to change the group ownership of a file to a group the user is in. As a result, if the second unprivileged user (the <code>become_user</code>) has a UNIX group in common with the user Ansible is connected as (the <code>remote_user</code>), and if <code>ansible_common_remote_group</code> is defined to be that group, Ansible can try to change the group ownership of the module file to that group by using <strong class="command">chgrp</strong>, thereby likely making it readable to the <code>become_user</code>.</p> <p>At this point, if <code>ansible_common_remote_group</code> was defined and a <strong class="command">chgrp</strong> was attempted and returned successfully, Ansible assumes (but, importantly, does not check) that the new group ownership is enough and does not fall back further. That is, Ansible <strong>does not check</strong> that the <code>become_user</code> does in fact share a group with the <code>remote_user</code>; so long as the command exits successfully, Ansible considers the result successful and does not proceed to check <code>allow_world_readable_tmpfiles</code> per below.</p> <p>If <code>ansible_common_remote_group</code> is <strong>not</strong> set and the chown above it failed, or if <code>ansible_common_remote_group</code> <em>is</em> set but the <strong class="command">chgrp</strong> (or following group-permissions <strong class="command">chmod</strong>) returned a non-successful exit code, Ansible will lastly check the value of <code>allow_world_readable_tmpfiles</code>. If this is set, Ansible will place the module file in a world-readable temporary directory, with world-readable permissions to allow the <code>become_user</code> (and incidentally any other user on the system) to read the contents of the file. <strong>If any of the parameters passed to the module are sensitive in nature, and you do not trust the remote machines, then this is a potential security risk.</strong></p> <p>Once the module is done executing, Ansible deletes the temporary file.</p> <p>Several ways exist to avoid the above logic flow entirely:</p> <ul class="simple"> <li>Use <code>pipelining</code>. When pipelining is enabled, Ansible does not save the module to a temporary file on the client. Instead it pipes the module to the remote python interpreter’s stdin. Pipelining does not work for python modules involving file transfer (for example: <a class="reference internal" href="../collections/ansible/builtin/copy_module.html#copy-module"><span class="std std-ref">copy</span></a>, <a class="reference internal" href="../collections/ansible/builtin/fetch_module.html#fetch-module"><span class="std std-ref">fetch</span></a>, <a class="reference internal" href="../collections/ansible/builtin/template_module.html#template-module"><span class="std std-ref">template</span></a>), or for non-python modules.</li> <li>Avoid becoming an unprivileged user. Temporary files are protected by UNIX file permissions when you <code>become</code> root or do not use <code>become</code>. In Ansible 2.1 and above, UNIX file permissions are also secure if you make the connection to the managed machine as root and then use <code>become</code> to access an unprivileged account.</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Although the Solaris ZFS filesystem has filesystem ACLs, the ACLs are not POSIX.1e filesystem acls (they are NFSv4 ACLs instead). Ansible cannot use these ACLs to manage its temp file permissions so you may have to resort to <code>allow_world_readable_tmpfiles</code> if the remote machines use ZFS.</p> </div> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.1.</span></p> </div> <p>Ansible makes it hard to unknowingly use <code>become</code> insecurely. Starting in Ansible 2.1, Ansible defaults to issuing an error if it cannot execute securely with <code>become</code>. If you cannot use pipelining or POSIX ACLs, must connect as an unprivileged user, must use <code>become</code> to execute as a different unprivileged user, and decide that your managed nodes are secure enough for the modules you want to run there to be world readable, you can turn on <code>allow_world_readable_tmpfiles</code> in the <code>ansible.cfg</code> file. Setting <code>allow_world_readable_tmpfiles</code> will change this from an error into a warning and allow the task to run as it did prior to 2.1.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 2.10.</span></p> </div> <p>Ansible 2.10 introduces the above-mentioned <code>ansible_common_remote_group</code> fallback. As mentioned above, if enabled, it is used when <code>remote_user</code> and <code>become_user</code> are both unprivileged users. Refer to the text above for details on when this fallback happens.</p> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As mentioned above, if <code>ansible_common_remote_group</code> and <code>allow_world_readable_tmpfiles</code> are both enabled, it is unlikely that the world-readable fallback will ever trigger, and yet Ansible might still be unable to access the module file. This is because after the group ownership change is successful, Ansible does not fall back any further, and also does not do any check to ensure that the <code>become_user</code> is actually a member of the “common group”. This is a design decision made by the fact that doing such a check would require another round-trip connection to the remote machine, which is a time-expensive operation. Ansible does, however, emit a warning in this case.</p> </div>   <h3 id="not-supported-by-all-connection-plugins">Not supported by all connection plugins</h3> <p>Privilege escalation methods must also be supported by the connection plugin used. Most connection plugins will warn if they do not support become. Some will just ignore it as they always run as root (jail, chroot, and so on).</p>   <h3 id="only-one-method-may-be-enabled-per-host">Only one method may be enabled per host</h3> <p>Methods cannot be chained. You cannot use <code>sudo /bin/su -</code> to become a user, you need to have privileges to run the command as that user in sudo or be able to su directly to it (the same for pbrun, pfexec or other supported methods).</p>   <h3 id="privilege-escalation-must-be-general">Privilege escalation must be general</h3> <p>You cannot limit privilege escalation permissions to certain commands. Ansible does not always use a specific command to do something but runs modules (code) from a temporary file name which changes every time. If you have ‘/sbin/service’ or ‘/bin/chmod’ as the allowed commands this will fail with ansible as those paths won’t match with the temporary file that Ansible creates to run the module. If you have security rules that constrain your sudo/pbrun/doas environment to running specific command paths only, use Ansible from a special account that does not have this constraint, or use AWX or the <a class="reference internal" href="https://docs.ansible.com/ansible/latest/reference_appendices/tower.html#ansible-platform"><span class="std std-ref">Red Hat Ansible Automation Platform</span></a> to manage indirect access to SSH credentials.</p>   <h3 id="may-not-access-environment-variables-populated-by-pamd-systemd">May not access environment variables populated by pamd_systemd</h3> <p>For most Linux distributions using <code>systemd</code> as their init, the default methods used by <code>become</code> do not open a new “session”, in the sense of systemd. Because the <code>pam_systemd</code> module will not fully initialize a new session, you might have surprises compared to a normal session opened through ssh: some environment variables set by <code>pam_systemd</code>, most notably <code>XDG_RUNTIME_DIR</code>, are not populated for the new user and instead inherited or just emptied.</p> <p>This might cause trouble when trying to invoke systemd commands that depend on <code>XDG_RUNTIME_DIR</code> to access the bus:</p> <pre data-language="console">$ echo $XDG_RUNTIME_DIR

$ systemctl --user status
Failed to connect to bus: Permission denied
</pre> <p>To force <code>become</code> to open a new systemd session that goes through <code>pam_systemd</code>, you can use <code>become_method: machinectl</code>.</p> <p>For more information, see <a class="reference external" href="https://github.com/systemd/systemd/issues/825#issuecomment-127917622">this systemd issue</a>.</p>    <h2 id="become-network">Become and network automation</h2> <p id="become-and-network-automation">As of version 2.6, Ansible supports <code>become</code> for privilege escalation (entering <code>enable</code> mode or privileged EXEC mode) on all Ansible-maintained network platforms that support <code>enable</code> mode. Using <code>become</code> replaces the <code>authorize</code> and <code>auth_pass</code> options in a <code>provider</code> dictionary.</p> <p>You must set the connection type to either <code>connection: ansible.netcommon.network_cli</code> or <code>connection: ansible.netcommon.httpapi</code> to use <code>become</code> for privilege escalation on network devices. Check the <a class="reference internal" href="../network/user_guide/platform_index.html#platform-options"><span class="std std-ref">Platform Options</span></a> documentation for details.</p> <p>You can use escalated privileges on only the specific tasks that need them, on an entire play, or on all plays. Adding <code>become: yes</code> and <code>become_method: enable</code> instructs Ansible to enter <code>enable</code> mode before executing the task, play, or playbook where those parameters are set.</p> <p>If you see this error message, the task that generated it requires <code>enable</code> mode to succeed:</p> <pre data-language="console">Invalid input (privileged mode required)
</pre> <p>To set <code>enable</code> mode for a specific task, add <code>become</code> at the task level:</p> <pre data-language="yaml">- name: Gather facts (eos)
  arista.eos.eos_facts:
    gather_subset:
      - "!hardware"
  become: yes
  become_method: enable
</pre> <p>To set enable mode for all tasks in a single play, add <code>become</code> at the play level:</p> <pre data-language="yaml">- hosts: eos-switches
  become: yes
  become_method: enable
  tasks:
    - name: Gather facts (eos)
      arista.eos.eos_facts:
        gather_subset:
          - "!hardware"
</pre>  <h3 id="setting-enable-mode-for-all-tasks">Setting enable mode for all tasks</h3> <p>Often you wish for all tasks in all plays to run using privilege mode, that is best achieved by using <code>group_vars</code>:</p> <p><strong>group_vars/eos.yml</strong></p> <pre data-language="yaml">ansible_connection: ansible.netcommon.network_cli
ansible_network_os: arista.eos.eos
ansible_user: myuser
ansible_become: yes
ansible_become_method: enable
</pre>  <h4 id="passwords-for-enable-mode">Passwords for enable mode</h4> <p>If you need a password to enter <code>enable</code> mode, you can specify it in one of two ways:</p> <ul class="simple"> <li>providing the <a class="reference internal" href="../cli/ansible-playbook.html#cmdoption-ansible-playbook-K"><code>--ask-become-pass</code></a> command line option</li> <li>setting the <code>ansible_become_password</code> connection variable</li> </ul> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As a reminder passwords should never be stored in plain text. For information on encrypting your passwords and other secrets with Ansible Vault, see <a class="reference internal" href="vault.html#vault"><span class="std std-ref">Encrypting content with Ansible Vault</span></a>.</p> </div>    <h3 id="authorize-and-auth-pass">authorize and auth_pass</h3> <p>Ansible still supports <code>enable</code> mode with <code>connection: local</code> for legacy network playbooks. To enter <code>enable</code> mode with <code>connection: local</code>, use the module options <code>authorize</code> and <code>auth_pass</code>:</p> <pre data-language="yaml">- hosts: eos-switches
  ansible_connection: local
  tasks:
    - name: Gather facts (eos)
      eos_facts:
        gather_subset:
          - "!hardware"
      provider:
        authorize: yes
        auth_pass: " {{ secret_auth_pass }}"
</pre> <p>We recommend updating your playbooks to use <code>become</code> for network-device <code>enable</code> mode consistently. The use of <code>authorize</code> and of <code>provider</code> dictionaries will be deprecated in future. Check the <a class="reference internal" href="../network/user_guide/platform_index.html#platform-options"><span class="std std-ref">Platform Options</span></a> and <a class="reference external" href="https://docs.ansible.com/ansible/2.9/modules/list_of_network_modules.html#network-modules" title="(in Ansible v2.9)"><span>Network modules</span></a> documentation for details.</p>    <h2 id="become-windows">Become and Windows</h2> <p id="become-and-windows">Since Ansible 2.3, <code>become</code> can be used on Windows hosts through the <code>runas</code> method. Become on Windows uses the same inventory setup and invocation arguments as <code>become</code> on a non-Windows host, so the setup and variable names are the same as what is defined in this document.</p> <p>While <code>become</code> can be used to assume the identity of another user, there are other uses for it with Windows hosts. One important use is to bypass some of the limitations that are imposed when running on WinRM, such as constrained network delegation or accessing forbidden system calls like the WUA API. You can use <code>become</code> with the same user as <code>ansible_user</code> to bypass these limitations and run commands that are not normally accessible in a WinRM session.</p>  <h3 id="administrative-rights">Administrative rights</h3> <p>Many tasks in Windows require administrative privileges to complete. When using the <code>runas</code> become method, Ansible will attempt to run the module with the full privileges that are available to the remote user. If it fails to elevate the user token, it will continue to use the limited token during execution.</p> <p>A user must have the <code>SeDebugPrivilege</code> to run a become process with elevated privileges. This privilege is assigned to Administrators by default. If the debug privilege is not available, the become process will run with a limited set of privileges and groups.</p> <p>To determine the type of token that Ansible was able to get, run the following task:</p> <pre data-language="yaml">- Check my user name
  ansible.windows.win_whoami:
  become: yes
</pre> <p>The output will look something similar to the below:</p> <pre data-language="ansible">ok: [windows] =&gt; {
    "account": {
        "account_name": "vagrant-domain",
        "domain_name": "DOMAIN",
        "sid": "S-1-5-21-3088887838-4058132883-1884671576-1105",
        "type": "User"
    },
    "authentication_package": "Kerberos",
    "changed": false,
    "dns_domain_name": "DOMAIN.LOCAL",
    "groups": [
        {
            "account_name": "Administrators",
            "attributes": [
                "Mandatory",
                "Enabled by default",
                "Enabled",
                "Owner"
            ],
            "domain_name": "BUILTIN",
            "sid": "S-1-5-32-544",
            "type": "Alias"
        },
        {
            "account_name": "INTERACTIVE",
            "attributes": [
                "Mandatory",
                "Enabled by default",
                "Enabled"
            ],
            "domain_name": "NT AUTHORITY",
            "sid": "S-1-5-4",
            "type": "WellKnownGroup"
        },
    ],
    "impersonation_level": "SecurityAnonymous",
    "label": {
        "account_name": "High Mandatory Level",
        "domain_name": "Mandatory Label",
        "sid": "S-1-16-12288",
        "type": "Label"
    },
    "login_domain": "DOMAIN",
    "login_time": "2018-11-18T20:35:01.9696884+00:00",
    "logon_id": 114196830,
    "logon_server": "DC01",
    "logon_type": "Interactive",
    "privileges": {
        "SeBackupPrivilege": "disabled",
        "SeChangeNotifyPrivilege": "enabled-by-default",
        "SeCreateGlobalPrivilege": "enabled-by-default",
        "SeCreatePagefilePrivilege": "disabled",
        "SeCreateSymbolicLinkPrivilege": "disabled",
        "SeDebugPrivilege": "enabled",
        "SeDelegateSessionUserImpersonatePrivilege": "disabled",
        "SeImpersonatePrivilege": "enabled-by-default",
        "SeIncreaseBasePriorityPrivilege": "disabled",
        "SeIncreaseQuotaPrivilege": "disabled",
        "SeIncreaseWorkingSetPrivilege": "disabled",
        "SeLoadDriverPrivilege": "disabled",
        "SeManageVolumePrivilege": "disabled",
        "SeProfileSingleProcessPrivilege": "disabled",
        "SeRemoteShutdownPrivilege": "disabled",
        "SeRestorePrivilege": "disabled",
        "SeSecurityPrivilege": "disabled",
        "SeShutdownPrivilege": "disabled",
        "SeSystemEnvironmentPrivilege": "disabled",
        "SeSystemProfilePrivilege": "disabled",
        "SeSystemtimePrivilege": "disabled",
        "SeTakeOwnershipPrivilege": "disabled",
        "SeTimeZonePrivilege": "disabled",
        "SeUndockPrivilege": "disabled"
    },
    "rights": [
        "SeNetworkLogonRight",
        "SeBatchLogonRight",
        "SeInteractiveLogonRight",
        "SeRemoteInteractiveLogonRight"
    ],
    "token_type": "TokenPrimary",
    "upn": "vagrant-domain@DOMAIN.LOCAL",
    "user_flags": []
}
</pre> <p>Under the <code>label</code> key, the <code>account_name</code> entry determines whether the user has Administrative rights. Here are the labels that can be returned and what they represent:</p> <ul class="simple"> <li>
<code>Medium</code>: Ansible failed to get an elevated token and ran under a limited token. Only a subset of the privileges assigned to user are available during the module execution and the user does not have administrative rights.</li> <li>
<code>High</code>: An elevated token was used and all the privileges assigned to the user are available during the module execution.</li> <li>
<code>System</code>: The <code>NT AUTHORITY\System</code> account is used and has the highest level of privileges available.</li> </ul> <p>The output will also show the list of privileges that have been granted to the user. When the privilege value is <code>disabled</code>, the privilege is assigned to the logon token but has not been enabled. In most scenarios these privileges are automatically enabled when required.</p> <p>If running on a version of Ansible that is older than 2.5 or the normal <code>runas</code> escalation process fails, an elevated token can be retrieved by:</p> <ul> <li>Set the <code>become_user</code> to <code>System</code> which has full control over the operating system.</li> <li>
<p>Grant <code>SeTcbPrivilege</code> to the user Ansible connects with on WinRM. <code>SeTcbPrivilege</code> is a high-level privilege that grants full control over the operating system. No user is given this privilege by default, and care should be taken if you grant this privilege to a user or group. For more information on this privilege, please see <a class="reference external" href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/dn221957(v=ws.11)">Act as part of the operating system</a>. You can use the below task to set this privilege on a Windows host:</p> <pre data-language="yaml">- name: grant the ansible user the SeTcbPrivilege right
  ansible.windows.win_user_right:
    name: SeTcbPrivilege
    users: '{{ansible_user}}'
    action: add
</pre> </li> <li>
<p>Turn UAC off on the host and reboot before trying to become the user. UAC is a security protocol that is designed to run accounts with the <code>least privilege</code> principle. You can turn UAC off by running the following tasks:</p> <pre data-language="yaml">- name: turn UAC off
  win_regedit:
    path: HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\policies\system
    name: EnableLUA
    data: 0
    type: dword
    state: present
  register: uac_result

- name: reboot after disabling UAC
  win_reboot:
  when: uac_result is changed
</pre> </li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Granting the <code>SeTcbPrivilege</code> or turning UAC off can cause Windows security vulnerabilities and care should be given if these steps are taken.</p> </div>   <h3 id="local-service-accounts">Local service accounts</h3> <p>Prior to Ansible version 2.5, <code>become</code> only worked on Windows with a local or domain user account. Local service accounts like <code>System</code> or <code>NetworkService</code> could not be used as <code>become_user</code> in these older versions. This restriction has been lifted since the 2.5 release of Ansible. The three service accounts that can be set under <code>become_user</code> are:</p> <ul class="simple"> <li>System</li> <li>NetworkService</li> <li>LocalService</li> </ul> <p>Because local service accounts do not have passwords, the <code>ansible_become_password</code> parameter is not required and is ignored if specified.</p>   <h3 id="become-without-setting-a-password">Become without setting a password</h3> <p>As of Ansible 2.8, <code>become</code> can be used to become a Windows local or domain account without requiring a password for that account. For this method to work, the following requirements must be met:</p> <ul class="simple"> <li>The connection user has the <code>SeDebugPrivilege</code> privilege assigned</li> <li>The connection user is part of the <code>BUILTIN\Administrators</code> group</li> <li>The <code>become_user</code> has either the <code>SeBatchLogonRight</code> or <code>SeNetworkLogonRight</code> user right</li> </ul> <p>Using become without a password is achieved in one of two different methods:</p> <ul class="simple"> <li>Duplicating an existing logon session’s token if the account is already logged on</li> <li>Using S4U to generate a logon token that is valid on the remote host only</li> </ul> <p>In the first scenario, the become process is spawned from another logon of that user account. This could be an existing RDP logon, console logon, but this is not guaranteed to occur all the time. This is similar to the <code>Run only when user is logged on</code> option for a Scheduled Task.</p> <p>In the case where another logon of the become account does not exist, S4U is used to create a new logon and run the module through that. This is similar to the <code>Run whether user is logged on or not</code> with the <code>Do not store password</code> option for a Scheduled Task. In this scenario, the become process will not be able to access any network resources like a normal WinRM process.</p> <p>To make a distinction between using become with no password and becoming an account that has no password make sure to keep <code>ansible_become_password</code> as undefined or set <code>ansible_become_password:</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Because there are no guarantees an existing token will exist for a user when Ansible runs, there’s a high change the become process will only have access to local resources. Use become with a password if the task needs to access network resources</p> </div>   <h3 id="accounts-without-a-password">Accounts without a password</h3> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>As a general security best practice, you should avoid allowing accounts without passwords.</p> </div> <p>Ansible can be used to become a Windows account that does not have a password (like the <code>Guest</code> account). To become an account without a password, set up the variables like normal but set <code>ansible_become_password: ''</code>.</p> <p>Before become can work on an account like this, the local policy <a class="reference external" href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-R2-and-2012/jj852174(v=ws.11)">Accounts: Limit local account use of blank passwords to console logon only</a> must be disabled. This can either be done through a Group Policy Object (GPO) or with this Ansible task:</p> <pre data-language="yaml">- name: allow blank password on become
  ansible.windows.win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Control\Lsa
    name: LimitBlankPasswordUse
    data: 0
    type: dword
    state: present
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This is only for accounts that do not have a password. You still need to set the account’s password under <code>ansible_become_password</code> if the become_user has a password.</p> </div>   <h3 id="become-flags-for-windows">Become flags for Windows</h3> <p>Ansible 2.5 added the <code>become_flags</code> parameter to the <code>runas</code> become method. This parameter can be set using the <code>become_flags</code> task directive or set in Ansible’s configuration using <code>ansible_become_flags</code>. The two valid values that are initially supported for this parameter are <code>logon_type</code> and <code>logon_flags</code>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>These flags should only be set when becoming a normal user account, not a local service account like LocalSystem.</p> </div> <p>The key <code>logon_type</code> sets the type of logon operation to perform. The value can be set to one of the following:</p> <ul class="simple"> <li>
<code>interactive</code>: The default logon type. The process will be run under a context that is the same as when running a process locally. This bypasses all WinRM restrictions and is the recommended method to use.</li> <li>
<code>batch</code>: Runs the process under a batch context that is similar to a scheduled task with a password set. This should bypass most WinRM restrictions and is useful if the <code>become_user</code> is not allowed to log on interactively.</li> <li>
<code>new_credentials</code>: Runs under the same credentials as the calling user, but outbound connections are run under the context of the <code>become_user</code> and <code>become_password</code>, similar to <code>runas.exe /netonly</code>. The <code>logon_flags</code> flag should also be set to <code>netcredentials_only</code>. Use this flag if the process needs to access a network resource (like an SMB share) using a different set of credentials.</li> <li>
<code>network</code>: Runs the process under a network context without any cached credentials. This results in the same type of logon session as running a normal WinRM process without credential delegation, and operates under the same restrictions.</li> <li>
<code>network_cleartext</code>: Like the <code>network</code> logon type, but instead caches the credentials so it can access network resources. This is the same type of logon session as running a normal WinRM process with credential delegation.</li> </ul> <p>For more information, see <a class="reference external" href="https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-logonusera">dwLogonType</a>.</p> <p>The <code>logon_flags</code> key specifies how Windows will log the user on when creating the new process. The value can be set to none or multiple of the following:</p> <ul class="simple"> <li>
<code>with_profile</code>: The default logon flag set. The process will load the user’s profile in the <code>HKEY_USERS</code> registry key to <code>HKEY_CURRENT_USER</code>.</li> <li>
<code>netcredentials_only</code>: The process will use the same token as the caller but will use the <code>become_user</code> and <code>become_password</code> when accessing a remote resource. This is useful in inter-domain scenarios where there is no trust relationship, and should be used with the <code>new_credentials</code> <code>logon_type</code>.</li> </ul> <p>By default <code>logon_flags=with_profile</code> is set, if the profile should not be loaded set <code>logon_flags=</code> or if the profile should be loaded with <code>netcredentials_only</code>, set <code>logon_flags=with_profile,netcredentials_only</code>.</p> <p>For more information, see <a class="reference external" href="https://docs.microsoft.com/en-gb/windows/desktop/api/winbase/nf-winbase-createprocesswithtokenw">dwLogonFlags</a>.</p> <p>Here are some examples of how to use <code>become_flags</code> with Windows tasks:</p> <pre data-language="yaml">- name: copy a file from a fileshare with custom credentials
  ansible.windows.win_copy:
    src: \\server\share\data\file.txt
    dest: C:\temp\file.txt
    remote_src: yes
  vars:
    ansible_become: yes
    ansible_become_method: runas
    ansible_become_user: DOMAIN\user
    ansible_become_password: Password01
    ansible_become_flags: logon_type=new_credentials logon_flags=netcredentials_only

- name: run a command under a batch logon
  ansible.windows.win_whoami:
  become: yes
  become_flags: logon_type=batch

- name: run a command and not load the user profile
  ansible.windows.win_whomai:
  become: yes
  become_flags: logon_flags=
</pre>   <h3 id="limitations-of-become-on-windows">Limitations of become on Windows</h3> <ul class="simple"> <li>Running a task with <code>async</code> and <code>become</code> on Windows Server 2008, 2008 R2 and Windows 7 only works when using Ansible 2.7 or newer.</li> <li>By default, the become user logs on with an interactive session, so it must have the right to do so on the Windows host. If it does not inherit the <code>SeAllowLogOnLocally</code> privilege or inherits the <code>SeDenyLogOnLocally</code> privilege, the become process will fail. Either add the privilege or set the <code>logon_type</code> flag to change the logon type used.</li> <li>Prior to Ansible version 2.3, become only worked when <code>ansible_winrm_transport</code> was either <code>basic</code> or <code>credssp</code>. This restriction has been lifted since the 2.4 release of Ansible for all hosts except Windows Server 2008 (non R2 version).</li> <li>The Secondary Logon service <code>seclogon</code> must be running to use <code>ansible_become_method: runas</code>
</li> </ul> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://groups.google.com/forum/#!forum/ansible-project">Mailing List</a></dt>
<dd>
<p>Questions? Help? Ideas? Stop by the list on Google Groups</p> </dd> <dt><a class="reference external" href="https://libera.chat/">irc.libera.chat</a></dt>
<dd>
<p>#ansible IRC chat channel</p> </dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2021 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/user_guide/become.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/user_guide/become.html</a>
  </p>
</div>
