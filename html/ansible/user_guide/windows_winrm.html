<h1 id="windows-winrm">Windows Remote Management</h1> <p id="windows-remote-management">Unlike Linux/Unix hosts, which use SSH by default, Windows hosts are configured with WinRM. This topic covers how to configure and use WinRM with Ansible.</p>   <ul class="simple"> <li><a class="reference internal" href="#what-is-winrm" id="id1">What is WinRM?</a></li> <li>
<p><a class="reference internal" href="#authentication-options" id="id2">Authentication Options</a></p> <ul> <li><a class="reference internal" href="#basic" id="id3">Basic</a></li> <li>
<p><a class="reference internal" href="#certificate" id="id4">Certificate</a></p> <ul> <li><a class="reference internal" href="#generate-a-certificate" id="id5">Generate a Certificate</a></li> <li><a class="reference internal" href="#import-a-certificate-to-the-certificate-store" id="id6">Import a Certificate to the Certificate Store</a></li> <li><a class="reference internal" href="#mapping-a-certificate-to-an-account" id="id7">Mapping a Certificate to an Account</a></li> </ul> </li> <li><a class="reference internal" href="#ntlm" id="id8">NTLM</a></li> <li>
<p><a class="reference internal" href="#kerberos" id="id9">Kerberos</a></p> <ul> <li><a class="reference internal" href="#installing-the-kerberos-library" id="id10">Installing the Kerberos Library</a></li> <li><a class="reference internal" href="#configuring-host-kerberos" id="id11">Configuring Host Kerberos</a></li> <li><a class="reference internal" href="#automatic-kerberos-ticket-management" id="id12">Automatic Kerberos Ticket Management</a></li> <li><a class="reference internal" href="#manual-kerberos-ticket-management" id="id13">Manual Kerberos Ticket Management</a></li> <li><a class="reference internal" href="#troubleshooting-kerberos" id="id14">Troubleshooting Kerberos</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#credssp" id="id15">CredSSP</a></p> <ul> <li><a class="reference internal" href="#installing-credssp-library" id="id16">Installing CredSSP Library</a></li> <li><a class="reference internal" href="#credssp-and-tls-1-2" id="id17">CredSSP and TLS 1.2</a></li> <li><a class="reference internal" href="#set-credssp-certificate" id="id18">Set CredSSP Certificate</a></li> </ul> </li> </ul> </li> <li><a class="reference internal" href="#non-administrator-accounts" id="id19">Non-Administrator Accounts</a></li> <li><a class="reference internal" href="#winrm-encryption" id="id20">WinRM Encryption</a></li> <li><a class="reference internal" href="#inventory-options" id="id21">Inventory Options</a></li> <li><a class="reference internal" href="#ipv6-addresses" id="id22">IPv6 Addresses</a></li> <li><a class="reference internal" href="#https-certificate-validation" id="id23">HTTPS Certificate Validation</a></li> <li><a class="reference internal" href="#tls-1-2-support" id="id24">TLS 1.2 Support</a></li> <li><a class="reference internal" href="#limitations" id="id25">Limitations</a></li> </ul>   <h2 id="what-is-winrm">What is WinRM?</h2> <p>WinRM is a management protocol used by Windows to remotely communicate with another server. It is a SOAP-based protocol that communicates over HTTP/HTTPS, and is included in all recent Windows operating systems. Since Windows Server 2012, WinRM has been enabled by default, but in most cases extra configuration is required to use WinRM with Ansible.</p> <p>Ansible uses the <a class="reference external" href="https://github.com/diyan/pywinrm">pywinrm</a> package to communicate with Windows servers over WinRM. It is not installed by default with the Ansible package, but can be installed by running the following:</p> <pre data-language="shell">pip install "pywinrm&gt;=0.3.0"
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>on distributions with multiple python versions, use pip2 or pip2.x, where x matches the python minor version Ansible is running under.</p> </div> <div class="admonition warning"> <p class="admonition-title">Warning</p> <p>Using the <code>winrm</code> or <code>psrp</code> connection plugins in Ansible on MacOS in the latest releases typically fail. This is a known problem that occurs deep within the Python stack and cannot be changed by Ansible. The only workaround today is to set the environment variable <code>no_proxy=*</code> and avoid using Kerberos auth.</p> </div>   <h2 id="authentication-options">Authentication Options</h2> <p>When connecting to a Windows host, there are several different options that can be used when authenticating with an account. The authentication type may be set on inventory hosts or groups with the <code>ansible_winrm_transport</code> variable.</p> <p>The following matrix is a high level overview of the options:</p> <table class="docutils align-default">  <thead> <tr>
<th class="head"><p>Option</p></th> <th class="head"><p>Local Accounts</p></th> <th class="head"><p>Active Directory Accounts</p></th> <th class="head"><p>Credential Delegation</p></th> <th class="head"><p>HTTP Encryption</p></th> </tr> </thead>  <tr>
<td><p>Basic</p></td> <td><p>Yes</p></td> <td><p>No</p></td> <td><p>No</p></td> <td><p>No</p></td> </tr> <tr>
<td><p>Certificate</p></td> <td><p>Yes</p></td> <td><p>No</p></td> <td><p>No</p></td> <td><p>No</p></td> </tr> <tr>
<td><p>Kerberos</p></td> <td><p>No</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> </tr> <tr>
<td><p>NTLM</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> <td><p>No</p></td> <td><p>Yes</p></td> </tr> <tr>
<td><p>CredSSP</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> <td><p>Yes</p></td> </tr>  </table>  <h3 id="basic">Basic</h3> <p>Basic authentication is one of the simplest authentication options to use, but is also the most insecure. This is because the username and password are simply base64 encoded, and if a secure channel is not in use (eg, HTTPS) then it can be decoded by anyone. Basic authentication can only be used for local accounts (not domain accounts).</p> <p>The following example shows host vars configured for basic authentication:</p> <pre data-language="yaml+jinja">ansible_user: LocalUsername
ansible_password: Password
ansible_connection: winrm
ansible_winrm_transport: basic
</pre> <p>Basic authentication is not enabled by default on a Windows host but can be enabled by running the following in PowerShell:</p> <pre data-language="YAML+Jinja">Set-Item -Path WSMan:\localhost\Service\Auth\Basic -Value $true
</pre>   <h3 id="certificate">Certificate</h3> <p>Certificate authentication uses certificates as keys similar to SSH key pairs, but the file format and key generation process is different.</p> <p>The following example shows host vars configured for certificate authentication:</p> <pre data-language="yaml+jinja">ansible_connection: winrm
ansible_winrm_cert_pem: /path/to/certificate/public/key.pem
ansible_winrm_cert_key_pem: /path/to/certificate/private/key.pem
ansible_winrm_transport: certificate
</pre> <p>Certificate authentication is not enabled by default on a Windows host but can be enabled by running the following in PowerShell:</p> <pre data-language="YAML+Jinja">Set-Item -Path WSMan:\localhost\Service\Auth\Certificate -Value $true
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Encrypted private keys cannot be used as the urllib3 library that is used by Ansible for WinRM does not support this functionality.</p> </div>  <h4 id="generate-a-certificate">Generate a Certificate</h4> <p>A certificate must be generated before it can be mapped to a local user. This can be done using one of the following methods:</p> <ul class="simple"> <li>OpenSSL</li> <li>PowerShell, using the <code>New-SelfSignedCertificate</code> cmdlet</li> <li>Active Directory Certificate Services</li> </ul> <p>Active Directory Certificate Services is beyond of scope in this documentation but may be the best option to use when running in a domain environment. For more information, see the <a class="reference external" href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2008-R2-and-2008/cc732625(v=ws.11)">Active Directory Certificate Services documentation</a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Using the PowerShell cmdlet <code>New-SelfSignedCertificate</code> to generate a certificate for authentication only works when being generated from a Windows 10 or Windows Server 2012 R2 host or later. OpenSSL is still required to extract the private key from the PFX certificate to a PEM file for Ansible to use.</p> </div> <p>To generate a certificate with <code>OpenSSL</code>:</p> <pre data-language="shell"># Set the name of the local user that will have the key mapped to
USERNAME="username"

cat &gt; openssl.conf &lt;&lt; EOL
distinguished_name = req_distinguished_name
[req_distinguished_name]
[v3_req_client]
extendedKeyUsage = clientAuth
subjectAltName = otherName:1.3.6.1.4.1.311.20.2.3;UTF8:$USERNAME@localhost
EOL

export OPENSSL_CONF=openssl.conf
openssl req -x509 -nodes -days 3650 -newkey rsa:2048 -out cert.pem -outform PEM -keyout cert_key.pem -subj "/CN=$USERNAME" -extensions v3_req_client
rm openssl.conf
</pre> <p>To generate a certificate with <code>New-SelfSignedCertificate</code>:</p> <pre data-language="powershell"># Set the name of the local user that will have the key mapped
$username = "username"
$output_path = "C:\temp"

# Instead of generating a file, the cert will be added to the personal
# LocalComputer folder in the certificate store
$cert = New-SelfSignedCertificate -Type Custom `
    -Subject "CN=$username" `
    -TextExtension @("2.5.29.37={text}1.3.6.1.5.5.7.3.2","2.5.29.17={text}upn=$username@localhost") `
    -KeyUsage DigitalSignature,KeyEncipherment `
    -KeyAlgorithm RSA `
    -KeyLength 2048

# Export the public key
$pem_output = @()
$pem_output += "-----BEGIN CERTIFICATE-----"
$pem_output += [System.Convert]::ToBase64String($cert.RawData) -replace ".{64}", "$&amp;`n"
$pem_output += "-----END CERTIFICATE-----"
[System.IO.File]::WriteAllLines("$output_path\cert.pem", $pem_output)

# Export the private key in a PFX file
[System.IO.File]::WriteAllBytes("$output_path\cert.pfx", $cert.Export("Pfx"))
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>To convert the PFX file to a private key that pywinrm can use, run the following command with OpenSSL <code>openssl pkcs12 -in cert.pfx -nocerts -nodes -out cert_key.pem -passin pass: -passout pass:</code></p> </div>   <h4 id="import-a-certificate-to-the-certificate-store">Import a Certificate to the Certificate Store</h4> <p>Once a certificate has been generated, the issuing certificate needs to be imported into the <code>Trusted Root Certificate Authorities</code> of the <code>LocalMachine</code> store, and the client certificate public key must be present in the <code>Trusted People</code> folder of the <code>LocalMachine</code> store. For this example, both the issuing certificate and public key are the same.</p> <p>Following example shows how to import the issuing certificate:</p> <pre data-language="powershell">$cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
$cert.Import("cert.pem")

$store_name = [System.Security.Cryptography.X509Certificates.StoreName]::Root
$store_location = [System.Security.Cryptography.X509Certificates.StoreLocation]::LocalMachine
$store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
$store.Open("MaxAllowed")
$store.Add($cert)
$store.Close()
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If using ADCS to generate the certificate, then the issuing certificate will already be imported and this step can be skipped.</p> </div> <p>The code to import the client certificate public key is:</p> <pre data-language="powershell">$cert = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Certificate2
$cert.Import("cert.pem")

$store_name = [System.Security.Cryptography.X509Certificates.StoreName]::TrustedPeople
$store_location = [System.Security.Cryptography.X509Certificates.StoreLocation]::LocalMachine
$store = New-Object -TypeName System.Security.Cryptography.X509Certificates.X509Store -ArgumentList $store_name, $store_location
$store.Open("MaxAllowed")
$store.Add($cert)
$store.Close()
</pre>   <h4 id="mapping-a-certificate-to-an-account">Mapping a Certificate to an Account</h4> <p>Once the certificate has been imported, map it to the local user account:</p> <pre data-language="YAML+Jinja">$username = "username"
$password = ConvertTo-SecureString -String "password" -AsPlainText -Force
$credential = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $username, $password

# This is the issuer thumbprint which in the case of a self generated cert
# is the public key thumbprint, additional logic may be required for other
# scenarios
$thumbprint = (Get-ChildItem -Path cert:\LocalMachine\root | Where-Object { $_.Subject -eq "CN=$username" }).Thumbprint

New-Item -Path WSMan:\localhost\ClientCertificate `
    -Subject "$username@localhost" `
    -URI * `
    -Issuer $thumbprint `
    -Credential $credential `
    -Force
</pre> <p>Once this is complete, the hostvar <code>ansible_winrm_cert_pem</code> should be set to the path of the public key and the <code>ansible_winrm_cert_key_pem</code> variable should be set to the path of the private key.</p>    <h3 id="ntlm">NTLM</h3> <p>NTLM is an older authentication mechanism used by Microsoft that can support both local and domain accounts. NTLM is enabled by default on the WinRM service, so no setup is required before using it.</p> <p>NTLM is the easiest authentication protocol to use and is more secure than <code>Basic</code> authentication. If running in a domain environment, <code>Kerberos</code> should be used instead of NTLM.</p> <p>Kerberos has several advantages over using NTLM:</p> <ul class="simple"> <li>NTLM is an older protocol and does not support newer encryption protocols.</li> <li>NTLM is slower to authenticate because it requires more round trips to the host in the authentication stage.</li> <li>Unlike Kerberos, NTLM does not allow credential delegation.</li> </ul> <p>This example shows host variables configured to use NTLM authentication:</p> <pre data-language="yaml+jinja">ansible_user: LocalUsername
ansible_password: Password
ansible_connection: winrm
ansible_winrm_transport: ntlm
</pre>   <h3 id="kerberos">Kerberos</h3> <p>Kerberos is the recommended authentication option to use when running in a domain environment. Kerberos supports features like credential delegation and message encryption over HTTP and is one of the more secure options that is available through WinRM.</p> <p>Kerberos requires some additional setup work on the Ansible host before it can be used properly.</p> <p>The following example shows host vars configured for Kerberos authentication:</p> <pre data-language="yaml+jinja">ansible_user: username@MY.DOMAIN.COM
ansible_password: Password
ansible_connection: winrm
ansible_port: 5985
ansible_winrm_transport: kerberos
</pre> <p>As of Ansible version 2.3, the Kerberos ticket will be created based on <code>ansible_user</code> and <code>ansible_password</code>. If running on an older version of Ansible or when <code>ansible_winrm_kinit_mode</code> is <code>manual</code>, a Kerberos ticket must already be obtained. See below for more details.</p> <p>There are some extra host variables that can be set:</p> <pre data-language="YAML+Jinja">ansible_winrm_kinit_mode: managed/manual (manual means Ansible will not obtain a ticket)
ansible_winrm_kinit_cmd: the kinit binary to use to obtain a Kerberos ticket (default to kinit)
ansible_winrm_service: overrides the SPN prefix that is used, the default is ``HTTP`` and should rarely ever need changing
ansible_winrm_kerberos_delegation: allows the credentials to traverse multiple hops
ansible_winrm_kerberos_hostname_override: the hostname to be used for the kerberos exchange
</pre>  <h4 id="installing-the-kerberos-library">Installing the Kerberos Library</h4> <p>Some system dependencies that must be installed prior to using Kerberos. The script below lists the dependencies based on the distro:</p> <pre data-language="shell"># Via Yum (RHEL/Centos/Fedora)
yum -y install gcc python-devel krb5-devel krb5-libs krb5-workstation

# Via Apt (Ubuntu)
sudo apt-get install python-dev libkrb5-dev krb5-user

# Via Portage (Gentoo)
emerge -av app-crypt/mit-krb5
emerge -av dev-python/setuptools

# Via Pkg (FreeBSD)
sudo pkg install security/krb5

# Via OpenCSW (Solaris)
pkgadd -d http://get.opencsw.org/now
/opt/csw/bin/pkgutil -U
/opt/csw/bin/pkgutil -y -i libkrb5_3

# Via Pacman (Arch Linux)
pacman -S krb5
</pre> <p>Once the dependencies have been installed, the <code>python-kerberos</code> wrapper can be install using <code>pip</code>:</p> <pre data-language="shell">pip install pywinrm[kerberos]
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>While Ansible has supported Kerberos auth through <code>pywinrm</code> for some time, optional features or more secure options may only be available in newer versions of the <code>pywinrm</code> and/or <code>pykerberos</code> libraries. It is recommended you upgrade each version to the latest available to resolve any warnings or errors. This can be done through tools like <code>pip</code> or a system package manager like <code>dnf</code>, <code>yum</code>, <code>apt</code> but the package names and versions available may differ between tools.</p> </div>   <h4 id="configuring-host-kerberos">Configuring Host Kerberos</h4> <p>Once the dependencies have been installed, Kerberos needs to be configured so that it can communicate with a domain. This configuration is done through the <code>/etc/krb5.conf</code> file, which is installed with the packages in the script above.</p> <p>To configure Kerberos, in the section that starts with:</p> <pre data-language="ini">[realms]
</pre> <p>Add the full domain name and the fully qualified domain names of the primary and secondary Active Directory domain controllers. It should look something like this:</p> <pre data-language="ini">[realms]
    MY.DOMAIN.COM = {
        kdc = domain-controller1.my.domain.com
        kdc = domain-controller2.my.domain.com
    }
</pre> <p>In the section that starts with:</p> <pre data-language="ini">[domain_realm]
</pre> <p>Add a line like the following for each domain that Ansible needs access for:</p> <pre data-language="ini">[domain_realm]
    .my.domain.com = MY.DOMAIN.COM
</pre> <p>You can configure other settings in this file such as the default domain. See <a class="reference external" href="https://web.mit.edu/kerberos/krb5-1.12/doc/admin/conf_files/krb5_conf.html">krb5.conf</a> for more details.</p>   <h4 id="automatic-kerberos-ticket-management">Automatic Kerberos Ticket Management</h4> <p>Ansible version 2.3 and later defaults to automatically managing Kerberos tickets when both <code>ansible_user</code> and <code>ansible_password</code> are specified for a host. In this process, a new ticket is created in a temporary credential cache for each host. This is done before each task executes to minimize the chance of ticket expiration. The temporary credential caches are deleted after each task completes and will not interfere with the default credential cache.</p> <p>To disable automatic ticket management, set <code>ansible_winrm_kinit_mode=manual</code> via the inventory.</p> <p>Automatic ticket management requires a standard <code>kinit</code> binary on the control host system path. To specify a different location or binary name, set the <code>ansible_winrm_kinit_cmd</code> hostvar to the fully qualified path to a MIT krbv5 <code>kinit</code>-compatible binary.</p>   <h4 id="manual-kerberos-ticket-management">Manual Kerberos Ticket Management</h4> <p>To manually manage Kerberos tickets, the <code>kinit</code> binary is used. To obtain a new ticket the following command is used:</p> <pre data-language="shell">kinit username@MY.DOMAIN.COM
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The domain must match the configured Kerberos realm exactly, and must be in upper case.</p> </div> <p>To see what tickets (if any) have been acquired, use the following command:</p> <pre data-language="shell">klist
</pre> <p>To destroy all the tickets that have been acquired, use the following command:</p> <pre data-language="shell">kdestroy
</pre>   <h4 id="troubleshooting-kerberos">Troubleshooting Kerberos</h4> <p>Kerberos is reliant on a properly-configured environment to work. To troubleshoot Kerberos issues, ensure that:</p> <ul> <li>The hostname set for the Windows host is the FQDN and not an IP address.</li> <li>The forward and reverse DNS lookups are working properly in the domain. To test this, ping the windows host by name and then use the ip address returned with <code>nslookup</code>. The same name should be returned when using <code>nslookup</code> on the IP address.</li> <li>The Ansible host’s clock is synchronized with the domain controller. Kerberos is time sensitive, and a little clock drift can cause the ticket generation process to fail.</li> <li>
<p>Ensure that the fully qualified domain name for the domain is configured in the <code>krb5.conf</code> file. To check this, run:</p> <pre data-language="YAML+Jinja">kinit -C username@MY.DOMAIN.COM
klist
</pre> <p>If the domain name returned by <code>klist</code> is different from the one requested, an alias is being used. The <code>krb5.conf</code> file needs to be updated so that the fully qualified domain name is used and not an alias.</p> </li> <li>If the default kerberos tooling has been replaced or modified (some IdM solutions may do this), this may cause issues when installing or upgrading the Python Kerberos library. As of the time of this writing, this library is called <code>pykerberos</code> and is known to work with both MIT and Heimdal Kerberos libraries. To resolve <code>pykerberos</code> installation issues, ensure the system dependencies for Kerberos have been met (see: <a class="reference internal" href="#installing-the-kerberos-library">Installing the Kerberos Library</a>), remove any custom Kerberos tooling paths from the PATH environment variable, and retry the installation of Python Kerberos library package.</li> </ul>    <h3 id="credssp">CredSSP</h3> <p>CredSSP authentication is a newer authentication protocol that allows credential delegation. This is achieved by encrypting the username and password after authentication has succeeded and sending that to the server using the CredSSP protocol.</p> <p>Because the username and password are sent to the server to be used for double hop authentication, ensure that the hosts that the Windows host communicates with are not compromised and are trusted.</p> <p>CredSSP can be used for both local and domain accounts and also supports message encryption over HTTP.</p> <p>To use CredSSP authentication, the host vars are configured like so:</p> <pre data-language="yaml+jinja">ansible_user: Username
ansible_password: Password
ansible_connection: winrm
ansible_winrm_transport: credssp
</pre> <p>There are some extra host variables that can be set as shown below:</p> <pre data-language="YAML+Jinja">ansible_winrm_credssp_disable_tlsv1_2: when true, will not use TLS 1.2 in the CredSSP auth process
</pre> <p>CredSSP authentication is not enabled by default on a Windows host, but can be enabled by running the following in PowerShell:</p> <pre data-language="powershell">Enable-WSManCredSSP -Role Server -Force
</pre>  <h4 id="installing-credssp-library">Installing CredSSP Library</h4> <p>The <code>requests-credssp</code> wrapper can be installed using <code>pip</code>:</p> <pre data-language="bash">pip install pywinrm[credssp]
</pre>   <h4 id="credssp-and-tls-1-2">CredSSP and TLS 1.2</h4> <p>By default the <code>requests-credssp</code> library is configured to authenticate over the TLS 1.2 protocol. TLS 1.2 is installed and enabled by default for Windows Server 2012 and Windows 8 and more recent releases.</p> <p>There are two ways that older hosts can be used with CredSSP:</p> <ul class="simple"> <li>Install and enable a hotfix to enable TLS 1.2 support (recommended for Server 2008 R2 and Windows 7).</li> <li>Set <code>ansible_winrm_credssp_disable_tlsv1_2=True</code> in the inventory to run over TLS 1.0. This is the only option when connecting to Windows Server 2008, which has no way of supporting TLS 1.2</li> </ul> <p>See <a class="reference internal" href="#winrm-tls12"><span class="std std-ref">TLS 1.2 Support</span></a> for more information on how to enable TLS 1.2 on the Windows host.</p>   <h4 id="set-credssp-certificate">Set CredSSP Certificate</h4> <p>CredSSP works by encrypting the credentials through the TLS protocol and uses a self-signed certificate by default. The <code>CertificateThumbprint</code> option under the WinRM service configuration can be used to specify the thumbprint of another certificate.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This certificate configuration is independent of the WinRM listener certificate. With CredSSP, message transport still occurs over the WinRM listener, but the TLS-encrypted messages inside the channel use the service-level certificate.</p> </div> <p>To explicitly set the certificate to use for CredSSP:</p> <pre data-language="YAML+Jinja"># Note the value $certificate_thumbprint will be different in each
# situation, this needs to be set based on the cert that is used.
$certificate_thumbprint = "7C8DCBD5427AFEE6560F4AF524E325915F51172C"

# Set the thumbprint value
Set-Item -Path WSMan:\localhost\Service\CertificateThumbprint -Value $certificate_thumbprint
</pre>     <h2 id="non-administrator-accounts">Non-Administrator Accounts</h2> <p>WinRM is configured by default to only allow connections from accounts in the local <code>Administrators</code> group. This can be changed by running:</p> <pre data-language="powershell">winrm configSDDL default
</pre> <p>This will display an ACL editor, where new users or groups may be added. To run commands over WinRM, users and groups must have at least the <code>Read</code> and <code>Execute</code> permissions enabled.</p> <p>While non-administrative accounts can be used with WinRM, most typical server administration tasks require some level of administrative access, so the utility is usually limited.</p>   <h2 id="winrm-encryption">WinRM Encryption</h2> <p>By default WinRM will fail to work when running over an unencrypted channel. The WinRM protocol considers the channel to be encrypted if using TLS over HTTP (HTTPS) or using message level encryption. Using WinRM with TLS is the recommended option as it works with all authentication options, but requires a certificate to be created and used on the WinRM listener.</p> <p>The <code>ConfigureRemotingForAnsible.ps1</code> creates a self-signed certificate and creates the listener with that certificate. If in a domain environment, ADCS can also create a certificate for the host that is issued by the domain itself.</p> <p>If using HTTPS is not an option, then HTTP can be used when the authentication option is <code>NTLM</code>, <code>Kerberos</code> or <code>CredSSP</code>. These protocols will encrypt the WinRM payload with their own encryption method before sending it to the server. The message-level encryption is not used when running over HTTPS because the encryption uses the more secure TLS protocol instead. If both transport and message encryption is required, set <code>ansible_winrm_message_encryption=always</code> in the host vars.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Message encryption over HTTP requires pywinrm&gt;=0.3.0.</p> </div> <p>A last resort is to disable the encryption requirement on the Windows host. This should only be used for development and debugging purposes, as anything sent from Ansible can be viewed, manipulated and also the remote session can completely be taken over by anyone on the same network. To disable the encryption requirement:</p> <pre data-language="YAML+Jinja">Set-Item -Path WSMan:\localhost\Service\AllowUnencrypted -Value $true
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Do not disable the encryption check unless it is absolutely required. Doing so could allow sensitive information like credentials and files to be intercepted by others on the network.</p> </div>   <h2 id="inventory-options">Inventory Options</h2> <p>Ansible’s Windows support relies on a few standard variables to indicate the username, password, and connection type of the remote hosts. These variables are most easily set up in the inventory, but can be set on the <code>host_vars</code>/ <code>group_vars</code> level.</p> <p>When setting up the inventory, the following variables are required:</p> <pre data-language="yaml+jinja"># It is suggested that these be encrypted with ansible-vault:
# ansible-vault edit group_vars/windows.yml
ansible_connection: winrm

# May also be passed on the command-line via --user
ansible_user: Administrator

# May also be supplied at runtime with --ask-pass
ansible_password: SecretPasswordGoesHere
</pre> <p>Using the variables above, Ansible will connect to the Windows host with Basic authentication through HTTPS. If <code>ansible_user</code> has a UPN value like <code>username@MY.DOMAIN.COM</code> then the authentication option will automatically attempt to use Kerberos unless <code>ansible_winrm_transport</code> has been set to something other than <code>kerberos</code>.</p> <p>The following custom inventory variables are also supported for additional configuration of WinRM connections:</p> <ul class="simple"> <li>
<code>ansible_port</code>: The port WinRM will run over, HTTPS is <code>5986</code> which is the default while HTTP is <code>5985</code>
</li> <li>
<code>ansible_winrm_scheme</code>: Specify the connection scheme (<code>http</code> or <code>https</code>) to use for the WinRM connection. Ansible uses <code>https</code> by default unless <code>ansible_port</code> is <code>5985</code>
</li> <li>
<code>ansible_winrm_path</code>: Specify an alternate path to the WinRM endpoint, Ansible uses <code>/wsman</code> by default</li> <li>
<code>ansible_winrm_realm</code>: Specify the realm to use for Kerberos authentication. If <code>ansible_user</code> contains <code>@</code>, Ansible will use the part of the username after <code>@</code> by default</li> <li>
<code>ansible_winrm_transport</code>: Specify one or more authentication transport options as a comma-separated list. By default, Ansible will use <code>kerberos,
basic</code> if the <code>kerberos</code> module is installed and a realm is defined, otherwise it will be <code>plaintext</code>
</li> <li>
<code>ansible_winrm_server_cert_validation</code>: Specify the server certificate validation mode (<code>ignore</code> or <code>validate</code>). Ansible defaults to <code>validate</code> on Python 2.7.9 and higher, which will result in certificate validation errors against the Windows self-signed certificates. Unless verifiable certificates have been configured on the WinRM listeners, this should be set to <code>ignore</code>
</li> <li>
<code>ansible_winrm_operation_timeout_sec</code>: Increase the default timeout for WinRM operations, Ansible uses <code>20</code> by default</li> <li>
<code>ansible_winrm_read_timeout_sec</code>: Increase the WinRM read timeout, Ansible uses <code>30</code> by default. Useful if there are intermittent network issues and read timeout errors keep occurring</li> <li>
<code>ansible_winrm_message_encryption</code>: Specify the message encryption operation (<code>auto</code>, <code>always</code>, <code>never</code>) to use, Ansible uses <code>auto</code> by default. <code>auto</code> means message encryption is only used when <code>ansible_winrm_scheme</code> is <code>http</code> and <code>ansible_winrm_transport</code> supports message encryption. <code>always</code> means message encryption will always be used and <code>never</code> means message encryption will never be used</li> <li>
<code>ansible_winrm_ca_trust_path</code>: Used to specify a different cacert container than the one used in the <code>certifi</code> module. See the HTTPS Certificate Validation section for more details.</li> <li>
<code>ansible_winrm_send_cbt</code>: When using <code>ntlm</code> or <code>kerberos</code> over HTTPS, the authentication library will try to send channel binding tokens to mitigate against man in the middle attacks. This flag controls whether these bindings will be sent or not (default: <code>yes</code>).</li> <li>
<code>ansible_winrm_*</code>: Any additional keyword arguments supported by <code>winrm.Protocol</code> may be provided in place of <code>*</code>
</li> </ul> <p>In addition, there are also specific variables that need to be set for each authentication option. See the section on authentication above for more information.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Ansible 2.0 has deprecated the “ssh” from <code>ansible_ssh_user</code>, <code>ansible_ssh_pass</code>, <code>ansible_ssh_host</code>, and <code>ansible_ssh_port</code> to become <code>ansible_user</code>, <code>ansible_password</code>, <code>ansible_host</code>, and <code>ansible_port</code>. If using a version of Ansible prior to 2.0, the older style (<code>ansible_ssh_*</code>) should be used instead. The shorter variables are ignored, without warning, in older versions of Ansible.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>ansible_winrm_message_encryption</code> is different from transport encryption done over TLS. The WinRM payload is still encrypted with TLS when run over HTTPS, even if <code>ansible_winrm_message_encryption=never</code>.</p> </div>   <h2 id="ipv6-addresses">IPv6 Addresses</h2> <p>IPv6 addresses can be used instead of IPv4 addresses or hostnames. This option is normally set in an inventory. Ansible will attempt to parse the address using the <a class="reference external" href="https://docs.python.org/3/library/ipaddress.html">ipaddress</a> package and pass to pywinrm correctly.</p> <p>When defining a host using an IPv6 address, just add the IPv6 address as you would an IPv4 address or hostname:</p> <pre data-language="ini">[windows-server]
2001:db8::1

[windows-server:vars]
ansible_user=username
ansible_password=password
ansible_connection=winrm
</pre> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The ipaddress library is only included by default in Python 3.x. To use IPv6 addresses in Python 2.7, make sure to run <code>pip install ipaddress</code> which installs a backported package.</p> </div>   <h2 id="https-certificate-validation">HTTPS Certificate Validation</h2> <p>As part of the TLS protocol, the certificate is validated to ensure the host matches the subject and the client trusts the issuer of the server certificate. When using a self-signed certificate or setting <code>ansible_winrm_server_cert_validation: ignore</code> these security mechanisms are bypassed. While self signed certificates will always need the <code>ignore</code> flag, certificates that have been issued from a certificate authority can still be validated.</p> <p>One of the more common ways of setting up a HTTPS listener in a domain environment is to use Active Directory Certificate Service (AD CS). AD CS is used to generate signed certificates from a Certificate Signing Request (CSR). If the WinRM HTTPS listener is using a certificate that has been signed by another authority, like AD CS, then Ansible can be set up to trust that issuer as part of the TLS handshake.</p> <p>To get Ansible to trust a Certificate Authority (CA) like AD CS, the issuer certificate of the CA can be exported as a PEM encoded certificate. This certificate can then be copied locally to the Ansible controller and used as a source of certificate validation, otherwise known as a CA chain.</p> <p>The CA chain can contain a single or multiple issuer certificates and each entry is contained on a new line. To then use the custom CA chain as part of the validation process, set <code>ansible_winrm_ca_trust_path</code> to the path of the file. If this variable is not set, the default CA chain is used instead which is located in the install path of the Python package <a class="reference external" href="https://github.com/certifi/python-certifi">certifi</a>.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Each HTTP call is done by the Python requests library which does not use the systems built-in certificate store as a trust authority. Certificate validation will fail if the server’s certificate issuer is only added to the system’s truststore.</p> </div>   <h2 id="winrm-tls12">TLS 1.2 Support</h2> <p id="tls-1-2-support">As WinRM runs over the HTTP protocol, using HTTPS means that the TLS protocol is used to encrypt the WinRM messages. TLS will automatically attempt to negotiate the best protocol and cipher suite that is available to both the client and the server. If a match cannot be found then Ansible will error out with a message similar to:</p> <pre data-language="YAML+Jinja">HTTPSConnectionPool(host='server', port=5986): Max retries exceeded with url: /wsman (Caused by SSLError(SSLError(1, '[SSL: UNSUPPORTED_PROTOCOL] unsupported protocol (_ssl.c:1056)')))
</pre> <p>Commonly this is when the Windows host has not been configured to support TLS v1.2 but it could also mean the Ansible controller has an older OpenSSL version installed.</p> <p>Windows 8 and Windows Server 2012 come with TLS v1.2 installed and enabled by default but older hosts, like Server 2008 R2 and Windows 7, have to be enabled manually.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>There is a bug with the TLS 1.2 patch for Server 2008 which will stop Ansible from connecting to the Windows host. This means that Server 2008 cannot be configured to use TLS 1.2. Server 2008 R2 and Windows 7 are not affected by this issue and can use TLS 1.2.</p> </div> <p>To verify what protocol the Windows host supports, you can run the following command on the Ansible controller:</p> <pre data-language="YAML+Jinja">openssl s_client -connect &lt;hostname&gt;:5986
</pre> <p>The output will contain information about the TLS session and the <code>Protocol</code> line will display the version that was negotiated:</p> <pre data-language="YAML+Jinja">New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-SHA
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1
    Cipher    : ECDHE-RSA-AES256-SHA
    Session-ID: 962A00001C95D2A601BE1CCFA7831B85A7EEE897AECDBF3D9ECD4A3BE4F6AC9B
    Session-ID-ctx:
    Master-Key: ....
    Start Time: 1552976474
    Timeout   : 7200 (sec)
    Verify return code: 21 (unable to verify the first certificate)
---

New, TLSv1/SSLv3, Cipher is ECDHE-RSA-AES256-GCM-SHA384
Server public key is 2048 bit
Secure Renegotiation IS supported
Compression: NONE
Expansion: NONE
No ALPN negotiated
SSL-Session:
    Protocol  : TLSv1.2
    Cipher    : ECDHE-RSA-AES256-GCM-SHA384
    Session-ID: AE16000050DA9FD44D03BB8839B64449805D9E43DBD670346D3D9E05D1AEEA84
    Session-ID-ctx:
    Master-Key: ....
    Start Time: 1552976538
    Timeout   : 7200 (sec)
    Verify return code: 21 (unable to verify the first certificate)
</pre> <p>If the host is returning <code>TLSv1</code> then it should be configured so that TLS v1.2 is enable. You can do this by running the following PowerShell script:</p> <pre data-language="powershell">Function Enable-TLS12 {
    param(
        [ValidateSet("Server", "Client")]
        [String]$Component = "Server"
    )

    $protocols_path = 'HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols'
    New-Item -Path "$protocols_path\TLS 1.2\$Component" -Force
    New-ItemProperty -Path "$protocols_path\TLS 1.2\$Component" -Name Enabled -Value 1 -Type DWORD -Force
    New-ItemProperty -Path "$protocols_path\TLS 1.2\$Component" -Name DisabledByDefault -Value 0 -Type DWORD -Force
}

Enable-TLS12 -Component Server

# Not required but highly recommended to enable the Client side TLS 1.2 components
Enable-TLS12 -Component Client

Restart-Computer
</pre> <p>The below Ansible tasks can also be used to enable TLS v1.2:</p> <pre data-language="yaml+jinja">- name: enable TLSv1.2 support
  win_regedit:
    path: HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\SCHANNEL\Protocols\TLS 1.2\{{ item.type }}
    name: '{{ item.property }}'
    data: '{{ item.value }}'
    type: dword
    state: present
  register: enable_tls12
  loop:
  - type: Server
    property: Enabled
    value: 1
  - type: Server
    property: DisabledByDefault
    value: 0
  - type: Client
    property: Enabled
    value: 1
  - type: Client
    property: DisabledByDefault
    value: 0

- name: reboot if TLS config was applied
  win_reboot:
  when: enable_tls12 is changed
</pre> <p>There are other ways to configure the TLS protocols as well as the cipher suites that are offered by the Windows host. One tool that can give you a GUI to manage these settings is <a class="reference external" href="https://www.nartac.com/Products/IISCrypto/">IIS Crypto</a> from Nartac Software.</p>   <h2 id="limitations">Limitations</h2> <p>Due to the design of the WinRM protocol , there are a few limitations when using WinRM that can cause issues when creating playbooks for Ansible. These include:</p> <ul class="simple"> <li>Credentials are not delegated for most authentication types, which causes authentication errors when accessing network resources or installing certain programs.</li> <li>Many calls to the Windows Update API are blocked when running over WinRM.</li> <li>Some programs fail to install with WinRM due to no credential delegation or because they access forbidden Windows API like WUA over WinRM.</li> <li>Commands under WinRM are done under a non-interactive session, which can prevent certain commands or executables from running.</li> <li>You cannot run a process that interacts with <code>DPAPI</code>, which is used by some installers (like Microsoft SQL Server).</li> </ul> <p>Some of these limitations can be mitigated by doing one of the following:</p> <ul class="simple"> <li>Set <code>ansible_winrm_transport</code> to <code>credssp</code> or <code>kerberos</code> (with <code>ansible_winrm_kerberos_delegation=true</code>) to bypass the double hop issue and access network resources</li> <li>Use <code>become</code> to bypass all WinRM restrictions and run a command as it would locally. Unlike using an authentication transport like <code>credssp</code>, this will also remove the non-interactive restriction and API restrictions like WUA and DPAPI</li> <li>Use a scheduled task to run a command which can be created with the <code>win_scheduled_task</code> module. Like <code>become</code>, this bypasses all WinRM restrictions but can only run a command and not modules.</li> </ul> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="playbooks_intro.html#playbooks-intro"><span class="std std-ref">Intro to playbooks</span></a></dt>
<dd>
<p>An introduction to playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_best_practices.html#playbooks-best-practices"><span class="std std-ref">Tips and tricks</span></a></dt>
<dd>
<p>Tips and tricks for playbooks</p> </dd> <dt><a class="reference external" href="https://docs.ansible.com/ansible/2.9/modules/list_of_windows_modules.html#windows-modules" title="(in Ansible v2.9)"><span class="xref std std-ref">List of Windows Modules</span></a></dt>
<dd>
<p>Windows specific module list, all implemented in PowerShell</p> </dd> <dt><a class="reference external" href="https://groups.google.com/group/ansible-project">User Mailing List</a></dt>
<dd>
<p>Have a question? Stop by the google group!</p> </dd> <dt><a class="reference external" href="https://libera.chat/">irc.libera.chat</a></dt>
<dd>
<p>#ansible IRC chat channel</p> </dd> </dl> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2021 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/user_guide/windows_winrm.html</a>
  </p>
</div>
