<section id="roles"> <h1 id="playbooks-reuse-roles">Roles</h1> <p>Roles let you automatically load related vars, files, tasks, handlers, and other Ansible artifacts based on a known file structure. After you group your content into roles, you can easily reuse them and share them with other users.</p>  <ul class="simple"> <li><a class="reference internal" href="#role-directory-structure" id="id3">Role directory structure</a></li> <li><a class="reference internal" href="#storing-and-finding-roles" id="id4">Storing and finding roles</a></li> <li>
<p><a class="reference internal" href="#using-roles" id="id5">Using roles</a></p> <ul> <li><a class="reference internal" href="#using-roles-at-the-play-level" id="id6">Using roles at the play level</a></li> <li><a class="reference internal" href="#including-roles-dynamic-reuse" id="id7">Including roles: dynamic reuse</a></li> <li><a class="reference internal" href="#importing-roles-static-reuse" id="id8">Importing roles: static reuse</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#role-argument-validation" id="id9">Role argument validation</a></p> <ul> <li><a class="reference internal" href="#specification-format" id="id10">Specification format</a></li> <li><a class="reference internal" href="#sample-specification" id="id11">Sample specification</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#running-a-role-multiple-times-in-one-play" id="id12">Running a role multiple times in one play</a></p> <ul> <li><a class="reference internal" href="#passing-different-parameters" id="id13">Passing different parameters</a></li> <li><a class="reference internal" href="#using-allow-duplicates-true" id="id14">Using <code>allow_duplicates: true</code></a></li> </ul> </li> <li>
<p><a class="reference internal" href="#using-role-dependencies" id="id15">Using role dependencies</a></p> <ul> <li><a class="reference internal" href="#running-role-dependencies-multiple-times-in-one-play" id="id16">Running role dependencies multiple times in one play</a></li> </ul> </li> <li><a class="reference internal" href="#embedding-modules-and-plugins-in-roles" id="id17">Embedding modules and plugins in roles</a></li> <li><a class="reference internal" href="#sharing-roles-ansible-galaxy" id="id18">Sharing roles: Ansible Galaxy</a></li> </ul>  <section id="role-directory-structure"> <h2 id="id1">Role directory structure</h2> <p>An Ansible role has a defined directory structure with seven main standard directories. You must include at least one of these directories in each role. You can omit any directories the role does not use. For example:</p> <pre data-language="text"># playbooks
site.yml
webservers.yml
fooservers.yml
</pre> <pre data-language="yaml">roles/
    common/               # this hierarchy represents a "role"
        tasks/            #
            main.yml      #  &lt;-- tasks file can include smaller files if warranted
        handlers/         #
            main.yml      #  &lt;-- handlers file
        templates/        #  &lt;-- files for use with the template resource
            ntp.conf.j2   #  &lt;------- templates end in .j2
        files/            #
            bar.txt       #  &lt;-- files for use with the copy resource
            foo.sh        #  &lt;-- script files for use with the script resource
        vars/             #
            main.yml      #  &lt;-- variables associated with this role
        defaults/         #
            main.yml      #  &lt;-- default lower priority variables for this role
        meta/             #
            main.yml      #  &lt;-- role dependencies
        library/          # roles can also include custom modules
        module_utils/     # roles can also include custom module_utils
        lookup_plugins/   # or other types of plugins, like lookup in this case

    webtier/              # same kind of structure as "common" was above, done for the webtier role
    monitoring/           # ""
    fooapp/               # ""
</pre> <p>By default, Ansible will look in most role directories for a <code>main.yml</code> file for relevant content (also <code>main.yaml</code> and <code>main</code>):</p> <ul class="simple"> <li>
<code>tasks/main.yml</code> - A list of tasks that the role provides to the play for execution.</li> <li>
<code>handlers/main.yml</code> - handlers that are imported into the parent play for use by the role or other roles and tasks in the play.</li> <li>
<code>defaults/main.yml</code> - very low precedence values for variables provided by the role (see <a class="reference internal" href="playbooks_variables.html#playbooks-variables"><span class="std std-ref">Using Variables</span></a> for more information). A role’s own defaults will take priority over other role’s defaults, but any/all other variable sources will override this.</li> <li>
<code>vars/main.yml</code> - high precedence variables provided by the role to the play (see <a class="reference internal" href="playbooks_variables.html#playbooks-variables"><span class="std std-ref">Using Variables</span></a> for more information).</li> <li>
<code>files/stuff.txt</code> - one or more files that are available for the role and it’s children.</li> <li>
<code>templates/something.j2</code> - templates to use in the role or child roles.</li> <li>
<code>meta/main.yml</code> - metadata for the role, including role dependencies and optional Galaxy metadata such as platforms supported. This is required for uploading into galaxy as a standalone role, but not for using the role in your play.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <ul class="simple"> <li>None of the files above are required for a role. For example, you can just provide <code>files/something.txt</code> or <code>vars/for_import.yml</code> and it will still be a valid role.</li> <li>On stand alone roles you can also include custom modules and/or plugins, for example <code>library/my_module.py</code>, which may be used within this role (see <a class="reference internal" href="#embedding-modules-and-plugins-in-roles"><span class="std std-ref">Embedding modules and plugins in roles</span></a> for more information).</li> <li>A ‘stand alone’ role refers to role that is not part of a collection but as individually installable content.</li> <li>Variables from <code>vars/</code> and <code>defaults/</code> are imported into play scope unless you disable it via the <code>public</code> option in <code>import_role</code>/<code>include_role</code>.</li> </ul> </div> <p>You can add other YAML files in some directories, but they won’t be used by default. They can be included/imported directly or specified when using <code>include_role/import_role</code>. For example, you can place platform-specific tasks in separate files and refer to them in the <code>tasks/main.yml</code> file:</p> <pre data-language="yaml"># roles/example/tasks/main.yml
- name: Install the correct web server for RHEL
  import_tasks: redhat.yml
  when: ansible_facts['os_family']|lower == 'redhat'

- name: Install the correct web server for Debian
  import_tasks: debian.yml
  when: ansible_facts['os_family']|lower == 'debian'

# roles/example/tasks/redhat.yml
- name: Install web server
  ansible.builtin.yum:
    name: "httpd"
    state: present

# roles/example/tasks/debian.yml
- name: Install web server
  ansible.builtin.apt:
    name: "apache2"
    state: present
</pre> <p>Or call those tasks directly when loading the role, which bypasses the <code>main.yml</code> files:</p> <pre data-language="yaml">- name: include apt tasks
  include_role:
      name: package_manager_bootstrap
      tasks_from: apt.yml
  when: ansible_facts['os_family'] == 'Debian'
</pre> <p>Directories <code>defaults</code> and <code>vars</code> may also include <em>nested directories</em>. If your variables file is a directory, Ansible reads all variables files and directories inside in alphabetical order. If a nested directory contains variables files as well as directories, Ansible reads the directories first. Below is an example of a <code>vars/main</code> directory:</p> <pre data-language="text">roles/
    common/          # this hierarchy represents a "role"
        vars/
            main/    #  &lt;-- variables associated with this role
                first_nested_directory/
                    first_variables_file.yml
                second_nested_directory/
                    second_variables_file.yml
                third_variables_file.yml
</pre> </section> <section id="storing-and-finding-roles"> <h2 id="role-search-path">Storing and finding roles</h2> <p>By default, Ansible looks for roles in the following locations:</p> <ul class="simple"> <li>in collections, if you are using them</li> <li>in a directory called <code>roles/</code>, relative to the playbook file</li> <li>in the configured <a class="reference internal" href="../reference_appendices/config.html#default-roles-path"><span class="std std-ref">roles_path</span></a>. The default search path is <code>~/.ansible/roles:/usr/share/ansible/roles:/etc/ansible/roles</code>.</li> <li>in the directory where the playbook file is located</li> </ul> <p>If you store your roles in a different location, set the <a class="reference internal" href="../reference_appendices/config.html#default-roles-path"><span class="std std-ref">roles_path</span></a> configuration option so Ansible can find your roles. Checking shared roles into a single location makes them easier to use in multiple playbooks. See <a class="reference internal" href="../installation_guide/intro_configuration.html#intro-configuration"><span class="std std-ref">Configuring Ansible</span></a> for details about managing settings in <code>ansible.cfg</code>.</p> <p>Alternatively, you can call a role with a fully qualified path:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - role: '/path/to/my/roles/common'
</pre> </section> <section id="using-roles"> <h2>Using roles</h2> <p>You can use roles in the following ways:</p> <ul class="simple"> <li>at the play level with the <code>roles</code> option: This is the classic way of using roles in a play.</li> <li>at the tasks level with <code>include_role</code>: You can reuse roles dynamically anywhere in the <code>tasks</code> section of a play using <code>include_role</code>.</li> <li>at the tasks level with <code>import_role</code>: You can reuse roles statically anywhere in the <code>tasks</code> section of a play using <code>import_role</code>.</li> <li>as a dependency of another role (see the <code>dependencies</code> keyword in <code>meta/main.yml</code> in this same page).</li> </ul> <section id="using-roles-at-the-play-level"> <h3 id="roles-keyword">Using roles at the play level</h3> <p>The classic (original) way to use roles is with the <code>roles</code> option for a given play:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - common
    - webservers
</pre> <p>When you use the <code>roles</code> option at the play level, each role ‘x’ looks for a <code>main.yml</code> (also <code>main.yaml</code> and <code>main</code>) in the following directories:</p> <ul class="simple"> <li><code>roles/x/tasks/</code></li> <li><code>roles/x/handlers/</code></li> <li><code>roles/x/vars/</code></li> <li><code>roles/x/defaults/</code></li> <li><code>roles/x/meta/</code></li> <li>Any copy, script, template or include tasks (in the role) can reference files in roles/x/{files,templates,tasks}/ (dir depends on task) without having to path them relatively or absolutely.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p><code>vars</code> and <code>defaults</code> can also match to a directory of the same name and Ansible will process all the files contained in that directory. See <a class="reference internal" href="#role-directory-structure"><span class="std std-ref">Role directory structure</span></a> for more details.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If you use <code>include_role/import_role</code>, you can specify a custom file name instead of <code>main</code>. The <code>meta</code> directory is an exception because it does not allow for customization.</p> </div> <p>When you use the <code>roles</code> option at the play level, Ansible treats the roles as static imports and processes them during playbook parsing. Ansible executes each play in this order:</p> <ul class="simple"> <li>Any <code>pre_tasks</code> defined in the play.</li> <li>Any handlers triggered by pre_tasks.</li> <li>Each role listed in <code>roles:</code>, in the order listed. Any role dependencies defined in the role’s <code>meta/main.yml</code> run first, subject to tag filtering and conditionals. See <a class="reference internal" href="#role-dependencies"><span class="std std-ref">Using role dependencies</span></a> for more details.</li> <li>Any <code>tasks</code> defined in the play.</li> <li>Any handlers triggered by the roles or tasks.</li> <li>Any <code>post_tasks</code> defined in the play.</li> <li>Any handlers triggered by post_tasks.</li> </ul> <div class="admonition note"> <p class="admonition-title">Note</p> <p>If using tags with tasks in a role, be sure to also tag your pre_tasks, post_tasks, and role dependencies and pass those along as well, especially if the pre/post tasks and role dependencies are used for monitoring outage window control or load balancing. See <a class="reference internal" href="playbooks_tags.html#tags"><span class="std std-ref">Tags</span></a> for details on adding and using tags.</p> </div> <p>You can pass other keywords to the <code>roles</code> option:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - common
    - role: foo_app_instance
      vars:
        dir: '/opt/a'
        app_port: 5000
      tags: typeA
    - role: foo_app_instance
      vars:
        dir: '/opt/b'
        app_port: 5001
      tags: typeB
</pre> <p>When you add a tag to the <code>role</code> option, Ansible applies the tag to ALL tasks within the role.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Prior to <code>ansible-core</code> 2.15, <code>vars:</code> within the <code>roles:</code> section of a playbook are added to the play variables, making them available to all tasks within the play before and after the role. This behavior can be changed by <a class="reference internal" href="../reference_appendices/config.html#default-private-role-vars"><span class="std std-ref">DEFAULT_PRIVATE_ROLE_VARS</span></a>. On more recent versions, <code>vars:</code> do not leak into the play’s variable scope.</p> </div> </section> <section id="including-roles-dynamic-reuse"> <h3>Including roles: dynamic reuse</h3> <p>You can reuse roles dynamically anywhere in the <code>tasks</code> section of a play using <code>include_role</code>. While roles added in a <code>roles</code> section run before any other tasks in a play, included roles run in the order they are defined. If there are other tasks before an <code>include_role</code> task, the other tasks will run first.</p> <p>To include a role:</p> <pre data-language="yaml">---
- hosts: webservers
  tasks:
    - name: Print a message
      ansible.builtin.debug:
        msg: "this task runs before the example role"

    - name: Include the example role
      include_role:
        name: example

    - name: Print a message
      ansible.builtin.debug:
        msg: "this task runs after the example role"
</pre> <p>You can pass other keywords, including variables and tags, when including roles:</p> <pre data-language="yaml">---
- hosts: webservers
  tasks:
    - name: Include the foo_app_instance role
      include_role:
        name: foo_app_instance
      vars:
        dir: '/opt/a'
        app_port: 5000
      tags: typeA
  ...
</pre> <p>When you add a <a class="reference internal" href="playbooks_tags.html#tags"><span class="std std-ref">tag</span></a> to an <code>include_role</code> task, Ansible applies the tag <strong>only</strong> to the include itself. This means you can pass <code>--tags</code> to run only selected tasks from the role, if those tasks themselves have the same tag as the include statement. See <a class="reference internal" href="playbooks_tags.html#selective-reuse"><span class="std std-ref">Selectively running tagged tasks in reusable files</span></a> for details.</p> <p>You can conditionally include a role:</p> <pre data-language="yaml">---
- hosts: webservers
  tasks:
    - name: Include the some_role role
      include_role:
        name: some_role
      when: "ansible_facts['os_family'] == 'RedHat'"
</pre> </section> <section id="importing-roles-static-reuse"> <h3>Importing roles: static reuse</h3> <p>You can reuse roles statically anywhere in the <code>tasks</code> section of a play using <code>import_role</code>. The behavior is the same as using the <code>roles</code> keyword. For example:</p> <pre data-language="yaml">---
- hosts: webservers
  tasks:
    - name: Print a message
      ansible.builtin.debug:
        msg: "before we run our role"

    - name: Import the example role
      import_role:
        name: example

    - name: Print a message
      ansible.builtin.debug:
        msg: "after we ran our role"
</pre> <p>You can pass other keywords, including variables and tags when importing roles:</p> <pre data-language="yaml">---
- hosts: webservers
  tasks:
    - name: Import the foo_app_instance role
      import_role:
        name: foo_app_instance
      vars:
        dir: '/opt/a'
        app_port: 5000
  ...
</pre> <p>When you add a tag to an <code>import_role</code> statement, Ansible applies the tag to <strong>all</strong> tasks within the role. See <a class="reference internal" href="playbooks_tags.html#tag-inheritance"><span class="std std-ref">Tag inheritance: adding tags to multiple tasks</span></a> for details.</p> </section> </section> <section id="role-argument-validation"> <h2 id="role-argument-spec">Role argument validation</h2> <p>Beginning with version 2.11, you may choose to enable role argument validation based on an argument specification. This specification is defined in the <code>meta/argument_specs.yml</code> file (or with the <code>.yaml</code> file extension). When this argument specification is defined, a new task is inserted at the beginning of role execution that will validate the parameters supplied for the role against the specification. If the parameters fail validation, the role will fail execution.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Ansible also supports role specifications defined in the role <code>meta/main.yml</code> file, as well. However, any role that defines the specs within this file will not work on versions below 2.11. For this reason, we recommend using the <code>meta/argument_specs.yml</code> file to maintain backward compatibility.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>When role argument validation is used on a role that has defined <a class="reference internal" href="#role-dependencies"><span class="std std-ref">dependencies</span></a>, then validation on those dependencies will run before the dependent role, even if argument validation fails for the dependent role.</p> </div> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Ansible tags the inserted role argument validation task with <a class="reference internal" href="playbooks_tags.html#special-tags"><span class="std std-ref">always</span></a>. If the role is <a class="reference internal" href="playbooks_reuse.html#dynamic-vs-static"><span class="std std-ref">statically imported</span></a> this task runs unless you use the <code>--skip-tags</code> flag.</p> </div> <section id="specification-format"> <h3>Specification format</h3> <p>The role argument specification must be defined in a top-level <code>argument_specs</code> block within the role <code>meta/argument_specs.yml</code> file. All fields are lowercase.</p> <dl class="field-list"> <dt class="field-odd">entry-point-name<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>The name of the role entry point.</li> <li>This should be <code>main</code> in the case of an unspecified entry point.</li> <li>This will be the base name of the tasks file to execute, with no <code>.yml</code> or <code>.yaml</code> file extension.</li> </ul> <dl class="field-list"> <dt class="field-odd">short_description<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>A short, one-line description of the entry point. Ideally, it is a phrase and not a sentence.</li> <li>The <code>short_description</code> is displayed by <code>ansible-doc -t role -l</code>.</li> <li>It also becomes part of the title for the role page in the documentation.</li> <li>The short description should always be a string and never a list, and should not end in a period.</li> </ul> </dd> <dt class="field-even">description<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>A longer description that may contain multiple lines.</li> <li>
<dl class="simple"> <dt>This can be a single string or a list of strings. In case this is a list of strings, every list</dt>
<dd>
<p>element is a new paragraph.</p> </dd> </dl> </li> </ul> </dd> <dt class="field-odd">version_added<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>The version of the role when the entrypoint was added.</li> <li>This is a string, and not a float, for example, <code>version_added: '2.1'</code>.</li> <li>In collections, this must be the collection version the entrypoint was added to. For example, <code>version_added: 1.0.0</code>.</li> </ul> </dd> <dt class="field-even">author<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>Name of the entry point authors.</li> <li>This can be a single string or a list of strings. Use one list entry per author. If there is only a single author, use a string or a one-element list.</li> </ul> </dd> <dt class="field-odd">options<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>Options are often called “parameters” or “arguments”. This section defines those options.</li> <li>For each role option (argument), you may include:</li> </ul> <dl class="field-list simple"> <dt class="field-odd">option-name<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>The name of the option/argument.</li> </ul> </dd> <dt class="field-even">description<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>Detailed explanation of what this option does. It should be written in full sentences.</li> <li>This can be a single string or a list of strings. In case this is a list of strings, every list element is a new paragraph.</li> </ul> </dd> <dt class="field-odd">version_added<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>Only needed if this option was added after the initial role/entry point release. In other words, this is greater than the top level <code>version_added</code> field.</li> <li>This is a string, and not a float, for example, <code>version_added: '2.1'</code>.</li> <li>In collections, this must be the collection version the option was added to. For example, <code>version_added: 1.0.0</code>.</li> </ul> </dd> <dt class="field-even">type<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>The data type of the option. See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_program_flow_modules.html#argument-spec"><span class="std std-ref">Argument spec</span></a> for allowed values for <code>type</code>. The default is <code>str</code>.</li> <li>If an option is of type <code>list</code>, <code>elements</code> should be specified.</li> </ul> </dd> <dt class="field-odd">required<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>Only needed if <code>true</code>.</li> <li>If missing, the option is not required.</li> </ul> </dd> <dt class="field-even">default<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>If <code>required</code> is <code>false</code>/missing, <code>default</code> may be specified (assumed <code>null</code> if missing).</li> <li>Ensure that the default value in the docs matches the default value in the code. The actual default for the role variable will always come from the role defaults (as defined in <a class="reference internal" href="#role-directory-structure"><span class="std std-ref">Role directory structure</span></a>).</li> <li>The default field must not be listed as part of the description unless it requires additional information or conditions.</li> <li>If the option is a boolean value, you should use <code>true</code>/<code>false</code> if you want to be compatible with <code>ansible-lint</code>.</li> </ul> </dd> <dt class="field-odd">choices<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>List of option values.</li> <li>Should be absent if empty.</li> </ul> </dd> <dt class="field-even">elements<span class="colon">:</span>
</dt> <dd class="field-even">
<ul class="simple"> <li>Specifies the data type for list elements when the type is <code>list</code>.</li> </ul> </dd> <dt class="field-odd">options<span class="colon">:</span>
</dt> <dd class="field-odd">
<ul class="simple"> <li>If this option takes a dict or list of dicts, you can define the structure here.</li> </ul> </dd> </dl> </dd> </dl> </dd> </dl> </section> <section id="sample-specification"> <h3>Sample specification</h3> <pre data-language="yaml"># roles/myapp/meta/argument_specs.yml
---
argument_specs:
  # roles/myapp/tasks/main.yml entry point
  main:
    short_description: Main entry point for the myapp role
    description:
      - This is the main entrypoint for the C(myapp) role.
      - Here we can describe what this entrypoint does in lengthy words.
      - Every new list item is a new paragraph. You can have multiple sentences
        per paragraph.
    author:
      - Daniel Ziegenberg
    options:
      myapp_int:
        type: "int"
        required: false
        default: 42
        description:
          - "The integer value, defaulting to 42."
          - "This is a second paragraph."

      myapp_str:
        type: "str"
        required: true
        description: "The string value"

      myapp_list:
        type: "list"
        elements: "str"
        required: true
        description: "A list of string values."
        version_added: 1.3.0

      myapp_list_with_dicts:
        type: "list"
        elements: "dict"
        required: false
        default:
          - myapp_food_kind: "meat"
            myapp_food_boiling_required: true
            myapp_food_preparation_time: 60
          - myapp_food_kind: "fruits"
            myapp_food_preparation_time: 5
        description: "A list of dicts with a defined structure and with default a value."
        options:
          myapp_food_kind:
            type: "str"
            choices:
              - "vegetables"
              - "fruits"
              - "grains"
              - "meat"
            required: false
            description: "A string value with a limited list of allowed choices."

          myapp_food_boiling_required:
            type: "bool"
            required: false
            default: false
            description: "Whether the kind of food requires boiling before consumption."

          myapp_food_preparation_time:
            type: int
            required: true
            description: "Time to prepare a dish in minutes."

      myapp_dict_with_suboptions:
        type: "dict"
        required: false
        default:
          myapp_host: "bar.foo"
          myapp_exclude_host: true
          myapp_path: "/etc/myapp"
        description: "A dict with a defined structure and default values."
        options:
          myapp_host:
            type: "str"
            choices:
              - "foo.bar"
              - "bar.foo"
              - "ansible.foo.bar"
            required: true
            description: "A string value with a limited list of allowed choices."

          myapp_exclude_host:
            type: "bool"
            required: true
            description: "A boolean value."

          myapp_path:
            type: "path"
            required: true
            description: "A path value."

          original_name:
            type: list
            elements: "str"
            required: false
            description: "An optional list of string values."

  # roles/myapp/tasks/alternate.yml entry point
  alternate:
    short_description: Alternate entry point for the myapp role
    description:
      - This is the alternate entrypoint for the C(myapp) role.
    version_added: 1.2.0
    options:
      myapp_int:
        type: "int"
        required: false
        default: 1024
        description: "The integer value, defaulting to 1024."
</pre> </section> </section> <section id="running-a-role-multiple-times-in-one-play"> <h2 id="run-role-twice">Running a role multiple times in one play</h2> <p>Ansible only executes each role once in a play, even if you define it multiple times unless the parameters defined on the role are different for each definition. For example, Ansible only runs the role <code>foo</code> once in a play like this:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - foo
    - bar
    - foo
</pre> <p>You have two options to force Ansible to run a role more than once.</p> <section id="passing-different-parameters"> <h3>Passing different parameters</h3> <p>If you pass different parameters in each role definition, Ansible runs the role more than once. Providing different variable values is not the same as passing different role parameters. You must use the <code>roles</code> keyword for this behavior, since <code>import_role</code> and <code>include_role</code> do not accept role parameters.</p> <p>This play runs the <code>foo</code> role twice:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - { role: foo, message: "first" }
    - { role: foo, message: "second" }
</pre> <p>This syntax also runs the <code>foo</code> role twice;</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - role: foo
      message: "first"
    - role: foo
      message: "second"
</pre> <p>In these examples, Ansible runs <code>foo</code> twice because each role definition has different parameters.</p> </section> <section id="using-allow-duplicates-true"> <h3>Using <code>allow_duplicates: true</code>
</h3> <p>Add <code>allow_duplicates: true</code> to the <code>meta/main.yml</code> file for the role:</p> <pre data-language="yaml"># playbook.yml
---
- hosts: webservers
  roles:
    - foo
    - foo

# roles/foo/meta/main.yml
---
allow_duplicates: true
</pre> <p>In this example, Ansible runs <code>foo</code> twice because we have explicitly enabled it to do so.</p> </section> </section> <section id="using-role-dependencies"> <h2 id="role-dependencies">Using role dependencies</h2> <p>Role dependencies let you automatically pull in other roles when using a role.</p> <p>Role dependencies are prerequisites, not true dependencies. The roles do not have a parent/child relationship. Ansible loads all listed roles, runs the roles listed under <code>dependencies</code> first, then runs the role that lists them. The play object is the parent of all roles, including roles called by a <code>dependencies</code> list.</p> <p>Role dependencies are stored in the <code>meta/main.yml</code> file within the role directory. This file should contain a list of roles and parameters to insert before the specified role. For example:</p> <pre data-language="yaml"># roles/myapp/meta/main.yml
---
dependencies:
  - role: common
    vars:
      some_parameter: 3
  - role: apache
    vars:
      apache_port: 80
  - role: postgres
    vars:
      dbname: blarg
      other_parameter: 12
</pre> <p>Ansible always executes roles listed in <code>dependencies</code> before the role that lists them. Ansible executes this pattern recursively when you use the <code>roles</code> keyword. For example, if you list role <code>foo</code> under <code>roles:</code>, role <code>foo</code> lists role <code>bar</code> under <code>dependencies</code> in its meta/main.yml file, and role <code>bar</code> lists role <code>baz</code> under <code>dependencies</code> in its meta/main.yml, Ansible executes <code>baz</code>, then <code>bar</code>, then <code>foo</code>.</p> <section id="running-role-dependencies-multiple-times-in-one-play"> <h3>Running role dependencies multiple times in one play</h3> <p>Ansible treats duplicate role dependencies like duplicate roles listed under <code>roles:</code>: Ansible only executes role dependencies once, even if defined multiple times, unless the parameters, tags, or when clause defined on the role are different for each definition. If two roles in a play both list a third role as a dependency, Ansible only runs that role dependency once, unless you pass different parameters, tags, when clause, or use <code>allow_duplicates: true</code> in the role you want to run multiple times. See <a class="reference internal" href="../galaxy/user_guide.html#galaxy-dependencies"><span class="std std-ref">Galaxy role dependencies</span></a> for more details.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>Role deduplication does not consult the invocation signature of parent roles. Additionally, when using <code>vars:</code> instead of role params, there is a side effect of changing variable scoping. Using <code>vars:</code> results in those variables being scoped at the play level. In the below example, using <code>vars:</code> would cause <code>n</code> to be defined as <code>4</code> throughout the entire play, including roles called before it.</p> <p>In addition to the above, users should be aware that role de-duplication occurs before variable evaluation. This means that <a class="reference internal" href="https://docs.ansible.com/ansible/latest/reference_appendices/glossary.html#term-Lazy-Evaluation"><span class="xref std std-term">Lazy Evaluation</span></a> may make seemingly different role invocations equivalently the same, preventing the role from running more than once.</p> </div> <p>For example, a role named <code>car</code> depends on a role named <code>wheel</code> as follows:</p> <pre data-language="yaml">---
dependencies:
  - role: wheel
    n: 1
  - role: wheel
    n: 2
  - role: wheel
    n: 3
  - role: wheel
    n: 4
</pre> <p>And the <code>wheel</code> role depends on two roles: <code>tire</code> and <code>brake</code>. The <code>meta/main.yml</code> for wheel would then contain the following:</p> <pre data-language="yaml">---
dependencies:
  - role: tire
  - role: brake
</pre> <p>And the <code>meta/main.yml</code> for <code>tire</code> and <code>brake</code> would contain the following:</p> <pre data-language="yaml">---
allow_duplicates: true
</pre> <p>The resulting order of execution would be as follows:</p> <pre data-language="text">tire(n=1)
brake(n=1)
wheel(n=1)
tire(n=2)
brake(n=2)
wheel(n=2)
...
car
</pre> <p>To use <code>allow_duplicates: true</code> with role dependencies, you must specify it for the role listed under <code>dependencies</code>, not for the role that lists it. In the example above, <code>allow_duplicates: true</code> appears in the <code>meta/main.yml</code> of the <code>tire</code> and <code>brake</code> roles. The <code>wheel</code> role does not require <code>allow_duplicates: true</code>, because each instance defined by <code>car</code> uses different parameter values.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>See <a class="reference internal" href="playbooks_variables.html#playbooks-variables"><span class="std std-ref">Using Variables</span></a> for details on how Ansible chooses among variable values defined in different places (variable inheritance and scope). Also, deduplication happens ONLY at the play level, so multiple plays in the same playbook may rerun the roles.</p> </div> </section> </section> <section id="embedding-modules-and-plugins-in-roles"> <h2 id="id2">Embedding modules and plugins in roles</h2> <div class="admonition note"> <p class="admonition-title">Note</p> <p>This applies only to standalone roles. Roles in collections do not support plugin embedding; they must use the collection’s <code>plugins</code> structure to distribute plugins.</p> </div> <p>If you write a custom module (see <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html#developing-modules"><span class="std std-ref">Should you develop a module?</span></a>) or a plugin (see <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.html#developing-plugins"><span class="std std-ref">Developing plugins</span></a>), you might wish to distribute it as part of a role. For example, if you write a module that helps configure your company’s internal software, and you want other people in your organization to use this module, but do not want to tell everyone how to configure their Ansible library path, you can include the module in your internal_config role.</p> <p>To add a module or a plugin to a role: Alongside the ‘tasks’ and ‘handlers’ structure of a role, add a directory named ‘library’ and then include the module directly inside the ‘library’ directory.</p> <p>Assuming you had this:</p> <pre data-language="text">roles/
    my_custom_modules/
        library/
            module1
            module2
</pre> <p>The module will be usable in the role itself, as well as any roles that are called <em>after</em> this role, as follows:</p> <pre data-language="yaml">---
- hosts: webservers
  roles:
    - my_custom_modules
    - some_other_role_using_my_custom_modules
    - yet_another_role_using_my_custom_modules
</pre> <p>If necessary, you can also embed a module in a role to modify a module in Ansible’s core distribution. For example, you can use the development version of a particular module before it is released in production releases by copying the module and embedding the copy in a role. Use this approach with caution, as API signatures may change in core components, and this workaround is not guaranteed to work.</p> <p>The same mechanism can be used to embed and distribute plugins in a role, using the same schema. For example, for a filter plugin:</p> <pre data-language="text">roles/
    my_custom_filter/
        filter_plugins
            filter1
            filter2
</pre> <p>These filters can then be used in a Jinja template in any role called after ‘my_custom_filter’.</p> </section> <section id="sharing-roles-ansible-galaxy"> <h2>Sharing roles: Ansible Galaxy</h2> <p><a class="reference external" href="https://galaxy.ansible.com">Ansible Galaxy</a> is a free site for finding, downloading, rating, and reviewing all kinds of community-developed Ansible roles and can be a great way to get a jumpstart on your automation projects.</p> <p>The client <code>ansible-galaxy</code> is included in Ansible. The Galaxy client allows you to download roles from Ansible Galaxy and provides an excellent default framework for creating your own roles.</p> <p>Read the <a class="reference external" href="https://ansible.readthedocs.io/projects/galaxy-ng/en/latest/">Ansible Galaxy documentation</a> page for more information.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="../galaxy/user_guide.html#ansible-galaxy"><span class="std std-ref">Galaxy User Guide</span></a></dt>
<dd>
<p>How to create new roles, share roles on Galaxy, role management</p> </dd> <dt><a class="reference internal" href="../reference_appendices/yamlsyntax.html#yaml-syntax"><span class="std std-ref">YAML Syntax</span></a></dt>
<dd>
<p>Learn about YAML syntax</p> </dd> <dt><a class="reference internal" href="playbooks.html#working-with-playbooks"><span class="std std-ref">Working with playbooks</span></a></dt>
<dd>
<p>Review the basic Playbook language features</p> </dd> <dt><a class="reference internal" href="../tips_tricks/ansible_tips_tricks.html#tips-and-tricks"><span class="std std-ref">General tips</span></a></dt>
<dd>
<p>Tips and tricks for playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_variables.html#playbooks-variables"><span class="std std-ref">Using Variables</span></a></dt>
<dd>
<p>Variables in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_conditionals.html#playbooks-conditionals"><span class="std std-ref">Conditionals</span></a></dt>
<dd>
<p>Conditionals in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_loops.html#playbooks-loops"><span class="std std-ref">Loops</span></a></dt>
<dd>
<p>Loops in playbooks</p> </dd> <dt><a class="reference internal" href="playbooks_tags.html#tags"><span class="std std-ref">Tags</span></a></dt>
<dd>
<p>Using tags to select or skip roles/tasks in long playbooks</p> </dd> <dt><a class="reference internal" href="../collections/index.html#list-of-collections"><span class="std std-ref">Collection Index</span></a></dt>
<dd>
<p>Browse existing collections, modules, and plugins</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.html#developing-modules"><span class="std std-ref">Should you develop a module?</span></a></dt>
<dd>
<p>Extending Ansible by writing your own modules</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Communication</span></a></dt>
<dd>
<p>Got questions? Need help? Want to share your ideas? Visit the Ansible communication guide</p> </dd> </dl> </div> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse_roles.html</a>
  </p>
</div>
