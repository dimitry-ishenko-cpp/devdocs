<section id="developing-network-resource-modules"> <h1 id="developing-resource-modules">Developing network resource modules</h1>  <ul class="simple"> <li><a class="reference internal" href="#understanding-network-and-security-resource-modules" id="id4">Understanding network and security resource modules</a></li> <li>
<p><a class="reference internal" href="#developing-network-and-security-resource-modules" id="id5">Developing network and security resource modules</a></p> <ul> <li><a class="reference internal" href="#understanding-the-model-and-resource-module-builder" id="id6">Understanding the model and resource module builder</a></li> <li><a class="reference internal" href="#accessing-the-resource-module-builder" id="id7">Accessing the resource module builder</a></li> <li><a class="reference internal" href="#creating-a-model" id="id8">Creating a model</a></li> <li><a class="reference internal" href="#creating-a-collection-scaffold-from-a-resource-model" id="id9">Creating a collection scaffold from a resource model</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#examples" id="id10">Examples</a></p> <ul> <li><a class="reference internal" href="#collection-directory-layout" id="id11">Collection directory layout</a></li> <li><a class="reference internal" href="#role-directory-layout" id="id12">Role directory layout</a></li> <li><a class="reference internal" href="#using-the-collection" id="id13">Using the collection</a></li> <li><a class="reference internal" href="#using-the-role" id="id14">Using the role</a></li> </ul> </li> <li><a class="reference internal" href="#resource-module-structure-and-workflow" id="id15">Resource module structure and workflow</a></li> <li><a class="reference internal" href="#running-ansible-test-sanity-and-tox-on-resource-modules" id="id16">Running <code>ansible-test sanity</code> and <code>tox</code> on resource modules</a></li> <li>
<p><a class="reference internal" href="#testing-resource-modules" id="id17">Testing resource modules</a></p> <ul> <li><a class="reference internal" href="#resource-module-integration-tests" id="id18">Resource module integration tests</a></li> <li><a class="reference internal" href="#unit-test-requirements" id="id19">Unit test requirements</a></li> </ul> </li> <li>
<p><a class="reference internal" href="#example-unit-testing-ansible-network-resource-modules" id="id20">Example: Unit testing Ansible network resource modules</a></p> <ul> <li><a class="reference internal" href="#using-mock-objects-to-unit-test-ansible-network-resource-modules" id="id21">Using mock objects to unit test Ansible network resource modules</a></li> <li><a class="reference internal" href="#mocking-device-data" id="id22">Mocking device data</a></li> </ul> </li> </ul>  <section id="understanding-network-and-security-resource-modules"> <h2>Understanding network and security resource modules</h2> <p>Network and security devices separate configuration into sections (such as interfaces, VLANs, and so on) that apply to a network or security service. Ansible resource modules take advantage of this to allow users to configure subsections or resources within the device configuration. Resource modules provide a consistent experience across different network and security devices. For example, a network resource module may only update the configuration for a specific portion of the network interfaces, VLANs, ACLs, and so on for a network device. The resource module:</p> <ol class="arabic simple"> <li>Fetches a piece of the configuration (fact gathering), for example, the interfaces configuration.</li> <li>Converts the returned configuration into key-value pairs.</li> <li>Places those key-value pairs into an internal independent structured data format.</li> </ol> <p>Now that the configuration data is normalized, the user can update and modify the data and then use the resource module to send the configuration data back to the device. This results in a full round-trip configuration update without the need for manual parsing, data manipulation, and data model management.</p> <p>The resource module has two top-level keys - <code>config</code> and <code>state</code>:</p> <ul class="simple"> <li>
<code>config</code> defines the resource configuration data model as key-value pairs. The type of the <code>config</code> option can be <code>dict</code> or <code>list of dict</code> based on the resource managed. That is, if the device has a single global configuration, it should be a <code>dict</code> (for example, a global LLDP configuration). If the device has multiple instances of configuration, it should be of type <code>list</code> with each element in the list of type <code>dict</code> (for example, interfaces configuration).</li> <li>
<code>state</code> defines the action the resource module takes on the end device.</li> </ul> <p>The <code>state</code> for a new resource module should support the following values (as applicable for the devices that support them):</p> <dl class="simple"> <dt>merged</dt>
<dd>
<p>Ansible merges the on-device configuration with the provided configuration in the task.</p> </dd> <dt>replaced</dt>
<dd>
<p>Ansible replaces the on-device configuration subsection with the provided configuration subsection in the task.</p> </dd> <dt>overridden</dt>
<dd>
<p>Ansible overrides the on-device configuration for the resource with the provided configuration in the task. Use caution with this state as you could remove your access to the device (for example, by overriding the management interface configuration).</p> </dd> <dt>deleted</dt>
<dd>
<p>Ansible deletes the on-device configuration subsection and restores any default settings.</p> </dd> <dt>gathered</dt>
<dd>
<p>Ansible displays the resource details gathered from the network device and accessed with the <code>gathered</code> key in the result.</p> </dd> <dt>rendered</dt>
<dd>
<p>Ansible renders the provided configuration in the task in the device-native format (for example, Cisco IOS CLI). Ansible returns this rendered configuration in the <code>rendered</code> key in the result. Note this state does not communicate with the network device and can be used offline.</p> </dd> <dt>parsed</dt>
<dd>
<p>Ansible parses the configuration from the <code>running_configuration</code> option into Ansible structured data in the <code>parsed</code> key in the result. Note this does not gather the configuration from the network device so this state can be used offline.</p> </dd> </dl> <p>Modules in Ansible-maintained collections must support these state values. If you develop a module with only “present” and “absent” for state, you may submit it to a community collection.</p> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The states <code>rendered</code>, <code>gathered</code>, and <code>parsed</code> do not perform any change on the device.</p> </div> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://www.ansible.com/blog/deep-dive-on-vlans-resource-modules-for-network-automation">Deep Dive on VLANs Resource Modules for Network Automation</a></dt>
<dd>
<p>Walkthrough of how state values are implemented for VLANs.</p> </dd> </dl> </div> </section> <section id="developing-network-and-security-resource-modules"> <h2>Developing network and security resource modules</h2> <p>The Ansible Engineering team ensures the module design and code pattern within Ansible-maintained collections is uniform across resources and across platforms to give a vendor-independent feel and deliver good quality code. We recommend you use the <a class="reference external" href="https://github.com/ansible-network/resource_module_builder">resource module builder</a> to develop a resource module.</p> <p>The highlevel process for developing a resource module is:</p> <ol class="arabic simple"> <li>Create and share a resource model design in the <a class="reference external" href="https://github.com/ansible-network/resource_module_models">resource module models repository</a> as a PR for review.</li> <li>Download the latest version of the <a class="reference external" href="https://github.com/ansible-network/resource_module_builder">resource module builder</a>.</li> <li>Run the <code>resource module builder</code> to create a collection scaffold from your approved resource model.</li> <li>Write the code to implement your resource module.</li> <li>Develop integration and unit tests to verify your resource module.</li> <li>Create a PR to the appropriate collection that you want to add your new resource module to. See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/contributing_maintained_collections.html#contributing-maintained-collections"><span class="std std-ref">Contributing to Ansible-maintained Collections</span></a> for details on determining the correct collection for your module.</li> </ol> <section id="understanding-the-model-and-resource-module-builder"> <h3>Understanding the model and resource module builder</h3> <p>The resource module builder is an Ansible Playbook that helps developers scaffold and maintain an Ansible resource module. It uses a model as the single source of truth for the module. This model is a <code>yaml</code> file that is used for the module DOCUMENTATION section and the argument spec.</p> <p>The resource module builder has the following capabilities:</p> <ul class="simple"> <li>Uses a defined model to scaffold a resource module directory layout and initial class files.</li> <li>Scaffolds either an Ansible role or a collection.</li> <li>Subsequent uses of the resource module builder will only replace the module arspec and file containing the module docstring.</li> <li>Allows you to store complex examples along side the model in the same directory.</li> <li>Maintains the model as the source of truth for the module and use resource module builder to update the source files as needed.</li> <li>Generates working sample modules for both <code>&lt;network_os&gt;_&lt;resource&gt;</code> and <code>&lt;network_os&gt;_facts</code>.</li> </ul> </section> <section id="accessing-the-resource-module-builder"> <h3>Accessing the resource module builder</h3> <p>To access the resource module builder:</p> <ol class="arabic simple"> <li>clone the GitHub repository:</li> </ol>  <pre data-language="bash">git clone https://github.com/ansible-network/resource_module_builder.git
</pre>  <ol class="arabic simple" start="2"> <li>Install the requirements:</li> </ol>  <pre data-language="bash">pip install -r requirements.txt
</pre>  </section> <section id="creating-a-model"> <h3>Creating a model</h3> <p>You must create a model for your new resource. The model is the single source of truth for both the argspec and docstring, keeping them in sync. Once your model is approved, you can use the resource module builder to generate three items based on the model:</p> <ul class="simple"> <li>The scaffold for a new module</li> <li>The argspec for the new module</li> <li>The docstring for the new module</li> </ul> <p>For any subsequent changes to the functionality, update the model first and use the resource module builder to update the module argspec and docstring.</p> <p>For example, the resource model builder includes the <code>myos_interfaces.yml</code> sample in the <code>models</code> directory, as seen below:</p> <pre data-language="yaml">---
GENERATOR_VERSION: '1.0'

NETWORK_OS: myos
RESOURCE: interfaces
COPYRIGHT: Copyright 2019 Red Hat
LICENSE: gpl-3.0.txt

DOCUMENTATION: |
  module: myos_interfaces
  version_added: 1.0.0
  short_description: 'Manages &lt;xxxx&gt; attributes of &lt;network_os&gt; &lt;resource&gt;'
  description: 'Manages &lt;xxxx&gt; attributes of &lt;network_os&gt; &lt;resource&gt;.'
  author: Ansible Network Engineer
 notes:
    - 'Tested against &lt;network_os&gt; &lt;version&gt;'
  options:
    config:
      description: The provided configuration
      type: list
      elements: dict
      suboptions:
        name:
          type: str
          description: The name of the &lt;resource&gt;
        some_string:
          type: str
          description:
          - The some_string_01
          choices:
          - choice_a
          - choice_b
          - choice_c
          default: choice_a
        some_bool:
          description:
          - The some_bool.
          type: bool
        some_int:
          description:
          - The some_int.
          type: int
          version_added: '1.1.0'
        some_dict:
          type: dict
          description:
          - The some_dict.
          suboptions:
            property_01:
              description:
              - The property_01
              type: str
    state:
      description:
      - The state of the configuration after module completion.
      type: str
      choices:
      - merged
      - replaced
      - overridden
      - deleted
      default: merged
EXAMPLES:
  - deleted_example_01.txt
  - merged_example_01.txt
  - overridden_example_01.txt
  - replaced_example_01.txt
</pre> <p>Notice that you should include examples for each of the states that the resource supports. The resource module builder also includes these in the sample model.</p> <p>Share this model as a PR for review at <a class="reference external" href="https://github.com/ansible-network/resource_module_models">resource module models repository</a>. You can also see more model examples at that location.</p> </section> <section id="creating-a-collection-scaffold-from-a-resource-model"> <h3>Creating a collection scaffold from a resource model</h3> <p>To use the resource module builder to create a collection scaffold from your approved resource model:</p> <pre data-language="bash">ansible-playbook -e rm_dest=&lt;destination for modules and module utils&gt; \
                 -e structure=collection \
                 -e collection_org=&lt;collection_org&gt; \
                 -e collection_name=&lt;collection_name&gt; \
                 -e model=&lt;model&gt; \
                 site.yml
</pre> <p>Where the parameters are as follows:</p> <ul class="simple"> <li>
<code>rm_dest</code>: The directory where the resource module builder places the files and directories for the resource module and facts modules.</li> <li>
<p><code>structure</code>: The directory layout type (role or collection)</p> <ul> <li>
<code>role</code>: Generate a role directory layout.</li> <li>
<code>collection</code>: Generate a collection directory layout.</li> </ul> </li> <li>
<code>collection_org</code>: The organization of the collection, required when <code>structure=collection</code>.</li> <li>
<code>collection_name</code>: The name of the collection, required when <code>structure=collection</code>.</li> <li>
<code>model</code>: The path to the model file.</li> </ul> <p>To use the resource module builder to create a role scaffold:</p> <pre data-language="bash">ansible-playbook -e rm_dest=&lt;destination for modules and module utils&gt; \
                 -e structure=role \
                 -e model=&lt;model&gt; \
                 site.yml
</pre> </section> </section> <section id="examples"> <h2>Examples</h2> <section id="collection-directory-layout"> <h3>Collection directory layout</h3> <p>This example shows the directory layout for the following:</p> <ul class="simple"> <li>
<code>network_os</code>: myos</li> <li>
<code>resource</code>: interfaces</li> </ul> <pre data-language="bash">ansible-playbook -e rm_dest=~/github/rm_example \
                 -e structure=collection \
                 -e collection_org=cidrblock \
                 -e collection_name=my_collection \
                 -e model=models/myos/interfaces/myos_interfaces.yml \
                 site.yml
</pre> <pre data-language="text">├── docs
├── LICENSE.txt
├── playbooks
├── plugins
|   ├── action
|   ├── filter
|   ├── inventory
|   ├── modules
|   |   ├── __init__.py
|   |   ├── myos_facts.py
|   |   └──  myos_interfaces.py
|   └──  module_utils
|       ├── __init__.py
|       └──  network
|           ├── __init__.py
|           └──  myos
|               ├── argspec
|               |   ├── facts
|               |   |   ├── facts.py
|               |   |   └──  __init__.py
|               |   ├── __init__.py
|               |   └──  interfaces
|               |       ├── __init__.py
|               |       └──  interfaces.py
|               ├── config
|               |   ├── __init__.py
|               |   └──  interfaces
|               |       ├── __init__.py
|               |       └──  interfaces.py
|               ├── facts
|               |   ├── facts.py
|               |   ├── __init__.py
|               |   └──  interfaces
|               |       ├── __init__.py
|               |       └──  interfaces.py
|               ├── __init__.py
|               └──  utils
|                   ├── __init__.py
|                   └──  utils.py
├── README.md
└──  roles
</pre> </section> <section id="role-directory-layout"> <h3>Role directory layout</h3> <p>This example displays the role directory layout for the following:</p> <ul class="simple"> <li>
<code>network_os</code>: myos</li> <li>
<code>resource</code>: interfaces</li> </ul> <pre data-language="bash">ansible-playbook -e rm_dest=~/github/rm_example/roles/my_role \
                 -e structure=role \
                 -e model=models/myos/interfaces/myos_interfaces.yml \
                 site.yml
</pre> <pre data-language="text">roles
└── my_role
    ├── library
    │   ├── __init__.py
    │   ├── myos_facts.py
    │   └── myos_interfaces.py
    ├── LICENSE.txt
    ├── module_utils
    │   ├── __init__.py
    │   └── network
    │       ├── __init__.py
    │       └── myos
    │           ├── argspec
    │           │   ├── facts
    │           │   │   ├── facts.py
    │           │   │   └── __init__.py
    │           │   ├── __init__.py
    │           │   └── interfaces
    │           │       ├── __init__.py
    │           │       └── interfaces.py
    │           ├── config
    │           │   ├── __init__.py
    │           │   └── interfaces
    │           │       ├── __init__.py
    │           │       └── interfaces.py
    │           ├── facts
    │           │   ├── facts.py
    │           │   ├── __init__.py
    │           │   └── interfaces
    │           │       ├── __init__.py
    │           │       └── interfaces.py
    │           ├── __init__.py
    │           └── utils
    │               ├── __init__.py
    │               └── utils.py
    └── README.md
</pre> </section> <section id="using-the-collection"> <h3>Using the collection</h3> <p>This example shows how to use the generated collection in a playbook:</p>  <pre data-language="yaml">----
- hosts: myos101
  gather_facts: False
  tasks:
  - cidrblock.my_collection.myos_interfaces:
    register: result
  - debug:
      var: result
  - cidrblock.my_collection.myos_facts:
  - debug:
      var: ansible_network_resources
</pre>  </section> <section id="using-the-role"> <h3>Using the role</h3> <p>This example shows how to use the generated role in a playbook:</p> <pre data-language="yaml">- hosts: myos101
  gather_facts: False
  roles:
  - my_role

- hosts: myos101
  gather_facts: False
  tasks:
  - myos_interfaces:
    register: result
  - debug:
      var: result
  - myos_facts:
  - debug:
      var: ansible_network_resources
</pre> </section> </section> <section id="resource-module-structure-and-workflow"> <h2>Resource module structure and workflow</h2> <p>The resource module structure includes the following components:</p> <dl> <dt>Module</dt>
<dd>
<ul class="simple"> <li>
<code>library/&lt;ansible_network_os&gt;_&lt;resource&gt;.py</code>.</li> <li>Imports the <code>module_utils</code> resource package and calls <code>execute_module</code> API:</li> </ul> <pre data-language="text">def main():
    result = &lt;resource_package&gt;(module).execute_module()
</pre> </dd> <dt>Module argspec</dt>
<dd>
<ul class="simple"> <li>
<code>module_utils/&lt;ansible_network_os&gt;/argspec/&lt;resource&gt;/</code>.</li> <li>Argspec for the resource.</li> </ul> </dd> <dt>Facts</dt>
<dd>
<ul class="simple"> <li>
<code>module_utils/&lt;ansible_network_os&gt;/facts/&lt;resource&gt;/</code>.</li> <li>Populate facts for the resource.</li> <li>Entry in <code>module_utils/&lt;ansible_network_os&gt;/facts/facts.py</code> for <code>get_facts</code> API to keep <code>&lt;ansible_network_os&gt;_facts</code> module and facts gathered for the resource module in sync for every subset.</li> <li>Entry of Resource subset in FACTS_RESOURCE_SUBSETS list in <code>module_utils/&lt;ansible_network_os&gt;/facts/facts.py</code> to make facts collection work.</li> </ul> </dd> <dt>Module package in module_utils</dt>
<dd>
<ul class="simple"> <li>
<code>module_utils/&lt;ansible_network_os&gt;/&lt;config&gt;/&lt;resource&gt;/</code>.</li> <li>Implement <code>execute_module</code> API that loads the configuration to device and generates the result with <code>changed</code>, <code>commands</code>, <code>before</code> and <code>after</code> keys.</li> <li>Call <code>get_facts</code> API that returns the <code>&lt;resource&gt;</code> configuration facts or return the difference if the device has onbox diff support.</li> <li>Compare facts gathered and given key-values if diff is not supported.</li> <li>Generate final configuration.</li> </ul> </dd> <dt>Utils</dt>
<dd>
<ul class="simple"> <li>
<code>module_utils/&lt;ansible_network_os&gt;/utils</code>.</li> <li>Utilities for the <code>&lt;ansible_network_os&gt;</code> platform.</li> </ul> </dd> </dl> </section> <section id="running-ansible-test-sanity-and-tox-on-resource-modules"> <h2 id="tox-resource-modules">Running <code>ansible-test sanity</code> and <code>tox</code> on resource modules</h2> <p>You should run <code>ansible-test sanity</code> and <code>tox -elinters</code> from the collection root directory before pushing your PR to an Ansible-maintained collection. The CI runs both and will fail if these tests fail. See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing.html#developing-testing"><span class="std std-ref">Testing Ansible</span></a> for details on <code>ansible-test sanity</code>.</p> <p>To install the necessary packages:</p> <ol class="arabic simple"> <li>Ensure you have a valid Ansible development environment configured. See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#environment-setup"><span class="std std-ref">Preparing an environment for developing Ansible modules</span></a> for details.</li> <li>Run <code>pip install -r requirements.txt</code> from the collection root directory.</li> </ol>  <p>Running <code>tox -elinters</code>:</p> <ul class="simple"> <li>Reads <code>tox.ini</code> from the collection root directory and installs required dependencies (such as <code>black</code> and <code>flake8</code>).</li> <li>Runs these with preconfigured options (such as line-length and ignores.)</li> <li>Runs <code>black</code> in check mode to show which files will be formatted without actually formatting them.</li> </ul>  </section> <section id="testing-resource-modules"> <h2>Testing resource modules</h2> <p>The tests rely on a role generated by the resource module builder. After changes to the resource module builder, the role should be regenerated and the tests modified and run as needed. To generate the role after changes:</p> <pre data-language="bash">rm -rf rmb_tests/roles/my_role
ansible-playbook -e rm_dest=./rmb_tests/roles/my_role \
                 -e structure=role \
                 -e model=models/myos/interfaces/myos_interfaces.yml \
                 site.yml
</pre> <section id="resource-module-integration-tests"> <h3 id="id3">Resource module integration tests</h3> <p>High-level integration test requirements for new resource modules are as follows:</p> <ol class="arabic simple"> <li>Write a test case for every state.</li> <li>Write additional test cases to test the behavior of the module when an empty <code>config.yaml</code> is given.</li> <li>Add a round trip test case. This involves a <code>merge</code> operation, followed by <code>gather_facts</code>, a <code>merge</code> update with additional configuration, and then reverting back to the base configuration using the previously gathered facts with the <code>state</code> set to <code>overridden</code>.</li> <li>Wherever applicable, assertions should check after and before <code>dicts</code> against a hard coded Source of Truth.</li> </ol> <p id="using-zuul-resource-modules">We use Zuul as the CI to run the integration test.</p> <ul class="simple"> <li>To view the report, click <span class="guilabel">Details</span> on the CI comment in the PR</li> <li>To view a failure report, click <span class="guilabel">ansible/check</span> and select the failed test.</li> <li>To view logs while the test is running, check for your PR number in the <a class="reference external" href="https://dashboard.zuul.ansible.com/t/ansible/status">Zuul status board</a>.</li> <li>To fix static test failure locally, run the <strong class="command">tox -e black</strong> <strong>inside the root folder of collection</strong>.</li> </ul> <p>To view The Ansible run logs and debug test failures:</p> <ol class="arabic simple"> <li>Click the failed job to get the summary, and click <span class="guilabel">Logs</span> for the log.</li> <li>Click <span class="guilabel">console</span> and scroll down to find the failed test.</li> <li>Click <span class="guilabel">&gt;</span> next to the failed test for complete details.</li> </ol> <section id="integration-test-structure"> <h4>Integration test structure</h4> <p>Each test case should generally follow this pattern:</p> <ul class="simple"> <li>setup —&gt; test —&gt; assert —&gt; test again (for idempotency) —&gt; assert —&gt; tear down (if needed) -&gt; done. This keeps test playbooks from becoming monolithic and difficult to troubleshoot.</li> <li>Include a name for each task that is not an assertion. You can add names to assertions as well, but it is easier to identify the broken task within a failed test if you add a name for each task.</li> <li>Files containing test cases must end in <code>.yaml</code>
</li> </ul> </section> <section id="implementation"> <h4>Implementation</h4> <p>For platforms that support <code>connection: local</code> <em>and</em> <code>connection: network_cli</code> use the following guidance:</p> <ul class="simple"> <li>Name the <code>targets/</code> directories after the module name.</li> <li>The <code>main.yaml</code> file should just reference the transport.</li> </ul> <p>The following example walks through the integration tests for the <code>vyos.vyos.vyos_l3_interfaces</code> module in the <a class="reference external" href="https://github.com/ansible-collections/vyos.vyos/tree/main/tests/integration">vyos.vyos</a> collection:</p> <p><code>test/integration/targets/vyos_l3_interfaces/tasks/main.yaml</code></p> <pre data-language="yaml">---
- import_tasks: cli.yaml
  tags:
    - cli
</pre> <p><code>test/integration/targets/vyos_l3_interfaces/tasks/cli.yaml</code></p> <pre data-language="yaml">---
- name: collect all cli test cases
  find:
    paths: "{{ role_path }}/tests/cli"
    patterns: "{{ testcase }}.yaml"
  register: test_cases
  delegate_to: localhost

- name: set test_items
  set_fact: test_items="{{ test_cases.files | map(attribute='path') | list }}"

- name: run test cases (connection=network_cli)
  include_tasks:
     file: "{{ test_case_to_run }}"
  vars:
     ansible_connection: network_cli
  with_items: "{{ test_items }}"
  loop_control:
    loop_var: test_case_to_run

- name: run test case (connection=local)
  include_tasks:
     file: "{{ test_case_to_run }}"
  vars:
     ansible_connection: local
     ansible_become: false
  with_first_found: "{{ test_items }}"
  loop_control:
    loop_var: test_case_to_run
</pre> <p><code>test/integration/targets/vyos_l3_interfaces/tests/cli/overridden.yaml</code></p> <pre data-language="yaml">---
- debug:
 msg: START vyos_l3_interfaces merged integration tests on connection={{ ansible_connection
   }}

- import_tasks: _remove_config.yaml

- block:

 - import_tasks: _populate.yaml

 - name: Overrides all device configuration with provided configuration
   register: result
   vyos.vyos.vyos_l3_interfaces: &amp;id001
     config:

       - name: eth0
         ipv4:

           - address: dhcp

       - name: eth1
         ipv4:

           - address: 192.0.2.15/24
     state: overridden

 - name: Assert that before dicts were correctly generated
   assert:
     that:
       - "{{ populate | symmetric_difference(result['before']) |length == 0 }}"

 - name: Assert that correct commands were generated
   assert:
     that:
       - "{{ overridden['commands'] | symmetric_difference(result['commands'])\
         \ |length == 0 }}"

 - name: Assert that after dicts were correctly generated
   assert:
     that:
       - "{{ overridden['after'] | symmetric_difference(result['after']) |length\
         \ == 0 }}"

 - name: Overrides all device configuration with provided configurations (IDEMPOTENT)
   register: result
   vyos.vyos.vyos_l3_interfaces: *id001

 - name: Assert that the previous task was idempotent
   assert:
     that:
       - result['changed'] == false

 - name: Assert that before dicts were correctly generated
   assert:
     that:
       - "{{ overridden['after'] | symmetric_difference(result['before']) |length\
         \ == 0 }}"
always:

 - import_tasks: _remove_config.yaml
</pre> </section> <section id="detecting-test-resources-at-runtime"> <h4>Detecting test resources at runtime</h4> <p>Your tests should detect resources (such as interfaces) at runtime rather than hard-coding them into the test. This allows the test to run on a variety of systems.</p> <p>For example:</p> <pre data-language="yaml">- name: Collect interface list
  connection: ansible.netcommon.network_cli
  register: intout
  cisco.nxos.nxos_command:
    commands:
      - show interface brief | json

- set_fact:
    intdataraw: "{{ intout.stdout_lines[0]['TABLE_interface']['ROW_interface'] }}"

- set_fact:
    nxos_int1: '{{ intdataraw[1].interface }}'

- set_fact:
    nxos_int2: '{{ intdataraw[2].interface }}'

- set_fact:
    nxos_int3: '{{ intdataraw[3].interface }}'
</pre> <p>See the complete test example of this at <a class="reference external" href="https://github.com/ansible-collections/cisco.nxos/blob/main/tests/integration/targets/prepare_nxos_tests/tasks/main.yml">https://github.com/ansible-collections/cisco.nxos/blob/main/tests/integration/targets/prepare_nxos_tests/tasks/main.yml</a>.</p> </section> <section id="running-network-integration-tests"> <h4>Running network integration tests</h4> <p>Ansible uses Zuul to run an integration test suite on every PR, including new tests introduced by that PR. To find and fix problems in network modules, run the network integration test locally before you submit a PR.</p> <p>First, create an inventory file that points to your test machines. The inventory group should match the platform name (for example, <code>eos</code>, <code>ios</code>):</p> <pre data-language="bash">cd test/integration
cp inventory.network.template inventory.networking
${EDITOR:-vi} inventory.networking
# Add in machines for the platform(s) you wish to test
</pre> <p>To run these network integration tests, use <code>ansible-test network-integration --inventory &lt;/path/to/inventory&gt; &lt;tests_to_run&gt;</code>:</p> <pre data-language="console">ansible-test network-integration  --inventory ~/myinventory -vvv vyos_facts
ansible-test network-integration  --inventory ~/myinventory -vvv vyos_.*
</pre> <p>To run all network tests for a particular platform:</p> <pre data-language="bash">ansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_.*
</pre> <p>This example will run against all <code>vyos</code> modules. Note that <code>vyos_.*</code> is a regex match, not a bash wildcard - include the <code>.</code> if you modify this example.</p> <p>To run integration tests for a specific module:</p> <pre data-language="bash">ansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_l3_interfaces
</pre> <p>To run a single test case on a specific module:</p> <pre data-language="bash"># Only run vyos_l3_interfaces/tests/cli/gathered.yaml
ansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking vyos_l3_interfaces --testcase gathered
</pre> <p>To run integration tests for a specific transport:</p> <pre data-language="bash"> # Only run nxapi test
ansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking  --tags="nxapi" nxos_.*

# Skip any cli tests
 ansible-test network-integration --inventory  /path/to-collection-module/test/integration/inventory.networking  --skip-tags="cli" nxos_.*
</pre> <p>See <a class="reference external" href="https://github.com/ansible-collections/cisco.nxos/blob/main/tests/integration/targets/nxos_bgp/tasks/main.yaml">test/integration/targets/nxos_bgp/tasks/main.yaml</a> for how this is implemented in the tests.</p> <p>For more options:</p> <pre data-language="bash">ansible-test network-integration --help
</pre> <p>If you need additional help or feedback, reach out to the community. Visit the <a class="reference internal" href="https://docs.ansible.com/ansible/latest/community/communication.html#communication"><span class="std std-ref">Ansible communication guide</span></a> for details.</p> </section> </section> <section id="unit-test-requirements"> <h3>Unit test requirements</h3> <p>High-level unit test requirements that new resource modules should follow:</p> <ol class="arabic simple"> <li>Write test cases for all the states with all possible combinations of config values.</li> <li>Write test cases to test the error conditions ( negative scenarios).</li> <li>Check the value of <code>changed</code> and <code>commands</code> keys in every test case.</li> </ol> <p>We run all unit test cases on our Zuul test suite, on the latest python version supported by our CI setup.</p> <p>Use the <a class="reference internal" href="#using-zuul-resource-modules"><span class="std std-ref">same procedure</span></a> as the integration tests to view Zuul unit tests reports and logs.</p> <p>See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html#testing-units-modules"><span class="std std-ref">unit module testing</span></a> for general unit test details.</p> </section> </section> <section id="example-unit-testing-ansible-network-resource-modules"> <h2>Example: Unit testing Ansible network resource modules</h2> <p>This section walks through an example of how to develop unit tests for Ansible resource modules.</p> <p>See <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html#testing-units"><span class="std std-ref">Unit Tests</span></a> and <a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing_units_modules.html#testing-units-modules"><span class="std std-ref">Unit Testing Ansible Modules</span></a> for general documentation on Ansible unit tests for modules. Please read those pages first to understand unit tests and why and when you should use them.</p> <section id="using-mock-objects-to-unit-test-ansible-network-resource-modules"> <h3>Using mock objects to unit test Ansible network resource modules</h3> <p><a class="reference external" href="https://docs.python.org/3/library/unittest.mock.html">Mock objects</a> can be very useful in building unit tests for special or difficult cases, but they can also lead to complex and confusing coding situations. One good use for mocks would be to simulate an API. The <code>mock</code> Python package is bundled with Ansible (use <code>import units.compat.mock</code>).</p> <p>You can mock the device connection and output from the device as follows:</p> <pre data-language="python">self.mock_get_config = patch( "ansible_collections.ansible.netcommon.plugins.module_utils.network.common.network.Config.get_config"
)
self.get_config = self.mock_get_config.start()

self.mock_load_config = patch(
"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.network.Config.load_config"
)
self.load_config = self.mock_load_config.start()

self.mock_get_resource_connection_config = patch(
"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.cfg.base.get_resource_connection"
)
self.get_resource_connection_config = (self.mock_get_resource_connection_config.start())

self.mock_get_resource_connection_facts = patch(
"ansible_collections.ansible.netcommon.plugins.module_utils.network.common.facts.facts.get_resource_connection"
)
self.get_resource_connection_facts = (self.mock_get_resource_connection_facts.start())

self.mock_edit_config = patch(
"ansible_collections.arista.eos.plugins.module_utils.network.eos.providers.providers.CliProvider.edit_config"
)
self.edit_config = self.mock_edit_config.start()

self.mock_execute_show_command = patch(
"ansible_collections.arista.eos.plugins.module_utils.network.eos.facts.l2_interfaces.l2_interfaces.L2_interfacesFacts.get_device_data"
)
self.execute_show_command = self.mock_execute_show_command.start()
</pre> <p>The facts file of the module now includes a new method, <code>get_device_data</code>. Call <code>get_device_data</code> here to emulate the device output.</p> </section> <section id="mocking-device-data"> <h3>Mocking device data</h3> <p>To mock fetching results from devices or provide other complex data structures that come from external libraries, you can use <code>fixtures</code> to read in pre-generated data. The text files for this pre-generated data live in <code>test/units/modules/network/PLATFORM/fixtures/</code>. See for example the <a class="reference external" href="https://github.com/ansible-collections/arista.eos/blob/main/tests/unit/modules/network/eos/fixtures/eos_l2_interfaces_config.cfg">eos_l2_interfaces.cfg file</a>.</p> <p>Load data using the <code>load_fixture</code> method and set this data as the return value of the <code>get_device_data</code> method in the facts file:</p> <pre data-language="python">def load_fixtures(self, commands=None, transport='cli'):
    def load_from_file(*args, **kwargs):
        return load_fixture('eos_l2_interfaces_config.cfg')
    self.execute_show_command.side_effect = load_from_file
</pre> <p>See the unit test file <a class="reference external" href="https://github.com/ansible-collections/arista.eos/blob/main/tests/unit/modules/network/eos/test_eos_l2_interfaces.py">test_eos_l2_interfaces</a> for a practical example.</p> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing_units.html#testing-units"><span class="std std-ref">Unit Tests</span></a></dt>
<dd>
<p>Deep dive into developing unit tests for Ansible modules</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/testing_running_locally.html#testing-running-locally"><span class="std std-ref">Testing Ansible and Collections</span></a></dt>
<dd>
<p>Running tests locally including gathering and reporting coverage data</p> </dd> <dt><a class="reference internal" href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.html#developing-modules-general"><span class="std std-ref">Developing modules</span></a></dt>
<dd>
<p>Get started developing a module</p> </dd> </dl> </div> </section> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012&ndash;2018 Michael DeHaan<br>&copy; 2018&ndash;2024 Red Hat, Inc.<br>Licensed under the GNU General Public License version 3.<br>
    <a href="https://docs.ansible.com/ansible/latest/network/dev_guide/developing_resource_modules_network.html" class="_attribution-link">https://docs.ansible.com/ansible/latest/network/dev_guide/developing_resource_modules_network.html</a>
  </p>
</div>
