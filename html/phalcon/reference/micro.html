<h1 id="micro-applications">Micro Applications</h1> <p>With Phalcon you can create “Micro-Framework like” applications. By doing this, you only need to write a minimal amount of code to create a PHP application. Micro applications are suitable to implement small applications, APIs and prototypes in a practical way.</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;

$app = new Micro();

$app-&gt;get(
    "/say/welcome/{name}",
    function ($name) {
        echo "&lt;h1&gt;Welcome $name!&lt;/h1&gt;";
    }
);

$app-&gt;handle();
</pre>  <h2 id="creating-a-micro-application">Creating a Micro Application</h2> <p><a class="reference internal" href="../api/phalcon_mvc_micro.html"><em>Phalcon\Mvc\Micro</em></a> is the class responsible for implementing a micro application.</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;

$app = new Micro();
</pre>   <h2 id="defining-routes">Defining routes</h2> <p>After instantiating the object, you will need to add some routes. <a class="reference internal" href="../api/phalcon_mvc_router.html"><em>Phalcon\Mvc\Router</em></a> manages routing internally. Routes must always start with /. A HTTP method constraint is optionally required when defining routes, so as to instruct the router to match only if the request also matches the HTTP methods. The following example shows how to define a route for the method GET:</p> <pre class="highlight-php" data-language="php">$app-&gt;get(
    "/say/hello/{name}",
    function ($name) {
        echo "&lt;h1&gt;Hello! $name&lt;/h1&gt;";
    }
);
</pre> <p>The “get” method indicates that the associated HTTP method is GET. The route <code class="code docutils literal"><span class="pre">/say/hello/{name}</span></code> also has a parameter <code class="code docutils literal"><span class="pre">{$name}</span></code> that is passed directly to the route handler (the anonymous function). Handlers are executed when a route is matched. A handler could be any callable item in the PHP userland. The following example shows how to define different types of handlers:</p> <pre class="highlight-php" data-language="php">// With a function
function say_hello($name) {
    echo "&lt;h1&gt;Hello! $name&lt;/h1&gt;";
}

$app-&gt;get(
    "/say/hello/{name}",
    "say_hello"
);

// With a static method
$app-&gt;get(
    "/say/hello/{name}",
    "SomeClass::someSayMethod"
);

// With a method in an object
$myController = new MyController();
$app-&gt;get(
    "/say/hello/{name}",
    [
        $myController,
        "someAction"
    ]
);

// Anonymous function
$app-&gt;get(
    "/say/hello/{name}",
    function ($name) {
        echo "&lt;h1&gt;Hello! $name&lt;/h1&gt;";
    }
);
</pre> <p><a class="reference internal" href="../api/phalcon_mvc_micro.html"><em>Phalcon\Mvc\Micro</em></a> provides a set of methods to define the HTTP method (or methods) which the route is constrained for:</p> <pre class="highlight-php" data-language="php">// Matches if the HTTP method is GET
$app-&gt;get(
    "/api/products",
    "get_products"
);

// Matches if the HTTP method is POST
$app-&gt;post(
    "/api/products/add",
    "add_product"
);

// Matches if the HTTP method is PUT
$app-&gt;put(
    "/api/products/update/{id}",
    "update_product"
);

// Matches if the HTTP method is DELETE
$app-&gt;delete(
    "/api/products/remove/{id}",
    "delete_product"
);

// Matches if the HTTP method is OPTIONS
$app-&gt;options(
    "/api/products/info/{id}",
    "info_product"
);

// Matches if the HTTP method is PATCH
$app-&gt;patch(
    "/api/products/update/{id}",
    "info_product"
);

// Matches if the HTTP method is GET or POST
$app-&gt;map(
    "/repos/store/refs",
    "action_product"
)-&gt;via(
    [
        "GET",
        "POST",
    ]
);
</pre> <p>To access the HTTP method data <code class="code docutils literal"><span class="pre">$app</span></code> needs to be passed into the closure:</p> <pre class="highlight-php" data-language="php">// Matches if the HTTP method is POST
$app-&gt;post(
    "/api/products/add",
    function () use ($app) {
        echo $app-&gt;request-&gt;getPost("productID");
    }
);
</pre>  <h3 id="routes-with-parameters">Routes with Parameters</h3> <p>Defining parameters in routes is very easy as demonstrated above. The name of the parameter has to be enclosed in brackets. Parameter formatting is also available using regular expressions to ensure consistency of data. This is demonstrated in the example below:</p> <pre class="highlight-php" data-language="php">// This route have two parameters and each of them have a format
$app-&gt;get(
    "/posts/{year:[0-9]+}/{title:[a-zA-Z\-]+}",
    function ($year, $title) {
        echo "&lt;h1&gt;Title: $title&lt;/h1&gt;";
        echo "&lt;h2&gt;Year: $year&lt;/h2&gt;";
    }
);
</pre>   <h3 id="starting-route">Starting Route</h3> <p>Normally, the starting route in an application is the route /, and it will more frequent to be accessed by the method GET. This scenario is coded as follows:</p> <pre class="highlight-php" data-language="php">// This is the start route
$app-&gt;get(
    "/",
    function () {
        echo "&lt;h1&gt;Welcome!&lt;/h1&gt;";
    }
);
</pre>   <h3 id="rewrite-rules">Rewrite Rules</h3> <p>The following rules can be used together with Apache to rewrite the URis:</p> <pre class="highlight-apacheconf" data-language="apacheconf">&lt;IfModule mod_rewrite.c&gt;
    RewriteEngine On
    RewriteCond %{REQUEST_FILENAME} !-f
    RewriteRule ^((?s).*)$ index.php?_url=/$1 [QSA,L]
&lt;/IfModule&gt;
</pre>    <h2 id="working-with-responses">Working with Responses</h2> <p>You are free to produce any kind of response in a handler: directly make an output, use a template engine, include a view, return a json, etc.:</p> <pre class="highlight-php" data-language="php">// Direct output
$app-&gt;get(
    "/say/hello",
    function () {
        echo "&lt;h1&gt;Hello! $name&lt;/h1&gt;";
    }
);

// Requiring another file
$app-&gt;get(
    "/show/results",
    function () {
        require "views/results.php";
    }
);

// Returning JSON
$app-&gt;get(
    "/get/some-json",
    function () {
        echo json_encode(
            [
                "some",
                "important",
                "data",
            ]
        );
    }
);
</pre> <p>In addition to that, you have access to the service <a class="reference internal" href="response.html"><em>“response”</em></a>, with which you can manipulate better the response:</p> <pre class="highlight-php" data-language="php">$app-&gt;get(
    "/show/data",
    function () use ($app) {
        // Set the Content-Type header
        $app-&gt;response-&gt;setContentType("text/plain");

        $app-&gt;response-&gt;sendHeaders();

        // Print a file
        readfile("data.txt");
    }
);
</pre> <p>Or create a response object and return it from the handler:</p> <pre class="highlight-php" data-language="php">$app-&gt;get(
    "/show/data",
    function () {
        // Create a response
        $response = new Phalcon\Http\Response();

        // Set the Content-Type header
        $response-&gt;setContentType("text/plain");

        // Pass the content of a file
        $response-&gt;setContent(file_get_contents("data.txt"));

        // Return the response
        return $response;
    }
);
</pre>   <h2 id="making-redirections">Making redirections</h2> <p>Redirections could be performed to forward the execution flow to another route:</p> <pre class="highlight-php" data-language="php">// This route makes a redirection to another route
$app-&gt;post("/old/welcome",
    function () use ($app) {
        $app-&gt;response-&gt;redirect("new/welcome");

        $app-&gt;response-&gt;sendHeaders();
    }
);

$app-&gt;post("/new/welcome",
    function () use ($app) {
        echo "This is the new Welcome";
    }
);
</pre>   <h2 id="generating-urls-for-routes">Generating URLs for Routes</h2> <p><a class="reference internal" href="url.html"><em>Phalcon\Mvc\Url</em></a> can be used to produce URLs based on the defined routes. You need to set up a name for the route; by this way the “url” service can produce the corresponding URL:</p> <pre class="highlight-php" data-language="php">// Set a route with the name "show-post"
$app-&gt;get(
    "/blog/{year}/{title}",
    function ($year, $title) use ($app) {
        // ... Show the post here
    }
)-&gt;setName("show-post");

// Produce a URL somewhere
$app-&gt;get(
    "/",
    function () use ($app) {
        echo '&lt;a href="', $app-&gt;url-&gt;get(
            [
                .html"for"   =&gt; "show-post",
                "title" =&gt; "php-is-a-great-framework",
                "year"  =&gt; 2015
            ]
        ), '"&gt;Show the post&lt;/a&gt;';
    }
);
</pre>   <h2 id="interacting-with-the-dependency-injector">Interacting with the Dependency Injector</h2> <p>In the micro application, a <a class="reference internal" href="di.html"><em>Phalcon\Di\FactoryDefault</em></a> services container is created implicitly; additionally you can create outside the application a container to manipulate its services:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;
use Phalcon\Di\FactoryDefault;
use Phalcon\Config\Adapter\Ini as IniConfig;

$di = new FactoryDefault();

$di-&gt;set(
    "config",
    function () {
        return new IniConfig("config.ini");
    }
);

$app = new Micro();

$app-&gt;setDI($di);

$app-&gt;get(
    "/",
    function () use ($app) {
        // Read a setting from the config
        echo $app-&gt;config-&gt;app_name;
    }
);

$app-&gt;post(
    "/contact",
    function () use ($app) {
        $app-&gt;flash-&gt;success("Yes!, the contact was made!");
    }
);
</pre> <p>The array-syntax is allowed to easily set/get services in the internal services container:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;
use Phalcon\Db\Adapter\Pdo\Mysql as MysqlAdapter;

$app = new Micro();

// Setup the database service
$app["db"] = function () {
    return new MysqlAdapter(
        [
            "host"     =&gt; "localhost",
            "username" =&gt; "root",
            "password" =&gt; "secret",
            "dbname"   =&gt; "test_db"
        ]
    );
};

$app-&gt;get(
    "/blog",
    function () use ($app) {
        $news = $app["db"]-&gt;query("SELECT * FROM news");

        foreach ($news as $new) {
            echo $new-&gt;title;
        }
    }
);
</pre>   <h2 id="not-found-handler">Not-Found Handler</h2> <p>When a user tries to access a route that is not defined, the micro application will try to execute the “Not-Found” handler. An example of that behavior is below:</p> <pre class="highlight-php" data-language="php">$app-&gt;notFound(
    function () use ($app) {
        $app-&gt;response-&gt;setStatusCode(404, "Not Found");

        $app-&gt;response-&gt;sendHeaders();

        echo "This is crazy, but this page was not found!";
    }
);
</pre>   <h2 id="models-in-micro-applications">Models in Micro Applications</h2> <p><a class="reference internal" href="models.html"><em>Models</em></a> can be used transparently in Micro Applications, only is required an autoloader to load models:</p> <pre class="highlight-php" data-language="php">$loader = new \Phalcon\Loader();

$loader-&gt;registerDirs(
    [
        __DIR__ . "/models/"
    ]
)-&gt;register();

$app = new \Phalcon\Mvc\Micro();

$app-&gt;get(
    "/products/find",
    function () {
        $products = Products::find();

        foreach ($products as $product) {
            echo $product-&gt;name, "&lt;br&gt;";
        }
    }
);

$app-&gt;handle();
</pre>   <h2 id="inject-model-instances">Inject model instances</h2> <p>By using class <a class="reference internal" href="../api/phalcon_mvc_model_binder.html"><em>Phalcon\Mvc\Model\Binder</em></a> you can inject model instances into your routes:</p> <pre class="highlight-php" data-language="php">$loader = new \Phalcon\Loader();

$loader-&gt;registerDirs(
    [
        __DIR__ . "/models/"
    ]
)-&gt;register();

$app = new \Phalcon\Mvc\Micro();
$app-&gt;setModelBinder(new \Phalcon\Mvc\Model\Binder());

$app-&gt;get(
    "/products/{product:[0-9]+}",
    function (Products $product) {
        // do anything with $product object
    }
);

$app-&gt;handle();
</pre> <blockquote class="highlights"> <div>Since Binder object is using internally Reflection Api which can be heavy there is ability to set cache. This can be done by using second argument in <code class="code docutils literal"><span class="pre">setModelBinder()</span></code> which can also accept service name or just by passing cache instance to <code class="code docutils literal"><span class="pre">Binder</span></code> constructor.</div>
</blockquote> <blockquote class="highlights"> <div>Currently the binder will only use the models primary key to perform a <code class="code docutils literal"><span class="pre">findFirst()</span></code> on. An example route for the above would be /products/1</div>
</blockquote>   <h2 id="micro-application-events">Micro Application Events</h2> <p><a class="reference internal" href="../api/phalcon_mvc_micro.html"><em>Phalcon\Mvc\Micro</em></a> is able to send events to the <a class="reference internal" href="events.html"><em>EventsManager</em></a> (if it is present). Events are triggered using the type “micro”. The following events are supported:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="74%"> <col width="13%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Event Name</th> <th class="head">Triggered</th> <th class="head">Can stop operation?</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>beforeHandleRoute</td> <td>The main method is just called, at this point the application doesn’t know if there is some matched route</td> <td>Yes</td> </tr> <tr class="row-odd">
<td>beforeExecuteRoute</td> <td>A route has been matched and it contains a valid handler, at this point the handler has not been executed</td> <td>Yes</td> </tr> <tr class="row-even">
<td>afterExecuteRoute</td> <td>Triggered after running the handler</td> <td>No</td> </tr> <tr class="row-odd">
<td>beforeNotFound</td> <td>Triggered when any of the defined routes match the requested URI</td> <td>Yes</td> </tr> <tr class="row-even">
<td>afterHandleRoute</td> <td>Triggered after completing the whole process in a successful way</td> <td>Yes</td> </tr> <tr class="row-odd">
<td>afterBinding</td> <td>Triggered after models are bound but before executing the handler</td> <td>Yes</td> </tr> </tbody> </table> <p>In the following example, we explain how to control the application security using events:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;
use Phalcon\Events\Event;
use Phalcon\Events\Manager as EventsManager;

// Create a events manager
$eventsManager = new EventsManager();

$eventsManager-&gt;attach(
    "micro:beforeExecuteRoute",
    function (Event $event, $app) {
        if ($app-&gt;session-&gt;get("auth") === false) {
            $app-&gt;flashSession-&gt;error("The user isn't authenticated");

            $app-&gt;response-&gt;redirect("/");

            $app-&gt;response-&gt;sendHeaders();

            // Return (false) stop the operation
            return false;
        }
    }
);

$app = new Micro();

// Bind the events manager to the app
$app-&gt;setEventsManager($eventsManager);
</pre>   <h2 id="middleware-events">Middleware events</h2> <p>In addition to the events manager, events can be added using the methods ‘before’, ‘after’ and ‘finish’:</p> <pre class="highlight-php" data-language="php">$app = new Phalcon\Mvc\Micro();

// Executed before every route is executed
// Return false cancels the route execution
$app-&gt;before(
    function () use ($app) {
        if ($app["session"]-&gt;get("auth") === false) {
            $app["flashSession"]-&gt;error("The user isn't authenticated");

            $app["response"]-&gt;redirect("/error");

            // Return false stops the normal execution
            return false;
        }

        return true;
    }
);

$app-&gt;map(
    "/api/robots",
    function () {
        return [
            "status" =&gt; "OK",
        ];
    }
);

$app-&gt;after(
    function () use ($app) {
        // This is executed after the route is executed
        echo json_encode($app-&gt;getReturnedValue());
    }
);

$app-&gt;finish(
    function () use ($app) {
        // This is executed when the request has been served
    }
);
</pre> <p>You can call the methods several times to add more events of the same type:</p> <pre class="highlight-php" data-language="php">$app-&gt;finish(
    function () use ($app) {
        // First 'finish' middleware
    }
);

$app-&gt;finish(
    function () use ($app) {
        // Second 'finish' middleware
    }
);
</pre> <p>Code for middlewares can be reused using separate classes:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro\MiddlewareInterface;

/**
 * CacheMiddleware
 *
 * Caches pages to reduce processing
 */
class CacheMiddleware implements MiddlewareInterface
{
    public function call($application)
    {
        $cache  = $application["cache"];
        $router = $application["router"];

        $key = preg_replace("/^[a-zA-Z0-9]/", "", $router-&gt;getRewriteUri());

        // Check if the request is cached
        if ($cache-&gt;exists($key)) {
            echo $cache-&gt;get($key);

            return false;
        }

        return true;
    }
}
</pre> <p>Then add the instance to the application:</p> <pre class="highlight-php" data-language="php">$app-&gt;before(
    new CacheMiddleware()
);
</pre> <p>The following middleware events are available:</p> <table class="docutils"> <colgroup> <col width="13%"> <col width="74%"> <col width="13%"> </colgroup> <thead valign="bottom"> <tr class="row-odd">
<th class="head">Event Name</th> <th class="head">Triggered</th> <th class="head">Can stop operation?</th> </tr> </thead> <tbody valign="top"> <tr class="row-even">
<td>before</td> <td>Before executing the handler. It can be used to control the access to the application</td> <td>Yes</td> </tr> <tr class="row-odd">
<td>after</td> <td>Executed after the handler is executed. It can be used to prepare the response</td> <td>No</td> </tr> <tr class="row-even">
<td>finish</td> <td>Executed after sending the response. It can be used to perform clean-up</td> <td>No</td> </tr> </tbody> </table> <div class="line-block"> <div class="line">finish | Executed after sending the response. It can be used to perform clean-up | No |</div> </div> <blockquote> <div>
<div class="line-block"> <div class="line"><br></div> </div> </div>
</blockquote>    <h2 id="using-controllers-as-handlers">Using Controllers as Handlers</h2> <p>Medium applications using the <code class="code docutils literal"><span class="pre">Mvc\Micro</span></code> approach may require organize handlers in controllers. You can use <a class="reference internal" href="../api/phalcon_mvc_micro_collection.html"><em>Phalcon\Mvc\Micro\Collection</em></a> to group handlers that belongs to controllers:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro\Collection as MicroCollection;

$posts = new MicroCollection();

// Set the main handler. ie. a controller instance
$posts-&gt;setHandler(
    new PostsController()
);

// Set a common prefix for all routes
$posts-&gt;setPrefix("/posts");

// Use the method 'index' in PostsController
$posts-&gt;get("/", "index");

// Use the method 'show' in PostsController
$posts-&gt;get("/show/{slug}", "show");

$app-&gt;mount($posts);
</pre> <p>The controller ‘PostsController’ might look like this:</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Controller;

class PostsController extends Controller
{
    public function index()
    {
        // ...
    }

    public function show($slug)
    {
        // ...
    }
}
</pre> <p>In the above example the controller is directly instantiated, Collection also have the ability to lazy-load controllers, this option provide better performance loading controllers only if the related routes are matched:</p> <pre class="highlight-php" data-language="php">$posts-&gt;setHandler("PostsController", true);
$posts-&gt;setHandler("Blog\Controllers\PostsController", true);
</pre>   <h2 id="returning-responses">Returning Responses</h2> <p>Handlers may return raw responses using <a class="reference internal" href="response.html"><em>Phalcon\Http\Response</em></a> or a component that implements the relevant interface. When responses are returned by handlers they are automatically sent by the application.</p> <pre class="highlight-php" data-language="php">use Phalcon\Mvc\Micro;
use Phalcon\Http\Response;

$app = new Micro();

// Return a response
$app-&gt;get(
    "/welcome/index",
    function () {
        $response = new Response();

        $response-&gt;setStatusCode(401, "Unauthorized");

        $response-&gt;setContent("Access is not authorized");

        return $response;
    }
);
</pre>   <h2 id="rendering-views">Rendering Views</h2> <p><a class="reference internal" href="views.html"><em>Phalcon\Mvc\View\Simple</em></a> can be used to render views, the following example shows how to do that:</p> <pre class="highlight-php" data-language="php">$app = new Phalcon\Mvc\Micro();

$app["view"] = function () {
    $view = new \Phalcon\Mvc\View\Simple();

    $view-&gt;setViewsDir("app/views/");

    return $view;
};

// Return a rendered view
$app-&gt;get(
    "/products/show",
    function () use ($app) {
        // Render app/views/products/show.phtml passing some variables
        echo $app["view"]-&gt;render(
            "products/show",
            [
                "id"   =&gt; 100,
                "name" =&gt; "Artichoke"
            ]
        );
    }
);
</pre> <p>Please note that this code block uses <a class="reference internal" href="../api/phalcon_mvc_view_simple.html"><em>Phalcon\Mvc\View\Simple</em></a> which uses relative paths instead of controllers and actions. If you would like to use <a class="reference internal" href="../api/phalcon_mvc_view_simple.html"><em>Phalcon\Mvc\View\Simple</em></a> instead, you will need to change the parameters of the <code class="code docutils literal"><span class="pre">render()</span></code> method:</p> <pre class="highlight-php" data-language="php">$app = new Phalcon\Mvc\Micro();

$app["view"] = function () {
    $view = new \Phalcon\Mvc\View();

    $view-&gt;setViewsDir("app/views/");

    return $view;
};

// Return a rendered view
$app-&gt;get(
    "/products/show",
    function () use ($app) {
        // Render app/views/products/show.phtml passing some variables
        echo $app["view"]-&gt;render(
            "products",
            "show",
            [
                "id"   =&gt; 100,
                "name" =&gt; "Artichoke"
            ]
        );
    }
);
</pre>   <h2 id="error-handling">Error Handling</h2> <p>A proper response can be generated if an exception is raised in a micro handler:</p> <pre class="highlight-php" data-language="php">$app = new Phalcon\Mvc\Micro();

$app-&gt;get(
    "/",
    function () {
        throw new \Exception("An error");
    }
);

$app-&gt;error(
    function ($exception) {
        echo "An error has occurred";
    }
);
</pre> <p>If the handler returns “false” the exception is stopped.</p>   <h2 id="related-sources">Related Sources</h2> <ul class="simple"> <li>
<a class="reference internal" href="tutorial-rest.html"><em>Creating a Simple REST API</em></a> is a tutorial that explains how to create a micro application to implement a RESTful web service.</li> <li>
<a class="reference external" href="http://store.phalconphp.com">Stickers Store</a> is a very simple micro-application making use of the micro-mvc approach [<a class="reference external" href="https://github.com/phalcon/store">Github</a>].</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2011&ndash;2017 Phalcon Framework Team<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="https://docs.phalconphp.com/en/latest/reference/micro.html" class="_attribution-link">https://docs.phalconphp.com/en/latest/reference/micro.html</a>
  </p>
</div>
