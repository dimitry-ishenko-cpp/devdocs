<p class="_links"><a href="../../dart-mirrors/dart-mirrors-library.html" class="_links-link">dart:mirrors</a></p> <h1>function property  </h1>  <section class="multi-line-signature" id="getter"> <a href="../methodmirror-class.html">MethodMirror</a> function </section>  <p>A mirror on the function associated with this closure.</p> <p>The function associated with an implicit closure of a function is that function.</p> <p>The function associated with an instance of a class that has a <code>call</code> method is that <code>call</code> method.</p> <p>A Dart implementation might choose to create a class for each closure expression, in which case <code>function</code> would be the same as <code>type.declarations[#call]</code>. But the Dart language model does not require this. A more typical implementation involves a single closure class for each type signature, where the call method dispatches to a function held in the closure rather the call method directly implementing the closure body. So one cannot rely on closures from distinct closure expressions having distinct classes (<code>type</code>), but one can rely on them having distinct functions (<code>function</code>).</p>   <h2 id="source">Implementation</h2> <pre class="language-dart" data-language="dart">MethodMirror get function;</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 the Dart project authors<br>Licensed under the BSD 3-Clause "New" or "Revised" License.<br>
    <a href="https://api.dart.dev/stable/2.18.5/dart-mirrors/ClosureMirror/function.html" class="_attribution-link">https://api.dart.dev/stable/2.18.5/dart-mirrors/ClosureMirror/function.html</a>
  </p>
</div>
