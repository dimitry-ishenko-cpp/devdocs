<h1 class="subsection" id="Self_002dReferential-Macros-1">3.10.5 Self-Referential Macros</h1> <div class="subsection-level-extent" id="Self_002dReferential-Macros">     <p>A <em class="dfn">self-referential</em> macro is one whose name appears in its definition. Recall that all macro definitions are rescanned for more macros to replace. If the self-reference were considered a use of the macro, it would produce an infinitely large expansion. To prevent this, the self-reference is not considered a macro call. It is passed into the preprocessor output unchanged. Consider an example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define foo (4 + foo)</pre>
</div> <p>where <code class="code">foo</code> is also a variable in your program. </p> <p>Following the ordinary rules, each reference to <code class="code">foo</code> will expand into <code class="code">(4 + foo)</code>; then this will be rescanned and will expand into <code class="code">(4 + (4 + foo))</code>; and so on until the computer runs out of memory. </p> <p>The self-reference rule cuts this process short after one step, at <code class="code">(4 + foo)</code>. Therefore, this macro definition has the possibly useful effect of causing the program to add 4 to the value of <code class="code">foo</code> wherever <code class="code">foo</code> is referred to. </p> <p>In most cases, it is a bad idea to take advantage of this feature. A person reading the program who sees that <code class="code">foo</code> is a variable will not expect that it is a macro as well. The reader will come across the identifier <code class="code">foo</code> in the program and think its value should be that of the variable <code class="code">foo</code>, whereas in fact the value is four greater. </p> <p>One common, useful use of self-reference is to create a macro which expands to itself. If you write </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define EPERM EPERM</pre>
</div> <p>then the macro <code class="code">EPERM</code> expands to <code class="code">EPERM</code>. Effectively, it is left alone by the preprocessor whenever it’s used in running text. You can tell that it’s a macro with ‘<samp class="samp">#ifdef</samp>’. You might do this if you want to define numeric constants with an <code class="code">enum</code>, but have ‘<samp class="samp">#ifdef</samp>’ be true for each constant. </p> <p>If a macro <code class="code">x</code> expands to use a macro <code class="code">y</code>, and the expansion of <code class="code">y</code> refers to the macro <code class="code">x</code>, that is an <em class="dfn">indirect self-reference</em> of <code class="code">x</code>. <code class="code">x</code> is not expanded in this case either. Thus, if we have </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define x (4 + y)
#define y (2 * x)</pre>
</div> <p>then <code class="code">x</code> and <code class="code">y</code> expand as follows: </p> <div class="example smallexample"> <div class="group"><pre class="example-preformatted" data-language="cpp">x    → (4 + y)
     → (4 + (2 * x))

y    → (2 * x)
     → (2 * (4 + y))</pre></div>
</div> <p>Each macro is expanded when it appears in the definition of the other macro, but not when it indirectly appears in its own definition. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Self_002dReferential-Macros.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Self_002dReferential-Macros.html</a>
  </p>
</div>
