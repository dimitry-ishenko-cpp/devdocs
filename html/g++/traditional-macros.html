<h1 class="section" id="Traditional-macros-1">10.2 Traditional macros</h1> <div class="section-level-extent" id="Traditional-macros">    <p>The major difference between traditional and ISO macros is that the former expand to text rather than to a token sequence. CPP removes all leading and trailing horizontal whitespace from a macro’s replacement text before storing it, but preserves the form of internal whitespace. </p> <p>One consequence is that it is legitimate for the replacement text to contain an unmatched quote (see <a class="pxref" href="traditional-lexical-analysis.html">Traditional lexical analysis</a>). An unclosed string or character constant continues into the text following the macro call. Similarly, the text at the end of a macro’s expansion can run together with the text after the macro invocation to produce a single token. </p> <p>Normally comments are removed from the replacement text after the macro is expanded, but if the <samp class="option">-CC</samp> option is passed on the command-line comments are preserved. (In fact, the current implementation removes comments even before saving the macro replacement text, but it careful to do it in such a way that the observed effect is identical even in the function-like macro case.) </p> <p>The ISO stringizing operator ‘<samp class="samp">#</samp>’ and token paste operator ‘<samp class="samp">##</samp>’ have no special meaning. As explained later, an effect similar to these operators can be obtained in a different way. Macro names that are embedded in quotes, either from the main file or after macro replacement, do not expand. </p> <p>CPP replaces an unquoted object-like macro name with its replacement text, and then rescans it for further macros to replace. Unlike standard macro expansion, traditional macro expansion has no provision to prevent recursion. If an object-like macro appears unquoted in its replacement text, it will be replaced again during the rescan pass, and so on <em class="emph">ad infinitum</em>. GCC detects when it is expanding recursive macros, emits an error message, and continues after the offending macro invocation. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define PLUS +
#define INC(x) PLUS+x
INC(foo);
     → ++foo;</pre>
</div> <p>Function-like macros are similar in form but quite different in behavior to their ISO counterparts. Their arguments are contained within parentheses, are comma-separated, and can cross physical lines. Commas within nested parentheses are not treated as argument separators. Similarly, a quote in an argument cannot be left unclosed; a following comma or parenthesis that comes before the closing quote is treated like any other character. There is no facility for handling variadic macros. </p> <p>This implementation removes all comments from macro arguments, unless the <samp class="option">-C</samp> option is given. The form of all other horizontal whitespace in arguments is preserved, including leading and trailing whitespace. In particular </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">f( )</pre>
</div> <p>is treated as an invocation of the macro ‘<samp class="samp">f</samp>’ with a single argument consisting of a single space. If you want to invoke a function-like macro that takes no arguments, you must not leave any whitespace between the parentheses. </p> <p>If a macro argument crosses a new line, the new line is replaced with a space when forming the argument. If the previous line contained an unterminated quote, the following line inherits the quoted state. </p> <p>Traditional preprocessors replace parameters in the replacement text with their arguments regardless of whether the parameters are within quotes or not. This provides a way to stringize arguments. For example </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define str(x) "x"
str(/* <span class="r">A comment</span> */some text )
     → "some text "</pre>
</div> <p>Note that the comment is removed, but that the trailing space is preserved. Here is an example of using a comment to effect token pasting. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define suffix(x) foo_/**/x
suffix(bar)
     → foo_bar</pre>
</div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Traditional-macros.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Traditional-macros.html</a>
  </p>
</div>
