<h1 class="section" id="Variadic-Macros-1">3.6 Variadic Macros</h1> <div class="section-level-extent" id="Variadic-Macros">       <p>A macro can be declared to accept a variable number of arguments much as a function can. The syntax for defining the macro is similar to that of a function. Here is an example: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define eprintf(...) fprintf (stderr, __VA_ARGS__)</pre>
</div> <p>This kind of macro is called <em class="dfn">variadic</em>. When the macro is invoked, all the tokens in its argument list after the last named argument (this macro has none), including any commas, become the <em class="dfn">variable argument</em>. This sequence of tokens replaces the identifier <code class="code">__VA_ARGS__</code> in the macro body wherever it appears. Thus, we have this expansion: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">eprintf ("%s:%d: ", input_file, lineno)
     →  fprintf (stderr, "%s:%d: ", input_file, lineno)</pre>
</div> <p>The variable argument is completely macro-expanded before it is inserted into the macro expansion, just like an ordinary argument. You may use the ‘<samp class="samp">#</samp>’ and ‘<samp class="samp">##</samp>’ operators to stringize the variable argument or to paste its leading or trailing token with another token. (But see below for an important special case for ‘<samp class="samp">##</samp>’.) </p> <p>If your macro is complicated, you may want a more descriptive name for the variable argument than <code class="code">__VA_ARGS__</code>. CPP permits this, as an extension. You may write an argument name immediately before the ‘<samp class="samp">...</samp>’; that name is used for the variable argument. The <code class="code">eprintf</code> macro above could be written </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define eprintf(args...) fprintf (stderr, args)</pre>
</div> <p>using this extension. You cannot use <code class="code">__VA_ARGS__</code> and this extension in the same macro. </p> <p>You can have named arguments as well as variable arguments in a variadic macro. We could define <code class="code">eprintf</code> like this, instead: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define eprintf(format, ...) fprintf (stderr, format, __VA_ARGS__)</pre>
</div> <p>This formulation looks more descriptive, but historically it was less flexible: you had to supply at least one argument after the format string. In standard C, you could not omit the comma separating the named argument from the variable arguments. (Note that this restriction has been lifted in C++20, and never existed in GNU C; see below.) </p> <p>Furthermore, if you left the variable argument empty, you would have gotten a syntax error, because there would have been an extra comma after the format string. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">eprintf("success!\n", );
     → fprintf(stderr, "success!\n", );</pre>
</div> <p>This has been fixed in C++20, and GNU CPP also has a pair of extensions which deal with this problem. </p> <p>First, in GNU CPP, and in C++ beginning in C++20, you are allowed to leave the variable argument out entirely: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">eprintf ("success!\n")
     → fprintf(stderr, "success!\n", );</pre>
</div> <p>Second, C++20 introduces the <code class="code">__VA_OPT__</code> function macro. This macro may only appear in the definition of a variadic macro. If the variable argument has any tokens, then a <code class="code">__VA_OPT__</code> invocation expands to its argument; but if the variable argument does not have any tokens, the <code class="code">__VA_OPT__</code> expands to nothing: </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define eprintf(format, ...) \
  fprintf (stderr, format __VA_OPT__(,) __VA_ARGS__)</pre>
</div> <p><code class="code">__VA_OPT__</code> is also available in GNU C and GNU C++. </p> <p>Historically, GNU CPP has also had another extension to handle the trailing comma: the ‘<samp class="samp">##</samp>’ token paste operator has a special meaning when placed between a comma and a variable argument. Despite the introduction of <code class="code">__VA_OPT__</code>, this extension remains supported in GNU CPP, for backward compatibility. If you write </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">#define eprintf(format, ...) fprintf (stderr, format, ##__VA_ARGS__)</pre>
</div> <p>and the variable argument is left out when the <code class="code">eprintf</code> macro is used, then the comma before the ‘<samp class="samp">##</samp>’ will be deleted. This does <em class="emph">not</em> happen if you pass an empty argument, nor does it happen if the token preceding ‘<samp class="samp">##</samp>’ is anything other than a comma. </p> <div class="example smallexample"> <pre class="example-preformatted" data-language="cpp">eprintf ("success!\n")
     → fprintf(stderr, "success!\n");</pre>
</div> <p>The above explanation is ambiguous about the case where the only macro parameter is a variable arguments parameter, as it is meaningless to try to distinguish whether no argument at all is an empty argument or a missing argument. CPP retains the comma when conforming to a specific C standard. Otherwise the comma is dropped as an extension to the standard. </p> <p>The C standard mandates that the only place the identifier <code class="code">__VA_ARGS__</code> can appear is in the replacement list of a variadic macro. It may not be used as a macro name, macro argument name, or within a different type of macro. It may also be forbidden in open text; the standard is ambiguous. We recommend you avoid using it except for its defined purpose. </p> <p>Likewise, C++ forbids <code class="code">__VA_OPT__</code> anywhere outside the replacement list of a variadic macro. </p> <p>Variadic macros became a standard part of the C language with C99. GNU CPP previously supported them with a named variable argument (‘<samp class="samp">args...</samp>’, not ‘<samp class="samp">...</samp>’ and <code class="code">__VA_ARGS__</code>), which is still supported for backward compatibility. </p> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Free Software Foundation<br>Licensed under the GNU Free Documentation License, Version 1.3.<br>
    <a href="https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Variadic-Macros.html" class="_attribution-link">https://gcc.gnu.org/onlinedocs/gcc-14.2.0/cpp/Variadic-Macros.html</a>
  </p>
</div>
