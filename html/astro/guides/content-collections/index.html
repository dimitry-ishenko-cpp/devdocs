<h1 id="_top" class="astro-556cgime">Content Collections</h1> <div class="content-panel astro-ayt3hsza"> <div class="sl-container astro-ayt3hsza"> <div class="sl-markdown-content astro-klj6ju3r"> <p><span> <strong>Added in:</strong> <code>astro@2.0.0</code> </span></p> <p><strong>Content collections</strong> are the best way to manage and author content in any Astro project. Collections help to organize your documents, validate your frontmatter, and provide automatic TypeScript type-safety for all of your content.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="what-are-content-collections">What are Content Collections?</h2></div> <p>A <strong>content collection</strong> is any top-level directory inside the reserved <code dir="auto">src/content</code> project directory, such as <code dir="auto">src/content/newsletter</code> and <code dir="auto">src/content/authors</code>. Only content collections are allowed inside the <code dir="auto">src/content</code> directory. This directory cannot be used for anything else.</p> <p>A <strong>collection entry</strong> is any piece of content stored inside of your content collection directory. Entries can use content authoring formats including Markdown (<code dir="auto">.md</code>) and MDX (<code dir="auto">.mdx</code> using the <a href="../integrations-guide/mdx/index.html">MDX integration</a>) or as one of two supported data formats: YAML (<code dir="auto">.yaml</code>) and JSON (<code dir="auto">.json</code>). We recommend using a consistent naming scheme (lower-case, dashes instead of spaces) for your files to make it easier to find and organize your content, but this is not required. You can also <a href="../routing/index.html#excluding-pages">exclude entries from being built</a> by prefixing the filename with an underscore (_).</p> <starlight-file-tree class="not-content astro-amtfieur" data-pagefind-ignore><ul><li class="directory"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span></span></summary><ul><li class="directory"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>newsletter/</strong></span> <span class="comment"> the “newsletter” collection </span></span></summary><ul>
<li class="file"><span class="tree-entry"><span class="">week-1.md</span> <span class="comment">a collection entry</span></span></li>
<li class="file"><span class="tree-entry"><span class="">week-2.md</span> <span class="comment">a collection entry</span></span></li>
<li class="file"><span class="tree-entry"><span class="">week-3.md</span> <span class="comment">a collection entry</span></span></li>
</ul></details></li></ul></details></li></ul></starlight-file-tree> <p>Once you have a collection, you can start <a href="#querying-collections">querying your content</a> using Astro’s built-in content APIs.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="the-astro-directory">The “.astro” Directory</h3></div> <p>Astro stores important metadata for content collections in an <code dir="auto">.astro</code> directory in your project. No action is needed on your part to maintain or update this directory. You are encouraged to ignore it entirely while working in your project.</p> <p>The <code dir="auto">.astro</code> directory will be updated for you automatically anytime you run the <a href="../../reference/cli-reference/index.html#astro-dev"><code dir="auto">astro dev</code></a>, <a href="../../reference/cli-reference/index.html#astro-build"><code dir="auto">astro build</code></a> commands. You can run <a href="../../reference/cli-reference/index.html#astro-sync"><code dir="auto">astro sync</code></a> at any time to update the <code dir="auto">.astro</code> directory manually.</p> <aside aria-label="Tip" class="starlight-aside starlight-aside--tip"><p class="starlight-aside__title" aria-hidden="true">Tip</p>
<section class="starlight-aside__content"><p>If you’re using Git for version control, we recommend ignoring the <code dir="auto">.astro</code> directory by adding <code dir="auto">.astro</code> to your <code dir="auto">.gitignore</code>. This tells Git to ignore this directory and any files inside of it.</p>
<div class="expressive-code">
<div class="_pre-heading">
<span class="sr-only">Terminal window</span>
</div>
<pre data-language="bash">echo "\n.astro" &gt;&gt; .gitignore</pre>

</div></section></aside> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="organizing-with-multiple-collections">Organizing with multiple collections</h3></div> <p>If two files represent different kinds of content (e.g. a blog post and an author profile), they most likely belong in different collections. This is important because many features (frontmatter validation, automatic TypeScript type-safety) require that all entries in a collection share a similar structure.</p> <p>If you find yourself working with different types of content, you should create multiple collections to represent each type. You can create as many different collections in your project as you’d like.</p> <starlight-file-tree class="not-content astro-amtfieur" data-pagefind-ignore><ul><li class="directory"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span></span></summary><ul>
<li class="directory"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>newsletter/</strong></span></span></summary><ul>
<li class="file"><span class="tree-entry"><span class="">week-1.md</span></span></li>
<li class="file"><span class="tree-entry"><span class="">week-2.md</span></span></li>
</ul></details></li>
<li class="directory"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>blog/</strong></span></span></summary><ul>
<li class="file"><span class="tree-entry"><span class="">post-1.md</span></span></li>
<li class="file"><span class="tree-entry"><span class="">post-2.md</span></span></li>
</ul></details></li>
<li class="directory"><details open><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>authors/</strong></span></span></summary><ul>
<li class="file"><span class="tree-entry"><span class="">grace-hopper.json</span></span></li>
<li class="file"><span class="tree-entry"><span class="">alan-turing.json</span></span></li>
</ul></details></li>
</ul></details></li></ul></starlight-file-tree> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="organizing-with-subdirectories">Organizing with subdirectories</h3></div> <p>A content collection is always a top-level folder inside of the <code dir="auto">src/content/</code> directory. You cannot nest one collection inside of another. However, you can use subdirectories to organize your content within a collection.</p> <p>For example, you can use the following directory structure to organize i18n translations within a single <code dir="auto">docs</code> collection. When you query this collection, you’ll be able to filter the result by language using the file path.</p> <starlight-file-tree class="not-content astro-amtfieur" data-pagefind-ignore><ul><li class="directory"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>src/content/ </span></span></summary><ul><li class="directory"><details open><summary><span class="tree-entry"><span class=""><span><span class="sr-only">Directory</span></span>docs/</span> <span class="comment">this collection uses subdirectories to organize by language </span></span></summary><ul>
<li class="directory"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>en/</strong></span></span></summary><ul><li class="file empty"><span class="tree-entry"><span class="">…</span></span></li></ul></details></li>
<li class="directory"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>es/</strong></span></span></summary><ul><li class="file empty"><span class="tree-entry"><span class="">…</span></span></li></ul></details></li>
<li class="directory"><details><summary><span class="tree-entry"><span class="highlight"><span><span class="sr-only">Directory</span></span><strong>de/</strong></span></span></summary><ul><li class="file empty"><span class="tree-entry"><span class="">…</span></span></li></ul></details></li>
</ul></details></li></ul></details></li></ul></starlight-file-tree> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="defining-collections">Defining Collections</h2></div> <aside aria-label="Note" class="starlight-aside starlight-aside--note"><p class="starlight-aside__title" aria-hidden="true">Note</p>
<section class="starlight-aside__content"><p>The <code dir="auto">src/content/config.ts</code> file is optional. However, choosing not to define your collections will disable some of their best features like frontmatter schema validation or automatic TypeScript typings.</p></section></aside> <p>To get the most out of your content collections, create a <code dir="auto">src/content/config.ts</code> file in your project (<code dir="auto">.js</code> and <code dir="auto">.mjs</code> extensions are also supported.) This is a special file that Astro will automatically load and use to configure your content collections.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">// 1. Import utilities from `astro:content`
import { defineCollection } from 'astro:content';
// 2. Define your collection(s)
const blogCollection = defineCollection({ /* ... */ });
// 3. Export a single `collections` object to register your collection(s)
//    This key should match your collection directory name in "src/content"
export const collections = {
  'blog': blogCollection,
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="setting-up-typescript">Setting up TypeScript</h3></div> <p>If you <strong>do not</strong> already extend Astro’s <code dir="auto">strict</code> or <code dir="auto">strictest</code> recommended TypeScript settings in your <code dir="auto">tsconfig.json</code> file, you may need to update your <code dir="auto">tsconfig.json</code> to enable <code dir="auto">strictNullChecks</code>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">tsconfig.json</span></div>
<pre data-language="json">{
  // Note: No change needed if you use "astro/tsconfigs/strict" or "astro/tsconfigs/strictest"
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true
  }
}</pre>

</div> <p>If you use <code dir="auto">.js</code> or <code dir="auto">.mjs</code> files in an Astro project, you can enable IntelliSense and type checking in your editor by enabling <code dir="auto">allowJs</code> in your <code dir="auto">tsconfig.json</code>:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">tsconfig.json</span></div>
<pre data-language="json">{
  // Note: No change needed if you use "astro/tsconfigs/strict" or "astro/tsconfigs/strictest"
  "extends": "astro/tsconfigs/base",
  "compilerOptions": {
    "strictNullChecks": true,
    "allowJs": true
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-a-collection-schema">Defining a collection schema</h3></div> <p>Schemas enforce consistent frontmatter or entry data within a collection. A schema <strong>guarantees</strong> that this data exists in a predictable form when you need to reference or query it. If any file violates its collection schema, Astro will provide a helpful error to let you know.</p> <p>Schemas also power Astro’s automatic TypeScript typings for your content. When you define a schema for your collection, Astro will automatically generate and apply a TypeScript interface to it. The result is full TypeScript support when you query your collection, including property autocompletion and type-checking.</p> <p>To define your first collection, create a <code dir="auto">src/content/config.ts</code> file if one does not already exist (<code dir="auto">.js</code> and <code dir="auto">.mjs</code> extensions are also supported.) This file should:</p> <ol> <li>
<strong>Import the proper utilities</strong> from <code dir="auto">astro:content</code>.</li> <li>
<strong>Define each collection that you’d like to validate.</strong> This includes a <code dir="auto">type</code> (introduced in Astro v2.5.0) specifying whether the collection contains content authoring formats like Markdown (<code dir="auto">type: 'content'</code>) or data formats like JSON or YAML (<code dir="auto">type: 'data'</code>). It also includes a <code dir="auto">schema</code> that defines the shape of your frontmatter or entry data.</li> <li>
<strong>Export a single <code dir="auto">collections</code> object</strong> to register your collections.</li> </ol> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">// 1. Import utilities from `astro:content`
import { z, defineCollection } from 'astro:content';


// 2. Define a `type` and `schema` for each collection
const blogCollection = defineCollection({
  type: 'content', // v2.5.0 and later
  schema: z.object({
    title: z.string(),
    tags: z.array(z.string()),
    image: z.string().optional(),
  }),
});


// 3. Export a single `collections` object to register your collection(s)
export const collections = {
  'blog': blogCollection,
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-multiple-collections">Defining multiple collections</h3></div> <p>You can use <code dir="auto">defineCollection()</code> as many times as you want to create multiple schemas. All collections must be exported from inside the single <code dir="auto">collections</code> object.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">const blogCollection = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const newsletter = defineCollection({
  type: 'content',
  schema: z.object({ /* ... */ })
});
const authors = defineCollection({
  type: 'data',
  schema: z.object({ /* ... */ })
});


export const collections = {
  'blog': blogCollection,
  'newsletter': newsletter,
  'authors': authors,
};</pre>

</div> <p>As your project grows, you are also free to reorganize your codebase and move logic out of the <code dir="auto">src/content/config.ts</code> file. Defining your schemas separately can be useful for reusing schemas across multiple collections and sharing schemas with other parts of your project.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">// 1. Import your utilities and schemas
import { defineCollection } from 'astro:content';
import { blogSchema, authorSchema } from '../schemas';


// 2. Define your collections
const blogCollection = defineCollection({
  type: 'content',
  schema: blogSchema,
});
const authorCollection = defineCollection({
  type: 'data',
  schema: authorSchema,
});


// 3. Export multiple collections to register them
export const collections = {
  'blog': blogCollection,
  'authors': authorCollection,
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="using-third-party-collection-schemas">Using third-party collection schemas</h3></div> <p>You can import collection schemas from anywhere, including external npm packages. This can be useful when working with themes and libraries that provide their own collection schemas for you to use.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">import { blogSchema } from 'my-blog-theme';
const blogCollection = defineCollection({ type: 'content', schema: blogSchema });


// Export the blog collection, using an external schema from 'my-blog-theme'
export const collections = {
  'blog': blogCollection,
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-datatypes-with-zod">Defining datatypes with Zod</h3></div> <p>Astro uses <a href="https://github.com/colinhacks/zod">Zod</a> to power its content schemas. With Zod, Astro is able to validate every file’s frontmatter within a collection <em>and</em> provide automatic TypeScript types when you go to query content from inside your project.</p> <p>To use Zod in Astro, import the <code dir="auto">z</code> utility from <code dir="auto">"astro:content"</code>. This is a re-export of the Zod library, and it supports all of the features of Zod. See <a href="https://github.com/colinhacks/zod">Zod’s README</a> for complete documentation on how Zod works and what features are available.</p> <div class="expressive-code">

<pre data-language="ts">// Example: A cheatsheet of many common Zod datatypes
import { z, defineCollection } from 'astro:content';


defineCollection({
  schema: z.object({
    isDraft: z.boolean(),
    title: z.string(),
    sortOrder: z.number(),
    image: z.object({
      src: z.string(),
      alt: z.string(),
    }),
    author: z.string().default('Anonymous'),
    language: z.enum(['en', 'es']),
    tags: z.array(z.string()),
    // An optional frontmatter property. Very common!
    footnote: z.string().optional(),
    // In frontmatter, dates written without quotes around them are interpreted as Date objects
    publishDate: z.date(),
    // You can also transform a date string (e.g. "2022-07-08") to a Date object
    // publishDate: z.string().transform((str) =&gt; new Date(str)),
    // Advanced: Validate that the string is also an email
    authorContact: z.string().email(),
    // Advanced: Validate that the string is also a URL
    canonicalURL: z.string().url(),
  })
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-collection-references">Defining collection references</h3></div> <p>Collection entries can also “reference” other related entries.</p> <p>With the <code dir="auto">reference()</code> function from the Collections API, you can define a property in a collection schema as an entry from another collection. For example, you can require that every <code dir="auto">space-shuttle</code> entry includes a <code dir="auto">pilot</code> property which uses the <code dir="auto">pilot</code> collection’s own schema for type checking, autocomplete, and validation.</p> <p>A common example is a blog post that references reusable author profiles stored as JSON, or related post URLs stored in the same collection:</p> <div class="expressive-code">

<pre data-language="ts">import { defineCollection, reference, z } from 'astro:content';


const blog = defineCollection({
  type: 'content',
  schema: z.object({
    title: z.string(),
    // Reference a single author from the `authors` collection by `id`
    author: reference('authors'),
    // Reference an array of related posts from the `blog` collection by `slug`
    relatedPosts: z.array(reference('blog')),
  })
});


const authors = defineCollection({
  type: 'data',
  schema: z.object({
    name: z.string(),
    portfolio: z.string().url(),
  })
});


export const collections = { blog, authors };</pre>

</div> <p>This example blog post specifies the <code dir="auto">slug</code>s of related posts and the <code dir="auto">id</code> of the post author:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/blog/welcome.md</span></div>
<pre data-language="yaml">---
title: "Welcome to my blog"
author: ben-holmes # references `src/content/authors/ben-holmes.json`
relatedPosts:
- about-me # references `src/content/blog/about-me.md`
- my-year-in-review # references `src/content/blog/my-year-in-review.md`
---</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="defining-custom-slugs">Defining custom slugs</h3></div> <p>When using <code dir="auto">type: 'content'</code>, every content entry generates a URL-friendly <code dir="auto">slug</code> property from its <a href="../../reference/api-reference/index.html#id">file <code dir="auto">id</code></a>. The slug is used to query the entry directly from your collection. It is also useful when creating new pages and URLs from your content.</p> <p>You can override an entry’s generated slug by adding your own <code dir="auto">slug</code> property to the file frontmatter. This is similar to the “permalink” feature of other web frameworks. <code dir="auto">"slug"</code> is a special, reserved property name that is not allowed in your custom collection <code dir="auto">schema</code> and will not appear in your entry’s <code dir="auto">data</code> property.</p> <div class="expressive-code">

<pre data-language="md">---
title: My Blog Post
slug: my-custom-slug/supports/slashes
---
Your blog post content here.</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="querying-collections">Querying Collections</h2></div> <p>Astro provides two functions to query a collection and return one (or more) content entries: <a href="../../reference/api-reference/index.html#getcollection"><code dir="auto">getCollection()</code></a> and <a href="../../reference/api-reference/index.html#getentry"><code dir="auto">getEntry()</code></a>.</p> <div class="expressive-code">

<pre data-language="js">import { getCollection, getEntry } from 'astro:content';


// Get all entries from a collection.
// Requires the name of the collection as an argument.
// Example: retrieve `src/content/blog/**`
const allBlogPosts = await getCollection('blog');


// Get a single entry from a collection.
// Requires the name of the collection and either
// the entry `slug` (content collections) or `id` (data collections)
// Example: retrieve `src/content/authors/grace-hopper.json`
const graceHopperProfile = await getEntry('authors', 'grace-hopper');</pre>

</div> <p>Both functions return content entries as defined by the <a href="../../reference/api-reference/index.html#collection-entry-type"><code dir="auto">CollectionEntry</code></a> type.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="accessing-referenced-data">Accessing referenced data</h3></div> <p>Any <a href="#defining-collection-references">references defined in your schema</a> must be queried separately after first querying your collection entry. You can use the <code dir="auto">getEntry()</code> function again, or <code dir="auto">getEntries()</code>, to retrieve the referenced entry from the returned <code dir="auto">data</code> object.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/blog/welcome.astro</span></div>
<pre data-language="astro">---
import { getEntry, getEntries } from 'astro:content';


const blogPost = await getEntry('blog', 'welcome');


// Resolve a singular reference
const author = await getEntry(blogPost.data.author);
// Resolve an array of references
const relatedPosts = await getEntries(blogPost.data.relatedPosts);
---


&lt;h1&gt;{blogPost.data.title}&lt;/h1&gt;
&lt;p&gt;Author: {author.data.name}&lt;/p&gt;


&lt;!-- ... --&gt;


&lt;h2&gt;You might also like:&lt;/h2&gt;
{relatedPosts.map(p =&gt; (
  &lt;a href={p.slug}&gt;{p.data.title}&lt;/a&gt;
))}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="filtering-collection-queries">Filtering collection queries</h3></div> <p><code dir="auto">getCollection()</code> takes an optional “filter” callback that allows you to filter your query based on an entry’s <code dir="auto">id</code> or <code dir="auto">data</code> (frontmatter) properties. For collections of <code dir="auto">type: 'content'</code>, you can also filter based on <code dir="auto">slug</code>.</p> <aside aria-label="Note" class="starlight-aside starlight-aside--note"><p class="starlight-aside__title" aria-hidden="true">Note</p>
<section class="starlight-aside__content"><p>The <code dir="auto">slug</code> property is specific to content collections, and will not be available when filtering collections of JSON or YAML.</p></section></aside> <p>You can use this to filter by any content criteria you like. For example, you can filter by properties like <code dir="auto">draft</code> to prevent any draft blog posts from publishing to your blog:</p> <div class="expressive-code">

<pre data-language="js">// Example: Filter out content entries with `draft: true`
import { getCollection } from 'astro:content';
const publishedBlogEntries = await getCollection('blog', ({ data }) =&gt; {
  return data.draft !== true;
});</pre>

</div> <p>You can also create draft pages that are available when running the dev server, but not built in production:</p> <div class="expressive-code">

<pre data-language="js">// Example: Filter out content entries with `draft: true` only when building for production
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog', ({ data }) =&gt; {
  return import.meta.env.PROD ? data.draft !== true : true;
});</pre>

</div> <p>The filter argument also supports filtering by nested directories within a collection. Since the <code dir="auto">id</code> includes the full nested path, you can filter by the start of each <code dir="auto">id</code> to only return items from a specific nested directory:</p> <div class="expressive-code">

<pre data-language="js">// Example: Filter entries by sub-directory in the collection
import { getCollection } from 'astro:content';
const englishDocsEntries = await getCollection('docs', ({ id }) =&gt; {
  return id.startsWith('en/');
});</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="using-content-in-astro-templates">Using content in Astro templates</h3></div> <p>Once you have queried your collection entries, you can access each entry directly inside of your Astro component template. This lets you to render HTML for things like links to your content (using the content <code dir="auto">slug</code>) or information about your content (using the <code dir="auto">data</code> property).</p> <p>For information about rendering your content to HTML, see <a href="#rendering-content-to-html">Rendering Content to HTML</a> below.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/index.astro</span></div>
<pre data-language="astro">---
import { getCollection } from 'astro:content';
const blogEntries = await getCollection('blog');
---
&lt;ul&gt;
  {blogEntries.map(blogPostEntry =&gt; (
    &lt;li&gt;
      &lt;a href={`/my-blog-url/${blogPostEntry.slug}`}&gt;{blogPostEntry.data.title}&lt;/a&gt;
      &lt;time datetime={blogPostEntry.data.publishedDate.toISOString()}&gt;
        {blogPostEntry.data.publishedDate.toDateString()}
      &lt;/time&gt;
    &lt;/li&gt;
  ))}
&lt;/ul&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="passing-content-as-props">Passing content as props</h3></div> <p>A component can also pass an entire content entry as a prop.</p> <p>If you do this, you can use the <a href="../../reference/api-reference/index.html#collection-entry-type"><code dir="auto">CollectionEntry</code></a> utility to correctly type your components props using TypeScript. This utility takes a string argument that matches the name of your collection schema, and will inherit all of the properties of that collection’s schema.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/components/BlogCard.astro</span></div>
<pre data-language="astro">---
import type { CollectionEntry } from 'astro:content';
interface Props {
  post: CollectionEntry&lt;'blog'&gt;;
}


// `post` will match your 'blog' collection schema type
const { post } = Astro.props;
---</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="rendering-content-to-html">Rendering content to HTML</h3></div> <p>Once queried, you can render Markdown and MDX entries to HTML using the entry <code dir="auto">render()</code> function property. Calling this function gives you access to rendered content and metadata, including both a <code dir="auto">&lt;Content /&gt;</code> component and a list of all rendered headings.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/render-example.astro</span></div>
<pre data-language="astro">---
import { getEntry } from 'astro:content';
const entry = await getEntry('blog', 'post-1');
const { Content, headings } = await entry.render();
---
&lt;p&gt;Published on: {entry.data.published.toDateString()}&lt;/p&gt;
&lt;Content /&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="generating-routes-from-content">Generating Routes from Content</h2></div> <p>Content collections are stored outside of the <code dir="auto">src/pages/</code> directory. This means that no routes are generated for your collection items by default. You will need to manually create a new <a href="../routing/index.html#dynamic-routes">dynamic route</a> to generate HTML pages from your collection entries. Your dynamic route will map the incoming request param (ex: <code dir="auto">Astro.params.slug</code> in <code dir="auto">src/pages/blog/[...slug].astro</code>) to fetch the correct entry inside a collection.</p> <p>The exact method for generating routes will depend on your build <a href="../../reference/configuration-reference/index.html#output"><code dir="auto">output</code></a> mode: ‘static’ (the default) or ‘server’ (for SSR).</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="building-for-static-output-default">Building for static output (default)</h3></div> <p>If you are building a static website (Astro’s default behavior), you would use the <a href="../../reference/api-reference/index.html#getstaticpaths"><code dir="auto">getStaticPaths()</code></a> function to create multiple pages from a single <code dir="auto">src/pages/</code> component during your build.</p> <p>Call <code dir="auto">getCollection()</code> inside of <code dir="auto">getStaticPaths()</code> to <a href="index.html#querying-collections">query your content or data collection</a>. Then, create your new URL paths using the <code dir="auto">slug</code> property (content collections) or <code dir="auto">id</code> property (data collections) of each content entry.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/posts/[...slug].astro</span></div>
<pre data-language="astro">---
import { getCollection } from 'astro:content';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map(entry =&gt; ({
    params: { slug: entry.slug }, props: { entry },
  }));
}
// 2. For your template, you can get the entry directly from the prop
const { entry } = Astro.props;
const { Content } = await entry.render();
---
&lt;h1&gt;{entry.data.title}&lt;/h1&gt;
&lt;Content /&gt;</pre>

</div> <p>This will generate a new page for every entry in the <code dir="auto">blog</code> collection. For example, an entry at <code dir="auto">src/content/blog/hello-world.md</code> will have a slug of <code dir="auto">hello-world</code>, and therefore its final URL will be <code dir="auto">/posts/hello-world/</code>.</p> <aside aria-label="Note" class="starlight-aside starlight-aside--note"><p class="starlight-aside__title" aria-hidden="true">Note</p>
<section class="starlight-aside__content"><p>If your custom slugs contain the <code dir="auto">/</code> character to produce URLs with multiple path segments, you must use a <a href="../routing/index.html#rest-parameters">rest parameter (<code dir="auto">[...slug]</code>)</a> in the <code dir="auto">.astro</code> filename for this dynamic routing page.</p></section></aside> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="building-for-server-output-ssr">Building for server output (SSR)</h3></div> <p>If you are building a dynamic website (using Astro’s SSR support), you are not expected to generate any paths ahead of time during the build. Instead, your page should examine the request (using <code dir="auto">Astro.request</code> or <code dir="auto">Astro.params</code>) to find the <code dir="auto">slug</code> on-demand, and then fetch it using <a href="../../reference/api-reference/index.html#getentry"><code dir="auto">getEntry()</code></a>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/posts/[...slug].astro</span></div>
<pre data-language="astro">---
import { getEntry } from "astro:content";
// 1. Get the slug from the incoming server request
const { slug } = Astro.params;
if (slug === undefined) {
  throw new Error("Slug is required");
}
// 2. Query for the entry directly using the request slug
const entry = await getEntry("blog", slug);
// 3. Redirect if the entry does not exist
if (entry === undefined) {
  return Astro.redirect("/404");
}
// 4. (Optional) Render the entry to HTML in the template
const { Content } = await entry.render();
---</pre>

</div> <aside aria-label="Tip" class="starlight-aside starlight-aside--tip"><p class="starlight-aside__title" aria-hidden="true">Tip</p>
<section class="starlight-aside__content"><p>Explore the <code dir="auto">src/pages/</code> folder of the <a href="https://github.com/withastro/blog-tutorial-demo/tree/content-collections/src/pages">blog tutorial demo code on GitHub</a> or <a href="https://stackblitz.com/github/withastro/blog-tutorial-demo/tree/content-collections?file=src/pages/blog.astro">open it in StackBlitz</a> to see full examples of creating pages from your collections for blog features like a list of blog posts, tags pages, and more!</p></section></aside> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="migrating-from-file-based-routing">Migrating from File-Based Routing</h2></div> <p>If you have an existing Astro project, such as a blog, that uses Markdown or MDX files in subfolders inside <code dir="auto">src/pages/</code>, consider migrating related content or data files to content collections.</p> <p>See how to convert a basic blog example from <code dir="auto">src/pages/posts/</code> to <code dir="auto">src/content/posts</code> in our <a href="https://docs.astro.build/en/tutorials/add-content-collections/">step-by-step tutorial</a> that uses the codebase from <a href="https://github.com/withastro/blog-tutorial-demo">the Build a Blog tutorial’s finished project</a>.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="enabling-json-schema-generation">Enabling JSON Schema Generation</h2></div> <p><span> <strong>Added in:</strong> <code>astro@4.13.0</code> </span></p> <p>If you are working with collections of type <code dir="auto">data</code>, Astro will auto-generate JSON schema files for your editor to get IntelliSense and type-checking. A separate file will be created for each data collection in your project based on your collections defined in <code dir="auto">src/content/config.ts</code> using a library called <a href="https://github.com/StefanTerdell/zod-to-json-schema#known-issues"><code dir="auto">zod-to-json-schema</code></a>.</p> <p>This feature requires you to manually set your schema’s file path as the value for <code dir="auto">$schema</code> in each data entry file of the collection:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/authors/armand.json</span></div>
<pre data-language="json">{
  "$schema": "../../../.astro/collections/authors.schema.json",
  "name": "Armand",
  "skills": ["Astro", "Starlight"]
}</pre>

</div> <p>Alternatively, you can set this value in your editor settings. For example, to set this value in <a href="https://code.visualstudio.com/docs/languages/json#_json-schemas-and-settings">VSCode’s <code dir="auto">json.schemas</code> setting</a>, provide the path of files to match and the location of your JSON schema:</p> <div class="expressive-code">

<pre data-language="json">{
  "json.schemas": [
    {
      "fileMatch": [
        "/src/content/authors/**"
      ],
      "url": "./.astro/collections/authors.schema.json"
    }
  ]
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="enabling-build-caching">Enabling Build Caching</h2></div> <p><span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span><span class="sl-badge default small neutral-badge astro-ctesguby">Experimental</span></p> <p>If you are working with large collections, you may wish to enable cached builds with the <a href="../../reference/configuration-reference/index.html#experimentalcontentcollectioncache"><code dir="auto">experimental.contentCollectionCache</code></a> flag. This experimental feature optimizes Astro’s build process, enabling unchanged collections to be stored and reused between builds.</p> <p>In many cases, this can lead to significant build performance improvements.</p> <p>While this feature stabilizes, you may run into issues with the stored cache. You can always reset your build cache by running the following command:</p> <div class="expressive-code">

<pre data-language="plaintext">npm run astro build -- --force</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="modifying-frontmatter-with-remark">Modifying Frontmatter with Remark</h2></div> <aside aria-label="Caution" class="starlight-aside starlight-aside--caution"><p class="starlight-aside__title" aria-hidden="true">Caution</p>
<section class="starlight-aside__content"><p><strong>Not recommended.</strong> Remark and rehype plugins access the <em>raw</em> Markdown or MDX document frontmatter. This means that <code dir="auto">remarkPluginFrontmatter</code> frontmatter is handled separately from your type-safe <code dir="auto">schema</code>, and will not reflect any changes or defaults applied through Astro. Use at your own risk!</p></section></aside> <p>Astro supports remark or rehype plugins that <a href="../markdown-content/index.html#modifying-frontmatter-programmatically">modify your frontmatter directly</a>. You can access this modified frontmatter inside of a content entry by using the <code dir="auto">remarkPluginFrontmatter</code> property returned from <code dir="auto">render()</code>:</p> <div class="expressive-code">

<pre data-language="astro">---
import { getEntry } from 'astro:content';
const blogPost = await getEntry('blog', 'post-1');
const { remarkPluginFrontmatter } = await blogPost.render();
---
&lt;p&gt;{blogPost.data.title} — {remarkPluginFrontmatter.readingTime}&lt;/p&gt;</pre>

</div> <div class="root astro-u7553m4s"> <div class="flex astro-u7553m4s"> <img src="data:image/webp;base64,UklGRuQEAABXRUJQVlA4WAoAAAAYAAAAMwAANQAAQUxQSGsCAAABoEZrmyFJeiMix7Zt27a9tm3btm3btm3bthVffO8iMyo7avZ/REwAVoo2y6zNnEnJOBS6dBzQdavzbr3ppFUaw5g0nEO94/9g7qebAZlzzpmaMQbo8SQpXsQLeRbyXU0YYNFdP9Mrc4PwkKG7HLD9FAdXA8CxJAOLVZn78hLY0hz2onhltKqIBHJnuJIsuv7KwFI9OQuuHIc16Vmy520wZW1DKUv5WV2YkubQl/dlWQZ13uRfJQkfhEG5DtOVXoJWpn9xI7iS4DDrXVYexJMXolzjsiyrg0abXPPoT9QYJcmjjKmVOVuRRewNlAjlCxfs2BX5rgILTN7/hOOOP/7E088++11q1K1HH374SSccf/xxW3WDMTEWHe5krDJWGfnb7og1aPw6JVIZH6TQk/vCFWU4in8wwUAOgi1Aw08ZUqDn/nBFXQPTFF4V0ztQE7klpldgmsKbq+KWqri5Aq2KNFcOWhVpVqJVEaj/D72VaQpviekZkrkZtU3BSCZzBwCbtwslDfKPB9cBXM7F9KmQfKA73H/upyQjnl8MgQMavM2QDPkX320Dg+bfUhPin7wQFi1/SksZBsO2+DEteu6HWo0/YUhK+DCAK6gimg4Dr2mITtf8SVLFS9Ak+CePtECP7W7/krHBF2qOBC3SIF7JNWAtgJbTdrngofd/FTIII+U//9UQJChzn10AADaz+G/Drq/Tk6+fdOYZZ5xx+tGHfkmv/PX6N/5g4V/v3nnoOMAg17gsc9iD5Fvb1kfhoOeo5Bh0HD5nlfU2WHX+6M4NAcAh0qK//+G69RoBtXKz2siOU+ENiDa1nAEAAFZQOCA8AgAAUA0AnQEqNAA2AD7lYqZPKSUjIiwVXZkgHIlkAMdkbc6KwKFXtoJpaNoyqLQ/FGN00F6wVZIfnXiVi1ZJjkcZ0nNZIsE90QHkgj4yGAjIg8GNR3g1bfXluGis9CqpEDIaIKQSEfuf2Uk/tJygs2T/CpkLOAD++90v7wUm4rf+3+Af0bFf9FDxRxPx/uyNmmuUn84N1S8oeCamnnI71i6f4UiRm8f9Hp1bg3B4DsRB5+mUgzo/4bnweeaxZgh0SL/aJJmVmzy9c8202SrAoix1gA9Mu6pJtpQzIzp5YuIDPxOw+qfShBsZNu7bs2FbLYm9QXO6KOogBnG8yukH0OwiE+DnM/TVmtkTBW16oDUc1kwDuwb2koEyJK3+nIi9vTEJbmgjzNy0hv2qQpmT8IGeGOmWASc8HdwGSXXiapinC4l4um2zabGEmrQWa8rLxGRQ/ZFsnmAvLdTLDk89DnLcpQ78xNMPbbKut8V2OvI0rPE6x/rStU9bxZRN+0T+Wa/kZPFrAtpeEMeI31JeMUUw7ki5RB5R3I4uviJ32A/q+PzE5/JGDVkn7vjHQboTyXOWWQI8qKDwRfPeR4/MHhDprmFlw7Qf/Y4VNXdX4X9DXrU1Dk02qM1tPVpcTLNneaESBYpH9S35JjhN7dD4DlrRVZjvdfI3Xa90VJCaBoCsRLS3lj97HXa2WoLFvBUR1hrmHn7KW+bQCefXaR8JfLC4VFMIDMFfZf8Lf7+0sF+p2hrsjrlHvC/Z1Mf4AABFWElGDgAAAE1NACoAAAAIAAAAAAAA" width="24" alt="" class="astro-u7553m4s"> <strong class="astro-u7553m4s">Related recipe:</strong> <a href="../../recipes/reading-time/index.html" class="astro-u7553m4s"> Add reading time </a> </div> </div> <p>The remark and rehype pipelines only run when your content is rendered, which explains why <code dir="auto">remarkPluginFrontmatter</code> is only available after you call <code dir="auto">render()</code> on your content entry. In contrast, <code dir="auto">getCollection()</code> and <code dir="auto">getEntry()</code> cannot return these values directly because they do not render your content.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="working-with-dates-in-the-frontmatter">Working with dates in the frontmatter</h2></div> <p>Several date formats are possible in content collections, but your collection’s schema must match the format used in your Markdown or MDX YAML frontmatter.</p> <p>YAML uses the <a href="https://www.iso.org/iso-8601-date-and-time-format.html">ISO-8601</a> standard to express dates. Use the format <code dir="auto">yyyy-mm-dd</code> (e.g. <code dir="auto">2021-07-28</code>) along with a schema type of <code dir="auto">z.date()</code>:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/posts/example-post.md</span></div>
<pre data-language="markdown">---
title: My Blog Post
pubDate: 2021-07-08
---</pre>

</div> <p>The date format will be specified in UTC if a timezone is not provided. If you need to specify a timezone, you can use the <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601</a> format.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/posts/example-post.md</span></div>
<pre data-language="markdown">---
title: My Blog Post
pubDate: 2021-07-08T12:00:00-04:00
---</pre>

</div> <p>To render only the <code dir="auto">YYYY-MM-DD</code> from the full UTC timestamp, use the JavaScript <code dir="auto">slice</code> method to remove the timestamp:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/layouts/ExampleLayout.astro</span></div>
<pre data-language="astro">---
const { frontmatter } = Astro.props;
---
&lt;h1&gt;{frontmatter.title}&lt;/h1&gt;
&lt;p&gt;{frontmatter.pubDate.toISOString().slice(0,10)}&lt;/p&gt;</pre>

</div> <p>To see an example of using <code dir="auto">toLocaleDateString</code> to format the day, month, and year instead, see the <a href="https://github.com/withastro/astro/blob/latest/examples/blog/src/components/FormattedDate.astro"><code dir="auto">&lt;FormattedDate /&gt;</code> component</a> in the official Astro blog template.</p> <span id="docsearch-lvl0" hidden class="astro-klj6ju3r">Learn</span> </div>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 Fred K. Schott<br>Licensed under the MIT License.<br>
    <a href="https://docs.astro.build/en/guides/content-collections/" class="_attribution-link">https://docs.astro.build/en/guides/content-collections/</a>
  </p>
</div>
