<h1 id="_top" class="astro-556cgime">Astro Integration API</h1> <div class="content-panel astro-ayt3hsza"> <div class="sl-container astro-ayt3hsza"> <div class="sl-markdown-content astro-klj6ju3r"> <p><strong>Astro Integrations</strong> add new functionality and behaviors for your project with only a few lines of code.</p> <p>This reference page is for anyone writing their own integration. To learn how to use an integration in your project, check out our <a href="../../guides/integrations-guide/index.html">Using Integrations</a> guide instead.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="examples">Examples</h2></div> <p>The official Astro integrations can act as reference for you as you go to build your own integrations.</p> <ul> <li>
<strong>Renderers:</strong> <a href="../../guides/integrations-guide/lit/index.html"><code dir="auto">lit</code></a>, <a href="../../guides/integrations-guide/svelte/index.html"><code dir="auto">svelte</code></a>, <a href="../../guides/integrations-guide/react/index.html"><code dir="auto">react</code></a>, <a href="../../guides/integrations-guide/preact/index.html"><code dir="auto">preact</code></a>, <a href="../../guides/integrations-guide/vue/index.html"><code dir="auto">vue</code></a>, <a href="../../guides/integrations-guide/solid-js/index.html"><code dir="auto">solid</code></a>
</li> <li>
<strong>Libraries:</strong> <a href="../../guides/integrations-guide/tailwind/index.html"><code dir="auto">tailwind</code></a>, <a href="../../guides/integrations-guide/partytown/index.html"><code dir="auto">partytown</code></a>
</li> <li>
<strong>Features:</strong> <a href="../../guides/integrations-guide/sitemap/index.html"><code dir="auto">sitemap</code></a>
</li> </ul> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="quick-api-reference">Quick API Reference</h2></div> <div class="expressive-code">

<pre data-language="ts">interface AstroIntegration {
  name: string;
  hooks: {
    'astro:config:setup'?: (options: {
      config: AstroConfig;
      command: 'dev' | 'build' | 'preview';
      isRestart: boolean;
      updateConfig: (newConfig: DeepPartial&lt;AstroConfig&gt;) =&gt; AstroConfig;
      addRenderer: (renderer: AstroRenderer) =&gt; void;
      addWatchFile: (path: URL | string) =&gt; void;
      addClientDirective: (directive: ClientDirectiveConfig) =&gt; void;
      addMiddleware: (middleware: AstroIntegrationMiddleware) =&gt; void;
      addDevToolbarApp: (pluginEntrypoint: string) =&gt; void;
      injectScript: (stage: InjectedScriptStage, content: string) =&gt; void;
      injectRoute: (injectedRoute: { pattern: string, entrypoint: string }) =&gt; void;
      logger: AstroIntegrationLogger;
    }) =&gt; void | Promise&lt;void&gt;;
    'astro:config:done'?: (options: {
      config: AstroConfig;
      setAdapter: (adapter: AstroAdapter) =&gt; void;
      injectTypes: (injectedType: { filename: string; content: string }) =&gt; URL;
      logger: AstroIntegrationLogger;
      }) =&gt; void | Promise&lt;void&gt;;
    'astro:route:setup'?: (options: { route: RouteOptions; logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:server:setup'?: (options: { server: vite.ViteDevServer; logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:server:start'?: (options: { address: AddressInfo; logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:server:done'?: (options: { logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:build:start'?: (options: { logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:build:setup'?: (options: {
      vite: ViteConfigWithSSR;
      pages: Map&lt;string, PageBuildData&gt;;
      target: 'client' | 'server';
      logger: AstroIntegrationLogger;
    }) =&gt; void | Promise&lt;void&gt;;
    'astro:build:generated'?: (options: { dir: URL; logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;
    'astro:build:ssr'?: (options: {
        manifest: SerializedSSRManifest;
        entryPoints: Map&lt;RouteData, URL&gt;;
        logger: AstroIntegrationLogger;
    }) =&gt; void | Promise&lt;void&gt;;
    'astro:build:done'?: (options: { dir: URL; routes: RouteData[]; logger: AstroIntegrationLogger; }) =&gt; void | Promise&lt;void&gt;;


    // ... any custom hooks from integrations
  };
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="hooks">Hooks</h2></div> <p>Astro provides hooks that integrations can implement to execute during certain parts of Astro’s lifecycle. Astro hooks are defined in the <code dir="auto">IntegrationHooks</code> interface, which is part of the global <code dir="auto">Astro</code> namespace.</p> <p>The following hooks are built in to Astro:</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroconfigsetup"><code dir="auto">astro:config:setup</code></h3></div> <p><strong>Next hook:</strong> <a href="#astroconfigdone"><code dir="auto">astro:config:done</code></a></p> <p><strong>When:</strong> On initialization, before either the <a href="https://vitejs.dev/config/">Vite</a> or <a href="../configuration-reference/index.html">Astro config</a> have resolved.</p> <p><strong>Why:</strong> To extend the project config. This includes updating the <a href="../configuration-reference/index.html">Astro config</a>, applying <a href="https://vitejs.dev/guide/api-plugin.html">Vite plugins</a>, adding component renderers, and injecting scripts onto the page.</p> <div class="expressive-code">

<pre data-language="ts">'astro:config:setup'?: (options: {
  config: AstroConfig;
  command: 'dev' | 'build' | 'preview';
  isRestart: boolean;
  updateConfig: (newConfig: DeepPartial&lt;AstroConfig&gt;) =&gt; AstroConfig;
  addRenderer: (renderer: AstroRenderer) =&gt; void;
  addClientDirective: (directive: ClientDirectiveConfig) =&gt; void;
  addMiddleware: (middleware: AstroIntegrationMiddleware) =&gt; void;
  addDevToolbarApp: (pluginEntrypoint: string) =&gt; void;
  addWatchFile: (path: URL | string) =&gt; void;
  injectScript: (stage: InjectedScriptStage, content: string) =&gt; void;
  injectRoute: ({ pattern: string, entrypoint: string }) =&gt; void;
  logger: AstroIntegrationLogger;
}) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="config-option">
<code dir="auto">config</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">AstroConfig</code></p> <p>A read-only copy of the user-supplied <a href="../configuration-reference/index.html">Astro config</a>. This is resolved <em>before</em> any other integrations have run. If you need a copy of the config after all integrations have completed their config updates, <a href="#astroconfigdone">see the <code dir="auto">astro:config:done</code> hook</a>.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="command-option">
<code dir="auto">command</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">'dev' | 'build' | 'preview'</code></p> <ul> <li>
<code dir="auto">dev</code> - Project is executed with <code dir="auto">astro dev</code>
</li> <li>
<code dir="auto">build</code> - Project is executed with <code dir="auto">astro build</code>
</li> <li>
<code dir="auto">preview</code> - Project is executed with <code dir="auto">astro preview</code>
</li> </ul> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="isrestart-option">
<code dir="auto">isRestart</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">boolean</code></p> <p><code dir="auto">false</code> when the dev server starts, <code dir="auto">true</code> when a reload is triggered. Useful to detect when this function is called more than once.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="updateconfig-option">
<code dir="auto">updateConfig</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">(newConfig: DeepPartial&lt;AstroConfig&gt;) =&gt; AstroConfig;</code></p> <p>A callback function to update the user-supplied <a href="../configuration-reference/index.html">Astro config</a>. Any config you provide <strong>will be merged with the user config + other integration config updates,</strong> so you are free to omit keys!</p> <p>For example, say you need to supply a <a href="https://vitejs.dev/">Vite</a> plugin to the user’s project:</p> <div class="expressive-code">

<pre data-language="js">import bananaCSS from '@vitejs/official-banana-css-plugin';


export default {
  name: 'banana-css-integration',
  hooks: {
    'astro:config:setup': ({ updateConfig }) =&gt; {
      updateConfig({
        vite: {
          plugins: [bananaCSS()],
        }
      })
    }
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="addrenderer-option">
<code dir="auto">addRenderer</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">(renderer:</code> <a href="https://github.com/withastro/astro/blob/fdd607c5755034edf262e7b275732519328a33b2/packages/astro/src/%40types/astro.ts#L872-L883"><code dir="auto">AstroRenderer</code></a> <code dir="auto">) =&gt; void;</code> <strong>Examples:</strong> <a href="https://github.com/withastro/astro/blob/main/packages/integrations/lit/src/index.ts"><code dir="auto">lit</code></a>, <a href="https://github.com/withastro/astro/blob/main/packages/integrations/svelte/src/index.ts"><code dir="auto">svelte</code></a>, <a href="https://github.com/withastro/astro/blob/main/packages/integrations/react/src/index.ts"><code dir="auto">react</code></a>, <a href="https://github.com/withastro/astro/blob/main/packages/integrations/preact/src/index.ts"><code dir="auto">preact</code></a>, <a href="https://github.com/withastro/astro/blob/main/packages/integrations/vue/src/index.ts"><code dir="auto">vue</code></a>, <a href="https://github.com/withastro/astro/blob/main/packages/integrations/solid/src/index.ts"><code dir="auto">solid</code></a></p> <p>A callback function to add a component framework renderer (i.e. React, Vue, Svelte, etc). You can browse the examples and type definition above for more advanced options, but here are the 2 main options to be aware of:</p> <ul> <li>
<code dir="auto">clientEntrypoint</code> - path to a file that executes on the client whenever your component is used. This is mainly for rendering or hydrating your component with JS.</li> <li>
<code dir="auto">serverEntrypoint</code> - path to a file that executes during server-side requests or static builds whenever your component is used. These should render components to static markup, with hooks for hydration where applicable. <a href="https://react.dev/reference/react-dom/server/renderToString">React’s <code dir="auto">renderToString</code> callback</a> is a classic example.</li> </ul> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="addwatchfile-option">
<code dir="auto">addWatchFile</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">URL | string</code></p> <p>If your integration depends on some configuration file that Vite doesn’t watch and/or needs a full dev server restart to take effect, add it with <code dir="auto">addWatchFile</code>. Whenever that file changes, the Astro dev server will be reloaded (you can check when a reload happens with <code dir="auto">isRestart</code>).</p> <p>Example usage:</p> <div class="expressive-code">

<pre data-language="js">// Must be an absolute path!
addWatchFile('/home/user/.../my-config.json');
addWatchFile(new URL('./tailwind.config.js', config.root));</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="addclientdirective-option">
<code dir="auto">addClientDirective</code> option</h4></div> <p><span> <strong>Added in:</strong> <code>astro@2.6.0</code> </span></p> <p><strong>Type:</strong> <code dir="auto">(directive:</code> <a href="https://github.com/withastro/astro/blob/00327c213f74627ac9ca1dec774efa5bf71e9375/packages/astro/src/%40types/astro.ts#L1872-L1875"><code dir="auto">ClientDirectiveConfig</code></a> <code dir="auto">) =&gt; void;</code></p> <p>Adds a <a href="../directives-reference/index.html#custom-client-directives">custom client directive</a> to be used in <code dir="auto">.astro</code> files.</p> <p>Note that directive entrypoints are only bundled through esbuild and should be kept small so they don’t slow down component hydration.</p> <p>Example usage:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig } from 'astro/config';
import clickDirective from './astro-click-directive/register.js'


// https://astro.build/config
export default defineConfig({
  integrations: [
    clickDirective()
  ],
});</pre>

</div> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro-click-directive/register.js</span></div>
<pre data-language="js">/**
 * @type {() =&gt; import('astro').AstroIntegration}
 */
export default () =&gt; ({
  name: "client:click",
  hooks: {
    "astro:config:setup": ({ addClientDirective }) =&gt; {
      addClientDirective({
        name: "click",
        entrypoint: "./astro-click-directive/click.js",
      });
    },
  },
});</pre>

</div> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro-click-directive/click.js</span></div>
<pre data-language="js">/**
 * Hydrate on first click on the window
 * @type {import('astro').ClientDirective}
 */
export default (load, opts, el) =&gt; {
  window.addEventListener('click', async () =&gt; {
    const hydrate = await load()
    await hydrate()
  }, { once: true })
}</pre>

</div> <p>You can also add types for the directives in your library’s type definition file:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro-click-directive/index.d.ts</span></div>
<pre data-language="ts">import 'astro'
declare module 'astro' {
  interface AstroClientDirectives {
    'client:click'?: boolean
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="adddevtoolbarapp-option">
<code dir="auto">addDevToolbarApp</code> option</h4></div> <p><span> <strong>Added in:</strong> <code>astro@3.4.0</code> </span></p> <p><strong>Type:</strong> <code dir="auto">(pluginEntrypoint: string) =&gt; void;</code></p> <p>Adds a <a href="../dev-toolbar-app-reference/index.html">custom dev toolbar app</a>.</p> <p>Example usage:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig } from 'astro/config';
import devToolbarIntegration from './astro-dev-toolbar-app/integration.js'


// https://astro.build/config
export default defineConfig({
  integrations: [
    devToolbarIntegration()
  ],
});</pre>

</div> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro-dev-toolbar-app/integration.js</span></div>
<pre data-language="js">/**
 * @type {() =&gt; import('astro').AstroIntegration}
 */
export default () =&gt; ({
  name: "dev-toolbar-app",
  hooks: {
    "astro:config:setup": ({ addDevToolbarApp }) =&gt; {
      addDevToolbarApp("./astro-dev-toolbar-app/plugin.js");
    },
  },
});</pre>

</div> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro-dev-toolbar-app/plugin.js</span></div>
<pre data-language="js">/**
 * @type {import('astro').DevToolbarApp}
 */
export default {
  id: "my-plugin",
  name: "My Plugin",
  icon: "&lt;svg&gt;...&lt;/svg&gt;",
  init() {
    console.log("I'm a dev toolbar app!")
  },
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="addmiddleware-option">
<code dir="auto">addMiddleware</code> option</h4></div> <p><span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span></p> <p><strong>Type:</strong> <code dir="auto">(middleware:</code> <a href="https://github.com/withastro/astro/blob/852ac0f75dfca1b2602e9cdbfa0447d9998e2449/packages/astro/src/%40types/astro.ts#L2124-L2127"><code dir="auto">AstroIntegrationMiddleware</code></a> <code dir="auto">) =&gt; void;</code></p> <p>Adds <a href="../../guides/middleware/index.html">middleware</a> to run on each request. Takes the <code dir="auto">entrypoint</code> module that contains the middleware, and an <code dir="auto">order</code> to specify whether it should run before (<code dir="auto">pre</code>) other middleware or after (<code dir="auto">post</code>).</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">@my-package/integration.js</span></div>
<pre data-language="js">/**
 * @type {() =&gt; import('astro').AstroIntegration}
 */
export default () =&gt; ({
  name: "my-middleware-package",
  hooks: {
    "astro:config:setup": ({ addMiddleware }) =&gt; {
        addMiddleware({
          entrypoint: '@my-package/middleware',
          order: 'pre'
        });
    },
  },
});</pre>

</div> <p>Middleware is defined in a package with an <code dir="auto">onRequest</code> function, as with user-defined middleware.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">@my-package/middleware.js</span></div>
<pre data-language="js">import { defineMiddleware } from 'astro:middleware';


export const onRequest = defineMiddleware(async (context, next) =&gt; {
  if(context.url.pathname === '/some-test-path') {
    return Response.json({
      ok: true
    });
  }


  return next();
});</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="injectroute-option">
<code dir="auto">injectRoute</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">({ pattern: string, entrypoint: string }) =&gt; void;</code></p> <p>A callback function to inject routes into an Astro project. Injected routes can be <a href="../../basics/astro-pages/index.html"><code dir="auto">.astro</code> pages</a> or <a href="../../guides/endpoints/index.html#static-file-endpoints"><code dir="auto">.js</code> and <code dir="auto">.ts</code> route handlers</a>.</p> <p><code dir="auto">injectRoute</code> takes an object with a <code dir="auto">pattern</code> and an <code dir="auto">entrypoint</code>.</p> <ul> <li>
<code dir="auto">pattern</code> - where the route should be output in the browser, for example <code dir="auto">/foo/bar</code>. A <code dir="auto">pattern</code> can use Astro’s filepath syntax for denoting dynamic routes, for example <code dir="auto">/foo/[bar]</code> or <code dir="auto">/foo/[...bar]</code>. Note that a file extension is <strong>not</strong> needed in the <code dir="auto">pattern</code>.</li> <li>
<code dir="auto">entrypoint</code> - a bare module specifier pointing towards the <code dir="auto">.astro</code> page or <code dir="auto">.js</code>/<code dir="auto">.ts</code> route handler that handles the route denoted in the <code dir="auto">pattern</code>.</li> </ul> <div tabindex="-1" class="heading-wrapper level-h5"><h5 id="example-usage">Example usage</h5></div> <div class="expressive-code">

<pre data-language="js">injectRoute({
  // Use Astro’s pattern syntax for dynamic routes.
  pattern: '/subfolder/[dynamic]',
  // Use relative path syntax for a local route.
  entrypoint: './src/dynamic-page.astro'
});</pre>

</div> <p>For an integration designed to be installed in other projects, use its package name to refer to the route entrypoint. The following example shows a package published to npm as <code dir="auto">@fancy/dashboard</code> injecting a dashboard route:</p> <div class="expressive-code">

<pre data-language="js">injectRoute({
  pattern: '/fancy-dashboard',
  entrypoint: '@fancy/dashboard/dashboard.astro'
});</pre>

</div> <p>When publishing your package (<code dir="auto">@fancy/dashboard</code>, in this case) to npm, you must export <code dir="auto">dashboard.astro</code> in your <code dir="auto">package.json</code>:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">package.json</span></div>
<pre data-language="json">{
  "name": "@fancy/dashboard",
  // ...
  "exports": { "./dashboard.astro": "./dashboard.astro" }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="injectscript-option">
<code dir="auto">injectScript</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">(stage: InjectedScriptStage, content: string) =&gt; void;</code></p> <p>A callback function to inject a string of JavaScript content onto every page.</p> <p>The <strong><code dir="auto">stage</code></strong> denotes how this script (the <code dir="auto">content</code>) should be inserted. Some stages allow inserting scripts without modification, while others allow optimization during <a href="https://vitejs.dev/guide/build.html">Vite’s bundling step</a>:</p> <ul> <li> <p><code dir="auto">"head-inline"</code>: Injected into a script tag in the <code dir="auto">&lt;head&gt;</code> of every page. <strong>Not</strong> optimized or resolved by Vite.</p> </li> <li> <p><code dir="auto">"before-hydration"</code>: Imported client-side, before the hydration script runs. Optimized and resolved by Vite.</p> </li> <li> <p><code dir="auto">"page"</code>: Similar to <code dir="auto">head-inline</code>, except that the injected snippet is handled by Vite and bundled with any other <code dir="auto">&lt;script&gt;</code> tags defined inside of Astro components on the page. The script will be loaded with a <code dir="auto">&lt;script type="module"&gt;</code> in the final page output, optimized and resolved by Vite.</p> </li> <li> <p><code dir="auto">"page-ssr"</code>: Imported as a separate module in the frontmatter of every Astro page component. Because this stage imports your script, the <code dir="auto">Astro</code> global is not available and your script will only be run once when the <code dir="auto">import</code> is first evaluated.</p> <p>The main use for the <code dir="auto">page-ssr</code> stage is injecting a CSS <code dir="auto">import</code> into every page to be optimized and resolved by Vite:</p> <div class="expressive-code">

<pre data-language="js">injectScript('page-ssr', 'import "global-styles.css";');</pre>

</div> </li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroconfigdone"><code dir="auto">astro:config:done</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astroconfigsetup"><code dir="auto">astro:config:setup</code></a></p> <p><strong>Next hook:</strong> <a href="#astroserversetup"><code dir="auto">astro:server:setup</code></a> when running in “dev” mode, or <a href="#astrobuildstart"><code dir="auto">astro:build:start</code></a> during production builds</p> <p><strong>When:</strong> After the Astro config has resolved and other integrations have run their <code dir="auto">astro:config:setup</code> hooks.</p> <p><strong>Why:</strong> To retrieve the final config for use in other hooks.</p> <div class="expressive-code">

<pre data-language="js">'astro:config:done'?: (options: {
  config: AstroConfig;
  setAdapter: (adapter: AstroAdapter) =&gt; void;
  injectTypes: (injectedType: { filename: string; content: string }) =&gt; URL;
  logger: AstroIntegrationLogger;
}) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="config-option-1">
<code dir="auto">config</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">AstroConfig</code></p> <p>A read-only copy of the user-supplied <a href="../configuration-reference/index.html">Astro config</a>. This is resolved <em>after</em> other integrations have run.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="setadapter-option">
<code dir="auto">setAdapter</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">(adapter: AstroAdapter) =&gt; void;</code></p> <p>Makes the integration an adapter. Read more in the <a href="../adapter-reference/index.html">adapter API</a>.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="injecttypes-options">
<code dir="auto">injectTypes</code> options</h4></div> <p><span> <strong>Added in:</strong> <code>astro@4.14.0</code> <span class="sl-badge default small astro-ctesguby">New</span> </span></p> <p><strong>Type:</strong> <code dir="auto">(injectedType: { filename: string; content: string }) =&gt; URL</code></p> <p>Allows you to inject types into your user’s project by adding a new <code dir="auto">*.d.ts</code> file.</p> <p>The <code dir="auto">filename</code> property will be used to generate a file at <code dir="auto">/.astro/integrations/&lt;normalized_integration_name&gt;/&lt;normalized_filename&gt;.d.ts</code> and must end with <code dir="auto">".d.ts"</code>.</p> <p>The <code dir="auto">content</code> property will create the body of the file and must be valid TypeScript.</p> <p>Additionally, <code dir="auto">injectTypes()</code> returns a URL to the normalized path so you can overwrite its content later on, or manipulate it in any way you want.</p> <div class="expressive-code">

<pre data-language="js">const path = injectTypes({
  filename: "types.d.ts",
  content: "declare module 'virtual:integration' {}"
})
console.log(path) // URL</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroserversetup"><code dir="auto">astro:server:setup</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astroconfigdone"><code dir="auto">astro:config:done</code></a></p> <p><strong>Next hook:</strong> <a href="#astroserverstart"><code dir="auto">astro:server:start</code></a></p> <p><strong>When:</strong> Just after the Vite server is created in “dev” mode, but before the <code dir="auto">listen()</code> event is fired. <a href="https://vitejs.dev/guide/api-javascript.html#createserver">See Vite’s createServer API</a> for more.</p> <p><strong>Why:</strong> To update Vite server options and middleware.</p> <div class="expressive-code">

<pre data-language="js">'astro:server:setup'?: (options: { server: vite.ViteDevServer }) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="server-option">
<code dir="auto">server</code> option</h4></div> <p><strong>Type:</strong> <a href="https://vitejs.dev/guide/api-javascript.html#vitedevserver"><code dir="auto">ViteDevServer</code></a></p> <p>A mutable instance of the Vite server used in “dev” mode. For instance, this is <a href="../../guides/integrations-guide/partytown/index.html">used by our Partytown integration</a> to inject the Partytown server as middleware:</p> <div class="expressive-code">

<pre data-language="js">export default {
  name: 'partytown',
  hooks: {
    'astro:server:setup': ({ server }) =&gt; {
      server.middlewares.use(
        function middleware(req, res, next) {
          // handle requests
        }
      );
    }
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroserverstart"><code dir="auto">astro:server:start</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astroserversetup"><code dir="auto">astro:server:setup</code></a></p> <p><strong>Next hook:</strong> <a href="#astroserverdone"><code dir="auto">astro:server:done</code></a></p> <p><strong>When:</strong> Just after the server’s <code dir="auto">listen()</code> event has fired.</p> <p><strong>Why:</strong> To intercept network requests at the specified address. If you intend to use this address for middleware, consider using <code dir="auto">astro:server:setup</code> instead.</p> <div class="expressive-code">

<pre data-language="js">'astro:server:start'?: (options: { address: AddressInfo }) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="address-option">
<code dir="auto">address</code> option</h4></div> <p><strong>Type:</strong> <a href="https://microsoft.github.io/PowerBI-JavaScript/interfaces/_node_modules__types_node_net_d_._net_.addressinfo.html"><code dir="auto">AddressInfo</code></a></p> <p>The address, family and port number supplied by the <a href="https://nodejs.org/api/net.html">Node.js Net module</a>.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroserverdone"><code dir="auto">astro:server:done</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astroserverstart"><code dir="auto">astro:server:start</code></a></p> <p><strong>When:</strong> Just after the dev server is closed.</p> <p><strong>Why:</strong> To run any cleanup events you may trigger during the <code dir="auto">astro:server:setup</code> or <code dir="auto">astro:server:start</code> hooks.</p> <div class="expressive-code">

<pre data-language="js">'astro:server:done'?: () =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astrobuildstart"><code dir="auto">astro:build:start</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astroconfigdone"><code dir="auto">astro:config:done</code></a></p> <p><strong>Next hook:</strong> <a href="#astrobuildsetup"><code dir="auto">astro:build:setup</code></a></p> <p><strong>When:</strong> After the <code dir="auto">astro:config:done</code> event, but before the production build begins.</p> <p><strong>Why:</strong> To set up any global objects or clients needed during a production build. This can also extend the build configuration options in the <a href="../adapter-reference/index.html">adapter API</a>.</p> <div class="expressive-code">

<pre data-language="js">'astro:build:start'?: () =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astrobuildsetup"><code dir="auto">astro:build:setup</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astrobuildstart"><code dir="auto">astro:build:start</code></a></p> <p><strong>Next hook:</strong> <a href="#astrobuildssr"><code dir="auto">astro:build:ssr</code></a></p> <p><strong>When:</strong> After the <code dir="auto">astro:build:start</code> hook, runs immediately before the build.</p> <p><strong>Why:</strong> At this point, the Vite config for the build has been completely constructed, this is your final chance to modify it. This can be useful for example to overwrite some defaults. If you’re not sure whether you should use this hook or <code dir="auto">astro:build:start</code>, use <code dir="auto">astro:build:start</code> instead.</p> <div class="expressive-code">

<pre data-language="js">'astro:build:setup'?: (options: {
  vite: ViteConfigWithSSR;
  pages: Map&lt;string, PageBuildData&gt;;
  target: 'client' | 'server';
}) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astrobuildgenerated"><code dir="auto">astro:build:generated</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astrobuildsetup"><code dir="auto">astro:build:setup</code></a></p> <p><strong>When:</strong> After a static production build has finished generating routes and assets.</p> <p><strong>Why:</strong> To access generated routes and assets <strong>before</strong> build artifacts are cleaned up. This is a very uncommon use case. We recommend using <a href="#astrobuilddone"><code dir="auto">astro:build:done</code></a> unless you really need to access the generated files before cleanup.</p> <div class="expressive-code">

<pre data-language="js">'astro:build:generated'?: (options: { dir: URL }) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astrobuildssr"><code dir="auto">astro:build:ssr</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astrobuildsetup"><code dir="auto">astro:build:setup</code></a></p> <p><strong>When:</strong> After a production SSR build has completed.</p> <p><strong>Why:</strong> To access the SSR manifest and map of the emitted entry points. This is useful when creating custom SSR builds in plugins or integrations.</p> <ul> <li>
<code dir="auto">entryPoints</code> maps a page route to the physical file emitted after the build;</li> <li>
<code dir="auto">middlewareEntryPoint</code> is the file system path of the middleware file;</li> </ul> <div class="expressive-code">

<pre data-language="js">'astro:build:ssr'?: (options: {
    manifest: SerializedSSRManifest,
    entryPoints: Map&lt;RouteData, URL&gt;,
    middlewareEntryPoint: URL
}) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astrobuilddone"><code dir="auto">astro:build:done</code></h3></div> <p><strong>Previous hook:</strong> <a href="#astrobuildssr"><code dir="auto">astro:build:ssr</code></a></p> <p><strong>When:</strong> After a production build (SSG or SSR) has completed.</p> <p><strong>Why:</strong> To access generated routes and assets for extension (ex. copy content into the generated <code dir="auto">/assets</code> directory). If you plan to transform generated assets, we recommend exploring the <a href="https://vitejs.dev/guide/api-plugin.html">Vite Plugin API</a> and <a href="#updateconfig-option">configuring via <code dir="auto">astro:config:setup</code></a> instead.</p> <div class="expressive-code">

<pre data-language="js">'astro:build:done'?: (options: { dir: URL; routes: RouteData[], pages: { pathname: string }[] }) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="dir-option">
<code dir="auto">dir</code> option</h4></div> <p><strong>Type:</strong> <a href="https://developer.mozilla.org/en-US/docs/Web/API/URL"><code dir="auto">URL</code></a></p> <p>A URL path to the build output directory. Note that if you need a valid absolute path string, you should use Node’s built-in <a href="https://nodejs.org/api/url.html#urlfileurltopathurl"><code dir="auto">fileURLToPath</code></a> utility.</p> <div class="expressive-code">

<pre data-language="js">import { writeFile } from 'node:fs/promises';
import { fileURLToPath } from 'node:url';


export default function myIntegration() {
  return {
    hooks: {
      'astro:build:done': async ({ dir }) =&gt; {
        const metadata = await getIntegrationMetadata();
        // Use fileURLToPath to get a valid, cross-platform absolute path string
        const outFile = fileURLToPath(new URL('./my-integration.json', dir));
        await writeFile(outFile, JSON.stringify(metadata));
      }
    }
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="routes-option">
<code dir="auto">routes</code> option</h4></div> <p><strong>Type:</strong> <a href="#routedata-type-reference"><code dir="auto">RouteData[]</code></a></p> <p>A list of all generated routes alongside their associated metadata.</p> <p>You can reference the full <code dir="auto">RouteData</code> type below, but the most common properties are:</p> <ul> <li>
<code dir="auto">component</code> - the input file path relative to the project root</li> <li>
<code dir="auto">pathname</code> - the output file URL (undefined for routes using <code dir="auto">[dynamic]</code> and <code dir="auto">[...spread]</code> params)</li> </ul> <div tabindex="-1" class="heading-wrapper level-h5"><h5 id="routedata-type-reference">
<code dir="auto">RouteData</code> type reference</h5></div> <div class="expressive-code">

<pre data-language="ts">interface RouteData {
  /** Whether a given route is an HTML page or non-HTML endpoint */
  type: 'page' | 'endpoint';
  /** Source component URL */
  component: string;
  /**
   * Output URL pathname where this route will be served
   * note: will be undefined for [dynamic] and [...spread] routes
   */
  pathname?: string;
  /**
   * regex used for matching an input URL against a requested route
   * ex. "[fruit]/about.astro" will generate the pattern: /^\/([^/]+?)\/about\/?$/
   * where pattern.test("banana/about") is "true"
   */
  pattern: RegExp;
  /**
   * Dynamic and spread route params
   * ex. "/pages/[lang]/[..slug].astro" will output the params ['lang', '...slug']
   */
  params: string[];
  /**
   * Similar to the "params" field, but with more associated metadata
   * ex. "/pages/[lang]/index.astro" will output the segments
   * [[ { content: 'lang', dynamic: true, spread: false } ]]
   */
  segments: { content: string; dynamic: boolean; spread: boolean; }[][];
  /**
   * Function to render component in-place from a set of input data.
   * This is typically for internal use, so call with caution!
   */
  generate: (data?: any) =&gt; string;
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="pages-option">
<code dir="auto">pages</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">{ pathname: string }[]</code></p> <p>A list of all generated pages. It is an object with one property.</p> <ul> <li>
<code dir="auto">pathname</code> - the finalized path of the page.</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="astroroutesetup"><code dir="auto">astro:route:setup</code></h3></div> <p><span> <strong>Added in:</strong> <code>astro@4.14.0</code> <span class="sl-badge default small astro-ctesguby">New</span> </span></p> <p><strong>When:</strong> In <code dir="auto">astro dev</code>, whenever a route is requested. In <code dir="auto">astro build</code>, while bundling and transforming a route file.</p> <p><strong>Why:</strong> To set options for a route at build or request time, such as enabling <a href="../../guides/server-side-rendering/index.html#opting-in-to-pre-rendering-in-server-mode">on-demand server rendering</a>.</p> <div class="expressive-code">

<pre data-language="js">'astro:route:setup'?: (options: { route: RouteOptions }) =&gt; void | Promise&lt;void&gt;;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="route-option">
<code dir="auto">route</code> option</h4></div> <p><strong>Type:</strong> <code dir="auto">RouteOptions</code></p> <p>An object with a <code dir="auto">component</code> property to identify the route and the following additional values to allow you to configure the generated route: <code dir="auto">prerender</code>.</p> <p>The <code dir="auto">component</code> property is a readonly string path relative to the project root, e.g <code dir="auto">"src/pages/blog/[slug].astro"</code>.</p> <div tabindex="-1" class="heading-wrapper level-h5"><h5 id="routeprerender"><code dir="auto">route.prerender</code></h5></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">undefined</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.14.0</code> <span class="sl-badge default small astro-ctesguby">New</span> </span> <p>The <code dir="auto">prerender</code> property is used to configure <a href="../../guides/server-side-rendering/index.html#opting-in-to-pre-rendering-in-server-mode">on-demand server rendering</a> for a route. If the route file contains an explicit <code dir="auto">export const prerender</code> value, the value will be used as the default instead of <code dir="auto">undefined</code>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig } from 'astro/config';


export default defineConfig({
  integrations: [setPrerender()],
});


function setPrerender() {
  return {
    name: 'set-prerender',
    hooks: {
      'astro:route:setup': ({ route }) =&gt; {
        if (route.component.endsWith('/blog/[slug].astro')) {
          route.prerender = true;
        }
      },
    },
  };
}</pre>

</div> <p>If the final value after running all the hooks is <code dir="auto">undefined</code>, the route will fall back to a prerender default based on the <a href="../configuration-reference/index.html#output"><code dir="auto">output</code> option</a>: prerendered for <code dir="auto">hybrid</code> mode, and on-demand rendered for <code dir="auto">server</code> mode.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="custom-hooks">Custom hooks</h3></div> <p>Custom hooks can be added to integrations by extending the <code dir="auto">IntegrationHooks</code> interface through <a href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#global-augmentation">global augmentation</a>.</p> <div class="expressive-code">

<pre data-language="ts">declare global {
  namespace Astro {
    export interface IntegrationHook {
      'your:hook': (params: YourHookParameters) =&gt; Promise&lt;void&gt;
    }
  }
}</pre>

</div> <p>Astro reserves the <code dir="auto">astro:</code> prefix for future built-in hooks. Please choose a different prefix when naming your custom hook.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="allow-installation-with-astro-add">Allow installation with <code dir="auto">astro add</code>
</h2></div> <p><a href="../cli-reference/index.html#astro-add">The <code dir="auto">astro add</code> command</a> allows users to easily add integrations and adapters to their project. If you want <em>your</em> integration to be installable with this tool, <strong>add <code dir="auto">astro-integration</code> to the <code dir="auto">keywords</code> field in your <code dir="auto">package.json</code></strong>:</p> <div class="expressive-code">

<pre data-language="json">{
  "name": "example",
  "keywords": ["astro-integration"],
}</pre>

</div> <p>Once you <a href="https://docs.npmjs.com/cli/v8/commands/npm-publish">publish your integration to npm</a>, running <code dir="auto">astro add example</code> will install your package with any peer dependencies specified in your <code dir="auto">package.json</code>. This will also apply your integration to the user’s <code dir="auto">astro.config</code> like so:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="diff">import { defineConfig } from 'astro/config';
 import example from 'example';


export default defineConfig({
  integrations: [example()],
})</pre>

</div> <aside aria-label="Caution" class="starlight-aside starlight-aside--caution"><p class="starlight-aside__title" aria-hidden="true">Caution</p>
<section class="starlight-aside__content"><p>This assumes your integration definition is 1) a <code dir="auto">default</code> export and 2) a function. Ensure this is true before adding the <code dir="auto">astro-integration</code> keyword!</p></section></aside> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="astrointegrationlogger"><code dir="auto">AstroIntegrationLogger</code></h2></div> <p>An instance of the Astro logger, useful to write logs. This logger uses the same <a href="../cli-reference/index.html#--verbose">log level</a> configured via CLI.</p> <p><strong>Methods available</strong> to write to terminal:</p> <ul> <li>
<code dir="auto">logger.info("Message")</code>;</li> <li>
<code dir="auto">logger.warn("Message")</code>;</li> <li>
<code dir="auto">logger.error("Message")</code>;</li> <li>
<code dir="auto">logger.debug("Message")</code>;</li> </ul> <p>All the messages are prepended with a label that has the same value of the integration.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">integration.ts</span></div>
<pre data-language="ts">import type { AstroIntegration } from "astro";
export function formatIntegration(): AstroIntegration {
    return {
        name: "astro-format",
        hooks: {
            "astro:build:done": ({ logger }) =&gt; {
                // do something
                logger.info("Integration ready.");
            }
        }
    }
}</pre>

</div> <p>The example above will log a message that includes the provided <code dir="auto">info</code> message:</p> <div class="expressive-code">
<div class="_pre-heading">
<span class="sr-only">Terminal window</span>
</div>
<pre data-language="shell">[astro-format] Integration ready.</pre>

</div> <p>To log some messages with a different label, use the <code dir="auto">.fork</code> method to specify an alternative to the default <code dir="auto">name</code>:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">integration.ts</span></div>
<pre data-language="ts">import type { AstroIntegration } from "astro";
export function formatIntegration(): AstroIntegration {
    return {
        name: "astro-format",
        hooks: {
            "astro:config:done": ({ logger }) =&gt; {
                // do something
                logger.info("Integration ready.");
            },
            "astro:build:done": ({ logger }) =&gt; {
                const buildLogger = logger.fork("astro-format/build");
                // do something
                buildLogger.info("Build finished.")
            }
        }
    }
}</pre>

</div> <p>The example above will produce logs with <code dir="auto">[astro-format]</code> by default, and <code dir="auto">[astro-format/build]</code> when specified:</p> <div class="expressive-code">
<div class="_pre-heading">
<span class="sr-only">Terminal window</span>
</div>
<pre data-language="shell">[astro-format] Integration ready.
[astro-format/build] Build finished.</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="integration-ordering">Integration Ordering</h2></div> <p>All integrations are run in the order that they are configured. For instance, for the array <code dir="auto">[react(), svelte()]</code> in a user’s <code dir="auto">astro.config.*</code>, <code dir="auto">react</code> will run before <code dir="auto">svelte</code>.</p> <p>Your integration should ideally run in any order. If this isn’t possible, we recommend documenting that your integration needs to come first or last in your user’s <code dir="auto">integrations</code> configuration array.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="combine-integrations-into-presets">Combine integrations into presets</h2></div> <p>An integration can also be written as a collection of multiple, smaller integrations. We call these collections <strong>presets.</strong> Instead of creating a factory function that returns a single integration object, a preset returns an <em>array</em> of integration objects. This is useful for building complex features out of multiple integrations.</p> <div class="expressive-code">

<pre data-language="js">integrations: [
  // Example: where examplePreset() returns: [integrationOne, integrationTwo, ...etc]
  examplePreset()
]</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="community-resources">Community Resources</h2></div> <ul> <li>
<a href="https://www.freecodecamp.org/news/how-to-use-the-astro-ui-framework/#chapter-8-build-your-own-astro-integrations-1">Build your own Astro Integrations</a> - by Emmanuel Ohans on FreeCodeCamp</li> <li>
<a href="https://github.com/florian-lefebvre/astro-integration-template">Astro Integration Template</a> - by Florian Lefebvre on GitHub</li> </ul> <span id="docsearch-lvl0" hidden class="astro-klj6ju3r">Reference</span> </div>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 Fred K. Schott<br>Licensed under the MIT License.<br>
    <a href="https://docs.astro.build/en/reference/integrations-reference/" class="_attribution-link">https://docs.astro.build/en/reference/integrations-reference/</a>
  </p>
</div>
