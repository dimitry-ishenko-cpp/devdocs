<h1 id="_top" class="astro-556cgime">Configuration Reference</h1> <div class="content-panel astro-ayt3hsza"> <div class="sl-container astro-ayt3hsza"> <div class="sl-markdown-content astro-klj6ju3r"> <p>The following reference covers all supported configuration options in Astro. To learn more about configuring Astro, read our guide on <a href="../../guides/configuring-astro/index.html">Configuring Astro</a>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig } from 'astro/config'


export default defineConfig({
  // your configuration options here...
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="top-level-options">Top-Level Options</h2></div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="site">site</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code></p> <p>Your final, deployed URL. Astro uses this full URL to generate your sitemap and canonical URLs in your final build. It is strongly recommended that you set this configuration to get the most out of Astro.</p> <div class="expressive-code">

<pre data-language="js">{
  site: 'https://www.my-site.dev'
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="base">base</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code></p> <p>The base path to deploy to. Astro will use this path as the root for your pages and assets both in development and in production build.</p> <p>In the example below, <code dir="auto">astro dev</code> will start your server at <code dir="auto">/docs</code>.</p> <div class="expressive-code">

<pre data-language="js">{
  base: '/docs'
}</pre>

</div> <p>When using this option, all of your static asset imports and URLs should add the base as a prefix. You can access this value via <code dir="auto">import.meta.env.BASE_URL</code>.</p> <p>The value of <code dir="auto">import.meta.env.BASE_URL</code> will be determined by your <code dir="auto">trailingSlash</code> config, no matter what value you have set for <code dir="auto">base</code>.</p> <p>A trailing slash is always included if <code dir="auto">trailingSlash: "always"</code> is set. If <code dir="auto">trailingSlash: "never"</code> is set, <code dir="auto">BASE_URL</code> will not include a trailing slash, even if <code dir="auto">base</code> includes one.</p> <p>Additionally, Astro will internally manipulate the configured value of <code dir="auto">config.base</code> before making it available to integrations. The value of <code dir="auto">config.base</code> as read by integrations will also be determined by your <code dir="auto">trailingSlash</code> configuration in the same way.</p> <p>In the example below, the values of <code dir="auto">import.meta.env.BASE_URL</code> and <code dir="auto">config.base</code> when processed will both be <code dir="auto">/docs</code>:</p> <div class="expressive-code">

<pre data-language="js">{
   base: '/docs/',
   trailingSlash: "never"
}</pre>

</div> <p>In the example below, the values of <code dir="auto">import.meta.env.BASE_URL</code> and <code dir="auto">config.base</code> when processed will both be <code dir="auto">/docs/</code>:</p> <div class="expressive-code">

<pre data-language="js">{
   base: '/docs',
   trailingSlash: "always"
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="trailingslash">trailingSlash</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'always' | 'never' | 'ignore'</code><br> <strong>Default:</strong> <code dir="auto">'ignore'</code></p> <p>Set the route matching behavior of the dev server. Choose from the following options:</p> <ul> <li>
<code dir="auto">'always'</code> - Only match URLs that include a trailing slash (ex: “/foo/“)</li> <li>
<code dir="auto">'never'</code> - Never match URLs that include a trailing slash (ex: “/foo”)</li> <li>
<code dir="auto">'ignore'</code> - Match URLs regardless of whether a trailing ”/” exists</li> </ul> <p>Use this configuration option if your production host has strict handling of how trailing slashes work or do not work.</p> <p>You can also set this if you prefer to be more strict yourself, so that URLs with or without trailing slashes won’t work during development.</p> <div class="expressive-code">

<pre data-language="js">{
  // Example: Require a trailing slash during development
  trailingSlash: 'always'
}</pre>

</div> <p><strong>See Also:</strong></p> <ul> <li>build.format</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="redirects">redirects</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Record.&lt;string, RedirectConfig&gt;</code><br> <strong>Default:</strong> <code dir="auto">{}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.9.0</code> </span> <p>Specify a mapping of redirects where the key is the route to match and the value is the path to redirect to.</p> <p>You can redirect both static and dynamic routes, but only to the same kind of route. For example you cannot have a <code dir="auto">'/article': '/blog/[...slug]'</code> redirect.</p> <div class="expressive-code">

<pre data-language="js">{
  redirects: {
    '/old': '/new',
    '/blog/[...slug]': '/articles/[...slug]',
  }
}</pre>

</div> <p>For statically-generated sites with no adapter installed, this will produce a client redirect using a <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/meta#http-equiv"><code dir="auto">&lt;meta http-equiv="refresh"&gt;</code> tag</a> and does not support status codes.</p> <p>When using SSR or with a static adapter in <code dir="auto">output: static</code> mode, status codes are supported. Astro will serve redirected GET requests with a status of <code dir="auto">301</code> and use a status of <code dir="auto">308</code> for any other request method.</p> <p>You can customize the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#redirection_messages">redirection status code</a> using an object in the redirect config:</p> <div class="expressive-code">

<pre data-language="js">{
  redirects: {
    '/other': {
      status: 302,
      destination: '/place',
    },
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="output">output</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'static' | 'server' | 'hybrid'</code><br> <strong>Default:</strong> <code dir="auto">'static'</code></p> <p>Specifies the output target for builds.</p> <ul> <li>
<code dir="auto">'static'</code> - Building a static site to be deployed to any static host.</li> <li>
<code dir="auto">'server'</code> - Building an app to be deployed to a host supporting SSR (server-side rendering).</li> <li>
<code dir="auto">'hybrid'</code> - Building a static site with a few server-side rendered pages.</li> </ul> <div class="expressive-code">

<pre data-language="js">import { defineConfig } from 'astro/config';


export default defineConfig({
  output: 'static'
})</pre>

</div> <p><strong>See Also:</strong></p> <ul> <li>adapter</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="adapter">adapter</h3></div> 
<p><strong>Type:</strong> <code dir="auto">AstroIntegration</code></p> <p>Deploy to your favorite server, serverless, or edge host with build adapters. Import one of our first-party adapters for <a href="../../guides/deploy/netlify/index.html#adapter-for-ssr">Netlify</a>, <a href="../../guides/deploy/vercel/index.html#adapter-for-ssr">Vercel</a>, and more to engage Astro SSR.</p> <p><a href="../../guides/server-side-rendering/index.html">See our Server-side Rendering guide</a> for more on SSR, and <a href="../../guides/deploy/index.html">our deployment guides</a> for a complete list of hosts.</p> <div class="expressive-code">

<pre data-language="js">import netlify from '@astrojs/netlify';
{
  // Example: Build for Netlify serverless deployment
  adapter: netlify(),
}</pre>

</div> <p><strong>See Also:</strong></p> <ul> <li>output</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="integrations">integrations</h3></div> 
<p><strong>Type:</strong> <code dir="auto">AstroIntegration[]</code></p> <p>Extend Astro with custom integrations. Integrations are your one-stop-shop for adding framework support (like Solid.js), new features (like sitemaps), and new libraries (like Partytown).</p> <p>Read our <a href="../../guides/integrations-guide/index.html">Integrations Guide</a> for help getting started with Astro Integrations.</p> <div class="expressive-code">

<pre data-language="js">import react from '@astrojs/react';
import tailwind from '@astrojs/tailwind';
{
  // Example: Add React + Tailwind support to Astro
  integrations: [react(), tailwind()]
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="root">root</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>CLI:</strong> <code dir="auto">--root</code><br> <strong>Default:</strong> <code dir="auto">"."</code> (current working directory)</p> <p>You should only provide this option if you run the <code dir="auto">astro</code> CLI commands in a directory other than the project root directory. Usually, this option is provided via the CLI instead of the <a href="../../guides/configuring-astro/index.html#supported-config-file-types">Astro config file</a>, since Astro needs to know your project root before it can locate your config file.</p> <p>If you provide a relative path (ex: <code dir="auto">--root: './my-project'</code>) Astro will resolve it against your current working directory.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="examples">Examples</h4></div> <div class="expressive-code">

<pre data-language="js">{
  root: './my-project-directory'
}</pre>

</div> <div class="expressive-code">
<div class="_pre-heading">
<span class="sr-only">Terminal window</span>
</div>
<pre data-language="bash">$ astro build --root ./my-project-directory</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="srcdir">srcDir</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">"./src"</code></p> <p>Set the directory that Astro will read your site from.</p> <p>The value can be either an absolute file system path or a path relative to the project root.</p> <div class="expressive-code">

<pre data-language="js">{
  srcDir: './www'
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="publicdir">publicDir</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">"./public"</code></p> <p>Set the directory for your static assets. Files in this directory are served at <code dir="auto">/</code> during dev and copied to your build directory during build. These files are always served or copied as-is, without transform or bundling.</p> <p>The value can be either an absolute file system path or a path relative to the project root.</p> <div class="expressive-code">

<pre data-language="js">{
  publicDir: './my-custom-publicDir-directory'
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="outdir">outDir</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">"./dist"</code></p> <p>Set the directory that <code dir="auto">astro build</code> writes your final build to.</p> <p>The value can be either an absolute file system path or a path relative to the project root.</p> <div class="expressive-code">

<pre data-language="js">{
  outDir: './my-custom-build-directory'
}</pre>

</div> <p><strong>See Also:</strong></p> <ul> <li>build.server</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="cachedir">cacheDir</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">"./node_modules/.astro"</code></p> <p>Set the directory for caching build artifacts. Files in this directory will be used in subsequent builds to speed up the build time.</p> <p>The value can be either an absolute file system path or a path relative to the project root.</p> <div class="expressive-code">

<pre data-language="js">{
  cacheDir: './my-custom-cache-directory'
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="compresshtml">compressHTML</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code></p> <p>This is an option to minify your HTML output and reduce the size of your HTML files.</p> <p>By default, Astro removes whitespace from your HTML, including line breaks, from <code dir="auto">.astro</code> components in a lossless manner. Some whitespace may be kept as needed to preserve the visual rendering of your HTML. This occurs both in development mode and in the final build.</p> <p>To disable HTML compression, set <code dir="auto">compressHTML</code> to false.</p> <div class="expressive-code">

<pre data-language="js">{
  compressHTML: false
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="scopedstylestrategy">scopedStyleStrategy</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'where' | 'class' | 'attribute'</code><br> <strong>Default:</strong> <code dir="auto">'attribute'</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.4</code> </span> <p>Specify the strategy used for scoping styles within Astro components. Choose from:</p> <ul> <li>
<code dir="auto">'where'</code> - Use <code dir="auto">:where</code> selectors, causing no specificity increase.</li> <li>
<code dir="auto">'class'</code> - Use class-based selectors, causing a +1 specificity increase.</li> <li>
<code dir="auto">'attribute'</code> - Use <code dir="auto">data-</code> attributes, causing a +1 specificity increase.</li> </ul> <p>Using <code dir="auto">'class'</code> is helpful when you want to ensure that element selectors within an Astro component override global style defaults (e.g. from a global stylesheet). Using <code dir="auto">'where'</code> gives you more control over specificity, but requires that you use higher-specificity selectors, layers, and other tools to control which selectors are applied. Using <code dir="auto">'attribute'</code> is useful when you are manipulating the <code dir="auto">class</code> attribute of elements and need to avoid conflicts between your own styling logic and Astro’s application of styles.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="security">security</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">{}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.9.0</code> </span> <p>Enables security measures for an Astro website.</p> <p>These features only exist for pages rendered on demand (SSR) using <code dir="auto">server</code> mode or pages that opt out of prerendering in <code dir="auto">hybrid</code> mode.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">export default defineConfig({
  output: "server",
  security: {
    checkOrigin: true
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="securitycheckorigin">security.checkOrigin</h4></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> ‘false’<br></p>
<span> <strong>Added in:</strong> <code>astro@4.9.0</code> </span> <p>When enabled, performs a check that the “origin” header, automatically passed by all modern browsers, matches the URL sent by each <code dir="auto">Request</code>. This is used to provide Cross-Site Request Forgery (CSRF) protection.</p> <p>The “origin” check is executed only for pages rendered on demand, and only for the requests <code dir="auto">POST</code>, <code dir="auto">PATCH</code>, <code dir="auto">DELETE</code> and <code dir="auto">PUT</code> with one of the following <code dir="auto">content-type</code> headers: <code dir="auto">'application/x-www-form-urlencoded'</code>, <code dir="auto">'multipart/form-data'</code>, <code dir="auto">'text/plain'</code>.</p> <p>If the “origin” header doesn’t match the <code dir="auto">pathname</code> of the request, Astro will return a 403 status code and will not render the page.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="vite">vite</h3></div> 
<p><strong>Type:</strong> <code dir="auto">ViteUserConfig</code></p> <p>Pass additional configuration options to Vite. Useful when Astro doesn’t support some advanced configuration that you may need.</p> <p>View the full <code dir="auto">vite</code> configuration object documentation on <a href="https://vitejs.dev/config/">vitejs.dev</a>.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="examples-1">Examples</h4></div> <div class="expressive-code">

<pre data-language="js">{
  vite: {
    ssr: {
      // Example: Force a broken package to skip SSR processing, if needed
      external: ['broken-npm-package'],
    }
  }
}</pre>

</div> <div class="expressive-code">

<pre data-language="js">{
  vite: {
    // Example: Add custom vite plugins directly to your Astro project
    plugins: [myPlugin()],
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="build-options">Build Options</h2></div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildformat">build.format</h3></div> 
<p><strong>Type:</strong> <code dir="auto">('file' | 'directory' | 'preserve')</code><br> <strong>Default:</strong> <code dir="auto">'directory'</code></p> <p>Control the output file format of each page. This value may be set by an adapter for you.</p> <ul> <li>
<code dir="auto">'file'</code>: Astro will generate an HTML file named for each page route. (e.g. <code dir="auto">src/pages/about.astro</code> and <code dir="auto">src/pages/about/index.astro</code> both build the file <code dir="auto">/about.html</code>)</li> <li>
<code dir="auto">'directory'</code>: Astro will generate a directory with a nested <code dir="auto">index.html</code> file for each page. (e.g. <code dir="auto">src/pages/about.astro</code> and <code dir="auto">src/pages/about/index.astro</code> both build the file <code dir="auto">/about/index.html</code>)</li> <li>
<code dir="auto">'preserve'</code>: Astro will generate HTML files exactly as they appear in your source folder. (e.g. <code dir="auto">src/pages/about.astro</code> builds <code dir="auto">/about.html</code> and <code dir="auto">src/pages/about/index.astro</code> builds the file <code dir="auto">/about/index.html</code>)</li> </ul> <div class="expressive-code">

<pre data-language="js">{
  build: {
    // Example: Generate `page.html` instead of `page/index.html` during build.
    format: 'file'
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="effect-on-astrourl">Effect on Astro.url</h4></div> <p>Setting <code dir="auto">build.format</code> controls what <code dir="auto">Astro.url</code> is set to during the build. When it is:</p> <ul> <li>
<code dir="auto">directory</code> - The <code dir="auto">Astro.url.pathname</code> will include a trailing slash to mimic folder behavior; ie <code dir="auto">/foo/</code>.</li> <li>
<code dir="auto">file</code> - The <code dir="auto">Astro.url.pathname</code> will include <code dir="auto">.html</code>; ie <code dir="auto">/foo.html</code>.</li> </ul> <p>This means that when you create relative URLs using <code dir="auto">new URL('./relative', Astro.url)</code>, you will get consistent behavior between dev and build.</p> <p>To prevent inconsistencies with trailing slash behaviour in dev, you can restrict the <a href="#trailingslash"><code dir="auto">trailingSlash</code> option</a> to <code dir="auto">'always'</code> or <code dir="auto">'never'</code> depending on your build format:</p> <ul> <li>
<code dir="auto">directory</code> - Set <code dir="auto">trailingSlash: 'always'</code>
</li> <li>
<code dir="auto">file</code> - Set <code dir="auto">trailingSlash: 'never'</code>
</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildclient">build.client</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">'./dist/client'</code></p> <p>Controls the output directory of your client-side CSS and JavaScript when <code dir="auto">output: 'server'</code> or <code dir="auto">output: 'hybrid'</code> only. <code dir="auto">outDir</code> controls where the code is built to.</p> <p>This value is relative to the <code dir="auto">outDir</code>.</p> <div class="expressive-code">

<pre data-language="js">{
  output: 'server', // or 'hybrid'
  build: {
    client: './client'
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildserver">build.server</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">'./dist/server'</code></p> <p>Controls the output directory of server JavaScript when building to SSR.</p> <p>This value is relative to the <code dir="auto">outDir</code>.</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    server: './server'
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildassets">build.assets</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">'_astro'</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.0.0</code> </span> <p>Specifies the directory in the build output where Astro-generated assets (bundled JS and CSS for example) should live.</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    assets: '_custom'
  }
}</pre>

</div> <p><strong>See Also:</strong></p> <ul> <li>outDir</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildassetsprefix">build.assetsPrefix</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string | Record.&lt;string, string&gt;</code><br> <strong>Default:</strong> <code dir="auto">undefined</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.2.0</code> </span> <p>Specifies the prefix for Astro-generated asset links. This can be used if assets are served from a different domain than the current site.</p> <p>This requires uploading the assets in your local <code dir="auto">./dist/_astro</code> folder to a corresponding <code dir="auto">/_astro/</code> folder on the remote domain. To rename the <code dir="auto">_astro</code> path, specify a new directory in <code dir="auto">build.assets</code>.</p> <p>To fetch all assets uploaded to the same domain (e.g. <code dir="auto">https://cdn.example.com/_astro/...</code>), set <code dir="auto">assetsPrefix</code> to the root domain as a string (regardless of your <code dir="auto">base</code> configuration):</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    assetsPrefix: 'https://cdn.example.com'
  }
}</pre>

</div> <p><strong>Added in:</strong> <code dir="auto">astro@4.5.0</code></p> <p>You can also pass an object to <code dir="auto">assetsPrefix</code> to specify a different domain for each file type. In this case, a <code dir="auto">fallback</code> property is required and will be used by default for any other files.</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    assetsPrefix: {
      'js': 'https://js.cdn.example.com',
      'mjs': 'https://js.cdn.example.com',
      'css': 'https://css.cdn.example.com',
      'fallback': 'https://cdn.example.com'
    }
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildserverentry">build.serverEntry</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">'entry.mjs'</code></p> <p>Specifies the file name of the server entrypoint when building to SSR. This entrypoint is usually dependent on which host you are deploying to and will be set by your adapter for you.</p> <p>Note that it is recommended that this file ends with <code dir="auto">.mjs</code> so that the runtime detects that the file is a JavaScript module.</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    serverEntry: 'main.mjs'
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildredirects">build.redirects</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.6.0</code> </span> <p>Specifies whether redirects will be output to HTML during the build. This option only applies to <code dir="auto">output: 'static'</code> mode; in SSR redirects are treated the same as all responses.</p> <p>This option is mostly meant to be used by adapters that have special configuration files for redirects and do not need/want HTML based redirects.</p> <div class="expressive-code">

<pre data-language="js">{
  build: {
    redirects: false
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="buildinlinestylesheets">build.inlineStylesheets</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'always' | 'auto' | 'never'</code><br> <strong>Default:</strong> <code dir="auto">auto</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.6.0</code> </span> <p>Control whether project styles are sent to the browser in a separate css file or inlined into <code dir="auto">&lt;style&gt;</code> tags. Choose from the following options:</p> <ul> <li>
<code dir="auto">'always'</code> - project styles are inlined into <code dir="auto">&lt;style&gt;</code> tags</li> <li>
<code dir="auto">'auto'</code> - only stylesheets smaller than <code dir="auto">ViteConfig.build.assetsInlineLimit</code> (default: 4kb) are inlined. Otherwise, project styles are sent in external stylesheets.</li> <li>
<code dir="auto">'never'</code> - project styles are sent in external stylesheets</li> </ul> <div class="expressive-code">

<pre data-language="js">{
  build: {
    inlineStylesheets: `never`,
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="server-options">Server Options</h2></div> <p>Customize the Astro dev server, used by both <code dir="auto">astro dev</code> and <code dir="auto">astro preview</code>.</p> <div class="expressive-code">

<pre data-language="js">{
  server: { port: 1234, host: true}
}</pre>

</div> <p>To set different configuration based on the command run (“dev”, “preview”) a function can also be passed to this configuration option.</p> <div class="expressive-code">

<pre data-language="js">{
  // Example: Use the function syntax to customize based on command
  server: ({ command }) =&gt; ({ port: command === 'dev' ? 4321 : 4000 })
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="serverhost">server.host</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string | boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@0.24.0</code> </span> <p>Set which network IP addresses the server should listen on (i.e. non-localhost IPs).</p> <ul> <li>
<code dir="auto">false</code> - do not expose on a network IP address</li> <li>
<code dir="auto">true</code> - listen on all addresses, including LAN and public addresses</li> <li>
<code dir="auto">[custom-address]</code> - expose on a network IP address at <code dir="auto">[custom-address]</code> (ex: <code dir="auto">192.168.0.1</code>)</li> </ul> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="serverport">server.port</h3></div> 
<p><strong>Type:</strong> <code dir="auto">number</code><br> <strong>Default:</strong> <code dir="auto">4321</code></p> <p>Set which port the server should listen on.</p> <p>If the given port is already in use, Astro will automatically try the next available port.</p> <div class="expressive-code">

<pre data-language="js">{
  server: { port: 8080 }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="serveropen">server.open</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string | boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.1.0</code> </span> <p>Controls whether the dev server should open in your browser window on startup.</p> <p>Pass a full URL string (e.g. ”<a href="http://example.com">http://example.com</a>”) or a pathname (e.g. “/about”) to specify the URL to open.</p> <div class="expressive-code">

<pre data-language="js">{
  server: { open: "/about" }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="serverheaders">server.headers</h3></div> 
<p><strong>Type:</strong> <code dir="auto">OutgoingHttpHeaders</code><br> <strong>Default:</strong> <code dir="auto">{}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@1.7.0</code> </span> <p>Set custom HTTP response headers to be sent in <code dir="auto">astro dev</code> and <code dir="auto">astro preview</code>.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="dev-toolbar-options">Dev Toolbar Options</h2></div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="devtoolbarenabled">devToolbar.enabled</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code></p> <p>Whether to enable the Astro Dev Toolbar. This toolbar allows you to inspect your page islands, see helpful audits on performance and accessibility, and more.</p> <p>This option is scoped to the entire project, to only disable the toolbar for yourself, run <code dir="auto">npm run astro preferences disable devToolbar</code>. To disable the toolbar for all your Astro projects, run <code dir="auto">npm run astro preferences disable devToolbar --global</code>.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="prefetch-options">Prefetch Options</h2></div> 
<p><strong>Type:</strong> <code dir="auto">boolean | object</code></p> <p>Enable prefetching for links on your site to provide faster page transitions. (Enabled by default on pages using the <code dir="auto">&lt;ViewTransitions /&gt;</code> router. Set <code dir="auto">prefetch: false</code> to opt out of this behaviour.)</p> <p>This configuration automatically adds a prefetch script to every page in the project giving you access to the <code dir="auto">data-astro-prefetch</code> attribute. Add this attribute to any <code dir="auto">&lt;a /&gt;</code> link on your page to enable prefetching for that page.</p> <div class="expressive-code">

<pre data-language="html">&lt;a href="/about.html" data-astro-prefetch&gt;About&lt;/a&gt;</pre>

</div> <p>Further customize the default prefetching behavior using the <a href="#prefetchdefaultstrategy"><code dir="auto">prefetch.defaultStrategy</code></a> and <a href="#prefetchprefetchall"><code dir="auto">prefetch.prefetchAll</code></a> options.</p> <p>See the <a href="../../guides/prefetch/index.html">Prefetch guide</a> for more information.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="prefetchprefetchall">prefetch.prefetchAll</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code></p> <p>Enable prefetching for all links, including those without the <code dir="auto">data-astro-prefetch</code> attribute. This value defaults to <code dir="auto">true</code> when using the <code dir="auto">&lt;ViewTransitions /&gt;</code> router. Otherwise, the default value is <code dir="auto">false</code>.</p> <div class="expressive-code">

<pre data-language="js">prefetch: {
  prefetchAll: true
}</pre>

</div> <p>When set to <code dir="auto">true</code>, you can disable prefetching individually by setting <code dir="auto">data-astro-prefetch="false"</code> on any individual links.</p> <div class="expressive-code">

<pre data-language="html">&lt;a href="/about.html" data-astro-prefetch="false"&gt;About&lt;/a&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="prefetchdefaultstrategy">prefetch.defaultStrategy</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'tap' | 'hover' | 'viewport' | 'load'</code><br> <strong>Default:</strong> <code dir="auto">'hover'</code></p> <p>The default prefetch strategy to use when the <code dir="auto">data-astro-prefetch</code> attribute is set on a link with no value.</p> <ul> <li>
<code dir="auto">'tap'</code>: Prefetch just before you click on the link.</li> <li>
<code dir="auto">'hover'</code>: Prefetch when you hover over or focus on the link. (default)</li> <li>
<code dir="auto">'viewport'</code>: Prefetch as the links enter the viewport.</li> <li>
<code dir="auto">'load'</code>: Prefetch all links on the page after the page is loaded.</li> </ul> <p>You can override this default value and select a different strategy for any individual link by setting a value on the attribute.</p> <div class="expressive-code">

<pre data-language="html">&lt;a href="/about.html" data-astro-prefetch="viewport"&gt;About&lt;/a&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="image-options">Image Options</h2></div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="imageendpoint">image.endpoint</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br> <strong>Default:</strong> <code dir="auto">undefined</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.1.0</code> </span> <p>Set the endpoint to use for image optimization in dev and SSR. Set to <code dir="auto">undefined</code> to use the default endpoint.</p> <p>The endpoint will always be injected at <code dir="auto">/_image</code>.</p> <div class="expressive-code">

<pre data-language="js">{
  image: {
    // Example: Use a custom image endpoint
    endpoint: './src/image-endpoint.ts',
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="imageservice">image.service</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Object</code><br> <strong>Default:</strong> <code dir="auto">{entrypoint: 'astro/assets/services/sharp', config?: {}}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.1.0</code> </span> <p>Set which image service is used for Astro’s assets support.</p> <p>The value should be an object with an entrypoint for the image service to use and optionally, a config object to pass to the service.</p> <p>The service entrypoint can be either one of the included services, or a third-party package.</p> <div class="expressive-code">

<pre data-language="js">{
  image: {
    // Example: Enable the Sharp-based image service with a custom config
    service: {
       entrypoint: 'astro/assets/services/sharp',
       config: {
         limitInputPixels: false,
      },
     },
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="imageserviceconfiglimitinputpixels">image.service.config.limitInputPixels</h4></div> 
<p><strong>Type:</strong> <code dir="auto">number | boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.1.0</code> </span> <p>Whether or not to limit the size of images that the Sharp image service will process.</p> <p>Set <code dir="auto">false</code> to bypass the default image size limit for the Sharp image service and process large images.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="imagedomains">image.domains</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Array.&lt;string&gt;</code><br> <strong>Default:</strong> <code dir="auto">{domains: []}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.10.10</code> </span> <p>Defines a list of permitted image source domains for remote image optimization. No other remote images will be optimized by Astro.</p> <p>This option requires an array of individual domain names as strings. Wildcards are not permitted. Instead, use <a href="#imageremotepatterns"><code dir="auto">image.remotePatterns</code></a> to define a list of allowed source URL patterns.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">{
  image: {
    // Example: Allow remote image optimization from a single domain
    domains: ['astro.build'],
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="imageremotepatterns">image.remotePatterns</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Array.&lt;RemotePattern&gt;</code><br> <strong>Default:</strong> <code dir="auto">{remotePatterns: []}</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.10.10</code> </span> <p>Defines a list of permitted image source URL patterns for remote image optimization.</p> <p><code dir="auto">remotePatterns</code> can be configured with four properties:</p> <ol> <li>protocol</li> <li>hostname</li> <li>port</li> <li>pathname</li> </ol> <div class="expressive-code">

<pre data-language="js">{
  image: {
    // Example: allow processing all images from your aws s3 bucket
    remotePatterns: [{
      protocol: 'https',
      hostname: '**.amazonaws.com',
    }],
  },
}</pre>

</div> <p>You can use wildcards to define the permitted <code dir="auto">hostname</code> and <code dir="auto">pathname</code> values as described below. Otherwise, only the exact values provided will be configured: <code dir="auto">hostname</code>:</p> <ul> <li>Start with ’**.’ to allow all subdomains (‘endsWith’).</li> <li>Start with ’*.’ to allow only one level of subdomain.</li> </ul> <p><code dir="auto">pathname</code>:</p> <ul> <li>End with ’/**’ to allow all sub-routes (‘startsWith’).</li> <li>End with ’/*’ to allow only one level of sub-route.</li> </ul> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="markdown-options">Markdown Options</h2></div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownshikiconfig">markdown.shikiConfig</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Partial&lt;ShikiConfig&gt;</code></p> <p>Shiki configuration options. See <a href="../../guides/markdown-content/index.html#shiki-configuration">the Markdown configuration docs</a> for usage.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownsyntaxhighlight">markdown.syntaxHighlight</h3></div> 
<p><strong>Type:</strong> <code dir="auto">'shiki' | 'prism' | false</code><br> <strong>Default:</strong> <code dir="auto">shiki</code></p> <p>Which syntax highlighter to use, if any.</p> <ul> <li>
<code dir="auto">shiki</code> - use the <a href="https://shiki.style">Shiki</a> highlighter</li> <li>
<code dir="auto">prism</code> - use the <a href="https://prismjs.com/">Prism</a> highlighter</li> <li>
<code dir="auto">false</code> - do not apply syntax highlighting.</li> </ul> <div class="expressive-code">

<pre data-language="js">{
  markdown: {
    // Example: Switch to use prism for syntax highlighting in Markdown
    syntaxHighlight: 'prism',
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownremarkplugins">markdown.remarkPlugins</h3></div> 
<p><strong>Type:</strong> <code dir="auto">RemarkPlugins</code></p> <p>Pass <a href="https://github.com/remarkjs/remark">remark plugins</a> to customize how your Markdown is built. You can import and apply the plugin function (recommended), or pass the plugin name as a string.</p> <div class="expressive-code">

<pre data-language="js">import remarkToc from 'remark-toc';
{
  markdown: {
    remarkPlugins: [ [remarkToc, { heading: "contents"} ] ]
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownrehypeplugins">markdown.rehypePlugins</h3></div> 
<p><strong>Type:</strong> <code dir="auto">RehypePlugins</code></p> <p>Pass <a href="https://github.com/remarkjs/remark-rehype">rehype plugins</a> to customize how your Markdown’s output HTML is processed. You can import and apply the plugin function (recommended), or pass the plugin name as a string.</p> <div class="expressive-code">

<pre data-language="js">import { rehypeAccessibleEmojis } from 'rehype-accessible-emojis';
{
  markdown: {
    rehypePlugins: [rehypeAccessibleEmojis]
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdowngfm">markdown.gfm</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.0.0</code> </span> <p>Astro uses <a href="https://github.com/remarkjs/remark-gfm">GitHub-flavored Markdown</a> by default. To disable this, set the <code dir="auto">gfm</code> flag to <code dir="auto">false</code>:</p> <div class="expressive-code">

<pre data-language="js">{
  markdown: {
    gfm: false,
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownsmartypants">markdown.smartypants</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code><br></p>
<span> <strong>Added in:</strong> <code>astro@2.0.0</code> </span> <p>Astro uses the <a href="https://daringfireball.net/projects/smartypants/">SmartyPants formatter</a> by default. To disable this, set the <code dir="auto">smartypants</code> flag to <code dir="auto">false</code>:</p> <div class="expressive-code">

<pre data-language="js">{
  markdown: {
    smartypants: false,
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="markdownremarkrehype">markdown.remarkRehype</h3></div> 
<p><strong>Type:</strong> <code dir="auto">RemarkRehype</code></p> <p>Pass options to <a href="https://github.com/remarkjs/remark-rehype#api">remark-rehype</a>.</p> <div class="expressive-code">

<pre data-language="js">{
  markdown: {
    // Example: Translate the footnotes text to another language, here are the default English values
    remarkRehype: { footnoteLabel: "Footnotes", footnoteBackLabel: "Back to reference 1"},
  },
};</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="i18n">i18n</h2></div> 
<p><strong>Type:</strong> <code dir="auto">object</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span> <p>Configures i18n routing and allows you to specify some customization options.</p> <p>See our guide for more information on <a href="../../guides/internationalization/index.html">internationalization in Astro</a></p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="i18ndefaultlocale">i18n.defaultLocale</h3></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span> <p>The default locale of your website/application. This is a required field.</p> <p>No particular language format or syntax is enforced, but we suggest using lower-case and hyphens as needed (e.g. “es”, “pt-br”) for greatest compatibility.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="i18nlocales">i18n.locales</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Locales</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span> <p>A list of all locales supported by the website, including the <code dir="auto">defaultLocale</code>. This is a required field.</p> <p>Languages can be listed either as individual codes (e.g. <code dir="auto">['en', 'es', 'pt-br']</code>) or mapped to a shared <code dir="auto">path</code> of codes (e.g. <code dir="auto">{ path: "english", codes: ["en", "en-US"]}</code>). These codes will be used to determine the URL structure of your deployed site.</p> <p>No particular language code format or syntax is enforced, but your project folders containing your content files must match exactly the <code dir="auto">locales</code> items in the list. In the case of multiple <code dir="auto">codes</code> pointing to a custom URL path prefix, store your content files in a folder with the same name as the <code dir="auto">path</code> configured.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="i18nfallback">i18n.fallback</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Record.&lt;string, string&gt;</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span> <p>The fallback strategy when navigating to pages that do not exist (e.g. a translated page has not been created).</p> <p>Use this object to declare a fallback <code dir="auto">locale</code> route for each language you support. If no fallback is specified, then unavailable pages will return a 404.</p> <div tabindex="-1" class="heading-wrapper level-h5"><h5 id="example">Example</h5></div> <p>The following example configures your content fallback strategy to redirect unavailable pages in <code dir="auto">/pt-br/</code> to their <code dir="auto">es</code> version, and unavailable pages in <code dir="auto">/fr/</code> to their <code dir="auto">en</code> version. Unavailable <code dir="auto">/es/</code> pages will return a 404.</p> <div class="expressive-code">

<pre data-language="js">export default defineConfig({
  i18n: {
    defaultLocale: "en",
    locales: ["en", "fr", "pt-br", "es"],
    fallback: {
      pt: "es",
      fr: "en"
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="i18nrouting">i18n.routing</h3></div> 
<p><strong>Type:</strong> <code dir="auto">Routing</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.7.0</code> </span> <p>Controls the routing strategy to determine your site URLs. Set this based on your folder/URL path configuration for your default language.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="i18nroutingprefixdefaultlocale">i18n.routing.prefixDefaultLocale</h4></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.7.0</code> </span> <p>When <code dir="auto">false</code>, only non-default languages will display a language prefix. The <code dir="auto">defaultLocale</code> will not show a language prefix and content files do not exist in a localized folder. URLs will be of the form <code dir="auto">example.com/[locale]/content/</code> for all non-default languages, but <code dir="auto">example.com/content/</code> for the default locale.</p> <p>When <code dir="auto">true</code>, all URLs will display a language prefix. URLs will be of the form <code dir="auto">example.com/[locale]/content/</code> for every route, including the default language. Localized folders are used for every language, including the default.</p> <div class="expressive-code">

<pre data-language="js">export default defineConfig({
  i18n: {
    defaultLocale: "en",
    locales: ["en", "fr", "pt-br", "es"],
    routing: {
      prefixDefaultLocale: true,
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="i18nroutingredirecttodefaultlocale">i18n.routing.redirectToDefaultLocale</h4></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">true</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.2.0</code> </span> <p>Configures whether or not the home URL (<code dir="auto">/</code>) generated by <code dir="auto">src/pages/index.astro</code> will redirect to <code dir="auto">/[defaultLocale]</code> when <code dir="auto">prefixDefaultLocale: true</code> is set.</p> <p>Set <code dir="auto">redirectToDefaultLocale: false</code> to disable this automatic redirection at the root of your site:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">export default defineConfig({
  i18n:{
    defaultLocale: "en",
    locales: ["en", "fr"],
    routing: {
      prefixDefaultLocale: true,
      redirectToDefaultLocale: false
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="i18nroutingmanual">i18n.routing.manual</h4></div> 
<p><strong>Type:</strong> <code dir="auto">string</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.6.0</code> </span> <p>When this option is enabled, Astro will <strong>disable</strong> its i18n middleware so that you can implement your own custom logic. No other <code dir="auto">routing</code> options (e.g. <code dir="auto">prefixDefaultLocale</code>) may be configured with <code dir="auto">routing: "manual"</code>.</p> <p>You will be responsible for writing your own routing logic, or executing Astro’s i18n middleware manually alongside your own.</p> <div class="expressive-code">

<pre data-language="js">export default defineConfig({
  i18n: {
    defaultLocale: "en",
    locales: ["en", "fr", "pt-br", "es"],
    routing: {
      prefixDefaultLocale: true,
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="legacy-flags">Legacy Flags</h2></div> <p>To help some users migrate between versions of Astro, we occasionally introduce <code dir="auto">legacy</code> flags. These flags allow you to opt in to some deprecated or otherwise outdated behavior of Astro in the latest version, so that you can continue to upgrade and take advantage of new Astro releases.</p> <div tabindex="-1" class="heading-wrapper level-h2"><h2 id="experimental-flags">Experimental Flags</h2></div> <p>Astro offers experimental flags to give users early access to new features. These flags are not guaranteed to be stable.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentaldirectrenderscript">experimental.directRenderScript</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.5.0</code> </span> <p>Enables a more reliable strategy to prevent scripts from being executed in pages where they are not used.</p> <p>Scripts will directly render as declared in Astro files (including existing features like TypeScript, importing <code dir="auto">node_modules</code>, and deduplicating scripts). You can also now conditionally render scripts in your Astro file. However, this means scripts are no longer hoisted to the <code dir="auto">&lt;head&gt;</code> and multiple scripts on a page are no longer bundled together. If you enable this option, you should check that all your <code dir="auto">&lt;script&gt;</code> tags behave as expected.</p> <p>This option will be enabled by default in Astro 5.0.</p> <div class="expressive-code">

<pre data-language="js">{
  experimental: {
    directRenderScript: true,
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalactions">experimental.actions</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.8.0</code> </span> <p>Actions help you write type-safe backend functions you can call from anywhere. Enable server rendering <a href="../../basics/rendering-modes/index.html#on-demand-rendered">using the <code dir="auto">output</code> property</a> and add the <code dir="auto">actions</code> flag to the <code dir="auto">experimental</code> object:</p> <div class="expressive-code">

<pre data-language="js">{
  output: 'hybrid', // or 'server'
  experimental: {
    actions: true,
  },
}</pre>

</div> <p>Declare all your actions in <code dir="auto">src/actions/index.ts</code>. This file is the global actions handler.</p> <p>Define an action using the <code dir="auto">defineAction()</code> utility from the <code dir="auto">astro:actions</code> module. An action accepts the <code dir="auto">handler</code> property to define your server-side request handler. If your action accepts arguments, apply the <code dir="auto">input</code> property to validate parameters with Zod.</p> <p>This example defines two actions: <code dir="auto">like</code> and <code dir="auto">comment</code>. The <code dir="auto">like</code> action accepts a JSON object with a <code dir="auto">postId</code> string, while the <code dir="auto">comment</code> action accepts <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_FormData_Objects">FormData</a> with <code dir="auto">postId</code>, <code dir="auto">author</code>, and <code dir="auto">body</code> strings. Each <code dir="auto">handler</code> updates your database and return a type-safe response.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/actions/index.ts</span></div>
<pre data-language="ts">import { defineAction, z } from "astro:actions";


export const server = {
  like: defineAction({
    input: z.object({ postId: z.string() }),
    handler: async ({ postId }) =&gt; {
      // update likes in db


      return likes;
    },
  }),
  comment: defineAction({
    accept: 'form',
    input: z.object({
      postId: z.string(),
      author: z.string(),
      body: z.string(),
    }),
    handler: async ({ postId }) =&gt; {
      // insert comments in db


      return comment;
    },
  }),
};</pre>

</div> <p>Then, call an action from your client components using the <code dir="auto">actions</code> object from <code dir="auto">astro:actions</code>. You can pass a type-safe object when using JSON, or a <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest_API/Using_FormData_Objects">FormData</a> object when using <code dir="auto">accept: 'form'</code> in your action definition.</p> <p>This example calls the <code dir="auto">like</code> and <code dir="auto">comment</code> actions from a React component:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/components/blog.tsx</span></div>
<pre data-language="tsx">import { actions } from "astro:actions";
import { useState } from "react";


export function Like({ postId }: { postId: string }) {
  const [likes, setLikes] = useState(0);
  return (
    &lt;button
      onClick={async () =&gt; {
        const newLikes = await actions.like({ postId });
        setLikes(newLikes);
      }}
    &gt;
      {likes} likes
    &lt;/button&gt;
  );
}


export function Comment({ postId }: { postId: string }) {
  return (
    &lt;form
      onSubmit={async (e) =&gt; {
        e.preventDefault();
        const formData = new FormData(e.target as HTMLFormElement);
        const result = await actions.blog.comment(formData);
        // handle result
      }}
    &gt;
      &lt;input type="hidden" name="postId" value={postId} /&gt;
      &lt;label htmlFor="author"&gt;Author&lt;/label&gt;
      &lt;input id="author" type="text" name="author" /&gt;
      &lt;textarea rows={10} name="body"&gt;&lt;/textarea&gt;
      &lt;button type="submit"&gt;Post&lt;/button&gt;
    &lt;/form&gt;
  );
}</pre>

</div> <p>For a complete overview, and to give feedback on this experimental API, see the <a href="https://github.com/withastro/roadmap/blob/actions/proposals/0046-actions.md">Actions RFC</a>.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalcontentcollectioncache">experimental.contentCollectionCache</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@3.5.0</code> </span> <p>Enables a persistent cache for content collections when building in static mode.</p> <div class="expressive-code">

<pre data-language="js">{
  experimental: {
    contentCollectionCache: true,
  },
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalclientprerender">experimental.clientPrerender</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.2.0</code> </span> <p>Enables pre-rendering your prefetched pages on the client in supported browsers.</p> <p>This feature uses the experimental <a href="https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API">Speculation Rules Web API</a> and enhances the default <code dir="auto">prefetch</code> behavior globally to prerender links on the client. You may wish to review the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Speculation_Rules_API#unsafe_prefetching">possible risks when prerendering on the client</a> before enabling this feature.</p> <p>Enable client side prerendering in your <code dir="auto">astro.config.mjs</code> along with any desired <code dir="auto">prefetch</code> configuration options:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">{
  prefetch: {
    prefetchAll: true,
    defaultStrategy: 'viewport',
  },
  experimental: {
    clientPrerender: true,
  },
}</pre>

</div> <p>Continue to use the <code dir="auto">data-astro-prefetch</code> attribute on any <code dir="auto">&lt;a /&gt;</code> link on your site to opt in to prefetching. Instead of appending a <code dir="auto">&lt;link&gt;</code> tag to the head of the document or fetching the page with JavaScript, a <code dir="auto">&lt;script&gt;</code> tag will be appended with the corresponding speculation rules.</p> <p>Client side prerendering requires browser support. If the Speculation Rules API is not supported, <code dir="auto">prefetch</code> will fallback to the supported strategy.</p> <p>See the <a href="../../guides/prefetch/index.html">Prefetch Guide</a> for more <code dir="auto">prefetch</code> options and usage.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalglobalroutepriority">experimental.globalRoutePriority</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.2.0</code> </span> <p>Prioritizes redirects and injected routes equally alongside file-based project routes, following the same <a href="../../guides/routing/index.html#route-priority-order">route priority order rules</a> for all routes.</p> <p>This allows more control over routing in your project by not automatically prioritizing certain types of routes, and standardizes the route priority ordering for all routes.</p> <p>The following example shows which route will build certain page URLs when file-based routes, injected routes, and redirects are combined as shown below:</p> <ul> <li>File-based route: <code dir="auto">/blog/post/[pid]</code>
</li> <li>File-based route: <code dir="auto">/[page]</code>
</li> <li>Injected route: <code dir="auto">/blog/[...slug]</code>
</li> <li>Redirect: <code dir="auto">/blog/tags/[tag]</code> -&gt; <code dir="auto">/[tag]</code>
</li> <li>Redirect: <code dir="auto">/posts</code> -&gt; <code dir="auto">/blog</code>
</li> </ul> <p>With <code dir="auto">experimental.globalRoutingPriority</code> enabled (instead of Astro 4.0 default route priority order):</p> <ul> <li>
<code dir="auto">/blog/tags/astro</code> is built by the redirect to <code dir="auto">/tags/[tag]</code> (instead of the injected route <code dir="auto">/blog/[...slug]</code>)</li> <li>
<code dir="auto">/blog/post/0</code> is built by the file-based route <code dir="auto">/blog/post/[pid]</code> (instead of the injected route <code dir="auto">/blog/[...slug]</code>)</li> <li>
<code dir="auto">/posts</code> is built by the redirect to <code dir="auto">/blog</code> (instead of the file-based route <code dir="auto">/[page]</code>)</li> </ul> <p>In the event of route collisions, where two routes of equal route priority attempt to build the same URL, Astro will log a warning identifying the conflicting routes.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalenv">experimental.env</h3></div> 
<p><strong>Type:</strong> <code dir="auto">object</code><br> <strong>Default:</strong> <code dir="auto">undefined</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.10.0</code> </span> <p>Enables experimental <code dir="auto">astro:env</code> features.</p> <p>The <code dir="auto">astro:env</code> API lets you configure a type-safe schema for your environment variables, and indicate whether they should be available on the server or the client. Import and use your defined variables from the appropriate <code dir="auto">/client</code> or <code dir="auto">/server</code> module:</p> <div class="expressive-code">

<pre data-language="astro">---
import { API_URL } from "astro:env/client"
import { API_SECRET_TOKEN } from "astro:env/server"


const data = await fetch(`${API_URL}/users`, {
  method: "GET",
  headers: {
    "Content-Type": "application/json",
    "Authorization": `Bearer ${API_SECRET_TOKEN}`
  },
})
---


&lt;script&gt;
import { API_URL } from "astro:env/client"


fetch(`${API_URL}/ping`)
&lt;/script&gt;</pre>

</div> <p>To define the data type and properties of your environment variables, declare a schema in your Astro config in <code dir="auto">experimental.env.schema</code>. The <code dir="auto">envField</code> helper allows you define your variable as a string, number, or boolean and pass properties in an object:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig, envField } from "astro/config"


export default defineConfig({
    experimental: {
        env: {
            schema: {
                API_URL: envField.string({ context: "client", access: "public", optional: true }),
                PORT: envField.number({ context: "server", access: "public", default: 4321 }),
                API_SECRET: envField.string({ context: "server", access: "secret" }),
            }
        }
    }
})</pre>

</div> <p>There are currently four data types supported: strings, numbers, booleans and enums.</p> <p>There are three kinds of environment variables, determined by the combination of <code dir="auto">context</code> (client or server) and <code dir="auto">access</code> (secret or public) settings defined in your <a href="#experimentalenvschema"><code dir="auto">env.schema</code></a>:</p> <ul> <li> <p><strong>Public client variables</strong>: These variables end up in both your final client and server bundles, and can be accessed from both client and server through the <code dir="auto">astro:env/client</code> module:</p> <div class="expressive-code">

<pre data-language="js">import { API_URL } from "astro:env/client"</pre>

</div> </li> <li> <p><strong>Public server variables</strong>: These variables end up in your final server bundle and can be accessed on the server through the <code dir="auto">astro:env/server</code> module:</p> <div class="expressive-code">

<pre data-language="js">import { PORT } from "astro:env/server"</pre>

</div> </li> <li> <p><strong>Secret server variables</strong>: These variables are not part of your final bundle and can be accessed on the server through the <code dir="auto">astro:env/server</code> module. The <code dir="auto">getSecret()</code> helper function can be used to retrieve secrets not specified in the schema. Its implementation is provided by your adapter and defaults to <code dir="auto">process.env</code>:</p> <div class="expressive-code">

<pre data-language="js">import { API_SECRET, getSecret } from "astro:env/server"


const SECRET_NOT_IN_SCHEMA = getSecret("SECRET_NOT_IN_SCHEMA") // string | undefined</pre>

</div> </li> </ul> <p><strong>Note:</strong> Secret client variables are not supported because there is no safe way to send this data to the client. Therefore, it is not possible to configure both <code dir="auto">context: "client"</code> and <code dir="auto">access: "secret"</code> in your schema.</p> <p>For a complete overview, and to give feedback on this experimental API, see the <a href="https://github.com/withastro/roadmap/blob/feat/astro-env-rfc/proposals/0046-astro-env.md">Astro Env RFC</a>.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="experimentalenvschema">experimental.env.schema</h4></div> 
<p><strong>Type:</strong> <code dir="auto">EnvSchema</code><br> <strong>Default:</strong> <code dir="auto">undefined</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.10.0</code> </span> <p>An object that uses <code dir="auto">envField</code> to define the data type (<code dir="auto">string</code>, <code dir="auto">number</code>, or <code dir="auto">boolean</code>) and properties of your environment variables: <code dir="auto">context</code> (client or server), <code dir="auto">access</code> (public or secret), a <code dir="auto">default</code> value to use, and whether or not this environment variable is <code dir="auto">optional</code> (defaults to <code dir="auto">false</code>).</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig, envField } from "astro/config"


export default defineConfig({
  experimental: {
    env: {
      schema: {
        API_URL: envField.string({ context: "client", access: "public", optional: true }),
        PORT: envField.number({ context: "server", access: "public", default: 4321 }),
        API_SECRET: envField.string({ context: "server", access: "secret" }),
      }
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="experimentalenvvalidatesecrets">experimental.env.validateSecrets</h4></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.11.6</code> </span> <p>Whether or not to validate secrets on the server when starting the dev server or running a build.</p> <p>By default, only public variables are validated on the server when starting the dev server or a build, and private variables are validated at runtime only. If enabled, private variables will also be checked on start. This is useful in some continuous integration (CI) pipelines to make sure all your secrets are correctly set before deploying.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">import { defineConfig, envField } from "astro/config"


export default defineConfig({
  experimental: {
    env: {
      schema: {
        // ...
      },
      validateSecrets: true
    }
  }
})</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalserverislands">experimental.serverIslands</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.12.0</code> </span> <p>Enables experimental Server Island features. Server Islands offer the ability to defer a component to render asynchronously after the page has already rendered.</p> <p>To enable, configure an <a href="../../basics/rendering-modes/index.html#on-demand-rendered">on-demand server rendering <code dir="auto">output</code> mode</a> with an adapter, and add the <code dir="auto">serverIslands</code> flag to the <code dir="auto">experimental</code> object:</p> <div class="expressive-code">

<pre data-language="js">{
  output: 'hybrid', // or 'server'
  adapter: nodejs({ mode: 'standalone' }),
  experimental: {
    serverIslands: true,
  },
}</pre>

</div> <p>Use the <code dir="auto">server:defer</code> directive on any Astro component to delay initial rendering:</p> <div class="expressive-code">

<pre data-language="astro">---
import Avatar from '~/components/Avatar.astro';
---
&lt;Avatar server:defer /&gt;</pre>

</div> <p>The outer page will be rendered, either at build time (<code dir="auto">hybrid</code>) or at runtime (<code dir="auto">server</code>) with the island content omitted and a <code dir="auto">&lt;script&gt;</code> tag included in its place.</p> <p>After the page loads in the browser, the script tag will replace itself with the the contents of the island by making a request.</p> <p>Any Astro component can be given the <code dir="auto">server: defer</code> attribute to delay its rendering. There is no special API and you can write <code dir="auto">.astro</code> code as normal:</p> <div class="expressive-code">

<pre data-language="astro">---
import { getUser } from '../api';


const user = await getUser(Astro.locals.userId);
---
&lt;img class="avatar" src={user.imageUrl}&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="server-island-fallback-content">Server island fallback content</h4></div> <p>Since your component will not render with the rest of the page, you may want to add generic content (e.g. a loading message) to temporarily show in its place. This content will be displayed when the page first renders but before the island has loaded.</p> <p>Add placeholder content as a child of your Astro component with the <code dir="auto">slot="fallback"</code> attribute. When your island content is available, the fallback content will be replaced.</p> <p>The example below displays a generic avatar as fallback content, then animates into a personalized avatar using view transitions:</p> <div class="expressive-code">

<pre data-language="astro">&lt;Avatar server:defer&gt;
  &lt;svg slot="fallback" class="generic-avatar" transition:name="avatar"&gt;...&lt;/svg&gt;
&lt;/Avatar&gt;</pre>

</div> <p>For a complete overview, and to give feedback on this experimental API, see the <a href="https://github.com/withastro/roadmap/pull/963">Server Islands RFC</a>.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalcontentintellisense">experimental.contentIntellisense</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.14.0</code> <span class="sl-badge default small astro-ctesguby">New</span> </span> <p>Enables Intellisense features (e.g. code completion, quick hints) for your content collection entries in compatible editors.</p> <p>When enabled, this feature will generate and add JSON schemas to the <code dir="auto">.astro</code> directory in your project. These files can be used by the Astro language server to provide Intellisense inside content files (<code dir="auto">.md</code>, <code dir="auto">.mdx</code>, <code dir="auto">.mdoc</code>).</p> <div class="expressive-code">

<pre data-language="js">{
  experimental: {
    contentIntellisense: true,
  },
}</pre>

</div> <p>To use this feature with the Astro VS Code extension, you must also enable the <code dir="auto">astro.content-intellisense</code> option in your VS Code settings. For editors using the Astro language server directly, pass the <code dir="auto">contentIntellisense: true</code> initialization parameter to enable this feature.</p> <div tabindex="-1" class="heading-wrapper level-h3"><h3 id="experimentalcontentlayer">experimental.contentLayer</h3></div> 
<p><strong>Type:</strong> <code dir="auto">boolean</code><br> <strong>Default:</strong> <code dir="auto">false</code><br></p>
<span> <strong>Added in:</strong> <code>astro@4.14.0</code> <span class="sl-badge default small astro-ctesguby">New</span> </span> <p>The Content Layer API is a new way to handle content and data in Astro. It is similar to and builds upon <a href="../../guides/content-collections/index.html">content collections</a>, taking them beyond local files in <code dir="auto">src/content/</code> and allowing you to fetch content from anywhere, including remote APIs, by adding a <code dir="auto">loader</code> to your collection.</p> <p>Your existing content collections can be <a href="#migrating-an-existing-content-collection-to-use-the-content-layer-api">migrated to the Content Layer API</a> with a few small changes. However, it is not necessary to update all your collections at once to add a new collection powered by the Content Layer API. You may have collections using both the existing and new APIs defined in <code dir="auto">src/content/config.ts</code> at the same time.</p> <p>The Content Layer API is designed to be more powerful and more performant, helping sites scale to thousands of pages. Data is cached between builds and updated incrementally. Markdown parsing is also 5-10 times faster, with similar scale reductions in memory, and MDX is 2-3 times faster.</p> <p>To enable, add the <code dir="auto">contentLayer</code> flag to the <code dir="auto">experimental</code> object in your Astro config:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">astro.config.mjs</span></div>
<pre data-language="js">{
  experimental: {
    contentLayer: true,
  }
}</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="fetching-data-with-a-loader">Fetching data with a <code dir="auto">loader</code>
</h4></div> <p>The Content Layer API allows you to fetch your content from outside of the <code dir="auto">src/content/</code> folder (whether stored locally in your project or remotely) and uses a <code dir="auto">loader</code> property to retrieve your data.</p> <p>The <code dir="auto">loader</code> is defined in the collection’s schema and returns an array of entries. Astro provides two built-in loader functions (<code dir="auto">glob()</code> and <code dir="auto">file()</code>) for fetching your local content, as well as access to the API to <a href="#creating-a-loader">construct your own loader and fetch remote data</a>.</p> <p>The <code dir="auto">glob()</code> loader creates entries from directories of Markdown, MDX, Markdoc, or JSON files from anywhere on the filesystem. It accepts a <code dir="auto">pattern</code> of entry files to match, and a <code dir="auto">base</code> file path of where your files are located. Use this when you have one file per entry.</p> <p>The <code dir="auto">file()</code> loader creates multiple entries from a single local file. Use this when all your entries are stored in an array of objects.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">import { defineCollection, z } from 'astro:content';
import { glob, file } from 'astro/loaders';


const blog = defineCollection({
  // By default the ID is a slug generated from
  // the path of the file relative to `base`
  loader: glob({ pattern: "**\/*.md", base: "./src/data/blog" }),
  schema: z.object({
    title: z.string(),
    description: z.string(),
    pubDate: z.coerce.date(),
    updatedDate: z.coerce.date().optional(),
  })
});


const dogs = defineCollection({
  // The path is relative to the project root, or an absolute path.
  loader: file("src/data/dogs.json"),
  schema: z.object({
    id: z.string(),
    breed: z.string(),
    temperament: z.array(z.string()),
  }),
});


export const collections = { blog, dogs };</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="querying-and-rendering-with-the-content-layer-api">Querying and rendering with the Content Layer API</h4></div> <p>The collection can be <a href="../../guides/content-collections/index.html#querying-collections">queried in the same way as content collections</a>:</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/index.astro</span></div>
<pre data-language="ts">import { getCollection, getEntry } from 'astro:content';


// Get all entries from a collection.
// Requires the name of the collection as an argument.
const allBlogPosts = await getCollection('blog');


// Get a single entry from a collection.
// Requires the name of the collection and ID
const labradorData = await getEntry('dogs', 'labrador-retriever');</pre>

</div> <p>Entries generated from Markdown, MDX, or Markdoc can be rendered directly to a page using the <code dir="auto">render()</code> function.</p> <aside aria-label="Note" class="starlight-aside starlight-aside--note"><p class="starlight-aside__title" aria-hidden="true">Note</p>
<section class="starlight-aside__content"><p>The syntax for rendering collection entries is different from the current content collections syntax.</p></section></aside> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/[slug].astro</span></div>
<pre data-language="astro">---
import { getEntry, render } from 'astro:content';


const post = await getEntry('blog', Astro.params.slug);


const { Content, headings } = await render(entry);
---


&lt;Content /&gt;</pre>

</div> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="creating-a-loader">Creating a loader</h4></div> <p>With the Content Layer API, you can build loaders to load or generate content from anywhere.</p> <p>For example, you can create a loader that fetches collection entries from a remote API.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">const countries = defineCollection({
  loader: async () =&gt; {
    const response = await fetch("https://restcountries.com/v3.1/all");
    const data = await response.json();
    // Must return an array of entries with an id property,
    // or an object with IDs as keys and entries as values
    return data.map((country) =&gt; ({
      id: country.cca3,
      ...country,
    }));
  },
  // optionally add a schema
  // schema: z.object...
});


export const collections = { countries };</pre>

</div> <p>For more advanced loading logic, you can define an object loader. This allows incremental updates and conditional loading while also giving full access to the data store. See the API in <a href="https://github.com/withastro/roadmap/blob/content-layer/proposals/0047-content-layer.md#loaders">the Content Layer API RFC</a>.</p> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="migrating-an-existing-content-collection-to-use-the-content-layer-api">Migrating an existing content collection to use the Content Layer API</h4></div> <p>You can convert an existing content collection with Markdown, MDX, Markdoc, or JSON entries to use the Content Layer API.</p> <ol> <li> <p><strong>Move the collection folder out of <code dir="auto">src/content/</code></strong> (e.g. to <code dir="auto">src/data/</code>). All collections located in the <code dir="auto">src/content/</code> folder will use the existing Content Collections API.</p> <p><strong>Do not move the existing <code dir="auto">src/content/config.ts</code> file</strong>. This file will define all collections, using either API.</p> </li> <li> <p><strong>Edit the collection definition</strong>. Your updated collection requires a <code dir="auto">loader</code>, and the option to select a collection <code dir="auto">type</code> is no longer available.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/content/config.ts</span></div>
<pre data-language="ts">import { defineCollection, z } from 'astro:content';
import { glob } from 'astro/loaders';


const blog = defineCollection({
  // For content layer you no longer define a `type`
 type: 'content',
 loader: glob({ pattern: "**\/*.md", base: "./src/data/blog" }),
  schema: z.object({
    title: z.string(),
    description: z.string(),
    pubDate: z.coerce.date(),
    updatedDate: z.coerce.date().optional(),
  }),
});</pre>

</div> </li> <li> <p><strong>Change references from <code dir="auto">slug</code> to <code dir="auto">id</code></strong>. Content layer collections do not have a <code dir="auto">slug</code> field. Instead, all updated collections will have an <code dir="auto">id</code>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/index.astro</span></div>
<pre data-language="astro">---
export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map((post) =&gt; ({
    params: { slug: post.slug },
    params: { slug: post.id },
    props: post,
  }));
}
---</pre>

</div> </li> <li> <p><strong>Switch to the new <code dir="auto">render()</code> function</strong>. Entries no longer have a <code dir="auto">render()</code> method, as they are now serializable plain objects. Instead, import the <code dir="auto">render()</code> function from <code dir="auto">astro:content</code>.</p> <div class="expressive-code">
<div class="_pre-heading"><span class="title">src/pages/index.astro</span></div>
<pre data-language="astro">---
 import { getEntry } from 'astro:content';
 import { getEntry, render } from 'astro:content';


  const post = await getEntry('blog', params.slug);


 const { Content, headings } = await post.render();
 const { Content, headings } = await render(post);
---


&lt;Content /&gt;</pre>

</div> </li> </ol> <div tabindex="-1" class="heading-wrapper level-h4"><h4 id="learn-more">Learn more</h4></div> <p>For a complete overview and the full API reference, see <a href="https://github.com/withastro/roadmap/blob/content-layer/proposals/0047-content-layer.md">the Content Layer API RFC</a> and <a href="https://github.com/withastro/roadmap/pull/982">share your feedback</a>.</p> <span id="docsearch-lvl0" hidden class="astro-klj6ju3r">Reference</span> </div>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2021 Fred K. Schott<br>Licensed under the MIT License.<br>
    <a href="https://docs.astro.build/en/reference/configuration-reference/" class="_attribution-link">https://docs.astro.build/en/reference/configuration-reference/</a>
  </p>
</div>
