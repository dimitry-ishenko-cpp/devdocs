<h1 class="command-name">FT.SEARCH</h1>
<pre>FT.SEARCH</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">FT.SEARCH index query 
  [NOCONTENT] 
  [VERBATIM] [NOSTOPWORDS] 
  [WITHSCORES] 
  [WITHPAYLOADS] 
  [WITHSORTKEYS] 
  [FILTER numeric_field min max [ FILTER numeric_field min max ...]] 
  [GEOFILTER geo_field lon lat radius m | km | mi | ft [ GEOFILTER geo_field lon lat radius m | km | mi | ft ...]] 
  [INKEYS count key [key ...]] [ INFIELDS count field [field ...]] 
  [RETURN count identifier [AS property] [ identifier [AS property] ...]] 
  [SUMMARIZE [ FIELDS count field [field ...]] [FRAGS num] [LEN fragsize] [SEPARATOR separator]] 
  [HIGHLIGHT [ FIELDS count field [field ...]] [ TAGS open close]] 
  [SLOP slop] 
  [TIMEOUT timeout] 
  [INORDER] 
  [LANGUAGE language] 
  [EXPANDER expander] 
  [SCORER scorer] 
  [EXPLAINSCORE] 
  [PAYLOAD payload] 
  [SORTBY sortby [ ASC | DESC]] 
  [LIMIT offset num] 
  [PARAMS nargs name value [ name value ...]] 
  [DIALECT dialect]
</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available in:</dt> <dd> <a href="https://redis.io/docs/stack">Redis Stack</a> / <a href="https://redis.io/docs/stack/search">Search 1.0.0</a> </dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(N)</dd> </dl> <p>Search the index with a textual query, returning either documents or just ids</p> <p><a href="#examples">Examples</a></p> <h2 id="required-arguments">Required arguments</h2> <details open> <summary><code>index</code></summary> <p>is index name. You must first create the index using <a href="../ft.create.html"><code>FT.CREATE</code></a>.</p> </details> <details open> <summary><code>query</code></summary> <p>is text query to search. If it's more than a single word, put it in quotes. Refer to <a href="https://redis.io/docs/stack/search/reference/query_syntax">Query syntax</a> for more details.</p> </details> <h2 id="optional-arguments">Optional arguments</h2> <details open> <summary><code>NOCONTENT</code></summary> <p>returns the document ids and not the content. This is useful if RediSearch is only an index on an external document collection.</p> </details> <details open> <summary><code>VERBATIM</code></summary> <p>does not try to use stemming for query expansion but searches the query terms verbatim.</p> </details> <details open> <summary><code>WITHSCORES</code></summary> <p>also returns the relative internal score of each document. This can be used to merge results from multiple instances.</p> </details> <details open> <summary><code>WITHPAYLOADS</code></summary> <p>retrieves optional document payloads. See <a href="../ft.create.html"><code>FT.CREATE</code></a>. The payloads follow the document id and, if <code>WITHSCORES</code> is set, the scores.</p> </details> <details open> <summary><code>WITHSORTKEYS</code></summary> <p>returns the value of the sorting key, right after the id and score and/or payload, if requested. This is usually not needed, and exists for distributed search coordination purposes. This option is relevant only if used in conjunction with <code>SORTBY</code>.</p> </details> <details open> <summary><code>FILTER numeric_attribute min max</code></summary> <p>limits results to those having numeric values ranging between <code>min</code> and <code>max</code>, if numeric_attribute is defined as a numeric attribute in <a href="../ft.create.html"><code>FT.CREATE</code></a>. <code>min</code> and <code>max</code> follow <a href="../zrange.html"><code>ZRANGE</code></a> syntax, and can be <code>-inf</code>, <code>+inf</code>, and use <code>(</code> for exclusive ranges. Multiple numeric filters for different attributes are supported in one query.</p> </details> <details open> <summary><code>GEOFILTER {geo_attribute} {lon} {lat} {radius} m|km|mi|ft</code></summary> <p>filter the results to a given <code>radius</code> from <code>lon</code> and <code>lat</code>. Radius is given as a number and units. See <a href="../georadius.html"><code>GEORADIUS</code></a> for more details.</p> </details> <details open> <summary><code>INKEYS {num} {attribute} ...</code></summary> <p>limits the result to a given set of keys specified in the list. The first argument must be the length of the list and greater than zero. Non-existent keys are ignored, unless all the keys are non-existent.</p> </details> <details open> <summary><code>INFIELDS {num} {attribute} ...</code></summary> <p>filters the results to those appearing only in specific attributes of the document, like <code>title</code> or <code>URL</code>. You must include <code>num</code>, which is the number of attributes you're filtering by. For example, if you request <code>title</code> and <code>URL</code>, then <code>num</code> is 2.</p> </details> <details open> <summary><code>RETURN {num} {identifier} AS {property} ...</code></summary> <p>limits the attributes returned from the document. <code>num</code> is the number of attributes following the keyword. If <code>num</code> is 0, it acts like <code>NOCONTENT</code>. <code>identifier</code> is either an attribute name (for hashes and JSON) or a JSON Path expression (for JSON). <code>property</code> is an optional name used in the result. If not provided, the <code>identifier</code> is used in the result.</p> </details> <details open> <summary><code>SUMMARIZE ...</code></summary> <p>returns only the sections of the attribute that contain the matched text. See <a href="https://redis.io/docs/stack/search/reference/highlight">Highlighting</a> for more information.</p> </details> <details open> <summary><code>HIGHLIGHT ...</code></summary> <p>formats occurrences of matched text. See <a href="https://redis.io/docs/stack/search/reference/highlight">Highlighting</a> for more information.</p> </details> <details open> <summary><code>SLOP {slop}</code></summary> <p>is the number of intermediate terms allowed to appear between the terms of the query. Suppose you're searching for a phrase <em>hello world</em>. If some terms appear in-between <em>hello</em> and <em>world</em>, a <code>SLOP</code> greater than <code>0</code> allows for these text attributes to match. By default, there is no <code>SLOP</code> constraint.</p> </details> <details open> <summary><code>INORDER</code></summary> <p>requires the terms in the document to have the same order as the terms in the query, regardless of the offsets between them. Typically used in conjunction with <code>SLOP</code>. Default is <code>false</code>.</p> </details> <details open> <summary><code>LANGUAGE {language}</code></summary> <p>use a stemmer for the supplied language during search for query expansion. If querying documents in Chinese, set to <code>chinese</code> to properly tokenize the query terms. Defaults to English. If an unsupported language is sent, the command returns an error. See <a href="../ft.create.html"><code>FT.CREATE</code></a> for the list of languages.</p> </details> <details open> <summary><code>EXPANDER {expander}</code></summary> <p>uses a custom query expander instead of the stemmer. See <a href="https://redis.io/docs/stack/search/reference/extensions">Extensions</a>.</p> </details> <details open> <summary><code>SCORER {scorer}</code></summary> <p>uses a custom scoring function you define. See <a href="https://redis.io/docs/stack/search/reference/extensions">Extensions</a>.</p> </details> <details open> <summary><code>EXPLAINSCORE</code></summary> <p>returns a textual description of how the scores were calculated. Using this option requires <code>WITHSCORES</code>.</p> </details> <details open> <summary><code>PAYLOAD {payload}</code></summary> <p>adds an arbitrary, binary safe payload that is exposed to custom scoring functions. See <a href="https://redis.io/docs/stack/search/reference/extensions">Extensions</a>.</p> </details> <details open> <summary><code>SORTBY {attribute} [ASC|DESC]</code></summary> <p>orders the results by the value of this attribute. This applies to both text and numeric attributes. Attributes needed for <code>SORTBY</code> should be declared as <code>SORTABLE</code> in the index, in order to be available with very low latency. Note that this adds memory overhead.</p> </details> <details open> <summary><code>LIMIT first num</code></summary> <p>limits the results to the offset and number of results given. Note that the offset is zero-indexed. The default is 0 10, which returns 10 items starting from the first result. You can use <code>LIMIT 0 0</code> to count the number of documents in the result set without actually returning them.</p> </details> <details open> <summary><code>TIMEOUT {milliseconds}</code></summary> <p>overrides the timeout parameter of the module.</p> </details> <details open> <summary><code>PARAMS {nargs} {name} {value}</code></summary> <p>defines one or more value parameters. Each parameter has a name and a value.</p> <p>You can reference parameters in the <code>query</code> by a <code>$</code>, followed by the parameter name, for example, <code>$user</code>. Each such reference in the search query to a parameter name is substituted by the corresponding parameter value. For example, with parameter definition <code>PARAMS 4 lon 29.69465 lat 34.95126</code>, the expression <code>@loc:[$lon $lat 10 km]</code> is evaluated to <code>@loc:[29.69465 34.95126 10 km]</code>. You cannot reference parameters in the query string where concrete values are not allowed, such as in field names, for example, <code>@loc</code>. To use <code>PARAMS</code>, set <code>DIALECT</code> to <code>2</code> or greater than <code>2</code>.</p> </details> <details open> <summary><code>DIALECT {dialect_version}</code></summary> <p>selects the dialect version under which to execute the query. If not specified, the query will execute under the default dialect version set during module initial loading or via <a href="../ft.config-set.html"><code>FT.CONFIG SET</code></a> command.</p> </details> <h2 id="return">Return</h2> <p>FT.SEARCH returns an array reply, where the first element is an integer reply of the total number of results, and then array reply pairs of document ids, and array replies of attribute/value pairs.</p> <div class="pl-4 border-l-8"> <div class="font-semibold text-slate-900">Notes</div> <ul> <li>If <code>NOCONTENT</code> is given, an array is returned where the first element is the total number of results, and the rest of the members are document ids.</li> <li>If a hash expires after the query process starts, the hash is counted in the total number of results, but the key name and content return as null.</li> </ul> </div> <h3 id="return-multiple-values">Return multiple values</h3> <p>When the index is defined <code>ON JSON</code>, a reply for a single attribute or a single JSONPath may return multiple values when the JSONPath matches multiple values, or when the JSONPath matches an array.</p> <p>Prior to RediSearch v2.6, only the first of the matched values was returned. Starting with RediSearch v2.6, all values are returned, wrapped with a top-level array.</p> <p>In order to maintain backward compatibility, the default behavior with RediSearch v2.6 is to return only the first value.</p> <p>To return all the values, use <code>DIALECT</code> 3 (or greater, when available).</p> <p>The <code>DIALECT</code> can be specified as a parameter in the FT.SEARCH command. If it is not specified, the <code>DEFAULT_DIALECT</code> is used, which can be set using <a href="../ft.config-set.html"><code>FT.CONFIG SET</code></a> or by passing it as an argument to the <code>redisearch</code> module when it is loaded.</p> <p>For example, with the following document and index:</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; JSON.SET doc:1 $ <span class="s1">'[{"arr": [1, 2, 3]}, {"val": "hello"}, {"val": "world"}]'</span>
</span></span><span class="line"><span class="cl">OK
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.CREATE idx ON JSON PREFIX <span class="m">1</span> doc: SCHEMA $..arr AS arr NUMERIC $..val AS val TEXT
</span></span><span class="line"><span class="cl">OK
</span></span></pre></div>
<p>Notice the different replies, with and without <code>DIALECT 3</code>:</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH idx * RETURN <span class="m">2</span> arr val
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"doc:1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"arr"</span>
</span></span><span class="line"><span class="cl">   2<span class="o">)</span> <span class="s2">"[1,2,3]"</span>
</span></span><span class="line"><span class="cl">   3<span class="o">)</span> <span class="s2">"val"</span>
</span></span><span class="line"><span class="cl">   4<span class="o">)</span> <span class="s2">"hello"</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH idx * RETURN <span class="m">2</span> arr val DIALECT <span class="m">3</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"doc:1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> 1<span class="o">)</span> <span class="s2">"arr"</span>
</span></span><span class="line"><span class="cl">   2<span class="o">)</span> <span class="s2">"[[1,2,3]]"</span>
</span></span><span class="line"><span class="cl">   3<span class="o">)</span> <span class="s2">"val"</span>
</span></span><span class="line"><span class="cl">   4<span class="o">)</span> <span class="s2">"[\"hello\",\"world\"]"</span>
</span></span></pre></div>
<h2 id="complexity">Complexity</h2> <p>FT.SEARCH complexity is O(n) for single word queries. <code>n</code> is the number of the results in the result set. Finding all the documents that have a specific term is O(1), however, a scan on all those documents is needed to load the documents data from redis hashes and return them.</p> <p>The time complexity for more complex queries varies, but in general it's proportional to the number of words, the number of intersection points between them and the number of results in the result set.</p> <h2 id="examples">Examples</h2> <details open> <summary><b>Search for a term in every text attribute</b></summary> <p>Search for the term "wizard" in every TEXT attribute of an index containing book data.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"wizard"</span></span></span></pre></div> </details> <details open> <summary><b>Search for a term in title attribute</b></summary> <p>Search for the term <em>dogs</em> in the <code>title</code> attribute.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"@title:dogs"</span></span></span></pre></div> </details> <details open> <summary><b>Search for books from specific years</b></summary> <p>Search for books published in 2020 or 2021.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"@published_at:[2020 2021]"</span></span></span></pre></div> </details> <details open> <summary><b>Search for a restaurant by distance from longitude/latitude</b></summary> <p>Search for Chinese restaurants within 5 kilometers of longitude -122.41, latitude 37.77 (San Francisco).</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH restaurants-idx <span class="s2">"chinese @location:[-122.41 37.77 5 km]"</span></span></span></pre></div> </details> <details open> <summary><b>Search for a book by terms but boost specific term</b></summary> <p>Search for the term <em>dogs</em> or <em>cats</em> in the <code>title</code> attribute, but give matches of <em>dogs</em> a higher relevance score (also known as <em>boosting</em>).</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"(@title:dogs | @title:cats) | (@title:dogs) =&gt; { </span><span class="nv">$weight</span><span class="s2">: 5.0; }"</span></span></span></pre></div> </details> <details open> <summary><b>Search for a book by a term and EXPLAINSCORE</b></summary> <p>Search for books with <em>dogs</em> in any TEXT attribute in the index and request an explanation of scoring for each result.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"dogs"</span> WITHSCORES EXPLAINSCORE</span></span></pre></div> </details> <details open> <summary><b>Search for a book by a term and TAG</b></summary> <p>Search for books with <em>space</em> in the title that have <code>science</code> in the TAG attribute <code>categories</code>.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"@title:space @categories:{science}"</span></span></span></pre></div> </details> <details open> <summary><b>Search for a book by a term but limit the number</b></summary> <p>Search for books with <em>Python</em> in any <code>TEXT</code> attribute, returning 10 results starting with the 11th result in the entire result set (the offset parameter is zero-based), and return only the <code>title</code> attribute for each result.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"python"</span> LIMIT <span class="m">10</span> <span class="m">10</span> RETURN <span class="m">1</span> title</span></span></pre></div> </details> <details open> <summary><b>Search for a book by a term and price</b></summary> <p>Search for books with <em>Python</em> in any <code>TEXT</code> attribute, returning the price stored in the original JSON document.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"python"</span> RETURN <span class="m">3</span> $.book.price AS price</span></span></pre></div> </details> <details open> <summary><b>Search for a book by title and distance</b></summary> <p>Search for books with semantically similar title to <em>Planet Earth</em>. Return top 10 results sorted by distance.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH books-idx <span class="s2">"*=&gt;[KNN 10 @title_embedding </span><span class="nv">$query_vec</span><span class="s2"> AS title_score]"</span> PARAMS <span class="m">2</span> query_vec &lt;<span class="s2">"Planet Earth"</span> embedding BLOB&gt; SORTBY title_score DIALECT <span class="m">2</span></span></span></pre></div> </details> <details open> <summary><b>Search for a phrase using SLOP</b></summary> <p>Search for a phrase <em>hello world</em>. First, create an index.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.CREATE memes SCHEMA phrase TEXT
</span></span><span class="line"><span class="cl">OK</span></span></pre></div> <p>Add variations of the phrase <em>hello world</em>.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; HSET s1 phrase <span class="s2">"hello world"</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; HSET s2 phrase <span class="s2">"hello simple world"</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; HSET s3 phrase <span class="s2">"hello somewhat less simple world"</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; HSET s4 phrase <span class="s2">"hello complicated yet encouraging problem solving world"</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; HSET s5 phrase <span class="s2">"hello complicated yet amazingly encouraging problem solving world"</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span></span></span></pre></div> <p>Then, search for the phrase <em>hello world</em>. The result returns all documents that contain the phrase.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello world)'</span> NOCONTENT 
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">5</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> <span class="s2">"s2"</span>
</span></span><span class="line"><span class="cl">4<span class="o">)</span> <span class="s2">"s3"</span>
</span></span><span class="line"><span class="cl">5<span class="o">)</span> <span class="s2">"s4"</span>
</span></span><span class="line"><span class="cl">6<span class="o">)</span> <span class="s2">"s5"</span></span></span></pre></div> <p>Now, return all documents that have one of fewer words between <em>hello</em> and <em>world</em>.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello world)'</span> NOCONTENT SLOP <span class="m">1</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> <span class="s2">"s2"</span></span></span></pre></div> <p>Now, return all documents with three or fewer words between <em>hello</em> and <em>world</em>.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello world)'</span> NOCONTENT SLOP <span class="m">3</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">3</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> <span class="s2">"s2"</span>
</span></span><span class="line"><span class="cl">4<span class="o">)</span> <span class="s2">"s3"</span></span></span></pre></div> <p><code>s5</code> needs a higher <code>SLOP</code> to match, <code>SLOP 6</code> or higher, to be exact. See what happens when you set <code>SLOP</code> to <code>5</code>.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello world)'</span> NOCONTENT SLOP <span class="m">5</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">4</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s1"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> <span class="s2">"s2"</span>
</span></span><span class="line"><span class="cl">4<span class="o">)</span> <span class="s2">"s3"</span>
</span></span><span class="line"><span class="cl">5<span class="o">)</span> <span class="s2">"s4"</span></span></span></pre></div> <p>If you add additional terms (and stemming), you get these results.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello amazing world)'</span> NOCONTENT 
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s5"</span></span></span></pre></div> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello encouraged world)'</span> NOCONTENT SLOP <span class="m">5</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">2</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s4"</span>
</span></span><span class="line"><span class="cl">3<span class="o">)</span> <span class="s2">"s5"</span></span></span></pre></div> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(hello encouraged world)'</span> NOCONTENT SLOP <span class="m">4</span>
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s4"</span></span></span></pre></div> <p>If you swap the terms, you can still retrieve the correct phrase.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(amazing hello world)'</span> NOCONTENT
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">1</span>
</span></span><span class="line"><span class="cl">2<span class="o">)</span> <span class="s2">"s5"</span></span></span></pre></div> <p>But, if you use <code>INORDER</code>, you get zero results.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(amazing hello world)'</span> NOCONTENT INORDER
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">0</span></span></span></pre></div> <p>Likewise, if you use a query attribute <code>$inorder</code> set to <code>true</code>, <code>s5</code> is not retrieved.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; FT.SEARCH memes <span class="s1">'@phrase:(amazing hello world)=&gt;{$inorder: true;}'</span> NOCONTENT
</span></span><span class="line"><span class="cl">1<span class="o">)</span> <span class="o">(</span>integer<span class="o">)</span> <span class="m">0</span></span></span></pre></div> <p>To sum up, the <code>INORDER</code> argument or <code>$inorder</code> query attribute require the query terms to match terms with similar ordering.</p> </details> <h2 id="see-also">See also</h2> <p><a href="../ft.create.html"><code>FT.CREATE</code></a> | <a href="../ft.aggregate.html"><code>FT.AGGREGATE</code></a></p> <h2 id="related-topics">Related topics</h2> <ul> <li><a href="https://redis.io/docs/stack/search/reference/extensions">Extensions</a></li> <li><a href="https://redis.io/docs/stack/search/reference/highlight">Highlighting</a></li> <li><a href="https://redis.io/docs/stack/search/reference/query_syntax">Query syntax</a></li> <li><a href="https://redis.io/docs/stack/search">RediSearch</a></li> </ul> <h2>History</h2> <ul> <li>Starting with Redis version 2.0.0: Deprecated <code>WITHPAYLOADS</code> and <code>PAYLOAD</code> arguments</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/ft.search/" class="_attribution-link">https://redis.io/commands/ft.search/</a>
  </p>
</div>
