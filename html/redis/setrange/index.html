<h1 class="command-name">SETRANGE</h1>
<pre>SETRANGE</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">SETRANGE key offset value</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available since:</dt> <dd>2.2.0</dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(1), not counting the time taken to copy the new string in place. Usually, this string is very small so the amortized complexity is O(1). Otherwise, complexity is O(M) with M being the length of the value argument.</dd> <dt class="font-semibold text-slate-900">ACL categories:</dt> <dd> <code>@write</code><span class="mr-1 last:hidden">,</span> <code>@string</code><span class="mr-1 last:hidden">,</span> <code>@slow</code><span class="mr-1 last:hidden">,</span> </dd> </dl> <p>Overwrites part of the string stored at <em>key</em>, starting at the specified offset, for the entire length of <em>value</em>. If the offset is larger than the current length of the string at <em>key</em>, the string is padded with zero-bytes to make <em>offset</em> fit. Non-existing keys are considered as empty strings, so this command will make sure it holds a string large enough to be able to set <em>value</em> at <em>offset</em>.</p> <p>Note that the maximum offset that you can set is 2^29 -1 (536870911), as Redis Strings are limited to 512 megabytes. If you need to grow beyond this size, you can use multiple keys.</p> <p><strong>Warning</strong>: When setting the last possible byte and the string value stored at <em>key</em> does not yet hold a string value, or holds a small string value, Redis needs to allocate all intermediate memory which can block the server for some time. On a 2010 MacBook Pro, setting byte number 536870911 (512MB allocation) takes ~300ms, setting byte number 134217728 (128MB allocation) takes ~80ms, setting bit number 33554432 (32MB allocation) takes ~30ms and setting bit number 8388608 (8MB allocation) takes ~8ms. Note that once this first allocation is done, subsequent calls to <code>SETRANGE</code> for the same <em>key</em> will not have the allocation overhead.</p> <h2 id="patterns">Patterns</h2> <p>Thanks to <code>SETRANGE</code> and the analogous <a href="../getrange.html"><code>GETRANGE</code></a> commands, you can use Redis strings as a linear array with O(1) random access. This is a very fast and efficient storage in many real world use cases.</p> <h2 id="return">Return</h2> <p><a href="https://redis.io/docs/reference/protocol-spec#resp-integers">Integer reply</a>: the length of the string after it was modified by the command.</p> <h2 id="examples">Examples</h2> <p>Basic usage:</p>  <pre class="redis-cli overflow-y-auto max-h-80">
SET key1 "Hello World"
SETRANGE key1 6 "Redis"
GET key1
</pre> <p>Example of zero padding:</p>  <pre class="redis-cli overflow-y-auto max-h-80">
SETRANGE key2 6 "Redis"
GET key2
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/setrange/" class="_attribution-link">https://redis.io/commands/setrange/</a>
  </p>
</div>
