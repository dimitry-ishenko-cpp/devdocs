<h1 class="command-name">TS.CREATE</h1>
<pre>TS.CREATE</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">TS.CREATE key 
  [RETENTION retentionPeriod] 
  [ENCODING [UNCOMPRESSED|COMPRESSED]] 
  [CHUNK_SIZE size] 
  [DUPLICATE_POLICY policy] 
  [LABELS {label value}...]
</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available in:</dt> <dd> <a href="https://redis.io/docs/stack">Redis Stack</a> / <a href="https://redis.io/docs/stack/timeseries">TimeSeries 1.0.0</a> </dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(1)</dd> </dl> <p>Create a new time series</p> <p><a href="#examples">Examples</a></p> <h2 id="required-arguments">Required arguments</h2> <details open><summary><code>key</code></summary> <p>is key name for the time series.</p> </details> <p><note><b>Notes:</b></note></p> <ul> <li>If a key already exists, you get a Redis error reply, <code>TSDB: key already exists</code>. You can check for the existence of a key with the <a href="../exists.html"><code>EXISTS</code></a> command.</li> <li>Other commands that also create a new time series when called with a key that does not exist are <a href="../ts.add.html"><code>TS.ADD</code></a>, <a href="../ts.incrby.html"><code>TS.INCRBY</code></a>, and <a href="../ts.decrby.html"><code>TS.DECRBY</code></a>. </li> </ul> <h2 id="optional-arguments">Optional arguments</h2> <details open><summary><code>RETENTION retentionPeriod</code></summary> <p>is maximum age for samples compared to the highest reported timestamp, in milliseconds. Samples are expired based solely on the difference between their timestamp and the timestamps passed to subsequent <a href="../ts.add.html"><code>TS.ADD</code></a>, <a href="../ts.madd.html"><code>TS.MADD</code></a>, <a href="../ts.incrby.html"><code>TS.INCRBY</code></a>, and <a href="../ts.decrby.html"><code>TS.DECRBY</code></a> calls with this key.</p> <p>When set to 0, samples never expire. When not specified, the option is set to the global <a href="https://redis.io/docs/stack/timeseries/configuration/#retention_policy">RETENTION_POLICY</a> configuration of the database, which by default is 0.</p> </details> <details open><summary><code>ENCODING enc</code></summary> <p>specifies the series samples encoding format as one of the following values:</p> <ul> <li>
<code>COMPRESSED</code>, applies compression to the series samples.</li> <li>
<code>UNCOMPRESSED</code>, keeps the raw samples in memory. Adding this flag keeps data in an uncompressed form.</li> </ul> <p><code>COMPRESSED</code> is almost always the right choice. Compression not only saves memory but usually improves performance due to a lower number of memory accesses. It can result in about 90% memory reduction. The exception are highly irregular timestamps or values, which occur rarely.</p> <p>When not specified, the option is set to <code>COMPRESSED</code>.</p> </details> <details open><summary><code>CHUNK_SIZE size</code></summary> <p>is initial allocation size, in bytes, for the data part of each new chunk. Actual chunks may consume more memory. Changing chunkSize (using <a href="../ts.alter.html"><code>TS.ALTER</code></a>) does not affect existing chunks.</p> <p>Must be a multiple of 8 in the range [48 .. 1048576]. When not specified, it is set to the global <a href="https://redis.io/docs/stack/timeseries/configuration/#chunk_size_bytes">CHUNK_SIZE_BYTES</a> configuration of the database, which by default is 4096 (a single memory page).</p> <p>Note: Before v1.6.10 no minimum was enforced. Between v1.6.10 and v1.6.17 and in v1.8.0 the minimum value was 128. Since v1.8.1 the minimum value is 48.</p> <p>The data in each key is stored in chunks. Each chunk contains header and data for a given timeframe. An index contains all chunks. Iterations occur inside each chunk. Depending on your use case, consider these tradeoffs for having smaller or larger sizes of chunks:</p> <ul> <li>Insert performance: Smaller chunks result in slower inserts (more chunks need to be created).</li> <li>Query performance: Queries for a small subset when the chunks are very large are slower, as we need to iterate over the chunk to find the data.</li> <li>Larger chunks may take more memory when you have a very large number of keys and very few samples per key, or less memory when you have many samples per key.</li> </ul> <p>If you are unsure about your use case, select the default.</p> </details> <details open><summary><code>DUPLICATE_POLICY policy</code></summary> <p>is policy for handling insertion (<a href="../ts.add.html"><code>TS.ADD</code></a> and <a href="../ts.madd.html"><code>TS.MADD</code></a>) of multiple samples with identical timestamps, with one of the following values:</p> <ul> <li>
<code>BLOCK</code>: ignore any newly reported value and reply with an error</li> <li>
<code>FIRST</code>: ignore any newly reported value</li> <li>
<code>LAST</code>: override with the newly reported value</li> <li>
<code>MIN</code>: only override if the value is lower than the existing value</li> <li>
<code>MAX</code>: only override if the value is higher than the existing value</li> <li>
<code>SUM</code>: If a previous sample exists, add the new sample to it so that the updated value is equal to (previous + new). If no previous sample exists, set the updated value equal to the new value.</li> </ul> <p>When not specified: set to the global <a href="https://redis.io/docs/stack/timeseries/configuration/#duplicate_policy">DUPLICATE_POLICY</a> configuration of the database (which, by default, is <code>BLOCK</code>).</p> </details> <details open><summary><code>LABELS {label value}...</code></summary> <p>is set of label-value pairs that represent metadata labels of the key and serve as a secondary index.</p> <p>The <a href="../ts.mget.html"><code>TS.MGET</code></a>, <a href="../ts.mrange.html"><code>TS.MRANGE</code></a>, and <a href="../ts.mrevrange.html"><code>TS.MREVRANGE</code></a> commands operate on multiple time series based on their labels. The <a href="../ts.queryindex.html"><code>TS.QUERYINDEX</code></a> command returns all time series keys matching a given filter based on their labels.</p> </details> <h2 id="return-value">Return value</h2> <p><a href="https://redis.io/docs/reference/protocol-spec#resp-simple-strings">Simple string reply</a> - <code>OK</code> if executed correctly, or <a href="https://redis.io/docs/reference/protocol-spec#resp-errors">Error reply</a> otherwise.</p> <h2 id="examples">Examples</h2> <details open><summary><b>Create a temperature time series</b></summary> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; TS.CREATE temperature:2:32 RETENTION <span class="m">60000</span> DUPLICATE_POLICY MAX LABELS sensor_id <span class="m">2</span> area_id <span class="m">32</span>
</span></span><span class="line"><span class="cl">OK</span></span></pre></div> </details> <h2 id="see-also">See also</h2> <p><a href="../ts.add.html"><code>TS.ADD</code></a> | <a href="../ts.incrby.html"><code>TS.INCRBY</code></a> | <a href="../ts.decrby.html"><code>TS.DECRBY</code></a> | <a href="../ts.mget.html"><code>TS.MGET</code></a> | <a href="../ts.mrange.html"><code>TS.MRANGE</code></a> | <a href="../ts.mrevrange.html"><code>TS.MREVRANGE</code></a> | <a href="../ts.queryindex.html"><code>TS.QUERYINDEX</code></a></p> <h2 id="related-topics">Related topics</h2> <ul> <li><a href="https://redis.io/docs/stack/timeseries">RedisTimeSeries</a></li> <li><a href="https://redis.com/blog/redistimeseries-version-1-2-is-here/">RedisTimeSeries Version 1.2 Is Here!</a></li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/ts.create/" class="_attribution-link">https://redis.io/commands/ts.create/</a>
  </p>
</div>
