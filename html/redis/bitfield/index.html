<h1 class="command-name">BITFIELD</h1>
<pre>BITFIELD</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">BITFIELD key [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]
  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;
  [GET encoding offset | [OVERFLOW &lt;WRAP | SAT | FAIL&gt;]
  &lt;SET encoding offset value | INCRBY encoding offset increment&gt;
  ...]]</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available since:</dt> <dd>3.2.0</dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(1) for each subcommand specified</dd> <dt class="font-semibold text-slate-900">ACL categories:</dt> <dd> <code>@write</code><span class="mr-1 last:hidden">,</span> <code>@bitmap</code><span class="mr-1 last:hidden">,</span> <code>@slow</code><span class="mr-1 last:hidden">,</span> </dd> </dl> <p>The command treats a Redis string as an array of bits, and is capable of addressing specific integer fields of varying bit widths and arbitrary non (necessary) aligned offset. In practical terms using this command you can set, for example, a signed 5 bits integer at bit offset 1234 to a specific value, retrieve a 31 bit unsigned integer from offset 4567. Similarly the command handles increments and decrements of the specified integers, providing guaranteed and well specified overflow and underflow behavior that the user can configure.</p> <p><code>BITFIELD</code> is able to operate with multiple bit fields in the same command call. It takes a list of operations to perform, and returns an array of replies, where each array matches the corresponding operation in the list of arguments.</p> <p>For example the following command increments a 5 bit signed integer at bit offset 100, and gets the value of the 4 bit unsigned integer at bit offset 0:</p> <pre>&gt; BITFIELD mykey INCRBY i5 100 1 GET u4 0
1) (integer) 1
2) (integer) 0
</pre> <p>Note that:</p> <ol> <li>Addressing with <code>GET</code> bits outside the current string length (including the case the key does not exist at all), results in the operation to be performed like the missing part all consists of bits set to 0.</li> <li>Addressing with <code>SET</code> or <code>INCRBY</code> bits outside the current string length will enlarge the string, zero-padding it, as needed, for the minimal length needed, according to the most far bit touched.</li> </ol> <h2 id="supported-subcommands-and-integer-encoding">Supported subcommands and integer encoding</h2> <p>The following is the list of supported commands.</p> <ul> <li>
<strong>GET</strong> <code>&lt;encoding&gt;</code> <code>&lt;offset&gt;</code> -- Returns the specified bit field.</li> <li>
<strong>SET</strong> <code>&lt;encoding&gt;</code> <code>&lt;offset&gt;</code> <code>&lt;value&gt;</code> -- Set the specified bit field and returns its old value.</li> <li>
<strong>INCRBY</strong> <code>&lt;encoding&gt;</code> <code>&lt;offset&gt;</code> <code>&lt;increment&gt;</code> -- Increments or decrements (if a negative increment is given) the specified bit field and returns the new value.</li> </ul> <p>There is another subcommand that only changes the behavior of successive <code>INCRBY</code> and <code>SET</code> subcommands calls by setting the overflow behavior:</p> <ul> <li>
<strong>OVERFLOW</strong> <code>[WRAP|SAT|FAIL]</code>
</li> </ul> <p>Where an integer encoding is expected, it can be composed by prefixing with <code>i</code> for signed integers and <code>u</code> for unsigned integers with the number of bits of our integer encoding. So for example <code>u8</code> is an unsigned integer of 8 bits and <code>i16</code> is a signed integer of 16 bits.</p> <p>The supported encodings are up to 64 bits for signed integers, and up to 63 bits for unsigned integers. This limitation with unsigned integers is due to the fact that currently the Redis protocol is unable to return 64 bit unsigned integers as replies.</p> <h2 id="bits-and-positional-offsets">Bits and positional offsets</h2> <p>There are two ways in order to specify offsets in the bitfield command. If a number without any prefix is specified, it is used just as a zero based bit offset inside the string.</p> <p>However if the offset is prefixed with a <code>#</code> character, the specified offset is multiplied by the integer encoding's width, so for example:</p> <pre>BITFIELD mystring SET i8 #0 100 SET i8 #1 200
</pre> <p>Will set the first i8 integer at offset 0 and the second at offset 8. This way you don't have to do the math yourself inside your client if what you want is a plain array of integers of a given size.</p> <h2 id="overflow-control">Overflow control</h2> <p>Using the <code>OVERFLOW</code> command the user is able to fine-tune the behavior of the increment or decrement overflow (or underflow) by specifying one of the following behaviors:</p> <ul> <li>
<strong>WRAP</strong>: wrap around, both with signed and unsigned integers. In the case of unsigned integers, wrapping is like performing the operation modulo the maximum value the integer can contain (the C standard behavior). With signed integers instead wrapping means that overflows restart towards the most negative value and underflows towards the most positive ones, so for example if an <code>i8</code> integer is set to the value 127, incrementing it by 1 will yield <code>-128</code>.</li> <li>
<strong>SAT</strong>: uses saturation arithmetic, that is, on underflows the value is set to the minimum integer value, and on overflows to the maximum integer value. For example incrementing an <code>i8</code> integer starting from value 120 with an increment of 10, will result into the value 127, and further increments will always keep the value at 127. The same happens on underflows, but towards the value is blocked at the most negative value.</li> <li>
<strong>FAIL</strong>: in this mode no operation is performed on overflows or underflows detected. The corresponding return value is set to NULL to signal the condition to the caller.</li> </ul> <p>Note that each <code>OVERFLOW</code> statement only affects the <code>INCRBY</code> and <code>SET</code> commands that follow it in the list of subcommands, up to the next <code>OVERFLOW</code> statement.</p> <p>By default, <strong>WRAP</strong> is used if not otherwise specified.</p> <pre>&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 1
2) (integer) 1
&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 2
2) (integer) 2
&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 3
2) (integer) 3
&gt; BITFIELD mykey incrby u2 100 1 OVERFLOW SAT incrby u2 102 1
1) (integer) 0
2) (integer) 3
</pre> <h2 id="return-value">Return value</h2> <p>The command returns an array with each entry being the corresponding result of the sub command given at the same position. <code>OVERFLOW</code> subcommands don't count as generating a reply.</p> <p>The following is an example of <code>OVERFLOW FAIL</code> returning NULL.</p> <pre>&gt; BITFIELD mykey OVERFLOW FAIL incrby u2 102 1
1) (nil)
</pre> <h2 id="motivations">Motivations</h2> <p>The motivation for this command is that the ability to store many small integers as a single large bitmap (or segmented over a few keys to avoid having huge keys) is extremely memory efficient, and opens new use cases for Redis to be applied, especially in the field of real time analytics. This use cases are supported by the ability to specify the overflow in a controlled way.</p> <p>Fun fact: Reddit's 2017 April fools' project <a href="https://reddit.com/r/place">r/place</a> was <a href="https://redditblog.com/2017/04/13/how-we-built-rplace/">built using the Redis BITFIELD command</a> in order to take an in-memory representation of the collaborative canvas.</p> <h2 id="performance-considerations">Performance considerations</h2> <p>Usually <code>BITFIELD</code> is a fast command, however note that addressing far bits of currently short strings will trigger an allocation that may be more costly than executing the command on bits already existing.</p> <h2 id="orders-of-bits">Orders of bits</h2> <p>The representation used by <code>BITFIELD</code> considers the bitmap as having the bit number 0 to be the most significant bit of the first byte, and so forth, so for example setting a 5 bits unsigned integer to value 23 at offset 7 into a bitmap previously set to all zeroes, will produce the following representation:</p> <pre>+--------+--------+
|00000001|01110000|
+--------+--------+
</pre> <p>When offsets and integer sizes are aligned to bytes boundaries, this is the same as big endian, however when such alignment does not exist, its important to also understand how the bits inside a byte are ordered.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/bitfield/" class="_attribution-link">https://redis.io/commands/bitfield/</a>
  </p>
</div>
