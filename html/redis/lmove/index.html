<h1 class="command-name">LMOVE</h1>
<pre>LMOVE</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">LMOVE source destination &lt;LEFT | RIGHT&gt; &lt;LEFT | RIGHT&gt;</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available since:</dt> <dd>6.2.0</dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(1)</dd> <dt class="font-semibold text-slate-900">ACL categories:</dt> <dd> <code>@write</code><span class="mr-1 last:hidden">,</span> <code>@list</code><span class="mr-1 last:hidden">,</span> <code>@slow</code><span class="mr-1 last:hidden">,</span> </dd> </dl> <p>Atomically returns and removes the first/last element (head/tail depending on the <code>wherefrom</code> argument) of the list stored at <code>source</code>, and pushes the element at the first/last element (head/tail depending on the <code>whereto</code> argument) of the list stored at <code>destination</code>.</p> <p>For example: consider <code>source</code> holding the list <code>a,b,c</code>, and <code>destination</code> holding the list <code>x,y,z</code>. Executing <code>LMOVE source destination RIGHT LEFT</code> results in <code>source</code> holding <code>a,b</code> and <code>destination</code> holding <code>c,x,y,z</code>.</p> <p>If <code>source</code> does not exist, the value <code>nil</code> is returned and no operation is performed. If <code>source</code> and <code>destination</code> are the same, the operation is equivalent to removing the first/last element from the list and pushing it as first/last element of the list, so it can be considered as a list rotation command (or a no-op if <code>wherefrom</code> is the same as <code>whereto</code>).</p> <p>This command comes in place of the now deprecated <a href="../rpoplpush.html"><code>RPOPLPUSH</code></a>. Doing <code>LMOVE RIGHT LEFT</code> is equivalent.</p> <h2 id="return">Return</h2> <p><a href="https://redis.io/docs/reference/protocol-spec#resp-bulk-strings">Bulk string reply</a>: the element being popped and pushed.</p> <h2 id="examples">Examples</h2>  <pre class="redis-cli overflow-y-auto max-h-80">
RPUSH mylist "one"
RPUSH mylist "two"
RPUSH mylist "three"
LMOVE mylist myotherlist RIGHT LEFT
LMOVE mylist myotherlist LEFT RIGHT
LRANGE mylist 0 -1
LRANGE myotherlist 0 -1
</pre> <h2 id="pattern-reliable-queue">Pattern: Reliable queue</h2> <p>Redis is often used as a messaging server to implement processing of background jobs or other kinds of messaging tasks. A simple form of queue is often obtained pushing values into a list in the producer side, and waiting for this values in the consumer side using <a href="../rpop.html"><code>RPOP</code></a> (using polling), or <a href="../brpop.html"><code>BRPOP</code></a> if the client is better served by a blocking operation.</p> <p>However in this context the obtained queue is not <em>reliable</em> as messages can be lost, for example in the case there is a network problem or if the consumer crashes just after the message is received but it is still to process.</p> <p><code>LMOVE</code> (or <a href="../blmove.html"><code>BLMOVE</code></a> for the blocking variant) offers a way to avoid this problem: the consumer fetches the message and at the same time pushes it into a <em>processing</em> list. It will use the <a href="../lrem.html"><code>LREM</code></a> command in order to remove the message from the <em>processing</em> list once the message has been processed.</p> <p>An additional client may monitor the <em>processing</em> list for items that remain there for too much time, and will push those timed out items into the queue again if needed.</p> <h2 id="pattern-circular-list">Pattern: Circular list</h2> <p>Using <code>LMOVE</code> with the same source and destination key, a client can visit all the elements of an N-elements list, one after the other, in O(N) without transferring the full list from the server to the client using a single <a href="../lrange.html"><code>LRANGE</code></a> operation.</p> <p>The above pattern works even in the following conditions:</p> <ul> <li>There are multiple clients rotating the list: they'll fetch different elements, until all the elements of the list are visited, and the process restarts.</li> <li>Even if other clients are actively pushing new items at the end of the list.</li> </ul> <p>The above makes it very simple to implement a system where a set of items must be processed by N workers continuously as fast as possible. An example is a monitoring system that must check that a set of web sites are reachable, with the smallest delay possible, using a number of parallel workers.</p> <p>Note that this implementation of workers is trivially scalable and reliable, because even if a message is lost the item is still in the queue and will be processed at the next iteration.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/lmove/" class="_attribution-link">https://redis.io/commands/lmove/</a>
  </p>
</div>
