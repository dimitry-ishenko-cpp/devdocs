<h1 class="command-name">TS.INCRBY</h1>
<pre>TS.INCRBY</pre> <div class="font-semibold text-slate-900">Syntax</div> <pre class="command-syntax">TS.INCRBY key value 
  [TIMESTAMP timestamp] 
  [RETENTION retentionPeriod] 
  [UNCOMPRESSED] 
  [CHUNK_SIZE size] 
  [LABELS {label value}...]
</pre> <dl class="grid grid-cols-[auto,1fr] gap-x-2 mb-12"> <dt class="font-semibold text-slate-900">Available in:</dt> <dd> <a href="https://redis.io/docs/stack">Redis Stack</a> / <a href="https://redis.io/docs/stack/timeseries">TimeSeries 1.0.0</a> </dd> <dt class="font-semibold text-slate-900">Time complexity:</dt> <dd>O(M) when M is the amount of compaction rules or O(1) with no compaction</dd> </dl> <p>Increase the value of the sample with the maximum existing timestamp, or create a new sample with a value equal to the value of the sample with the maximum existing timestamp with a given increment</p> <p><a href="#examples">Examples</a></p> <h2 id="required-arguments">Required arguments</h2> <details open><summary><code>key</code></summary> <p>is key name for the time series.</p> </details> <details open><summary><code>value</code></summary> <p>is numeric data value of the sample (double)</p> </details> <p><note><b>Notes</b></note></p> <ul> <li>When specified key does not exist, a new time series is created.</li> <li>You can use this command as a counter or gauge that automatically gets history as a time series.</li> <li>Explicitly adding samples to a compacted time series (using <a href="../ts.add.html"><code>TS.ADD</code></a>, <a href="../ts.madd.html"><code>TS.MADD</code></a>, <code>TS.INCRBY</code>, or <a href="../ts.decrby.html"><code>TS.DECRBY</code></a>) may result in inconsistencies between the raw and the compacted data. The compaction process may override such samples.<br> </li> </ul> <h2 id="optional-arguments">Optional arguments</h2> <details open><summary><code>TIMESTAMP timestamp</code></summary> <p>is (integer) UNIX sample timestamp in milliseconds or <code>*</code> to set the timestamp according to the server clock.</p> <p><code>timestamp</code> must be equal to or higher than the maximum existing timestamp. When equal, the value of the sample with the maximum existing timestamp is increased. If it is higher, a new sample with a timestamp set to <code>timestamp</code> is created, and its value is set to the value of the sample with the maximum existing timestamp plus <code>value</code>.</p> <p>If the time series is empty, the value is set to <code>value</code>.</p> <p>When not specified, the timestamp is set according to the server clock.</p> </details> <details open><summary><code>RETENTION retentionPeriod</code> <p>is maximum retention period, compared to the maximum existing timestamp, in milliseconds. Use it only if you are creating a new time series. It is ignored if you are adding samples to an existing time series. See <code>RETENTION</code> in <a href="../ts.create.html"><code>TS.CREATE</code></a>.</p> </summary></details> <details open><summary><code>UNCOMPRESSED</code></summary> <p>changes data storage from compressed (default) to uncompressed. Use it only if you are creating a new time series. It is ignored if you are adding samples to an existing time series. See <code>ENCODING</code> in <a href="../ts.create.html"><code>TS.CREATE</code></a>.</p> </details> <details open><summary><code>CHUNK_SIZE size</code></summary> <p>is memory size, in bytes, allocated for each data chunk. Use it only if you are creating a new time series. It is ignored if you are adding samples to an existing time series. See <code>CHUNK_SIZE</code> in <a href="../ts.create.html"><code>TS.CREATE</code></a>.</p> </details> <details open><summary><code>LABELS [{label value}...]</code></summary> <p>is set of label-value pairs that represent metadata labels of the key and serve as a secondary index. Use it only if you are creating a new time series. It is ignored if you are adding samples to an existing time series. See <code>LABELS</code> in <a href="../ts.create.html"><code>TS.CREATE</code></a>.</p> </details> <p><note><b>Notes</b></note></p> <ul> <li>You can use this command to add data to a nonexisting time series in a single command. This is why <code>RETENTION</code>, <code>UNCOMPRESSED</code>, <code>CHUNK_SIZE</code>, and <code>LABELS</code> are optional arguments.</li> <li>When specified and the key doesn't exist, a new time series is created. Setting the <code>RETENTION</code> and <code>LABELS</code> introduces additional time complexity. </li> </ul> <h2 id="return-value">Return value</h2> <p><a href="https://redis.io/docs/reference/protocol-spec#resp-integers">Integer reply</a> - the timestamp of the upserted sample, or <a href="https://redis.io/docs/reference/protocol-spec#resp-errors">Error reply</a>.</p> <h2 id="examples">Examples</h2> <details open><summary><b>Store sum of data from several sources</b></summary> <p>Suppose you are getting number of orders or total income per minute from several points of sale, and you want to store only the combined value. Call TS.INCRBY for each point-of-sale report.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; TS.INCRBY a <span class="m">232</span> TIMESTAMP 1657811829000		// point-of-sale <span class="c1">#1</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1657811829000</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; TS.INCRBY a <span class="m">157</span> TIMESTAMP 1657811829000		// point-of-sale <span class="c1">#2</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1657811829000</span>
</span></span><span class="line"><span class="cl">127.0.0.1:6379&gt; TS.INCRBY a <span class="m">432</span> TIMESTAMP 1657811829000		// point-of-sale <span class="c1">#3</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1657811829000</span></span></span></pre></div> <p>Note that the timestamps must arrive in non-decreasing order.</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; ts.incrby a <span class="m">100</span> TIMESTAMP <span class="m">50</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>error<span class="o">)</span> TSDB: timestamp must be equal to or higher than the maximum existing timestamp</span></span></pre></div> <p>You can achieve similar results without such protection using <code>TS.ADD key timestamp value ON_DUPLICATE sum</code>.</p> </details> <details open><summary><b>Count sensor captures</b></summary> <p>Supose a sensor ticks whenever a car is passed on a road, and you want to count occurrences. Whenever you get a tick from the sensor you can simply call:</p> <div class="highlight"><pre tabindex="0" class="chroma"><span class="line"><span class="cl">127.0.0.1:6379&gt; TS.INCRBY a <span class="m">1</span>
</span></span><span class="line"><span class="cl"><span class="o">(</span>integer<span class="o">)</span> <span class="m">1658431553109</span></span></span></pre></div> <p>The timestamp is filled automatically.</p> </details> <h2 id="see-also">See also</h2> <p><a href="../ts.decrby.html"><code>TS.DECRBY</code></a> | <a href="../ts.create.html"><code>TS.CREATE</code></a></p> <h2 id="related-topics">Related topics</h2> <p><a href="https://redis.io/docs/stack/timeseries">RedisTimeSeries</a></p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2006&ndash;2022 Salvatore Sanfilippo<br>Licensed under the Creative Commons Attribution-ShareAlike License 4.0.<br>
    <a href="https://redis.io/commands/ts.incrby/" class="_attribution-link">https://redis.io/commands/ts.incrby/</a>
  </p>
</div>
