<h1>
View Lifecycle</h1>
<p>Both <a href="classes.html"><code>View</code> and <code>CollectionView</code></a> are aware of their lifecycle state which indicates if the view is rendered, attached to the DOM or destroyed.</p> <h2 id="documentation-index">
Documentation Index</h2>
<ul> <li><a href="#view-lifecycle">View Lifecycle</a></li> <li>
<a href="#lifecycle-state-methods">Lifecycle State Methods</a><ul> <li><a href="#isrendered"><code>isRendered()</code></a></li> <li><a href="#isattached"><code>isAttached()</code></a></li> <li><a href="#isdestroyed"><code>isDestroyed()</code></a></li> </ul> </li> <li>
<a href="#instantiating-a-view">Instantiating a View</a><ul> <li><a href="#using-setelement">Using <code>setElement</code></a></li> </ul> </li> <li>
<a href="#rendering-a-view">Rendering a View</a><ul> <li><a href="#view-rendering"><code>View</code> Rendering</a></li> <li><a href="#collectionview-rendering"><code>CollectionView</code> Rendering</a></li> </ul> </li> <li><a href="#rendering-children">Rendering Children</a></li> <li><a href="#attaching-a-view">Attaching a View</a></li> <li><a href="#detaching-a-view">Detaching a View</a></li> <li><a href="#destroying-a-view">Destroying a View</a></li> <li><a href="#rendering-children">Destroying Children</a></li> </ul> <h2 id="lifecycle-state-methods">
Lifecycle State Methods</h2>
<p>Both <code>View</code> and <code>CollectionView</code> share methods for checking lifecycle state.</p> <h3 id="isrendered">
<code>isRendered()</code>
</h3>
<p>Returns a boolean value reflecting if the view is considered rendered.</p> <h3 id="isattached">
<code>isAttached()</code>
</h3>
<p>Returns a boolean value reflecting if the view is considered attached to the DOM.</p> <h3 id="isdestroyed">
<code>isDestroyed()</code>
</h3>
<p>Returns a boolean value reflecting if the view has been destroyed.</p> <h2 id="instantiating-a-view">
Instantiating a View</h2>
<p>Marionette Views are Backbone Views and so when they are instantiated the view has an <code>el</code>. That <code>el</code> will be the root node for the view and other than its contents it will not change for the life of the view unless directly manipulated (ie: <code>view.$el.addClass</code>)</p> <p>The view can be passed an existing <code>el</code> either in the DOM (ie: <code>el: $('.foo-selector')</code>) or in memory (ie: <code>el: $('&lt;div&gt;&lt;/div&gt;')</code>) or most commonly, the view constructs its own <code>el</code> at instantiation as <a href="http://backbonejs.org/#View-el">documented on backbonejs.org</a>.</p> <p>Marionette will determine the initial state of the view as to whether the view is considered already <a href="#rendering-a-view">rendered</a> or <a href="#attaching-a-view">attached</a>. If a view is already rendered or attached its <a href="#lifecycle-state-methods">state</a> will reflect that status, but the <a href="events.class.html#dom-change-events">related events</a> will not have fired.</p> <p>For more information on instanting a view with pre-rendered DOM see: <a href="dom.prerendered.html">Prerendered Content</a>.</p> <h3 id="using-setelement">
Using <code>setElement</code>
</h3>
<p><code>Backbone.View</code> allows the user to change the view's <code>el</code> after instantiaton using <a href="http://backbonejs.org/#View-setElement"><code>setElement</code></a>. This method can be used in Marionette as well, but should be done with caution. <code>setElement</code> will redelegate view events, but it will essentially ignore children of the view, whether through <code>regions</code> or through <code>children</code> and the view's <code>behaviors</code> will also be unaware of the change. It is likely better to reconstuct a new view with the new <code>el</code> than to try to change the <code>el</code> of an existing view.</p> <h2 id="rendering-a-view">
Rendering a View</h2>
<p>In Marionette <a href="view.rendering.html">rendering a view</a> is changing a view's <code>el</code>'s contents.</p> <p>What rendering indicates varies slightly between the two Marionette views.</p> <p><strong>Note</strong> Once a view is considered "rendered" it cannot be unrendered until it is <a href="#destroying-a-view">destroyed</a>.</p> <h3 id="view-rendering">
<code>View</code> Rendering</h3>
<p>For <a href="marionette.view.html"><code>View</code></a>, rendering entails serializing the view's data, passing it to a template, and taking the results of that template and replacing the contents of the view's <code>el</code>. So when a <code>View</code> is instantiated it is considered rendered if the <code>el</code> node contains any content. However after instantiation a template may render empty in which case the <code>View</code> will still be considered "rendered" even though it contains no content.</p> <h3 id="collectionview-rendering">
<code>CollectionView</code> Rendering</h3>
<p>For <a href="marionette.collectionview.html"><code>CollectionView</code></a>, rendering signifies that the view's <a href="marionette.collectionview.html#collectionviews-children"><code>children</code></a> were created and attached to the view's <code>el</code>. So unlike <code>View</code> a <code>CollectionView</code> can be instantiated with content in its <code>el</code>, but until the <code>children</code> are "rendered" the entire view is not considered rendered.</p> <p>Notably if there are no <code>children</code> when rendering, the view will still be considered rendered. This is true whether or not an <a href="marionette.collectionview.html#collectionviews-emptyview"><code>emptyView</code></a> is rendered. So it is possible for a <code>CollectionView</code> to be "rendered" but the <code>el</code> to only be an empty tag. Also note that just like <code>View</code> a <code>CollectionView</code> may have a <code>template</code> which is rendered and attached to the <code>el</code> during the <code>render</code>, but the template rendering itself has no bearing on the status of the <code>CollectionView</code>.</p> <h2 id="rendering-children">
Rendering Children</h2>
<p>Rendering child views is often best accomplish after the view render as typically the first render happens prior to the view entering the DOM. This helps to prevent unnecessary repaints and reflows by making the DOM insert at the highest possible view in the view tree.</p> <p>The exception is views with <a href="dom.prerendered.html">prerendered content</a>. In the case that the view is instantiated rendered, child views are best managed in the view's <a href="common.html#initialize"><code>initialize</code></a>.</p> <h3 id="view-children">
<code>View</code> Children</h3>
<p>In general the best method for adding a child view to a <code>View</code> is to use <a href="marionette.view.html#showing-a-view"><code>showChildView</code></a> in the <a href="events.class.html#render-and-beforerender-events"><code>render</code> event</a>.</p> <p>View regions will be emptied on each render so views shown outside of the <code>render</code> event will still need be reshown on subsequent renders.</p> <h3 id="collectionview-children">
<code>CollectionView</code> Children</h3>
<p>The primary use case for a <code>CollectionView</code> is maintaining child views to match the state of a Backbone Collection. By default children will be added or removed to match the models within the collection. However a <code>CollectionView</code> can have children in addition to, or instead of, views matching the <code>collection</code>.</p> <h4>
Adding managed children</h4>
<p>If you add a view to a <code>CollectionView</code>s children by default it will treat it as any other view added from the <code>collection</code>. This means it is subject to the <a href="marionette.collectionview.html#defining-the-viewcomparator"><code>viewComparator</code></a> and <a href="marionette.collectionview.html#defining-the-viewfilter"><code>viewFilter</code></a>.</p> <p>So if you are accounting for added views in your <code>viewFilter</code> and <code>viewComparator</code> the best place to add these children is likely in the <a href="events.class.html#render-and-beforerender-events"><code>render</code> event</a> as the views will only be added once (or re-added if the children are rebuilt in a subsequent <code>render</code>) and managed in the sort or filter as the <code>collection</code> is updated.</p> <h4>
Adding unmanaged children</h4>
<p>Unlike managed children there may be cases where you want to insert views to the results of the <code>CollectionView</code> after the <code>collection</code> changes, or after sorting and/or filtering. In these cases the solution might depend slightly on the features used on the <code>CollectionView</code>.</p> <p>The goal will be to add the unmanaged views after other views are added and to remove any unmanaged views prior to any managed <code>children</code> changes. To do so you must understand which <a href="events.class.html#collectionview-events"><code>CollectionView</code> event</a> will occur prior to changes to the <code>children</code> for your particular use case. By default a <code>CollectionView</code> sorts according to the <code>collection</code> sort, so unless <code>viewComparator</code> is disabled, the best event for removing unmanaged views is the <a href="events.class.html#sort-and-beforesort-events"><code>before:sort</code> event</a>, but if <code>viewComparator</code> is false the next event to consider is the <a href="events.class.html#filter-and-beforefilter-events"><code>before:filter</code> event</a> if your <code>CollectionView</code> has a <code>viewFilter</code>, otherwise the <a href="events.class.html#renderchildren-and-beforerenderchildren-events"><code>before:render:children</code> event</a> is ideal.</p> <p>Once you have determined the best strategy for removing your unmanaged child views, adding them is best handled in the <a href="events.class.html#renderchildren-and-beforerenderchildren-events"><code>render:children</code> event</a>. Additionally adding a child with <code>addChildView</code> will itself cause these events to occur, so to prevent stack overflows, it is best to use a flag to guard the adds and to insert a new view at a specified index.</p> <p>The following simplistic example will add an unmanaged view at the 5th index and remove it prior to any changes to the <code>children</code>. In a real world scenario it will likely be more complicated to keep track of which view to remove in the <code>onBeforeSort</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { CollectionView } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyCollectionView = CollectionView.extend({
  <span class="hljs-attr">childView</span>: MyChildView,
  onBeforeSort() {
    <span class="hljs-keyword">this</span>.removeChildView(<span class="hljs-keyword">this</span>.children.findByIndex(<span class="hljs-number">5</span>));
  },
  onRenderChildren() {
    <span class="hljs-keyword">this</span>.addFooView();
  },
  addFooView() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.addingFooView) {
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">this</span>.addingFooView = <span class="hljs-literal">true</span>;
    <span class="hljs-keyword">this</span>.addChildView(<span class="hljs-keyword">new</span> FooView(), <span class="hljs-number">5</span>);
    <span class="hljs-keyword">this</span>.addingFooView = <span class="hljs-literal">false</span>;
  }
});
</pre> <h2 id="attaching-a-view">
Attaching a View</h2>
<p>In Marionette a view is attached if the view's <code>el</code> can be found in the DOM. The best time to add listeners to the view's <code>el</code> is likely in the <a href="events.class.html#attach-and-beforeattach-events"><code>attach</code> event</a>.</p> <p>While the <code>el</code> of the view can be attached the contents of the view can be removed and added to during the lifetime of the view. If you are adding listeners to the contents of the view rather than <code>attach</code> the <a href="events.class.html#domrefresh-event"><code>dom:refresh</code> event</a> would be best.</p> <p>The attached state is maintained when attaching a view with a <code>Region</code> or as a child of a <code>CollectionView</code> or during <a href="#instantiating-a-view">view instantiation</a>. If a view is attached by other means like <code>$.append</code> [<code>isAttached</code>] may not reflect the actual state of attachment.</p> <h2 id="detaching-a-view">
Detaching a View</h2>
<p>A view is detached when its <code>el</code> is removed from the DOM. The best time to clean up any listeners added to the <code>el</code> is in the <a href="events.class.html#detach-and-beforedetach-events"><code>before:detach</code> event</a>.</p> <p>While the <code>el</code> of the view may remain attached, its contents will be removed on render. If you have added listeners to the contents of the view rather than <code>before:detach</code> the <a href="events.class.html#domremove-event"><code>dom:remove</code> event</a> would be best.</p> <h2 id="destroying-a-view">
Destroying a View</h2>
<p>Destroying a view (ie: <code>myView.destroy()</code>) cleans up anything constucted within Marionette so that if a view's instance is no longer referenced the view can be cleaned up by the browser's garbage collector.</p> <p>The <a href="events.class.html#destroy-and-beforedestroy-events"><code>before:destroy</code> event</a> is the best place to clean up any added listeners not related to the view's DOM.</p> <p>The state of the view after the destroy is not attached and not rendered although the <code>el</code> is not emptied.</p> <h2 id="destroying-children">
Destroying Children</h2>
<p>Children added to a <code>View</code>'s region or through a <code>CollectionView</code> will be automatically destroyed if the view is re-rendered, if the view is destroyed, or for <code>CollectionView</code> if the <code>collection</code> is reset.</p> <p><strong>Note</strong> Children are removed after the DOM detach of the parent to prevent multiple reflows or repaints.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Muted Solutions, LLC<br>Licensed under the MIT License.<br>
    <a href="https://marionettejs.com/docs/v4.0.0/view.lifecycle.html" class="_attribution-link">https://marionettejs.com/docs/v4.0.0/view.lifecycle.html</a>
  </p>
</div>
