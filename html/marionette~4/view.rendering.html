<h1>
View Template Rendering</h1>
<p>Unlike <a href="http://backbonejs.org/#View-template"><code>Backbone.View</code></a>, <a href="classes.html">Marionette views</a> provide a customizable solution for rendering a template with data and placing the results in the DOM.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">tagName</span>: <span class="hljs-string">'h1'</span>,
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'Contents'</span>)
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView();
myView.render();
</pre> <p>In the above example the contents of the <code>template</code> attribute will be rendered inside a <code>&lt;h1&gt;</code> tag available at <code>myView.el</code>.</p> <p><a href="https://jsfiddle.net/marionettejs/h762zjua/" class="btn btn-action">Live example</a></p> <h2 id="documentation-index">
Documentation Index</h2>
<ul> <li><a href="#what-is-a-template">What is a template</a></li> <li>
<a href="#setting-a-view-template">Setting a View Template</a><ul> <li><a href="#using-a-view-without-a-template">Using a View Without a Template</a></li> </ul> </li> <li>
<a href="#rendering-the-template">Rendering the Template</a><ul> <li><a href="#using-a-custom-renderer">Using a Custom Renderer</a></li> <li><a href="#rendering-to-html">Rendering to HTML</a></li> <li><a href="#rendering-to-dom">Rendering to DOM</a></li> </ul> </li> <li>
<a href="#serializing-data">Serializing Data</a><ul> <li><a href="#serializing-a-model">Serializing a Model</a></li> <li><a href="#serializing-a-collection">Serializing a Collection</a></li> <li><a href="#serializing-with-a-collectionview">Serializing with a <code>CollectionView</code></a></li> </ul> </li> <li>
<a href="#adding-context-data">Adding Context Data</a><ul> <li><a href="#what-is-context-data">What is Context Data?</a></li> </ul> </li> </ul> <h2 id="what-is-a-template">
What is a template?</h2>
<p>A template is a function that given data returns either an HTML string or DOM. <a href="#rendering-the-template">The default renderer</a> in Marionette expects the template to return an HTML string. Marionette's dependency Underscore comes with an HTML string <a href="http://underscorejs.org/#template">template compiler</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'&lt;h1&gt;Hello, world&lt;/h1&gt;'</span>)
});
</pre> <p>This doesn't have to be an underscore template, you can pass your own rendering function:</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> Handlebars <span class="hljs-keyword">from</span> <span class="hljs-string">'handlebars'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: Handlebars.compile(<span class="hljs-string">'&lt;h1&gt;Hello, {{ name }}'</span>)
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/ep0e4qkt/" class="btn btn-action">Live example</a></p> <h2 id="setting-a-view-template">
Setting a View Template</h2>
<p>Marionette views use the <code>getTemplate</code> method to determine which template to use for rendering into its <code>el</code>. By default <code>getTemplate</code> is predefined on the view as simply:</p> <pre data-language="javascript">getTemplate() {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.template
}
</pre> <p>In most cases by using the default <code>getTemplate</code> you can simply set the <code>template</code> on the view to define the view's template, but in some circumstances you may want to set the template conditionally.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'Hello World!'</span>),
  getTemplate() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.model.has(<span class="hljs-string">'user'</span>)) {
      <span class="hljs-keyword">return</span> _.template(<span class="hljs-string">'Hello User!'</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.template;
  }
});
</pre> <p><a href="https://jsfiddle.net/marionettejs/9k5v4p92/" class="btn btn-action">Live example</a></p> <h3 id="using-a-view-without-a-template">
Using a View Without a Template</h3>
<p>By default <code>CollectionView</code> has no defined <code>template</code> and will only attempt to render the <code>template</code> if one is defined. For <code>View</code> there may be some situations where you do not intend to use a <code>template</code>. Perhaps you only need the view's <code>el</code> or you are using <a href="dom.prerendered.html">prerendered content</a>.</p> <p>In this case setting <code>template</code> to <code>false</code> will prevent the template render. In the case of <code>View</code> it will also prevent the <a href="events.class.html#render-and-beforerender-events"><code>render</code> events</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyIconButtonView = View.extend({
  <span class="hljs-attr">template</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">tagName</span>: <span class="hljs-string">'button'</span>,
  <span class="hljs-attr">className</span>: <span class="hljs-string">'.icon-button'</span>,
  <span class="hljs-attr">triggers</span>: {
    <span class="hljs-string">'click'</span>: <span class="hljs-string">'click'</span>
  },
  onRender() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'You will never see me!'</span>);
  }
});
</pre> <h2 id="rendering-the-template">
Rendering the Template</h2>
<p>Each view class has a renderer which by default passes the <a href="#serializing-data">view data</a> to the template function and returns the html string it generates.</p> <p>The current default renderer is essentially the following:</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { View, CollectionView } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderer</span>(<span class="hljs-params">template, data</span>) </span>{
  <span class="hljs-keyword">return</span> template(data);
}

View.setRenderer(renderer);
CollectionView.setRenderer(renderer);
</pre> <p>Previous to Marionette v4 the default renderer was the <code>TemplateCache</code>. This renderer has been extracted to a separate library: <a href="https://github.com/marionettejs/marionette.templatecache">https://github.com/marionettejs/marionette.templatecache</a> and can be used with v4.</p> <h3 id="using-a-custom-renderer">
Using a Custom Renderer</h3>
<p>You can set the renderer for a view class by using the class method <code>setRenderer</code>. The renderer accepts two arguments. The first is the template passed to the view, and the second argument is the data to be rendered into the template.</p> <p>Here's an example that allows for the <code>template</code> of a view to be an underscore template string.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

View.setRenderer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">template, data</span>) </span>{
  <span class="hljs-keyword">return</span> _.template(template)(data);
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> View({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'Hello &lt;%- name %&gt;!'</span>,
  <span class="hljs-attr">model</span>: <span class="hljs-keyword">new</span> Backbone.Model({ <span class="hljs-attr">name</span>: <span class="hljs-string">'World'</span> })
});

myView.render();

<span class="hljs-comment">// myView.el is &lt;div&gt;Hello World!&lt;/div&gt;</span>
</pre> <p>The renderer can also be customized separately on any extended View.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> MyHBSView = View.extend();

<span class="hljs-comment">// Similar example as above but for handlebars</span>
MyHBSView.setRenderer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">template, data</span>) </span>{
  <span class="hljs-keyword">return</span> Handlebars.compile(template)(data);
});

<span class="hljs-keyword">const</span> myHBSView = <span class="hljs-keyword">new</span> MyHBSView({
  <span class="hljs-attr">template</span>: <span class="hljs-string">'Hello {{ name }}!'</span>,
  <span class="hljs-attr">model</span>: <span class="hljs-keyword">new</span> Backbone.Model({ <span class="hljs-attr">name</span>: <span class="hljs-string">'World'</span> })
});

myHBSView.render();

<span class="hljs-comment">// myView.el is &lt;div&gt;Hello World!&lt;/div&gt;</span>
</pre> <p><strong>Note</strong> These examples while functional may not be ideal. If possible it is recommend to precompile your templates which can be done for a number of templating using various plugins for bundling tools such as <a href="installation.html">Browserify or Webpack</a>.</p> <h3 id="rendering-to-html">
Rendering to HTML</h3>
<p>The default Marionette renders return the HTML as a string. This string is passed to the view's <code>attachElContents</code> method which in turn uses the DOM API's <a href="dom.api.html#setcontentsel-html"><code>setContents</code></a>. to set the contents of the view's <code>el</code> with DOM from the string.</p> <h4>
Customizing <code>attachElContents</code>
</h4>
<p>You can modify the way any particular view attaches a compiled template to the <code>el</code> by overriding <code>attachElContents</code>. This method receives only the results of the view's renderer and is only called if the renderer returned a value.</p> <p>For instance, perhaps for one particular view you need to bypass the <a href="dom.api.html">DOM API</a> and set the html directly:</p> <pre data-language="javascript">attachElContent(html) {
  <span class="hljs-keyword">this</span>.el.innerHTML = html;
}
</pre> <h3 id="rendering-to-dom">
Rendering to DOM</h3>
<p>Marionette also supports templates that render to DOM instead of html strings by using a custom render.</p> <p>In the following example the <code>template</code> method passed to the renderer will return a DOM element, and then if the view is already rendered utilize <a href="https://github.com/patrick-steele-idem/morphdom">morphdom</a> to patch the DOM or otherwise it will set the view's <code>el</code> to the result of the template. (Note in this case the view's <code>el</code> created at instantiation would be overridden).</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> morphdom <span class="hljs-keyword">from</span> <span class="hljs-string">'morphdom'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> VDomView = View.extend();

VDomView.setRenderer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">template, data</span>) </span>{
  <span class="hljs-keyword">const</span> el = template(data);

  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isRendered()) {
    <span class="hljs-comment">// Patch the view's el contents in the DOM</span>
    morphdom(<span class="hljs-keyword">this</span>.el, el, { <span class="hljs-attr">childrenOnly</span>: <span class="hljs-literal">true</span> });
    <span class="hljs-keyword">return</span>;
  }

  <span class="hljs-keyword">this</span>.setElement(el.cloneNode(<span class="hljs-literal">true</span>));
});
</pre> <p>In this case because the renderer is modifying the <code>el</code> directly, there is no need to return the result of the template rendering for the view to handle in <a href="#customizing-attachelcontents"><code>attachElContents</code></a>. It is certainly an option to return the compiled DOM and modify <a href="#customizing-attachelcontents"><code>attachElContents</code></a> to handle a DOM object instead of a string literal, but in many cases it may be overcomplicated to do so.</p> <p>There are a variety of possibilities for rendering with Marionette. If you are looking into alternatives from the default this may be a useful resource: <a href="https://github.com/blikblum/marionette.renderers#renderers">https://github.com/blikblum/marionette.renderers#renderers</a></p> <h2 id="serializing-data">
Serializing Data</h2>
<p>Marionette will automatically serialize the data from its <code>model</code> or <code>collection</code> for the template to use at <a href="#rendering-the-template">rendering</a>. You can override this logic and provide serialization of other data with the <code>serializeData</code> method. The method is called with no arguments, but has the context of the view and should return a javascript object for the template to consume. If <code>serializeData</code> does not return data the template may still receive <a href="#adding-context-data">added context</a> or an empty object for rendering.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">`
    &lt;div&gt;&lt;% user.name %&gt;&lt;/div&gt;
    &lt;ul&gt;
    &lt;% _.each(groups, function(group) { %&gt;
      &lt;li&gt;&lt;%- group.name %&gt;&lt;/li&gt;
    &lt;% }) %&gt;
    &lt;/ul&gt;
  `</span>),
  serializeData() {
    <span class="hljs-comment">// For this view I need both the</span>
    <span class="hljs-comment">// model and collection serialized</span>
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">user</span>: <span class="hljs-keyword">this</span>.serializeModel(),
      <span class="hljs-attr">groups</span>: <span class="hljs-keyword">this</span>.serializeCollection(),
    };
  }
});
</pre> <p><strong>Note</strong> You should not use this method to add arbitrary extra data to your template. Instead use <code>templateContext</code> to <a href="#adding-context-data">add context data to your template</a>.</p> <h3 id="serializing-a-model">
Serializing a Model</h3>
<p>If the view has a <code>model</code> it will pass that model's attributes to the template.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> Backbone <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyModel = Backbone.Model.extend({
  <span class="hljs-attr">defaults</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'world'</span>
  }
});

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'&lt;h1&gt;Hello, &lt;%- name %&gt;&lt;/h1&gt;'</span>)
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView({ <span class="hljs-attr">model</span>: <span class="hljs-keyword">new</span> MyModel() });
</pre> <p><a href="https://jsfiddle.net/marionettejs/warfa6rL/" class="btn btn-action">Live example</a></p> <p>How the <code>model</code> is serialized can also be customized per view.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  serializeModel() {
    <span class="hljs-keyword">const</span> data = _.clone(<span class="hljs-keyword">this</span>.model.attributes);

    <span class="hljs-comment">// serialize nested model data</span>
    data.sub_model = data.sub_model.attributes;

    <span class="hljs-keyword">return</span> data;
  }
});
</pre> <h3 id="serializing-a-collection">
Serializing a Collection</h3>
<p>If the view does not have a <code>model</code> but has a <code>collection</code> the collection's models will be serialized to an array provided as an <code>items</code> attribute to the template.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> Backbone <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">`
    &lt;ul&gt;
    &lt;% _.each(items, function(item) { %&gt;
      &lt;li&gt;&lt;%- item.name %&gt;&lt;/li&gt;
    &lt;% }) %&gt;
    &lt;/ul&gt;
  `</span>)
});

<span class="hljs-keyword">const</span> collection = <span class="hljs-keyword">new</span> Backbone.Collection([
  {<span class="hljs-attr">name</span>: <span class="hljs-string">'Steve'</span>}, {<span class="hljs-attr">name</span>: <span class="hljs-string">'Helen'</span>}
]);

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView({ collection });
</pre> <p><a href="https://jsfiddle.net/marionettejs/qyodkakf/" class="btn btn-action">Live example</a></p> <p>How the <code>collection</code> is serialized can also be customized per view.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  serializeCollection() {
    <span class="hljs-keyword">return</span> _.map(<span class="hljs-keyword">this</span>.collection.models, model =&gt; {
      <span class="hljs-keyword">const</span> data = _.clone(model.attributes);

      <span class="hljs-comment">// serialize nested model data</span>
      data.sub_model = data.sub_model.attributes;

      <span class="hljs-keyword">return</span> data;
    });
  }
});
</pre> <h3 id="serializing-with-a-collectionview">
Serializing with a <code>CollectionView</code>
</h3>
<p>if you are using a <code>template</code> with a <code>CollectionView</code> that is not also given a <code>model</code>, your <code>CollectionView</code> will <a href="serializing-a-collection.html">serialize the collection</a> for the template. This could be costly and unnecessary. If your <code>CollectionView</code> has a <code>template</code> it is advised to either use an empty <code>model</code> or override the <a href="#serializing-data"><code>serializeData</code></a> method.</p> <h2 id="adding-context-data">
Adding Context Data</h2>
<p>Marionette views provide a <code>templateContext</code> attribute that is used to add extra information to your templates. This can be either an object, or a function returning an object. The keys on the returned object will be mixed into the model or collection keys and made available to the template.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'&lt;h1&gt;Hello, &lt;%- name %&gt;&lt;/h1&gt;'</span>),
  <span class="hljs-attr">templateContext</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">'World'</span>
  }
});
</pre> <p>Additionally context data overwrites the serialized data</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'&lt;h1&gt;Hello, &lt;%- name %&gt;&lt;/h1&gt;'</span>),
  templateContext() {
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">name</span>: <span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'name'</span>).toUpperCase()
    };
  }
});
</pre> <p>You can also define a template context value as a method. How this method is called is determined by your templating solution. For instance with handlebars a method is called with the context of the data passed to the template.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> Handlebars <span class="hljs-keyword">from</span> <span class="hljs-string">'handlebars'</span>;
<span class="hljs-keyword">import</span> Backbone <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone'</span>;
<span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: Handlebars.compile(<span class="hljs-string">`
    &lt;h1{{#if isDr}} class="dr"{{/if}}&gt;Hello {{ fullName }}&lt;/h1&gt;,
  `</span>),
  <span class="hljs-attr">templateContext</span>: {
    isDr() {
      <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.degree) === <span class="hljs-string">'phd'</span>;
    },
    fullName() {
      <span class="hljs-comment">// Because of Handlebars `this` here is the data object</span>
      <span class="hljs-comment">// passed to the template which is the result of the</span>
      <span class="hljs-comment">// templateContext mixed with the serialized data of the view</span>
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.isDr() ? <span class="hljs-string">`Dr. { this.name }`</span> : <span class="hljs-keyword">this</span>.name;
    }
  }
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView({
  <span class="hljs-attr">model</span>: <span class="hljs-keyword">new</span> Backbone.Model({ <span class="hljs-attr">degree</span>: <span class="hljs-string">'masters'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Joe'</span> });
});
</pre> <p><strong>Note</strong> the data object passed to the template is not deeply cloned and in some cases is not cloned at all. Take caution when modifying the data passed to the template, that you are not also modifying your model's data indirectly.</p> <h3 id="what-is-context-data">
What is Context Data?</h3>
<p>While <a href="#serializing-data">serializing data</a> deals more with getting the data belonging to the view into the template, template context mixes in other needed data, or in some cases, might do extra computations that go beyond simply "serializing" the view's <code>model</code> or <code>collection</code></p> <pre data-language="javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'underscore'</span>
<span class="hljs-keyword">import</span> { CollectionView } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;
<span class="hljs-keyword">import</span> GroupView <span class="hljs-keyword">from</span> <span class="hljs-string">'./group-view'</span>;

<span class="hljs-keyword">const</span> MyCollectionView = CollectionView.extend({
  <span class="hljs-attr">tagName</span>: <span class="hljs-string">'div'</span>,
  <span class="hljs-attr">childViewContainer</span>: <span class="hljs-string">'ul'</span>,
  <span class="hljs-attr">childView</span>: GroupView,
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">`
    &lt;h1&gt;Hello &lt;% name %&gt; of &lt;% orgName %&gt;&lt;/h1&gt;
    &lt;div&gt;You have &lt;% stats.public %&gt; group(s).&lt;/div&gt;
    &lt;div&gt;You have &lt;% stats.private %&gt; group(s).&lt;/div&gt;
    &lt;h3&gt;Groups:&lt;/h3&gt;
    &lt;ul&gt;&lt;/ul&gt;
  `</span>),
  templateContext() {
    <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">this</span>.model;
    <span class="hljs-keyword">const</span> organization = user.getOrganization();
    <span class="hljs-keyword">const</span> groups = <span class="hljs-keyword">this</span>.collection;

    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">orgName</span>: organization.get(<span class="hljs-string">'name'</span>),
      <span class="hljs-attr">name</span>: user.getFullName(),
      <span class="hljs-attr">stats</span>: groups.countBy(<span class="hljs-string">'type'</span>)
    };
  }
})
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Muted Solutions, LLC<br>Licensed under the MIT License.<br>
    <a href="https://marionettejs.com/docs/v4.0.0/view.rendering.html" class="_attribution-link">https://marionettejs.com/docs/v4.0.0/view.rendering.html</a>
  </p>
</div>
