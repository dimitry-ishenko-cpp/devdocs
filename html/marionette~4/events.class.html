<h1>
Class Events</h1>
<p>Marionette uses <a href="events.html#triggermethod"><code>triggerMethod</code></a> internally to trigger various events used within the <a href="classes.html">classes</a>. This provides <a href="events.html#onevent-binding">'onEvent' binding</a> providing convenient hooks for handling class events. Notably all internally triggered events will pass the triggering class instance as the first argument of the event.</p> <h2 id="documentation-index">
Documentation Index</h2>
<ul> <li>
<a href="#application-events">Application Events</a><ul> <li><a href="#before-start-event"><code>before:start</code> event</a></li> <li><a href="#start-event"><code>start</code> event</a></li> </ul> </li> <li>
<a href="#behavior-events">Behavior Events</a><ul> <li><a href="#initialize-event"><code>initialize</code> event</a></li> <li><a href="#proxied-events">Proxied Events</a></li> </ul> </li> <li>
<a href="#region-events">Region Events</a><ul> <li><a href="#show-and-beforeshow-events"><code>show</code> and <code>before:show</code> events</a></li> <li><a href="#empty-and-beforeempty-events"><code>empty</code> and <code>before:empty</code> events</a></li> </ul> </li> <li><a href="#mnobject-events">MnObject Events</a></li> <li>
<a href="#view-events">View Events</a><ul> <li><a href="#addregion-and-beforeaddregion-events"><code>add:region</code> and <code>before:add:region</code> events</a></li> <li><a href="#removeregion-and-beforeremoveregion-events"><code>remove:region</code> and <code>before:remove:region</code> events</a></li> </ul> </li> <li>
<a href="#collectionview-events">CollectionView Events</a><ul> <li><a href="#addchild-and-beforeaddchild-events"><code>add:child</code> and <code>before:add:child</code> events</a></li> <li><a href="#removechild-and-beforeremovechild-events"><code>remove:child</code> and <code>before:remove:child</code> events</a></li> <li><a href="#sort-and-beforesort-events"><code>sort</code> and <code>before:sort</code> events</a></li> <li><a href="#filter-and-beforefilter-events"><code>filter</code> and <code>before:filter</code> events</a></li> <li><a href="#renderchildren-and-beforerenderchildren-events"><code>render:children</code> and <code>before:render:children</code> events</a></li> <li><a href="#destroychildren-and-beforedestroychildren-events"><code>destroy:children</code> and <code>before:destroy:children</code> events</a></li> <li><a href="#collectionview-emptyview-region-events">CollectionView EmptyView Region Events</a></li> </ul> </li> <li>
<a href="#dom-change-events">DOM Change Events</a><ul> <li><a href="#render-and-beforerender-events"><code>render</code> and <code>before:render</code> events</a></li> <li><a href="#attach-and-beforeattach-events"><code>attach</code> and <code>before:attach</code> events</a></li> <li><a href="#detach-and-beforedetach-events"><code>detach</code> and <code>before:detach</code> events</a></li> <li><a href="#domrefresh-event"><code>dom:refresh</code> event</a></li> <li><a href="#domremove-event"><code>dom:remove</code> event</a></li> <li><a href="#advanced-event-settings">Advanced Event Settings</a></li> </ul> </li> <li>
<a href="#destroy-events">Destroy Events</a><ul> <li><a href="#destroy-and-beforedestroy-events"><code>destroy</code> and <code>before:destroy</code> events</a></li> </ul> </li> <li>
<a href="#supporting-backbone-views">Supporting Backbone Views</a><ul> <li><a href="#marionetteevents-and-triggermethod"><code>Marionette.Events</code> and <code>triggerMethod</code></a></li> <li><a href="#lifecycle-events">Lifecycle Events</a></li> </ul> </li> </ul> <h2 id="application-events">
Application Events</h2>
<p>The <code>Application</code> object will fire two events:</p> <h3 id="beforestart-event">
<code>before:start</code> event</h3>
<p>Fired just before the application is started. Use this to prepare the application with anything it will need to start, for example instantiating routers, models, and collections.</p> <h3 id="start-event">
<code>start</code> event</h3>
<p>Fired as part of the application startup. This is where you should be showing your views and starting <code>Backbone.history</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> Bb <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone'</span>;
<span class="hljs-keyword">import</span> { Application } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">import</span> MyModel <span class="hljs-keyword">from</span> <span class="hljs-string">'./mymodel'</span>;
<span class="hljs-keyword">import</span> MyView <span class="hljs-keyword">from</span> <span class="hljs-string">'./myview'</span>;

<span class="hljs-keyword">const</span> MyApp = Application.extend({
  <span class="hljs-attr">region</span>: <span class="hljs-string">'#root-element'</span>,

  initialize(options) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Initialize'</span> + options.foo);
  },

  onBeforeStart(app, options) {
    <span class="hljs-keyword">this</span>.model = <span class="hljs-keyword">new</span> MyModel(options.data);
  },

  onStart(app, options) {
    <span class="hljs-keyword">this</span>.showView(<span class="hljs-keyword">new</span> MyView({<span class="hljs-attr">model</span>: <span class="hljs-keyword">this</span>.model}));
    Bb.history.start();
  }
});

<span class="hljs-keyword">const</span> myApp = <span class="hljs-keyword">new</span> MyApp({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'My App'</span> });
myApp.start({ <span class="hljs-attr">data</span>: { <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span> } });
</pre> <p><a href="https://jsfiddle.net/marionettejs/ny59rs7b/" class="btn btn-action">Live example</a></p> <p>As shown the <code>options</code> object is passed into the <code>Application</code> as the second argument to <code>start</code>.</p> <h4>
Application <code>destroy</code> events</h4>
<p>The <code>Application</code> class also triggers <a href="#destroy-and-beforedestroy-events">Destroy Events</a>.</p> <h2 id="behavior-events">
Behavior Events</h2>
<h3 id="initialize-event">
<code>initialize</code> event</h3>
<p>After the view and behavior are <a href="marionette.behavior.html#events--initialize-order">constructed and initialized</a>, the last event to occur is an <code>initialize</code> event on the behavior which is passed the view instance and any options passed to the view at instantiation.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { Behavior, View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyBehavior = Behavior.extend({
  onInitialize(view, options) {
    <span class="hljs-built_in">console</span>.log(options.msg);
  }
});

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">behaviors</span>: [MyBehavior]
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView({ <span class="hljs-attr">msg</span>: <span class="hljs-string">'view initialized'</span> });
</pre> <p><strong>Note</strong> This event is unique in that the triggering class instance (the view) is not the same instance as the handler (the behavior). In most cases internally triggered events are triggered and handled by the same instance, but this is an exception.</p> <h3 id="proxied-events">
Proxied Events</h3>
<p>A <code>Behavior</code>'s view events <a href="marionette.behavior.html#proxy-handlers">are proxied directly on the behavior</a>.</p> <p><strong>Note</strong> In order to prevent conflict <code>Behavior</code> does not trigger <a href="#destroy-and-beforedestroy-events">destroy events</a> with its own destruction. A <code>destroy</code> event occurring on the <code>Behavior</code> will have originated from the related view.</p> <h2 id="region-events">
Region Events</h2>
<p>When you show a view inside a region - either using <a href="marionette.region.html#showing-a-view"><code>region.show(view)</code></a> or <a href="marionette.view.html#showing-a-view"><code>showChildView('region', view)</code></a> - the <code>Region</code> will emit events around the view events that you can hook into.</p> <p>The <code>Region</code> class also triggers <a href="#destroy-and-beforedestroy-events">Destroy Events</a>.</p> <h3 id="show-and-beforeshow-events">
<code>show</code> and <code>before:show</code> events</h3>
<p>These events fire before (<code>before:show</code>) and after (<code>show</code>) showing anything in a region. A view may or may not be rendered during <code>before:show</code>, but a view will be rendered by <code>show</code>.</p> <p>The <code>show</code> events will receive the region instance, the view being shown, and any options passed to <code>region.show</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { Region, View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyRegion = Region.extend({
  onBeforeShow(myRegion, view, options) {
    <span class="hljs-built_in">console</span>.log(myRegion.hasView()); <span class="hljs-comment">//false</span>
    <span class="hljs-built_in">console</span>.log(view.isRendered()); <span class="hljs-comment">// false</span>
    <span class="hljs-built_in">console</span>.log(options.foo === <span class="hljs-string">'bar'</span>); <span class="hljs-comment">// true</span>
  },
  onShow(myRegion, view, options) {
    <span class="hljs-built_in">console</span>.log(myRegion.hasView()); <span class="hljs-comment">//true</span>
    <span class="hljs-built_in">console</span>.log(view.isRendered()); <span class="hljs-comment">// true</span>
    <span class="hljs-built_in">console</span>.log(options.foo === <span class="hljs-string">'bar'</span>); <span class="hljs-comment">// true</span>
  }
});

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'hello'</span>)
});

<span class="hljs-keyword">const</span> myRegion = <span class="hljs-keyword">new</span> MyRegion({ <span class="hljs-attr">el</span>: <span class="hljs-string">'#dom-hook'</span> });

myRegion.show(<span class="hljs-keyword">new</span> MyView(), { <span class="hljs-attr">foo</span>: <span class="hljs-string">'bar'</span> });
</pre> <h3 id="empty-and-beforeempty-events">
<code>empty</code> and <code>before:empty</code> events</h3>
<p>These events fire before (<code>before:empty</code>) and after (<code>empty</code>) emptying a region's view. These events will not fire if there is no view in the region, even if the region detaches DOM from within the region's <code>el</code>. The view will not be detached or destroyed during <code>before:empty</code>, but will be detached or destroyed during the <code>empty</code>.</p> <p>The empty events will receive the region instance, the view leaving the region.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { Region, View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyRegion = Region.extend({
  onBeforeEmpty(myRegion, view) {
    <span class="hljs-built_in">console</span>.log(myRegion.hasView()); <span class="hljs-comment">//true</span>
    <span class="hljs-built_in">console</span>.log(view.isDestroyed()); <span class="hljs-comment">// false</span>
  },
  onEmpty(myRegion, view) {
    <span class="hljs-built_in">console</span>.log(myRegion.hasView()); <span class="hljs-comment">//false</span>
    <span class="hljs-built_in">console</span>.log(view.isDestroyed()); <span class="hljs-comment">// true</span>
  }
});

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'hello'</span>)
});

<span class="hljs-keyword">const</span> myRegion = <span class="hljs-keyword">new</span> MyRegion({ <span class="hljs-attr">el</span>: <span class="hljs-string">'#dom-hook'</span> });

myRegion.empty(); <span class="hljs-comment">// no events, no view emptied</span>

myRegion.show(<span class="hljs-keyword">new</span> MyView());

myRegion.empty();
</pre> <h2 id="mnobject-events">
MnObject Events</h2>
<p>The <code>MnObject</code> class triggers <a href="#destroy-and-beforedestroy-events">Destroy Events</a>.</p> <h2 id="view-events">
View Events</h2>
<h3 id="addregion-and-beforeaddregion-events">
<code>add:region</code> and <code>before:add:region</code> events</h3>
<p>These events fire before (<code>before:add:region</code>) and after (<code>add:region</code>) a region is added to a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region is fully instantated for both events.</p> <h3 id="removeregion-and-beforeremoveregion-events">
<code>remove:region</code> and <code>before:remove:region</code> events</h3>
<p>These events fire before (<code>before:remove:region</code>) and after (<code>remove:region</code>) a region is removed from a view. This event handler will receive the view instance, the region name string, and the region instance as event arguments. The region will be not be destroyed in the before event, but is destroyed by <code>remove:region</code>.</p> <p><strong>Note</strong> Currently these events are only triggered using the <code>view.removeRegion</code> API and not when the region is destroyed directly. <a href="https://github.com/marionettejs/backbone.marionette/issues/3602">https://github.com/marionettejs/backbone.marionette/issues/3602</a></p> <h2 id="collectionview-events">
CollectionView Events</h2>
<p>The <code>CollectionView</code> triggers unique events specifically related to child management.</p> <h3 id="addchild-and-beforeaddchild-events">
<code>add:child</code> and <code>before:add:child</code> events</h3>
<p>These events fire before (<code>before:add:child</code>) and after (<code>add:child</code>) each child view is instantiated and added to the <a href="collectionview.html#collectionviews-children"><code>children</code></a>. These will fire once for each item in the attached collection or for any view added using <a href="collectionview.html#adding-a-child-view"><code>addChildView</code></a>.</p> <h3 id="removechild-and-beforeremovechild-events">
<code>remove:child</code> and <code>before:remove:child</code> events</h3>
<p>These events fire before (<code>before:remove:child</code>) and after (<code>remove:child</code>) each child view is removed to the <a href="collectionview.html#collectionviews-children"><code>children</code></a>. A view may be removed from the <code>children</code> if it is destroyed, if it is removed from the <code>collection</code> or if it is removed with <a href="collectionview.html#removing-a-child-view"><code>removeChildView</code></a>.</p> <p><strong>NOTE</strong> A childview may or may not be destroyed by this point.</p> <p><strong>NOTE</strong> When a <code>CollectionView</code> is destroyed it will not individually remove its <code>children</code>. Each childview will be destroyed, but any needed clean up during the <code>CollectionView</code>'s destruction should happen in <a href="#destroychildren-and-beforedestroychildren-events"><code>before:destroy:children</code></a>.</p> <h3 id="sort-and-beforesort-events">
<code>sort</code> and <code>before:sort</code> events</h3>
<p>These events fire before (<code>before:sort</code>) and after (<code>sort</code>) sorting the children in the <code>CollectionView</code>. These events will only fire if there are <a href="collectionview.html#collectionviews-children"><code>children</code></a> and a <a href="collectionview.html#defining-the-viewcomparator"><code>viewComparator</code></a></p> <h3 id="filter-and-beforefilter-events">
<code>filter</code> and <code>before:filter</code> events</h3>
<p>These events fire before (<code>before:filter</code>) and after (<code>filter</code>) filtering the children in the <code>CollectionView</code>. This event will only fire if there are <a href="collectionview.html#collectionviews-children"><code>children</code></a> and a <a href="collectionview.html#defining-the-viewfilter"><code>viewFilter</code></a>.</p> <p>When the <code>filter</code> event is fired the children filtered out will have already been detached from the view's <code>el</code>, but new children will not yet have been rendered. The <code>filter</code> event not only receives the view instance, but also arrays of attached views, and detached views.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> MyCollectionView = CollectionView.extend({
  onBeforeFilter(myCollectionView) {
   <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Nothing has changed yet!'</span>);
  },
  onFilter(myCollectionView, attachViews, detachedView) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Array of attached views'</span>, attachedView);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Array of detached views'</span>, attachedView);
  }
});
</pre> <h3 id="renderchildren-and-beforerenderchildren-events">
<code>render:children</code> and <code>before:render:children</code> events</h3>
<p>Similar to <a href="#show-and-beforeshow-events"><code>Region</code> <code>show</code> and <code>before:show</code> events</a> these events fire before (<code>before:render:children</code>) and after (<code>render:children</code>) the <code>children</code> of the <code>CollectionView</code> are attached to the <code>CollectionView</code>'s <code>el</code> or <code>childViewContainer</code>.</p> <p>These events will be passed the <code>CollectionView</code> instance and the array of views being attached. The views in the array may or may not be rendered or attached for <code>before:render:children</code>, but will be rendered and attached by <code>render:children</code>.</p> <p>If the <code>CollectionView</code> can determine that added views will only be appended to the end, only the appended views will be passed to the event. Otherwise all of the <code>children</code> views will be passed.</p> <p><strong>Note</strong> if you consistently need all of the views within this event use <a href="marionette.collectionview.html#collectionviews-children"><code>children</code></a></p> <h3 id="destroychildren-and-beforedestroychildren-events">
<code>destroy:children</code> and <code>before:destroy:children</code> events</h3>
<p>These events fire before (<code>before:destroy:children</code>) and after (<code>destroy:children</code>) destroying the children in the <code>CollectionView</code>. These events will only fire if there are <a href="collectionview.html#collectionviews-children"><code>children</code></a>.</p> <h3 id="collectionview-emptyview-region-events">
CollectionView EmptyView Region Events</h3>
<p>The <code>CollectionView</code> uses a region internally that can be used to know when the empty view is show or destroyed. See <a href="#region-events">Region Events</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { CollectionView } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = CollectionView.extend({
  <span class="hljs-attr">emptyView</span>: MyEmptyView
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView();

myView.getEmptyRegion().on({
  <span class="hljs-string">'show'</span>() {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'CollectionView is empty!'</span>);
  },
  <span class="hljs-string">'before:empty'</span>() {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasView()) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'CollectionView is removing the emptyView'</span>);
    }
  }
});

myView.render();
</pre> <h2 id="dom-change-events">
DOM Change Events</h2>
<h3 id="render-and-beforerender-events">
<code>render</code> and <code>before:render</code> events</h3>
<p>Reflects when a view's template is being rendered into its <code>el</code>.</p> <p><code>before:render</code> will occur prior to removing any current child views. <code>render</code> is an ideal event for attaching child views to the view's template as the first render <em>generally</em> occurs prior to the view attaching to the DOM.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { View, CollectionView } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;
<span class="hljs-keyword">import</span> MyChildView <span class="hljs-keyword">from</span> <span class="hljs-string">'./MyChildView'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  <span class="hljs-attr">template</span>: _.template(<span class="hljs-string">'&lt;div class="foo-region"&gt;&lt;/div&gt;'</span>),
  <span class="hljs-attr">regions</span>: {
    <span class="hljs-string">'foo'</span>: <span class="hljs-string">'.foo-region'</span>
  },
  onRender() {
    <span class="hljs-keyword">this</span>.showChildView(<span class="hljs-string">'foo'</span>, <span class="hljs-keyword">new</span> MyChildView());
  }
});

<span class="hljs-keyword">const</span> MyCollectionView = CollectionView.extend({
  <span class="hljs-attr">childView</span>: MyChildView,
  onRender() {
    <span class="hljs-comment">// Add a child not from the `collection`</span>
    <span class="hljs-keyword">this</span>.addChildView(<span class="hljs-keyword">new</span> MyChildView());
  }
})
</pre> <p><strong>Note</strong> This event is only triggered when rendering a template into a view. A view that is pre-rendered will not have this event triggered unless re-rendered. <a href="dom.prerendered.html">Pre-rendered views</a> should use <code>initialize</code> for attaching child views and the <code>render</code> event if the view is re-rendered.</p> <p><strong>Note</strong> If a view's <code>template</code> is set to <code>false</code> this event will not trigger.</p> <h3 id="attach-and-beforeattach-events">
<code>attach</code> and <code>before:attach</code> events</h3>
<p>Relects when the <code>el</code> of a view is attached to the DOM. These events will not trigger when a view is re-rendered as the <code>el</code> itself does not change.</p> <p><code>attach</code> is the ideal event to setup any external DOM listeners such as <code>jQuery</code> plugins that use the view's <code>el</code>, but <em>not</em> its contents.</p> <h3 id="detach-and-beforedetach-events">
<code>detach</code> and <code>before:detach</code> events</h3>
<p>Relects when the <code>el</code> of a view is detached from the DOM. These events will not trigger when a view is re-rendered as the <code>el</code> itself does not change.</p> <p><code>before:detach</code> is the ideal event to clean up any external DOM listeners such as <code>jQuery</code> plugins that use the view's <code>el</code>, but <em>not</em> its contents.</p> <h3 id="domrefresh-event">
<code>dom:refresh</code> event</h3>
<p>Relects when the <em>contents</em> of a view's <code>el</code> change in the DOM. This event will fire when the view is first <a href="#attach-and-beforeattach-events"><code>attach</code>ed</a>. It will also fire if an attached view is re-rendered.</p> <p>This is the ideal event to setup any external DOM listeners such as <code>jQuery</code> plugins that use DOM <em>within</em> the <code>el</code> of the view and not the view's <code>el</code> itself.</p> <p><strong>NOTE</strong> This event will not fire if the view has no template to render unless it contains prerendered html.</p> <h3 id="domremove-event">
<code>dom:remove</code> event</h3>
<p>Relects when the <em>contents</em> of a view's <code>el</code> are about to change in the DOM. This event will fire when the view is about to be <a href="#detach-and-beforedetach-events"><code>detach</code>ed</a>. It will also fire before an attached view is re-rendered.</p> <p>This is the ideal event to clean up any external DOM listeners such as <code>jQuery</code> plugins that use DOM <em>within</em> the <code>el</code> of the view and not the view's <code>el</code> itself.</p> <p><strong>NOTE</strong> This event will not fire if the view has no template to render unless it contains prerendered html.</p> <h3 id="advanced-event-settings">
Advanced Event Settings</h3>
<p>Marionette is able to trigger <code>attach</code>/<code>detach</code> events down the view tree along with triggering the <code>dom:refresh</code>/<code>dom:remove</code> events because of the view event monitor. This monitor starts when a view is created or shown in a region (to handle non-Marionette views).</p> <p>In some cases it may be a useful performance improvement to disable this functionality. Doing so is as easy as setting <code>monitorViewEvents: false</code> on the view class.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> NonMonitoredView = View.extend({
  <span class="hljs-attr">monitorViewEvents</span>: <span class="hljs-literal">false</span>
});
</pre> <p><strong>Note</strong>: Disabling the view monitor will break the monitor generated events for this view <em>and all child views</em> of this view. Disabling should be done carefully.</p> <h2 id="destroy-events">
Destroy Events</h2>
<h3 id="destroy-and-beforedestroy-events">
<code>destroy</code> and <code>before:destroy</code> events</h3>
<p>Every class has a <code>destroy</code> method which can be used to clean up the instance. With the exception of <code>Behavior</code>'s each of these methods triggers a <code>before:destroy</code> and a <code>destroy</code> event.</p> <p>As a general rule, <code>onBeforeDestroy</code> is the best handler for cleanup as the instance and any internally created children are already destroyed by the time <code>onDestroy</code> is called.</p> <p><strong>Note</strong> For views this is not the ideal location for clean up of anything touching the DOM. See <a href="#domremove-event"><code>dom:remove</code></a> or [<code>before:detach</code>] for DOM related clean up.</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { Application, View } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyView = View.extend({
  onBeforeDestroy(options) {
    <span class="hljs-built_in">console</span>.log(options.foo);
  }
});

<span class="hljs-keyword">const</span> myView = <span class="hljs-keyword">new</span> MyView();

mvView.destroy({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'destroy view'</span> });

<span class="hljs-keyword">const</span> MyApp = Application.extend({
  onBeforeDestroy(options) {
    <span class="hljs-built_in">console</span>.log(options.foo);
  }
});

<span class="hljs-keyword">const</span> myApp = <span class="hljs-keyword">new</span> MyApp();

myApp.destroy({ <span class="hljs-attr">foo</span>: <span class="hljs-string">'destroy app'</span> });
</pre> <h4>
<code>CollectionView</code> <code>destroy:children</code> and <code>before:destroy:children</code> events</h4>
<p>Similar to <code>destroy</code>, <code>CollectionView</code> has events for when all of its children are destroyed. See <a href="#destroychildren-and-beforedestroychildren-events">the CollectionView's events</a> for more information.</p> <h2 id="supporting-backbone-views">
Supporting Backbone Views</h2>
<h3 id="marionetteevents-and-triggermethod">
<code>Marionette.Events</code> and <code>triggerMethod</code>
</h3>
<p>Internally Marionette uses <a href="common.html#triggermethod"><code>triggerMethod</code></a> for event triggering. This API is not available to <code>Backbone.View</code>s so in order to support <code>Backbone.View</code>s in Marionette v4+, <code>Marionette.Events</code> must be mixed into the non-Marionette view.</p> <p>This can be done for an individual view definition:</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-keyword">const</span> MyBbView = Backbone.View.extend(Events);
</pre> <p>or for all <code>Backbone.View</code>s</p> <pre data-language="javascript">_.extend(Backbone.View.prototype, Events);
</pre> <h3 id="lifecycle-events">
Lifecycle Events</h3>
<h4>
<code>render</code> and <code>destroy</code>
</h4>
<p>To support non-Marionette Views, Marionette uses two flags to determine if it should trigger <code>render</code> and <code>destroy</code> events on the view. If a custom view throws it's own <code>render</code> or <code>destroy</code> events, the related flag should be set to <code>true</code> to avoid Marionette duplicating these events.</p> <pre data-language="javascript"><span class="hljs-comment">// Add support for triggerMethod</span>
<span class="hljs-keyword">import</span> { Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

_.extend(Backbone.View.prototype, Events);

<span class="hljs-keyword">const</span> MyCustomView = Backbone.View.extend({
  <span class="hljs-attr">supportsRenderLifecycle</span>: <span class="hljs-literal">true</span>,
  <span class="hljs-attr">supportsDestroyLifecycle</span>: <span class="hljs-literal">true</span>,
  render() {
    <span class="hljs-keyword">this</span>.triggerMethod(<span class="hljs-string">'before:render'</span>);

    <span class="hljs-keyword">this</span>.$el.html(<span class="hljs-string">'render html'</span>);

    <span class="hljs-comment">// Since render is being triggered here set the</span>
    <span class="hljs-comment">// supportsRenderLifecycle flag to true to avoid duplication</span>
    <span class="hljs-keyword">this</span>.triggerMethod(<span class="hljs-string">'render'</span>);
  },
  destroy() {
    <span class="hljs-keyword">this</span>.triggerMethod(<span class="hljs-string">'before:destroy'</span>);

    <span class="hljs-keyword">this</span>.remove();

    <span class="hljs-comment">// Since destroy is being triggered here set the</span>
    <span class="hljs-comment">// supportsDestroyLifecycle flag to true to avoid duplication</span>
    <span class="hljs-keyword">this</span>.triggerMethod(<span class="hljs-string">'destroy'</span>);
  }
});
</pre> <h4>
DOM Change Lifecycle Events</h4>
<p>As mentioned in <a href="#advanced-event-settings">Advanced Event Settings</a> some DOM events are triggers from the view event monitor that will handle DOM attachment related events down the view tree. Backbone View's won't have the functionality unless the monitor is added. This will include all <a href="#dom-change-events">DOM Change Events</a> other than render.</p> <p>You can add the view events monitor to any non-Marionette view:</p> <pre data-language="javascript"><span class="hljs-keyword">import</span> { monitorViewEvents, Events } <span class="hljs-keyword">from</span> <span class="hljs-string">'backbone.marionette'</span>;

<span class="hljs-comment">// Add support for triggerMethod</span>
_.extend(Backbone.View.prototype, Events);

<span class="hljs-keyword">const</span> MyCustomView = Backbone.View.extend({
  initialize() {
    monitorViewEvents(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">// Ideally this happens first prior to any rendering</span>
    <span class="hljs-comment">// or attaching that might occur in the initialize</span>
  }
});
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2017 Muted Solutions, LLC<br>Licensed under the MIT License.<br>
    <a href="https://marionettejs.com/docs/v4.0.0/events.class.html" class="_attribution-link">https://marionettejs.com/docs/v4.0.0/events.class.html</a>
  </p>
</div>
