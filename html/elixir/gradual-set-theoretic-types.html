<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/pages/references/gradual-set-theoretic-types.md#L1" title="View Source" class="source" rel="help">Source</a> <span>Gradual set-theoretic types</span> </h1> <p>Elixir is in the process of incorporating set-theoretic types into the compiler. This document outlines the current stage of our implementation for this Elixir version. Elixir's type system is:</p>
<ul>
<li><p><strong>sound</strong> - the inferred and assigned by the type system align with the behaviour of the program</p></li>
<li><p><strong>gradual</strong> - Elixir's type system includes the <code class="inline">dynamic()</code> type, which can be used when the type of a variable or expression is checked at runtime. In the absence of <code class="inline">dynamic()</code>, Elixir's type system behaves as a static one</p></li>
<li><p><strong>developer friendly</strong> - the types are described, implemented, and composed using basic set operations: unions, intersections, and negation (hence it is a set-theoretic type system)</p></li>
</ul>
<p>The current milestone aims to infer types from patterns and guards and use them to type check programs, enabling the Elixir compiler to find faults and bugs in codebases without requiring changes to existing software. User provided type signatures are planned for future releases. The underlying principles, theory, and roadmap of our work have been outlined in <a href="https://arxiv.org/abs/2306.06391">"The Design Principles of the Elixir Type System" by Giuseppe Castagna, Guillaume Duboc, Jos√© Valim</a>.</p>
<h2 id="supported-types" class="section-heading">  <span class="text">Supported types</span> </h2> <p>At the moment, Elixir developers interact with set-theoretic types through warnings found by the type system. These warnings will represent types using the following notation:</p>
<ul>
<li><p><code class="inline">binary()</code>, <code class="inline">integer()</code>, <code class="inline">float()</code>, <code class="inline">pid()</code>, <code class="inline">port()</code>, <code class="inline">reference()</code> - these types are indivisible. This means both <code class="inline">1</code> and <code class="inline">13</code> get the same <code class="inline">integer()</code> type.</p></li>
<li><p><code class="inline">atom()</code> - it represents all atoms and it is divisible. For instance, the atom <code class="inline">:foo</code> and <code class="inline">:hello_world</code> are also valid (distinct) types.</p></li>
<li><p><code class="inline">tuple()</code> - it represents all tuples. Tuples may also be written using the curly brackets syntax, such as <code class="inline">{:ok, binary()}</code>. A <code class="inline">...</code> at the end of the tuple means the overall size of the tuple is unknown. For example, the following tuple has at least two elements: <code class="inline">{:ok, binary(), ...}</code>.</p></li>
<li><p><code class="inline">list(type)</code> - it represents a list of <code class="inline">type</code>. More precisely, it can be written as <code class="inline">empty_list() or non_empty_list(type, empty_list())</code>. Improper lists, which are lists which do not end with an empty list, such as <code class="inline">[1, 2 | 3]</code>, can be written as <code class="inline">list(integer(), integer())</code>.</p></li>
<li><p><code class="inline">map()</code> and structs - maps can be "closed" or "open". Closed maps only allow the specified keys, such as <code class="inline">%{key: atom(), value: integer()}</code>. Open maps support any other keys in addition to the ones listed and their definition starts with <code class="inline">...</code>, such as <code class="inline">%{..., key: atom(), value: integer()}</code>. Structs are closed maps with the <code class="inline">__struct__</code> key.</p></li>
<li><p><code class="inline">function()</code> - it represents anonymous functions (which may be closures)</p></li>
</ul>
<h2 id="set-operations" class="section-heading">  <span class="text">Set operations</span> </h2> <p>We compose types by using set operations. For example, to say a function returns either atoms or integers, one could write: <code class="inline">atom() or integer()</code>.</p>
<p>Intersections are available via the <code class="inline">and</code> operator, such as <code class="inline">atom() and integer()</code>, which in this case it becomes the empty set <code class="inline">none()</code>. <code class="inline">term()</code> is the union of all types, also known as the "top" type.</p>
<p>Intersections are useful when modelling functions. For example, imagine the following function:</p>
<pre data-language="elixir">def negate(x) when is_integer(x), do: -x
def negate(x) when is_boolean(x), do: not x</pre>
<p>If you give it an integer, it negates it. If you give it a boolean, it negates it.</p>
<p>We can say this function has the type <code class="inline">(integer() -&gt; integer())</code> because it is capable of receiving an integer and returning an integer. In this case, <code class="inline">(integer() -&gt; integer())</code> is a set that represents all functions that can receive an integer and return an integer. Even though this function can receive other arguments and return other values, it is still part of the <code class="inline">(integer() -&gt; integer())</code> set.</p>
<p>This function also has the type <code class="inline">(boolean() -&gt; boolean())</code>, because it receives booleans and returns booleans. Therefore, we can say the overall type of the function is <code class="inline">(integer() -&gt; integer()) and (boolean() -&gt; boolean())</code>. The intersection means the function belongs to both sets.</p>
<p>At this point, you may ask, why not a union? As a real-world example, take a t-shirt with green and yellow stripes. We can say the t-shirt belongs to the set of "t-shirts with green color". We can also say the t-shirt belongs to the set of "t-shirts with yellow color". Let's see the difference between unions and intersections:</p>
<ul>
<li><p><code class="inline">(t_shirts_with_green() or t_shirts_with_yellow())</code> - contains t-shirts with either green or yellow, such as green, green and red, green and yellow, yellow, yellow and red, etc.</p></li>
<li><p><code class="inline">(t_shirts_with_green() and t_shirts_with_yellow())</code> - contains t-shirts with both green and yellow (and also other colors)</p></li>
</ul>
<p>Since the t-shirt has both colors, we say it belongs to the intersection of both sets. The same way that a function that goes from <code class="inline">(integer() -&gt; integer())</code> and <code class="inline">(boolean() -&gt; boolean())</code> is also an intersection. In practice, it does not make sense to define the union of two functions in Elixir, so the compiler will always point to the right direction.</p>
<p>Finally, we can also negate types by using <code class="inline">not</code>. For example, to express all atoms, except the atoms <code class="inline">:foo</code> and <code class="inline">:bar</code>, one can write: <code class="inline">atom() and not (:foo or :bar)</code>.</p>
<h2 id="the-dynamic-type" class="section-heading">  <span class="text">The <code class="inline">dynamic()</code> type</span> </h2> <p>Existing Elixir programs do not have type declarations, but we still want to be able to type check them. This is done with the introduction of the <code class="inline">dynamic()</code> type.</p>
<p>When Elixir sees the following function:</p>
<pre data-language="elixir">def negate(x) when is_integer(x), do: -x
def negate(x) when is_boolean(x), do: not x</pre>
<p>Elixir type checks it as if the function had the type <code class="inline">(dynamic() -&gt; dynamic())</code>. Then, based on patterns and guards, we can refine the value of the variable <code class="inline">x</code> to be <code class="inline">dynamic() and integer()</code> and <code class="inline">dynamic() and boolean()</code> for each clause respectively. We say <code class="inline">dynamic()</code> is a gradual type, which leads us to <em>gradual set-theoretic types</em>.</p>
<p>The simplest way to reason about <code class="inline">dynamic()</code> in Elixir is that it is a range of types. If you have a type <code class="inline">atom() or integer()</code>, the underlying code needs to work with both <code class="inline">atom() or integer()</code>. For example, if you call <code class="inline">Integer.to_string(var)</code>, and <code class="inline">var</code> has type <code class="inline">atom() or integer()</code>, the type system will emit a warning, because <a href="integer.html#to_string/1"><code class="inline">Integer.to_string/1</code></a> does not accept atoms.</p>
<p>However, by intersecting a type with <code class="inline">dynamic()</code>, we make the type gradual and therefore only a subset of the type needs to be valid. For instance, if you call <code class="inline">Integer.to_string(var)</code>, and <code class="inline">var</code> has type <code class="inline">dynamic() and (atom() or integer())</code>, the type system will not emit a warning, because <a href="integer.html#to_string/1"><code class="inline">Integer.to_string/1</code></a> works with at least one of the types. For convenience, most programs will write <code class="inline">dynamic(atom() or integer())</code> instead of the intersection. They are equivalent.</p>
<p>Compared to other gradually typed languages, the <code class="inline">dynamic()</code> type in Elixir is quite powerful: it restricts our program to certain types, via intersections, while still emitting warnings once it is certain the code will fail. This makes <code class="inline">dynamic()</code> an excellent tool for typing existing Elixir code with meaningful warnings.</p>
<p>If the user provides their own types, and those types are not <code class="inline">dynamic()</code>, then Elixir's type system behaves as a statically typed one. This brings us to one last property of dynamic types in Elixir: dynamic types are always at the root. For example, when you write a tuple of type <code class="inline">{:ok, dynamic()}</code>, Elixir will rewrite it to <code class="inline">dynamic({:ok, term()})</code>. While this has the downside that you cannot make part of a tuple/map/list gradual, only the whole tuple/map/list, it comes with the upside that dynamic is always explicitly at the root, making it harder to accidentally sneak <code class="inline">dynamic()</code> in a statically typed program.</p>
<h2 id="type-inference" class="section-heading">  <span class="text">Type inference</span> </h2> <p>Type inference (or reconstruction) is the ability of a type system automatically deduce, either partially or fully, the type of an expression at compile time. Type inference may occur at different levels. For example, many programming languages can automatically infer the types of variables, also known "local type inference", but not all can infer type signatures. In other words, they may not reconstruct the arguments types and return types of a function.</p>
<p>Inferring type signatures comes with a series of trade-offs:</p>
<ul>
<li><p>Speed - type inference algorithms are often more computationally intensive than type checking algorithms.</p></li>
<li><p>Expressiveness - in any given type system, the constructs that support inference are always a subset of those that can be type-checked. Therefore, if a programming language is restricted to fully reconstructed types, it is less expressive than a solely type checked counterpart.</p></li>
<li><p>Incremental compilation - type inference complicates incremental compilation. If module A depends on module B, which depends on module C, a change to C may require the type signature in B to be reconstructed, which may then require A to be recomputed (and so on). This dependency chain may require large projects to explicitly add type signatures for stability and compilation efficiency.</p></li>
<li><p>Cascading errors - when a user accidentally makes type errors or the code has conflicting assumptions, type inference may lead to less clear error messages as the type system tries to reconcile diverging type assumptions across code paths.</p></li>
</ul>
<p>On the other hand, type inference offers the benefit of enabling type checking for functions and codebases without requiring the user to add type annotations. To balance these trade-offs, Elixir‚Äôs type system provides the following type reconstruction capabilities:</p>
<ul>
<li><p>Local type inference - the type system automatically infer the types of variables, at the place those variables are defined.</p></li>
<li><p>Type inference of patterns (and guards in future releases) - the argument types of a function are automatically inferred based on patterns and guards, which capture and narrow types based on common Elixir constructs.</p></li>
<li><p>Module-local inference of return types - the gradual return types of functions are computed considering all of the functions within the module itself. Any call to a function in another module is conservatively assumed to return <code class="inline">dynamic()</code>.</p></li>
</ul>
<p>The last two items offer gradual reconstruction of type signatures. Our goal is to provide an efficient type reconstruction algorithm that can detect definite bugs in dynamic codebases, even in the absence of explicit type annotations. The gradual system focuses on proving cases where all combinations of a type <em>will</em> fail, rather than issuing warnings for cases where some combinations <em>might</em> error.</p>
<p>Once Elixir introduces typed function signatures (see "Roadmap"), any function with an explicit type signature will be checked against the user-provided type, as in other statically typed languages, without performing type inference of the function signature.</p>
<h2 id="roadmap" class="section-heading">  <span class="text">Roadmap</span> </h2> <p>The current milestone is to implement type inference of patterns and guards, as well as type checking of all language constructs, without changes to the Elixir language. At this stage, we want to collect feedback on the quality of error messages and performance, and therefore the type system has no user facing API. Full type inference of patterns was released in Elixir v1.18, and inference of guards is expected as part of Elixir v1.19.</p>
<p>If the results are satisfactory, the next milestone will include a mechanism for defining typed structs. Elixir programs frequently pattern match on structs, which reveals information about the struct fields, but it knows nothing about their respective types. By propagating types from structs and their fields throughout the program, we will increase the type system‚Äôs ability to find errors while further straining our type system implementation. Proposals including the required changes to the language surface will be sent to the community once we reach this stage.</p>
<p>The third milestone is to introduce set-theoretic type signatures for functions. Unfortunately, the existing Erlang Typespecs are not precise enough for set-theoretic types and they will be phased out of the language and have their postprocessing moved into a separate library once this stage concludes.</p>
<h2 id="acknowledgements" class="section-heading">  <span class="text">Acknowledgements</span> </h2> <p>The type system was made possible thanks to a partnership between <a href="https://www.cnrs.fr/">CNRS</a> and <a href="https://remote.com/">Remote</a>. The research was partially supported by <a href="https://supabase.com/">Supabase</a> and <a href="https://www.fresha.com/">Fresha</a>. The development work is sponsored by <a href="https://www.fresha.com/">Fresha</a>, <a href="https://starfish.team/">Starfish*</a>, and <a href="https://dashbit.co/">Dashbit</a>.</p> </div> <div class="bottom-actions" id="bottom-actions"> <div class="bottom-actions-item"> <a href="compatibility-and-deprecations.html" class="bottom-actions-button" rel="prev"> <span class="subheader"> ‚Üê Previous Page </span> <span class="title"> Compatibility and deprecations </span> </a> </div> <div class="bottom-actions-item"> <a href="library-guidelines.html" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page ‚Üí </span> <span class="title"> Library guidelines </span> </a> </div> </div> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/gradual-set-theoretic-types.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/gradual-set-theoretic-types.html</a>
  </p>
</div>
