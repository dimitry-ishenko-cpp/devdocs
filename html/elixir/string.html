<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L3" title="View Source" class="source" rel="help">Source</a> <span translate="no">String</span>  </h1> <section id="moduledoc"> <p>Strings in Elixir are UTF-8 encoded binaries.</p>
<p>Strings in Elixir are a sequence of Unicode characters, typically written between double quoted strings, such as <code class="inline">"hello"</code> and <code class="inline">"héllò"</code>.</p>
<p>In case a string must have a double-quote in itself, the double quotes must be escaped with a backslash, for example: <code class="inline">"this is a string with \"double quotes\""</code>.</p>
<p>You can concatenate two strings with the <a href="kernel.html#%3C%3E/2"><code class="inline">&lt;&gt;/2</code></a> operator:</p>
<pre data-language="elixir">iex&gt; "hello" &lt;&gt; " " &lt;&gt; "world"
"hello world"</pre>
<p>The functions in this module act according to <a href="http://www.unicode.org/versions/Unicode16.0.0/">The Unicode Standard, Version 16.0.0</a>.</p>
<h2 id="module-interpolation" class="section-heading">  <span class="text">Interpolation</span> </h2> <p>Strings in Elixir also support interpolation. This allows you to place some value in the middle of a string by using the <code class="inline">#{}</code> syntax:</p>
<pre data-language="elixir">iex&gt; name = "joe"
iex&gt; "hello #{name}"
"hello joe"</pre>
<p>Any Elixir expression is valid inside the interpolation. If a string is given, the string is interpolated as is. If any other value is given, Elixir will attempt to convert it to a string using the <a href="string.chars.html"><code class="inline">String.Chars</code></a> protocol. This allows, for example, to output an integer from the interpolation:</p>
<pre data-language="elixir">iex&gt; "2 + 2 = #{2 + 2}"
"2 + 2 = 4"</pre>
<p>In case the value you want to interpolate cannot be converted to a string, because it doesn't have a human textual representation, a protocol error will be raised.</p>
<h2 id="module-escape-characters" class="section-heading">  <span class="text">Escape characters</span> </h2> <p>Besides allowing double-quotes to be escaped with a backslash, strings also support the following escape characters:</p>
<ul>
<li>
<code class="inline">\0</code> - Null byte</li>
<li>
<code class="inline">\a</code> - Bell</li>
<li>
<code class="inline">\b</code> - Backspace</li>
<li>
<code class="inline">\t</code> - Horizontal tab</li>
<li>
<code class="inline">\n</code> - Line feed (New lines)</li>
<li>
<code class="inline">\v</code> - Vertical tab</li>
<li>
<code class="inline">\f</code> - Form feed</li>
<li>
<code class="inline">\r</code> - Carriage return</li>
<li>
<code class="inline">\e</code> - Command Escape</li>
<li>
<code class="inline">\s</code> - Space</li>
<li>
<code class="inline">\#</code> - Returns the <code class="inline">#</code> character itself, skipping interpolation</li>
<li>
<code class="inline">\\</code> - Single backslash</li>
<li>
<code class="inline">\xNN</code> - A byte represented by the hexadecimal <code class="inline">NN</code>
</li>
<li>
<code class="inline">\uNNNN</code> - A Unicode code point represented by <code class="inline">NNNN</code>
</li>
<li>
<code class="inline">\u{NNNNNN}</code> - A Unicode code point represented by <code class="inline">NNNNNN</code>
</li>
</ul>
<p>Note it is generally not advised to use <code class="inline">\xNN</code> in Elixir strings, as introducing an invalid byte sequence would make the string invalid. If you have to introduce a character by its hexadecimal representation, it is best to work with Unicode code points, such as <code class="inline">\uNNNN</code>. In fact, understanding Unicode code points can be essential when doing low-level manipulations of string, so let's explore them in detail next.</p>
<h2 id="module-unicode-and-code-points" class="section-heading">  <span class="text">Unicode and code points</span> </h2> <p>In order to facilitate meaningful communication between computers across multiple languages, a standard is required so that the ones and zeros on one machine mean the same thing when they are transmitted to another. The Unicode Standard acts as an official registry of virtually all the characters we know: this includes characters from classical and historical texts, emoji, and formatting and control characters as well.</p>
<p>Unicode organizes all of the characters in its repertoire into code charts, and each character is given a unique numerical index. This numerical index is known as a Code Point.</p>
<p>In Elixir you can use a <code class="inline">?</code> in front of a character literal to reveal its code point:</p>
<pre data-language="elixir">iex&gt; ?a
97
iex&gt; ?ł
322</pre>
<p>Note that most Unicode code charts will refer to a code point by its hexadecimal (hex) representation, e.g. <code class="inline">97</code> translates to <code class="inline">0061</code> in hex, and we can represent any Unicode character in an Elixir string by using the <code class="inline">\u</code> escape character followed by its code point number:</p>
<pre data-language="elixir">iex&gt; "\u0061" === "a"
true
iex&gt; 0x0061 = 97 = ?a
97</pre>
<p>The hex representation will also help you look up information about a code point, e.g. <a href="https://codepoints.net/U+0061">https://codepoints.net/U+0061</a> has a data sheet all about the lower case <code class="inline">a</code>, a.k.a. code point 97. Remember you can get the hex presentation of a number by calling <a href="integer.html#to_string/2"><code class="inline">Integer.to_string/2</code></a>:</p>
<pre data-language="elixir">iex&gt; Integer.to_string(?a, 16)
"61"</pre>
<h2 id="module-utf-8-encoded-and-encodings" class="section-heading">  <span class="text">UTF-8 encoded and encodings</span> </h2> <p>Now that we understand what the Unicode standard is and what code points are, we can finally talk about encodings. Whereas the code point is <strong>what</strong> we store, an encoding deals with <strong>how</strong> we store it: encoding is an implementation. In other words, we need a mechanism to convert the code point numbers into bytes so they can be stored in memory, written to disk, and such.</p>
<p>Elixir uses UTF-8 to encode its strings, which means that code points are encoded as a series of 8-bit bytes. UTF-8 is a <strong>variable width</strong> character encoding that uses one to four bytes to store each code point. It is capable of encoding all valid Unicode code points. Let's see an example:</p>
<pre data-language="elixir">iex&gt; string = "héllo"
"héllo"
iex&gt; String.length(string)
5
iex&gt; byte_size(string)
6</pre>
<p>Although the string above has 5 characters, it uses 6 bytes, as two bytes are used to represent the character <code class="inline">é</code>.</p>
<h2 id="module-grapheme-clusters" class="section-heading">  <span class="text">Grapheme clusters</span> </h2> <p>This module also works with the concept of grapheme cluster (from now on referenced as graphemes). Graphemes can consist of multiple code points that may be perceived as a single character by readers. For example, "é" can be represented either as a single "e with acute" code point, as seen above in the string <code class="inline">"héllo"</code>, or as the letter "e" followed by a "combining acute accent" (two code points):</p>
<pre data-language="elixir">iex&gt; string = "\u0065\u0301"
"é"
iex&gt; byte_size(string)
3
iex&gt; String.length(string)
1
iex&gt; String.codepoints(string)
["e", "́"]
iex&gt; String.graphemes(string)
["é"]</pre>
<p>Although it looks visually the same as before, the example above is made of two characters, it is perceived by users as one.</p>
<p>Graphemes can also be two characters that are interpreted as one by some languages. For example, some languages may consider "ch" as a single character. However, since this information depends on the locale, it is not taken into account by this module.</p>
<p>In general, the functions in this module rely on the Unicode Standard, but do not contain any of the locale specific behavior. More information about graphemes can be found in the <a href="https://www.unicode.org/reports/tr29/">Unicode Standard Annex #29</a>.</p>
<p>For converting a binary to a different encoding and for Unicode normalization mechanisms, see Erlang's <code class="inline">:unicode</code> module.</p>
<h2 id="module-string-and-binary-operations" class="section-heading">  <span class="text">String and binary operations</span> </h2> <p>To act according to the Unicode Standard, many functions in this module run in linear time, as they need to traverse the whole string considering the proper Unicode code points.</p>
<p>For example, <a href="#length/1"><code class="inline">String.length/1</code></a> will take longer as the input grows. On the other hand, <a href="kernel.html#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> always runs in constant time (i.e. regardless of the input size).</p>
<p>This means often there are performance costs in using the functions in this module, compared to the more low-level operations that work directly with binaries:</p>
<ul>
<li>
<a href="kernel.html#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> - retrieves part of the binary</li>
<li>
<a href="kernel.html#bit_size/1"><code class="inline">Kernel.bit_size/1</code></a> and <a href="kernel.html#byte_size/1"><code class="inline">Kernel.byte_size/1</code></a> - size related functions</li>
<li>
<a href="kernel.html#is_bitstring/1"><code class="inline">Kernel.is_bitstring/1</code></a> and <a href="kernel.html#is_binary/1"><code class="inline">Kernel.is_binary/1</code></a> - type-check function</li>
<li>Plus a number of functions for working with binaries (bytes) in the <a href="https://www.erlang.org/doc/apps/stdlib/binary.html"><code class="inline">:binary</code> module</a>
</li>
</ul>
<p>A <code class="inline">utf8</code> modifier is also available inside the binary syntax <code class="inline">&lt;&lt;&gt;&gt;</code>. It can be used to match code points out of a binary/string:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;eacute::utf8&gt;&gt; = "é"
iex&gt; eacute
233</pre>
<p>See the <a href="patterns-and-guards.html"><em>Patterns and Guards</em> guide</a> and the documentation for <a href="kernel.specialforms.html#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;</code></a> for more information on binary pattern matching.</p>
<p>You can also fully convert a string into a list of integer code points, known as "charlists" in Elixir, by calling <a href="#to_charlist/1"><code class="inline">String.to_charlist/1</code></a>:</p>
<pre data-language="elixir">iex&gt; String.to_charlist("héllo")
[104, 233, 108, 108, 111]</pre>
<p>If you would rather see the underlying bytes of a string, instead of its codepoints, a common trick is to concatenate the null byte <code class="inline">&lt;&lt;0&gt;&gt;</code> to it:</p>
<pre data-language="elixir">iex&gt; "héllo" &lt;&gt; &lt;&lt;0&gt;&gt;
&lt;&lt;104, 195, 169, 108, 108, 111, 0&gt;&gt;</pre>
<p>Alternatively, you can view a string's binary representation by passing an option to <a href="io.html#inspect/2"><code class="inline">IO.inspect/2</code></a>:</p>
<pre data-language="elixir">IO.inspect("héllo", binaries: :as_binaries)
#=&gt; &lt;&lt;104, 195, 169, 108, 108, 111&gt;&gt;</pre>
<h2 id="module-self-synchronization" class="section-heading">  <span class="text">Self-synchronization</span> </h2> <p>The UTF-8 encoding is self-synchronizing. This means that if malformed data (i.e., data that is not possible according to the definition of the encoding) is encountered, only one code point needs to be rejected.</p>
<p>This module relies on this behavior to ignore such invalid characters. For example, <a href="#length/1"><code class="inline">length/1</code></a> will return a correct result even if an invalid code point is fed into it.</p>
<p>In other words, this module expects invalid data to be detected elsewhere, usually when retrieving data from the external source. For example, a driver that reads strings from a database will be responsible to check the validity of the encoding. <a href="#chunk/2"><code class="inline">String.chunk/2</code></a> can be used for breaking a string into valid and invalid parts.</p>
<h2 id="module-compile-binary-patterns" class="section-heading">  <span class="text">Compile binary patterns</span> </h2> <p>Many functions in this module work with patterns. For example, <a href="#split/3"><code class="inline">String.split/3</code></a> can split a string into multiple strings given a pattern. This pattern can be a string, a list of strings or a compiled pattern:</p>
<pre data-language="elixir">iex&gt; String.split("foo bar", " ")
["foo", "bar"]

iex&gt; String.split("foo bar!", [" ", "!"])
["foo", "bar", ""]

iex&gt; pattern = :binary.compile_pattern([" ", "!"])
iex&gt; String.split("foo bar!", pattern)
["foo", "bar", ""]</pre>
<p>The compiled pattern is useful when the same match will be done over and over again. Note though that the compiled pattern cannot be stored in a module attribute as the pattern is generated at runtime and does not survive compile time.</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:codepoint/0" data-no-tooltip translate="no">codepoint()</a> </dt> <dd class="summary-synopsis"><p>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:grapheme/0" data-no-tooltip translate="no">grapheme()</a> </dt> <dd class="summary-synopsis"><p>Multiple code points that may be perceived as a single character by readers</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:pattern/0" data-no-tooltip translate="no">pattern()</a> </dt> <dd class="summary-synopsis"><p>Pattern used in functions like <a href="#replace/4"><code class="inline">replace/4</code></a> and <a href="#split/3"><code class="inline">split/3</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" data-no-tooltip translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>A UTF-8 encoded binary.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#at/2" data-no-tooltip translate="no">at(string, position)</a> </dt> <dd class="summary-synopsis"><p>Returns the grapheme at the <code class="inline">position</code> of the given UTF-8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#bag_distance/2" data-no-tooltip translate="no">bag_distance(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Computes the bag distance between two strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#byte_slice/3" data-no-tooltip translate="no">byte_slice(string, start_bytes, size_bytes)</a> </dt> <dd class="summary-synopsis"><p>Returns a substring starting at (or after) <code class="inline">start_bytes</code> and of at most the given <code class="inline">size_bytes</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#capitalize/2" data-no-tooltip translate="no">capitalize(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts the first character in the given string to uppercase and the remainder to lowercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#chunk/2" data-no-tooltip translate="no">chunk(string, trait)</a> </dt> <dd class="summary-synopsis"><p>Splits the string into chunks of characters that share a common trait.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#codepoints/1" data-no-tooltip translate="no">codepoints(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a list of code points encoded as strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#contains?/2" data-no-tooltip translate="no">contains?(string, contents)</a> </dt> <dd class="summary-synopsis"><p>Searches if <code class="inline">string</code> contains any of the given <code class="inline">contents</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#downcase/2" data-no-tooltip translate="no">downcase(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in the given string to lowercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#duplicate/2" data-no-tooltip translate="no">duplicate(subject, n)</a> </dt> <dd class="summary-synopsis"><p>Returns a string <code class="inline">subject</code> repeated <code class="inline">n</code> times.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ends_with?/2" data-no-tooltip translate="no">ends_with?(string, suffix)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#equivalent?/2" data-no-tooltip translate="no">equivalent?(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to <code class="inline">string2</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#first/1" data-no-tooltip translate="no">first(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the first grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#graphemes/1" data-no-tooltip translate="no">graphemes(string)</a> </dt> <dd class="summary-synopsis"><p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#jaro_distance/2" data-no-tooltip translate="no">jaro_distance(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Computes the Jaro distance (similarity) between two strings.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#last/1" data-no-tooltip translate="no">last(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the last grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#length/1" data-no-tooltip translate="no">length(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the number of Unicode graphemes in a UTF-8 string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#match?/2" data-no-tooltip translate="no">match?(string, regex)</a> </dt> <dd class="summary-synopsis"><p>Checks if <code class="inline">string</code> matches the given regular expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#myers_difference/2" data-no-tooltip translate="no">myers_difference(string1, string2)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list that represents an edit script.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_codepoint/1" data-no-tooltip translate="no">next_codepoint(arg)</a> </dt> <dd class="summary-synopsis"><p>Returns the next code point in a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_grapheme/1" data-no-tooltip translate="no">next_grapheme(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the next grapheme in a string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#next_grapheme_size/1" data-no-tooltip translate="no">next_grapheme_size(string)</a> </dt> <dd class="summary-synopsis"><p>Returns the size (in bytes) of the next grapheme.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#normalize/2" data-no-tooltip translate="no">normalize(string, form)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pad_leading/3" data-no-tooltip translate="no">pad_leading(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pad_trailing/3" data-no-tooltip translate="no">pad_trailing(string, count, padding \\ [" "])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#printable?/2" data-no-tooltip translate="no">printable?(string, character_limit \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Checks if a string contains only printable characters up to <code class="inline">character_limit</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace/4" data-no-tooltip translate="no">replace(subject, pattern, replacement, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_invalid/2" data-no-tooltip translate="no">replace_invalid(bytes, replacement \\ "�")</a> </dt> <dd class="summary-synopsis"><p>Returns a new string created by replacing all invalid bytes with <code class="inline">replacement</code> (<code class="inline">"�"</code> by default).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_leading/3" data-no-tooltip translate="no">replace_leading(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_prefix/3" data-no-tooltip translate="no">replace_prefix(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_suffix/3" data-no-tooltip translate="no">replace_suffix(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_trailing/3" data-no-tooltip translate="no">replace_trailing(string, match, replacement)</a> </dt> <dd class="summary-synopsis"><p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reverse/1" data-no-tooltip translate="no">reverse(string)</a> </dt> <dd class="summary-synopsis"><p>Reverses the graphemes in given string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/2" data-no-tooltip translate="no">slice(string, range)</a> </dt> <dd class="summary-synopsis"><p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/3" data-no-tooltip translate="no">slice(string, start, length)</a> </dt> <dd class="summary-synopsis"><p>Returns a substring starting at the offset <code class="inline">start</code>, and of the given <code class="inline">length</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1" data-no-tooltip translate="no">split(binary)</a> </dt> <dd class="summary-synopsis"><p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/3" data-no-tooltip translate="no">split(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Divides a string into parts based on a pattern.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_at/2" data-no-tooltip translate="no">split_at(string, position)</a> </dt> <dd class="summary-synopsis"><p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#splitter/3" data-no-tooltip translate="no">splitter(string, pattern, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns an enumerable that splits a string on demand.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#starts_with?/2" data-no-tooltip translate="no">starts_with?(string, prefix)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_atom/1" data-no-tooltip translate="no">to_atom(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string to an existing atom or creates a new one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_charlist/1" data-no-tooltip translate="no">to_charlist(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string into a charlist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_existing_atom/1" data-no-tooltip translate="no">to_existing_atom(string)</a> </dt> <dd class="summary-synopsis"><p>Converts a string to an existing atom or raises if the atom does not exist.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_float/1" data-no-tooltip translate="no">to_float(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a float whose text representation is <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/1" data-no-tooltip translate="no">to_integer(string)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">string</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_integer/2" data-no-tooltip translate="no">to_integer(string, base)</a> </dt> <dd class="summary-synopsis"><p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim/1" data-no-tooltip translate="no">trim(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim/2" data-no-tooltip translate="no">trim(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading and trailing <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_leading/1" data-no-tooltip translate="no">trim_leading(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading Unicode whitespaces have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_leading/2" data-no-tooltip translate="no">trim_leading(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all leading <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_trailing/1" data-no-tooltip translate="no">trim_trailing(string)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all trailing Unicode whitespaces has been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#trim_trailing/2" data-no-tooltip translate="no">trim_trailing(string, to_trim)</a> </dt> <dd class="summary-synopsis"><p>Returns a string where all trailing <code class="inline">to_trim</code> characters have been removed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#upcase/2" data-no-tooltip translate="no">upcase(string, mode \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Converts all characters in the given string to uppercase according to <code class="inline">mode</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#valid?/2" data-no-tooltip translate="no">valid?(string, algorithm \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Checks whether <code class="inline">string</code> contains only valid characters.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:codepoint/0">codepoint()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L276" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type codepoint() :: t()</pre> </div> <p>A single Unicode code point encoded in UTF-8. It may be one or more bytes.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:grapheme/0">grapheme()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L279" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type grapheme() :: t()</pre> </div> <p>Multiple code points that may be perceived as a single character by readers</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:pattern/0">pattern()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L292" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type pattern() ::
  t() | [nonempty_binary()] | (compiled_search_pattern :: :binary.cp())</pre> </div> <p>Pattern used in functions like <a href="#replace/4"><code class="inline">replace/4</code></a> and <a href="#split/3"><code class="inline">split/3</code></a>.</p>
<p>It must be one of:</p>
<ul>
<li>a string</li>
<li>an empty list</li>
<li>a list containing non-empty strings</li>
<li>a compiled search pattern created by <a href="https://www.erlang.org/doc/apps/stdlib/binary.html#compile_pattern/1"><code class="inline">:binary.compile_pattern/1</code></a>
</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L273" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: binary()</pre> </div> <p>A UTF-8 encoded binary.</p>
<p>The types <code class="inline">String.t()</code> and <code class="inline">binary()</code> are equivalent to analysis tools. Although, for those reading the documentation, <code class="inline">String.t()</code> implies it is a UTF-8 encoded binary.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="at/2">at(string, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2262" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec at(t(), integer()) :: grapheme() | nil</pre> </div> <p>Returns the grapheme at the <code class="inline">position</code> of the given UTF-8 <code class="inline">string</code>. If <code class="inline">position</code> is greater than <code class="inline">string</code> length, then it returns <code class="inline">nil</code>.</p>
<section role="note" class="admonition warning"><h4 class="admonition-title warning">Linear Access</h4>
<p>This function has to linearly traverse the string. If you want to access a string or a binary in constant time based on the number of bytes, use <a href="kernel.html#binary_slice/3"><code class="inline">Kernel.binary_slice/3</code></a> or <a href="https://www.erlang.org/doc/apps/stdlib/binary.html#at/2"><code class="inline">:binary.at/2</code></a> instead.</p></section><h4 id="at/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.at("elixir", 0)
"e"

iex&gt; String.at("elixir", 1)
"l"

iex&gt; String.at("elixir", 10)
nil

iex&gt; String.at("elixir", -1)
"r"

iex&gt; String.at("elixir", -10)
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="bag_distance/2">bag_distance(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L3034" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec bag_distance(t(), t()) :: float()</pre> </div> <p>Computes the bag distance between two strings.</p>
<p>Returns a float value between 0 and 1 representing the bag distance between <code class="inline">string1</code> and <code class="inline">string2</code>.</p>
<p>The bag distance is meant to be an efficient approximation of the distance between two strings to quickly rule out strings that are largely different.</p>
<p>The algorithm is outlined in the "String Matching with Metric Trees Using an Approximate Distance" paper by Ilaria Bartolini, Paolo Ciaccia, and Marco Patella.</p>
<h4 id="bag_distance/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.bag_distance("abc", "")
0.0
iex&gt; String.bag_distance("abcd", "a")
0.25
iex&gt; String.bag_distance("abcd", "ab")
0.5
iex&gt; String.bag_distance("abcd", "abc")
0.75
iex&gt; String.bag_distance("abcd", "abcd")
1.0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="byte_slice/3">byte_slice(string, start_bytes, size_bytes)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2589" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec byte_slice(t(), integer(), non_neg_integer()) :: t()</pre> </div> <p>Returns a substring starting at (or after) <code class="inline">start_bytes</code> and of at most the given <code class="inline">size_bytes</code>.</p>
<p>This function works on bytes and then adjusts the string to eliminate truncated codepoints. This is useful when you have a string and you need to guarantee it does not exceed a certain amount of bytes.</p>
<p>If the offset is greater than the number of bytes in the string, then it returns <code class="inline">""</code>. Similar to <a href="#slice/2"><code class="inline">String.slice/2</code></a>, a negative <code class="inline">start_bytes</code> will be adjusted to the end of the string (but in bytes).</p>
<p>This function does not guarantee the string won't have invalid codepoints, it only guarantees to remove truncated codepoints immediately at the beginning or the end of the slice.</p>
<h4 id="byte_slice/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Consider the string "héllo". Let's see its representation:</p>
<pre data-language="elixir">iex&gt; inspect("héllo", binaries: :as_binaries)
"&lt;&lt;104, 195, 169, 108, 108, 111&gt;&gt;"</pre>
<p>Although the string has 5 characters, it is made of 6 bytes. Now imagine we want to get only the first two bytes. To do so, let's use <a href="kernel.html#binary_slice/3"><code class="inline">binary_slice/3</code></a>, which is unaware of codepoints:</p>
<pre data-language="elixir">iex&gt; binary_slice("héllo", 0, 2)
&lt;&lt;104, 195&gt;&gt;</pre>
<p>As you can see, this operation is unsafe and returns an invalid string. That's because we cut the string in the middle of the bytes representing "é". On the other hand, we could use <a href="#slice/3"><code class="inline">String.slice/3</code></a>:</p>
<pre data-language="elixir">iex&gt; String.slice("héllo", 0, 2)
"hé"</pre>
<p>While the above is correct, it has 3 bytes. If you have a requirement where you need <em>at most</em> 2 bytes, the result would also be invalid. In such scenarios, you can use this function, which will slice the given bytes, but clean up the truncated codepoints:</p>
<pre data-language="elixir">iex&gt; String.byte_slice("héllo", 0, 2)
"h"</pre>
<p>Truncated codepoints at the beginning are also cleaned up:</p>
<pre data-language="elixir">iex&gt; String.byte_slice("héllo", 2, 3)
"llo"</pre>
<p>Note that, if you want to work on raw bytes, then you must use <a href="kernel.html#binary_slice/3"><code class="inline">binary_slice/3</code></a> instead.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="capitalize/2">capitalize(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L971" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec capitalize(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts the first character in the given string to uppercase and the remainder to lowercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> capitalizes only the letters A to Z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter <code class="inline">i</code> with the dotless variant.</p>
<p>Also see <a href="#upcase/2"><code class="inline">upcase/2</code></a> and <a href="#capitalize/2"><code class="inline">capitalize/2</code></a> for other conversions. If you want a variation of this function that does not lowercase the rest of string, see Erlang's <a href="https://www.erlang.org/doc/apps/stdlib/string.html#titlecase/1"><code class="inline">:string.titlecase/1</code></a>.</p>
<h4 id="capitalize/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.capitalize("abcd")
"Abcd"
iex&gt; String.capitalize("ABCD")
"Abcd"

iex&gt; String.capitalize("ﬁn")
"Fin"
iex&gt; String.capitalize("olá")
"Olá"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="chunk/2">chunk(string, trait)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2027" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec chunk(t(), :valid | :printable) :: [t()]</pre> </div> <p>Splits the string into chunks of characters that share a common trait.</p>
<p>The trait can be one of two options:</p>
<ul>
<li><p><code class="inline">:valid</code> - the string is split into chunks of valid and invalid character sequences</p></li>
<li><p><code class="inline">:printable</code> - the string is split into chunks of printable and non-printable character sequences</p></li>
</ul>
<p>Returns a list of binaries each of which contains only one kind of characters.</p>
<p>If the given string is empty, an empty list is returned.</p>
<h4 id="chunk/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0&gt;&gt;, :valid)
["abc\0"]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0xFFFF::utf16&gt;&gt;, :valid)
["abc\0", &lt;&lt;0xFFFF::utf16&gt;&gt;]

iex&gt; String.chunk(&lt;&lt;?a, ?b, ?c, 0, 0x0FFFF::utf8&gt;&gt;, :printable)
["abc", &lt;&lt;0, 0x0FFFF::utf8&gt;&gt;]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="codepoints/1">codepoints(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1761" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec codepoints(t()) :: [codepoint()]</pre> </div> <p>Returns a list of code points encoded as strings.</p>
<p>To retrieve code points in their natural integer representation, see <a href="#to_charlist/1"><code class="inline">to_charlist/1</code></a>. For details about code points and graphemes, see the <a href="string.html"><code class="inline">String</code></a> module documentation.</p>
<h4 id="codepoints/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.codepoints("olá")
["o", "l", "á"]

iex&gt; String.codepoints("оптими зации")
["о", "п", "т", "и", "м", "и", " ", "з", "а", "ц", "и", "и"]

iex&gt; String.codepoints("ἅἪῼ")
["ἅ", "Ἢ", "ῼ"]

iex&gt; String.codepoints("\u00e9")
["é"]

iex&gt; String.codepoints("\u0065\u0301")
["e", "́"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="contains?/2">contains?(string, contents)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2822" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec contains?(t(), [t()] | pattern()) :: boolean()</pre> </div> <p>Searches if <code class="inline">string</code> contains any of the given <code class="inline">contents</code>.</p>
<p><code class="inline">contents</code> can be either a string, a list of strings, or a compiled pattern. If <code class="inline">contents</code> is a list, this function will search if any of the strings in <code class="inline">contents</code> are part of <code class="inline">string</code>.</p>
<section role="note" class="admonition tip"><h4 class="admonition-title tip">Searching for a string in a list</h4>
<p>If you want to check if <code class="inline">string</code> is listed in <code class="inline">contents</code>, where <code class="inline">contents</code> is a list, use <code class="inline">Enum.member?(contents, string)</code> instead.</p></section><h4 id="contains?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.contains?("elixir of life", "of")
true
iex&gt; String.contains?("elixir of life", ["life", "death"])
true
iex&gt; String.contains?("elixir of life", ["death", "mercury"])
false</pre>
<p>The argument can also be a compiled pattern:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern(["life", "death"])
iex&gt; String.contains?("elixir of life", pattern)
true</pre>
<p>An empty string will always match:</p>
<pre data-language="elixir">iex&gt; String.contains?("elixir of life", "")
true
iex&gt; String.contains?("elixir of life", ["", "other"])
true</pre>
<p>An empty list will never match:</p>
<pre data-language="elixir">iex&gt; String.contains?("elixir of life", [])
false

iex&gt; String.contains?("", [])
false</pre>
<p>Be aware that this function can match within or across grapheme boundaries. For example, take the grapheme "é" which is made of the characters "e" and the acute accent. The following returns <code class="inline">true</code>:</p>
<pre data-language="elixir">iex&gt; String.contains?(String.normalize("é", :nfd), "e")
true</pre>
<p>However, if "é" is represented by the single character "e with acute" accent, then it will return <code class="inline">false</code>:</p>
<pre data-language="elixir">iex&gt; String.contains?(String.normalize("é", :nfc), "e")
false</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="downcase/2">downcase(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L919" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec downcase(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts all characters in the given string to lowercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> lowercases only the letters A to Z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter i with the dotless variant.</p>
<p>Also see <a href="#upcase/2"><code class="inline">upcase/2</code></a> and <a href="#capitalize/2"><code class="inline">capitalize/2</code></a> for other conversions.</p>
<h4 id="downcase/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.downcase("ABCD")
"abcd"

iex&gt; String.downcase("AB 123 XPTO")
"ab 123 xpto"

iex&gt; String.downcase("OLÁ")
"olá"</pre>
<p>The <code class="inline">:ascii</code> mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</p>
<pre data-language="elixir">iex&gt; String.downcase("OLÁ", :ascii)
"olÁ"</pre>
<p>The <code class="inline">:greek</code> mode properly handles the context sensitive sigma in Greek:</p>
<pre data-language="elixir">iex&gt; String.downcase("ΣΣ")
"σσ"

iex&gt; String.downcase("ΣΣ", :greek)
"σς"</pre>
<p>And <code class="inline">:turkic</code> properly handles the letter i with the dotless variant:</p>
<pre data-language="elixir">iex&gt; String.downcase("Iİ")
"ii̇"

iex&gt; String.downcase("Iİ", :turkic)
"ıi"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="duplicate/2">duplicate(subject, n)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1730" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec duplicate(t(), non_neg_integer()) :: t()</pre> </div> <p>Returns a string <code class="inline">subject</code> repeated <code class="inline">n</code> times.</p>
<p>Inlined by the compiler.</p>
<h4 id="duplicate/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.duplicate("abc", 0)
""

iex&gt; String.duplicate("abc", 1)
"abc"

iex&gt; String.duplicate("abc", 2)
"abcabc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="ends_with?/2">ends_with?(string, suffix)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2724" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec ends_with?(t(), t() | [t()]) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string</code> ends with any of the suffixes given.</p>
<p><code class="inline">suffixes</code> can be either a single suffix or a list of suffixes.</p>
<h4 id="ends_with?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.ends_with?("language", "age")
true
iex&gt; String.ends_with?("language", ["youth", "age"])
true
iex&gt; String.ends_with?("language", ["youth", "elixir"])
false</pre>
<p>An empty suffix will always match:</p>
<pre data-language="elixir">iex&gt; String.ends_with?("language", "")
true
iex&gt; String.ends_with?("language", ["", "other"])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="equivalent?/2">equivalent?(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L727" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec equivalent?(t(), t()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string1</code> is canonically equivalent to <code class="inline">string2</code>.</p>
<p>It performs Normalization Form Canonical Decomposition (NFD) on the strings before comparing them. This function is equivalent to:</p>
<pre data-language="elixir">String.normalize(string1, :nfd) == String.normalize(string2, :nfd)</pre>
<p>If you plan to compare multiple strings, multiple times in a row, you may normalize them upfront and compare them directly to avoid multiple normalization passes.</p>
<h4 id="equivalent?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.equivalent?("abc", "abc")
true

iex&gt; String.equivalent?("man\u0303ana", "mañana")
true

iex&gt; String.equivalent?("abc", "ABC")
false

iex&gt; String.equivalent?("nø", "nó")
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="first/1">first(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2161" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec first(t()) :: grapheme() | nil</pre> </div> <p>Returns the first grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p>
<h4 id="first/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.first("elixir")
"e"

iex&gt; String.first("եոգլի")
"ե"

iex&gt; String.first("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="graphemes/1">graphemes(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2079" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec graphemes(t()) :: [grapheme()]</pre> </div> <p>Returns Unicode graphemes in the string as per Extended Grapheme Cluster algorithm.</p>
<p>The algorithm is outlined in the <a href="https://www.unicode.org/reports/tr29/">Unicode Standard Annex #29, Unicode Text Segmentation</a>.</p>
<p>For details about code points and graphemes, see the <a href="string.html"><code class="inline">String</code></a> module documentation.</p>
<h4 id="graphemes/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.graphemes("Ńaïve")
["Ń", "a", "ï", "v", "e"]

iex&gt; String.graphemes("\u00e9")
["é"]

iex&gt; String.graphemes("\u0065\u0301")
["é"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="jaro_distance/2">jaro_distance(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L3096" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec jaro_distance(t(), t()) :: float()</pre> </div> <p>Computes the Jaro distance (similarity) between two strings.</p>
<p>Returns a float value between <code class="inline">0.0</code> (equates to no similarity) and <code class="inline">1.0</code> (is an exact match) representing <a href="https://en.wikipedia.org/wiki/Jaro-Winkler_distance">Jaro</a> distance between <code class="inline">string1</code> and <code class="inline">string2</code>.</p>
<p>The Jaro distance metric is designed and best suited for short strings such as person names. Elixir itself uses this function to provide the "did you mean?" functionality. For instance, when you are calling a function in a module and you have a typo in the function name, we attempt to suggest the most similar function name available, if any, based on the <a href="#jaro_distance/2"><code class="inline">jaro_distance/2</code></a> score.</p>
<h4 id="jaro_distance/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.jaro_distance("Dwayne", "Duane")
0.8222222222222223
iex&gt; String.jaro_distance("even", "odd")
0.0
iex&gt; String.jaro_distance("same", "same")
1.0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="last/1">last(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2188" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec last(t()) :: grapheme() | nil</pre> </div> <p>Returns the last grapheme from a UTF-8 string, <code class="inline">nil</code> if the string is empty.</p>
<p>It traverses the whole string to find its last grapheme.</p>
<h4 id="last/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.last("")
nil

iex&gt; String.last("elixir")
"r"

iex&gt; String.last("եոգլի")
"ի"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="length/1">length(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2209" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec length(t()) :: non_neg_integer()</pre> </div> <p>Returns the number of Unicode graphemes in a UTF-8 string.</p>
<h4 id="length/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.length("elixir")
6

iex&gt; String.length("եոգլի")
5</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="match?/2">match?(string, regex)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2759" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec match?(t(), Regex.t()) :: boolean()</pre> </div> <p>Checks if <code class="inline">string</code> matches the given regular expression.</p>
<h4 id="match?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.match?("foo", ~r/foo/)
true

iex&gt; String.match?("bar", ~r/foo/)
false</pre>
<p>Elixir also provides text-based match operator <a href="kernel.html#=~/2"><code class="inline">=~/2</code></a> and function <a href="regex.html#match?/2"><code class="inline">Regex.match?/2</code></a> as alternatives to test strings against regular expressions.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="myers_difference/2">myers_difference(string1, string2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L3122" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec myers_difference(t(), t()) :: [{:eq | :ins | :del, t()}]</pre> </div> <p>Returns a keyword list that represents an edit script.</p>
<p>Check <a href="list.html#myers_difference/2"><code class="inline">List.myers_difference/2</code></a> for more information.</p>
<h4 id="myers_difference/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; string1 = "fox hops over the dog"
iex&gt; string2 = "fox jumps over the lazy cat"
iex&gt; String.myers_difference(string1, string2)
[eq: "fox ", del: "ho", ins: "jum", eq: "ps over the ", del: "dog", ins: "lazy cat"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_codepoint/1">next_codepoint(arg)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1817" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec next_codepoint(t()) :: {codepoint(), t()} | nil</pre> </div> <p>Returns the next code point in a string.</p>
<p>The result is a tuple with the code point and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p>
<p>As with other functions in the <a href="string.html"><code class="inline">String</code></a> module, <a href="#next_codepoint/1"><code class="inline">next_codepoint/1</code></a> works with binaries that are invalid UTF-8. If the string starts with a sequence of bytes that is not valid in UTF-8 encoding, the first element of the returned tuple is a binary with the first byte.</p>
<h4 id="next_codepoint/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.next_codepoint("olá")
{"o", "lá"}

iex&gt; invalid = "\x80\x80OK" # first two bytes are invalid in UTF-8
iex&gt; {_, rest} = String.next_codepoint(invalid)
{&lt;&lt;128&gt;&gt;, &lt;&lt;128, 79, 75&gt;&gt;}
iex&gt; String.next_codepoint(rest)
{&lt;&lt;128&gt;&gt;, "OK"}</pre>
<h4 id="next_codepoint/1-comparison-with-binary-pattern-matching" class="section-heading">  <span class="text">Comparison with binary pattern matching</span> </h4> <p>Binary pattern matching provides a similar way to decompose a string:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;codepoint::utf8, rest::binary&gt;&gt; = "Elixir"
"Elixir"
iex&gt; codepoint
69
iex&gt; rest
"lixir"</pre>
<p>though not entirely equivalent because <code class="inline">codepoint</code> comes as an integer, and the pattern won't match invalid UTF-8.</p>
<p>Binary pattern matching, however, is simpler and more efficient, so pick the option that better suits your use case.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_grapheme/1">next_grapheme(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2107" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec next_grapheme(t()) :: {grapheme(), t()} | nil</pre> </div> <p>Returns the next grapheme in a string.</p>
<p>The result is a tuple with the grapheme and the remainder of the string or <code class="inline">nil</code> in case the String reached its end.</p>
<h4 id="next_grapheme/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.next_grapheme("olá")
{"o", "lá"}

iex&gt; String.next_grapheme("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="next_grapheme_size/1">next_grapheme_size(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2134" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec next_grapheme_size(t()) :: {pos_integer(), t()} | nil</pre> </div> <p>Returns the size (in bytes) of the next grapheme.</p>
<p>The result is a tuple with the next grapheme size in bytes and the remainder of the string or <code class="inline">nil</code> in case the string reached its end.</p>
<h4 id="next_grapheme_size/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.next_grapheme_size("olá")
{1, "lá"}

iex&gt; String.next_grapheme_size("")
nil</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="normalize/2">normalize(string, form)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L782" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec normalize(t(), :nfd | :nfc | :nfkd | :nfkc) :: t()</pre> </div> <p>Converts all characters in <code class="inline">string</code> to Unicode normalization form identified by <code class="inline">form</code>.</p>
<p>Invalid Unicode codepoints are skipped and the remaining of the string is converted. If you want the algorithm to stop and return on invalid codepoint, use <a href="https://www.erlang.org/doc/apps/stdlib/unicode.html#characters_to_nfd_binary/1"><code class="inline">:unicode.characters_to_nfd_binary/1</code></a>, <a href="https://www.erlang.org/doc/apps/stdlib/unicode.html#characters_to_nfc_binary/1"><code class="inline">:unicode.characters_to_nfc_binary/1</code></a>, <a href="https://www.erlang.org/doc/apps/stdlib/unicode.html#characters_to_nfkd_binary/1"><code class="inline">:unicode.characters_to_nfkd_binary/1</code></a>, and <a href="https://www.erlang.org/doc/apps/stdlib/unicode.html#characters_to_nfkc_binary/1"><code class="inline">:unicode.characters_to_nfkc_binary/1</code></a> instead.</p>
<p>Normalization forms <code class="inline">:nfkc</code> and <code class="inline">:nfkd</code> should not be blindly applied to arbitrary text. Because they erase many formatting distinctions, they will prevent round-trip conversion to and from many legacy character sets.</p>
<h4 id="normalize/2-forms" class="section-heading">  <span class="text">Forms</span> </h4> <p>The supported forms are:</p>
<ul>
<li><p><code class="inline">:nfd</code> - Normalization Form Canonical Decomposition. Characters are decomposed by canonical equivalence, and multiple combining characters are arranged in a specific order.</p></li>
<li><p><code class="inline">:nfc</code> - Normalization Form Canonical Composition. Characters are decomposed and then recomposed by canonical equivalence.</p></li>
<li><p><code class="inline">:nfkd</code> - Normalization Form Compatibility Decomposition. Characters are decomposed by compatibility equivalence, and multiple combining characters are arranged in a specific order.</p></li>
<li><p><code class="inline">:nfkc</code> - Normalization Form Compatibility Composition. Characters are decomposed and then recomposed by compatibility equivalence.</p></li>
</ul>
<h4 id="normalize/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.normalize("yêṩ", :nfd)
"yêṩ"

iex&gt; String.normalize("leña", :nfc)
"leña"

iex&gt; String.normalize("ﬁ", :nfkd)
"fi"

iex&gt; String.normalize("fi", :nfkc)
"fi"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pad_leading/3">pad_leading(string, count, padding \\ [" "])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1366" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pad_leading(t(), non_neg_integer(), t() | [t()]) :: t()</pre> </div> <p>Returns a new string padded with a leading filler which is made of elements from the <code class="inline">padding</code>.</p>
<p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p>
<p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p>
<p>Raises <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains a non-string element.</p>
<h4 id="pad_leading/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.pad_leading("abc", 5)
"  abc"

iex&gt; String.pad_leading("abc", 4, "12")
"1abc"

iex&gt; String.pad_leading("abc", 6, "12")
"121abc"

iex&gt; String.pad_leading("abc", 5, ["1", "23"])
"123abc"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pad_trailing/3">pad_trailing(string, count, padding \\ [" "])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1408" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pad_trailing(t(), non_neg_integer(), t() | [t()]) :: t()</pre> </div> <p>Returns a new string padded with a trailing filler which is made of elements from the <code class="inline">padding</code>.</p>
<p>Passing a list of strings as <code class="inline">padding</code> will take one element of the list for every missing entry. If the list is shorter than the number of inserts, the filling will start again from the beginning of the list. Passing a string <code class="inline">padding</code> is equivalent to passing the list of graphemes in it. If no <code class="inline">padding</code> is given, it defaults to whitespace.</p>
<p>When <code class="inline">count</code> is less than or equal to the length of <code class="inline">string</code>, given <code class="inline">string</code> is returned.</p>
<p>Raises <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> if the given <code class="inline">padding</code> contains a non-string element.</p>
<h4 id="pad_trailing/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.pad_trailing("abc", 5)
"abc  "

iex&gt; String.pad_trailing("abc", 4, "12")
"abc1"

iex&gt; String.pad_trailing("abc", 6, "12")
"abc121"

iex&gt; String.pad_trailing("abc", 5, ["1", "23"])
"abc123"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="printable?/2">printable?(string, character_limit \\ :infinity)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L322" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec printable?(t(), 0) :: true</pre> <pre translate="no" data-language="elixir">@spec printable?(t(), pos_integer() | :infinity) :: boolean()</pre> </div> <p>Checks if a string contains only printable characters up to <code class="inline">character_limit</code>.</p>
<p>Takes an optional <code class="inline">character_limit</code> as a second argument. If <code class="inline">character_limit</code> is <code class="inline">0</code>, this function will return <code class="inline">true</code>.</p>
<h4 id="printable?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.printable?("abc")
true

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;)
false

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;, 2)
true

iex&gt; String.printable?("abc" &lt;&gt; &lt;&lt;0&gt;&gt;, 0)
true</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="replace/4">replace(subject, pattern, replacement, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1562" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace(t(), pattern() | Regex.t(), t() | (t() -&gt; t() | iodata()), keyword()) ::
  t()</pre> </div> <p>Returns a new string created by replacing occurrences of <code class="inline">pattern</code> in <code class="inline">subject</code> with <code class="inline">replacement</code>.</p>
<p>The <code class="inline">subject</code> is always a string.</p>
<p>The <code class="inline">pattern</code> may be a string, a list of strings, a regular expression, or a compiled pattern.</p>
<p>The <code class="inline">replacement</code> may be a string or a function that receives the matched pattern and must return the replacement as a string or iodata.</p>
<p>By default it replaces all occurrences but this behavior can be controlled through the <code class="inline">:global</code> option; see the "Options" section below.</p>
<h4 id="replace/4-options" class="section-heading">  <span class="text">Options</span> </h4> <ul><li>
<code class="inline">:global</code> - (boolean) if <code class="inline">true</code>, all occurrences of <code class="inline">pattern</code> are replaced with <code class="inline">replacement</code>, otherwise only the first occurrence is replaced. Defaults to <code class="inline">true</code>
</li></ul>
<h4 id="replace/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace("a,b,c", ",", "-")
"a-b-c"

iex&gt; String.replace("a,b,c", ",", "-", global: false)
"a-b,c"</pre>
<p>The pattern may also be a list of strings and the replacement may also be a function that receives the matches:</p>
<pre data-language="elixir">iex&gt; String.replace("a,b,c", ["a", "c"], fn &lt;&lt;char&gt;&gt; -&gt; &lt;&lt;char + 1&gt;&gt; end)
"b,b,d"</pre>
<p>When the pattern is a regular expression, one can give <code class="inline">\N</code> or <code class="inline">\g{N}</code> in the <code class="inline">replacement</code> string to access a specific capture in the regular expression:</p>
<pre data-language="elixir">iex&gt; String.replace("a,b,c", ~r/,(.)/, ",\\1\\g{1}")
"a,bb,cc"</pre>
<p>Note that we had to escape the backslash escape character (i.e., we used <code class="inline">\\N</code> instead of just <code class="inline">\N</code> to escape the backslash; same thing for <code class="inline">\\g{N}</code>). By giving <code class="inline">\0</code>, one can inject the whole match in the replacement string.</p>
<p>A compiled pattern can also be given:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern(",")
iex&gt; String.replace("a,b,c", pattern, "[]")
"a[]b[]c"</pre>
<p>When an empty string is provided as a <code class="inline">pattern</code>, the function will treat it as an implicit empty string between each grapheme and the string will be interspersed. If an empty string is provided as <code class="inline">replacement</code> the <code class="inline">subject</code> will be returned:</p>
<pre data-language="elixir">iex&gt; String.replace("ELIXIR", "", ".")
".E.L.I.X.I.R."

iex&gt; String.replace("ELIXIR", "", "")
"ELIXIR"</pre>
<p>Be aware that this function can replace within or across grapheme boundaries. For example, take the grapheme "é" which is made of the characters "e" and the acute accent. The following will replace only the letter "e", moving the accent to the letter "o":</p>
<pre data-language="elixir">iex&gt; String.replace(String.normalize("é", :nfd), "e", "o")
"ó"</pre>
<p>However, if "é" is represented by the single character "e with acute" accent, then it won't be replaced at all:</p>
<pre data-language="elixir">iex&gt; String.replace(String.normalize("é", :nfc), "e", "o")
"é"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="replace_invalid/2">replace_invalid(bytes, replacement \\ "�")<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1925" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_invalid(binary(), t()) :: t()</pre> </div> <p>Returns a new string created by replacing all invalid bytes with <code class="inline">replacement</code> (<code class="inline">"�"</code> by default).</p>
<h4 id="replace_invalid/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace_invalid("asd" &lt;&gt; &lt;&lt;0xFF::8&gt;&gt;)
"asd�"

iex&gt; String.replace_invalid("nem rán bề bề")
"nem rán bề bề"

iex&gt; String.replace_invalid("nem rán b" &lt;&gt; &lt;&lt;225, 187&gt;&gt; &lt;&gt; " bề")
"nem rán b� bề"

iex&gt; String.replace_invalid("nem rán b" &lt;&gt; &lt;&lt;225, 187&gt;&gt; &lt;&gt; " bề", "ERROR!")
"nem rán bERROR! bề"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_leading/3">replace_leading(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1032" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_leading(t(), t(), t()) :: t()</pre> </div> <p>Replaces all leading occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> of <code class="inline">match</code> in <code class="inline">string</code>.</p>
<p>Returns the string untouched if there are no occurrences.</p>
<p>If <code class="inline">match</code> is <code class="inline">""</code>, this function raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> exception: this happens because this function replaces <strong>all</strong> the occurrences of <code class="inline">match</code> at the beginning of <code class="inline">string</code>, and it's impossible to replace "multiple" occurrences of <code class="inline">""</code>.</p>
<h4 id="replace_leading/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace_leading("hello world", "hello ", "")
"world"
iex&gt; String.replace_leading("hello hello world", "hello ", "")
"world"

iex&gt; String.replace_leading("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_leading("hello hello world", "hello ", "ola ")
"ola ola world"</pre>
<p>This function can replace across grapheme boundaries. See <a href="#replace/3"><code class="inline">replace/3</code></a> for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_prefix/3">replace_prefix(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1153" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_prefix(t(), t(), t()) :: t()</pre> </div> <p>Replaces prefix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p>
<p>Returns the string untouched if there is no match. If <code class="inline">match</code> is an empty string (<code class="inline">""</code>), <code class="inline">replacement</code> is just prepended to <code class="inline">string</code>.</p>
<h4 id="replace_prefix/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace_prefix("world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "")
"world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "")
"hello world"

iex&gt; String.replace_prefix("world", "hello ", "ola ")
"world"
iex&gt; String.replace_prefix("hello world", "hello ", "ola ")
"ola world"
iex&gt; String.replace_prefix("hello hello world", "hello ", "ola ")
"ola hello world"

iex&gt; String.replace_prefix("world", "", "hello ")
"hello world"</pre>
<p>This function can replace across grapheme boundaries. See <a href="#replace/3"><code class="inline">replace/3</code></a> for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_suffix/3">replace_suffix(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1195" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_suffix(t(), t(), t()) :: t()</pre> </div> <p>Replaces suffix in <code class="inline">string</code> by <code class="inline">replacement</code> if it matches <code class="inline">match</code>.</p>
<p>Returns the string untouched if there is no match. If <code class="inline">match</code> is an empty string (<code class="inline">""</code>), <code class="inline">replacement</code> is just appended to <code class="inline">string</code>.</p>
<h4 id="replace_suffix/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace_suffix("hello", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world", " world", "")
"hello"
iex&gt; String.replace_suffix("hello world world", " world", "")
"hello world"

iex&gt; String.replace_suffix("hello", " world", " mundo")
"hello"
iex&gt; String.replace_suffix("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_suffix("hello world world", " world", " mundo")
"hello world mundo"

iex&gt; String.replace_suffix("hello", "", " world")
"hello world"</pre>
<p>This function can replace across grapheme boundaries. See <a href="#replace/3"><code class="inline">replace/3</code></a> for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_trailing/3">replace_trailing(string, match, replacement)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1091" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_trailing(t(), t(), t()) :: t()</pre> </div> <p>Replaces all trailing occurrences of <code class="inline">match</code> by <code class="inline">replacement</code> in <code class="inline">string</code>.</p>
<p>Returns the string untouched if there are no occurrences.</p>
<p>If <code class="inline">match</code> is <code class="inline">""</code>, this function raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> exception: this happens because this function replaces <strong>all</strong> the occurrences of <code class="inline">match</code> at the end of <code class="inline">string</code>, and it's impossible to replace "multiple" occurrences of <code class="inline">""</code>.</p>
<h4 id="replace_trailing/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.replace_trailing("hello world", " world", "")
"hello"
iex&gt; String.replace_trailing("hello world world", " world", "")
"hello"

iex&gt; String.replace_trailing("hello world", " world", " mundo")
"hello mundo"
iex&gt; String.replace_trailing("hello world world", " world", " mundo")
"hello mundo mundo"</pre>
<p>This function can replace across grapheme boundaries. See <a href="#replace/3"><code class="inline">replace/3</code></a> for more information and examples.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="reverse/1">reverse(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1698" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reverse(t()) :: t()</pre> </div> <p>Reverses the graphemes in given string.</p>
<h4 id="reverse/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.reverse("abcd")
"dcba"

iex&gt; String.reverse("hello world")
"dlrow olleh"

iex&gt; String.reverse("hello ∂og")
"go∂ olleh"</pre>
<p>Keep in mind reversing the same string twice does not necessarily yield the original string:</p>
<pre data-language="elixir">iex&gt; "̀e"
"̀e"
iex&gt; String.reverse("̀e")
"è"
iex&gt; String.reverse(String.reverse("̀e"))
"è"</pre>
<p>In the first example the accent is before the vowel, so it is considered two graphemes. However, when you reverse it once, you have the vowel followed by the accent, which becomes one grapheme. Reversing it again will keep it as one single grapheme.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/2">slice(string, range)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2411" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slice(t(), Range.t()) :: t()</pre> </div> <p>Returns a substring from the offset given by the start of the range to the offset given by the end of the range.</p>
<p>This function works on Unicode graphemes. For example, slicing the first three characters of the string "héllo" will return "hél", which internally is represented by more than three bytes. Use <a href="#byte_slice/3"><code class="inline">String.byte_slice/3</code></a> if you want to slice by a given number of bytes, while respecting the codepoint boundaries. If you want to work on raw bytes, check <a href="kernel.html#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> or <a href="kernel.html#binary_slice/3"><code class="inline">Kernel.binary_slice/3</code></a> instead.</p>
<p>If the start of the range is not a valid offset for the given string or if the range is in reverse order, returns <code class="inline">""</code>.</p>
<p>If the start or end of the range is negative, the whole string is traversed first in order to convert the negative indices into positive ones.</p>
<h4 id="slice/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.slice("elixir", 1..3)
"lix"
iex&gt; String.slice("elixir", 1..10)
"lixir"

iex&gt; String.slice("elixir", -4..-1)
"ixir"
iex&gt; String.slice("elixir", -4..6)
"ixir"
iex&gt; String.slice("elixir", -100..100)
"elixir"</pre>
<p>For ranges where <code class="inline">start &gt; stop</code>, you need to explicitly mark them as increasing:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 2..-1//1)
"ixir"
iex&gt; String.slice("elixir", 1..-2//1)
"lixi"</pre>
<p>You can use <a href="kernel.html#../0"><code class="inline">../0</code></a> as a shortcut for <code class="inline">0..-1//1</code>, which returns the whole string as is:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", ..)
"elixir"</pre>
<p>The step can be any positive number. For example, to get every 2 characters of the string:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 0..-1//2)
"eii"</pre>
<p>If the first position is after the string ends or after the last position of the range, it returns an empty string:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 10..3//1)
""
iex&gt; String.slice("a", 1..1500)
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/3">slice(string, start, length)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2324" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slice(t(), integer(), non_neg_integer()) :: grapheme()</pre> </div> <p>Returns a substring starting at the offset <code class="inline">start</code>, and of the given <code class="inline">length</code>.</p>
<p>This function works on Unicode graphemes. For example, slicing the first three characters of the string "héllo" will return "hél", which internally is represented by more than three bytes. Use <a href="#byte_slice/3"><code class="inline">String.byte_slice/3</code></a> if you want to slice by a given number of bytes, while respecting the codepoint boundaries. If you want to work on raw bytes, check <a href="kernel.html#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> or <a href="kernel.html#binary_slice/3"><code class="inline">Kernel.binary_slice/3</code></a> instead.</p>
<p>If the offset is greater than string length, then it returns <code class="inline">""</code>.</p>
<h4 id="slice/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.slice("elixir", 1, 3)
"lix"

iex&gt; String.slice("elixir", 1, 10)
"lixir"

iex&gt; String.slice("elixir", 10, 3)
""</pre>
<p>If the start position is negative, it is normalized against the string length and clamped to 0:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", -4, 4)
"ixir"

iex&gt; String.slice("elixir", -10, 3)
"eli"</pre>
<p>If start is more than the string length, an empty string is returned:</p>
<pre data-language="elixir">iex&gt; String.slice("elixir", 10, 1500)
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(binary)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L386" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t()) :: [t()]</pre> </div> <p>Divides a string into substrings at each Unicode whitespace occurrence with leading and trailing whitespace ignored.</p>
<p>Groups of whitespace are treated as a single occurrence. Divisions do not occur on non-breaking whitespace.</p>
<h4 id="split/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.split("foo bar")
["foo", "bar"]

iex&gt; String.split("foo" &lt;&gt; &lt;&lt;194, 133&gt;&gt; &lt;&gt; "bar")
["foo", "bar"]

iex&gt; String.split(" foo   bar ")
["foo", "bar"]

iex&gt; String.split("no\u00a0break")
["no\u00a0break"]</pre>
<p>Removes empty strings, like when using <code class="inline">trim: true</code> in <a href="#split/3"><code class="inline">String.split/3</code></a>.</p>
<pre data-language="elixir">iex&gt; String.split(" ")
[]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="split/3">split(string, pattern, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L493" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t(), pattern() | Regex.t(), keyword()) :: [t()]</pre> </div> <p>Divides a string into parts based on a pattern.</p>
<p>Returns a list of these parts.</p>
<p>The <code class="inline">pattern</code> may be a string, a list of strings, a regular expression, or a compiled pattern.</p>
<p>The string is split into as many parts as possible by default, but can be controlled via the <code class="inline">:parts</code> option.</p>
<p>Empty strings are only removed from the result if the <code class="inline">:trim</code> option is set to <code class="inline">true</code>.</p>
<p>When the pattern used is a regular expression, the string is split using <a href="regex.html#split/3"><code class="inline">Regex.split/3</code></a>.</p>
<p>If the pattern cannot be found, a list containing the original string will be returned.</p>
<h4 id="split/3-options" class="section-heading">  <span class="text">Options</span> </h4> <ul>
<li><p><code class="inline">:parts</code> (positive integer or <code class="inline">:infinity</code>) - the string is split into at most as many parts as this option specifies. If <code class="inline">:infinity</code>, the string will be split into all possible parts. Defaults to <code class="inline">:infinity</code>.</p></li>
<li><p><code class="inline">:trim</code> (boolean) - if <code class="inline">true</code>, empty strings are removed from the resulting list.</p></li>
</ul>
<p>This function also accepts all options accepted by <a href="regex.html#split/3"><code class="inline">Regex.split/3</code></a> if <code class="inline">pattern</code> is a regular expression.</p>
<h4 id="split/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Splitting with a string pattern:</p>
<pre data-language="elixir">iex&gt; String.split("a,b,c", ",")
["a", "b", "c"]

iex&gt; String.split("a,b,c", ",", parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", " ", trim: true)
["a", "b", "c"]</pre>
<p>A list of patterns:</p>
<pre data-language="elixir">iex&gt; String.split("1,2 3,4", [" ", ","])
["1", "2", "3", "4"]</pre>
<p>A regular expression:</p>
<pre data-language="elixir">iex&gt; String.split("a,b,c", ~r{,})
["a", "b", "c"]

iex&gt; String.split("a,b,c", ~r{,}, parts: 2)
["a", "b,c"]

iex&gt; String.split(" a b c ", ~r{\s}, trim: true)
["a", "b", "c"]

iex&gt; String.split("abc", ~r{b}, include_captures: true)
["a", "b", "c"]</pre>
<p>A compiled pattern:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern([" ", ","])
iex&gt; String.split("1,2 3,4", pattern)
["1", "2", "3", "4"]</pre>
<p>Splitting on empty string returns graphemes:</p>
<pre data-language="elixir">iex&gt; String.split("abc", "")
["", "a", "b", "c", ""]

iex&gt; String.split("abc", "", trim: true)
["a", "b", "c"]

iex&gt; String.split("abc", "", parts: 1)
["abc"]

iex&gt; String.split("abc", "", parts: 3)
["", "a", "bc"]</pre>
<p>Splitting on an non-existing pattern returns the original string:</p>
<pre data-language="elixir">iex&gt; String.split("abc", ",")
["abc"]</pre>
<p>Be aware that this function can split within or across grapheme boundaries. For example, take the grapheme "é" which is made of the characters "e" and the acute accent. The following will split the string into two parts:</p>
<pre data-language="elixir">iex&gt; String.split(String.normalize("é", :nfd), "e")
["", "́"]</pre>
<p>However, if "é" is represented by the single character "e with acute" accent, then it will split the string into just one part:</p>
<pre data-language="elixir">iex&gt; String.split(String.normalize("é", :nfc), "e")
["é"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_at/2">split_at(string, position)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L675" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split_at(t(), integer()) :: {t(), t()}</pre> </div> <p>Splits a string into two at the specified offset. When the offset given is negative, location is counted from the end of the string.</p>
<p>The offset is capped to the length of the string. Returns a tuple with two elements.</p>
<section role="note" class="admonition warning"><h4 class="admonition-title warning">Linear Access</h4>
<p>This function splits on graphemes and for such it has to linearly traverse the string. If you want to split a string or a binary based on the number of bytes, use <a href="kernel.html#binary_part/3"><code class="inline">Kernel.binary_part/3</code></a> instead.</p></section><h4 id="split_at/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.split_at("sweetelixir", 5)
{"sweet", "elixir"}

iex&gt; String.split_at("sweetelixir", -6)
{"sweet", "elixir"}

iex&gt; String.split_at("abc", 0)
{"", "abc"}

iex&gt; String.split_at("abc", 1000)
{"abc", ""}

iex&gt; String.split_at("abc", -1000)
{"", "abc"}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="splitter/3">splitter(string, pattern, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L598" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec splitter(t(), pattern(), keyword()) :: Enumerable.t()</pre> </div> <p>Returns an enumerable that splits a string on demand.</p>
<p>This is in contrast to <a href="#split/3"><code class="inline">split/3</code></a> which splits the entire string upfront.</p>
<p>This function does not support regular expressions by design. When using regular expressions, it is often more efficient to have the regular expressions traverse the string at once than in parts, like this function does.</p>
<h4 id="splitter/3-options" class="section-heading">  <span class="text">Options</span> </h4> <ul><li>:trim - when <code class="inline">true</code>, does not emit empty patterns</li></ul>
<h4 id="splitter/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.splitter("1,2 3,4 5,6 7,8,...,99999", [" ", ","]) |&gt; Enum.take(4)
["1", "2", "3", "4"]

iex&gt; String.splitter("abcd", "") |&gt; Enum.take(10)
["", "a", "b", "c", "d", ""]

iex&gt; String.splitter("abcd", "", trim: true) |&gt; Enum.take(10)
["a", "b", "c", "d"]</pre>
<p>A compiled pattern can also be given:</p>
<pre data-language="elixir">iex&gt; pattern = :binary.compile_pattern([" ", ","])
iex&gt; String.splitter("1,2 3,4 5,6 7,8,...,99999", pattern) |&gt; Enum.take(4)
["1", "2", "3", "4"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="starts_with?/2">starts_with?(string, prefix)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2676" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec starts_with?(t(), t() | [t()]) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">string</code> starts with any of the prefixes given.</p>
<p><code class="inline">prefix</code> can be either a string, a list of strings, or a compiled pattern.</p>
<h4 id="starts_with?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.starts_with?("elixir", "eli")
true
iex&gt; String.starts_with?("elixir", ["erlang", "elixir"])
true
iex&gt; String.starts_with?("elixir", ["erlang", "ruby"])
false</pre>
<p>An empty string will always match:</p>
<pre data-language="elixir">iex&gt; String.starts_with?("elixir", "")
true
iex&gt; String.starts_with?("elixir", ["", "other"])
true</pre>
<p>An empty list will never match:</p>
<pre data-language="elixir">iex&gt; String.starts_with?("elixir", [])
false

iex&gt; String.starts_with?("", [])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_atom/1">to_atom(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2896" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_atom(t()) :: atom()</pre> </div> <p>Converts a string to an existing atom or creates a new one.</p>
<p>Warning: this function creates atoms dynamically and atoms are not garbage-collected. Therefore, <code class="inline">string</code> should not be an untrusted value, such as input received from a socket or during a web request. Consider using <a href="#to_existing_atom/1"><code class="inline">to_existing_atom/1</code></a> instead.</p>
<p>By default, the maximum number of atoms is <code class="inline">1_048_576</code>. This limit can be raised or lowered using the VM option <code class="inline">+t</code>.</p>
<p>The maximum atom size is of 255 Unicode code points.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_atom/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.to_atom("my_atom")
:my_atom</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_charlist/1">to_charlist(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2861" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_charlist(t()) :: charlist()</pre> </div> <p>Converts a string into a charlist.</p>
<p>Specifically, this function takes a UTF-8 encoded binary and returns a list of its integer code points. It is similar to <a href="#codepoints/1"><code class="inline">codepoints/1</code></a> except that the latter returns a list of code points as strings.</p>
<p>In case you need to work with bytes, take a look at the <a href="https://www.erlang.org/doc/apps/stdlib/binary.html"><code class="inline">:binary</code> module</a>.</p>
<h4 id="to_charlist/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.to_charlist("foo")
~c"foo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_existing_atom/1">to_existing_atom(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2929" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_existing_atom(t()) :: atom()</pre> </div> <p>Converts a string to an existing atom or raises if the atom does not exist.</p>
<p>The maximum atom size is of 255 Unicode code points. Raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> if the atom does not exist.</p>
<p>Inlined by the compiler.</p>
<section role="note" class="admonition info"><h4 class="admonition-title info">Atoms and modules</h4>
<p>Since Elixir is a compiled language, the atoms defined in a module will only exist after said module is loaded, which typically happens whenever a function in the module is executed. Therefore, it is generally recommended to call <a href="#to_existing_atom/1"><code class="inline">String.to_existing_atom/1</code></a> only to convert atoms defined within the module making the function call to <a href="#to_existing_atom/1"><code class="inline">to_existing_atom/1</code></a>.</p>
<p>To create a module name itself from a string safely, it is recommended to use <a href="module.html#safe_concat/1"><code class="inline">Module.safe_concat/1</code></a>.</p></section><h4 id="to_existing_atom/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; _ = :my_atom
iex&gt; String.to_existing_atom("my_atom")
:my_atom</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_float/1">to_float(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L3000" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_float(t()) :: float()</pre> </div> <p>Returns a float whose text representation is <code class="inline">string</code>.</p>
<p><code class="inline">string</code> must be the string representation of a float including leading digits and a decimal point. To parse a string without decimal point as a float, refer to <a href="float.html#parse/1"><code class="inline">Float.parse/1</code></a>. Otherwise, an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> will be raised.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_float/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.to_float("2.2017764e+0")
2.2017764

iex&gt; String.to_float("3.0")
3.0

String.to_float("3")
** (ArgumentError) argument error

String.to_float(".3")
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/1">to_integer(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2955" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_integer(t()) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">string</code>.</p>
<p><code class="inline">string</code> must be the string representation of an integer. Otherwise, an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> will be raised. If you want to parse a string that may contain an ill-formatted integer, use <a href="integer.html#parse/1"><code class="inline">Integer.parse/1</code></a>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_integer/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.to_integer("123")
123</pre>
<p>Passing a string that does not represent an integer leads to an error:</p>
<pre data-language="elixir">String.to_integer("invalid data")
** (ArgumentError) argument error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_integer/2">to_integer(string, base)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L2971" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_integer(t(), 2..36) :: integer()</pre> </div> <p>Returns an integer whose text representation is <code class="inline">string</code> in base <code class="inline">base</code>.</p>
<p>Inlined by the compiler.</p>
<h4 id="to_integer/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.to_integer("3FF", 16)
1023</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim/1">trim(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1312" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim(t()) :: t()</pre> </div> <p>Returns a string where all leading and trailing Unicode whitespaces have been removed.</p>
<h4 id="trim/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim("\n  abc\n  ")
"abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim/2">trim(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1329" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim(t(), t()) :: t()</pre> </div> <p>Returns a string where all leading and trailing <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim("a  abc  a", "a")
"  abc  "</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_leading/1">trim_leading(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1250" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim_leading(t()) :: t()</pre> </div> <p>Returns a string where all leading Unicode whitespaces have been removed.</p>
<h4 id="trim_leading/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim_leading("\n  abc   ")
"abc   "</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_leading/2">trim_leading(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1265" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim_leading(t(), t()) :: t()</pre> </div> <p>Returns a string where all leading <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim_leading/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim_leading("__ abc _", "_")
" abc _"

iex&gt; String.trim_leading("1 abc", "11")
"1 abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_trailing/1">trim_trailing(string)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1281" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim_trailing(t()) :: t()</pre> </div> <p>Returns a string where all trailing Unicode whitespaces has been removed.</p>
<h4 id="trim_trailing/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim_trailing("   abc\n  ")
"   abc"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="trim_trailing/2">trim_trailing(string, to_trim)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1296" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec trim_trailing(t(), t()) :: t()</pre> </div> <p>Returns a string where all trailing <code class="inline">to_trim</code> characters have been removed.</p>
<h4 id="trim_trailing/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.trim_trailing("_ abc __", "_")
"_ abc "

iex&gt; String.trim_trailing("abc 1", "11")
"abc 1"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="upcase/2">upcase(string, mode \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec upcase(t(), :default | :ascii | :greek | :turkic) :: t()</pre> </div> <p>Converts all characters in the given string to uppercase according to <code class="inline">mode</code>.</p>
<p><code class="inline">mode</code> may be <code class="inline">:default</code>, <code class="inline">:ascii</code>, <code class="inline">:greek</code> or <code class="inline">:turkic</code>. The <code class="inline">:default</code> mode considers all non-conditional transformations outlined in the Unicode standard. <code class="inline">:ascii</code> uppercases only the letters a to z. <code class="inline">:greek</code> includes the context sensitive mappings found in Greek. <code class="inline">:turkic</code> properly handles the letter i with the dotless variant.</p>
<h4 id="upcase/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.upcase("abcd")
"ABCD"

iex&gt; String.upcase("ab 123 xpto")
"AB 123 XPTO"

iex&gt; String.upcase("olá")
"OLÁ"</pre>
<p>The <code class="inline">:ascii</code> mode ignores Unicode characters and provides a more performant implementation when you know the string contains only ASCII characters:</p>
<pre data-language="elixir">iex&gt; String.upcase("olá", :ascii)
"OLá"</pre>
<p>And <code class="inline">:turkic</code> properly handles the letter i with the dotless variant:</p>
<pre data-language="elixir">iex&gt; String.upcase("ıi")
"II"

iex&gt; String.upcase("ıi", :turkic)
"Iİ"</pre>
<p>Also see <a href="#downcase/2"><code class="inline">downcase/2</code></a> and <a href="#capitalize/2"><code class="inline">capitalize/2</code></a> for other conversions.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="valid?/2">valid?(string, algorithm \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/string.ex#L1867" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec valid?(t(), :default | :fast_ascii) :: boolean()</pre> </div> <p>Checks whether <code class="inline">string</code> contains only valid characters.</p>
<p><code class="inline">algorithm</code> may be <code class="inline">:default</code> or <code class="inline">:fast_ascii</code>. Both algorithms are equivalent from a validation perspective (they will always produce the same output), but <code class="inline">:fast_ascii</code> can yield significant performance benefits in specific scenarios.</p>
<p>If all of the following conditions are true, you may want to experiment with the <code class="inline">:fast_ascii</code> algorithm to see if it yields performance benefits in your specific scenario:</p>
<ul>
<li>You are running Erlang/OTP 26 or newer on a 64 bit platform</li>
<li>You expect most of your strings to be longer than ~64 bytes</li>
<li>You expect most of your strings to contain mostly ASCII codepoints</li>
</ul>
<p>Note that the <code class="inline">:fast_ascii</code> algorithm does not affect correctness, you can expect the output of <a href="#valid?/2"><code class="inline">String.valid?/2</code></a> to be the same regardless of algorithm. The only difference to be expected is one of performance, which can be expected to improve roughly linearly in string length compared to the <code class="inline">:default</code> algorithm.</p>
<h4 id="valid?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; String.valid?("a")
true

iex&gt; String.valid?("ø")
true

iex&gt; String.valid?(&lt;&lt;0xFFFF::16&gt;&gt;)
false

iex&gt; String.valid?(&lt;&lt;0xEF, 0xB7, 0x90&gt;&gt;)
true

iex&gt; String.valid?("asd" &lt;&gt; &lt;&lt;0xFFFF::16&gt;&gt;)
false

iex&gt; String.valid?("a", :fast_ascii)
true

iex&gt; String.valid?(4)
** (FunctionClauseError) no function clause matching in String.valid?/2</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/String.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/String.html</a>
  </p>
</div>
