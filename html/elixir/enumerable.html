<h1>   <span translate="no">Enumerable</span> <small>protocol</small>  </h1> <section id="moduledoc"> <p>Enumerable protocol used by <a href="enum.html"><code class="inline">Enum</code></a> and <a href="stream.html"><code class="inline">Stream</code></a> modules.</p>
<p>When you invoke a function in the <a href="enum.html"><code class="inline">Enum</code></a> module, the first argument is usually a collection that must implement this protocol. For example, the expression <code class="inline">Enum.map([1, 2, 3], &amp;(&amp;1 * 2))</code> invokes <a href="#reduce/3"><code class="inline">Enumerable.reduce/3</code></a> to perform the reducing operation that builds a mapped list by calling the mapping function <code class="inline">&amp;(&amp;1 * 2)</code> on every element in the collection and consuming the element with an accumulated list.</p>
<p>Internally, <a href="enum.html#map/2"><code class="inline">Enum.map/2</code></a> is implemented as follows:</p>
<pre data-language="elixir">def map(enumerable, fun) do
  reducer = fn x, acc -&gt; {:cont, [fun.(x) | acc]} end
  Enumerable.reduce(enumerable, {:cont, []}, reducer) |&gt; elem(1) |&gt; :lists.reverse()
end</pre>
<p>Note that the user-supplied function is wrapped into a <a href="#t:reducer/0"><code class="inline">reducer/0</code></a> function. The <a href="#t:reducer/0"><code class="inline">reducer/0</code></a> function must return a tagged tuple after each step, as described in the <a href="#t:acc/0"><code class="inline">acc/0</code></a> type. At the end, <a href="#reduce/3"><code class="inline">Enumerable.reduce/3</code></a> returns <a href="#t:result/0"><code class="inline">result/0</code></a>.</p>
<p>This protocol uses tagged tuples to exchange information between the reducer function and the data type that implements the protocol. This allows enumeration of resources, such as files, to be done efficiently while also guaranteeing the resource will be closed at the end of the enumeration. This protocol also allows suspension of the enumeration, which is useful when interleaving between many enumerables is required (as in the <code class="inline">zip/1</code> and <code class="inline">zip/2</code> functions).</p>
<p>This protocol requires four functions to be implemented, <a href="#reduce/3"><code class="inline">reduce/3</code></a>, <a href="#count/1"><code class="inline">count/1</code></a>, <a href="#member?/2"><code class="inline">member?/2</code></a>, and <a href="#slice/1"><code class="inline">slice/1</code></a>. The core of the protocol is the <a href="#reduce/3"><code class="inline">reduce/3</code></a> function. All other functions exist as optimizations paths for data structures that can implement certain properties in better than linear time.</p> </section> <section id="summary" class="details-list">  <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:acc/0" translate="no">acc()</a> </dt> <dd class="summary-synopsis"><p>The accumulator value for each step.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:continuation/0" translate="no">continuation()</a> </dt> <dd class="summary-synopsis"><p>A partially applied reduce function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:reducer/0" translate="no">reducer()</a> </dt> <dd class="summary-synopsis"><p>The reducer function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:result/0" translate="no">result()</a> </dt> <dd class="summary-synopsis"><p>The result of the reduce operation.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:slicing_fun/0" translate="no">slicing_fun()</a> </dt> <dd class="summary-synopsis"><p>A slicing function that receives the initial position, the number of elements in the slice, and the step.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>All the types that implement this protocol.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/1" translate="no">t(_element)</a> </dt> <dd class="summary-synopsis"><p>An enumerable of elements of type <code class="inline">element</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:to_list_fun/0" translate="no">to_list_fun()</a> </dt> <dd class="summary-synopsis"><p>Receives an enumerable and returns a list.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#count/1" translate="no">count(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Retrieves the number of elements in the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#member?/2" translate="no">member?(enumerable, element)</a> </dt> <dd class="summary-synopsis"><p>Checks if an <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reduce/3" translate="no">reduce(enumerable, acc, fun)</a> </dt> <dd class="summary-synopsis"><p>Reduces the <code class="inline">enumerable</code> into an element.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#slice/1" translate="no">slice(enumerable)</a> </dt> <dd class="summary-synopsis"><p>Returns a function that slices the data structure contiguously.</p></dd> </div> </dl> </section> <section id="types" class="details-list">  <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:acc/0">acc()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L73" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type acc() :: {:cont, term()} | {:halt, term()} | {:suspend, term()}</pre> </div> <p>The accumulator value for each step.</p>
<p>It must be a tagged tuple with one of the following "tags":</p>
<ul>
<li>
<code class="inline">:cont</code> - the enumeration should continue</li>
<li>
<code class="inline">:halt</code> - the enumeration should halt immediately</li>
<li>
<code class="inline">:suspend</code> - the enumeration should be suspended immediately</li>
</ul>
<p>Depending on the accumulator value, the result returned by <a href="#reduce/3"><code class="inline">Enumerable.reduce/3</code></a> will change. Please check the <a href="#t:result/0"><code class="inline">result/0</code></a> type documentation for more information.</p>
<p>In case a <a href="#t:reducer/0"><code class="inline">reducer/0</code></a> function returns a <code class="inline">:suspend</code> accumulator, it must be explicitly handled by the caller and never leak.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:continuation/0">continuation()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L122" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type continuation() :: (acc() -&gt; result())</pre> </div> <p>A partially applied reduce function.</p>
<p>The continuation is the closure returned as a result when the enumeration is suspended. When invoked, it expects a new accumulator and it returns the result.</p>
<p>A continuation can be trivially implemented as long as the reduce function is defined in a tail recursive fashion. If the function is tail recursive, all the state is passed as arguments, so the continuation is the reducing function partially applied.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:reducer/0">reducer()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L83" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type reducer() :: (element :: term(), current_acc :: acc() -&gt; updated_acc :: acc())</pre> </div> <p>The reducer function.</p>
<p>Should be called with the <code class="inline">enumerable</code> element and the accumulator contents.</p>
<p>Returns the accumulator for the next enumeration step.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:result/0">result()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L105" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type result() ::
  {:done, term()} | {:halted, term()} | {:suspended, term(), continuation()}</pre> </div> <p>The result of the reduce operation.</p>
<p>It may be <em>done</em> when the enumeration is finished by reaching its end, or <em>halted</em>/<em>suspended</em> when the enumeration was halted or suspended by the tagged accumulator.</p>
<p>In case the tagged <code class="inline">:halt</code> accumulator is given, the <code class="inline">:halted</code> tuple with the accumulator must be returned. Functions like <a href="enum.html#take_while/2"><code class="inline">Enum.take_while/2</code></a> use <code class="inline">:halt</code> underneath and can be used to test halting enumerables.</p>
<p>In case the tagged <code class="inline">:suspend</code> accumulator is given, the caller must return the <code class="inline">:suspended</code> tuple with the accumulator and a continuation. The caller is then responsible of managing the continuation and the caller must always call the continuation, eventually halting or continuing until the end. <a href="enum.html#zip/2"><code class="inline">Enum.zip/2</code></a> uses suspension, so it can be used to test whether your implementation handles suspension correctly. You can also use <a href="stream.html#zip/2"><code class="inline">Stream.zip/2</code></a> with <a href="enum.html#take_while/2"><code class="inline">Enum.take_while/2</code></a> to test the combination of <code class="inline">:suspend</code> with <code class="inline">:halt</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:slicing_fun/0">slicing_fun()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L136" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type slicing_fun() ::
  (start :: non_neg_integer(), length :: pos_integer(), step :: pos_integer() -&gt;
     [term()])</pre> </div> <p>A slicing function that receives the initial position, the number of elements in the slice, and the step.</p>
<p>The <code class="inline">start</code> position is a number <code class="inline">&gt;= 0</code> and guaranteed to exist in the <code class="inline">enumerable</code>. The length is a number <code class="inline">&gt;= 1</code> in a way that <code class="inline">start + length * step &lt;= count</code>, where <code class="inline">count</code> is the maximum amount of elements in the enumerable.</p>
<p>The function should return a non empty list where the amount of elements is equal to <code class="inline">length</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L1" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: term()</pre> </div> <p>All the types that implement this protocol.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/1">t(_element)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L55" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t(_element) :: t()</pre> </div> <p>An enumerable of elements of type <code class="inline">element</code>.</p>
<p>This type is equivalent to <a href="#t:t/0"><code class="inline">t/0</code></a> but is especially useful for documentation.</p>
<p>For example, imagine you define a function that expects an enumerable of integers and returns an enumerable of strings:</p>
<pre data-language="elixir">@spec integers_to_strings(Enumerable.t(integer())) :: Enumerable.t(String.t())
def integers_to_strings(integers) do
  Stream.map(integers, &amp;Integer.to_string/1)
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:to_list_fun/0">to_list_fun()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L142" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type to_list_fun() :: (t() -&gt; [term()])</pre> </div> <p>Receives an enumerable and returns a list.</p> </section> </section> </div> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="count/1">count(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L178" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec count(t()) :: {:ok, non_neg_integer()} | {:error, module()}</pre> </div> <p>Retrieves the number of elements in the <code class="inline">enumerable</code>.</p>
<p>It should return <code class="inline">{:ok, count}</code> if you can count the number of elements in <code class="inline">enumerable</code> in a faster way than fully traversing it.</p>
<p>Otherwise it should return <code class="inline">{:error, __MODULE__}</code> and a default algorithm built on top of <a href="#reduce/3"><code class="inline">reduce/3</code></a> that runs in linear time will be used.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="member?/2">member?(enumerable, element)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L194" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec member?(t(), term()) :: {:ok, boolean()} | {:error, module()}</pre> </div> <p>Checks if an <code class="inline">element</code> exists within the <code class="inline">enumerable</code>.</p>
<p>It should return <code class="inline">{:ok, boolean}</code> if you can check the membership of a given element in <code class="inline">enumerable</code> with <a href="kernel.html#===/2"><code class="inline">===/2</code></a> without traversing the whole of it.</p>
<p>Otherwise it should return <code class="inline">{:error, __MODULE__}</code> and a default algorithm built on top of <a href="#reduce/3"><code class="inline">reduce/3</code></a> that runs in linear time will be used.</p>
<p>When called outside guards, the <a href="kernel.html#in/2"><code class="inline">in</code></a> and <a href="kernel.html#in/2"><code class="inline">not in</code></a> operators work by using this function.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="reduce/3">reduce(enumerable, acc, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L166" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reduce(t(), acc(), reducer()) :: result()</pre> </div> <p>Reduces the <code class="inline">enumerable</code> into an element.</p>
<p>Most of the operations in <a href="enum.html"><code class="inline">Enum</code></a> are implemented in terms of reduce. This function should apply the given <a href="#t:reducer/0"><code class="inline">reducer/0</code></a> function to each element in the <code class="inline">enumerable</code> and proceed as expected by the returned accumulator.</p>
<p>See the documentation of the types <a href="#t:result/0"><code class="inline">result/0</code></a> and <a href="#t:acc/0"><code class="inline">acc/0</code></a> for more information.</p>
<h4 id="reduce/3-examples" class="section-heading"> <a href="#reduce/3-examples">  Examples </a> </h4> <p>As an example, here is the implementation of <code class="inline">reduce</code> for lists:</p>
<pre data-language="elixir">def reduce(_list, {:halt, acc}, _fun), do: {:halted, acc}
def reduce(list, {:suspend, acc}, fun), do: {:suspended, acc, &amp;reduce(list, &amp;1, fun)}
def reduce([], {:cont, acc}, _fun), do: {:done, acc}
def reduce([head | tail], {:cont, acc}, fun), do: reduce(tail, fun.(head, acc), fun)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="slice/1">slice(enumerable)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/enum.ex#L230" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec slice(t()) ::
  {:ok, size :: non_neg_integer(), slicing_fun() | to_list_fun()}
  | {:error, module()}</pre> </div> <p>Returns a function that slices the data structure contiguously.</p>
<p>It should return either:</p>
<ul>
<li><p><code class="inline">{:ok, size, slicing_fun}</code> - if the <code class="inline">enumerable</code> has a known bound and can access a position in the <code class="inline">enumerable</code> without traversing all previous elements. The <code class="inline">slicing_fun</code> will receive a <code class="inline">start</code> position, the <code class="inline">amount</code> of elements to fetch, and a <code class="inline">step</code>.</p></li>
<li><p><code class="inline">{:ok, size, to_list_fun}</code> - if the <code class="inline">enumerable</code> has a known bound and can access a position in the <code class="inline">enumerable</code> by first converting it to a list via <code class="inline">to_list_fun</code>.</p></li>
<li><p><code class="inline">{:error, __MODULE__}</code> - the enumerable cannot be sliced efficiently and a default algorithm built on top of <a href="#reduce/3"><code class="inline">reduce/3</code></a> that runs in linear time will be used.</p></li>
</ul>
<h4 id="slice/1-differences-to-count-1" class="section-heading"> <a href="#slice/1-differences-to-count-1">  Differences to </a><a href="#count/1"><code class="inline">count/1</code></a> </h4> <p>The <code class="inline">size</code> value returned by this function is used for boundary checks, therefore it is extremely important that this function only returns <code class="inline">:ok</code> if retrieving the <code class="inline">size</code> of the <code class="inline">enumerable</code> is cheap, fast, and takes constant time. Otherwise the simplest of operations, such as <code class="inline">Enum.at(enumerable, 0)</code>, will become too expensive.</p>
<p>On the other hand, the <a href="#count/1"><code class="inline">count/1</code></a> function in this protocol should be implemented whenever you can count the number of elements in the collection without traversing it.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.15.4/Enumerable.html" class="_attribution-link">https://hexdocs.pm/elixir/1.15.4/Enumerable.html</a>
  </p>
</div>
