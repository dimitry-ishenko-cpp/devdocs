<h1>   <span translate="no">Inspect</span> <small>protocol</small>  </h1> <section id="moduledoc"> <p>The <a href="inspect.html#content"><code class="inline">Inspect</code></a> protocol converts an Elixir data structure into an algebra document.</p>
<p>This is typically done when you want to customize how your own structs are inspected in logs and the terminal.</p>
<p>This documentation refers to implementing the <a href="inspect.html#content"><code class="inline">Inspect</code></a> protocol for your own data structures. To learn more about using inspect, see <a href="kernel.html#inspect/2"><code class="inline">Kernel.inspect/2</code></a> and <a href="io.html#inspect/2"><code class="inline">IO.inspect/2</code></a>.</p>
<h2 id="module-inspect-representation" class="section-heading"> <a href="#module-inspect-representation">  Inspect representation </a> </h2> <p>There are typically three choices of inspect representation. In order to understand them, let's imagine we have the following <code class="inline">User</code> struct:</p>
<pre data-language="elixir">defmodule User do
  defstruct [:id, :name, :address]
end</pre>
<p>Our choices are:</p>
<ol>
<li><p>Print the struct using Elixir's struct syntax, for example: <code class="inline">%User{address: "Earth", id: 13, name: "Jane"}</code>. This is the default representation and best choice if all struct fields are public.</p></li>
<li><p>Print using the <code class="inline">#User&lt;...&gt;</code> notation, for example: <code class="inline">#User&lt;id: 13, name: "Jane", ...&gt;</code>. This notation does not emit valid Elixir code and is typically used when the struct has private fields (for example, you may want to hide the field <code class="inline">:address</code> to redact person identifiable information).</p></li>
<li><p>Print the struct using the expression syntax, for example: <code class="inline">User.new(13, "Jane", "Earth")</code>. This assumes there is a <code class="inline">User.new/3</code> function. This option is mostly used as an alternative to option 2 for representing custom data structures, such as <a href="mapset.html"><code class="inline">MapSet</code></a>, <a href="date.range.html"><code class="inline">Date.Range</code></a>, and others.</p></li>
</ol>
<p>You can implement the Inspect protocol for your own structs while adhering to the conventions above. Option 1 is the default representation and you can quickly achieve option 2 by deriving the <a href="inspect.html#content"><code class="inline">Inspect</code></a> protocol. For option 3, you need your custom implementation.</p>
<h2 id="module-deriving" class="section-heading"> <a href="#module-deriving">  Deriving </a> </h2> <p>The <a href="inspect.html#content"><code class="inline">Inspect</code></a> protocol can be derived to customize the order of fields (the default is alphabetical) and hide certain fields from structs, so they don't show up in logs, inspects and similar. The latter is especially useful for fields containing private information.</p>
<p>The supported options are:</p>
<ul>
<li><p><code class="inline">:only</code> - only include the given fields when inspecting.</p></li>
<li><p><code class="inline">:except</code> - remove the given fields when inspecting.</p></li>
<li><p><code class="inline">:optional</code> - (since v1.14.0) do not include a field if it matches its default value. This can be used to simplify the struct representation at the cost of hiding information.</p></li>
</ul>
<p>Whenever <code class="inline">:only</code> or <code class="inline">:except</code> are used to restrict fields, the struct will be printed using the <code class="inline">#User&lt;...&gt;</code> notation, as the struct can no longer be copy and pasted as valid Elixir code. Let's see an example:</p>
<pre data-language="elixir">defmodule User do
  @derive {Inspect, only: [:id, :name]}
  defstruct [:id, :name, :address]
end

inspect(%User{id: 1, name: "Jane", address: "Earth"})
#=&gt; #User&lt;id: 1, name: "Jane", ...&gt;</pre>
<p>If you use only the <code class="inline">:optional</code> option, the struct will still be printed as <code class="inline">%User{...}</code>.</p>
<h2 id="module-custom-implementation" class="section-heading"> <a href="#module-custom-implementation">  Custom implementation </a> </h2> <p>You can also define your custom protocol implementation by defining the <a href="#inspect/2"><code class="inline">inspect/2</code></a> function. The function receives the entity to be inspected followed by the inspecting options, represented by the struct <a href="inspect.opts.html"><code class="inline">Inspect.Opts</code></a>. Building of the algebra document is done with <a href="inspect.algebra.html"><code class="inline">Inspect.Algebra</code></a>.</p>
<p>Many times, inspecting a structure can be implemented in function of existing entities. For example, here is <a href="mapset.html"><code class="inline">MapSet</code></a>'s <a href="#inspect/2"><code class="inline">inspect/2</code></a> implementation:</p>
<pre data-language="elixir">defimpl Inspect, for: MapSet do
  import Inspect.Algebra

  def inspect(map_set, opts) do
    concat(["MapSet.new(", Inspect.List.inspect(MapSet.to_list(map_set), opts), ")"])
  end
end</pre>
<p>The <a href="inspect.algebra.html#concat/1"><code class="inline">concat/1</code></a> function comes from <a href="inspect.algebra.html"><code class="inline">Inspect.Algebra</code></a> and it concatenates algebra documents together. In the example above it is concatenating the string <code class="inline">"MapSet.new("</code>, the document returned by <a href="inspect.algebra.html#to_doc/2"><code class="inline">Inspect.Algebra.to_doc/2</code></a>, and the final string <code class="inline">")"</code>. Therefore, the MapSet with the numbers 1, 2, and 3 will be printed as:</p>
<pre data-language="elixir">iex&gt; MapSet.new([1, 2, 3], fn x -&gt; x * 2 end)
MapSet.new([2, 4, 6])</pre>
<p>In other words, <a href="mapset.html"><code class="inline">MapSet</code></a>'s inspect representation returns an expression that, when evaluated, builds the <a href="mapset.html"><code class="inline">MapSet</code></a> itself.</p>
<h3 id="module-error-handling" class="section-heading"> <a href="#module-error-handling">  Error handling </a> </h3> <p>In case there is an error while your structure is being inspected, Elixir will raise an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> error and will automatically fall back to a raw representation for printing the structure.</p>
<p>You can, however, access the underlying error by invoking the <a href="inspect.html#content"><code class="inline">Inspect</code></a> implementation directly. For example, to test <a href="inspect.mapset.html"><code class="inline">Inspect.MapSet</code></a> above, you can invoke it as:</p>
<pre data-language="elixir">Inspect.MapSet.inspect(MapSet.new(), %Inspect.Opts{})</pre> </section> <section id="summary" class="details-list">  <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>All the types that implement this protocol.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#inspect/2" translate="no">inspect(term, opts)</a> </dt> <dd class="summary-synopsis"><p>Converts <code class="inline">term</code> into an algebra document.</p></dd> </div> </dl> </section> <section id="types" class="details-list">  <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/inspect.ex#L6" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: term()</pre> </div> <p>All the types that implement this protocol.</p> </section> </section> </div> </section> <section id="functions" class="details-list">  <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="inspect/2">inspect(term, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.15.4/lib/elixir/lib/inspect.ex#L142" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec inspect(t(), Inspect.Opts.t()) :: Inspect.Algebra.t()</pre> </div> <p>Converts <code class="inline">term</code> into an algebra document.</p>
<p>This function shouldn't be invoked directly, unless when implementing a custom <code class="inline">inspect_fun</code> to be given to <a href="inspect.opts.html"><code class="inline">Inspect.Opts</code></a>. Everywhere else, <a href="inspect.algebra.html#to_doc/2"><code class="inline">Inspect.Algebra.to_doc/2</code></a> should be preferred as it handles structs and exceptions.</p> </section> </section> </div> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.15.4/Inspect.html" class="_attribution-link">https://hexdocs.pm/elixir/1.15.4/Inspect.html</a>
  </p>
</div>
