<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Mix</span>  </h1> <section id="moduledoc"> <p>Mix is a build tool that provides tasks for creating, compiling, and testing Elixir projects, managing its dependencies, and more.</p>
<h2 id="module-mix-project" class="section-heading">  <span class="text"><a href="mix.project.html"><code class="inline">Mix.Project</code></a></span> </h2> <p>The foundation of Mix is a project. A project can be defined by using <a href="mix.project.html"><code class="inline">Mix.Project</code></a> in a module, usually placed in a file named <code class="inline">mix.exs</code>:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0"
    ]
  end
end</pre>
<p>See the <a href="mix.project.html"><code class="inline">Mix.Project</code></a> module for detailed documentation on Mix projects.</p>
<p>Once the project is defined, a number of default Mix tasks can be run directly from the command line:</p>
<ul>
<li>
<a href="mix.tasks.compile.html"><code class="inline">mix compile</code></a> - compiles the current project</li>
<li>
<a href="mix.tasks.test.html"><code class="inline">mix test</code></a> - runs tests for the given project</li>
<li>
<a href="mix.tasks.run.html"><code class="inline">mix run</code></a> - runs a particular command inside the project</li>
</ul>
<p>Each task has its own options and sometimes specific configuration to be defined in the <code class="inline">project/0</code> function. You can use <a href="mix.tasks.help.html"><code class="inline">mix help</code></a> to list all available tasks and <code class="inline">mix help NAME</code> to show help for a particular task.</p>
<p>The best way to get started with your first project is by calling <code class="inline">mix new my_project</code> from the command line.</p>
<h2 id="module-mix-task" class="section-heading">  <span class="text"><a href="mix.task.html"><code class="inline">Mix.Task</code></a></span> </h2> <p>Tasks are what make Mix extensible.</p>
<p>Projects can extend Mix behaviour by adding their own tasks. For example, adding the task below inside your project will make it available to everyone that uses your project:</p>
<pre data-language="elixir">defmodule Mix.Tasks.Hello do
  use Mix.Task

  def run(_) do
    Mix.shell().info("Hello world")
  end
end</pre>
<p>The task can now be invoked with <code class="inline">mix hello</code>.</p>
<p>See the <a href="mix.task.html"><code class="inline">Mix.Task</code></a> behaviour for detailed documentation on Mix tasks.</p>
<h2 id="module-dependencies" class="section-heading">  <span class="text">Dependencies</span> </h2> <p>Mix also manages your dependencies and integrates nicely with the <a href="https://hex.pm">Hex package manager</a>.</p>
<p>In order to use dependencies, you need to add a <code class="inline">:deps</code> key to your project configuration. We often extract the list of dependencies into its own function:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0",
      deps: deps()
    ]
  end

  defp deps do
    [
      {:ecto, "~&gt; 2.0"},
      {:plug, github: "elixir-lang/plug"}
    ]
  end
end</pre>
<p>You can run <a href="mix.tasks.deps.html"><code class="inline">mix help deps</code></a> to learn more about dependencies in Mix.</p>
<h2 id="module-environments" class="section-heading">  <span class="text">Environments</span> </h2> <p>Mix supports different environments. Environments allow developers to prepare and organize their project specifically for different scenarios. By default, Mix provides three environments:</p>
<ul>
<li>
<code class="inline">:dev</code> - the default environment</li>
<li>
<code class="inline">:test</code> - the environment <a href="mix.tasks.test.html"><code class="inline">mix test</code></a> runs on</li>
<li>
<code class="inline">:prod</code> - the environment your dependencies run on</li>
</ul>
<p>The environment can be changed via the command line by setting the <code class="inline">MIX_ENV</code> environment variable, for example:</p>
<pre data-language="elixir">$ MIX_ENV=prod mix run server.exs
</pre>
<p>You can also specify that certain dependencies are available only for certain environments:</p>
<pre data-language="elixir">{:some_test_dependency, "~&gt; 1.0", only: :test}</pre>
<p>When running Mix via the command line, you can configure the default environment or the preferred environment per task via the <code class="inline">def cli</code> function in your <code class="inline">mix.exs</code>. For example:</p>
<pre data-language="elixir">def cli do
  [
    default_env: :local,
    preferred_envs: [docs: :docs]
  ]
end</pre>
<p>The environment can be read via <a href="#env/0"><code class="inline">Mix.env/0</code></a>.</p>
<h2 id="module-targets" class="section-heading">  <span class="text">Targets</span> </h2> <p>Besides environments, Mix supports targets. Targets are useful when a project needs to compile to different architectures and some of the dependencies are only available to some of them. By default, the target is <code class="inline">:host</code> but it can be set via the <code class="inline">MIX_TARGET</code> environment variable.</p>
<p>When running Mix via the command line, you can configure the default target or the preferred target per task via the <code class="inline">def cli</code> function in your <code class="inline">mix.exs</code>. For example:</p>
<pre data-language="elixir">def cli do
  [
    default_target: :local,
    preferred_targets: [docs: :docs]
  ]
end</pre>
<p>The target can be read via <a href="#target/0"><code class="inline">Mix.target/0</code></a>.</p>
<h2 id="module-configuration" class="section-heading">  <span class="text">Configuration</span> </h2> <p>Mix allows you to configure the application environment of your application and of your dependencies. See the <a href="https://hexdocs.pm/elixir/Application.html"><code class="inline">Application</code></a> module to learn more about the application environment. On this section, we will focus on how to configure it at two distinct moments: build-time and runtime.</p>
<blockquote>
<h4 class="warning">Avoiding the application environment</h4>
<p>The application environment is discouraged for libraries. See Elixir's <a href="https://hexdocs.pm/elixir/library-guidelines.html">Library Guidelines</a> for more information.</p>
</blockquote>
<h3 id="module-build-time-configuration" class="section-heading">  <span class="text">Build-time configuration</span> </h3> <p>Whenever you invoke a <code class="inline">mix</code> command, Mix loads the configuration in <code class="inline">config/config.exs</code>, if said file exists. It is common for the <code class="inline">config/config.exs</code> file itself to import other configuration based on the current <code class="inline">MIX_ENV</code>, such as <code class="inline">config/dev.exs</code>, <code class="inline">config/test.exs</code>, and <code class="inline">config/prod.exs</code>, by calling <a href="https://hexdocs.pm/elixir/Config.html#import_config/1"><code class="inline">Config.import_config/1</code></a>:</p>
<pre data-language="elixir">import Config
import_config "#{config_env()}.exs"</pre>
<p>We say <code class="inline">config/config.exs</code> and all imported files are build-time configuration as they are evaluated whenever you compile your code. In other words, if your configuration does something like:</p>
<pre data-language="elixir">import Config
config :my_app, :secret_key, System.fetch_env!("MY_APP_SECRET_KEY")</pre>
<p>The <code class="inline">:secret_key</code> key under <code class="inline">:my_app</code> will be computed on the host machine before your code compiles. This can be an issue if the machine compiling your code does not have access to all environment variables used to run your code, as loading the config above will fail due to the missing environment variable. Furthermore, even if the environment variable is set, changing the environment variable will require a full recompilation of your application by calling <code class="inline">mix compile --force</code> (otherwise your project won't start). Luckily, Mix also provides runtime configuration, which is preferred in such cases and we will see next.</p>
<h3 id="module-runtime-configuration" class="section-heading">  <span class="text">Runtime configuration</span> </h3> <p>To enable runtime configuration in your release, all you need to do is to create a file named <code class="inline">config/runtime.exs</code>:</p>
<pre data-language="elixir">import Config
config :my_app, :secret_key, System.fetch_env!("MY_APP_SECRET_KEY")</pre>
<p>This file is executed whenever your project runs. If you assemble a release with <a href="mix.tasks.release.html"><code class="inline">mix release</code></a>, it also executes every time your release starts.</p>
<h2 id="module-aliases" class="section-heading">  <span class="text">Aliases</span> </h2> <p>Aliases are shortcuts or tasks specific to the current project.</p>
<p>In the <a href="#module-mix-task">Mix.Task section</a>, we have defined a task that would be available to everyone using our project as a dependency. What if we wanted the task to only be available for our project? Just define an alias:</p>
<pre data-language="elixir">defmodule MyApp.MixProject do
  use Mix.Project

  def project do
    [
      app: :my_app,
      version: "1.0.0",
      aliases: aliases()
    ]
  end

  defp aliases do
    [
      c: "compile",
      hello: &amp;hello/1,
      paid_task: &amp;paid_task/1
    ]
  end

  defp hello(_) do
    Mix.shell().info("Hello world")
  end

  defp paid_task(_) do
    Mix.Task.run("paid.task", [
      "first_arg",
      "second_arg",
      "--license-key",
      System.fetch_env!("SOME_LICENSE_KEY")
    ])
  end
end</pre>
<p>In the example above, we have defined three aliases. One is <code class="inline">mix c</code> which is a shortcut for <a href="mix.tasks.compile.html"><code class="inline">mix compile</code></a>. Another is named <code class="inline">mix hello</code> and the third is named <code class="inline">mix paid_task</code>, which executes the code inside a custom function to invoke the <code class="inline">paid.task</code> task with several arguments, including one pulled from an environment variable.</p>
<p>Aliases may also be lists, specifying multiple tasks to be run consecutively:</p>
<pre data-language="elixir">[all: [&amp;hello/1, "deps.get --only #{Mix.env()}", "compile"]]</pre>
<p>In the example above, we have defined an alias named <code class="inline">mix all</code>, that prints "Hello world", then fetches dependencies specific to the current environment, and compiles the project.</p>
<p>Aliases can also be used to augment existing tasks. Let's suppose you want to augment <a href="mix.tasks.clean.html"><code class="inline">mix clean</code></a> to clean another directory Mix does not know about:</p>
<pre data-language="elixir">[clean: ["clean", &amp;clean_extra/1]]</pre>
<p>Where <code class="inline">&amp;clean_extra/1</code> would be a function in your <code class="inline">mix.exs</code> with extra cleanup logic.</p>
<p>If the alias is overriding an existing task, the arguments given to the alias will be forwarded to the original task in order to preserve semantics. Otherwise arguments given to the alias are appended to the arguments of the last task in the list.</p>
<p>Another use case of aliases is to run Elixir scripts and shell commands, for example:</p>
<pre data-language="elixir"># priv/hello1.exs
IO.puts("Hello One")

# priv/hello2.exs
IO.puts("Hello Two")

# priv/world.sh
#!/bin/sh
echo "world!"

# mix.exs
defp aliases do
  [
    some_alias: ["hex.info", "run priv/hello1.exs", "cmd priv/world.sh"]
  ]
end</pre>
<p>In the example above we have created the alias <code class="inline">some_alias</code> that will run the task <code class="inline">mix hex.info</code>, then <a href="mix.tasks.run.html"><code class="inline">mix run</code></a> to run an Elixir script, then <a href="mix.tasks.cmd.html"><code class="inline">mix cmd</code></a> to execute a command line shell script. This shows how powerful aliases mixed with Mix tasks can be.</p>
<p>One common pitfall of aliases comes when trying to invoke the same task multiple times. Mix tasks are designed to run only once. This prevents the same task from being executed multiple times. For example, if there are several tasks depending on <a href="mix.tasks.compile.html"><code class="inline">mix compile</code></a>, the code will be compiled only once.</p>
<p>Similarly, <a href="mix.tasks.format.html"><code class="inline">mix format</code></a> can only be invoked once. So if you have an alias that attempts to invoke <a href="mix.tasks.format.html"><code class="inline">mix format</code></a> multiple times, it won't work unless it is explicitly reenabled using <a href="mix.task.html#reenable/1"><code class="inline">Mix.Task.reenable/1</code></a>:</p>
<pre data-language="elixir">another_alias: [
  "format --check-formatted priv/hello1.exs",
  "cmd priv/world.sh",
  fn _ -&gt; Mix.Task.reenable("format") end,
  "format --check-formatted priv/hello2.exs"
]</pre>
<p>Some tasks are automatically reenabled though, as they are expected to be invoked multiple times, such as: <a href="mix.tasks.cmd.html"><code class="inline">mix cmd</code></a>, <a href="mix.tasks.do.html"><code class="inline">mix do</code></a>, <a href="mix.tasks.xref.html"><code class="inline">mix xref</code></a>, etc.</p>
<p>Finally, aliases defined in the current project do not affect its dependencies and aliases defined in dependencies are not accessible from the current project, with the exception of umbrella projects. Umbrella projects will run the aliases of its children when the umbrella project itself does not define said alias and there is no task with said name.</p>
<h2 id="module-environment-variables" class="section-heading">  <span class="text">Environment variables</span> </h2> <p>Several environment variables can be used to modify Mix's behavior.</p>
<p>Mix responds to the following variables:</p>
<ul>
<li><p><code class="inline">MIX_ARCHIVES</code> - specifies the directory into which the archives should be installed (default: <code class="inline">~/.mix/archives</code>)</p></li>
<li><p><code class="inline">MIX_BUILD_PATH</code> - sets the project <a href="mix.project.html#build_path/0"><code class="inline">Mix.Project.build_path/0</code></a> config. This option must always point to a subdirectory inside a temporary directory. For instance, never "/tmp" or "_build" but "_build/PROD" or "/tmp/PROD", as required by Mix. This environment variable is used mostly by external build tools. For your CI servers, you likely want to use <code class="inline">MIX_BUILD_ROOT</code> below.</p></li>
<li><p><code class="inline">MIX_BUILD_ROOT</code> - sets the root directory where build artifacts should be written to. For example, "_build". If <code class="inline">MIX_BUILD_PATH</code> is set, this option is ignored.</p></li>
<li><p><code class="inline">MIX_DEBUG</code> - outputs debug information about each task before running it</p></li>
<li><p><code class="inline">MIX_DEPS_PATH</code> - sets the project <a href="mix.project.html#deps_path/0"><code class="inline">Mix.Project.deps_path/0</code></a> config for the current project (default: <code class="inline">deps</code>)</p></li>
<li><p><code class="inline">MIX_ENV</code> - specifies which environment should be used. See <a href="#module-environments">Environments</a></p></li>
<li><p><code class="inline">MIX_EXS</code> - changes the full path to the <code class="inline">mix.exs</code> file</p></li>
<li><p><code class="inline">MIX_HOME</code> - path to Mix's home directory, stores configuration files and scripts used by Mix (default: <code class="inline">~/.mix</code>)</p></li>
<li><p><code class="inline">MIX_INSTALL_DIR</code> <em>(since v1.12.0)</em> - specifies directory where <a href="#install/2"><code class="inline">Mix.install/2</code></a> keeps install cache</p></li>
<li><p><code class="inline">MIX_PATH</code> - appends extra code paths</p></li>
<li><p><code class="inline">MIX_PROFILE</code> - a list of comma-separated Mix tasks to profile the time spent on functions by the process running the task</p></li>
<li><p><code class="inline">MIX_QUIET</code> - does not print information messages to the terminal</p></li>
<li><p><code class="inline">MIX_REBAR3</code> - path to rebar3 command that overrides the one Mix installs (default: <code class="inline">~/.mix/rebar3</code>)</p></li>
<li><p><code class="inline">MIX_TARGET</code> - specifies which target should be used. See <a href="#module-targets">Targets</a></p></li>
<li><p><code class="inline">MIX_XDG</code> - asks Mix to follow the <a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html">XDG Directory Specification</a> for its home directory and configuration files. This behavior needs to be opt-in due to backwards compatibility. <code class="inline">MIX_HOME</code> has higher preference than <code class="inline">MIX_XDG</code>. If none of the variables are set, the default directory <code class="inline">~/.mix</code> will be used</p></li>
</ul>
<p>Environment variables that are not meant to hold a value (and act basically as flags) should be set to either <code class="inline">1</code> or <code class="inline">true</code>, for example:</p>
<pre data-language="elixir">$ MIX_DEBUG=1 mix compile
</pre>
<p>In addition, Mix also uses the following environment variables defined by other libraries</p>
<ul><li>
<code class="inline">HEX_CACERTS_PATH</code> - use specified CA certificate file instead of default system CA certificates. This configures how HTTPS calls are made via <a href="https://www.erlang.org/doc/man/ssl#type-client_cafile">Erlang <code class="inline">ssl</code> module</a> to fetch remote archives and packages. For more details, see <a href="https://hexdocs.pm/hex/Mix.Tasks.Hex.Config.html#module-config-keys"><code class="inline">mix hex.config</code></a>.</li></ul> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#compilers/0" data-no-tooltip translate="no">compilers()</a> </dt> <dd class="summary-synopsis"><p>Returns the default compilers used by Mix.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug/1" data-no-tooltip translate="no">debug(debug)</a> </dt> <dd class="summary-synopsis"><p>Sets Mix debug mode.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug?/0" data-no-tooltip translate="no">debug?()</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if Mix is in debug mode, <code class="inline">false</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#ensure_application!/1" data-no-tooltip translate="no">ensure_application!(app)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given application from Erlang/OTP or Elixir and its dependencies are available in the path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#env/0" data-no-tooltip translate="no">env()</a> </dt> <dd class="summary-synopsis"><p>Returns the current Mix environment.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#env/1" data-no-tooltip translate="no">env(env)</a> </dt> <dd class="summary-synopsis"><p>Changes the current Mix environment to <code class="inline">env</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#install/2" data-no-tooltip translate="no">install(deps, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Installs and starts dependencies.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#install_project_dir/0" data-no-tooltip translate="no">install_project_dir()</a> </dt> <dd class="summary-synopsis"><p>Returns the directory where the current <a href="#install/2"><code class="inline">Mix.install/2</code></a> project resides.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#installed?/0" data-no-tooltip translate="no">installed?()</a> </dt> <dd class="summary-synopsis"><p>Returns whether <a href="#install/2"><code class="inline">Mix.install/2</code></a> was called in the current node.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#path_for/1" data-no-tooltip translate="no">path_for(atom)</a> </dt> <dd class="summary-synopsis"><p>The path for local archives or escripts.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/1" data-no-tooltip translate="no">raise(message)</a> </dt> <dd class="summary-synopsis"><p>Raises a Mix error that is nicely formatted, defaulting to exit status <code class="inline">1</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#raise/2" data-no-tooltip translate="no">raise(message, opts)</a> </dt> <dd class="summary-synopsis"><p>Raises a Mix error that is nicely formatted.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shell/0" data-no-tooltip translate="no">shell()</a> </dt> <dd class="summary-synopsis"><p>Returns the current shell.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shell/1" data-no-tooltip translate="no">shell(shell)</a> </dt> <dd class="summary-synopsis"><p>Sets the current shell.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#target/0" data-no-tooltip translate="no">target()</a> </dt> <dd class="summary-synopsis"><p>Returns the Mix target.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#target/1" data-no-tooltip translate="no">target(target)</a> </dt> <dd class="summary-synopsis"><p>Changes the current Mix target to <code class="inline">target</code>.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="compilers/0">compilers()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L481" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compilers() :: [atom()]</pre> </div> <p>Returns the default compilers used by Mix.</p>
<p>It can be used in your <code class="inline">mix.exs</code> to prepend or append new compilers to Mix:</p>
<pre data-language="elixir">def project do
  [compilers: Mix.compilers() ++ [:foo, :bar]]
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="debug/1">debug(debug)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L556" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec debug(boolean()) :: :ok</pre> </div> <p>Sets Mix debug mode.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="debug?/0">debug?()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L548" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec debug?() :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if Mix is in debug mode, <code class="inline">false</code> otherwise.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="ensure_application!/1">ensure_application!(app)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L615" class="source">Source</a>
</h3> <section class="docstring"> <p>Ensures the given application from Erlang/OTP or Elixir and its dependencies are available in the path.</p>
<p>Generally speaking, you should list the Erlang application dependencies under the <code class="inline">:extra_applications</code> section of your <code class="inline">mix.exs</code>. This must only be used by Mix tasks which wish to avoid depending on Erlang/Elixir for certain reasons.</p>
<p>This function does not start the given applications.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="env/0">env()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L430" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec env() :: atom()</pre> </div> <p>Returns the current Mix environment.</p>
<p>This function should not be used at runtime in application code (as opposed to infrastructure and build code like Mix tasks). Mix is a build tool and may not be available after the code is compiled (for example in a release).</p>
<p>To differentiate the program behavior depending on the environment, it is recommended to use application environment through <a href="https://hexdocs.pm/elixir/Application.html#get_env/3"><code class="inline">Application.get_env/3</code></a>. Proper configuration can be set in config files, often per-environment (see the <a href="https://hexdocs.pm/elixir/Config.html"><code class="inline">Config</code></a> module for more information).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="env/1">env(env)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L445" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec env(atom()) :: :ok</pre> </div> <p>Changes the current Mix environment to <code class="inline">env</code>.</p>
<p>Be careful when invoking this function as any project configuration won't be reloaded.</p>
<p>This function should not be used at runtime in application code (see <a href="#env/0"><code class="inline">env/0</code></a> for more information).</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="install/2">install(deps, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L809" class="source">Source</a>
</h3> <section class="docstring"> <p>Installs and starts dependencies.</p>
<p>The given <code class="inline">deps</code> should be in the same format as defined in a regular Mix project. See <a href="mix.tasks.deps.html"><code class="inline">mix help deps</code></a> for more information. As a shortcut, an atom can be given as dependency to mean the latest version. In other words, specifying <code class="inline">:decimal</code> is the same as <code class="inline">{:decimal, "&gt;= 0.0.0"}</code>.</p>
<p>After each successful installation, a given set of dependencies is cached so starting another VM and calling <a href="#install/2"><code class="inline">Mix.install/2</code></a> with the same dependencies will avoid unnecessary downloads and compilations. The location of the cache directory can be controlled using the <code class="inline">MIX_INSTALL_DIR</code> environment variable.</p>
<p>This function can only be called outside of a Mix project and only with the same dependencies in the given VM.</p>
<h4 id="install/2-options" class="section-heading">  <span class="text">Options</span> </h4> <ul>
<li><p><code class="inline">:force</code> - if <code class="inline">true</code>, runs with empty install cache. This is useful when you want to update your dependencies or your install got into an inconsistent state. To use this option, you can also set the <code class="inline">MIX_INSTALL_FORCE</code> environment variable. (Default: <code class="inline">false</code>)</p></li>
<li><p><code class="inline">:verbose</code> - if <code class="inline">true</code>, prints additional debugging information (Default: <code class="inline">false</code>)</p></li>
<li><p><code class="inline">:consolidate_protocols</code> - if <code class="inline">true</code>, runs protocol consolidation via the <a href="mix.tasks.compile.protocols.html"><code class="inline">mix compile.protocols</code></a> task (Default: <code class="inline">true</code>)</p></li>
<li><p><code class="inline">:elixir</code> - if set, ensures the current Elixir version matches the given version requirement (Default: <code class="inline">nil</code>)</p></li>
<li><p><code class="inline">:system_env</code> <em>(since v1.13.0)</em> - a list or a map of system environment variable names with respective values as binaries. The system environment is made part of the <a href="#install/2"><code class="inline">Mix.install/2</code></a> cache, so different configurations will lead to different apps</p></li>
<li><p><code class="inline">:config</code> <em>(since v1.13.0)</em> - a keyword list of keyword lists of compile-time configuration. The configuration is part of the <a href="#install/2"><code class="inline">Mix.install/2</code></a> cache, so different configurations will lead to different apps. For this reason, you want to minimize the amount of configuration set through this option. Use <a href="https://hexdocs.pm/elixir/Application.html#put_all_env/2"><code class="inline">Application.put_all_env/2</code></a> for setting other runtime configuration.</p></li>
<li><p><code class="inline">:config_path</code> <em>(since v1.14.0)</em> - path to a configuration file. If a <code class="inline">runtime.exs</code> file exists in the same directory as the given path, it is loaded too.</p></li>
<li><p><code class="inline">:lockfile</code> <em>(since v1.14.0)</em> - path to a lockfile to be used as a basis of dependency resolution.</p></li>
<li><p><code class="inline">:start_applications</code> <em>(since v1.15.3)</em> - if <code class="inline">true</code>, ensures that installed app and its dependencies are started after install (Default: <code class="inline">true</code>)</p></li>
</ul>
<h4 id="install/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Installing <code class="inline">:decimal</code> and <code class="inline">:jason</code>:</p>
<pre data-language="elixir">Mix.install([
  :decimal,
  {:jason, "~&gt; 1.0"}
])</pre>
<p>Installing <code class="inline">:nx</code> and <code class="inline">:exla</code>, and configuring the underlying applications and environment variables:</p>
<pre data-language="elixir">Mix.install(
  [:nx, :exla],
  config: [
    nx: [default_backend: EXLA]
  ],
  system_env: [
    XLA_TARGET: "cuda111"
  ]
)</pre>
<p>Installing a Mix project as a path dependency along with its configuration and deps:</p>
<pre data-language="elixir"># $ git clone https://github.com/hexpm/hexpm /tmp/hexpm
# $ cd /tmp/hexpm &amp;&amp; mix setup

Mix.install(
  [
    {:hexpm, path: "/tmp/hexpm", env: :dev},
  ],
  config_path: "/tmp/hexpm/config/config.exs",
  lockfile: "/tmp/hexpm/mix.lock"
)

Hexpm.Repo.query!("SELECT COUNT(1) from packages")
#=&gt; ...</pre>
<p>The example above can be simplified by passing the application name as an atom for <code class="inline">:config_path</code> and <code class="inline">:lockfile</code>:</p>
<pre data-language="elixir">Mix.install(
  [
    {:hexpm, path: "/tmp/hexpm", env: :dev},
  ],
  config_path: :hexpm,
  lockfile: :hexpm
)</pre>
<h4 id="install/2-limitations" class="section-heading">  <span class="text">Limitations</span> </h4> <p>There is one limitation to <a href="#install/2"><code class="inline">Mix.install/2</code></a>, which is actually an Elixir behavior. If you are installing a dependency that defines a struct or macro, you cannot use the struct or macro immediately after the install call. For example, this won't work:</p>
<pre data-language="elixir">Mix.install([:decimal])
%Decimal{} = Decimal.new(42)</pre>
<p>That's because Elixir first expands all structs and all macros, and then it executes the code. This means that, by the time Elixir tries to expand the <code class="inline">%Decimal{}</code> struct, the dependency has not been installed yet.</p>
<p>Luckily this has a straightforward solution, which is to move the code inside a module:</p>
<pre data-language="elixir">Mix.install([:decimal])

defmodule Script do
  def run do
    %Decimal{} = Decimal.new(42)
  end
end

Script.run()</pre>
<p>The contents inside <code class="inline">defmodule</code> will only be expanded and executed after <a href="#install/2"><code class="inline">Mix.install/2</code></a> runs, which means that any struct, macros, and imports will be correctly handled.</p>
<h4 id="install/2-environment-variables" class="section-heading">  <span class="text">Environment variables</span> </h4> <p>The <code class="inline">MIX_INSTALL_DIR</code> environment variable configures the directory that caches all <a href="#install/2"><code class="inline">Mix.install/2</code></a>. It defaults to the "mix/install" folder in the default user cache of your operating system. You can use <a href="#install_project_dir/0"><code class="inline">install_project_dir/0</code></a> to access the directory of an existing install (alongside other installs):</p>
<pre data-language="elixir">iex&gt; Mix.install([])
iex&gt; Mix.install_project_dir()</pre>
<p>The <code class="inline">MIX_INSTALL_FORCE</code> is available since Elixir v1.13.0 and forces <a href="#install/2"><code class="inline">Mix.install/2</code></a> to discard any previously cached entry of the current install.</p>
<p>The <code class="inline">MIX_INSTALL_RESTORE_PROJECT_DIR</code> environment variable may be specified since Elixir v1.16.2. It should point to a previous installation directory, which can be obtained with <a href="#install_project_dir/0"><code class="inline">Mix.install_project_dir/0</code></a> (after calling <a href="#install/2"><code class="inline">Mix.install/2</code></a>). Using a restore dir may speed up the installation, since matching dependencies do not need be refetched nor recompiled. This environment variable is ignored if <code class="inline">:force</code> is enabled.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="install_project_dir/0">install_project_dir()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L1090" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec install_project_dir() :: Path.t() | nil</pre> </div> <p>Returns the directory where the current <a href="#install/2"><code class="inline">Mix.install/2</code></a> project resides.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="installed?/0">installed?()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L1102" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec installed?() :: boolean()</pre> </div> <p>Returns whether <a href="#install/2"><code class="inline">Mix.install/2</code></a> was called in the current node.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="path_for/1">path_for(atom)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L596" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec path_for(:archives | :escripts) :: String.t()</pre> </div> <p>The path for local archives or escripts.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/1">raise(message)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L564" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec raise(binary()) :: no_return()</pre> </div> <p>Raises a Mix error that is nicely formatted, defaulting to exit status <code class="inline">1</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="raise/2">raise(message, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L578" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec raise(binary(), [{:exit_status, non_neg_integer()}]) :: no_return()</pre> </div> <p>Raises a Mix error that is nicely formatted.</p>
<h4 id="raise/2-options" class="section-heading">  <span class="text">Options</span> </h4> <ul><li>
<code class="inline">:exit_status</code> - defines exit status, defaults to <code class="inline">1</code>
</li></ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="shell/0">shell()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L506" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shell() :: module()</pre> </div> <p>Returns the current shell.</p>
<p><a href="#shell/0"><code class="inline">shell/0</code></a> can be used as a wrapper for the current shell. It contains conveniences for requesting information from the user, printing to the shell and so forth. The Mix shell is swappable (see <a href="#shell/1"><code class="inline">shell/1</code></a>), allowing developers to use a test shell that simply sends messages to the current process instead of performing IO (see <a href="mix.shell.process.html"><code class="inline">Mix.Shell.Process</code></a>).</p>
<p>By default, this returns <a href="mix.shell.io.html"><code class="inline">Mix.Shell.IO</code></a>.</p>
<h4 id="shell/0-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">Mix.shell().info("Preparing to do something dangerous...")

if Mix.shell().yes?("Are you sure?") do
  # do something dangerous
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shell/1">shell(shell)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L540" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shell(module()) :: :ok</pre> </div> <p>Sets the current shell.</p>
<p>As an argument you may pass <a href="mix.shell.io.html"><code class="inline">Mix.Shell.IO</code></a>, <a href="mix.shell.process.html"><code class="inline">Mix.Shell.Process</code></a>, <a href="mix.shell.quiet.html"><code class="inline">Mix.Shell.Quiet</code></a>, or any module that implements the <a href="mix.shell.html"><code class="inline">Mix.Shell</code></a> behaviour.</p>
<p>After calling this function, <code class="inline">shell</code> becomes the shell that is returned by <a href="#shell/0"><code class="inline">shell/0</code></a>.</p>
<h4 id="shell/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Mix.shell(Mix.Shell.IO)
:ok</pre>
<p>You can use <a href="#shell/0"><code class="inline">shell/0</code></a> and <a href="#shell/1"><code class="inline">shell/1</code></a> to temporarily switch shells, for example, if you want to run a Mix Task that normally produces a lot of output:</p>
<pre data-language="elixir">shell = Mix.shell()
Mix.shell(Mix.Shell.Quiet)

try do
  Mix.Task.run("noisy.task")
after
  Mix.shell(shell)
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="target/0">target()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L453" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec target() :: atom()</pre> </div> <p>Returns the Mix target.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="target/1">target(target)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/mix/lib/mix.ex#L465" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec target(atom()) :: :ok</pre> </div> <p>Changes the current Mix target to <code class="inline">target</code>.</p>
<p>Be careful when invoking this function as any project configuration won't be reloaded.</p> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="mix.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/mix/1.17.2/Mix.html" class="_attribution-link">https://hexdocs.pm/mix/1.17.2/Mix.html</a>
  </p>
</div>
