<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Date</span>  </h1> <section id="moduledoc"> <p>A Date struct and functions.</p>
<p>The Date struct contains the fields year, month, day and calendar. New dates can be built with the <a href="#new/3"><code class="inline">new/3</code></a> function or using the <code class="inline">~D</code> (see <a href="kernel.html#sigil_D/2"><code class="inline">sigil_D/2</code></a>) sigil:</p>
<pre data-language="elixir">iex&gt; ~D[2000-01-01]
~D[2000-01-01]</pre>
<p>Both <a href="#new/3"><code class="inline">new/3</code></a> and sigil return a struct where the date fields can be accessed directly:</p>
<pre data-language="elixir">iex&gt; date = ~D[2000-01-01]
iex&gt; date.year
2000
iex&gt; date.month
1</pre>
<p>The functions on this module work with the <a href="date.html"><code class="inline">Date</code></a> struct as well as any struct that contains the same fields as the <a href="date.html"><code class="inline">Date</code></a> struct, such as <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> and <a href="datetime.html"><code class="inline">DateTime</code></a>. Such functions expect <a href="calendar.html#t:date/0"><code class="inline">Calendar.date/0</code></a> in their typespecs (instead of <a href="#t:t/0"><code class="inline">t/0</code></a>).</p>
<p>Developers should avoid creating the Date structs directly and instead rely on the functions provided by this module as well as the ones in third-party calendar libraries.</p>
<h2 id="module-comparing-dates" class="section-heading">  <span class="text">Comparing dates</span> </h2> <p>Comparisons in Elixir using <a href="kernel.html#==/2"><code class="inline">==/2</code></a>, <a href="kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="kernel.html#%3C/2"><code class="inline">&lt;/2</code></a> and similar are structural and based on the <a href="date.html"><code class="inline">Date</code></a> struct fields. For proper comparison between dates, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function. The existence of the <a href="#compare/2"><code class="inline">compare/2</code></a> function in this module also allows using <a href="enum.html#min/2"><code class="inline">Enum.min/2</code></a> and <a href="enum.html#max/2"><code class="inline">Enum.max/2</code></a> functions to get the minimum and maximum date of an <a href="enum.html"><code class="inline">Enum</code></a>. For example:</p>
<pre data-language="elixir">iex&gt;  Enum.min([~D[2017-03-31], ~D[2017-04-01]], Date)
~D[2017-03-31]</pre>
<h2 id="module-using-epochs" class="section-heading">  <span class="text">Using epochs</span> </h2> <p>The <a href="#add/2"><code class="inline">add/2</code></a>, <a href="#diff/2"><code class="inline">diff/2</code></a> and <a href="#shift/2"><code class="inline">shift/2</code></a> functions can be used for computing dates or retrieving the number of days between instants. For example, if there is an interest in computing the number of days from the Unix epoch (1970-01-01):</p>
<pre data-language="elixir">iex&gt; Date.diff(~D[2010-04-17], ~D[1970-01-01])
14716

iex&gt; Date.add(~D[1970-01-01], 14716)
~D[2010-04-17]

iex&gt; Date.shift(~D[1970-01-01], year: 40, month: 3, week: 2, day: 2)
~D[2010-04-17]</pre>
<p>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01).</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" data-no-tooltip translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add/2" data-no-tooltip translate="no">add(date, days)</a> </dt> <dd class="summary-synopsis"><p>Adds the number of days to the given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#after?/2" data-no-tooltip translate="no">after?(date1, date2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the first date is strictly later than the second.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#before?/2" data-no-tooltip translate="no">before?(date1, date2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the first date is strictly earlier than the second.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#beginning_of_month/1" data-no-tooltip translate="no">beginning_of_month(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates a date that is the first day of the month for the given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#beginning_of_week/2" data-no-tooltip translate="no">beginning_of_week(date, starting_on \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Calculates a date that is the first day of the week for the given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare/2" data-no-tooltip translate="no">compare(date1, date2)</a> </dt> <dd class="summary-synopsis"><p>Compares two date structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert/2" data-no-tooltip translate="no">convert(date, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">date</code> from its calendar to the given <code class="inline">calendar</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert!/2" data-no-tooltip translate="no">convert!(date, calendar)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#convert/2"><code class="inline">Date.convert/2</code></a>, but raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#day_of_era/1" data-no-tooltip translate="no">day_of_era(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day-of-era and era for a given calendar <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#day_of_week/2" data-no-tooltip translate="no">day_of_week(date, starting_on \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the week of a given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#day_of_year/1" data-no-tooltip translate="no">day_of_year(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates the day of the year of a given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#days_in_month/1" data-no-tooltip translate="no">days_in_month(date)</a> </dt> <dd class="summary-synopsis"><p>Returns the number of days in the given <code class="inline">date</code> month.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#diff/2" data-no-tooltip translate="no">diff(date1, date2)</a> </dt> <dd class="summary-synopsis"><p>Calculates the difference between two dates, in a full number of days.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#end_of_month/1" data-no-tooltip translate="no">end_of_month(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates a date that is the last day of the month for the given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#end_of_week/2" data-no-tooltip translate="no">end_of_week(date, starting_on \\ :default)</a> </dt> <dd class="summary-synopsis"><p>Calculates a date that is the last day of the week for the given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl/2" data-no-tooltip translate="no">from_erl(tuple, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang date tuple to a <a href="date.html"><code class="inline">Date</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl!/2" data-no-tooltip translate="no">from_erl!(tuple, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang date tuple but raises for invalid dates.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_gregorian_days/2" data-no-tooltip translate="no">from_gregorian_days(days, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts a number of gregorian days to a <a href="date.html"><code class="inline">Date</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601/2" data-no-tooltip translate="no">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Dates" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601!/2" data-no-tooltip translate="no">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Dates" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#leap_year?/1" data-no-tooltip translate="no">leap_year?(date)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the year in the given <code class="inline">date</code> is a leap year.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#months_in_year/1" data-no-tooltip translate="no">months_in_year(date)</a> </dt> <dd class="summary-synopsis"><p>Returns the number of months in the given <code class="inline">date</code> year.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/4" data-no-tooltip translate="no">new(year, month, day, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new ISO date.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/4" data-no-tooltip translate="no">new!(year, month, day, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new ISO date.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#quarter_of_year/1" data-no-tooltip translate="no">quarter_of_year(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates the quarter of the year of a given <code class="inline">date</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#range/2" data-no-tooltip translate="no">range(first, last)</a> </dt> <dd class="summary-synopsis"><p>Returns a range of dates.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#range/3" data-no-tooltip translate="no">range(first, last, step)</a> </dt> <dd class="summary-synopsis"><p>Returns a range of dates with a step.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shift/2" data-no-tooltip translate="no">shift(date, duration)</a> </dt> <dd class="summary-synopsis"><p>Shifts given <code class="inline">date</code> by <code class="inline">duration</code> according to its calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_erl/1" data-no-tooltip translate="no">to_erl(date)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">date</code> to an Erlang date tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_gregorian_days/1" data-no-tooltip translate="no">to_gregorian_days(date)</a> </dt> <dd class="summary-synopsis"><p>Converts a <code class="inline">date</code> struct to a number of gregorian days.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_iso8601/2" data-no-tooltip translate="no">to_iso8601(date, format \\ :extended)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">date</code> to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1" data-no-tooltip translate="no">to_string(date)</a> </dt> <dd class="summary-synopsis"><p>Converts the given date to a string according to its calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_today/1" data-no-tooltip translate="no">utc_today(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the current date in UTC.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#year_of_era/1" data-no-tooltip translate="no">year_of_era(date)</a> </dt> <dd class="summary-synopsis"><p>Calculates the year-of-era and era for a given calendar year.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L64" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: %Date{
  calendar: Calendar.calendar(),
  day: Calendar.day(),
  month: Calendar.month(),
  year: Calendar.year()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="add/2">add(date, days)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L709" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec add(Calendar.date(), integer()) :: t()</pre> </div> <p>Adds the number of days to the given <code class="inline">date</code>.</p>
<p>The days are counted as Gregorian days. The date is returned in the same calendar as it was given in.</p>
<p>To shift a date by a <a href="duration.html"><code class="inline">Duration</code></a> and according to its underlying calendar, use <a href="#shift/2"><code class="inline">Date.shift/2</code></a>.</p>
<h4 id="add/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.add(~D[2000-01-03], -2)
~D[2000-01-01]
iex&gt; Date.add(~D[2000-01-01], 2)
~D[2000-01-03]
iex&gt; Date.add(~N[2000-01-01 09:00:00], 2)
~D[2000-01-03]
iex&gt; Date.add(~D[-0010-01-01], -2)
~D[-0011-12-30]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="after?/2">after?(date1, date2)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L617" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec after?(Calendar.date(), Calendar.date()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the first date is strictly later than the second.</p>
<h4 id="after?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.after?(~D[2022-02-02], ~D[2021-01-01])
true
iex&gt; Date.after?(~D[2021-01-01], ~D[2021-01-01])
false
iex&gt; Date.after?(~D[2021-01-01], ~D[2022-02-02])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="before?/2">before?(date1, date2)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L598" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec before?(Calendar.date(), Calendar.date()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the first date is strictly earlier than the second.</p>
<h4 id="before?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.before?(~D[2021-01-01], ~D[2022-02-02])
true
iex&gt; Date.before?(~D[2021-01-01], ~D[2021-01-01])
false
iex&gt; Date.before?(~D[2022-02-02], ~D[2021-01-01])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="beginning_of_month/1">beginning_of_month(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1124" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec beginning_of_month(Calendar.date()) :: t()</pre> </div> <p>Calculates a date that is the first day of the month for the given <code class="inline">date</code>.</p>
<h4 id="beginning_of_month/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.beginning_of_month(~D[2000-01-31])
~D[2000-01-01]
iex&gt; Date.beginning_of_month(~D[2000-01-01])
~D[2000-01-01]
iex&gt; Date.beginning_of_month(~N[2000-01-31 01:23:45])
~D[2000-01-01]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="beginning_of_week/2">beginning_of_week(date, starting_on \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L919" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec beginning_of_week(Calendar.date(), starting_on :: :default | atom()) :: t()</pre> </div> <p>Calculates a date that is the first day of the week for the given <code class="inline">date</code>.</p>
<p>If the day is already the first day of the week, it returns the day itself. For the built-in ISO calendar, the week starts on Monday. A weekday rather than <code class="inline">:default</code> can be given as <code class="inline">starting_on</code>.</p>
<h4 id="beginning_of_week/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.beginning_of_week(~D[2020-07-11])
~D[2020-07-06]
iex&gt; Date.beginning_of_week(~D[2020-07-06])
~D[2020-07-06]
iex&gt; Date.beginning_of_week(~D[2020-07-11], :sunday)
~D[2020-07-05]
iex&gt; Date.beginning_of_week(~D[2020-07-11], :saturday)
~D[2020-07-11]
iex&gt; Date.beginning_of_week(~N[2020-07-11 01:23:45])
~D[2020-07-06]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare/2">compare(date1, date2)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L555" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compare(Calendar.date(), Calendar.date()) :: :lt | :eq | :gt</pre> </div> <p>Compares two date structs.</p>
<p>Returns <code class="inline">:gt</code> if first date is later than the second and <code class="inline">:lt</code> for vice versa. If the two dates are equal <code class="inline">:eq</code> is returned.</p>
<h4 id="compare/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.compare(~D[2016-04-16], ~D[2016-04-28])
:lt</pre>
<p>This function can also be used to compare across more complex calendar types by considering only the date fields:</p>
<pre data-language="elixir">iex&gt; Date.compare(~D[2016-04-16], ~N[2016-04-28 01:23:45])
:lt
iex&gt; Date.compare(~D[2016-04-16], ~N[2016-04-16 01:23:45])
:eq
iex&gt; Date.compare(~N[2016-04-16 12:34:56], ~N[2016-04-16 01:23:45])
:eq</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert/2">convert(date, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L642" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert(Calendar.date(), Calendar.calendar()) ::
  {:ok, t()} | {:error, :incompatible_calendars}</pre> </div> <p>Converts the given <code class="inline">date</code> from its calendar to the given <code class="inline">calendar</code>.</p>
<p>Returns <code class="inline">{:ok, date}</code> if the calendars are compatible, or <code class="inline">{:error, :incompatible_calendars}</code> if they are not.</p>
<p>See also <a href="calendar.html#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>.</p>
<h4 id="convert/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Date.convert(~D[2000-01-01], Calendar.Holocene)
{:ok, %Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert!/2">convert!(date, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L675" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert!(Calendar.date(), Calendar.calendar()) :: t()</pre> </div> <p>Similar to <a href="#convert/2"><code class="inline">Date.convert/2</code></a>, but raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> if the conversion between the two calendars is not possible.</p>
<h4 id="convert!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; Date.convert!(~D[2000-01-01], Calendar.Holocene)
%Date{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="day_of_era/1">day_of_era(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1103" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec day_of_era(Calendar.date()) :: {Calendar.day(), non_neg_integer()}</pre> </div> <p>Calculates the day-of-era and era for a given calendar <code class="inline">date</code>.</p>
<p>Returns a tuple <code class="inline">{day, era}</code> representing the day within the era and the era number.</p>
<h4 id="day_of_era/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.day_of_era(~D[0001-01-01])
{1, 1}

iex&gt; Date.day_of_era(~D[0000-12-31])
{1, 0}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="day_of_week/2">day_of_week(date, starting_on \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L889" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec day_of_week(Calendar.date(), starting_on :: :default | atom()) ::
  Calendar.day_of_week()</pre> </div> <p>Calculates the day of the week of a given <code class="inline">date</code>.</p>
<p>Returns the day of the week as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 7, where 1 is Monday and 7 is Sunday.</p>
<p>An optional <code class="inline">starting_on</code> value may be supplied, which configures the weekday the week starts on. The default value for it is <code class="inline">:default</code>, which translates to <code class="inline">:monday</code> for the built-in ISO calendar. Any other weekday may be given to.</p>
<h4 id="day_of_week/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.day_of_week(~D[2016-10-31])
1
iex&gt; Date.day_of_week(~D[2016-11-01])
2
iex&gt; Date.day_of_week(~N[2016-11-01 01:23:45])
2
iex&gt; Date.day_of_week(~D[-0015-10-30])
3

iex&gt; Date.day_of_week(~D[2016-10-31], :sunday)
2
iex&gt; Date.day_of_week(~D[2016-11-01], :sunday)
3
iex&gt; Date.day_of_week(~N[2016-11-01 01:23:45], :sunday)
3
iex&gt; Date.day_of_week(~D[-0015-10-30], :sunday)
4</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="day_of_year/1">day_of_year(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1022" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec day_of_year(Calendar.date()) :: Calendar.day()</pre> </div> <p>Calculates the day of the year of a given <code class="inline">date</code>.</p>
<p>Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 366.</p>
<h4 id="day_of_year/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.day_of_year(~D[2016-01-01])
1
iex&gt; Date.day_of_year(~D[2016-11-01])
306
iex&gt; Date.day_of_year(~D[-0015-10-30])
303
iex&gt; Date.day_of_year(~D[2004-12-31])
366</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="days_in_month/1">days_in_month(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L236" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec days_in_month(Calendar.date()) :: Calendar.day()</pre> </div> <p>Returns the number of days in the given <code class="inline">date</code> month.</p>
<h4 id="days_in_month/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.days_in_month(~D[1900-01-13])
31
iex&gt; Date.days_in_month(~D[1900-02-09])
28
iex&gt; Date.days_in_month(~N[2000-02-20 01:23:45])
29</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="diff/2">diff(date1, date2)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L741" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec diff(Calendar.date(), Calendar.date()) :: integer()</pre> </div> <p>Calculates the difference between two dates, in a full number of days.</p>
<p>It returns the number of Gregorian days between the dates. Only <a href="date.html"><code class="inline">Date</code></a> structs that follow the same or compatible calendars can be compared this way. If two calendars are not compatible, it will raise.</p>
<h4 id="diff/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.diff(~D[2000-01-03], ~D[2000-01-01])
2
iex&gt; Date.diff(~D[2000-01-01], ~D[2000-01-03])
-2
iex&gt; Date.diff(~D[0000-01-02], ~D[-0001-12-30])
3
iex&gt; Date.diff(~D[2000-01-01], ~N[2000-01-03 09:00:00])
-2</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="end_of_month/1">end_of_month(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1145" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec end_of_month(Calendar.date()) :: t()</pre> </div> <p>Calculates a date that is the last day of the month for the given <code class="inline">date</code>.</p>
<h4 id="end_of_month/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.end_of_month(~D[2000-01-01])
~D[2000-01-31]
iex&gt; Date.end_of_month(~D[2000-01-31])
~D[2000-01-31]
iex&gt; Date.end_of_month(~N[2000-01-01 01:23:45])
~D[2000-01-31]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="end_of_week/2">end_of_week(date, starting_on \\ :default)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L972" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec end_of_week(Calendar.date(), starting_on :: :default | atom()) :: t()</pre> </div> <p>Calculates a date that is the last day of the week for the given <code class="inline">date</code>.</p>
<p>If the day is already the last day of the week, it returns the day itself. For the built-in ISO calendar, the week ends on Sunday. A weekday rather than <code class="inline">:default</code> can be given as <code class="inline">starting_on</code>.</p>
<h4 id="end_of_week/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.end_of_week(~D[2020-07-11])
~D[2020-07-12]
iex&gt; Date.end_of_week(~D[2020-07-05])
~D[2020-07-05]
iex&gt; Date.end_of_week(~D[2020-07-06], :sunday)
~D[2020-07-11]
iex&gt; Date.end_of_week(~D[2020-07-06], :saturday)
~D[2020-07-10]
iex&gt; Date.end_of_week(~N[2020-07-11 01:23:45])
~D[2020-07-12]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_erl/2">from_erl(tuple, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L462" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl(:calendar.date(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts an Erlang date tuple to a <a href="date.html"><code class="inline">Date</code></a> struct.</p>
<p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will return an error tuple.</p>
<h4 id="from_erl/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.from_erl({2000, 1, 1})
{:ok, ~D[2000-01-01]}
iex&gt; Date.from_erl({2000, 13, 1})
{:error, :invalid_date}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_erl!/2">from_erl!(tuple, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L480" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl!(:calendar.date(), Calendar.calendar()) :: t()</pre> </div> <p>Converts an Erlang date tuple but raises for invalid dates.</p>
<h4 id="from_erl!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.from_erl!({2000, 1, 1})
~D[2000-01-01]
iex&gt; Date.from_erl!({2000, 13, 1})
** (ArgumentError) cannot convert {2000, 13, 1} to date, reason: :invalid_date</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_gregorian_days/2">from_gregorian_days(days, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L506" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_gregorian_days(integer(), Calendar.calendar()) :: t()</pre> </div> <p>Converts a number of gregorian days to a <a href="date.html"><code class="inline">Date</code></a> struct.</p>
<h4 id="from_gregorian_days/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.from_gregorian_days(1)
~D[0000-01-02]
iex&gt; Date.from_gregorian_days(730_485)
~D[2000-01-01]
iex&gt; Date.from_gregorian_days(-1)
~D[-0001-12-31]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L356" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601(String.t(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Parses the extended "Dates" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>The year parsed by this function is limited to four digits.</p>
<h4 id="from_iso8601/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.from_iso8601("2015-01-23")
{:ok, ~D[2015-01-23]}

iex&gt; Date.from_iso8601("2015:01:23")
{:error, :invalid_format}

iex&gt; Date.from_iso8601("2015-01-32")
{:error, :invalid_date}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L377" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601!(String.t(), Calendar.calendar()) :: t()</pre> </div> <p>Parses the extended "Dates" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>Raises if the format is invalid.</p>
<h4 id="from_iso8601!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.from_iso8601!("2015-01-23")
~D[2015-01-23]
iex&gt; Date.from_iso8601!("2015:01:23")
** (ArgumentError) cannot parse "2015:01:23" as date, reason: :invalid_format</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="leap_year?/1">leap_year?(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L215" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec leap_year?(Calendar.date()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the year in the given <code class="inline">date</code> is a leap year.</p>
<h4 id="leap_year?/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.leap_year?(~D[2000-01-01])
true
iex&gt; Date.leap_year?(~D[2001-01-01])
false
iex&gt; Date.leap_year?(~D[2004-01-01])
true
iex&gt; Date.leap_year?(~D[1900-01-01])
false
iex&gt; Date.leap_year?(~N[2004-01-01 01:23:45])
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="months_in_year/1">months_in_year(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L253" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec months_in_year(Calendar.date()) :: Calendar.month()</pre> </div> <p>Returns the number of months in the given <code class="inline">date</code> year.</p>
<h4 id="months_in_year/1-example" class="section-heading">  <span class="text">Example</span> </h4> <pre data-language="elixir">iex&gt; Date.months_in_year(~D[1900-01-13])
12</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="new/4">new(year, month, day, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L282" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(Calendar.year(), Calendar.month(), Calendar.day(), Calendar.calendar()) ::
  {:ok, t()} | {:error, atom()}</pre> </div> <p>Builds a new ISO date.</p>
<p>Expects all values to be integers. Returns <code class="inline">{:ok, date}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p>
<h4 id="new/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.new(2000, 1, 1)
{:ok, ~D[2000-01-01]}
iex&gt; Date.new(2000, 13, 1)
{:error, :invalid_date}
iex&gt; Date.new(2000, 2, 29)
{:ok, ~D[2000-02-29]}

iex&gt; Date.new(2000, 2, 30)
{:error, :invalid_date}
iex&gt; Date.new(2001, 2, 29)
{:error, :invalid_date}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="new!/4">new!(year, month, day, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L307" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new!(Calendar.year(), Calendar.month(), Calendar.day(), Calendar.calendar()) ::
  t()</pre> </div> <p>Builds a new ISO date.</p>
<p>Expects all values to be integers. Returns <code class="inline">date</code> if each entry fits its appropriate range, raises if the date is invalid.</p>
<h4 id="new!/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.new!(2000, 1, 1)
~D[2000-01-01]
iex&gt; Date.new!(2000, 13, 1)
** (ArgumentError) cannot build date, reason: :invalid_date
iex&gt; Date.new!(2000, 2, 29)
~D[2000-02-29]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="quarter_of_year/1">quarter_of_year(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1048" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec quarter_of_year(Calendar.date()) :: non_neg_integer()</pre> </div> <p>Calculates the quarter of the year of a given <code class="inline">date</code>.</p>
<p>Returns the day of the year as an integer. For the ISO 8601 calendar (the default), it is an integer from 1 to 4.</p>
<h4 id="quarter_of_year/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.quarter_of_year(~D[2016-10-31])
4
iex&gt; Date.quarter_of_year(~D[2016-01-01])
1
iex&gt; Date.quarter_of_year(~N[2016-04-01 01:23:45])
2
iex&gt; Date.quarter_of_year(~D[-0015-09-30])
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="range/2">range(first, last)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L103" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec range(Calendar.date(), Calendar.date()) :: Date.Range.t()</pre> </div> <p>Returns a range of dates.</p>
<p>A range of dates represents a discrete number of dates where the first and last values are dates with matching calendars.</p>
<p>Ranges of dates can be increasing (<code class="inline">first &lt;= last</code>) and are always inclusive. For a decreasing range, use <a href="#range/3"><code class="inline">range/3</code></a> with a step of -1 as first argument.</p>
<h4 id="range/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.range(~D[1999-01-01], ~D[2000-01-01])
Date.range(~D[1999-01-01], ~D[2000-01-01])</pre>
<p>A range of dates implements the <a href="enumerable.html"><code class="inline">Enumerable</code></a> protocol, which means functions in the <a href="enum.html"><code class="inline">Enum</code></a> module can be used to work with ranges:</p>
<pre data-language="elixir">iex&gt; range = Date.range(~D[2001-01-01], ~D[2002-01-01])
iex&gt; range
Date.range(~D[2001-01-01], ~D[2002-01-01])
iex&gt; Enum.count(range)
366
iex&gt; ~D[2001-02-01] in range
true
iex&gt; Enum.take(range, 3)
[~D[2001-01-01], ~D[2001-01-02], ~D[2001-01-03]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="range/3">range(first, last, step)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L144" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec range(Calendar.date(), Calendar.date(), step :: pos_integer() | neg_integer()) ::
  Date.Range.t()</pre> </div> <p>Returns a range of dates with a step.</p>
<h4 id="range/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; range = Date.range(~D[2001-01-01], ~D[2002-01-01], 2)
iex&gt; range
Date.range(~D[2001-01-01], ~D[2002-01-01], 2)
iex&gt; Enum.count(range)
183
iex&gt; ~D[2001-01-03] in range
true
iex&gt; Enum.take(range, 3)
[~D[2001-01-01], ~D[2001-01-03], ~D[2001-01-05]]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shift/2">shift(date, duration)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L800" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shift(Calendar.date(), Duration.t() | [unit_pair]) :: t()
when unit_pair:
       {:year, integer()}
       | {:month, integer()}
       | {:week, integer()}
       | {:day, integer()}</pre> </div> <p>Shifts given <code class="inline">date</code> by <code class="inline">duration</code> according to its calendar.</p>
<p>Allowed units are: <code class="inline">:year</code>, <code class="inline">:month</code>, <code class="inline">:week</code>, <code class="inline">:day</code>.</p>
<p>When using the default ISO calendar, durations are collapsed and applied in the order of months and then days:</p>
<ul>
<li>when shifting by 1 year and 2 months the date is actually shifted by 14 months</li>
<li>when shifting by 2 weeks and 3 days the date is shifted by 17 days</li>
</ul>
<p>When shifting by month, days are rounded down to the nearest valid date.</p>
<p>Raises an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> when called with time scale units.</p>
<h4 id="shift/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.shift(~D[2016-01-03], month: 2)
~D[2016-03-03]
iex&gt; Date.shift(~D[2016-01-30], month: -1)
~D[2015-12-30]
iex&gt; Date.shift(~D[2016-01-31], year: 4, day: 1)
~D[2020-02-01]
iex&gt; Date.shift(~D[2016-01-03], Duration.new!(month: 2))
~D[2016-03-03]

# leap years
iex&gt; Date.shift(~D[2024-02-29], year: 1)
~D[2025-02-28]
iex&gt; Date.shift(~D[2024-02-29], year: 4)
~D[2028-02-29]

# rounding down
iex&gt; Date.shift(~D[2015-01-31], month: 1)
~D[2015-02-28]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_erl/1">to_erl(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L441" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_erl(Calendar.date()) :: :calendar.date()</pre> </div> <p>Converts the given <code class="inline">date</code> to an Erlang date tuple.</p>
<p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise.</p>
<h4 id="to_erl/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.to_erl(~D[2000-01-01])
{2000, 1, 1}

iex&gt; Date.to_erl(~N[2000-01-01 00:00:00])
{2000, 1, 1}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_gregorian_days/1">to_gregorian_days(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L525" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_gregorian_days(Calendar.date()) :: integer()</pre> </div> <p>Converts a <code class="inline">date</code> struct to a number of gregorian days.</p>
<h4 id="to_gregorian_days/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.to_gregorian_days(~D[0000-01-02])
1
iex&gt; Date.to_gregorian_days(~D[2000-01-01])
730_485
iex&gt; Date.to_gregorian_days(~N[2000-01-01 00:00:00])
730_485</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_iso8601/2">to_iso8601(date, format \\ :extended)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L411" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_iso8601(Calendar.date(), :extended | :basic) :: String.t()</pre> </div> <p>Converts the given <code class="inline">date</code> to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>By default, <a href="#to_iso8601/2"><code class="inline">Date.to_iso8601/2</code></a> returns dates formatted in the "extended" format, for human readability. It also supports the "basic" format through passing the <code class="inline">:basic</code> option.</p>
<p>Only supports converting dates which are in the ISO calendar, or other calendars in which the days also start at midnight. Attempting to convert dates from other calendars will raise an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a>.</p>
<h3 id="to_iso8601/2-examples" class="section-heading">  <span class="text">Examples</span> </h3> <pre data-language="elixir">iex&gt; Date.to_iso8601(~D[2000-02-28])
"2000-02-28"

iex&gt; Date.to_iso8601(~D[2000-02-28], :basic)
"20000228"

iex&gt; Date.to_iso8601(~N[2000-02-28 00:00:00])
"2000-02-28"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L331" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_string(Calendar.date()) :: String.t()</pre> </div> <p>Converts the given date to a string according to its calendar.</p>
<h3 id="to_string/1-examples" class="section-heading">  <span class="text">Examples</span> </h3> <pre data-language="elixir">iex&gt; Date.to_string(~D[2000-02-28])
"2000-02-28"
iex&gt; Date.to_string(~N[2000-02-28 01:23:45])
"2000-02-28"
iex&gt; Date.to_string(~D[-0100-12-15])
"-0100-12-15"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="utc_today/1">utc_today(calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L183" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec utc_today(Calendar.calendar()) :: t()</pre> </div> <p>Returns the current date in UTC.</p>
<h4 id="utc_today/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; date = Date.utc_today()
iex&gt; date.year &gt;= 2016
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="year_of_era/1">year_of_era(date)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/calendar/date.ex#L1073" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec year_of_era(Calendar.date()) :: {Calendar.year(), non_neg_integer()}</pre> </div> <p>Calculates the year-of-era and era for a given calendar year.</p>
<p>Returns a tuple <code class="inline">{year, era}</code> representing the year within the era and the era number.</p>
<h4 id="year_of_era/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Date.year_of_era(~D[0001-01-01])
{1, 1}
iex&gt; Date.year_of_era(~D[0000-12-31])
{1, 0}
iex&gt; Date.year_of_era(~D[-0001-01-01])
{2, 0}</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.17.2/Date.html" class="_attribution-link">https://hexdocs.pm/elixir/1.17.2/Date.html</a>
  </p>
</div>
