<div class="getting-started-title"> <small>Getting Started</small> <h1>Pattern matching</h1> </div>  <p>In this chapter, we will show how the <code class="language-plaintext highlighter-rouge">=</code> operator in Elixir is actually a match operator and how to use it to pattern match inside data structures. Finally, we will learn about the pin operator <code class="language-plaintext highlighter-rouge">^</code> used to access previously bound values.</p> <h2 id="the-match-operator">The match operator</h2> <p>We have used the <code class="language-plaintext highlighter-rouge">=</code> operator a couple times to assign variables in Elixir:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; x = 1
1
iex&gt; x
1
</pre></div> <p>In Elixir, the <code class="language-plaintext highlighter-rouge">=</code> operator is actually called <em>the match operator</em>. Let’s see why:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; x = 1
1
iex&gt; 1 = x
1
iex&gt; 2 = x
** (MatchError) no match of right hand side value: 1
</pre></div> <p>Notice that <code class="language-plaintext highlighter-rouge">1 = x</code> is a valid expression, and it matched because both the left and right side are equal to 1. When the sides do not match, a <code class="language-plaintext highlighter-rouge">MatchError</code> is raised.</p> <p>A variable can only be assigned on the left side of <code class="language-plaintext highlighter-rouge">=</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 1 = unknown
** (CompileError) iex:1: undefined function unknown/0
</pre></div> <p>Since there is no variable <code class="language-plaintext highlighter-rouge">unknown</code> previously defined, Elixir assumed you were trying to call a function named <code class="language-plaintext highlighter-rouge">unknown/0</code>, but such a function does not exist.</p> <h2 id="pattern-matching">Pattern matching</h2> <p>The match operator is not only used to match against simple values, but it is also useful for destructuring more complex data types. For example, we can pattern match on tuples:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {a, b, c} = {:hello, "world", 42}
{:hello, "world", 42}
iex&gt; a
:hello
iex&gt; b
"world"
</pre></div> <p>A pattern match error will occur if the sides can’t be matched, for example if the tuples have different sizes:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {a, b, c} = {:hello, "world"}
** (MatchError) no match of right hand side value: {:hello, "world"}
</pre></div> <p>And also when comparing different types, for example if matching a tuple on the left side with a list on the right side:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {a, b, c} = [:hello, "world", 42]
** (MatchError) no match of right hand side value: [:hello, "world", 42]
</pre></div> <p>More interestingly, we can match on specific values. The example below asserts that the left side will only match the right side when the right side is a tuple that starts with the atom <code class="language-plaintext highlighter-rouge">:ok</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {:ok, result} = {:ok, 13}
{:ok, 13}
iex&gt; result
13

iex&gt; {:ok, result} = {:error, :oops}
** (MatchError) no match of right hand side value: {:error, :oops}
</pre></div> <p>We can pattern match on lists:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [a, b, c] = [1, 2, 3]
[1, 2, 3]
iex&gt; a
1
</pre></div> <p>A list also supports matching on its own head and tail:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [head | tail] = [1, 2, 3]
[1, 2, 3]
iex&gt; head
1
iex&gt; tail
[2, 3]
</pre></div> <p>Similar to the <code class="language-plaintext highlighter-rouge">hd/1</code> and <code class="language-plaintext highlighter-rouge">tl/1</code> functions, we can’t match an empty list with a head and tail pattern:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [head | tail] = []
** (MatchError) no match of right hand side value: []
</pre></div> <p>The <code class="language-plaintext highlighter-rouge">[head | tail]</code> format is not only used on pattern matching but also for prepending items to a list:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; list = [1, 2, 3]
[1, 2, 3]
iex&gt; [0 | list]
[0, 1, 2, 3]
</pre></div> <p>Pattern matching allows developers to easily destructure data types such as tuples and lists. As we will see in the following chapters, it is one of the foundations of recursion in Elixir and applies to other types as well, like maps and binaries.</p> <h2 id="the-pin-operator">The pin operator</h2> <p>Variables in Elixir can be rebound:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; x = 1
1
iex&gt; x = 2
2
</pre></div> <p>However, there are times when we don’t want variables to be rebound.</p> <p>Use the pin operator <code class="language-plaintext highlighter-rouge">^</code> when you want to pattern match against a variable’s <em>existing value</em> rather than rebinding the variable.</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; x = 1
1
iex&gt; ^x = 2
** (MatchError) no match of right hand side value: 2
</pre></div> <p>Because we have pinned <code class="language-plaintext highlighter-rouge">x</code> when it was bound to the value of <code class="language-plaintext highlighter-rouge">1</code>, it is equivalent to the following:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 1 = 2
** (MatchError) no match of right hand side value: 2
</pre></div> <p>Notice that we even see the exact same error message.</p> <p>We can use the pin operator inside other pattern matches, such as tuples or lists:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; x = 1
1
iex&gt; [^x, 2, 3] = [1, 2, 3]
[1, 2, 3]
iex&gt; {y, ^x} = {2, 1}
{2, 1}
iex&gt; y
2
iex&gt; {y, ^x} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
</pre></div> <p>Because <code class="language-plaintext highlighter-rouge">x</code> was bound to the value of <code class="language-plaintext highlighter-rouge">1</code> when it was pinned, this last example could have been written as:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {y, 1} = {2, 2}
** (MatchError) no match of right hand side value: {2, 2}
</pre></div> <p>If a variable is mentioned more than once in a pattern, all references should bind to the same value:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; {x, x} = {1, 1}
{1, 1}
iex&gt; {x, x} = {1, 2}
** (MatchError) no match of right hand side value: {1, 2}
</pre></div> <p>In some cases, you don’t care about a particular value in a pattern. It is a common practice to bind those values to the underscore, <code class="language-plaintext highlighter-rouge">_</code>. For example, if only the head of the list matters to us, we can assign the tail to underscore:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [head | _] = [1, 2, 3]
[1, 2, 3]
iex&gt; head
1
</pre></div> <p>The variable <code class="language-plaintext highlighter-rouge">_</code> is special in that it can never be read from. Trying to read from it gives a compile error:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; _
** (CompileError) iex:1: invalid use of _. "_" represents a value to be ignored in a pattern and cannot be used in expressions
</pre></div> <p>Although pattern matching allows us to build powerful constructs, its usage is limited. For instance, you cannot make function calls on the left side of a match. The following example is invalid:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; length([1, [2], 3]) = 3
** (CompileError) iex:1: cannot invoke remote function :erlang.length/1 inside match
</pre></div> <p>This finishes our introduction to pattern matching. As we will see in the next chapter, pattern matching is very common in many language constructs.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/pattern-matching.html" class="_attribution-link">https://elixir-lang.org/getting-started/pattern-matching.html</a>
  </p>
</div>
