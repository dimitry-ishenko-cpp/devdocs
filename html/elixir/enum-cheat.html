<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/pages/cheatsheets/enum-cheat.cheatmd#L1" title="View Source" class="source" rel="help">Source</a>  <span>Enum cheatsheet</span> </h1> <p>A quick reference into the <a href="enum.html"><code class="inline">Enum</code></a> module, a module for working with collections (known as enumerables). Most of the examples below use the following data structure:</p>
<pre data-language="elixir">cart = [
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre>
<p>Some examples use the <a href="kernel.html#=~/2"><code class="inline">string =~ part</code></a> operator, which checks the string on the left contains the part on the right.</p>
<section class="h2 col-2"><h2 id="predicates" class="col-2 section-heading">  <span class="text">Predicates</span> </h2> <section class="h3"><h3 id="any-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#any?/2"><code class="inline">any?(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.any?(cart, &amp; &amp;1.fruit == "orange")
true
iex&gt; Enum.any?(cart, &amp; &amp;1.fruit == "pear")
false</pre>
<p><code class="inline">any?</code> with an empty collection is always false:</p>
<pre data-language="elixir">iex&gt; Enum.any?([], &amp; &amp;1.fruit == "orange")
false</pre></section><section class="h3"><h3 id="all-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#all?/2"><code class="inline">all?(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.all?(cart, &amp; &amp;1.count &gt; 0)
true
iex&gt; Enum.all?(cart, &amp; &amp;1.count &gt; 1)
false</pre>
<p><code class="inline">all?</code> with an empty collection is always true:</p>
<pre data-language="elixir">iex&gt; Enum.all?([], &amp; &amp;1.count &gt; 0)
true</pre></section><section class="h3"><h3 id="member-enum-value" class="section-heading">  <span class="text"><a href="enum.html#member?/2"><code class="inline">member?(enum, value)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.member?(cart, %{fruit: "apple", count: 3})
true
iex&gt; Enum.member?(cart, :something_else)
false</pre>
<p><code class="inline">item in enum</code> is equivalent to <code class="inline">Enum.member?(enum, item)</code>:</p>
<pre data-language="elixir">iex&gt; %{fruit: "apple", count: 3} in cart
true
iex&gt; :something_else in cart
false</pre></section><section class="h3"><h3 id="empty-enum" class="section-heading">  <span class="text"><a href="enum.html#empty?/1"><code class="inline">empty?(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.empty?(cart)
false
iex&gt; Enum.empty?([])
true</pre></section></section><section class="h2 col-2"><h2 id="filtering" class="col-2 section-heading">  <span class="text">Filtering</span> </h2> <section class="h3"><h3 id="filter-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#filter/2"><code class="inline">filter(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.filter(cart, &amp;(&amp;1.fruit =~ "o"))
[%{fruit: "orange", count: 6}]
iex&gt; Enum.filter(cart, &amp;(&amp;1.fruit =~ "e"))
[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="reject-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#reject/2"><code class="inline">reject(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reject(cart, &amp;(&amp;1.fruit =~ "o"))
[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre></section><section class="h3"><h3 id="flat_map-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#flat_map/2"><code class="inline">flat_map(enum, fun)</code></a></span> </h3> <p>This function (also listed <a href="#concatenating-flattening">below</a>) can be used to transform and filter in one pass, returning empty lists to exclude results:</p>
<pre data-language="elixir">iex&gt; Enum.flat_map(cart, fn item -&gt;
...&gt;   if item.count &gt; 1, do: [item.fruit], else: []
...&gt; end)
["apple", "orange"]</pre></section><section class="h3"><h3 id="comprehension" class="section-heading">  <span class="text"><a href="kernel.specialforms.html#for/1"><code class="inline">Comprehension</code></a></span> </h3> <p>Filtering can also be done with comprehensions:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart, item.fruit =~ "e" do
...&gt;   item
...&gt; end
[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
]</pre>
<p>Pattern-matching in comprehensions acts as a filter as well:</p>
<pre data-language="elixir">iex&gt; for %{count: 1, fruit: fruit} &lt;- cart do
...&gt;   fruit
...&gt; end
["banana"]</pre></section></section><section class="h2 col-2"><h2 id="mapping" class="col-2 section-heading">  <span class="text">Mapping</span> </h2> <section class="h3"><h3 id="map-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#map/2"><code class="inline">map(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.map(cart, &amp; &amp;1.fruit)
["apple", "banana", "orange"]
iex&gt; Enum.map(cart, fn item -&gt;
...&gt;   %{item | count: item.count + 10}
...&gt; end)
[
  %{fruit: "apple", count: 13},
  %{fruit: "banana", count: 11},
  %{fruit: "orange", count: 16}
]</pre></section><section class="h3"><h3 id="map_every-enum-nth-fun" class="section-heading">  <span class="text"><a href="enum.html#map_every/3"><code class="inline">map_every(enum, nth, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.map_every(cart, 2, fn item -&gt;
...&gt;   %{item | count: item.count + 10}
...&gt; end)
[
  %{fruit: "apple", count: 13},
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 16}
]</pre></section><section class="h3"><h3 id="comprehension-1" class="section-heading">  <span class="text"><a href="kernel.specialforms.html#for/1"><code class="inline">Comprehension</code></a></span> </h3> <p>Mapping can also be done with comprehensions:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart do
...&gt;   item.fruit
...&gt; end
["apple", "banana", "orange"]</pre>
<p>You can also filter and map at once:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart, item.fruit =~ "e" do
...&gt;   item.fruit
...&gt; end
["apple", "orange"]</pre></section></section><section class="h2 col-2"><h2 id="side-effects" class="col-2 section-heading">  <span class="text">Side-effects</span> </h2> <section class="h3"><h3 id="each-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#each/2"><code class="inline">each(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.each(cart, &amp;IO.puts(&amp;1.fruit))
apple
banana
orange
:ok</pre>
<p><a href="enum.html#each/2"><code class="inline">Enum.each/2</code></a> is used exclusively for side-effects.</p></section></section><section class="h2 col-2"><h2 id="accumulating" class="col-2 section-heading">  <span class="text">Accumulating</span> </h2> <section class="h3"><h3 id="reduce-enum-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#reduce/3"><code class="inline">reduce(enum, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reduce(cart, 0, fn item, acc -&gt;
...&gt;   item.count + acc
...&gt; end)
10</pre></section><section class="h3"><h3 id="map_reduce-enum-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#map_reduce/3"><code class="inline">map_reduce(enum, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.map_reduce(cart, 0, fn item, acc -&gt;
...&gt;   {item.fruit, item.count + acc}
...&gt; end)
{["apple", "banana", "orange"], 10}</pre></section><section class="h3"><h3 id="scan-enum-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#scan/3"><code class="inline">scan(enum, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.scan(cart, 0, fn item, acc -&gt;
...&gt;   item.count + acc
...&gt; end)
[3, 4, 10]</pre></section><section class="h3"><h3 id="reduce_while-enum-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#reduce_while/3"><code class="inline">reduce_while(enum, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reduce_while(cart, 0, fn item, acc -&gt;
...&gt;   if item.fruit == "orange" do
...&gt;     {:halt, acc}
...&gt;   else
...&gt;     {:cont, item.count + acc}
...&gt;   end
...&gt; end)
4</pre></section><section class="h3"><h3 id="comprehension-2" class="section-heading">  <span class="text"><a href="kernel.specialforms.html#for/1"><code class="inline">Comprehension</code></a></span> </h3> <p>Reducing can also be done with comprehensions:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart, reduce: 0 do
...&gt;   acc -&gt; item.count + acc
...&gt; end
10</pre>
<p>You can also filter and reduce at once:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart, item.fruit =~ "e", reduce: 0 do
...&gt;   acc -&gt; item.count + acc
...&gt; end
9</pre></section></section><section class="h2 col-2"><h2 id="aggregations" class="col-2 section-heading">  <span class="text">Aggregations</span> </h2> <section class="h3"><h3 id="count-enum" class="section-heading">  <span class="text"><a href="enum.html#count/1"><code class="inline">count(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.count(cart)
3</pre>
<p>See <a href="enum.html#count_until/2"><code class="inline">Enum.count_until/2</code></a> to count until a limit.</p></section><section class="h3"><h3 id="frequencies-enum" class="section-heading">  <span class="text"><a href="enum.html#frequencies/1"><code class="inline">frequencies(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.frequencies(["apple", "banana", "orange", "apple"])
%{"apple" =&gt; 2, "banana" =&gt; 1, "orange" =&gt; 1}</pre></section><section class="h3"><h3 id="frequencies_by-enum-key_fun" class="section-heading">  <span class="text"><a href="enum.html#frequencies_by/2"><code class="inline">frequencies_by(enum, key_fun)</code></a></span> </h3> <p>Frequencies of the last letter of the fruit:</p>
<pre data-language="elixir">iex&gt; Enum.frequencies_by(cart, &amp;String.last(&amp;1.fruit))
%{"a" =&gt; 1, "e" =&gt; 2}</pre></section><section class="h3"><h3 id="count-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#count/2"><code class="inline">count(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.count(cart, &amp;(&amp;1.fruit =~ "e"))
2
iex&gt; Enum.count(cart, &amp;(&amp;1.fruit =~ "y"))
0</pre>
<p>See <a href="enum.html#count_until/3"><code class="inline">Enum.count_until/3</code></a> to count until a limit with a function.</p></section><section class="h3"><h3 id="sum-enum" class="section-heading">  <span class="text"><a href="enum.html#sum/1"><code class="inline">sum(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp; &amp;1.count) |&gt; Enum.sum()
10</pre>
<p>Note: this should typically be done in one pass using <a href="enum.html#sum_by/2"><code class="inline">Enum.sum_by/2</code></a>.</p></section><section class="h3"><h3 id="sum_by-enum-mapper" class="section-heading">  <span class="text"><a href="enum.html#sum_by/2"><code class="inline">sum_by(enum, mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.sum_by(cart, &amp; &amp;1.count)
10</pre></section><section class="h3"><h3 id="product-enum" class="section-heading">  <span class="text"><a href="enum.html#product/1"><code class="inline">product(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp; &amp;1.count) |&gt; Enum.product()
18</pre>
<p>Note: this should typically be done in one pass using <a href="enum.html#product_by/2"><code class="inline">Enum.product_by/2</code></a>.</p></section><section class="h3"><h3 id="product_by-enum-mapper" class="section-heading">  <span class="text"><a href="enum.html#product_by/2"><code class="inline">product_by(enum, mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.product_by(cart, &amp; &amp;1.count)
18</pre></section></section><section class="h2 col-2"><h2 id="sorting" class="col-2 section-heading">  <span class="text">Sorting</span> </h2> <section class="h3"><h3 id="sort-enum-sorter-asc" class="section-heading">  <span class="text"><a href="enum.html#sort/2"><code class="inline">sort(enum, sorter \\ :asc)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp; &amp;1.fruit) |&gt; Enum.sort()
["apple", "banana", "orange"]
iex&gt; cart |&gt; Enum.map(&amp; &amp;1.fruit) |&gt; Enum.sort(:desc)
["orange", "banana", "apple"]</pre>
<p>When sorting structs, use <a href="enum.html#sort/2"><code class="inline">Enum.sort/2</code></a> with a module as sorter.</p></section><section class="h3"><h3 id="sort_by-enum-mapper-sorter-asc" class="section-heading">  <span class="text"><a href="enum.html#sort_by/2"><code class="inline">sort_by(enum, mapper, sorter \\ :asc)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.sort_by(cart, &amp; &amp;1.count)
[
  %{fruit: "banana", count: 1},
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
]
iex&gt; Enum.sort_by(cart, &amp; &amp;1.count, :desc)
[
  %{fruit: "orange", count: 6},
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre>
<p>When the sorted by value is a struct, use <a href="enum.html#sort_by/3"><code class="inline">Enum.sort_by/3</code></a> with a module as sorter.</p></section><section class="h3"><h3 id="min-enum" class="section-heading">  <span class="text"><a href="enum.html#min/1"><code class="inline">min(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp; &amp;1.count) |&gt; Enum.min()
1</pre>
<p>When comparing structs, use <a href="enum.html#min/2"><code class="inline">Enum.min/2</code></a> with a module as sorter.</p></section><section class="h3"><h3 id="min_by-enum-mapper" class="section-heading">  <span class="text"><a href="enum.html#min_by/2"><code class="inline">min_by(enum, mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.min_by(cart, &amp; &amp;1.count)
%{fruit: "banana", count: 1}</pre>
<p>When comparing structs, use <a href="enum.html#min_by/3"><code class="inline">Enum.min_by/3</code></a> with a module as sorter.</p></section><section class="h3"><h3 id="max-enum" class="section-heading">  <span class="text"><a href="enum.html#max/1"><code class="inline">max(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp; &amp;1.count) |&gt; Enum.max()
6</pre>
<p>When comparing structs, use <a href="enum.html#max/2"><code class="inline">Enum.max/2</code></a> with a module as sorter.</p></section><section class="h3"><h3 id="max_by-enum-mapper" class="section-heading">  <span class="text"><a href="enum.html#max_by/2"><code class="inline">max_by(enum, mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.max_by(cart, &amp; &amp;1.count)
%{fruit: "orange", count: 6}</pre>
<p>When comparing structs, use <a href="enum.html#max_by/3"><code class="inline">Enum.max_by/3</code></a> with a module as sorter.</p></section></section><section class="h2 col-2"><h2 id="concatenating-flattening" class="col-2 section-heading">  <span class="text">Concatenating &amp; flattening</span> </h2> <section class="h3"><h3 id="concat-enums" class="section-heading">  <span class="text"><a href="enum.html#concat/1"><code class="inline">concat(enums)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.concat([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
[1, 2, 3, 4, 5, 6, 7, 8, 9]</pre></section><section class="h3"><h3 id="concat-left-right" class="section-heading">  <span class="text"><a href="enum.html#concat/2"><code class="inline">concat(left, right)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.concat([1, 2, 3], [4, 5, 6])
[1, 2, 3, 4, 5, 6]</pre></section><section class="h3"><h3 id="flat_map-enum-fun-1" class="section-heading">  <span class="text"><a href="enum.html#flat_map/2"><code class="inline">flat_map(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.flat_map(cart, fn item -&gt;
...&gt;   List.duplicate(item.fruit, item.count)
...&gt; end)
["apple", "apple", "apple", "banana", "orange",
 "orange", "orange", "orange", "orange", "orange"]</pre></section><section class="h3"><h3 id="flat_map_reduce-enum-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#flat_map_reduce/3"><code class="inline">flat_map_reduce(enum, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.flat_map_reduce(cart, 0, fn item, acc -&gt;
...&gt;   list = List.duplicate(item.fruit, item.count)
...&gt;   acc = acc + item.count
...&gt;   {list, acc}
...&gt; end)
{["apple", "apple", "apple", "banana", "orange",
  "orange", "orange", "orange", "orange", "orange"], 10}</pre></section><section class="h3"><h3 id="comprehension-3" class="section-heading">  <span class="text"><a href="kernel.specialforms.html#for/1"><code class="inline">Comprehension</code></a></span> </h3> <p>Flattening can also be done with comprehensions:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart,
...&gt;     fruit &lt;- List.duplicate(item.fruit, item.count) do
...&gt;   fruit
...&gt; end
["apple", "apple", "apple", "banana", "orange",
 "orange", "orange", "orange", "orange", "orange"]</pre></section></section><section class="h2 col-2"><h2 id="conversion" class="col-2 section-heading">  <span class="text">Conversion</span> </h2> <section class="h3"><h3 id="into-enum-collectable" class="section-heading">  <span class="text"><a href="enum.html#into/2"><code class="inline">into(enum, collectable)</code></a></span> </h3> <pre data-language="elixir">iex&gt; pairs = [{"apple", 3}, {"banana", 1}, {"orange", 6}]
iex&gt; Enum.into(pairs, %{})
%{"apple" =&gt; 3, "banana" =&gt; 1, "orange" =&gt; 6}</pre></section><section class="h3"><h3 id="into-enum-collectable-transform" class="section-heading">  <span class="text"><a href="enum.html#into/3"><code class="inline">into(enum, collectable, transform)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.into(cart, %{}, fn item -&gt;
...&gt;   {item.fruit, item.count}
...&gt; end)
%{"apple" =&gt; 3, "banana" =&gt; 1, "orange" =&gt; 6}</pre></section><section class="h3"><h3 id="to_list-enum" class="section-heading">  <span class="text"><a href="enum.html#to_list/1"><code class="inline">to_list(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.to_list(1..5)
[1, 2, 3, 4, 5]</pre></section><section class="h3"><h3 id="comprehension-4" class="section-heading">  <span class="text"><a href="kernel.specialforms.html#for/1"><code class="inline">Comprehension</code></a></span> </h3> <p>Conversion can also be done with comprehensions:</p>
<pre data-language="elixir">iex&gt; for item &lt;- cart, into: %{} do
...&gt;   {item.fruit, item.count}
...&gt; end
%{"apple" =&gt; 3, "banana" =&gt; 1, "orange" =&gt; 6}</pre></section></section><section class="h2 col-2"><h2 id="duplicates-uniques" class="col-2 section-heading">  <span class="text">Duplicates &amp; uniques</span> </h2> <section class="h3"><h3 id="dedup-enum" class="section-heading">  <span class="text"><a href="enum.html#dedup/1"><code class="inline">dedup(enum)</code></a></span> </h3> <p><code class="inline">dedup</code> only removes contiguous duplicates:</p>
<pre data-language="elixir">iex&gt; Enum.dedup([1, 2, 2, 3, 3, 3, 1, 2, 3])
[1, 2, 3, 1, 2, 3]</pre></section><section class="h3"><h3 id="dedup_by-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#dedup_by/2"><code class="inline">dedup_by(enum, fun)</code></a></span> </h3> <p>Remove contiguous entries given a property:</p>
<pre data-language="elixir">iex&gt; Enum.dedup_by(cart, &amp; &amp;1.fruit =~ "a")
[%{fruit: "apple", count: 3}]
iex&gt; Enum.dedup_by(cart, &amp; &amp;1.count &lt; 5)
[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="uniq-enum" class="section-heading">  <span class="text"><a href="enum.html#uniq/1"><code class="inline">uniq(enum)</code></a></span> </h3> <p><code class="inline">uniq</code> applies to the whole collection:</p>
<pre data-language="elixir">iex&gt; Enum.uniq([1, 2, 2, 3, 3, 3, 1, 2, 3])
[1, 2, 3]</pre>
<p>Comprehensions also support the <code class="inline">uniq: true</code> option.</p></section><section class="h3"><h3 id="uniq_by-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#uniq_by/2"><code class="inline">uniq_by(enum, fun)</code></a></span> </h3> <p>Get entries which are unique by the last letter of the fruit:</p>
<pre data-language="elixir">iex&gt; Enum.uniq_by(cart, &amp;String.last(&amp;1.fruit))
[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre></section></section><section class="h2 col-2"><h2 id="indexing" class="col-2 section-heading">  <span class="text">Indexing</span> </h2> <section class="h3"><h3 id="at-enum-index-default-nil" class="section-heading">  <span class="text"><a href="enum.html#at/2"><code class="inline">at(enum, index, default \\ nil)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.at(cart, 0)
%{fruit: "apple", count: 3}
iex&gt; Enum.at(cart, 10)
nil
iex&gt; Enum.at(cart, 10, :none)
:none</pre>
<p>Accessing a list by index in a loop is discouraged.</p></section><section class="h3"><h3 id="fetch-enum-index" class="section-heading">  <span class="text"><a href="enum.html#fetch/2"><code class="inline">fetch(enum, index)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.fetch(cart, 0)
{:ok, %{fruit: "apple", count: 3}}
iex&gt; Enum.fetch(cart, 10)
:error</pre></section><section class="h3"><h3 id="fetch-enum-index-1" class="section-heading">  <span class="text"><a href="enum.html#fetch!/2"><code class="inline">fetch!(enum, index)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.fetch!(cart, 0)
%{fruit: "apple", count: 3}
iex&gt; Enum.fetch!(cart, 10)
** (Enum.OutOfBoundsError) out of bounds error</pre></section><section class="h3"><h3 id="with_index-enum" class="section-heading">  <span class="text"><a href="enum.html#with_index/1"><code class="inline">with_index(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.with_index(cart)
[
  {%{fruit: "apple", count: 3}, 0},
  {%{fruit: "banana", count: 1}, 1},
  {%{fruit: "orange", count: 6}, 2}
]</pre></section><section class="h3"><h3 id="with_index-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#with_index/2"><code class="inline">with_index(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.with_index(cart, fn item, index -&gt;
...&gt;   {item.fruit, index}
...&gt; end)
[
  {"apple", 0},
  {"banana", 1},
  {"orange", 2}
]</pre></section></section><section class="h2 col-2"><h2 id="finding" class="col-2 section-heading">  <span class="text">Finding</span> </h2> <section class="h3"><h3 id="find-enum-default-nil-fun" class="section-heading">  <span class="text"><a href="enum.html#find/2"><code class="inline">find(enum, default \\ nil, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.find(cart, &amp;(&amp;1.fruit =~ "o"))
%{fruit: "orange", count: 6}
iex&gt; Enum.find(cart, &amp;(&amp;1.fruit =~ "y"))
nil
iex&gt; Enum.find(cart, :none, &amp;(&amp;1.fruit =~ "y"))
:none</pre></section><section class="h3"><h3 id="find_index-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#find_index/2"><code class="inline">find_index(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.find_index(cart, &amp;(&amp;1.fruit =~ "o"))
2
iex&gt; Enum.find_index(cart, &amp;(&amp;1.fruit =~ "y"))
nil</pre></section><section class="h3"><h3 id="find_value-enum-default-nil-fun" class="section-heading">  <span class="text"><a href="enum.html#find_value/2"><code class="inline">find_value(enum, default \\ nil, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.find_value(cart, fn item -&gt;
...&gt;   if item.count == 1, do: item.fruit, else: nil
...&gt; end)
"banana"
iex&gt; Enum.find_value(cart, :none, fn item -&gt;
...&gt;   if item.count == 100, do: item.fruit, else: nil
...&gt; end)
:none</pre></section></section><section class="h2 col-2"><h2 id="grouping" class="col-2 section-heading">  <span class="text">Grouping</span> </h2> <section class="h3"><h3 id="group_by-enum-key_fun" class="section-heading">  <span class="text"><a href="enum.html#group_by/2"><code class="inline">group_by(enum, key_fun)</code></a></span> </h3> <p>Group by the last letter of the fruit:</p>
<pre data-language="elixir">iex&gt; Enum.group_by(cart, &amp;String.last(&amp;1.fruit))
%{
  "a" =&gt; [%{fruit: "banana", count: 1}],
  "e" =&gt; [
    %{fruit: "apple", count: 3},
    %{fruit: "orange", count: 6}
  ]
}</pre></section><section class="h3"><h3 id="group_by-enum-key_fun-value_fun" class="section-heading">  <span class="text"><a href="enum.html#group_by/3"><code class="inline">group_by(enum, key_fun, value_fun)</code></a></span> </h3> <p>Group by the last letter of the fruit with custom value:</p>
<pre data-language="elixir">iex&gt; Enum.group_by(cart, &amp;String.last(&amp;1.fruit), &amp; &amp;1.fruit)
%{
  "a" =&gt; ["banana"],
  "e" =&gt; ["apple", "orange"]
}</pre></section></section><section class="h2 col-2"><h2 id="joining-interspersing" class="col-2 section-heading">  <span class="text">Joining &amp; interspersing</span> </h2> <section class="h3"><h3 id="join-enum-joiner" class="section-heading">  <span class="text"><a href="enum.html#join/2"><code class="inline">join(enum, joiner \\ "")</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.join(["apple", "banana", "orange"], ", ")
"apple, banana, orange"</pre></section><section class="h3"><h3 id="map_join-enum-joiner-mapper" class="section-heading">  <span class="text"><a href="enum.html#map_join/3"><code class="inline">map_join(enum, joiner \\ "", mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.map_join(cart, ", ", &amp; &amp;1.fruit)
"apple, banana, orange"</pre></section><section class="h3"><h3 id="intersperse-enum-separator" class="section-heading">  <span class="text"><a href="enum.html#intersperse/2"><code class="inline">intersperse(enum, separator \\ "")</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.intersperse(["apple", "banana", "orange"], ", ")
["apple", ", ", "banana", ", ", "orange"]</pre></section><section class="h3"><h3 id="map_intersperse-enum-separator-mapper" class="section-heading">  <span class="text"><a href="enum.html#map_intersperse/3"><code class="inline">map_intersperse(enum, separator \\ "", mapper)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.map_intersperse(cart, ", ", &amp; &amp;1.fruit)
["apple", ", ", "banana", ", ", "orange"]</pre></section></section><section class="h2 col-2"><h2 id="slicing" class="col-2 section-heading">  <span class="text">Slicing</span> </h2> <section class="h3"><h3 id="slice-enum-index_range" class="section-heading">  <span class="text"><a href="enum.html#slice/2"><code class="inline">slice(enum, index_range)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.slice(cart, 0..1)
[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre>
<p>Negative ranges count from the back:</p>
<pre data-language="elixir">iex&gt; Enum.slice(cart, -2..-1)
[
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="slice-enum-start_index-amount" class="section-heading">  <span class="text"><a href="enum.html#slice/3"><code class="inline">slice(enum, start_index, amount)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.slice(cart, 1, 2)
[
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="slide-enum-range_or_single_index-insertion_index" class="section-heading">  <span class="text"><a href="enum.html#slide/3"><code class="inline">slide(enum, range_or_single_index, insertion_index)</code></a></span> </h3> <pre data-language="elixir">fruits = ["apple", "banana", "grape", "orange", "pear"]
iex&gt; Enum.slide(fruits, 2, 0)
["grape", "apple", "banana", "orange", "pear"]
iex&gt; Enum.slide(fruits, 2, 4)
["apple", "banana", "orange", "pear", "grape"]
iex&gt; Enum.slide(fruits, 1..3, 0)
["banana", "grape", "orange", "apple", "pear"]
iex&gt; Enum.slide(fruits, 1..3, 4)
["apple", "pear", "banana", "grape", "orange"]</pre></section></section><section class="h2 col-2"><h2 id="reversing" class="col-2 section-heading">  <span class="text">Reversing</span> </h2> <section class="h3"><h3 id="reverse-enum" class="section-heading">  <span class="text"><a href="enum.html#reverse/1"><code class="inline">reverse(enum)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reverse(cart)
[
  %{fruit: "orange", count: 6},
  %{fruit: "banana", count: 1},
  %{fruit: "apple", count: 3}
]</pre></section><section class="h3"><h3 id="reverse-enum-tail" class="section-heading">  <span class="text"><a href="enum.html#reverse/2"><code class="inline">reverse(enum, tail)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reverse(cart, [:this_will_be, :the_tail])
[
  %{fruit: "orange", count: 6},
  %{fruit: "banana", count: 1},
  %{fruit: "apple", count: 3},
  :this_will_be,
  :the_tail
]</pre></section><section class="h3"><h3 id="reverse_slice-enum-start_index-count" class="section-heading">  <span class="text"><a href="enum.html#reverse_slice/3"><code class="inline">reverse_slice(enum, start_index, count)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.reverse_slice(cart, 1, 2)
[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6},
  %{fruit: "banana", count: 1}
]</pre></section></section><section class="h2 col-2"><h2 id="splitting" class="col-2 section-heading">  <span class="text">Splitting</span> </h2> <section class="h3"><h3 id="split-enum-amount" class="section-heading">  <span class="text"><a href="enum.html#split/2"><code class="inline">split(enum, amount)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.split(cart, 1)
{[%{fruit: "apple", count: 3}],
 [
   %{fruit: "banana", count: 1},
   %{fruit: "orange", count: 6}
 ]}</pre>
<p>Negative indexes count from the back:</p>
<pre data-language="elixir">iex&gt; Enum.split(cart, -1)
{[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
 ],
 [%{fruit: "orange", count: 6}]}</pre></section><section class="h3"><h3 id="split_while-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#split_while/2"><code class="inline">split_while(enum, fun)</code></a></span> </h3> <p>Stops splitting as soon as it is false:</p>
<pre data-language="elixir">iex&gt; Enum.split_while(cart, &amp;(&amp;1.fruit =~ "e"))
{[%{fruit: "apple", count: 3}],
 [
   %{fruit: "banana", count: 1},
   %{fruit: "orange", count: 6}
 ]}</pre></section><section class="h3"><h3 id="split_with-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#split_with/2"><code class="inline">split_with(enum, fun)</code></a></span> </h3> <p>Splits the whole collection:</p>
<pre data-language="elixir">iex&gt; Enum.split_with(cart, &amp;(&amp;1.fruit =~ "e"))
{[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
 ],
 [%{fruit: "banana", count: 1}]}</pre></section></section><section class="h2 col-2"><h2 id="splitting-drop-and-take" class="col-2 section-heading">  <span class="text">Splitting (drop and take)</span> </h2> <section class="h3"><h3 id="drop-enum-amount" class="section-heading">  <span class="text"><a href="enum.html#drop/2"><code class="inline">drop(enum, amount)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.drop(cart, 1)
[
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre>
<p>Negative indexes count from the back:</p>
<pre data-language="elixir">iex&gt; Enum.drop(cart, -1)
[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre></section><section class="h3"><h3 id="drop_every-enum-nth" class="section-heading">  <span class="text"><a href="enum.html#drop_every/2"><code class="inline">drop_every(enum, nth)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.drop_every(cart, 2)
[%{fruit: "banana", count: 1}]</pre></section><section class="h3"><h3 id="drop_while-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#drop_while/2"><code class="inline">drop_while(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.drop_while(cart, &amp;(&amp;1.fruit =~ "e"))
[
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="take-enum-amount" class="section-heading">  <span class="text"><a href="enum.html#take/2"><code class="inline">take(enum, amount)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.take(cart, 1)
[%{fruit: "apple", count: 3}]</pre>
<p>Negative indexes count from the back:</p>
<pre data-language="elixir">iex&gt; Enum.take(cart, -1)
[%{fruit: "orange", count: 6}]</pre></section><section class="h3"><h3 id="take_every-enum-nth" class="section-heading">  <span class="text"><a href="enum.html#take_every/2"><code class="inline">take_every(enum, nth)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.take_every(cart, 2)
[
  %{fruit: "apple", count: 3},
  %{fruit: "orange", count: 6}
]</pre></section><section class="h3"><h3 id="take_while-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#take_while/2"><code class="inline">take_while(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.take_while(cart, &amp;(&amp;1.fruit =~ "e"))
[%{fruit: "apple", count: 3}]</pre></section></section><section class="h2 col-2"><h2 id="random" class="col-2 section-heading">  <span class="text">Random</span> </h2> <section class="h3"><h3 id="random-enum" class="section-heading">  <span class="text"><a href="enum.html#random/1"><code class="inline">random(enum)</code></a></span> </h3> <p>Results will vary on every call:</p>
<pre data-language="elixir">iex&gt; Enum.random(cart)
%{fruit: "orange", count: 6}</pre></section><section class="h3"><h3 id="take_random-enum-count" class="section-heading">  <span class="text"><a href="enum.html#take_random/2"><code class="inline">take_random(enum, count)</code></a></span> </h3> <p>Results will vary on every call:</p>
<pre data-language="elixir">iex&gt; Enum.take_random(cart, 2)
[
  %{fruit: "orange", count: 6},
  %{fruit: "apple", count: 3}
]</pre></section><section class="h3"><h3 id="shuffle-enum" class="section-heading">  <span class="text"><a href="enum.html#shuffle/1"><code class="inline">shuffle(enum)</code></a></span> </h3> <p>Results will vary on every call:</p>
<pre data-language="elixir">iex&gt; Enum.shuffle(cart)
[
  %{fruit: "orange", count: 6},
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1}
]</pre></section></section><section class="h2 col-2"><h2 id="chunking" class="col-2 section-heading">  <span class="text">Chunking</span> </h2> <section class="h3"><h3 id="chunk_by-enum-fun" class="section-heading">  <span class="text"><a href="enum.html#chunk_by/2"><code class="inline">chunk_by(enum, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.chunk_by(cart, &amp;String.length(&amp;1.fruit))
[
  [%{fruit: "apple", count: 3}],
  [
    %{fruit: "banana", count: 1},
    %{fruit: "orange", count: 6}
  ]
]</pre></section><section class="h3"><h3 id="chunk_every-enum-count" class="section-heading">  <span class="text"><a href="enum.html#chunk_every/2"><code class="inline">chunk_every(enum, count)</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.chunk_every(cart, 2)
[
  [
    %{fruit: "apple", count: 3},
    %{fruit: "banana", count: 1}
  ],
  [%{fruit: "orange", count: 6}]
]</pre></section><section class="h3"><h3 id="chunk_every-enum-count-step-leftover" class="section-heading">  <span class="text"><a href="enum.html#chunk_every/2"><code class="inline">chunk_every(enum, count, step, leftover \\ [])</code></a></span> </h3> <pre data-language="elixir">iex&gt; Enum.chunk_every(cart, 2, 2, [:elements, :to_complete])
[
  [
    %{fruit: "apple", count: 3},
    %{fruit: "banana", count: 1}
  ],
  [
    %{fruit: "orange", count: 6},
    :elements
  ]
]
iex&gt; Enum.chunk_every(cart, 2, 1, :discard)
[
  [
    %{fruit: "apple", count: 3},
    %{fruit: "banana", count: 1}
  ],
  [
    %{fruit: "banana", count: 1},
    %{fruit: "orange", count: 6}
  ]
]</pre>
<p>See <a href="enum.html#chunk_while/4"><code class="inline">Enum.chunk_while/4</code></a> for custom chunking.</p></section></section><section class="h2 col-2"><h2 id="zipping" class="col-2 section-heading">  <span class="text">Zipping</span> </h2> <section class="h3"><h3 id="zip-enum1-enum2" class="section-heading">  <span class="text"><a href="enum.html#zip/2"><code class="inline">zip(enum1, enum2)</code></a></span> </h3> <pre data-language="elixir">iex&gt; fruits = ["apple", "banana", "orange"]
iex&gt; counts = [3, 1, 6]
iex&gt; Enum.zip(fruits, counts)
[{"apple", 3}, {"banana", 1}, {"orange", 6}]</pre>
<p>See <a href="enum.html#zip/1"><code class="inline">Enum.zip/1</code></a> for zipping many collections at once.</p></section><section class="h3"><h3 id="zip_with-enum1-enum2-fun" class="section-heading">  <span class="text"><a href="enum.html#zip_with/2"><code class="inline">zip_with(enum1, enum2, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; fruits = ["apple", "banana", "orange"]
iex&gt; counts = [3, 1, 6]
iex&gt; Enum.zip_with(fruits, counts, fn fruit, count -&gt;
...&gt;   %{fruit: fruit, count: count}
...&gt; end)
[
  %{fruit: "apple", count: 3},
  %{fruit: "banana", count: 1},
  %{fruit: "orange", count: 6}
]</pre>
<p>See <a href="enum.html#zip_with/2"><code class="inline">Enum.zip_with/2</code></a> for zipping many collections at once.</p></section><section class="h3"><h3 id="zip_reduce-left-right-acc-fun" class="section-heading">  <span class="text"><a href="enum.html#zip_reduce/4"><code class="inline">zip_reduce(left, right, acc, fun)</code></a></span> </h3> <pre data-language="elixir">iex&gt; fruits = ["apple", "banana", "orange"]
iex&gt; counts = [3, 1, 6]
iex&gt; Enum.zip_reduce(fruits, counts, 0, fn fruit, count, acc -&gt;
...&gt;   price = if fruit =~ "e", do: count * 2, else: count
...&gt;   acc + price
...&gt; end)
19</pre>
<p>See <a href="enum.html#zip_reduce/3"><code class="inline">Enum.zip_reduce/3</code></a> for zipping many collections at once.</p></section><section class="h3"><h3 id="unzip-list" class="section-heading">  <span class="text"><a href="enum.html#unzip/1"><code class="inline">unzip(list)</code></a></span> </h3> <pre data-language="elixir">iex&gt; cart |&gt; Enum.map(&amp;{&amp;1.fruit, &amp;1.count}) |&gt; Enum.unzip()
{["apple", "banana", "orange"], [3, 1, 6]}</pre></section></section> </div> <div class="bottom-actions" id="bottom-actions"> <div class="bottom-actions-item"> <a href="debugging.html" class="bottom-actions-button" rel="prev"> <span class="subheader"> ← Previous Page </span> <span class="title"> Debugging </span> </a> </div> <div class="bottom-actions-item"> <a href="what-anti-patterns.html" class="bottom-actions-button" rel="next"> <span class="subheader"> Next Page → </span> <span class="title"> What are anti-patterns? </span> </a> </div> </div> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/enum-cheat.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/enum-cheat.html</a>
  </p>
</div>
