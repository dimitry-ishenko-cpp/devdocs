<div class="getting-started-title"> <small>Getting Started</small> <h1>Basic operators</h1> </div>  <p>In the <a href="basic-types.html">previous chapter</a>, we saw Elixir provides <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">-</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">/</code> as arithmetic operators, plus the functions <code class="language-plaintext highlighter-rouge">div/2</code> and <code class="language-plaintext highlighter-rouge">rem/2</code> for integer division and remainder.</p> <p>Elixir also provides <code class="language-plaintext highlighter-rouge">++</code> and <code class="language-plaintext highlighter-rouge">--</code> to manipulate lists:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; [1, 2, 3] ++ [4, 5, 6]
[1, 2, 3, 4, 5, 6]
iex&gt; [1, 2, 3] -- [2]
[1, 3]
</pre></div> <p>String concatenation is done with <code class="language-plaintext highlighter-rouge">&lt;&gt;</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; "foo" &lt;&gt; "bar"
"foobar"
</pre></div> <p>Elixir also provides three boolean operators: <code class="language-plaintext highlighter-rouge">or</code>, <code class="language-plaintext highlighter-rouge">and</code> and <code class="language-plaintext highlighter-rouge">not</code>. These operators are strict in the sense that they expect something that evaluates to a boolean (<code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code>) as their first argument:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; true and true
true
iex&gt; false or is_atom(:example)
true
</pre></div> <p>Providing a non-boolean will raise an exception:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 1 and true
** (BadBooleanError) expected a boolean on left-side of "and", got: 1
</pre></div> <p><code class="language-plaintext highlighter-rouge">or</code> and <code class="language-plaintext highlighter-rouge">and</code> are short-circuit operators. They only execute the right side if the left side is not enough to determine the result:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; false and raise("This error will never be raised")
false
iex&gt; true or raise("This error will never be raised")
true
</pre></div> <p>Besides these boolean operators, Elixir also provides <code class="language-plaintext highlighter-rouge">||</code>, <code class="language-plaintext highlighter-rouge">&amp;&amp;</code> and <code class="language-plaintext highlighter-rouge">!</code> which accept arguments of any type. For these operators, all values except <code class="language-plaintext highlighter-rouge">false</code> and <code class="language-plaintext highlighter-rouge">nil</code> will evaluate to true:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language=""># or
iex&gt; 1 || true
1
iex&gt; false || 11
11

# and
iex&gt; nil &amp;&amp; 13
nil
iex&gt; true &amp;&amp; 17
17

# not
iex&gt; !true
false
iex&gt; !1
false
iex&gt; !nil
true
</pre></div> <p>As a rule of thumb, use <code class="language-plaintext highlighter-rouge">and</code>, <code class="language-plaintext highlighter-rouge">or</code> and <code class="language-plaintext highlighter-rouge">not</code> when you are expecting booleans. If any of the arguments are non-boolean, use <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>, <code class="language-plaintext highlighter-rouge">||</code> and <code class="language-plaintext highlighter-rouge">!</code>.</p> <p>Elixir also provides <code class="language-plaintext highlighter-rouge">==</code>, <code class="language-plaintext highlighter-rouge">!=</code>, <code class="language-plaintext highlighter-rouge">===</code>, <code class="language-plaintext highlighter-rouge">!==</code>, <code class="language-plaintext highlighter-rouge">&lt;=</code>, <code class="language-plaintext highlighter-rouge">&gt;=</code>, <code class="language-plaintext highlighter-rouge">&lt;</code> and <code class="language-plaintext highlighter-rouge">&gt;</code> as comparison operators:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 1 == 1
true
iex&gt; 1 != 2
true
iex&gt; 1 &lt; 2
true
</pre></div> <p>The difference between <code class="language-plaintext highlighter-rouge">==</code> and <code class="language-plaintext highlighter-rouge">===</code> is that the latter is more strict when comparing integers and floats:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; 1 == 1.0
true
iex&gt; 1 === 1.0
false
</pre></div> <p>We say these operators perform <em>structural comparison</em>. For more information, you can read our documentation on <a href="https://hexdocs.pm/elixir/Kernel.html#module-structural-comparison">Structural vs Semantic comparisons</a>.</p> <p>In the next chapter, we are going to discuss pattern matching through the use of <code class="language-plaintext highlighter-rouge">=</code>, the match operator.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/basic-operators.html" class="_attribution-link">https://elixir-lang.org/getting-started/basic-operators.html</a>
  </p>
</div>
