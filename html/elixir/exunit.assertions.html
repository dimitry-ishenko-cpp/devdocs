<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L64" title="View Source" class="source" rel="help">Source</a> <span translate="no">ExUnit.Assertions</span>  </h1> <section id="moduledoc"> <p>This module contains a set of assertion functions that are imported by default into your test cases.</p>
<p>In general, a developer will want to use the general <code class="inline">assert</code> macro in tests. This macro introspects your code and provides good reporting whenever there is a failure. For example, <code class="inline">assert some_fun() == 10</code> will fail (assuming <code class="inline">some_fun()</code> returns <code class="inline">13</code>):</p>
<pre data-language="elixir">Comparison (using ==) failed in:
code:  assert some_fun() == 10
left:  13
right: 10</pre>
<p>This module also provides other convenience functions like <code class="inline">assert_in_delta</code> and <code class="inline">assert_raise</code> to easily handle other common cases such as checking a floating-point number or handling exceptions.</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#assert/1" data-no-tooltip translate="no">assert(assertion)</a> </dt> <dd class="summary-synopsis"><p>Asserts its argument is a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert/2" data-no-tooltip translate="no">assert(value, message)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">value</code> is truthy, displaying the given <code class="inline">message</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_in_delta/4" data-no-tooltip translate="no">assert_in_delta(value1, value2, delta, message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts that <code class="inline">value1</code> and <code class="inline">value2</code> differ by no more than <code class="inline">delta</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_raise/2" data-no-tooltip translate="no">assert_raise(exception, function)</a> </dt> <dd class="summary-synopsis"><p>Asserts the <code class="inline">exception</code> is raised during <code class="inline">function</code> execution. Returns the rescued exception, fails otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_raise/3" data-no-tooltip translate="no">assert_raise(exception, message, function)</a> </dt> <dd class="summary-synopsis"><p>Asserts the <code class="inline">exception</code> is raised during <code class="inline">function</code> execution with the expected <code class="inline">message</code>, which can be a <a href="https://hexdocs.pm/elixir/Regex.html"><code class="inline">Regex</code></a> or an exact <a href="https://hexdocs.pm/elixir/String.html"><code class="inline">String</code></a>. Returns the rescued exception, fails otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_receive/3" data-no-tooltip translate="no">assert_receive(pattern, timeout \\ nil, failure_message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts that a message matching <code class="inline">pattern</code> was or is going to be received within the <code class="inline">timeout</code> period, specified in milliseconds.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#assert_received/2" data-no-tooltip translate="no">assert_received(pattern, failure_message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts that a message matching <code class="inline">pattern</code> was received and is in the current process' mailbox.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#catch_error/1" data-no-tooltip translate="no">catch_error(expression)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">expression</code> will cause an error.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#catch_exit/1" data-no-tooltip translate="no">catch_exit(expression)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">expression</code> will exit.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#catch_throw/1" data-no-tooltip translate="no">catch_throw(expression)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">expression</code> will throw a value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flunk/1" data-no-tooltip translate="no">flunk(message \\ "Flunked!")</a> </dt> <dd class="summary-synopsis"><p>Fails with a message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute/1" data-no-tooltip translate="no">refute(assertion)</a> </dt> <dd class="summary-synopsis"><p>A negative assertion, expects the expression to be <code class="inline">false</code> or <code class="inline">nil</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute/2" data-no-tooltip translate="no">refute(value, message)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">value</code> is <code class="inline">nil</code> or <code class="inline">false</code> (that is, <code class="inline">value</code> is not truthy).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute_in_delta/4" data-no-tooltip translate="no">refute_in_delta(value1, value2, delta, message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts <code class="inline">value1</code> and <code class="inline">value2</code> are not within <code class="inline">delta</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute_receive/3" data-no-tooltip translate="no">refute_receive(pattern, timeout \\ nil, failure_message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts that a message matching <code class="inline">pattern</code> was not received (and won't be received) within the <code class="inline">timeout</code> period, specified in milliseconds.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#refute_received/2" data-no-tooltip translate="no">refute_received(pattern, failure_message \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Asserts a message matching <code class="inline">pattern</code> was not received (i.e. it is not in the current process' mailbox).</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="assert/1">assert(assertion)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L125" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts its argument is a truthy value.</p>
<p><code class="inline">assert</code> introspects the underlying expression and provides good reporting whenever there is a failure. For example, if the expression uses the comparison operator, the message will show the values of the two sides. The assertion</p>
<pre data-language="elixir">assert 1 + 2 + 3 + 4 &gt; 15</pre>
<p> will fail with the message:</p>
<pre data-language="elixir">Assertion with &gt; failed
code:  assert 1 + 2 + 3 + 4 &gt; 15
left:  10
right: 15</pre>
<p>Similarly, if a match expression is given, it will report any failure in terms of that match. Given</p>
<pre data-language="elixir">assert [1] = [2]</pre>
<p>you'll see:</p>
<pre data-language="elixir">match (=) failed
code:  assert [1] = [2]
left: [1]
right: [2]</pre>
<p>Keep in mind that <code class="inline">assert</code> does not change its semantics based on the expression. In other words, the expression is still required to return a truthy value. For example, the following will fail:</p>
<pre data-language="elixir">assert nil = some_function_that_returns_nil()</pre>
<p>Even though the match works, <code class="inline">assert</code> still expects a truth value. In such cases, simply use <a href="https://hexdocs.pm/elixir/Kernel.html#==/2"><code class="inline">==/2</code></a> or <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert/2">assert(value, message)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L408" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">value</code> is truthy, displaying the given <code class="inline">message</code> otherwise.</p>
<h4 id="assert/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert false, "it will never be true"

assert x == :foo, "expected x to be foo"

assert match?({:ok, _}, x), "expected x to match {:ok, _}"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_in_delta/4">assert_in_delta(value1, value2, delta, message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L854" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts that <code class="inline">value1</code> and <code class="inline">value2</code> differ by no more than <code class="inline">delta</code>.</p>
<p>This difference is inclusive, so the test will pass if the difference and the <code class="inline">delta</code> are equal.</p>
<h4 id="assert_in_delta/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert_in_delta 1.1, 1.5, 0.2
assert_in_delta 10, 15, 2
assert_in_delta 10, 15, 5</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_raise/2">assert_raise(exception, function)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L803" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts the <code class="inline">exception</code> is raised during <code class="inline">function</code> execution. Returns the rescued exception, fails otherwise.</p>
<h4 id="assert_raise/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert_raise ArithmeticError, fn -&gt;
  1 + "test"
end

assert_raise RuntimeError, fn -&gt;
  raise "assertion will pass due to this raise"
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="assert_raise/3">assert_raise(exception, message, function)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L769" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts the <code class="inline">exception</code> is raised during <code class="inline">function</code> execution with the expected <code class="inline">message</code>, which can be a <a href="https://hexdocs.pm/elixir/Regex.html"><code class="inline">Regex</code></a> or an exact <a href="https://hexdocs.pm/elixir/String.html"><code class="inline">String</code></a>. Returns the rescued exception, fails otherwise.</p>
<h4 id="assert_raise/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert_raise ArithmeticError, "bad argument in arithmetic expression", fn -&gt;
  1 + "test"
end

assert_raise RuntimeError, ~r/^today's lucky number is 0\.\d+!$/, fn -&gt;
  raise "today's lucky number is #{:rand.uniform()}!"
end</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="assert_receive/3">assert_receive(pattern, timeout \\ nil, failure_message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L444" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts that a message matching <code class="inline">pattern</code> was or is going to be received within the <code class="inline">timeout</code> period, specified in milliseconds.</p>
<p>Unlike <code class="inline">assert_received</code>, it has a configurable timeout. The default timeout duration is determined by the <code class="inline">assert_receive_timeout</code> option, which can be set using <a href="exunit.html#configure/1"><code class="inline">ExUnit.configure/1</code></a>. This option defaults to 100 milliseconds.</p>
<p>The <code class="inline">pattern</code> argument must be a match pattern. Flunks with <code class="inline">failure_message</code> if a message matching <code class="inline">pattern</code> is not received.</p>
<h4 id="assert_receive/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert_receive :hello</pre>
<p>Asserts against a larger timeout:</p>
<pre data-language="elixir">assert_receive :hello, 20_000</pre>
<p>You can also match against specific patterns:</p>
<pre data-language="elixir">assert_receive {:hello, _}

x = 5
assert_receive {:count, ^x}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="assert_received/2">assert_received(pattern, failure_message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L473" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts that a message matching <code class="inline">pattern</code> was received and is in the current process' mailbox.</p>
<p>The <code class="inline">pattern</code> argument must be a match pattern. Flunks with <code class="inline">failure_message</code> if a message matching <code class="inline">pattern</code> was not received.</p>
<p>Timeout is set to 0, so there is no waiting time.</p>
<h4 id="assert_received/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">send(self(), :hello)
assert_received :hello

send(self(), :bye)
assert_received :hello, "Oh No!"
** (ExUnit.AssertionError) Oh No!</pre>
<p>You can also match against specific patterns:</p>
<pre data-language="elixir">send(self(), {:hello, "world"})
assert_received {:hello, _}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="catch_error/1">catch_error(expression)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L916" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">expression</code> will cause an error.</p>
<p>Returns the error or fails otherwise.</p>
<h4 id="catch_error/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert catch_error(error(1)) == 1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="catch_exit/1">catch_exit(expression)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L902" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">expression</code> will exit.</p>
<p>Returns the exit status/message of the current process or fails otherwise.</p>
<h4 id="catch_exit/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert catch_exit(exit(1)) == 1</pre>
<p>To assert exits from linked processes started from the test, trap exits with <a href="https://hexdocs.pm/elixir/Process.html#flag/2"><code class="inline">Process.flag/2</code></a> and assert the exit message with <a href="#assert_receive/2"><code class="inline">assert_receive/2</code></a>.</p>
<pre data-language="elixir">Process.flag(:trap_exit, true)
pid = spawn_link(fn -&gt; Process.exit(self(), :normal) end)
assert_receive {:EXIT, ^pid, :normal}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="catch_throw/1">catch_throw(expression)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L881" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">expression</code> will throw a value.</p>
<p>Returns the thrown value or fails otherwise.</p>
<h4 id="catch_throw/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">assert catch_throw(throw(1)) == 1</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="flunk/1">flunk(message \\ "Flunked!")<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L1061" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec flunk(String.t()) :: no_return()</pre> </div> <p>Fails with a message.</p>
<h4 id="flunk/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">flunk("This should raise an error")</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="refute/1">refute(assertion)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L202" class="source">Source</a>
</h3> <section class="docstring"> <p>A negative assertion, expects the expression to be <code class="inline">false</code> or <code class="inline">nil</code>.</p>
<p>Keep in mind that <code class="inline">refute</code> does not change the semantics of the given expression. In other words, the following will fail:</p>
<pre data-language="elixir">refute {:ok, _} = some_function_that_returns_error_tuple()</pre>
<p>The code above will fail because the <code class="inline">=</code> operator always fails when the sides do not match and <a href="#refute/2"><code class="inline">refute/2</code></a> does not change it.</p>
<p>The correct way to write the refutation above is to use <a href="https://hexdocs.pm/elixir/Kernel.html#match?/2"><code class="inline">match?/2</code></a>:</p>
<pre data-language="elixir">refute match?({:ok, _}, some_function_that_returns_error_tuple())</pre>
<h4 id="refute/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">refute age &lt; 0</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="refute/2">refute(value, message)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L942" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">value</code> is <code class="inline">nil</code> or <code class="inline">false</code> (that is, <code class="inline">value</code> is not truthy).</p>
<h4 id="refute/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">refute true, "This will obviously fail"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="refute_in_delta/4">refute_in_delta(value1, value2, delta, message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L1035" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts <code class="inline">value1</code> and <code class="inline">value2</code> are not within <code class="inline">delta</code>.</p>
<p>This difference is exclusive, so the test will fail if the difference and the delta are equal.</p>
<p>If you supply <code class="inline">message</code>, information about the values will automatically be appended to it.</p>
<h4 id="refute_in_delta/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">refute_in_delta 1.1, 1.2, 0.2
refute_in_delta 10, 11, 2</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="refute_receive/3">refute_receive(pattern, timeout \\ nil, failure_message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L962" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts that a message matching <code class="inline">pattern</code> was not received (and won't be received) within the <code class="inline">timeout</code> period, specified in milliseconds.</p>
<p>The <code class="inline">pattern</code> argument must be a match pattern. Flunks with <code class="inline">failure_message</code> if a message matching <code class="inline">pattern</code> is received.</p>
<h4 id="refute_receive/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">refute_receive :bye</pre>
<p>Refute received with an explicit timeout:</p>
<pre data-language="elixir">refute_receive :bye, 1000</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="refute_received/2">refute_received(pattern, failure_message \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/ex_unit/lib/ex_unit/assertions.ex#L985" class="source">Source</a>
</h3> <section class="docstring"> <p>Asserts a message matching <code class="inline">pattern</code> was not received (i.e. it is not in the current process' mailbox).</p>
<p>The <code class="inline">pattern</code> argument must be a match pattern. Flunks with <code class="inline">failure_message</code> if a message matching <code class="inline">pattern</code> was received.</p>
<p>Timeout is set to 0, so there is no waiting time.</p>
<h4 id="refute_received/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">send(self(), :hello)
refute_received :bye

send(self(), :hello)
refute_received :hello, "Oh No!"
** (ExUnit.AssertionError) Oh No!</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="exunit.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/ex_unit/1.17.2/ExUnit.Assertions.html" class="_attribution-link">https://hexdocs.pm/ex_unit/1.17.2/ExUnit.Assertions.html</a>
  </p>
</div>
