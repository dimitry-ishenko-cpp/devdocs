<div class="getting-started-title"> <small>Getting Started</small> <h1>Recursion</h1> </div>  <h2 id="loops-through-recursion">Loops through recursion</h2> <p>Due to immutability, loops in Elixir (as in any functional programming language) are written differently from imperative languages. For example, in an imperative language like C, one would write:</p> <div class="language-c highlighter-rouge"><pre class="highlight" data-language="">for(i = 0; i &lt; sizeof(array); i++) {
  array[i] = array[i] * 2;
}
</pre></div> <p>In the example above, we are mutating both the array and the variable <code class="language-plaintext highlighter-rouge">i</code>. However, data structures in Elixir are immutable. For this reason, functional languages rely on recursion: a function is called recursively until a condition is reached that stops the recursive action from continuing. No data is mutated in this process. Consider the example below that prints a string an arbitrary number of times:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Recursion do
  def print_multiple_times(msg, n) when n &gt; 0 do
    IO.puts(msg)
    print_multiple_times(msg, n - 1)
  end

  def print_multiple_times(_msg, 0) do
    :ok
  end
end

Recursion.print_multiple_times("Hello!", 3)
# Hello!
# Hello!
# Hello!
:ok
</pre></div> <p>Similar to <code class="language-plaintext highlighter-rouge">case</code>, a function may have many clauses. A particular clause is executed when the arguments passed to the function match the clause’s argument patterns and its guards evaluate to <code class="language-plaintext highlighter-rouge">true</code>.</p> <p>When <code class="language-plaintext highlighter-rouge">print_multiple_times/2</code> is initially called in the example above, the argument <code class="language-plaintext highlighter-rouge">n</code> is equal to <code class="language-plaintext highlighter-rouge">3</code>.</p> <p>The first clause has a guard which says “use this definition if and only if <code class="language-plaintext highlighter-rouge">n</code> is more than <code class="language-plaintext highlighter-rouge">0</code>”. Since this is the case, it prints the <code class="language-plaintext highlighter-rouge">msg</code> and then calls itself passing <code class="language-plaintext highlighter-rouge">n - 1</code> (<code class="language-plaintext highlighter-rouge">2</code>) as the second argument.</p> <p>Now we execute the same function again, starting from the first clause. Given the second argument, <code class="language-plaintext highlighter-rouge">n</code>, is still more than 0, we print the message and call ourselves once more, now with the second argument set to <code class="language-plaintext highlighter-rouge">1</code>. Then we print the message one last time and call <code class="language-plaintext highlighter-rouge">print_multiple_times("Hello!", 0)</code>, starting from the top once again.</p> <p>When the second argument is zero, the guard <code class="language-plaintext highlighter-rouge">n &gt; 0</code> evaluates to false, and the first function clause won’t execute. Elixir then proceeds to try the next function clause, which explicitly matches on the case where <code class="language-plaintext highlighter-rouge">n</code> is <code class="language-plaintext highlighter-rouge">0</code>. This clause, also known as the termination clause, ignores the message argument by assigning it to the <code class="language-plaintext highlighter-rouge">_msg</code> variable and returns the atom <code class="language-plaintext highlighter-rouge">:ok</code>.</p> <p>Finally, if you pass an argument that does not match any clause, Elixir raises a <code class="language-plaintext highlighter-rouge">FunctionClauseError</code>:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Recursion.print_multiple_times "Hello!", -1
** (FunctionClauseError) no function clause matching in Recursion.print_multiple_times/2

    The following arguments were given to Recursion.print_multiple_times/2:

        # 1
        "Hello!"

        # 2
        -1

    iex:1: Recursion.print_multiple_times/2
</pre></div> <h2 id="reduce-and-map-algorithms">Reduce and map algorithms</h2> <p>Let’s now see how we can use the power of recursion to sum a list of numbers:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def sum_list([head | tail], accumulator) do
    sum_list(tail, head + accumulator)
  end

  def sum_list([], accumulator) do
    accumulator
  end
end

IO.puts Math.sum_list([1, 2, 3], 0) #=&gt; 6
</pre></div> <p>We invoke <code class="language-plaintext highlighter-rouge">sum_list</code> with the list <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> and the initial value <code class="language-plaintext highlighter-rouge">0</code> as arguments. We will try each clause until we find one that matches according to the pattern matching rules. In this case, the list <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code> matches against <code class="language-plaintext highlighter-rouge">[head | tail]</code> which binds <code class="language-plaintext highlighter-rouge">head</code> to <code class="language-plaintext highlighter-rouge">1</code> and <code class="language-plaintext highlighter-rouge">tail</code> to <code class="language-plaintext highlighter-rouge">[2, 3]</code>; <code class="language-plaintext highlighter-rouge">accumulator</code> is set to <code class="language-plaintext highlighter-rouge">0</code>.</p> <p>Then, we add the head of the list to the accumulator <code class="language-plaintext highlighter-rouge">head + accumulator</code> and call <code class="language-plaintext highlighter-rouge">sum_list</code> again, recursively, passing the tail of the list as its first argument. The tail will once again match <code class="language-plaintext highlighter-rouge">[head | tail]</code> until the list is empty, as seen below:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">sum_list [1, 2, 3], 0
sum_list [2, 3], 1
sum_list [3], 3
sum_list [], 6
</pre></div> <p>When the list is empty, it will match the final clause which returns the final result of <code class="language-plaintext highlighter-rouge">6</code>.</p> <p>The process of taking a list and <em>reducing</em> it down to one value is known as a <em>reduce algorithm</em> and is central to functional programming.</p> <p>What if we instead want to double all of the values in our list?</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">defmodule Math do
  def double_each([head | tail]) do
    [head * 2 | double_each(tail)]
  end

  def double_each([]) do
    []
  end
end
</pre></div> <div class="language-console highlighter-rouge"><pre class="highlight" data-language="">$ iex math.exs
</pre></div> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Math.double_each([1, 2, 3]) #=&gt; [2, 4, 6]
</pre></div> <p>Here we have used recursion to traverse a list, doubling each element and returning a new list. The process of taking a list and <em>mapping</em> over it is known as a <em>map algorithm</em>.</p> <p>Recursion and <a href="https://en.wikipedia.org/wiki/Tail_call">tail call</a> optimization are an important part of Elixir and are commonly used to create loops. However, when programming in Elixir you will rarely use recursion as above to manipulate lists.</p> <p>The <a href="https://hexdocs.pm/elixir/Enum.html"><code class="language-plaintext highlighter-rouge">Enum</code> module</a>, which we’re going to see in the next chapter, already provides many conveniences for working with lists. For instance, the examples above could be written as:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Enum.reduce([1, 2, 3], 0, fn(x, acc) -&gt; x + acc end)
6
iex&gt; Enum.map([1, 2, 3], fn(x) -&gt; x * 2 end)
[2, 4, 6]
</pre></div> <p>Or, using the capture syntax:</p> <div class="language-elixir highlighter-rouge"><pre class="highlight" data-language="">iex&gt; Enum.reduce([1, 2, 3], 0, &amp;+/2)
6
iex&gt; Enum.map([1, 2, 3], &amp;(&amp;1 * 2))
[2, 4, 6]
</pre></div> <p>Let’s take a deeper look at <code class="language-plaintext highlighter-rouge">Enumerable</code> and, while we’re at it, its lazy counterpart, <code class="language-plaintext highlighter-rouge">Stream</code>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012 Plataformatec<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://elixir-lang.org/getting-started/recursion.html" class="_attribution-link">https://elixir-lang.org/getting-started/recursion.html</a>
  </p>
</div>
