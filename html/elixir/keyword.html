<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Keyword</span>  </h1> <section id="moduledoc"> <p>A keyword list is a list that consists exclusively of two-element tuples.</p>
<p>The first element of these tuples is known as the <em>key</em>, and it must be an atom. The second element, known as the <em>value</em>, can be any term.</p>
<p>Keywords are mostly used to work with optional values. For a general introduction to keywords and how they compare with maps, see our <a href="keywords-and-maps.html">Keyword and Maps</a> guide.</p>
<h2 id="module-examples" class="section-heading">  <span class="text">Examples</span> </h2> <p>For example, the following is a keyword list:</p>
<pre data-language="elixir">[{:exit_on_close, true}, {:active, :once}, {:packet_size, 1024}]</pre>
<p>Elixir provides a special and more concise syntax for keyword lists:</p>
<pre data-language="elixir">[exit_on_close: true, active: :once, packet_size: 1024]</pre>
<p>The two syntaxes return the exact same value.</p>
<p>A <em>key</em> can be any atom, consisting of Unicode letters, numbers, an underscore or the <code class="inline">@</code> sign. If the <em>key</em> should have any other characters, such as spaces, you can wrap it in quotes:</p>
<pre data-language="elixir">iex&gt; ["exit on close": true]
["exit on close": true]</pre>
<p>Wrapping an atom in quotes does not make it a string. Keyword list <em>keys</em> are always atoms. Quotes should only be used when necessary or Elixir will issue a warning.</p>
<h2 id="module-duplicate-keys-and-ordering" class="section-heading">  <span class="text">Duplicate keys and ordering</span> </h2> <p>A keyword may have duplicate keys so it is not strictly a key-value data type. However, most of the functions in this module work on a key-value structure and behave similar to the functions you would find in the <a href="map.html"><code class="inline">Map</code></a> module. For example, <a href="#get/3"><code class="inline">Keyword.get/3</code></a> will get the first entry matching the given key, regardless if duplicate entries exist. Similarly, <a href="#put/3"><code class="inline">Keyword.put/3</code></a> and <a href="#delete/2"><code class="inline">Keyword.delete/2</code></a> ensure all duplicate entries for a given key are removed when invoked. Note, however, that keyword list operations need to traverse the whole list in order to find keys, so these operations are slower than their map counterparts.</p>
<p>A handful of functions exist to handle duplicate keys, for example, <a href="#get_values/2"><code class="inline">get_values/2</code></a> returns all values for a given key and <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> deletes just the first entry of the existing ones.</p>
<p>Even though lists preserve the existing order, the functions in <a href="keyword.html"><code class="inline">Keyword</code></a> do not guarantee any ordering. For example, if you invoke <code class="inline">Keyword.put(opts, new_key, new_value)</code>, there is no guarantee for where <code class="inline">new_key</code> will be added to (the front, the end or anywhere else).</p>
<p>Given ordering is not guaranteed, it is not recommended to pattern match on keyword lists either. For example, a function such as:</p>
<pre data-language="elixir">def my_function([some_key: value, another_key: another_value])</pre>
<p>will match</p>
<pre data-language="elixir">my_function([some_key: :foo, another_key: :bar])</pre>
<p>but it won't match</p>
<pre data-language="elixir">my_function([another_key: :bar, some_key: :foo])</pre>
<p>Most of the functions in this module work in linear time. This means that the time it takes to perform an operation grows at the same rate as the length of the list.</p>
<h2 id="module-call-syntax" class="section-heading">  <span class="text">Call syntax</span> </h2> <p>When keyword lists are passed as the last argument to a function, the square brackets around the keyword list can be omitted. For example, the keyword list syntax:</p>
<pre data-language="elixir">String.split("1-0", "-", [trim: true, parts: 2])</pre>
<p>can be written without the enclosing brackets whenever it is the last argument of a function call:</p>
<pre data-language="elixir">String.split("1-0", "-", trim: true, parts: 2)</pre>
<p>Since tuples, lists and maps are treated similarly to function arguments in Elixir syntax, this property is also available to them:</p>
<pre data-language="elixir">iex&gt; {1, 2, foo: :bar}
{1, 2, [{:foo, :bar}]}

iex&gt; [1, 2, foo: :bar]
[1, 2, {:foo, :bar}]

iex&gt; %{1 =&gt; 2, foo: :bar}
%{1 =&gt; 2, :foo =&gt; :bar}</pre> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:default/0" data-no-tooltip translate="no">default()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:key/0" data-no-tooltip translate="no">key()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" data-no-tooltip translate="no">t()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/1" data-no-tooltip translate="no">t(value)</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:value/0" data-no-tooltip translate="no">value()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#delete/2" data-no-tooltip translate="no">delete(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the entries in the keyword list under a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_first/2" data-no-tooltip translate="no">delete_first(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Deletes the first entry in the keyword list under a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#drop/2" data-no-tooltip translate="no">drop(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Drops the given <code class="inline">keys</code> from the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#equal?/2" data-no-tooltip translate="no">equal?(left, right)</a> </dt> <dd class="summary-synopsis"><p>Checks if two keywords are equal.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch/2" data-no-tooltip translate="no">fetch(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fetch!/2" data-no-tooltip translate="no">fetch!(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Fetches the value for specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#filter/2" data-no-tooltip translate="no">filter(keywords, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list containing only the entries from <code class="inline">keywords</code> for which the function <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_keys/2" data-no-tooltip translate="no">from_keys(keys, value)</a> </dt> <dd class="summary-synopsis"><p>Builds a keyword from the given <code class="inline">keys</code> and the fixed <code class="inline">value</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get/3" data-no-tooltip translate="no">get(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Gets the value under the given <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update/3" data-no-tooltip translate="no">get_and_update(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_and_update!/3" data-no-tooltip translate="no">get_and_update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value under <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_lazy/3" data-no-tooltip translate="no">get_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Gets the value under the given <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_values/2" data-no-tooltip translate="no">get_values(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Gets all values under a specific <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#has_key?/2" data-no-tooltip translate="no">has_key?(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#intersect/3" data-no-tooltip translate="no">intersect(keyword1, keyword2, fun \\ fn _key, _v1, v2 -&gt; v2 end)</a> </dt> <dd class="summary-synopsis"><p>Intersects two keyword lists, returning a keyword with the common keys.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keys/1" data-no-tooltip translate="no">keys(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all keys from the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#keyword?/1" data-no-tooltip translate="no">keyword?(term)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list, otherwise <code class="inline">false</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge/2" data-no-tooltip translate="no">merge(keywords1, keywords2)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#merge/3" data-no-tooltip translate="no">merge(keywords1, keywords2, fun)</a> </dt> <dd class="summary-synopsis"><p>Merges two keyword lists into one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/0" data-no-tooltip translate="no">new()</a> </dt> <dd class="summary-synopsis"><p>Returns an empty keyword list, i.e. an empty list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/1" data-no-tooltip translate="no">new(pairs)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/2" data-no-tooltip translate="no">new(pairs, transform)</a> </dt> <dd class="summary-synopsis"><p>Creates a keyword list from an enumerable via the transformation function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop/3" data-no-tooltip translate="no">pop(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop!/2" data-no-tooltip translate="no">pop!(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list, raising if <code class="inline">key</code> is not present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_first/3" data-no-tooltip translate="no">pop_first(keywords, key, default \\ nil)</a> </dt> <dd class="summary-synopsis"><p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_lazy/3" data-no-tooltip translate="no">pop_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#pop_values/2" data-no-tooltip translate="no">pop_values(keywords, key)</a> </dt> <dd class="summary-synopsis"><p>Returns all values for <code class="inline">key</code> and removes all associated entries in the keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put/3" data-no-tooltip translate="no">put(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under the specified <code class="inline">key</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new/3" data-no-tooltip translate="no">put_new(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>, unless the entry <code class="inline">key</code> already exists.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_new_lazy/3" data-no-tooltip translate="no">put_new_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reject/2" data-no-tooltip translate="no">reject(keywords, fun)</a> </dt> <dd class="summary-synopsis"><p>Returns a keyword list excluding the entries from <code class="inline">keywords</code> for which the function <code class="inline">fun</code> returns a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace/3" data-no-tooltip translate="no">replace(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace!/3" data-no-tooltip translate="no">replace!(keywords, key, value)</a> </dt> <dd class="summary-synopsis"><p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#replace_lazy/3" data-no-tooltip translate="no">replace_lazy(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Replaces the value under <code class="inline">key</code> using the given function only if <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/2" data-no-tooltip translate="no">split(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given <code class="inline">keys</code> and extracts them into a separate keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split_with/2" data-no-tooltip translate="no">split_with(keywords, fun)</a> </dt> <dd class="summary-synopsis"><p>Splits the <code class="inline">keywords</code> into two keyword lists according to the given function <code class="inline">fun</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#take/2" data-no-tooltip translate="no">take(keywords, keys)</a> </dt> <dd class="summary-synopsis"><p>Takes all entries corresponding to the given <code class="inline">keys</code> and returns them as a new keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_list/1" data-no-tooltip translate="no">to_list(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns the keyword list itself.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update/4" data-no-tooltip translate="no">update(keywords, key, default, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the value under <code class="inline">key</code> in <code class="inline">keywords</code> using the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#update!/3" data-no-tooltip translate="no">update!(keywords, key, fun)</a> </dt> <dd class="summary-synopsis"><p>Updates the value under <code class="inline">key</code> using the given function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#validate/2" data-no-tooltip translate="no">validate(keyword, values)</a> </dt> <dd class="summary-synopsis"><p>Ensures the given <code class="inline">keyword</code> has only the keys given in <code class="inline">values</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#validate!/2" data-no-tooltip translate="no">validate!(keyword, values)</a> </dt> <dd class="summary-synopsis"><p>Similar to <a href="#validate/2"><code class="inline">validate/2</code></a> but returns the keyword or raises an error.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#values/1" data-no-tooltip translate="no">values(keywords)</a> </dt> <dd class="summary-synopsis"><p>Returns all values from the keyword list.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:default/0">default()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L106" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type default() :: any()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:key/0">key()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L102" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type key() :: atom()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L108" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: [{key(), value()}]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:t/1">t(value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L109" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t(value) :: [{key(), value}]</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:value/0">value()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L103" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type value() :: any()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="delete/2">delete(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L719" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete(t(), key()) :: t()</pre> </div> <p>Deletes the entries in the keyword list under a specific <code class="inline">key</code>.</p>
<p>If the <code class="inline">key</code> does not exist, it returns the keyword list unchanged. Use <a href="#delete_first/2"><code class="inline">delete_first/2</code></a> to delete just the first entry in case of duplicate keys.</p>
<h4 id="delete/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.delete([a: 1, b: 2], :a)
[b: 2]
iex&gt; Keyword.delete([a: 1, b: 2, a: 3], :a)
[b: 2]
iex&gt; Keyword.delete([b: 2], :a)
[b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_first/2">delete_first(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L744" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_first(t(), key()) :: t()</pre> </div> <p>Deletes the first entry in the keyword list under a specific <code class="inline">key</code>.</p>
<p>If the <code class="inline">key</code> does not exist, it returns the keyword list unchanged.</p>
<h4 id="delete_first/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.delete_first([a: 1, b: 2, a: 3], :a)
[b: 2, a: 3]
iex&gt; Keyword.delete_first([b: 2], :a)
[b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="drop/2">drop(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1299" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec drop(t(), [key()]) :: t()</pre> </div> <p>Drops the given <code class="inline">keys</code> from the keyword list.</p>
<p>Removes duplicate keys from the new keyword list.</p>
<h4 id="drop/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.drop([a: 1, a: 2], [:a])
[]
iex&gt; Keyword.drop([a: 1, b: 2, c: 3], [:b, :d])
[a: 1, c: 3]
iex&gt; Keyword.drop([a: 1, b: 2, b: 3, c: 3, a: 5], [:b, :d])
[a: 1, c: 3, a: 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="equal?/2">equal?(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L959" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec equal?(t(), t()) :: boolean()</pre> </div> <p>Checks if two keywords are equal.</p>
<p>Considers two keywords to be equal if they contain the same keys and those keys contain the same values.</p>
<h4 id="equal?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.equal?([a: 1, b: 2], [b: 2, a: 1])
true
iex&gt; Keyword.equal?([a: 1, b: 2], [b: 1, a: 2])
false
iex&gt; Keyword.equal?([a: 1, b: 2, a: 3], [b: 2, a: 3, a: 1])
true</pre>
<p>Comparison between values is done with <code class="inline">===/3</code>, which means integers are not equivalent to floats:</p>
<pre data-language="elixir">iex&gt; Keyword.equal?([a: 1.0], [a: 1])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch/2">fetch(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L578" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch(t(), key()) :: {:ok, value()} | :error</pre> </div> <p>Fetches the value for a specific <code class="inline">key</code> and returns it in a tuple.</p>
<p>If the <code class="inline">key</code> does not exist, it returns <code class="inline">:error</code>.</p>
<h4 id="fetch/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.fetch([a: 1], :a)
{:ok, 1}
iex&gt; Keyword.fetch([a: 1], :b)
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="fetch!/2">fetch!(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L599" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec fetch!(t(), key()) :: value()</pre> </div> <p>Fetches the value for specific <code class="inline">key</code>.</p>
<p>If the <code class="inline">key</code> does not exist, it raises a <a href="keyerror.html"><code class="inline">KeyError</code></a>.</p>
<h4 id="fetch!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.fetch!([a: 1], :a)
1
iex&gt; Keyword.fetch!([a: 1], :b)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="filter/2">filter(keywords, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1484" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec filter(t(), ({key(), value()} -&gt; as_boolean(term()))) :: t()</pre> </div> <p>Returns a keyword list containing only the entries from <code class="inline">keywords</code> for which the function <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#reject/2"><code class="inline">reject/2</code></a> which discards all entries where the function returns a truthy value.</p>
<h4 id="filter/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.filter([one: 1, two: 2, three: 3], fn {_key, val} -&gt; rem(val, 2) == 1 end)
[one: 1, three: 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="from_keys/2">from_keys(keys, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L124" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_keys([key()], value()) :: t(value())</pre> </div> <p>Builds a keyword from the given <code class="inline">keys</code> and the fixed <code class="inline">value</code>.</p>
<h4 id="from_keys/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.from_keys([:foo, :bar, :baz], :atom)
[foo: :atom, bar: :atom, baz: :atom]
iex&gt; Keyword.from_keys([], :atom)
[]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="get/3">get(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L395" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get(t(), key(), default()) :: value() | default()</pre> </div> <p>Gets the value under the given <code class="inline">key</code>.</p>
<p>Returns the default value if <code class="inline">key</code> does not exist (<code class="inline">nil</code> if no default value is provided).</p>
<p>If duplicate entries exist, it returns the first one. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p>
<h4 id="get/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.get([], :a)
nil
iex&gt; Keyword.get([a: 1], :a)
1
iex&gt; Keyword.get([a: 1], :b)
nil
iex&gt; Keyword.get([a: 1], :b, 3)
3</pre>
<p>With duplicate keys:</p>
<pre data-language="elixir">iex&gt; Keyword.get([a: 1, a: 2], :a, 3)
1
iex&gt; Keyword.get([a: 1, a: 2], :b, 3)
3</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update/3">get_and_update(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L475" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_and_update(t(), key(), (value() | nil -&gt;
                              {current_value, new_value :: value()} | :pop)) ::
  {current_value, new_keywords :: t()}
when current_value: value()</pre> </div> <p>Gets the value from <code class="inline">key</code> and updates it, all in one pass.</p>
<p>The <code class="inline">fun</code> argument receives the value of <code class="inline">key</code> (or <code class="inline">nil</code> if <code class="inline">key</code> is not present) and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>. The <code class="inline">fun</code> may also return <code class="inline">:pop</code>, implying the current value shall be removed from the keyword list and returned.</p>
<p>Returns a tuple that contains the current value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p>
<h4 id="get_and_update/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{nil, [b: "new value!", a: 1]}

iex&gt; Keyword.get_and_update([a: 2], :a, fn number -&gt;
...&gt;   {2 * number, 3 * number}
...&gt; end)
{4, [a: 6]}

iex&gt; Keyword.get_and_update([a: 1], :a, fn _ -&gt; :pop end)
{1, []}

iex&gt; Keyword.get_and_update([a: 1], :b, fn _ -&gt; :pop end)
{nil, [a: 1]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_and_update!/3">get_and_update!(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L539" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_and_update!(t(), key(), (value() -&gt;
                               {current_value, new_value :: value()} | :pop)) ::
  {current_value, new_keywords :: t()}
when current_value: value()</pre> </div> <p>Gets the value under <code class="inline">key</code> and updates it. Raises if there is no <code class="inline">key</code>.</p>
<p>The <code class="inline">fun</code> argument receives the value under <code class="inline">key</code> and must return a two-element tuple: the current value (the retrieved value, which can be operated on before being returned) and the new value to be stored under <code class="inline">key</code>.</p>
<p>Returns a tuple that contains the current value returned by <code class="inline">fun</code> and a new keyword list with the updated value under <code class="inline">key</code>.</p>
<h4 id="get_and_update!/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.get_and_update!([a: 1], :a, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
{1, [a: "new value!"]}

iex&gt; Keyword.get_and_update!([a: 1], :b, fn current_value -&gt;
...&gt;   {current_value, "new value!"}
...&gt; end)
** (KeyError) key :b not found in: [a: 1]

iex&gt; Keyword.get_and_update!([a: 1], :a, fn _ -&gt;
...&gt;   :pop
...&gt; end)
{1, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_lazy/3">get_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L427" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_lazy(t(), key(), (-&gt; value())) :: value()</pre> </div> <p>Gets the value under the given <code class="inline">key</code>.</p>
<p>If <code class="inline">key</code> does not exist, lazily evaluates <code class="inline">fun</code> and returns its result.</p>
<p>This is useful if the default value is very expensive to calculate or generally difficult to set up and tear down again.</p>
<p>If duplicate entries exist, it returns the first one. Use <a href="#get_values/2"><code class="inline">get_values/2</code></a> to retrieve all entries.</p>
<h4 id="get_lazy/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.get_lazy(keyword, :a, fun)
1
iex&gt; Keyword.get_lazy(keyword, :b, fun)
13</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_values/2">get_values(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L620" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_values(t(), key()) :: [value()]</pre> </div> <p>Gets all values under a specific <code class="inline">key</code>.</p>
<h4 id="get_values/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.get_values([], :a)
[]
iex&gt; Keyword.get_values([a: 1], :a)
[1]
iex&gt; Keyword.get_values([a: 1, a: 2], :a)
[1, 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="has_key?/2">has_key?(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1115" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec has_key?(t(), key()) :: boolean()</pre> </div> <p>Returns whether a given <code class="inline">key</code> exists in the given <code class="inline">keywords</code>.</p>
<h4 id="has_key?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.has_key?([a: 1], :a)
true
iex&gt; Keyword.has_key?([a: 1], :b)
false</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="intersect/3">intersect(keyword1, keyword2, fun \\ fn _key, _v1, v2 -&gt; v2 end)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L982" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec intersect(keyword(), keyword(), (key(), value(), value() -&gt; value())) ::
  keyword()</pre> </div> <p>Intersects two keyword lists, returning a keyword with the common keys.</p>
<p>By default, it returns the values of the intersected keys in <code class="inline">keyword2</code>. The keys are returned in the order found in <code class="inline">keyword1</code>.</p>
<h4 id="intersect/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.intersect([a: 1, b: 2], [b: "b", c: "c"])
[b: "b"]

iex&gt; Keyword.intersect([a: 1, b: 2], [b: 2, c: 3], fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 4]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keys/1">keys(keywords)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L646" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec keys(t()) :: [key()]</pre> </div> <p>Returns all keys from the keyword list.</p>
<p>Keeps duplicate keys in the resulting list of keys.</p>
<h4 id="keys/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.keys(a: 1, b: 2)
[:a, :b]

iex&gt; Keyword.keys(a: 1, b: 2, a: 3)
[:a, :b, :a]

iex&gt; Keyword.keys([{:a, 1}, {"b", 2}, {:c, 3}])
** (ArgumentError) expected a keyword list, but an entry in the list is not a two-element tuple with an atom as its first element, got: {"b", 2}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="keyword?/1">keyword?(term)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L150" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec keyword?(term()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if <code class="inline">term</code> is a keyword list, otherwise <code class="inline">false</code>.</p>
<p>When <code class="inline">term</code> is a list it is traversed to the end.</p>
<h4 id="keyword?/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.keyword?([])
true
iex&gt; Keyword.keyword?(a: 1)
true
iex&gt; Keyword.keyword?([{Foo, 1}])
true
iex&gt; Keyword.keyword?([{}])
false
iex&gt; Keyword.keyword?([:key])
false
iex&gt; Keyword.keyword?(%{})
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge/2">merge(keywords1, keywords2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1014" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec merge(t(), t()) :: t()</pre> </div> <p>Merges two keyword lists into one.</p>
<p>Adds all keys, including duplicate keys, given in <code class="inline">keywords2</code> to <code class="inline">keywords1</code>, overriding any existing ones.</p>
<p>There are no guarantees about the order of the keys in the returned keyword.</p>
<h4 id="merge/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4])
[b: 2, a: 3, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5])
[b: 2, a: 3, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1], [2, 3])
** (ArgumentError) expected a keyword list as the second argument, got: [2, 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="merge/3">merge(keywords1, keywords2, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1072" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec merge(t(), t(), (key(), value(), value() -&gt; value())) :: t()</pre> </div> <p>Merges two keyword lists into one.</p>
<p>Adds all keys, including duplicate keys, given in <code class="inline">keywords2</code> to <code class="inline">keywords1</code>. Invokes the given function to solve conflicts.</p>
<p>If <code class="inline">keywords2</code> has duplicate keys, it invokes the given function for each matching pair in <code class="inline">keywords1</code>.</p>
<p>There are no guarantees about the order of the keys in the returned keyword.</p>
<h4 id="merge/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4], fn _k, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4]

iex&gt; Keyword.merge([a: 1, b: 2], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 5]

iex&gt; Keyword.merge([a: 1, b: 2, a: 3], [a: 3, d: 4, a: 5], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
[b: 2, a: 4, d: 4, a: 8]

iex&gt; Keyword.merge([a: 1, b: 2], [:a, :b], fn :a, v1, v2 -&gt;
...&gt;   v1 + v2
...&gt; end)
** (ArgumentError) expected a keyword list as the second argument, got: [:a, :b]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/0">new()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L166" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new() :: []</pre> </div> <p>Returns an empty keyword list, i.e. an empty list.</p>
<h4 id="new/0-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.new()
[]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/1">new(pairs)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L185" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(Enumerable.t()) :: t()</pre> </div> <p>Creates a keyword list from an enumerable.</p>
<p>Removes duplicate entries and the last one prevails. Unlike <code class="inline">Enum.into(enumerable, [])</code>, <code class="inline">Keyword.new(enumerable)</code> guarantees the keys are unique.</p>
<h4 id="new/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.new([{:b, 1}, {:a, 2}])
[b: 1, a: 2]

iex&gt; Keyword.new([{:a, 1}, {:a, 2}, {:a, 3}])
[a: 3]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/2">new(pairs, transform)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L203" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(Enumerable.t(), (term() -&gt; {key(), value()})) :: t()</pre> </div> <p>Creates a keyword list from an enumerable via the transformation function.</p>
<p>Removes duplicate entries and the last one prevails. Unlike <code class="inline">Enum.into(enumerable, [], fun)</code>, <code class="inline">Keyword.new(enumerable, fun)</code> guarantees the keys are unique.</p>
<h4 id="new/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.new([:a, :b], fn x -&gt; {x, x} end)
[a: :a, b: :b]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pop/3">pop(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1326" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pop(t(), key(), default()) :: {value() | default(), t()}</pre> </div> <p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list.</p>
<p>It returns a tuple where the first element is the first value for <code class="inline">key</code> and the second element is a keyword list with all entries associated with <code class="inline">key</code> removed. If the <code class="inline">key</code> is not present in the keyword list, it returns <code class="inline">{default, keyword_list}</code>.</p>
<p>If you don't want to remove all the entries associated with <code class="inline">key</code> use <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> instead, which will remove only the first entry.</p>
<h4 id="pop/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.pop([a: 1], :a)
{1, []}
iex&gt; Keyword.pop([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop([a: 1, a: 2], :a)
{1, []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop!/2">pop!(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1352" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pop!(t(), key()) :: {value(), t()}</pre> </div> <p>Returns the first value for <code class="inline">key</code> and removes all associated entries in the keyword list, raising if <code class="inline">key</code> is not present.</p>
<p>This function behaves like <a href="#pop/3"><code class="inline">pop/3</code></a>, but raises in case the <code class="inline">key</code> is not present in the given <code class="inline">keywords</code>.</p>
<h4 id="pop!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.pop!([a: 1], :a)
{1, []}
iex&gt; Keyword.pop!([a: 1, a: 2], :a)
{1, []}
iex&gt; Keyword.pop!([a: 1], :b)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="pop_first/3">pop_first(keywords, key, default \\ nil)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1442" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pop_first(t(), key(), default()) :: {value() | default(), t()}</pre> </div> <p>Returns and removes the first value associated with <code class="inline">key</code> in the keyword list.</p>
<p>Keeps duplicate keys in the resulting keyword list.</p>
<h4 id="pop_first/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.pop_first([a: 1], :a)
{1, []}
iex&gt; Keyword.pop_first([a: 1], :b)
{nil, [a: 1]}
iex&gt; Keyword.pop_first([a: 1], :b, 3)
{3, [a: 1]}
iex&gt; Keyword.pop_first([a: 1, a: 2], :a)
{1, [a: 2]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_lazy/3">pop_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1416" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pop_lazy(t(), key(), (-&gt; value())) :: {value(), t()}</pre> </div> <p>Lazily returns and removes all values associated with <code class="inline">key</code> in the keyword list.</p>
<p>This is useful if the default value is very expensive to calculate or generally difficult to set up and tear down again.</p>
<p>Removes all duplicate keys. See <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> for removing only the first entry.</p>
<h4 id="pop_lazy/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.pop_lazy(keyword, :a, fun)
{1, []}
iex&gt; Keyword.pop_lazy(keyword, :b, fun)
{13, [a: 1]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="pop_values/2">pop_values(keywords, key)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1381" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec pop_values(t(), key()) :: {[value()], t()}</pre> </div> <p>Returns all values for <code class="inline">key</code> and removes all associated entries in the keyword list.</p>
<p>It returns a tuple where the first element is a list of values for <code class="inline">key</code> and the second element is a keyword list with all entries associated with <code class="inline">key</code> removed. If the <code class="inline">key</code> is not present in the keyword list, it returns <code class="inline">{[], keyword_list}</code>.</p>
<p>If you don't want to remove all the entries associated with <code class="inline">key</code> use <a href="#pop_first/3"><code class="inline">pop_first/3</code></a> instead, which will remove only the first entry.</p>
<h4 id="pop_values/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.pop_values([a: 1], :a)
{[1], []}
iex&gt; Keyword.pop_values([a: 1], :b)
{[], [a: 1]}
iex&gt; Keyword.pop_values([a: 1, a: 2], :a)
{[1, 2], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put/3">put(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L780" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put(t(), key(), value()) :: t()</pre> </div> <p>Puts the given <code class="inline">value</code> under the specified <code class="inline">key</code>.</p>
<p>If a value under <code class="inline">key</code> already exists, it overrides the value and removes all duplicate entries.</p>
<h4 id="put/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.put([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put([a: 1, b: 2], :a, 3)
[a: 3, b: 2]
iex&gt; Keyword.put([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new/3">put_new(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L825" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_new(t(), key(), value()) :: t()</pre> </div> <p>Puts the given <code class="inline">value</code> under <code class="inline">key</code>, unless the entry <code class="inline">key</code> already exists.</p>
<h4 id="put_new/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.put_new([a: 1], :b, 2)
[b: 2, a: 1]
iex&gt; Keyword.put_new([a: 1, b: 2], :a, 3)
[a: 1, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_new_lazy/3">put_new_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L805" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_new_lazy(t(), key(), (-&gt; value())) :: t()</pre> </div> <p>Evaluates <code class="inline">fun</code> and puts the result under <code class="inline">key</code> in keyword list unless <code class="inline">key</code> is already present.</p>
<p>This is useful if the value is very expensive to calculate or generally difficult to set up and tear down again.</p>
<h4 id="put_new_lazy/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; keyword = [a: 1]
iex&gt; fun = fn -&gt;
...&gt;   # some expensive operation here
...&gt;   13
...&gt; end
iex&gt; Keyword.put_new_lazy(keyword, :a, fun)
[a: 1]
iex&gt; Keyword.put_new_lazy(keyword, :b, fun)
[b: 13, a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reject/2">reject(keywords, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1512" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reject(t(), ({key(), value()} -&gt; as_boolean(term()))) :: t()</pre> </div> <p>Returns a keyword list excluding the entries from <code class="inline">keywords</code> for which the function <code class="inline">fun</code> returns a truthy value.</p>
<p>See also <a href="#filter/2"><code class="inline">filter/2</code></a>.</p>
<h4 id="reject/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.reject([one: 1, two: 2, three: 3], fn {_key, val} -&gt; rem(val, 2) == 1 end)
[two: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace/3">replace(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L849" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace(t(), key(), value()) :: t()</pre> </div> <p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p>
<p>In case a key exists multiple times in the keyword list, it removes later occurrences.</p>
<h4 id="replace/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.replace([a: 1, b: 2, a: 4], :a, 3)
[a: 3, b: 2]

iex&gt; Keyword.replace([a: 1], :b, 2)
[a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace!/3">replace!(keywords, key, value)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L883" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace!(t(), key(), value()) :: t()</pre> </div> <p>Puts a value under <code class="inline">key</code> only if the <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p>
<p>If <code class="inline">key</code> is not present in <code class="inline">keywords</code>, it raises a <a href="keyerror.html"><code class="inline">KeyError</code></a>.</p>
<h4 id="replace!/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.replace!([a: 1, b: 2, a: 3], :a, :new)
[a: :new, b: 2]
iex&gt; Keyword.replace!([a: 1, b: 2, c: 3, b: 4], :b, :new)
[a: 1, b: :new, c: 3]

iex&gt; Keyword.replace!([a: 1], :b, 2)
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="replace_lazy/3">replace_lazy(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L921" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec replace_lazy(t(), key(), (existing_value :: value() -&gt; new_value :: value())) ::
  t()</pre> </div> <p>Replaces the value under <code class="inline">key</code> using the given function only if <code class="inline">key</code> already exists in <code class="inline">keywords</code>.</p>
<p>In comparison to <a href="#replace/3"><code class="inline">replace/3</code></a>, this can be useful when it's expensive to calculate the value.</p>
<p>If <code class="inline">key</code> does not exist, the original keyword list is returned unchanged.</p>
<h4 id="replace_lazy/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.replace_lazy([a: 1, b: 2], :a, fn v -&gt; v * 4 end)
[a: 4, b: 2]

iex&gt; Keyword.replace_lazy([a: 2, b: 2, a: 1], :a, fn v -&gt; v * 4 end)
[a: 8, b: 2]

iex&gt; Keyword.replace_lazy([a: 1, b: 2], :c, fn v -&gt; v * 4 end)
[a: 1, b: 2]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/2">split(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1212" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t(), [key()]) :: {t(), t()}</pre> </div> <p>Takes all entries corresponding to the given <code class="inline">keys</code> and extracts them into a separate keyword list.</p>
<p>Returns a tuple with the new list and the old list with removed keys.</p>
<p>Ignores keys for which there are no entries in the keyword list.</p>
<p>Entries with duplicate keys end up in the same keyword list.</p>
<h4 id="split/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.split([a: 1, b: 2, c: 3], [:a, :c, :e])
{[a: 1, c: 3], [b: 2]}
iex&gt; Keyword.split([a: 1, b: 2, c: 3, a: 4], [:a, :c, :e])
{[a: 1, c: 3, a: 4], [b: 2]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="split_with/2">split_with(keywords, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1252" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split_with(t(), ({key(), value()} -&gt; as_boolean(term()))) :: {t(), t()}</pre> </div> <p>Splits the <code class="inline">keywords</code> into two keyword lists according to the given function <code class="inline">fun</code>.</p>
<p>The provided <code class="inline">fun</code> receives each <code class="inline">{key, value}</code> pair in the <code class="inline">keywords</code> as its only argument. Returns a tuple with the first keyword list containing all the elements in <code class="inline">keywords</code> for which applying <code class="inline">fun</code> returned a truthy value, and a second keyword list with all the elements for which applying <code class="inline">fun</code> returned a falsy value (<code class="inline">false</code> or <code class="inline">nil</code>).</p>
<h4 id="split_with/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.split_with([a: 1, b: 2, c: 3], fn {_k, v} -&gt; rem(v, 2) == 0 end)
{[b: 2], [a: 1, c: 3]}

iex&gt; Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {_k, v} -&gt; rem(v, 2) == 0 end)
{[b: 2, b: 4], [a: 1, c: 3]}

iex&gt; Keyword.split_with([a: 1, b: 2, c: 3, b: 4], fn {k, v} -&gt; k in [:a, :c] and rem(v, 2) == 0 end)
{[], [a: 1, b: 2, c: 3, b: 4]}

iex&gt; Keyword.split_with([], fn {_k, v} -&gt; rem(v, 2) == 0 end)
{[], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="take/2">take(keywords, keys)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1279" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec take(t(), [key()]) :: t()</pre> </div> <p>Takes all entries corresponding to the given <code class="inline">keys</code> and returns them as a new keyword list.</p>
<p>Preserves duplicate keys in the new keyword list.</p>
<h4 id="take/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.take([a: 1, b: 2, c: 3], [:a, :c, :e])
[a: 1, c: 3]
iex&gt; Keyword.take([a: 1, b: 2, c: 3, a: 5], [:a, :c, :e])
[a: 1, c: 3, a: 5]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_list/1">to_list(keywords)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1459" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_list(t()) :: t()</pre> </div> <p>Returns the keyword list itself.</p>
<h4 id="to_list/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.to_list(a: 1)
[a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update/4">update(keywords, key, default, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1176" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec update(t(), key(), default :: value(), (existing_value :: value() -&gt;
                                          new_value :: value())) :: t()</pre> </div> <p>Updates the value under <code class="inline">key</code> in <code class="inline">keywords</code> using the given function.</p>
<p>If the <code class="inline">key</code> does not exist, it inserts the given <code class="inline">default</code> value. Does not pass the <code class="inline">default</code> value through the update function.</p>
<p>Removes all duplicate keys and only updates the first one.</p>
<h4 id="update/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.update([a: 1], :a, 13, fn existing_value -&gt; existing_value * 2 end)
[a: 2]

iex&gt; Keyword.update([a: 1, a: 2], :a, 13, fn existing_value -&gt; existing_value * 2 end)
[a: 2]

iex&gt; Keyword.update([a: 1], :b, 11, fn existing_value -&gt; existing_value * 2 end)
[a: 1, b: 11]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="update!/3">update!(keywords, key, fun)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L1138" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec update!(t(), key(), (current_value :: value() -&gt; new_value :: value())) :: t()</pre> </div> <p>Updates the value under <code class="inline">key</code> using the given function.</p>
<p>Raises <a href="keyerror.html"><code class="inline">KeyError</code></a> if the <code class="inline">key</code> does not exist.</p>
<p>Removes all duplicate keys and only updates the first one.</p>
<h4 id="update!/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.update!([a: 1, b: 2, a: 3], :a, &amp;(&amp;1 * 2))
[a: 2, b: 2]
iex&gt; Keyword.update!([a: 1, b: 2, c: 3], :b, &amp;(&amp;1 * 2))
[a: 1, b: 4, c: 3]

iex&gt; Keyword.update!([a: 1], :b, &amp;(&amp;1 * 2))
** (KeyError) key :b not found in: [a: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="validate/2">validate(keyword, values)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L259" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec validate(
  keyword(),
  values :: [atom() | {atom(), term()}]
) :: {:ok, keyword()} | {:error, [atom()]}</pre> </div> <p>Ensures the given <code class="inline">keyword</code> has only the keys given in <code class="inline">values</code>.</p>
<p>The second argument must be a list of atoms, specifying a given key, or tuples specifying a key and a default value.</p>
<p>If the keyword list has only the given keys, it returns <code class="inline">{:ok, keyword}</code> with default values applied. Otherwise it returns <code class="inline">{:error, invalid_keys}</code> with invalid keys.</p>
<p>See also: <a href="#validate!/2"><code class="inline">validate!/2</code></a>.</p>
<h4 id="validate/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; {:ok, result} = Keyword.validate([], [one: 1, two: 2])
iex&gt; Enum.sort(result)
[one: 1, two: 2]

iex&gt; {:ok, result} = Keyword.validate([two: 3], [one: 1, two: 2])
iex&gt; Enum.sort(result)
[one: 1, two: 3]</pre>
<p>If atoms are given, they are supported as keys but do not provide a default value:</p>
<pre data-language="elixir">iex&gt; {:ok, result} = Keyword.validate([], [:one, two: 2])
iex&gt; Enum.sort(result)
[two: 2]

iex&gt; {:ok, result} = Keyword.validate([one: 1], [:one, two: 2])
iex&gt; Enum.sort(result)
[one: 1, two: 2]</pre>
<p>Passing unknown keys returns an error:</p>
<pre data-language="elixir">iex&gt; Keyword.validate([three: 3, four: 4], [one: 1, two: 2])
{:error, [:four, :three]}</pre>
<p>Passing the same key multiple times also errors:</p>
<pre data-language="elixir">iex&gt; Keyword.validate([one: 1, two: 2, one: 1], [:one, :two])
{:error, [:one]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="validate!/2">validate!(keyword, values)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L342" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec validate!(
  keyword(),
  values :: [atom() | {atom(), term()}]
) :: keyword()</pre> </div> <p>Similar to <a href="#validate/2"><code class="inline">validate/2</code></a> but returns the keyword or raises an error.</p>
<h4 id="validate!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.validate!([], [one: 1, two: 2]) |&gt; Enum.sort()
[one: 1, two: 2]
iex&gt; Keyword.validate!([two: 3], [one: 1, two: 2]) |&gt; Enum.sort()
[one: 1, two: 3]</pre>
<p>If atoms are given, they are supported as keys but do not provide a default value:</p>
<pre data-language="elixir">iex&gt; Keyword.validate!([], [:one, two: 2]) |&gt; Enum.sort()
[two: 2]
iex&gt; Keyword.validate!([one: 1], [:one, two: 2]) |&gt; Enum.sort()
[one: 1, two: 2]</pre>
<p>Passing unknown keys raises an error:</p>
<pre data-language="elixir">iex&gt; Keyword.validate!([three: 3], [one: 1, two: 2])
** (ArgumentError) unknown keys [:three] in [three: 3], the allowed keys are: [:one, :two]</pre>
<p>Passing the same key multiple times also errors:</p>
<pre data-language="elixir">iex&gt; Keyword.validate!([one: 1, two: 2, one: 1], [:one, :two])
** (ArgumentError) duplicate keys [:one] in [one: 1, two: 2, one: 1]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="values/1">values(keywords)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/keyword.ex#L675" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec values(t()) :: [value()]</pre> </div> <p>Returns all values from the keyword list.</p>
<p>Keeps values from duplicate keys in the resulting list of values.</p>
<h4 id="values/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Keyword.values(a: 1, b: 2)
[1, 2]
iex&gt; Keyword.values(a: 1, b: 2, a: 3)
[1, 2, 3]</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/Keyword.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/Keyword.html</a>
  </p>
</div>
