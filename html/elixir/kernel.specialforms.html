<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Kernel.SpecialForms</span>  </h1> <section id="moduledoc"> <p>Special forms are the basic building blocks of Elixir, and therefore cannot be overridden by the developer.</p>
<p>The <a href="kernel.specialforms.html"><code class="inline">Kernel.SpecialForms</code></a> module consists solely of macros that can be invoked anywhere in Elixir code without the use of the <code class="inline">Kernel.SpecialForms.</code> prefix. This is possible because they all have been automatically imported, in the same fashion as the functions and macros from the <a href="kernel.html"><code class="inline">Kernel</code></a> module.</p>
<p>These building blocks are defined in this module. Some of these special forms are lexical (such as <a href="#alias/2"><code class="inline">alias/2</code></a> and <a href="#case/2"><code class="inline">case/2</code></a>). The macros <a href="#%7B%7D/1"><code class="inline">{}/1</code></a> and <a href="#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;/1</code></a> are also special forms used to define tuple and binary data structures respectively.</p>
<p>This module also documents macros that return information about Elixir's compilation environment, such as (<a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, <a href="#__MODULE__/0"><code class="inline">__MODULE__/0</code></a>, <a href="#__DIR__/0"><code class="inline">__DIR__/0</code></a>, <a href="#__STACKTRACE__/0"><code class="inline">__STACKTRACE__/0</code></a>, and <a href="#__CALLER__/0"><code class="inline">__CALLER__/0</code></a>).</p>
<p>Additionally, it documents two special forms, <a href="#__block__/1"><code class="inline">__block__/1</code></a> and <a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a>, which are not intended to be called directly by the developer but they appear in quoted contents since they are essential in Elixir's constructs.</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#%25/2" data-no-tooltip translate="no">%struct{}</a> </dt> <dd class="summary-synopsis"><p>Matches on or builds a struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%25%7B%7D/1" data-no-tooltip translate="no">%{}</a> </dt> <dd class="summary-synopsis"><p>Creates a map.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#&amp;/1" data-no-tooltip translate="no">&amp;expr</a> </dt> <dd class="summary-synopsis"><p>Capture operator. Captures or creates an anonymous function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#./2" data-no-tooltip translate="no">left . right</a> </dt> <dd class="summary-synopsis"><p>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__aliases__/1" data-no-tooltip translate="no">__aliases__(args)</a> </dt> <dd class="summary-synopsis"><p>Internal special form to hold aliases information.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__block__/1" data-no-tooltip translate="no">__block__(args)</a> </dt> <dd class="summary-synopsis"><p>Internal special form for block expressions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__CALLER__/0" data-no-tooltip translate="no">__CALLER__</a> </dt> <dd class="summary-synopsis"><p>Returns the current calling environment as a <a href="macro.env.html"><code class="inline">Macro.Env</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__cursor__/1" data-no-tooltip translate="no">__cursor__(args)</a> </dt> <dd class="summary-synopsis"><p>Internal special form for cursor position.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__DIR__/0" data-no-tooltip translate="no">__DIR__</a> </dt> <dd class="summary-synopsis"><p>Returns the absolute path of the directory of the current file as a binary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__ENV__/0" data-no-tooltip translate="no">__ENV__</a> </dt> <dd class="summary-synopsis"><p>Returns the current environment information as a <a href="macro.env.html"><code class="inline">Macro.Env</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__MODULE__/0" data-no-tooltip translate="no">__MODULE__</a> </dt> <dd class="summary-synopsis"><p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#__STACKTRACE__/0" data-no-tooltip translate="no">__STACKTRACE__</a> </dt> <dd class="summary-synopsis"><p>Returns the stacktrace for the currently handled exception.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#::/2" data-no-tooltip translate="no">left :: right</a> </dt> <dd class="summary-synopsis"><p>Type operator. Used by types and bitstrings to specify types.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%3C%3C%3E%3E/1" data-no-tooltip translate="no">&lt;&lt;args&gt;&gt;</a> </dt> <dd class="summary-synopsis"><p>Defines a new bitstring.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#=/2" data-no-tooltip translate="no">left = right</a> </dt> <dd class="summary-synopsis"><p>Match operator. Matches the value on the right against the pattern on the left.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#alias/2" data-no-tooltip translate="no">alias(module, opts)</a> </dt> <dd class="summary-synopsis"><p><a href="#alias/2"><code class="inline">alias/2</code></a> is used to set up aliases, often useful with modules' names.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#case/2" data-no-tooltip translate="no">case(condition, clauses)</a> </dt> <dd class="summary-synopsis"><p>Matches the given expression against the given clauses.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cond/1" data-no-tooltip translate="no">cond(clauses)</a> </dt> <dd class="summary-synopsis"><p>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#fn/1" data-no-tooltip translate="no">fn(clauses)</a> </dt> <dd class="summary-synopsis"><p>Defines an anonymous function.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#for/1" data-no-tooltip translate="no">for(args)</a> </dt> <dd class="summary-synopsis"><p>Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#import/2" data-no-tooltip translate="no">import(module, opts)</a> </dt> <dd class="summary-synopsis"><p>Imports functions and macros from other modules.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#quote/2" data-no-tooltip translate="no">quote(opts, block)</a> </dt> <dd class="summary-synopsis"><p>Gets the representation of any expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#receive/1" data-no-tooltip translate="no">receive(args)</a> </dt> <dd class="summary-synopsis"><p>Checks if there is a message matching any of the given clauses in the current process mailbox.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#require/2" data-no-tooltip translate="no">require(module, opts)</a> </dt> <dd class="summary-synopsis"><p>Requires a module in order to use its macros.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#super/1" data-no-tooltip translate="no">super(args)</a> </dt> <dd class="summary-synopsis"><p>Calls the overridden function when overriding it with <a href="kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#try/1" data-no-tooltip translate="no">try(args)</a> </dt> <dd class="summary-synopsis"><p>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unquote/1" data-no-tooltip translate="no">unquote(expr)</a> </dt> <dd class="summary-synopsis"><p>Unquotes the given expression inside a quoted expression.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#unquote_splicing/1" data-no-tooltip translate="no">unquote_splicing(expr)</a> </dt> <dd class="summary-synopsis"><p>Unquotes the given list expanding its arguments.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#with/1" data-no-tooltip translate="no">with(args)</a> </dt> <dd class="summary-synopsis"><p>Combine matching clauses.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%5E/1" data-no-tooltip translate="no">^var</a> </dt> <dd class="summary-synopsis"><p>Pin operator. Accesses an already bound variable in match clauses.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#%7B%7D/1" data-no-tooltip translate="no">{args}</a> </dt> <dd class="summary-synopsis"><p>Creates a tuple.</p></dd> </div> </dl> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="%25/2">%struct{}<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L154" class="source">Source</a>
</h3> <section class="docstring"> <p>Matches on or builds a struct.</p>
<p>A struct is a tagged map that allows developers to provide default values for keys, tags to be used in polymorphic dispatches and compile time assertions.</p>
<p>Structs are usually defined with the <a href="kernel.html#defstruct/1"><code class="inline">Kernel.defstruct/1</code></a> macro:</p>
<pre data-language="elixir">defmodule User do
  defstruct name: "john", age: 27
end</pre>
<p>Now a struct can be created as follows:</p>
<pre data-language="elixir">%User{}</pre>
<p>Underneath a struct is just a map with a <code class="inline">:__struct__</code> key pointing to the <code class="inline">User</code> module:</p>
<pre data-language="elixir">%User{} == %{__struct__: User, name: "john", age: 27}</pre>
<p>The struct fields can be given when building the struct:</p>
<pre data-language="elixir">%User{age: 31}
#=&gt; %{__struct__: User, name: "john", age: 31}</pre>
<p>Or also on pattern matching to extract values out:</p>
<pre data-language="elixir">%User{age: age} = user</pre>
<p>An update operation specific for structs is also available:</p>
<pre data-language="elixir">%User{user | age: 28}</pre>
<p>The advantage of structs is that they validate that the given keys are part of the defined struct. The example below will fail because there is no key <code class="inline">:full_name</code> in the <code class="inline">User</code> struct:</p>
<pre data-language="elixir">%User{full_name: "john doe"}</pre>
<p>The syntax above will guarantee the given keys are valid at compilation time and it will guarantee at runtime the given argument is a struct, failing with <a href="badstructerror.html"><code class="inline">BadStructError</code></a> otherwise.</p>
<p>Although structs are maps, by default structs do not implement any of the protocols implemented for maps. Check <a href="kernel.html#defprotocol/2"><code class="inline">Kernel.defprotocol/2</code></a> for more information on how structs can be used with protocols for polymorphic dispatch. Also see <a href="kernel.html#struct/2"><code class="inline">Kernel.struct/2</code></a> and <a href="kernel.html#struct!/2"><code class="inline">Kernel.struct!/2</code></a> for examples on how to create and update structs dynamically.</p>
<h4 id="%25/2-pattern-matching-on-struct-names" class="section-heading">  <span class="text">Pattern matching on struct names</span> </h4> <p>Besides allowing pattern matching on struct fields, such as:</p>
<pre data-language="elixir">%User{age: age} = user</pre>
<p>Structs also allow pattern matching on the struct name:</p>
<pre data-language="elixir">%struct_name{} = user
struct_name #=&gt; User</pre>
<p>You can also assign the struct name to <code class="inline">_</code> when you want to check if something is a struct but you are not interested in its name:</p>
<pre data-language="elixir">%_{} = user</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%25%7B%7D/1">%{}<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L82" class="source">Source</a>
</h3> <section class="docstring"> <p>Creates a map.</p>
<p>See the <a href="map.html"><code class="inline">Map</code></a> module for more information about maps, their syntax, and ways to access and manipulate them.</p>
<h4 id="%25%7B%7D/1-ast-representation" class="section-heading">  <span class="text">AST representation</span> </h4> <p>Regardless of whether <code class="inline">=&gt;</code> or the keyword syntax is used, key-value pairs in maps are always represented internally as a list of two-element tuples for simplicity:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   %{"a" =&gt; :b, c: :d}
...&gt; end
{:%{}, [], [{"a", :b}, {:c, :d}]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="&amp;/1">&amp;expr<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1844" class="source">Source</a>
</h3> <section class="docstring"> <p>Capture operator. Captures or creates an anonymous function.</p>
<h4 id="&amp;/1-capture" class="section-heading">  <span class="text">Capture</span> </h4> <p>The capture operator is most commonly used to capture a function with given name and arity from a module:</p>
<pre data-language="elixir">iex&gt; fun = &amp;Kernel.is_atom/1
iex&gt; fun.(:atom)
true
iex&gt; fun.("string")
false</pre>
<p>In the example above, we captured <a href="kernel.html#is_atom/1"><code class="inline">Kernel.is_atom/1</code></a> as an anonymous function and then invoked it.</p>
<p>The capture operator can also be used to capture local functions, including private ones, and imported functions by omitting the module name:</p>
<pre data-language="elixir">&amp;local_function/1</pre>
<p>See also <a href="function.html#capture/3"><code class="inline">Function.capture/3</code></a>.</p>
<h4 id="&amp;/1-anonymous-functions" class="section-heading">  <span class="text">Anonymous functions</span> </h4> <p>The capture operator can also be used to partially apply functions, where <code class="inline">&amp;1</code>, <code class="inline">&amp;2</code> and so on can be used as value placeholders. For example:</p>
<pre data-language="elixir">iex&gt; double = &amp;(&amp;1 * 2)
iex&gt; double.(2)
4</pre>
<p>In other words, <code class="inline">&amp;(&amp;1 * 2)</code> is equivalent to <code class="inline">fn x -&gt; x * 2 end</code>.</p>
<p>We can partially apply a remote function with placeholder:</p>
<pre data-language="elixir">iex&gt; take_five = &amp;Enum.take(&amp;1, 5)
iex&gt; take_five.(1..10)
[1, 2, 3, 4, 5]</pre>
<p>Another example while using an imported or local function:</p>
<pre data-language="elixir">iex&gt; first_elem = &amp;elem(&amp;1, 0)
iex&gt; first_elem.({0, 1})
0</pre>
<p>The <code class="inline">&amp;</code> operator can be used with more complex expressions:</p>
<pre data-language="elixir">iex&gt; fun = &amp;(&amp;1 + &amp;2 + &amp;3)
iex&gt; fun.(1, 2, 3)
6</pre>
<p>As well as with lists and tuples:</p>
<pre data-language="elixir">iex&gt; fun = &amp;{&amp;1, &amp;2}
iex&gt; fun.(1, 2)
{1, 2}

iex&gt; fun = &amp;[&amp;1 | &amp;2]
iex&gt; fun.(1, [2, 3])
[1, 2, 3]</pre>
<p>The only restrictions when creating anonymous functions is that at least one placeholder must be present, i.e. it must contain at least <code class="inline">&amp;1</code>, and that block expressions are not supported:</p>
<pre data-language="elixir"># No placeholder, fails to compile.
&amp;(:foo)

# Block expression, fails to compile.
&amp;(&amp;1; &amp;2)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="./2">left . right<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L496" class="source">Source</a>
</h3> <section class="docstring"> <p>Dot operator. Defines a remote call, a call to an anonymous function, or an alias.</p>
<p>The dot (<code class="inline">.</code>) in Elixir can be used for remote calls:</p>
<pre data-language="elixir">iex&gt; String.downcase("FOO")
"foo"</pre>
<p>In this example above, we have used <code class="inline">.</code> to invoke <code class="inline">downcase</code> in the <a href="string.html"><code class="inline">String</code></a> module, passing <code class="inline">"FOO"</code> as argument.</p>
<p>The dot may be used to invoke anonymous functions too:</p>
<pre data-language="elixir">iex&gt; (fn n -&gt; n end).(7)
7</pre>
<p>in which case there is a function on the left hand side.</p>
<p>We can also use the dot for creating aliases:</p>
<pre data-language="elixir">iex&gt; Hello.World
Hello.World</pre>
<p>This time, we have joined two aliases, defining the final alias <code class="inline">Hello.World</code>.</p>
<h4 id="./2-syntax" class="section-heading">  <span class="text">Syntax</span> </h4> <p>The right side of <code class="inline">.</code> may be a word starting with an uppercase letter, which represents an alias, a word starting with lowercase or underscore, any valid language operator or any name wrapped in single- or double-quotes. Those are all valid examples:</p>
<pre data-language="elixir">iex&gt; Kernel.Sample
Kernel.Sample

iex&gt; Kernel.length([1, 2, 3])
3

iex&gt; Kernel.+(1, 2)
3

iex&gt; Kernel."+"(1, 2)
3</pre>
<p>Wrapping the function name in single- or double-quotes is always a remote call. Therefore <code class="inline">Kernel."Foo"</code> will attempt to call the function "Foo" and not return the alias <code class="inline">Kernel.Foo</code>. This is done by design as module names are more strict than function names.</p>
<p>When the dot is used to invoke an anonymous function there is only one operand, but it is still written using a postfix notation:</p>
<pre data-language="elixir">iex&gt; negate = fn n -&gt; -n end
iex&gt; negate.(7)
-7</pre>
<h4 id="./2-quoted-expression" class="section-heading">  <span class="text">Quoted expression</span> </h4> <p>When <code class="inline">.</code> is used, the quoted expression may take two distinct forms. When the right side starts with a lowercase letter (or underscore):</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   String.downcase("FOO")
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}</pre>
<p>Note that we have an inner tuple, containing the atom <code class="inline">:.</code> representing the dot as first element:</p>
<pre data-language="elixir">{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}</pre>
<p>This tuple follows the general quoted expression structure in Elixir, with the name as first argument, some keyword list as metadata as second, and the list of arguments as third. In this case, the arguments are the alias <a href="string.html"><code class="inline">String</code></a> and the atom <code class="inline">:downcase</code>. The second argument in a remote call is <strong>always</strong> an atom.</p>
<p>In the case of calls to anonymous functions, the inner tuple with the dot special form has only one argument, reflecting the fact that the operator is unary:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   negate.(0)
...&gt; end
{{:., [], [{:negate, [], __MODULE__}]}, [], [0]}</pre>
<p>When the right side is an alias (i.e. starts with uppercase), we get instead:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   Hello.World
...&gt; end
{:__aliases__, [alias: false], [:Hello, :World]}</pre>
<p>We go into more details about aliases in the <a href="#__aliases__/1"><code class="inline">__aliases__/1</code></a> special form documentation.</p>
<h4 id="./2-unquoting" class="section-heading">  <span class="text">Unquoting</span> </h4> <p>We can also use unquote to generate a remote call in a quoted expression:</p>
<pre data-language="elixir">iex&gt; x = :downcase
iex&gt; quote do
...&gt;   String.unquote(x)("FOO")
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:String]}, :downcase]}, [], ["FOO"]}</pre>
<p>Similar to <code class="inline">Kernel."FUNCTION_NAME"</code>, <code class="inline">unquote(x)</code> will always generate a remote call, independent of the value of <code class="inline">x</code>. To generate an alias via the quoted expression, one needs to rely on <a href="module.html#concat/2"><code class="inline">Module.concat/2</code></a>:</p>
<pre data-language="elixir">iex&gt; x = Sample
iex&gt; quote do
...&gt;   Module.concat(String, unquote(x))
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:Module]}, :concat]}, [],
 [{:__aliases__, [alias: false], [:String]}, Sample]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="__aliases__/1">__aliases__(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1878" class="source">Source</a>
</h3> <section class="docstring"> <p>Internal special form to hold aliases information.</p>
<p>It is usually compiled to an atom:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   Foo.Bar
...&gt; end
{:__aliases__, [alias: false], [:Foo, :Bar]}</pre>
<p>Elixir represents <code class="inline">Foo.Bar</code> as <code class="inline">__aliases__</code> so calls can be unambiguously identified by the operator <code class="inline">:.</code>. For example:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   Foo.bar()
...&gt; end
{{:., [], [{:__aliases__, [alias: false], [:Foo]}, :bar]}, [], []}</pre>
<p>Whenever an expression iterator sees a <code class="inline">:.</code> as the tuple key, it can be sure that it represents a call and the second argument in the list is an atom.</p>
<p>On the other hand, aliases hold some properties:</p>
<ol>
<li><p>The head element of aliases can be any term that must expand to an atom at compilation time.</p></li>
<li><p>The tail elements of aliases are guaranteed to always be atoms.</p></li>
<li><p>When the head element of aliases is the atom <code class="inline">:Elixir</code>, no expansion happens.</p></li>
</ol> </section> </section> <section class="detail"> <h3 class="detail-header" id="__block__/1">__block__(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1757" class="source">Source</a>
</h3> <section class="docstring"> <p>Internal special form for block expressions.</p>
<p>This is the special form used whenever we have a block of expressions in Elixir. This special form is private and should not be invoked directly:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   1
...&gt;   2
...&gt;   3
...&gt; end
{:__block__, [], [1, 2, 3]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="__CALLER__/0">__CALLER__<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L719" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the current calling environment as a <a href="macro.env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the filename, line numbers, set up aliases, the function and others.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="__cursor__/1">__cursor__(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1766" class="source">Source</a>
</h3> <section class="docstring"> <p>Internal special form for cursor position.</p>
<p>This is the special form used whenever we need to represent the cursor position in Elixir's AST. See <a href="code.fragment.html"><code class="inline">Code.Fragment</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="__DIR__/0">__DIR__<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L711" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the absolute path of the directory of the current file as a binary.</p>
<p>Although the directory can be accessed as <code class="inline">Path.dirname(__ENV__.file)</code>, this macro is a convenient shortcut.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="__ENV__/0">__ENV__<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L695" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the current environment information as a <a href="macro.env.html"><code class="inline">Macro.Env</code></a> struct.</p>
<p>In the environment you can access the current filename, line numbers, set up aliases, the current function and others.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="__MODULE__/0">__MODULE__<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L703" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the current module name as an atom or <code class="inline">nil</code> otherwise.</p>
<p>Although the module can be accessed in the <a href="#__ENV__/0"><code class="inline">__ENV__/0</code></a>, this macro is a convenient shortcut.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="__STACKTRACE__/0">__STACKTRACE__<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L731" class="source">Source</a>
</h3> <section class="docstring"> <p>Returns the stacktrace for the currently handled exception.</p>
<p>It is available only in the <code class="inline">catch</code> and <code class="inline">rescue</code> clauses of <a href="#try/1"><code class="inline">try/1</code></a> expressions.</p>
<p>To retrieve the stacktrace of the current process, use <code class="inline">Process.info(self(), :current_stacktrace)</code> instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="::/2">left :: right<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L789" class="source">Source</a>
</h3> <section class="docstring"> <p>Type operator. Used by types and bitstrings to specify types.</p>
<p>This operator is used in two distinct occasions in Elixir. It is used in typespecs to specify the type of a variable, function or of a type itself:</p>
<pre data-language="elixir">@type number :: integer | float
@spec add(number, number) :: number</pre>
<p>It may also be used in bit strings to specify the type of a given bit segment:</p>
<pre data-language="elixir">&lt;&lt;int::integer-little, rest::bits&gt;&gt; = bits</pre>
<p>Read the documentation on the <a href="typespecs.html">Typespecs page</a> and <a href="#%3C%3C%3E%3E/1"><code class="inline">&lt;&lt;&gt;&gt;/1</code></a> for more information on typespecs and bitstrings respectively.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%3C%3C%3E%3E/1">&lt;&lt;args&gt;&gt;<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L374" class="source">Source</a>
</h3> <section class="docstring"> <p>Defines a new bitstring.</p>
<h4 id="%3C%3C%3E%3E/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;</pre>
<h4 id="%3C%3C%3E%3E/1-types" class="section-heading">  <span class="text">Types</span> </h4> <p>A bitstring is made of many segments and each segment has a type. There are 9 types used in bitstrings:</p>
<ul>
<li><code class="inline">integer</code></li>
<li><code class="inline">float</code></li>
<li>
<code class="inline">bits</code> (alias for <code class="inline">bitstring</code>)</li>
<li><code class="inline">bitstring</code></li>
<li><code class="inline">binary</code></li>
<li>
<code class="inline">bytes</code> (alias for <code class="inline">binary</code>)</li>
<li><code class="inline">utf8</code></li>
<li><code class="inline">utf16</code></li>
<li><code class="inline">utf32</code></li>
</ul>
<p>When no type is specified, the default is <code class="inline">integer</code>:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;1, 2, 3&gt;&gt;
&lt;&lt;1, 2, 3&gt;&gt;</pre>
<p>Elixir also accepts by default the segment to be a literal string which expands to integers:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;0, "foo"&gt;&gt;
&lt;&lt;0, 102, 111, 111&gt;&gt;</pre>
<p>You can use one of <code class="inline">utf8</code> (the default), <code class="inline">utf16</code>, and <code class="inline">utf32</code> to control how the string is encoded:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;"foo"::utf16&gt;&gt;
&lt;&lt;0, 102, 0, 111, 0, 111&gt;&gt;</pre>
<p>Which is equivalent to writing:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;?f::utf16, ?o::utf16, ?o::utf16&gt;&gt;
&lt;&lt;0, 102, 0, 111, 0, 111&gt;&gt;</pre>
<p>At runtime, binaries need to be explicitly tagged as <code class="inline">binary</code>:</p>
<pre data-language="elixir">iex&gt; rest = "oo"
iex&gt; &lt;&lt;102, rest::binary&gt;&gt;
"foo"</pre>
<p>Otherwise we get an <a href="argumenterror.html"><code class="inline">ArgumentError</code></a> when constructing the binary:</p>
<pre data-language="elixir">rest = "oo"
&lt;&lt;102, rest&gt;&gt;
** (ArgumentError) argument error</pre>
<h4 id="%3C%3C%3E%3E/1-options" class="section-heading">  <span class="text">Options</span> </h4> <p>Many options can be given by using <code class="inline">-</code> as separator. Order is arbitrary, so the following are all equivalent:</p>
<pre data-language="elixir">&lt;&lt;102::integer-native, rest::binary&gt;&gt;
&lt;&lt;102::native-integer, rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer, rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer-size(8), rest::binary&gt;&gt;
&lt;&lt;102::unsigned-big-integer-8, rest::binary&gt;&gt;
&lt;&lt;102::8-integer-big-unsigned, rest::binary&gt;&gt;
&lt;&lt;102, rest::binary&gt;&gt;</pre>
<h3 id="%3C%3C%3E%3E/1-unit-and-size" class="section-heading">  <span class="text">Unit and Size</span> </h3> <p>The length of the match is equal to the <code class="inline">unit</code> (a number of bits) times the <code class="inline">size</code> (the number of repeated segments of length <code class="inline">unit</code>).</p>
<table>
<thead><tr>
<th style="text-align: left;">Type</th>
<th style="text-align: left;">Default Unit</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><code class="inline">integer</code></td>
<td style="text-align: left;">1 bit</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">float</code></td>
<td style="text-align: left;">1 bit</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">binary</code></td>
<td style="text-align: left;">8 bits</td>
</tr>
</tbody>
</table>
<p>Sizes for types are a bit more nuanced. The default size for integers is 8.</p>
<p>For floats, it is 64. For floats, <code class="inline">size * unit</code> must result in 16, 32, or 64, corresponding to <a href="https://en.wikipedia.org/wiki/IEEE_floating_point">IEEE 754</a> binary16, binary32, and binary64, respectively.</p>
<p>For binaries, the default is the size of the binary. Only the last binary in a match can use the default size. All others must have their size specified explicitly, even if the match is unambiguous. For example:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;name::binary-size(5), " the ", species::binary&gt;&gt; = &lt;&lt;"Frank the Walrus"&gt;&gt;
"Frank the Walrus"
iex&gt; {name, species}
{"Frank", "Walrus"}</pre>
<p>The size can be a variable or any valid guard expression:</p>
<pre data-language="elixir">iex&gt; name_size = 5
iex&gt; &lt;&lt;name::binary-size(^name_size), " the ", species::binary&gt;&gt; = &lt;&lt;"Frank the Walrus"&gt;&gt;
iex&gt; {name, species}
{"Frank", "Walrus"}</pre>
<p>The size can access prior variables defined in the binary itself:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;name_size::size(8), name::binary-size(name_size), " the ", species::binary&gt;&gt; = &lt;&lt;5, "Frank the Walrus"&gt;&gt;
iex&gt; {name, species}
{"Frank", "Walrus"}</pre>
<p>However, it cannot access variables defined in the match outside of the binary/bitstring:</p>
<pre data-language="elixir">{name_size, &lt;&lt;name::binary-size(name_size), _rest::binary&gt;&gt;} = {5, &lt;&lt;"Frank the Walrus"&gt;&gt;}
** (CompileError): undefined variable "name_size" in bitstring segment</pre>
<p>Failing to specify the size for the non-last causes compilation to fail:</p>
<pre data-language="elixir">&lt;&lt;name::binary, " the ", species::binary&gt;&gt; = &lt;&lt;"Frank the Walrus"&gt;&gt;
** (CompileError): a binary field without size is only allowed at the end of a binary pattern</pre>
<h4>Shortcut Syntax</h4>
<p>Size and unit can also be specified using a syntax shortcut when passing integer values:</p>
<pre data-language="elixir">iex&gt; x = 1
iex&gt; &lt;&lt;x::8&gt;&gt; == &lt;&lt;x::size(8)&gt;&gt;
true
iex&gt; &lt;&lt;x::8*4&gt;&gt; == &lt;&lt;x::size(8)-unit(4)&gt;&gt;
true</pre>
<p>This syntax reflects the fact the effective size is given by multiplying the size by the unit.</p>
<h3 id="%3C%3C%3E%3E/1-modifiers" class="section-heading">  <span class="text">Modifiers</span> </h3> <p>Some types have associated modifiers to clear up ambiguity in byte representation.</p>
<table>
<thead><tr>
<th style="text-align: left;">Modifier</th>
<th style="text-align: left;">Relevant Type(s)</th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><code class="inline">signed</code></td>
<td style="text-align: left;"><code class="inline">integer</code></td>
</tr>
<tr>
<td style="text-align: left;">
<code class="inline">unsigned</code> (default)</td>
<td style="text-align: left;"><code class="inline">integer</code></td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">little</code></td>
<td style="text-align: left;">
<code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code>
</td>
</tr>
<tr>
<td style="text-align: left;">
<code class="inline">big</code> (default)</td>
<td style="text-align: left;">
<code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code>
</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">native</code></td>
<td style="text-align: left;">
<code class="inline">integer</code>, <code class="inline">float</code>, <code class="inline">utf16</code>, <code class="inline">utf32</code>
</td>
</tr>
</tbody>
</table>
<h3 id="%3C%3C%3E%3E/1-sign" class="section-heading">  <span class="text">Sign</span> </h3> <p>Integers can be <code class="inline">signed</code> or <code class="inline">unsigned</code>, defaulting to <code class="inline">unsigned</code>.</p>
<pre data-language="elixir">iex&gt; &lt;&lt;int::integer&gt;&gt; = &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
156
iex&gt; &lt;&lt;int::integer-signed&gt;&gt; = &lt;&lt;-100&gt;&gt;
&lt;&lt;156&gt;&gt;
iex&gt; int
-100</pre>
<p><code class="inline">signed</code> and <code class="inline">unsigned</code> are only used for matching binaries (see below) and are only used for integers.</p>
<pre data-language="elixir">iex&gt; &lt;&lt;-100::signed, _rest::binary&gt;&gt; = &lt;&lt;-100, "foo"&gt;&gt;
&lt;&lt;156, 102, 111, 111&gt;&gt;</pre>
<h3 id="%3C%3C%3E%3E/1-endianness" class="section-heading">  <span class="text">Endianness</span> </h3> <p>Elixir has three options for endianness: <code class="inline">big</code>, <code class="inline">little</code>, and <code class="inline">native</code>. The default is <code class="inline">big</code>:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;number::little-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
256
iex&gt; &lt;&lt;number::big-integer-size(16)&gt;&gt; = &lt;&lt;0, 1&gt;&gt;
&lt;&lt;0, 1&gt;&gt;
iex&gt; number
1</pre>
<p><code class="inline">native</code> is determined by the VM at startup and will depend on the host operating system.</p>
<h4 id="%3C%3C%3E%3E/1-binary-bitstring-matching" class="section-heading">  <span class="text">Binary/Bitstring Matching</span> </h4> <p>Binary matching is a powerful feature in Elixir that is useful for extracting information from binaries as well as pattern matching.</p>
<p>Binary matching can be used by itself to extract information from binaries:</p>
<pre data-language="elixir">iex&gt; &lt;&lt;"Hello, ", place::binary&gt;&gt; = "Hello, World"
"Hello, World"
iex&gt; place
"World"</pre>
<p>Or as a part of function definitions to pattern match:</p>
<pre data-language="elixir">defmodule ImageType do
  @png_signature &lt;&lt;137::size(8), 80::size(8), 78::size(8), 71::size(8),
                   13::size(8), 10::size(8), 26::size(8), 10::size(8)&gt;&gt;
  @jpg_signature &lt;&lt;255::size(8), 216::size(8)&gt;&gt;

  def type(&lt;&lt;@png_signature, _rest::binary&gt;&gt;), do: :png
  def type(&lt;&lt;@jpg_signature, _rest::binary&gt;&gt;), do: :jpg
  def type(_), do: :unknown
end</pre>
<h3 id="%3C%3C%3E%3E/1-performance-optimizations" class="section-heading">  <span class="text">Performance &amp; Optimizations</span> </h3> <p>The Erlang compiler can provide a number of optimizations on binary creation and matching. To see optimization output, set the <code class="inline">bin_opt_info</code> compiler option:</p>
<pre data-language="elixir">ERL_COMPILER_OPTIONS=bin_opt_info mix compile</pre>
<p>To learn more about specific optimizations and performance considerations, check out the <a href="https://www.erlang.org/doc/efficiency_guide/binaryhandling.html">"Constructing and matching binaries" chapter of the Erlang's Efficiency Guide</a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="=/2">left = right<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L768" class="source">Source</a>
</h3> <section class="docstring"> <p>Match operator. Matches the value on the right against the pattern on the left.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="alias/2">alias(module, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L557" class="source">Source</a>
</h3> <section class="docstring"> <p><a href="#alias/2"><code class="inline">alias/2</code></a> is used to set up aliases, often useful with modules' names.</p>
<h4 id="alias/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p><a href="#alias/2"><code class="inline">alias/2</code></a> can be used to set up an alias for any module:</p>
<pre data-language="elixir">defmodule Math do
  alias MyKeyword, as: Keyword
end</pre>
<p>In the example above, we have set up <code class="inline">MyKeyword</code> to be aliased as <a href="keyword.html"><code class="inline">Keyword</code></a>. So now, any reference to <a href="keyword.html"><code class="inline">Keyword</code></a> will be automatically replaced by <code class="inline">MyKeyword</code>.</p>
<p>In case one wants to access the original <a href="keyword.html"><code class="inline">Keyword</code></a>, it can be done by accessing <code class="inline">Elixir</code>:</p>
<pre data-language="elixir">Keyword.values #=&gt; uses MyKeyword.values
Elixir.Keyword.values #=&gt; uses Keyword.values</pre>
<p>Note that calling <code class="inline">alias</code> without the <code class="inline">:as</code> option automatically sets an alias based on the last part of the module. For example:</p>
<pre data-language="elixir">alias Foo.Bar.Baz</pre>
<p>Is the same as:</p>
<pre data-language="elixir">alias Foo.Bar.Baz, as: Baz</pre>
<p>We can also alias multiple modules in one line:</p>
<pre data-language="elixir">alias Foo.{Bar, Baz, Biz}</pre>
<p>Is the same as:</p>
<pre data-language="elixir">alias Foo.Bar
alias Foo.Baz
alias Foo.Biz</pre>
<h4 id="alias/2-lexical-scope" class="section-heading">  <span class="text">Lexical scope</span> </h4> <p><a href="#import/2"><code class="inline">import/2</code></a>, <a href="#require/2"><code class="inline">require/2</code></a> and <a href="#alias/2"><code class="inline">alias/2</code></a> are called directives and all have lexical scope. This means you can set up aliases inside specific functions and it won't affect the overall scope.</p>
<h4 id="alias/2-warnings" class="section-heading">  <span class="text">Warnings</span> </h4> <p>If you alias a module and you don't use the alias, Elixir is going to issue a warning implying the alias is not being used.</p>
<p>In case the alias is generated automatically by a macro, Elixir won't emit any warnings though, since the alias was not explicitly defined.</p>
<p>Both warning behaviors could be changed by explicitly setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="case/2">case(condition, clauses)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1981" class="source">Source</a>
</h3> <section class="docstring"> <p>Matches the given expression against the given clauses.</p>
<p><a href="#case/2"><code class="inline">case/2</code></a> relies on pattern matching and guards to choose which clause to execute. If your logic cannot be expressed within patterns and guards, consider using <a href="kernel.html#if/2"><code class="inline">if/2</code></a> or <a href="#cond/1"><code class="inline">cond/1</code></a> instead.</p>
<h4 id="case/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">case File.read(file) do
  {:ok, contents} when is_binary(contents) -&gt;
    String.split(contents, "\n")

  {:error, _reason} -&gt;
    Logger.warning "could not find #{file}, assuming empty..."
    []
end</pre>
<p>In the example above, we match the result of <a href="file.html#read/1"><code class="inline">File.read/1</code></a> against each clause "head" and execute the clause "body" corresponding to the first clause that matches.</p>
<p>If no clause matches, an error is raised. For this reason, it may be necessary to add a final catch-all clause (like <code class="inline">_</code>) which will always match.</p>
<pre data-language="elixir">x = 10

case x do
  0 -&gt;
    "This clause won't match"

  _ -&gt;
    "This clause would match any value (x = #{x})"
end
#=&gt; "This clause would match any value (x = 10)"</pre>
<p>If you find yourself nesting <code class="inline">case</code> expressions inside <code class="inline">case</code> expressions, consider using <a href="#with/1"><code class="inline">with/1</code></a>.</p>
<h4 id="case/2-variable-handling" class="section-heading">  <span class="text">Variable handling</span> </h4> <p>Note that variables bound in a clause do not leak to the outer context:</p>
<pre data-language="elixir">case data do
  {:ok, value} -&gt; value
  :error -&gt; nil
end

value
#=&gt; unbound variable value</pre>
<p>Variables in the outer context cannot be overridden either:</p>
<pre data-language="elixir">value = 7

case lucky? do
  false -&gt; value = 13
  true -&gt; true
end

value
#=&gt; 7</pre>
<p>In the example above, <code class="inline">value</code> is going to be <code class="inline">7</code> regardless of the value of <code class="inline">lucky?</code>. The variable <code class="inline">value</code> bound in the clause and the variable <code class="inline">value</code> bound in the outer context are two entirely separate variables.</p>
<p>If you want to pattern match against an existing variable, you need to use the <a href="#%5E/1"><code class="inline">^/1</code></a> operator:</p>
<pre data-language="elixir">x = 1

case 10 do
  ^x -&gt; "Won't match"
  _ -&gt; "Will match"
end
#=&gt; "Will match"</pre>
<h4 id="case/2-using-guards-to-match-against-multiple-values" class="section-heading">  <span class="text">Using guards to match against multiple values</span> </h4> <p>While it is not possible to match against multiple patterns in a single clause, it's possible to match against multiple values by using guards:</p>
<pre data-language="elixir">case data do
  value when value in [:one, :two] -&gt;
    "#{value} has been matched"

  :three -&gt;
    "three has been matched"
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="cond/1">cond(clauses)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L2016" class="source">Source</a>
</h3> <section class="docstring"> <p>Evaluates the expression corresponding to the first clause that evaluates to a truthy value.</p>
<h4 id="cond/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>The following example has a single clause that always evaluates to true:</p>
<pre data-language="elixir">cond do
  hd([1, 2, 3]) -&gt;
    "1 is considered as true"
end
#=&gt; "1 is considered as true"</pre>
<p>If all clauses evaluate to <code class="inline">nil</code> or <code class="inline">false</code>, <code class="inline">cond</code> raises an error. For this reason, it may be necessary to add a final always-truthy condition (anything non-<code class="inline">false</code> and non-<code class="inline">nil</code>), which will always match:</p>
<pre data-language="elixir">cond do
  1 + 1 == 1 -&gt;
    "This will never match"
  2 * 2 != 4 -&gt;
    "Nor this"
  true -&gt;
    "This will"
end
#=&gt; "This will"</pre>
<p>If your <code class="inline">cond</code> has two clauses, and the last one falls back to <code class="inline">true</code>, you may consider using <a href="kernel.html#if/2"><code class="inline">if/2</code></a> instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="fn/1">fn(clauses)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1740" class="source">Source</a>
</h3> <section class="docstring"> <p>Defines an anonymous function.</p>
<p>See <a href="function.html"><code class="inline">Function</code></a> for more information.</p>
<h4 id="fn/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; add = fn a, b -&gt; a + b end
iex&gt; add.(1, 2)
3</pre>
<p>Anonymous functions can also have multiple clauses. All clauses should expect the same number of arguments:</p>
<pre data-language="elixir">iex&gt; negate = fn
...&gt;   true -&gt; false
...&gt;   false -&gt; true
...&gt; end
iex&gt; negate.(false)
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="for/1">for(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1539" class="source">Source</a>
</h3> <section class="docstring"> <p>Comprehensions allow you to quickly build a data structure from an enumerable or a bitstring.</p>
<p>Let's start with an example:</p>
<pre data-language="elixir">iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]</pre>
<p>A comprehension accepts many generators and filters. <code class="inline">for</code> uses the <code class="inline">&lt;-</code> operator to extract values from the enumerable on its right side and match them against the pattern on the left. We call them generators:</p>
<pre data-language="elixir"># A list generator:
iex&gt; for n &lt;- [1, 2, 3, 4], do: n * 2
[2, 4, 6, 8]

# A comprehension with two generators
iex&gt; for x &lt;- [1, 2], y &lt;- [2, 3], do: x * y
[2, 3, 4, 6]</pre>
<p>Filters can also be given:</p>
<pre data-language="elixir"># A comprehension with a generator and a filter
iex&gt; for n &lt;- [1, 2, 3, 4, 5, 6], rem(n, 2) == 0, do: n
[2, 4, 6]</pre>
<p>Filters must evaluate to truthy values (everything but <code class="inline">nil</code> and <code class="inline">false</code>). If a filter is falsy, then the current value is discarded.</p>
<p>Generators can also be used to filter as it removes any value that doesn't match the pattern on the left side of <code class="inline">&lt;-</code>:</p>
<pre data-language="elixir">iex&gt; users = [user: "john", admin: "meg", guest: "barbara"]
iex&gt; for {type, name} when type != :guest &lt;- users do
...&gt;   String.upcase(name)
...&gt; end
["JOHN", "MEG"]</pre>
<p>Bitstring generators are also supported and are very useful when you need to organize bitstring streams:</p>
<pre data-language="elixir">iex&gt; pixels = &lt;&lt;213, 45, 132, 64, 76, 32, 76, 0, 0, 234, 32, 15&gt;&gt;
iex&gt; for &lt;&lt;r::8, g::8, b::8 &lt;- pixels&gt;&gt;, do: {r, g, b}
[{213, 45, 132}, {64, 76, 32}, {76, 0, 0}, {234, 32, 15}]</pre>
<p>Variable assignments inside the comprehension, be it in generators, filters or inside the block, are not reflected outside of the comprehension.</p>
<p>Variable assignments inside filters must still return a truthy value, otherwise values are discarded. Let's see an example. Imagine you have a keyword list where the key is a programming language and the value is its direct parent. Then let's try to compute the grandparent of each language. You could try this:</p>
<pre data-language="elixir">iex&gt; languages = [elixir: :erlang, erlang: :prolog, prolog: nil]
iex&gt; for {language, parent} &lt;- languages, grandparent = languages[parent], do: {language, grandparent}
[elixir: :prolog]</pre>
<p>Given the grandparents of Erlang and Prolog were nil, those values were filtered out. If you don't want this behavior, a simple option is to move the filter inside the do-block:</p>
<pre data-language="elixir">iex&gt; languages = [elixir: :erlang, erlang: :prolog, prolog: nil]
iex&gt; for {language, parent} &lt;- languages do
...&gt;   grandparent = languages[parent]
...&gt;   {language, grandparent}
...&gt; end
[elixir: :prolog, erlang: nil, prolog: nil]</pre>
<p>However, such option is not always available, as you may have further filters. An alternative is to convert the filter into a generator by wrapping the right side of <code class="inline">=</code> in a list:</p>
<pre data-language="elixir">iex&gt; languages = [elixir: :erlang, erlang: :prolog, prolog: nil]
iex&gt; for {language, parent} &lt;- languages, grandparent &lt;- [languages[parent]], do: {language, grandparent}
[elixir: :prolog, erlang: nil, prolog: nil]</pre>
<h4 id="for/1-the-into-and-uniq-options" class="section-heading">  <span class="text">The <code class="inline">:into</code> and <code class="inline">:uniq</code> options</span> </h4> <p>In the examples above, the result returned by the comprehension was always a list. The returned result can be configured by passing an <code class="inline">:into</code> option, that accepts any structure as long as it implements the <a href="collectable.html"><code class="inline">Collectable</code></a> protocol.</p>
<p>For example, we can use bitstring generators with the <code class="inline">:into</code> option to easily remove all spaces in a string:</p>
<pre data-language="elixir">iex&gt; for &lt;&lt;c &lt;- " hello world "&gt;&gt;, c != ?\s, into: "", do: &lt;&lt;c&gt;&gt;
"helloworld"</pre>
<p>The <a href="io.html"><code class="inline">IO</code></a> module provides streams, that are both <a href="enumerable.html"><code class="inline">Enumerable</code></a> and <a href="collectable.html"><code class="inline">Collectable</code></a>, here is an upcase echo server using comprehensions:</p>
<pre data-language="elixir">for line &lt;- IO.stream(), into: IO.stream() do
  String.upcase(line)
end</pre>
<p>Similarly, <code class="inline">uniq: true</code> can also be given to comprehensions to guarantee the results are only added to the collection if they were not returned before. For example:</p>
<pre data-language="elixir">iex&gt; for x &lt;- [1, 1, 2, 3], uniq: true, do: x * 2
[2, 4, 6]

iex&gt; for &lt;&lt;x &lt;- "abcabc"&gt;&gt;, uniq: true, into: "", do: &lt;&lt;x - 32&gt;&gt;
"ABC"</pre>
<h4 id="for/1-the-reduce-option" class="section-heading">  <span class="text">The <code class="inline">:reduce</code> option</span> </h4> <p><em>Available since Elixir v1.8</em>.</p>
<p>While the <code class="inline">:into</code> option allows us to customize the comprehension behavior to a given data type, such as putting all of the values inside a map or inside a binary, it is not always enough.</p>
<p>For example, imagine that you have a binary with letters where you want to count how many times each lowercase letter happens, ignoring all uppercase ones. For instance, for the string <code class="inline">"AbCabCABc"</code>, we want to return the map <code class="inline">%{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 1}</code>.</p>
<p>If we were to use <code class="inline">:into</code>, we would need a data type that computes the frequency of each element it holds. While there is no such data type in Elixir, you could implement one yourself.</p>
<p>A simpler option would be to use comprehensions for the mapping and filtering of letters, and then we invoke <a href="enum.html#reduce/3"><code class="inline">Enum.reduce/3</code></a> to build a map, for example:</p>
<pre data-language="elixir">iex&gt; letters = for &lt;&lt;x &lt;- "AbCabCABc"&gt;&gt;, x in ?a..?z, do: &lt;&lt;x&gt;&gt;
iex&gt; Enum.reduce(letters, %{}, fn x, acc -&gt; Map.update(acc, x, 1, &amp; &amp;1 + 1) end)
%{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 1}</pre>
<p>While the above is straight-forward, it has the downside of traversing the data at least twice. If you are expecting long strings as inputs, this can be quite expensive.</p>
<p>Luckily, comprehensions also support the <code class="inline">:reduce</code> option, which would allow us to fuse both steps above into a single step:</p>
<pre data-language="elixir">iex&gt; for &lt;&lt;x &lt;- "AbCabCABc"&gt;&gt;, x in ?a..?z, reduce: %{} do
...&gt;   acc -&gt; Map.update(acc, &lt;&lt;x&gt;&gt;, 1, &amp; &amp;1 + 1)
...&gt; end
%{"a" =&gt; 1, "b" =&gt; 2, "c" =&gt; 1}</pre>
<p>When the <code class="inline">:reduce</code> key is given, its value is used as the initial accumulator and the <code class="inline">do</code> block must be changed to use <code class="inline">-&gt;</code> clauses, where the left side of <code class="inline">-&gt;</code> receives the accumulated value of the previous iteration and the expression on the right side must return the new accumulator value. Once there are no more elements, the final accumulated value is returned. If there are no elements at all, then the initial accumulator value is returned.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="import/2">import(module, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L687" class="source">Source</a>
</h3> <section class="docstring"> <p>Imports functions and macros from other modules.</p>
<p><a href="#import/2"><code class="inline">import/2</code></a> allows one to easily access functions or macros from other modules without using the qualified name.</p>
<h4 id="import/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>If you are using several functions from a given module, you can import those functions and reference them as local functions, for example:</p>
<pre data-language="elixir">iex&gt; import List
iex&gt; flatten([1, [2], 3])
[1, 2, 3]</pre>
<h4 id="import/2-selector" class="section-heading">  <span class="text">Selector</span> </h4> <p>By default, Elixir imports functions and macros from the given module, except the ones starting with an underscore (which are usually callbacks):</p>
<pre data-language="elixir">import List</pre>
<p>A developer can filter to import only functions, macros, or sigils (which can be functions or macros) via the <code class="inline">:only</code> option:</p>
<pre data-language="elixir">import List, only: :functions
import List, only: :macros
import Kernel, only: :sigils</pre>
<p>Alternatively, Elixir allows a developer to pass pairs of name/arities to <code class="inline">:only</code> or <code class="inline">:except</code> as a fine grained control on what to import (or not):</p>
<pre data-language="elixir">import List, only: [flatten: 1]
import String, except: [split: 2]</pre>
<p>Importing the same module again will erase the previous imports, except when the <code class="inline">except</code> option is used, which is always exclusive on a previously declared <a href="#import/2"><code class="inline">import/2</code></a>. If there is no previous import, then it applies to all functions and macros in the module. For example:</p>
<pre data-language="elixir">import List, only: [flatten: 1, keyfind: 4]
import List, except: [flatten: 1]</pre>
<p>After the two import calls above, only <a href="list.html#keyfind/4"><code class="inline">List.keyfind/4</code></a> will be imported.</p>
<h4 id="import/2-underscore-functions" class="section-heading">  <span class="text">Underscore functions</span> </h4> <p>By default functions starting with <code class="inline">_</code> are not imported. If you really want to import a function starting with <code class="inline">_</code> you must explicitly include it in the <code class="inline">:only</code> selector.</p>
<pre data-language="elixir">import File.Stream, only: [__build__: 3]</pre>
<h4 id="import/2-lexical-scope" class="section-heading">  <span class="text">Lexical scope</span> </h4> <p>It is important to note that <a href="#import/2"><code class="inline">import/2</code></a> is lexical. This means you can import specific macros inside specific functions:</p>
<pre data-language="elixir">defmodule Math do
  def some_function do
    # 1) Disable "if/2" from Kernel
    import Kernel, except: [if: 2]

    # 2) Require the new "if/2" macro from MyMacros
    import MyMacros

    # 3) Use the new macro
    if do_something, it_works
  end
end</pre>
<p>In the example above, we imported macros from <code class="inline">MyMacros</code>, replacing the original <a href="kernel.html#if/2"><code class="inline">if/2</code></a> implementation by our own within that specific function. All other functions in that module will still be able to use the original one.</p>
<h4 id="import/2-warnings" class="section-heading">  <span class="text">Warnings</span> </h4> <p>If you import a module and you don't use any of the imported functions or macros from this module, Elixir is going to issue a warning implying the import is not being used.</p>
<p>In case the import is generated automatically by a macro, Elixir won't emit any warnings though, since the import was not explicitly defined.</p>
<p>Both warning behaviors could be changed by explicitly setting the <code class="inline">:warn</code> option to <code class="inline">true</code> or <code class="inline">false</code>.</p>
<h4 id="import/2-ambiguous-function-macro-names" class="section-heading">  <span class="text">Ambiguous function/macro names</span> </h4> <p>If two modules <code class="inline">A</code> and <code class="inline">B</code> are imported and they both contain a <code class="inline">foo</code> function with an arity of <code class="inline">1</code>, an error is only emitted if an ambiguous call to <code class="inline">foo/1</code> is actually made; that is, the errors are emitted lazily, not eagerly.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="quote/2">quote(opts, block)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1312" class="source">Source</a>
</h3> <section class="docstring"> <p>Gets the representation of any expression.</p>
<h4 id="quote/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; quote do
...&gt;   sum(1, 2, 3)
...&gt; end
{:sum, [], [1, 2, 3]}</pre>
<h4 id="quote/2-elixir-s-ast-abstract-syntax-tree" class="section-heading">  <span class="text">Elixir's AST (Abstract Syntax Tree)</span> </h4> <p>Any Elixir code can be represented using Elixir data structures. The building block of Elixir macros is a tuple with three elements, for example:</p>
<pre data-language="elixir">{:sum, [], [1, 2, 3]}</pre>
<p>The tuple above represents a function call to <code class="inline">sum</code> passing 1, 2 and 3 as arguments. The tuple elements are:</p>
<ul>
<li><p>The first element of the tuple is always an atom or another tuple in the same representation.</p></li>
<li><p>The second element of the tuple represents <a href="macro.html#t:metadata/0">metadata</a>.</p></li>
<li><p>The third element of the tuple are the arguments for the function call. The third argument may be an atom, which is usually a variable (or a local call).</p></li>
</ul>
<p>Besides the tuple described above, Elixir has a few literals that are also part of its AST. Those literals return themselves when quoted. They are:</p>
<pre data-language="elixir">:sum         #=&gt; Atoms
1            #=&gt; Integers
2.0          #=&gt; Floats
[1, 2]       #=&gt; Lists
"strings"    #=&gt; Strings
{key, value} #=&gt; Tuples with two elements</pre>
<p>Any other value, such as a map or a four-element tuple, must be escaped (<a href="macro.html#escape/1"><code class="inline">Macro.escape/1</code></a>) before being introduced into an AST.</p>
<h4 id="quote/2-options" class="section-heading">  <span class="text">Options</span> </h4> <ul>
<li><p><code class="inline">:bind_quoted</code> - passes a binding to the macro. Whenever a binding is given, <a href="#unquote/1"><code class="inline">unquote/1</code></a> is automatically disabled.</p></li>
<li><p><code class="inline">:context</code> - sets the resolution context.</p></li>
<li><p><code class="inline">:generated</code> - marks the given chunk as generated so it does not emit warnings. It is also useful to avoid dialyzer reporting errors when macros generate unused clauses.</p></li>
<li><p><code class="inline">:file</code> - sets the quoted expressions to have the given file.</p></li>
<li><p><code class="inline">:line</code> - sets the quoted expressions to have the given line.</p></li>
<li><p><code class="inline">:location</code> - when set to <code class="inline">:keep</code>, keeps the current line and file from quote. Read the "Stacktrace information" section below for more information.</p></li>
<li>
<p><code class="inline">:unquote</code> - when <code class="inline">false</code>, disables unquoting. This means any <code class="inline">unquote</code> call will be kept as is in the AST, instead of replaced by the <code class="inline">unquote</code> arguments. For example:</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   unquote("hello")
...&gt; end
"hello"

iex&gt; quote unquote: false do
...&gt;   unquote("hello")
...&gt; end
{:unquote, [], ["hello"]}</pre>
</li>
</ul>
<h4 id="quote/2-quote-and-macros" class="section-heading">  <span class="text">Quote and macros</span> </h4> <p><a href="#quote/2"><code class="inline">quote/2</code></a> is commonly used with macros for code generation. As an exercise, let's define a macro that multiplies a number by itself (squared). In practice, there is no reason to define such a macro (and it would actually be seen as a bad practice), but it is simple enough that it allows us to focus on the important aspects of quotes and macros:</p>
<pre data-language="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      unquote(x) * unquote(x)
    end
  end
end</pre>
<p>We can invoke it as:</p>
<pre data-language="elixir">import Math
IO.puts("Got #{squared(5)}")</pre>
<p>At first, there is nothing in this example that actually reveals it is a macro. But what is happening is that, at compilation time, <code class="inline">squared(5)</code> becomes <code class="inline">5 * 5</code>. The argument <code class="inline">5</code> is duplicated in the produced code, we can see this behavior in practice though because our macro actually has a bug:</p>
<pre data-language="elixir">import Math
my_number = fn -&gt;
  IO.puts("Returning 5")
  5
end
IO.puts("Got #{squared(my_number.())}")</pre>
<p>The example above will print:</p>
<pre data-language="elixir">Returning 5
Returning 5
Got 25</pre>
<p>Notice how "Returning 5" was printed twice, instead of just once. This is because a macro receives an expression and not a value (which is what we would expect in a regular function). This means that:</p>
<pre data-language="elixir">squared(my_number.())</pre>
<p>Actually expands to:</p>
<pre data-language="elixir">my_number.() * my_number.()</pre>
<p>Which invokes the function twice, explaining why we get the printed value twice! In the majority of the cases, this is actually unexpected behavior, and that's why one of the first things you need to keep in mind when it comes to macros is to <strong>not unquote the same value more than once</strong>.</p>
<p>Let's fix our macro:</p>
<pre data-language="elixir">defmodule Math do
  defmacro squared(x) do
    quote do
      x = unquote(x)
      x * x
    end
  end
end</pre>
<p>Now invoking <code class="inline">squared(my_number.())</code> as before will print the value just once.</p>
<p>In fact, this pattern is so common that most of the times you will want to use the <code class="inline">bind_quoted</code> option with <a href="#quote/2"><code class="inline">quote/2</code></a>:</p>
<pre data-language="elixir">defmodule Math do
  defmacro squared(x) do
    quote bind_quoted: [x: x] do
      x * x
    end
  end
end</pre>
<p><code class="inline">:bind_quoted</code> will translate to the same code as the example above. <code class="inline">:bind_quoted</code> can be used in many cases and is seen as good practice, not only because it helps prevent us from running into common mistakes, but also because it allows us to leverage other tools exposed by macros, such as unquote fragments discussed in some sections below.</p>
<p>Before we finish this brief introduction, you will notice that, even though we defined a variable <code class="inline">x</code> inside our quote:</p>
<pre data-language="elixir">quote do
  x = unquote(x)
  x * x
end</pre>
<p>When we call:</p>
<pre data-language="elixir">import Math
squared(5)
x
** (CompileError) undefined variable "x"</pre>
<p>We can see that <code class="inline">x</code> did not leak to the user context. This happens because Elixir macros are hygienic, a topic we will discuss at length in the next sections as well.</p>
<h4 id="quote/2-hygiene-in-variables" class="section-heading">  <span class="text">Hygiene in variables</span> </h4> <p>Consider the following example:</p>
<pre data-language="elixir">defmodule Hygiene do
  defmacro no_interference do
    quote do
      a = 1
    end
  end
end

require Hygiene

a = 10
Hygiene.no_interference()
a
#=&gt; 10</pre>
<p>In the example above, <code class="inline">a</code> returns 10 even if the macro is apparently setting it to 1 because variables defined in the macro do not affect the context the macro is executed in. If you want to set or get a variable in the caller's context, you can do it with the help of the <code class="inline">var!</code> macro:</p>
<pre data-language="elixir">defmodule NoHygiene do
  defmacro interference do
    quote do
      var!(a) = 1
    end
  end
end

require NoHygiene

a = 10
NoHygiene.interference()
a
#=&gt; 1</pre>
<p>You cannot even access variables defined in the same module unless you explicitly give it a context:</p>
<pre data-language="elixir">defmodule Hygiene do
  defmacro write do
    quote do
      a = 1
    end
  end

  defmacro read do
    quote do
      a
    end
  end
end

require Hygiene
Hygiene.write()
Hygiene.read()
** (CompileError) undefined variable "a" (context Hygiene)</pre>
<p>For such, you can explicitly pass the current module scope as argument:</p>
<pre data-language="elixir">defmodule ContextHygiene do
  defmacro write do
    quote do
      var!(a, ContextHygiene) = 1
    end
  end

  defmacro read do
    quote do
      var!(a, ContextHygiene)
    end
  end
end

require Hygiene
ContextHygiene.write()
ContextHygiene.read()
#=&gt; 1</pre>
<p>The contexts of a variable is identified by the third element of the tuple. The default context is <code class="inline">nil</code> and <code class="inline">quote</code> assigns another context to all variables within:</p>
<pre data-language="elixir">quote(do: var)
#=&gt; {:var, [], Elixir}</pre>
<p>In case of variables returned by macros, there may also be a <code class="inline">:counter</code> key in the metadata, which is used to further refine its contexts and guarantee isolation between macro invocations as seen in the previous example.</p>
<h4 id="quote/2-hygiene-in-aliases" class="section-heading">  <span class="text">Hygiene in aliases</span> </h4> <p>Aliases inside quote are hygienic by default. Consider the following example:</p>
<pre data-language="elixir">defmodule Hygiene do
  alias Map, as: M

  defmacro no_interference do
    quote do
      M.new()
    end
  end
end

require Hygiene
Hygiene.no_interference()
#=&gt; %{}</pre>
<p>Note that, even though the alias <code class="inline">M</code> is not available in the context the macro is expanded, the code above works because <code class="inline">M</code> still expands to <a href="map.html"><code class="inline">Map</code></a>.</p>
<p>Similarly, even if we defined an alias with the same name before invoking a macro, it won't affect the macro's result:</p>
<pre data-language="elixir">defmodule Hygiene do
  alias Map, as: M

  defmacro no_interference do
    quote do
      M.new()
    end
  end
end

require Hygiene
alias SomethingElse, as: M
Hygiene.no_interference()
#=&gt; %{}</pre>
<p>In some cases, you want to access an alias or a module defined in the caller. For such, you can use the <code class="inline">alias!</code> macro:</p>
<pre data-language="elixir">defmodule Hygiene do
  # This will expand to Elixir.Nested.hello()
  defmacro no_interference do
    quote do
      Nested.hello()
    end
  end

  # This will expand to Nested.hello() for
  # whatever is Nested in the caller
  defmacro interference do
    quote do
      alias!(Nested).hello()
    end
  end
end

defmodule Parent do
  defmodule Nested do
    def hello, do: "world"
  end

  require Hygiene
  Hygiene.no_interference()
  ** (UndefinedFunctionError) ...

  Hygiene.interference()
  #=&gt; "world"
end</pre>
<h4 id="quote/2-hygiene-in-imports" class="section-heading">  <span class="text">Hygiene in imports</span> </h4> <p>Similar to aliases, imports in Elixir are hygienic. Consider the following code:</p>
<pre data-language="elixir">defmodule Hygiene do
  defmacrop get_length do
    quote do
      length([1, 2, 3])
    end
  end

  def return_length do
    import Kernel, except: [length: 1]
    get_length
  end
end

Hygiene.return_length()
#=&gt; 3</pre>
<p>Notice how <code class="inline">Hygiene.return_length/0</code> returns <code class="inline">3</code> even though the <a href="kernel.html#length/1"><code class="inline">Kernel.length/1</code></a> function is not imported. In fact, even if <code class="inline">return_length/0</code> imported a function with the same name and arity from another module, it wouldn't affect the function result:</p>
<pre data-language="elixir">def return_length do
  import String, only: [length: 1]
  get_length
end</pre>
<p>Calling this new <code class="inline">return_length/0</code> will still return <code class="inline">3</code> as result.</p>
<p>Elixir is smart enough to delay the resolution to the latest possible moment. So, if you call <code class="inline">length([1, 2, 3])</code> inside quote, but no <a href="kernel.html#length/1"><code class="inline">length/1</code></a> function is available, it is then expanded in the caller:</p>
<pre data-language="elixir">defmodule Lazy do
  defmacrop get_length do
    import Kernel, except: [length: 1]

    quote do
      length("hello")
    end
  end

  def return_length do
    import Kernel, except: [length: 1]
    import String, only: [length: 1]
    get_length
  end
end

Lazy.return_length()
#=&gt; 5</pre>
<h4 id="quote/2-stacktrace-information" class="section-heading">  <span class="text">Stacktrace information</span> </h4> <p>When defining functions via macros, developers have the option of choosing if runtime errors will be reported from the caller or from inside the quote. Let's see an example:</p>
<pre data-language="elixir"># adder.ex
defmodule Adder do
  @doc "Defines a function that adds two numbers"
  defmacro defadd do
    quote location: :keep do
      def add(a, b), do: a + b
    end
  end
end

# sample.ex
defmodule Sample do
  import Adder
  defadd
end

require Sample
Sample.add(:one, :two)
** (ArithmeticError) bad argument in arithmetic expression
    adder.ex:5: Sample.add/2</pre>
<p>When using <code class="inline">location: :keep</code> and invalid arguments are given to <code class="inline">Sample.add/2</code>, the stacktrace information will point to the file and line inside the quote. Without <code class="inline">location: :keep</code>, the error is reported to where <code class="inline">defadd</code> was invoked. <code class="inline">location: :keep</code> affects only definitions inside the quote.</p>
<blockquote>
<h4 class="warning">
<code class="inline">location: :keep</code> and unquote</h4>
<p>Do not use <code class="inline">location: :keep</code> if the function definition also <code class="inline">unquote</code>s some of the macro arguments. If you do so, Elixir will store the file definition of the current location but the unquoted arguments may contain line information of the macro caller, leading to erroneous stacktraces.</p>
</blockquote>
<h4 id="quote/2-binding-and-unquote-fragments" class="section-heading">  <span class="text">Binding and unquote fragments</span> </h4> <p>Elixir quote/unquote mechanisms provide a functionality called unquote fragments. Unquote fragments provide an easy way to generate functions on the fly. Consider this example:</p>
<pre data-language="elixir">kv = [foo: 1, bar: 2]
Enum.each(kv, fn {k, v} -&gt;
  def unquote(k)(), do: unquote(v)
end)</pre>
<p>In the example above, we have generated the functions <code class="inline">foo/0</code> and <code class="inline">bar/0</code> dynamically. Now, imagine that we want to convert this functionality into a macro:</p>
<pre data-language="elixir">defmacro defkv(kv) do
  Enum.map(kv, fn {k, v} -&gt;
    quote do
      def unquote(k)(), do: unquote(v)
    end
  end)
end</pre>
<p>We can invoke this macro as:</p>
<pre data-language="elixir">defkv [foo: 1, bar: 2]</pre>
<p>However, we can't invoke it as follows:</p>
<pre data-language="elixir">kv = [foo: 1, bar: 2]
defkv kv</pre>
<p>This is because the macro is expecting its arguments to be a keyword list at <strong>compilation</strong> time. Since in the example above we are passing the representation of the variable <code class="inline">kv</code>, our code fails.</p>
<p>This is actually a common pitfall when developing macros. We are assuming a particular shape in the macro. We can work around it by unquoting the variable inside the quoted expression:</p>
<pre data-language="elixir">defmacro defkv(kv) do
  quote do
    Enum.each(unquote(kv), fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end)
  end
end</pre>
<p>If you try to run our new macro, you will notice it won't even compile, complaining that the variables <code class="inline">k</code> and <code class="inline">v</code> do not exist. This is because of the ambiguity: <code class="inline">unquote(k)</code> can either be an unquote fragment, as previously, or a regular unquote as in <code class="inline">unquote(kv)</code>.</p>
<p>One solution to this problem is to disable unquoting in the macro, however, doing that would make it impossible to inject the <code class="inline">kv</code> representation into the tree. That's when the <code class="inline">:bind_quoted</code> option comes to the rescue (again!). By using <code class="inline">:bind_quoted</code>, we can automatically disable unquoting while still injecting the desired variables into the tree:</p>
<pre data-language="elixir">defmacro defkv(kv) do
  quote bind_quoted: [kv: kv] do
    Enum.each(kv, fn {k, v} -&gt;
      def unquote(k)(), do: unquote(v)
    end)
  end
end</pre>
<p>In fact, the <code class="inline">:bind_quoted</code> option is recommended every time one desires to inject a value into the quote.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="receive/1">receive(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L2381" class="source">Source</a>
</h3> <section class="docstring"> <p>Checks if there is a message matching any of the given clauses in the current process mailbox.</p>
<p>If there is no matching message, the current process waits until a matching message arrives or until after a given timeout value.</p>
<p>Any new and existing messages that do not match will remain in the mailbox.</p>
<h4 id="receive/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">receive do
  {:selector, number, name} when is_integer(number) -&gt;
    name
  name when is_atom(name) -&gt;
    name
  _ -&gt;
    IO.puts(:stderr, "Unexpected message received")
end</pre>
<p>An optional <code class="inline">after</code> clause can be given in case no matching message is received during the given timeout period, specified in milliseconds:</p>
<pre data-language="elixir">receive do
  {:selector, number, name} when is_integer(number) -&gt;
    name
  name when is_atom(name) -&gt;
    name
  _ -&gt;
    IO.puts(:stderr, "Unexpected message received")
after
  5000 -&gt;
    IO.puts(:stderr, "No message in 5 seconds")
end</pre>
<p>The <code class="inline">after</code> clause can be specified even if there are no match clauses. The timeout value given to <code class="inline">after</code> can be any expression evaluating to one of the allowed values:</p>
<ul>
<li><p><code class="inline">:infinity</code> - the process should wait indefinitely for a matching message, this is the same as not using the after clause</p></li>
<li><p><code class="inline">0</code> - if there is no matching message in the mailbox, the timeout will occur immediately</p></li>
<li><p>positive integer smaller than or equal to <code class="inline">4_294_967_295</code> (<code class="inline">0xFFFFFFFF</code> in hexadecimal notation) - it should be possible to represent the timeout value as an unsigned 32-bit integer.</p></li>
</ul>
<h4 id="receive/1-variable-handling" class="section-heading">  <span class="text">Variable handling</span> </h4> <p>The <a href="#receive/1"><code class="inline">receive/1</code></a> special form handles variables exactly as the <a href="#case/2"><code class="inline">case/2</code></a> special macro. For more information, check the docs for <a href="#case/2"><code class="inline">case/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="require/2">require(module, opts)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L584" class="source">Source</a>
</h3> <section class="docstring"> <p>Requires a module in order to use its macros.</p>
<h4 id="require/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Public functions in modules are globally available, but in order to use macros, you need to opt-in by requiring the module they are defined in.</p>
<p>Let's suppose you created your own <a href="kernel.html#if/2"><code class="inline">if/2</code></a> implementation in the module <code class="inline">MyMacros</code>. If you want to invoke it, you need to first explicitly require the <code class="inline">MyMacros</code>:</p>
<pre data-language="elixir">defmodule Math do
  require MyMacros
  MyMacros.if do_something, it_works
end</pre>
<p>An attempt to call a macro that was not loaded will raise an error.</p>
<h4 id="require/2-alias-shortcut" class="section-heading">  <span class="text">Alias shortcut</span> </h4> <p><a href="#require/2"><code class="inline">require/2</code></a> also accepts <code class="inline">:as</code> as an option so it automatically sets up an alias. Please check <a href="#alias/2"><code class="inline">alias/2</code></a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="super/1">super(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1885" class="source">Source</a>
</h3> <section class="docstring"> <p>Calls the overridden function when overriding it with <a href="kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a>.</p>
<p>See <a href="kernel.html#defoverridable/1"><code class="inline">Kernel.defoverridable/1</code></a> for more information and documentation.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="try/1">try(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L2325" class="source">Source</a>
</h3> <section class="docstring"> <p>Evaluates the given expressions and handles any error, exit, or throw that may have happened.</p>
<h4 id="try/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">try do
  do_something_that_may_fail(some_arg)
rescue
  ArgumentError -&gt;
    IO.puts("Invalid argument given")
catch
  value -&gt;
    IO.puts("Caught #{inspect(value)}")
else
  value -&gt;
    IO.puts("Success! The result was #{inspect(value)}")
after
  IO.puts("This is printed regardless if it failed or succeeded")
end</pre>
<p>The <code class="inline">rescue</code> clause is used to handle exceptions while the <code class="inline">catch</code> clause can be used to catch thrown values and exits. The <code class="inline">else</code> clause can be used to control flow based on the result of the expression. <code class="inline">catch</code>, <code class="inline">rescue</code>, and <code class="inline">else</code> clauses work based on pattern matching (similar to the <code class="inline">case</code> special form).</p>
<p>Calls inside <a href="#try/1"><code class="inline">try/1</code></a> are not tail recursive since the VM needs to keep the stacktrace in case an exception happens. To retrieve the stacktrace, access <a href="#__STACKTRACE__/0"><code class="inline">__STACKTRACE__/0</code></a> inside the <code class="inline">rescue</code> or <code class="inline">catch</code> clause.</p>
<h4 id="try/1-rescue-clauses" class="section-heading">  <span class="text"><code class="inline">rescue</code> clauses</span> </h4> <p>Besides relying on pattern matching, <code class="inline">rescue</code> clauses provide some conveniences around exceptions that allow one to rescue an exception by its name. All the following formats are valid patterns in <code class="inline">rescue</code> clauses:</p>
<pre data-language="elixir"># Rescue a single exception without binding the exception
# to a variable
try do
  UndefinedModule.undefined_function
rescue
  UndefinedFunctionError -&gt; nil
end

# Rescue any of the given exception without binding
try do
  UndefinedModule.undefined_function
rescue
  [UndefinedFunctionError, ArgumentError] -&gt; nil
end

# Rescue and bind the exception to the variable "x"
try do
  UndefinedModule.undefined_function
rescue
  x in [UndefinedFunctionError] -&gt; nil
end

# Rescue all kinds of exceptions and bind the rescued exception
# to the variable "x"
try do
  UndefinedModule.undefined_function
rescue
  x -&gt; nil
end</pre>
<h3 id="try/1-erlang-errors" class="section-heading">  <span class="text">Erlang errors</span> </h3> <p>Erlang errors are transformed into Elixir ones when rescuing:</p>
<pre data-language="elixir">try do
  :erlang.error(:badarg)
rescue
  ArgumentError -&gt; :ok
end
#=&gt; :ok</pre>
<p>The most common Erlang errors will be transformed into their Elixir counterpart. Those which are not will be transformed into the more generic <a href="erlangerror.html"><code class="inline">ErlangError</code></a>:</p>
<pre data-language="elixir">try do
  :erlang.error(:unknown)
rescue
  ErlangError -&gt; :ok
end
#=&gt; :ok</pre>
<p>In fact, <a href="erlangerror.html"><code class="inline">ErlangError</code></a> can be used to rescue any error that is not a proper Elixir error. For example, it can be used to rescue the earlier <code class="inline">:badarg</code> error too, prior to transformation:</p>
<pre data-language="elixir">try do
  :erlang.error(:badarg)
rescue
  ErlangError -&gt; :ok
end
#=&gt; :ok</pre>
<h4 id="try/1-catch-clauses" class="section-heading">  <span class="text"><code class="inline">catch</code> clauses</span> </h4> <p>The <code class="inline">catch</code> clause can be used to catch thrown values, exits, and errors.</p>
<h3 id="try/1-catching-thrown-values" class="section-heading">  <span class="text">Catching thrown values</span> </h3> <p><code class="inline">catch</code> can be used to catch values thrown by <a href="kernel.html#throw/1"><code class="inline">Kernel.throw/1</code></a>:</p>
<pre data-language="elixir">try do
  throw(:some_value)
catch
  thrown_value -&gt;
    IO.puts("A value was thrown: #{inspect(thrown_value)}")
end</pre>
<h3 id="try/1-catching-values-of-any-kind" class="section-heading">  <span class="text">Catching values of any kind</span> </h3> <p>The <code class="inline">catch</code> clause also supports catching exits and errors. To do that, it allows matching on both the <em>kind</em> of the caught value as well as the value itself:</p>
<pre data-language="elixir">try do
  exit(:shutdown)
catch
  :exit, value -&gt;
    IO.puts("Exited with value #{inspect(value)}")
end

try do
  exit(:shutdown)
catch
  kind, value when kind in [:exit, :throw] -&gt;
    IO.puts("Caught exit or throw with value #{inspect(value)}")
end</pre>
<p>The <code class="inline">catch</code> clause also supports <code class="inline">:error</code> alongside <code class="inline">:exit</code> and <code class="inline">:throw</code> as in Erlang, although this is commonly avoided in favor of <code class="inline">raise</code>/<code class="inline">rescue</code> control mechanisms. One reason for this is that when catching <code class="inline">:error</code>, the error is not automatically transformed into an Elixir error:</p>
<pre data-language="elixir">try do
  :erlang.error(:badarg)
catch
  :error, :badarg -&gt; :ok
end
#=&gt; :ok</pre>
<h4 id="try/1-after-clauses" class="section-heading">  <span class="text"><code class="inline">after</code> clauses</span> </h4> <p>An <code class="inline">after</code> clause allows you to define cleanup logic that will be invoked both when the block of code passed to <a href="#try/1"><code class="inline">try/1</code></a> succeeds and also when an error is raised. Note that the process will exit as usual when receiving an exit signal that causes it to exit abruptly and so the <code class="inline">after</code> clause is not guaranteed to be executed. Luckily, most resources in Elixir (such as open files, ETS tables, ports, sockets, and so on) are linked to or monitor the owning process and will automatically clean themselves up if that process exits.</p>
<pre data-language="elixir">File.write!("tmp/story.txt", "Hello, World")
try do
  do_something_with("tmp/story.txt")
after
  File.rm("tmp/story.txt")
end</pre>
<p>Although <code class="inline">after</code> clauses are invoked whether or not there was an error, they do not modify the return value. All of the following examples return <code class="inline">:return_me</code>:</p>
<pre data-language="elixir">try do
  :return_me
after
  IO.puts("I will be printed")
  :not_returned
end

try do
  raise "boom"
rescue
  _ -&gt; :return_me
after
  IO.puts("I will be printed")
  :not_returned
end</pre>
<h4 id="try/1-else-clauses" class="section-heading">  <span class="text"><code class="inline">else</code> clauses</span> </h4> <p><code class="inline">else</code> clauses allow the result of the body passed to <a href="#try/1"><code class="inline">try/1</code></a> to be pattern matched on:</p>
<pre data-language="elixir">x = 2
try do
  1 / x
rescue
  ArithmeticError -&gt;
    :infinity
else
  y when y &lt; 1 and y &gt; -1 -&gt;
    :small
  _ -&gt;
    :large
end</pre>
<p>If an <code class="inline">else</code> clause is not present and no exceptions are raised, the result of the expression will be returned:</p>
<pre data-language="elixir">x = 1
^x =
  try do
    1 / x
  rescue
    ArithmeticError -&gt;
      :infinity
  end</pre>
<p>However, when an <code class="inline">else</code> clause is present but the result of the expression does not match any of the patterns then an exception will be raised. This exception will not be caught by a <code class="inline">catch</code> or <code class="inline">rescue</code> in the same <code class="inline">try</code>:</p>
<pre data-language="elixir">x = 1
try do
  try do
    1 / x
  rescue
    # The TryClauseError cannot be rescued here:
    TryClauseError -&gt;
      :error_a
  else
    0 -&gt;
      :small
  end
rescue
  # The TryClauseError is rescued here:
  TryClauseError -&gt;
    :error_b
end</pre>
<p>Similarly, an exception inside an <code class="inline">else</code> clause is not caught or rescued inside the same <code class="inline">try</code>:</p>
<pre data-language="elixir">try do
  try do
    nil
  catch
    # The exit(1) call below can not be caught here:
    :exit, _ -&gt;
      :exit_a
  else
    _ -&gt;
      exit(1)
  end
catch
  # The exit is caught here:
  :exit, _ -&gt;
    :exit_b
end</pre>
<p>This means the VM no longer needs to keep the stacktrace once inside an <code class="inline">else</code> clause and so tail recursion is possible when using a <code class="inline">try</code> with a tail call as the final call inside an <code class="inline">else</code> clause. The same is true for <code class="inline">rescue</code> and <code class="inline">catch</code> clauses.</p>
<p>Only the result of the tried expression falls down to the <code class="inline">else</code> clause. If the <code class="inline">try</code> ends up in the <code class="inline">rescue</code> or <code class="inline">catch</code> clauses, their result will not fall down to <code class="inline">else</code>:</p>
<pre data-language="elixir">try do
  throw(:catch_this)
catch
  :throw, :catch_this -&gt;
    :it_was_caught
else
  # :it_was_caught will not fall down to this "else" clause.
  other -&gt;
    {:else, other}
end</pre>
<h4 id="try/1-variable-handling" class="section-heading">  <span class="text">Variable handling</span> </h4> <p>Since an expression inside <code class="inline">try</code> may not have been evaluated due to an exception, any variable created inside <code class="inline">try</code> cannot be accessed externally. For instance:</p>
<pre data-language="elixir">try do
  x = 1
  do_something_that_may_fail(same_arg)
  :ok
catch
  _, _ -&gt; :failed
end

x
#=&gt; unbound variable "x"</pre>
<p>In the example above, <code class="inline">x</code> cannot be accessed since it was defined inside the <code class="inline">try</code> clause. A common practice to address this issue is to return the variables defined inside <code class="inline">try</code>:</p>
<pre data-language="elixir">x =
  try do
    x = 1
    do_something_that_may_fail(same_arg)
    x
  catch
    _, _ -&gt; :failed
  end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="unquote/1">unquote(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1366" class="source">Source</a>
</h3> <section class="docstring"> <p>Unquotes the given expression inside a quoted expression.</p>
<p>This function expects a valid Elixir AST, also known as quoted expression, as argument. If you would like to <code class="inline">unquote</code> any value, such as a map or a four-element tuple, you should call <a href="macro.html#escape/1"><code class="inline">Macro.escape/1</code></a> before unquoting.</p>
<h4 id="unquote/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine the situation you have a quoted expression and you want to inject it inside some quote. The first attempt would be:</p>
<pre data-language="elixir">value =
  quote do
    13
  end

quote do
  sum(1, value, 3)
end</pre>
<p>Which the argument for the <code class="inline">:sum</code> function call is not the expected result:</p>
<pre data-language="elixir">{:sum, [], [1, {:value, [], Elixir}, 3]}</pre>
<p>For this, we use <code class="inline">unquote</code>:</p>
<pre data-language="elixir">iex&gt; value =
...&gt;   quote do
...&gt;     13
...&gt;   end
iex&gt; quote do
...&gt;   sum(1, unquote(value), 3)
...&gt; end
{:sum, [], [1, 13, 3]}</pre>
<p>If you want to unquote a value that is not a quoted expression, such as a map, you need to call <a href="macro.html#escape/1"><code class="inline">Macro.escape/1</code></a> before:</p>
<pre data-language="elixir">iex&gt; value = %{foo: :bar}
iex&gt; quote do
...&gt;   process_map(unquote(Macro.escape(value)))
...&gt; end
{:process_map, [], [{:%{}, [], [foo: :bar]}]}</pre>
<p>If you forget to escape it, Elixir will raise an error when compiling the code.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="unquote_splicing/1">unquote_splicing(expr)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1382" class="source">Source</a>
</h3> <section class="docstring"> <p>Unquotes the given list expanding its arguments.</p>
<p>Similar to <a href="#unquote/1"><code class="inline">unquote/1</code></a>.</p>
<h4 id="unquote_splicing/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; values = [2, 3, 4]
iex&gt; quote do
...&gt;   sum(1, unquote_splicing(values), 5)
...&gt; end
{:sum, [], [1, 2, 3, 4, 5]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="with/1">with(args)<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L1716" class="source">Source</a>
</h3> <section class="docstring"> <p>Combine matching clauses.</p>
<p>One of the ways to understand with is to show which code patterns it improves. Imagine you have a map where the fields <code class="inline">width</code> and <code class="inline">height</code> are optional and you want to compute its area, as <code class="inline">{:ok, area}</code> or return <code class="inline">:error</code>. We could implement this function as:</p>
<pre data-language="elixir">def area(opts) do
  case Map.fetch(opts, :width) do
    {:ok, width} -&gt;
      case Map.fetch(opts, :height) do
        {:ok, height} -&gt; {:ok, width * height}
        :error -&gt; :error
      end

    :error -&gt;
      :error
  end
end</pre>
<p>when called as <code class="inline">area(%{width: 10, height: 15})</code>, it should return <code class="inline">{:ok, 150}</code>. If any of the fields are missing, it returns <code class="inline">:error</code>.</p>
<p>While the code above works, it is quite verbose. Using <code class="inline">with</code>, we could rewrite it as:</p>
<pre data-language="elixir">def area(opts) do
  with {:ok, width} &lt;- Map.fetch(opts, :width),
       {:ok, height} &lt;- Map.fetch(opts, :height) do
    {:ok, width * height}
  end
end</pre>
<p>Instead of defining nested <code class="inline">case</code>s with clauses, we use <code class="inline">with</code> alongside the <code class="inline">PATTERN &lt;- EXPRESSION</code> operator to match expressions on its right side against the pattern on the left. Consider <code class="inline">&lt;-</code> as a sibling to <code class="inline">=</code>, except that, while <code class="inline">=</code> raises in case of not matches, <code class="inline">&lt;-</code> will simply abort the <code class="inline">with</code> chain and return the non-matched value.</p>
<p>Let's give it a try on IEx:</p>
<pre data-language="elixir">iex&gt; opts = %{width: 10, height: 15}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do
...&gt;   {:ok, width * height}
...&gt; end
{:ok, 150}</pre>
<p>If all clauses match, the <code class="inline">do</code> block is executed, returning its result. Otherwise the chain is aborted and the non-matched value is returned:</p>
<pre data-language="elixir">iex&gt; opts = %{width: 10}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do
...&gt;   {:ok, width * height}
...&gt; end
:error</pre>
<p>Guards can be used in patterns as well:</p>
<pre data-language="elixir">iex&gt; users = %{"melany" =&gt; "guest", "bob" =&gt; :admin}
iex&gt; with {:ok, role} when not is_binary(role) &lt;- Map.fetch(users, "bob") do
...&gt;   {:ok, to_string(role)}
...&gt; end
{:ok, "admin"}</pre>
<p>As in <a href="#for/1"><code class="inline">for/1</code></a>, variables bound inside <a href="#with/1"><code class="inline">with/1</code></a> won't be accessible outside of <a href="#with/1"><code class="inline">with/1</code></a>.</p>
<p>Expressions without <code class="inline">&lt;-</code> may also be used in clauses. For instance, you can perform regular matches with the <code class="inline">=</code> operator:</p>
<pre data-language="elixir">iex&gt; width = nil
iex&gt; opts = %{width: 10, height: 15}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      double_width = width * 2,
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do
...&gt;   {:ok, double_width * height}
...&gt; end
{:ok, 300}
iex&gt; width
nil</pre>
<p>The behavior of any expression in a clause is the same as if it was written outside of <code class="inline">with</code>. For example, <code class="inline">=</code> will raise a <a href="matcherror.html"><code class="inline">MatchError</code></a> instead of returning the non-matched value:</p>
<pre data-language="elixir">with :foo = :bar, do: :ok
** (MatchError) no match of right hand side value: :bar</pre>
<p>As with any other function or macro call in Elixir, explicit parens can also be used around the arguments before the <code class="inline">do</code>-<code class="inline">end</code> block:</p>
<pre data-language="elixir">iex&gt; opts = %{width: 10, height: 15}
iex&gt; with(
...&gt;   {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;   {:ok, height} &lt;- Map.fetch(opts, :height)
...&gt; ) do
...&gt;   {:ok, width * height}
...&gt; end
{:ok, 150}</pre>
<p>The choice between parens and no parens is a matter of preference.</p>
<h4 id="with/1-else-clauses" class="section-heading">  <span class="text">Else clauses</span> </h4> <p>An <code class="inline">else</code> option can be given to modify what is being returned from <code class="inline">with</code> in the case of a failed match:</p>
<pre data-language="elixir">iex&gt; opts = %{width: 10}
iex&gt; with {:ok, width} &lt;- Map.fetch(opts, :width),
...&gt;      {:ok, height} &lt;- Map.fetch(opts, :height) do
...&gt;   {:ok, width * height}
...&gt; else
...&gt;   :error -&gt;
...&gt;     {:error, :wrong_data}
...&gt;
...&gt;   _other_error -&gt;
...&gt;     :unexpected_error
...&gt; end
{:error, :wrong_data}</pre>
<p>The <code class="inline">else</code> block works like a <code class="inline">case</code> clause: it can have multiple clauses, and the first match will be used. Variables bound inside <code class="inline">with</code> (such as <code class="inline">width</code> in this example) are not available in the <code class="inline">else</code> block.</p>
<p>If an <code class="inline">else</code> block is used and there are no matching clauses, a <a href="withclauseerror.html"><code class="inline">WithClauseError</code></a> exception is raised.</p>
<h3 id="with/1-beware" class="section-heading">  <span class="text">Beware!</span> </h3> <p>Keep in mind that, one of potential drawback of <code class="inline">with</code> is that all failure clauses are flattened into a single <code class="inline">else</code> block. For example, take this code that checks if a given path points to an Elixir file and that it exists before creating a backup copy:</p>
<pre data-language="elixir">with ".ex" &lt;- Path.extname(path),
     true &lt;- File.exists?(path) do
  backup_path = path &lt;&gt; ".backup"
  File.cp!(path, backup_path)
  {:ok, backup_path}
else
  binary when is_binary(binary) -&gt;
    {:error, :invalid_extension}

  false -&gt;
    {:error, :missing_file}
end</pre>
<p>Note how we are having to reconstruct the result types of <a href="path.html#extname/1"><code class="inline">Path.extname/1</code></a> and <a href="file.html#exists?/1"><code class="inline">File.exists?/1</code></a> to build error messages. In this case, it is better to refactor the code so each <code class="inline">&lt;-</code> already return the desired format in case of errors, like this:</p>
<pre data-language="elixir">with :ok &lt;- validate_extension(path),
     :ok &lt;- validate_exists(path) do
  backup_path = path &lt;&gt; ".backup"
  File.cp!(path, backup_path)
  {:ok, backup_path}
end

defp validate_extension(path) do
  if Path.extname(path) == ".ex", do: :ok, else: {:error, :invalid_extension}
end

defp validate_exists(path) do
  if File.exists?(path), do: :ok, else: {:error, :missing_file}
end</pre>
<p>Note how the code above is better organized and clearer once we make sure each <code class="inline">&lt;-</code> in <code class="inline">with</code> returns a normalized format.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="%5E/1">^var<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L763" class="source">Source</a>
</h3> <section class="docstring"> <p>Pin operator. Accesses an already bound variable in match clauses.</p>
<h4 id="%5E/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Elixir allows variables to be rebound via static single assignment:</p>
<pre data-language="elixir">iex&gt; x = 1
iex&gt; x = x + 1
iex&gt; x
2</pre>
<p>However, in some situations, it is useful to match against an existing value, instead of rebinding. This can be done with the <code class="inline">^</code> special form, colloquially known as the pin operator:</p>
<pre data-language="elixir">iex&gt; x = 1
iex&gt; ^x = List.first([1])
iex&gt; ^x = List.first([2])
** (MatchError) no match of right hand side value: 2</pre>
<p>Note that <code class="inline">^x</code> always refers to the value of <code class="inline">x</code> prior to the match. The following example will match:</p>
<pre data-language="elixir">iex&gt; x = 0
iex&gt; {x, ^x} = {1, 0}
iex&gt; x
1</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="%7B%7D/1">{args}<a href="https://github.com/elixir-lang/elixir/blob/v1.17.2/lib/elixir/lib/kernel/special_forms.ex#L62" class="source">Source</a>
</h3> <section class="docstring"> <p>Creates a tuple.</p>
<p>More information about the tuple data type and about functions to manipulate tuples can be found in the <a href="tuple.html"><code class="inline">Tuple</code></a> module; some functions for working with tuples are also available in <a href="kernel.html"><code class="inline">Kernel</code></a> (such as <a href="kernel.html#elem/2"><code class="inline">Kernel.elem/2</code></a> or <a href="kernel.html#tuple_size/1"><code class="inline">Kernel.tuple_size/1</code></a>).</p>
<h4 id="%7B%7D/1-ast-representation" class="section-heading">  <span class="text">AST representation</span> </h4> <p>Only two-element tuples are considered literals in Elixir and return themselves when quoted. Therefore, all other tuples are represented in the AST as calls to the <code class="inline">:{}</code> special form.</p>
<pre data-language="elixir">iex&gt; quote do
...&gt;   {1, 2}
...&gt; end
{1, 2}

iex&gt; quote do
...&gt;   {1, 2, 3}
...&gt; end
{:{}, [], [1, 2, 3]}</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.34.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.17.2/Kernel.SpecialForms.html" class="_attribution-link">https://hexdocs.pm/elixir/1.17.2/Kernel.SpecialForms.html</a>
  </p>
</div>
