<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Path</span>  </h1> <section id="moduledoc"> <p>This module provides conveniences for manipulating or retrieving file system paths.</p>
<p>The functions in this module may receive chardata as arguments and will always return a string encoded in UTF-8. Chardata is a string or a list of characters and strings, see <a href="io.html#t:chardata/0"><code class="inline">IO.chardata/0</code></a>. If a binary is given, in whatever encoding, its encoding will be kept.</p>
<p>The majority of the functions in this module do not interact with the file system, except for a few functions that require it (like <a href="#wildcard/2"><code class="inline">wildcard/2</code></a> and <a href="#expand/1"><code class="inline">expand/1</code></a>).</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" data-no-tooltip translate="no">t()</a> </dt> <dd class="summary-synopsis"><p>A path.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/1" data-no-tooltip translate="no">absname(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the given path to an absolute one.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#absname/2" data-no-tooltip translate="no">absname(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/1" data-no-tooltip translate="no">basename(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#basename/2" data-no-tooltip translate="no">basename(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#dirname/1" data-no-tooltip translate="no">dirname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the directory component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/1" data-no-tooltip translate="no">expand(path)</a> </dt> <dd class="summary-synopsis"><p>Converts the path to an absolute one, expanding any <code class="inline">.</code> and <code class="inline">..</code> components and a leading <code class="inline">~</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#expand/2" data-no-tooltip translate="no">expand(path, relative_to)</a> </dt> <dd class="summary-synopsis"><p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#extname/1" data-no-tooltip translate="no">extname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the extension of the last component of <code class="inline">path</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/1" data-no-tooltip translate="no">join(list)</a> </dt> <dd class="summary-synopsis"><p>Joins a list of paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#join/2" data-no-tooltip translate="no">join(left, right)</a> </dt> <dd class="summary-synopsis"><p>Joins two paths.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative/1" data-no-tooltip translate="no">relative(name)</a> </dt> <dd class="summary-synopsis"><p>Forces the path to be a relative path.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to/3" data-no-tooltip translate="no">relative_to(path, cwd, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns the direct relative path from <code class="inline">path</code> in relation to <code class="inline">cwd</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#relative_to_cwd/2" data-no-tooltip translate="no">relative_to_cwd(path, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Convenience to get the path relative to the current working directory.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/1" data-no-tooltip translate="no">rootname(path)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#rootname/2" data-no-tooltip translate="no">rootname(path, extension)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#safe_relative/2" data-no-tooltip translate="no">safe_relative(path, cwd \\ File.cwd!())</a> </dt> <dd class="summary-synopsis"><p>Returns a relative path that is protected from directory-traversal attacks.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#safe_relative_to/2" data-no-tooltip translate="no">safe_relative_to(path, cwd)</a> <span class="deprecated" title="Use safe_relative/2 instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Returns a relative path that is protected from directory-traversal attacks.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#split/1" data-no-tooltip translate="no">split(path)</a> </dt> <dd class="summary-synopsis"><p>Splits the path into a list at the path separator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#type/1" data-no-tooltip translate="no">type(name)</a> </dt> <dd class="summary-synopsis"><p>Returns the path type.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#wildcard/2" data-no-tooltip translate="no">wildcard(glob, opts \\ [])</a> </dt> <dd class="summary-synopsis"><p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L19" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: IO.chardata()</pre> </div> <p>A path.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="absname/1">absname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L46" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec absname(t()) :: binary()</pre> </div> <p>Converts the given path to an absolute one.</p>
<p>Unlike <a href="#expand/1"><code class="inline">expand/1</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code>, or <code class="inline">~</code>.</p>
<h4 id="absname/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <h3 id="absname/1-unix-like-operating-systems" class="section-heading">  <span class="text">Unix-like operating systems</span> </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "/usr/local/foo"

Path.absname("../x")
#=&gt; "/usr/local/../x"</pre>
<h3 id="absname/1-windows" class="section-heading">  <span class="text">Windows</span> </h3> <pre data-language="elixir">Path.absname("foo")
#=&gt; "D:/usr/local/foo"

Path.absname("../x")
#=&gt; "D:/usr/local/../x"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="absname/2">absname(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L72" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec absname(t(), t() | (-&gt; t())) :: binary()</pre> </div> <p>Builds a path from <code class="inline">relative_to</code> to <code class="inline">path</code>.</p>
<p>If <code class="inline">path</code> is already an absolute path, <code class="inline">relative_to</code> is ignored. See also <a href="#relative_to/3"><code class="inline">relative_to/3</code></a>. <code class="inline">relative_to</code> is either a path or an anonymous function, which is invoked only when necessary, that returns a path.</p>
<p>Unlike <a href="#expand/2"><code class="inline">expand/2</code></a>, no attempt is made to resolve <code class="inline">..</code>, <code class="inline">.</code> or <code class="inline">~</code>.</p>
<h4 id="absname/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.absname("foo", "bar")
"bar/foo"

iex&gt; Path.absname("../x", "bar")
"bar/../x"

iex&gt; Path.absname("foo", fn -&gt; "lazy" end)
"lazy/foo"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/1">basename(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L506" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec basename(t()) :: binary()</pre> </div> <p>Returns the last component of the path or the path itself if it does not contain any directory separators.</p>
<h4 id="basename/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.basename("foo")
"foo"

iex&gt; Path.basename("foo/bar")
"bar"

iex&gt; Path.basename("lib/module/submodule.ex")
"submodule.ex"

iex&gt; Path.basename("/")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="basename/2">basename(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L530" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec basename(t(), t()) :: binary()</pre> </div> <p>Returns the last component of <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="basename/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.basename("~/foo/bar.ex", ".ex")
"bar"

iex&gt; Path.basename("~/foo/bar.exs", ".ex")
"bar.exs"

iex&gt; Path.basename("~/foo/bar.old.ex", ".ex")
"bar.old"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="dirname/1">dirname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L553" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec dirname(t()) :: binary()</pre> </div> <p>Returns the directory component of <code class="inline">path</code>.</p>
<h4 id="dirname/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.dirname("/foo/bar.ex")
"/foo"

iex&gt; Path.dirname("/foo/bar/baz.ex")
"/foo/bar"

iex&gt; Path.dirname("/foo/bar/")
"/foo/bar"

iex&gt; Path.dirname("bar.ex")
"."</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/1">expand(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L188" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand(t()) :: binary()</pre> </div> <p>Converts the path to an absolute one, expanding any <code class="inline">.</code> and <code class="inline">..</code> components and a leading <code class="inline">~</code>.</p>
<p>If a relative path is provided it is expanded relatively to the current working directory.</p>
<h4 id="expand/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">Path.expand("/foo/bar/../baz")
#=&gt; "/foo/baz"

Path.expand("foo/bar/../baz")
#=&gt; "$PWD/foo/baz"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="expand/2">expand(path, relative_to)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L217" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec expand(t(), t()) :: binary()</pre> </div> <p>Expands the path relative to the path given as the second argument expanding any <code class="inline">.</code> and <code class="inline">..</code> characters.</p>
<p>If the path is already an absolute path, <code class="inline">relative_to</code> is ignored.</p>
<p>Note that this function treats a <code class="inline">path</code> with a leading <code class="inline">~</code> as an absolute one.</p>
<p>The second argument is first expanded to an absolute path.</p>
<h4 id="expand/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir"># Assuming that the absolute path to baz is /quux/baz
Path.expand("foo/bar/../bar", "baz")
#=&gt; "/quux/baz/foo/bar"

Path.expand("foo/bar/../bar", "/baz")
#=&gt; "/baz/foo/bar"

Path.expand("/foo/bar/../bar", "/baz")
#=&gt; "/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="extname/1">extname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L579" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec extname(t()) :: binary()</pre> </div> <p>Returns the extension of the last component of <code class="inline">path</code>.</p>
<p>For filenames starting with a dot and without an extension, it returns an empty string.</p>
<p>See <a href="#basename/1"><code class="inline">basename/1</code></a> and <a href="#rootname/1"><code class="inline">rootname/1</code></a> for related functions to extract information from paths.</p>
<h4 id="extname/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.extname("foo.erl")
".erl"

iex&gt; Path.extname("~/foo/bar")
""

iex&gt; Path.extname(".gitignore")
""</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/1">join(list)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L641" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec join([t(), ...]) :: binary()</pre> </div> <p>Joins a list of paths.</p>
<p>This function should be used to convert a list of paths to a path. Note that any trailing slash is removed when joining.</p>
<p>Raises an error if the given list of paths is empty.</p>
<h4 id="join/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.join(["~", "foo"])
"~/foo"

iex&gt; Path.join(["foo"])
"foo"

iex&gt; Path.join(["/", "foo", "bar/"])
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="join/2">join(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L670" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec join(t(), t()) :: binary()</pre> </div> <p>Joins two paths.</p>
<p>The right path will always be expanded to its relative format and any trailing slash will be removed when joining.</p>
<h4 id="join/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.join("foo", "bar")
"foo/bar"

iex&gt; Path.join("/foo", "/bar/")
"/foo/bar"</pre>
<p>The functions in this module support chardata, so giving a list will treat it as a single entity:</p>
<pre data-language="elixir">iex&gt; Path.join("foo", ["bar", "fiz"])
"foo/barfiz"

iex&gt; Path.join(["foo", "bar"], "fiz")
"foobar/fiz"</pre>
<p>Use <a href="#join/1"><code class="inline">join/1</code></a> if you need to join a list of paths instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="relative/1">relative(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L277" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative(t()) :: binary()</pre> </div> <p>Forces the path to be a relative path.</p>
<p>If an absolute path is given, it is stripped from its root component.</p>
<h4 id="relative/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <h3 id="relative/1-unix-like-operating-systems" class="section-heading">  <span class="text">Unix-like operating systems</span> </h3> <pre data-language="elixir">Path.relative("/usr/local/bin")   #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("../usr/local/bin") #=&gt; "../usr/local/bin"</pre>
<h3 id="relative/1-windows" class="section-heading">  <span class="text">Windows</span> </h3> <pre data-language="elixir">Path.relative("D:/usr/local/bin") #=&gt; "usr/local/bin"
Path.relative("usr/local/bin")    #=&gt; "usr/local/bin"
Path.relative("D:bar.ex")         #=&gt; "bar.ex"
Path.relative("/bar/foo.ex")      #=&gt; "bar/foo.ex"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="relative_to/3">relative_to(path, cwd, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L401" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative_to(t(), t(), keyword()) :: binary()</pre> </div> <p>Returns the direct relative path from <code class="inline">path</code> in relation to <code class="inline">cwd</code>.</p>
<p>In other words, this function attempts to return a path such that <code class="inline">Path.expand(result, cwd)</code> points to <code class="inline">path</code>. This function aims to return a relative path whenever possible, but that's not guaranteed:</p>
<ul>
<li><p>If both paths are relative, a relative path is always returned</p></li>
<li><p>If both paths are absolute, a relative path may be returned if they share a common prefix. You can pass the <code class="inline">:force</code> option to force this function to traverse up, but even then a relative path is not guaranteed (for example, if the absolute paths belong to different drives on Windows)</p></li>
<li><p>If a mixture of paths are given, the result will always match the given <code class="inline">path</code> (the first argument)</p></li>
</ul>
<p>This function expands <code class="inline">.</code> and <code class="inline">..</code> entries without traversing the file system, so it assumes no symlinks between the paths. See <a href="#safe_relative_to/2"><code class="inline">safe_relative_to/2</code></a> for a safer alternative.</p>
<h4 id="relative_to/3-options" class="section-heading">  <span class="text">Options</span> </h4> <ul><li>
<code class="inline">:force</code> - (boolean since v1.16.0) if <code class="inline">true</code> forces a relative path to be returned by traversing the path up. Except if the paths are in different volumes on Windows. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="relative_to/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <h3 id="relative_to/3-with-relative-cwd" class="section-heading">  <span class="text">With relative <code class="inline">cwd</code></span> </h3> <p>If both paths are relative, a minimum path is computed:</p>
<pre data-language="elixir">Path.relative_to("tmp/foo/bar", "tmp")      #=&gt; "foo/bar"
Path.relative_to("tmp/foo/bar", "tmp/foo")  #=&gt; "bar"
Path.relative_to("tmp/foo/bar", "tmp/bat")  #=&gt; "../foo/bar"</pre>
<p>If an absolute path is given with relative <code class="inline">cwd</code>, it is returned as:</p>
<pre data-language="elixir">Path.relative_to("/usr/foo/bar", "tmp/bat")  #=&gt; "/usr/foo/bar"</pre>
<h3 id="relative_to/3-with-absolute-cwd" class="section-heading">  <span class="text">With absolute <code class="inline">cwd</code></span> </h3> <p>If both paths are absolute, a relative is computed if possible, without traversing up:</p>
<pre data-language="elixir">Path.relative_to("/usr/local/foo", "/usr/local")      #=&gt; "foo"
Path.relative_to("/usr/local/foo", "/")               #=&gt; "usr/local/foo"
Path.relative_to("/usr/local/foo", "/etc")            #=&gt; "/usr/local/foo"
Path.relative_to("/usr/local/foo", "/usr/local/foo")  #=&gt; "."
Path.relative_to("/usr/local/../foo", "/usr/foo")     #=&gt; "."
Path.relative_to("/usr/local/../foo/bar", "/usr/foo") #=&gt; "bar"</pre>
<p>If <code class="inline">:force</code> is set to <code class="inline">true</code> paths are traversed up:</p>
<pre data-language="elixir">Path.relative_to("/usr", "/usr/local", force: true)          #=&gt; ".."
Path.relative_to("/usr/foo", "/usr/local", force: true)      #=&gt; "../foo"
Path.relative_to("/usr/../foo/bar", "/etc/foo", force: true) #=&gt; "../../foo/bar"</pre>
<p>If a relative path is given, it is assumed to be relative to the given path, so the path is returned with "." and ".." expanded:</p>
<pre data-language="elixir">Path.relative_to(".", "/usr/local")          #=&gt; "."
Path.relative_to("foo", "/usr/local")        #=&gt; "foo"
Path.relative_to("foo/../bar", "/usr/local") #=&gt; "bar"
Path.relative_to("foo/..", "/usr/local")     #=&gt; "."
Path.relative_to("../foo", "/usr/local")     #=&gt; "../foo"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="relative_to_cwd/2">relative_to_cwd(path, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L479" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec relative_to_cwd(
  t(),
  keyword()
) :: binary()</pre> </div> <p>Convenience to get the path relative to the current working directory.</p>
<p>If, for some reason, the current working directory cannot be retrieved, this function returns the given <code class="inline">path</code>.</p>
<p>Check <a href="#relative_to/3"><code class="inline">relative_to/3</code></a> for the supported options.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/1">rootname(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L596" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec rootname(t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<h4 id="rootname/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.ex")
"/foo/bar"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="rootname/2">rootname(path, extension)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L616" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec rootname(t(), t()) :: binary()</pre> </div> <p>Returns the <code class="inline">path</code> with the <code class="inline">extension</code> stripped.</p>
<p>This function should be used to remove a specific extension which may or may not be there.</p>
<h4 id="rootname/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.rootname("/foo/bar.erl", ".erl")
"/foo/bar"

iex&gt; Path.rootname("/foo/bar.erl", ".ex")
"/foo/bar.erl"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="safe_relative/2">safe_relative(path, cwd \\ File.cwd!())<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L909" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec safe_relative(t(), t()) :: {:ok, binary()} | :error</pre> </div> <p>Returns a relative path that is protected from directory-traversal attacks.</p>
<p>The given relative path is sanitized by eliminating <code class="inline">..</code> and <code class="inline">.</code> components.</p>
<p>This function checks that, after expanding those components, the path is still "safe". Paths are considered unsafe if either of these is true:</p>
<ul>
<li><p>The path is not relative, such as <code class="inline">"/foo/bar"</code>.</p></li>
<li><p>A <code class="inline">..</code> component would make it so that the path would traverse up above the root of <code class="inline">relative_to</code>.</p></li>
<li><p>A symbolic link in the path points to something above the root of <code class="inline">cwd</code>.</p></li>
</ul>
<h4 id="safe_relative/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.safe_relative("foo")
{:ok, "foo"}

iex&gt; Path.safe_relative("deps/my_dep/app.beam")
{:ok, "deps/my_dep/app.beam"}

iex&gt; Path.safe_relative("deps/my_dep/./build/../app.beam", File.cwd!())
{:ok, "deps/my_dep/app.beam"}

iex&gt; Path.safe_relative("my_dep/../..")
:error

iex&gt; Path.safe_relative("/usr/local", File.cwd!())
:error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="safe_relative_to/2">safe_relative_to(path, cwd)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L870" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use safe_relative/2 instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec safe_relative_to(t(), t()) :: {:ok, binary()} | :error</pre> </div> <p>Returns a relative path that is protected from directory-traversal attacks.</p>
<p>See <a href="#safe_relative/2"><code class="inline">safe_relative/2</code></a> for a non-deprecated version of this API.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="split/1">split(path)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L718" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec split(t()) :: [binary()]</pre> </div> <p>Splits the path into a list at the path separator.</p>
<p>If an empty string is given, returns an empty list.</p>
<p>On Windows, path is split on both <code class="inline">"\"</code> and <code class="inline">"/"</code> separators and the driver letter, if there is one, is always returned in lowercase.</p>
<h4 id="split/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Path.split("")
[]

iex&gt; Path.split("foo")
["foo"]

iex&gt; Path.split("/foo/bar")
["/", "foo", "bar"]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="type/1">type(name)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L243" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec type(t()) :: :absolute | :relative | :volumerelative</pre> </div> <p>Returns the path type.</p>
<h4 id="type/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <h3 id="type/1-unix-like-operating-systems" class="section-heading">  <span class="text">Unix-like operating systems</span> </h3> <pre data-language="elixir">Path.type("/")                #=&gt; :absolute
Path.type("/usr/local/bin")   #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("../usr/local/bin") #=&gt; :relative
Path.type("~/file")           #=&gt; :relative</pre>
<h3 id="type/1-windows" class="section-heading">  <span class="text">Windows</span> </h3> <pre data-language="elixir">Path.type("D:/usr/local/bin") #=&gt; :absolute
Path.type("usr/local/bin")    #=&gt; :relative
Path.type("D:bar.ex")         #=&gt; :volumerelative
Path.type("/bar/foo.ex")      #=&gt; :volumerelative</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="wildcard/2">wildcard(glob, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/path.ex#L801" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec wildcard(
  t(),
  keyword()
) :: [binary()]</pre> </div> <p>Traverses paths according to the given <code class="inline">glob</code> expression and returns a list of matches.</p>
<p>The wildcard looks like an ordinary path, except that the following "wildcard characters" are interpreted in a special way:</p>
<ul>
<li><p><code class="inline">?</code> - matches one character.</p></li>
<li><p><code class="inline">*</code> - matches any number of characters up to the end of the filename, the next dot, or the next slash.</p></li>
<li><p><code class="inline">**</code> - two adjacent <code class="inline">*</code>'s used as a single pattern will match all files and zero or more directories and subdirectories.</p></li>
<li><p><code class="inline">[char1,char2,...]</code> - matches any of the characters listed; two characters separated by a hyphen will match a range of characters. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
<li><p><code class="inline">{item1,item2,...}</code> - matches one of the alternatives. Do not add spaces before and after the comma as it would then match paths containing the space character itself.</p></li>
</ul>
<p>Other characters represent themselves. Only paths that have exactly the same character in the same position will match. Note that matching is case-sensitive: <code class="inline">"a"</code> will not match <code class="inline">"A"</code>.</p>
<p>Directory separators must always be written as <code class="inline">/</code>, even on Windows. You may call <a href="#expand/1"><code class="inline">Path.expand/1</code></a> to normalize the path before invoking this function.</p>
<p>A character preceded by <code class="inline">\\</code> loses its special meaning. Note that <code class="inline">\\</code> must be written as <code class="inline">\\\\</code> in a string literal. For example, <code class="inline">"\\\\?*"</code> will match any filename starting with <code class="inline">?.</code>.</p>
<p>By default, the patterns <code class="inline">*</code> and <code class="inline">?</code> do not match files starting with a dot <code class="inline">.</code>. See the <code class="inline">:match_dot</code> option in the "Options" section below.</p>
<h4 id="wildcard/2-options" class="section-heading">  <span class="text">Options</span> </h4> <ul><li>
<code class="inline">:match_dot</code> - (boolean) if <code class="inline">false</code>, the special wildcard characters <code class="inline">*</code> and <code class="inline">?</code> will not match files starting with a dot (<code class="inline">.</code>). If <code class="inline">true</code>, files starting with a <code class="inline">.</code> will not be treated specially. Defaults to <code class="inline">false</code>.</li></ul>
<h4 id="wildcard/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine you have a directory called <code class="inline">projects</code> with three Elixir projects inside of it: <code class="inline">elixir</code>, <code class="inline">ex_doc</code>, and <code class="inline">plug</code>. You can find all <code class="inline">.beam</code> files inside the <code class="inline">ebin</code> directory of each project as follows:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.beam")</pre>
<p>If you want to search for both <code class="inline">.beam</code> and <code class="inline">.app</code> files, you could do:</p>
<pre data-language="elixir">Path.wildcard("projects/*/ebin/**/*.{beam,app}")</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/Path.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/Path.html</a>
  </p>
</div>
