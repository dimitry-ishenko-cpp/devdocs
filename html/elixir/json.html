<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L166" title="View Source" class="source" rel="help">Source</a> <span translate="no">JSON</span>  </h1> <section id="moduledoc"> <p>JSON encoding and decoding.</p>
<p>Both encoder and decoder fully conform to <a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> and <a href="https://ecma-international.org/publications-and-standards/standards/ecma-404/">ECMA 404</a> standards.</p>
<h2 id="module-encoding" class="section-heading">  <span class="text">Encoding</span> </h2> <p>Elixir built-in data structures are encoded to JSON as follows:</p>
<table>
<thead><tr>
<th style="text-align: left;"><strong>Elixir</strong></th>
<th style="text-align: left;"><strong>JSON</strong></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;"><code class="inline">integer() | float()</code></td>
<td style="text-align: left;">Number</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">true | false</code></td>
<td style="text-align: left;">Boolean</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">nil</code></td>
<td style="text-align: left;">Null</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">binary()</code></td>
<td style="text-align: left;">String</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">atom()</code></td>
<td style="text-align: left;">String</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">list()</code></td>
<td style="text-align: left;">Array</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">%{binary() =&gt; _}</code></td>
<td style="text-align: left;">Object</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">%{atom() =&gt; _}</code></td>
<td style="text-align: left;">Object</td>
</tr>
<tr>
<td style="text-align: left;"><code class="inline">%{integer() =&gt; _}</code></td>
<td style="text-align: left;">Object</td>
</tr>
</tbody>
</table>
<p>You may also implement the <a href="json.encoder.html"><code class="inline">JSON.Encoder</code></a> protocol for custom data structures.</p>
<h2 id="module-decoding" class="section-heading">  <span class="text">Decoding</span> </h2> <p>Elixir built-in data structures are decoded from JSON as follows:</p>
<table>
<thead><tr>
<th style="text-align: left;"><strong>JSON</strong></th>
<th style="text-align: left;"><strong>Elixir</strong></th>
</tr></thead>
<tbody>
<tr>
<td style="text-align: left;">Number</td>
<td style="text-align: left;"><code class="inline">integer() | float()</code></td>
</tr>
<tr>
<td style="text-align: left;">Boolean</td>
<td style="text-align: left;"><code class="inline">true | false</code></td>
</tr>
<tr>
<td style="text-align: left;">Null</td>
<td style="text-align: left;"><code class="inline">nil</code></td>
</tr>
<tr>
<td style="text-align: left;">String</td>
<td style="text-align: left;"><code class="inline">binary()</code></td>
</tr>
<tr>
<td style="text-align: left;">Object</td>
<td style="text-align: left;"><code class="inline">%{binary() =&gt; _}</code></td>
</tr>
</tbody>
</table> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:decode_error_reason/0" data-no-tooltip translate="no">decode_error_reason()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:encoder/0" data-no-tooltip translate="no">encoder()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#decode/1" data-no-tooltip translate="no">decode(binary)</a> </dt> <dd class="summary-synopsis"><p>Decodes the given JSON.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#decode/3" data-no-tooltip translate="no">decode(binary, acc, decoders)</a> </dt> <dd class="summary-synopsis"><p>Decodes the given JSON with the given decoders.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#decode!/1" data-no-tooltip translate="no">decode!(binary)</a> </dt> <dd class="summary-synopsis"><p>Decodes the given JSON but raises an exception in case of errors.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#encode!/2" data-no-tooltip translate="no">encode!(term, encoder \\ &amp;protocol_encode/2)</a> </dt> <dd class="summary-synopsis"><p>Encodes the given term to JSON as a binary.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#encode_to_iodata!/2" data-no-tooltip translate="no">encode_to_iodata!(term, encoder \\ &amp;protocol_encode/2)</a> </dt> <dd class="summary-synopsis"><p>Encodes the given term to JSON as an iodata.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#protocol_encode/2" data-no-tooltip translate="no">protocol_encode(value, encoder)</a> </dt> <dd class="summary-synopsis"><p>This is the default encode implementation passed to <a href="#encode!/1"><code class="inline">encode!/1</code></a>.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:decode_error_reason/0">decode_error_reason()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L210" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type decode_error_reason() ::
  {:unexpected_end, non_neg_integer()}
  | {:invalid_byte, non_neg_integer(), byte()}
  | {:unexpected_sequence, non_neg_integer(), binary()}</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:encoder/0">encoder()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L208" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type encoder() :: (term(), encoder() -&gt; iodata())</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail"> <h3 class="detail-header" id="decode/1">decode(binary)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L234" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec decode(binary()) :: {:ok, term()} | {:error, decode_error_reason()}</pre> </div> <p>Decodes the given JSON.</p>
<p>Returns <code class="inline">{:ok, decoded}</code> or <code class="inline">{:error, reason}</code>.</p>
<h4 id="decode/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; JSON.decode("[null,123,\"string\",{\"key\":\"value\"}]")
{:ok, [nil, 123, "string", %{"key" =&gt; "value"}]}</pre>
<h4 id="decode/1-error-reasons" class="section-heading">  <span class="text">Error reasons</span> </h4> <p>The error tuple will have one of the following reasons.</p>
<ul>
<li>
<code class="inline">{:unexpected_end, offset}</code> if <code class="inline">binary</code> contains incomplete JSON value</li>
<li>
<code class="inline">{:invalid_byte, offset, byte}</code> if <code class="inline">binary</code> contains unexpected byte or invalid UTF-8 byte</li>
<li>
<code class="inline">{:unexpected_sequence, offset, bytes}</code> if <code class="inline">binary</code> contains invalid UTF-8 escape</li>
</ul> </section> </section> <section class="detail"> <h3 class="detail-header" id="decode/3">decode(binary, acc, decoders)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L270" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec decode(binary(), term(), keyword()) ::
  {term(), term(), binary()} | {:error, decode_error_reason()}</pre> </div> <p>Decodes the given JSON with the given decoders.</p>
<p>Returns <code class="inline">{decoded, acc, rest}</code> or <code class="inline">{:error, reason}</code>. See <a href="#decode/1"><code class="inline">decode/1</code></a> for the error reasons.</p>
<h4 id="decode/3-decoders" class="section-heading">  <span class="text">Decoders</span> </h4> <p>All decoders are optional. If not provided, they will fall back to implementations used by the <a href="#decode/1"><code class="inline">decode/1</code></a> function:</p>
<ul>
<li>for <code class="inline">array_start</code>: <code class="inline">fn _ -&gt; [] end</code>
</li>
<li><p>for <code class="inline">array_push</code>: <code class="inline">fn elem, acc -&gt; [elem | acc] end</code></p></li>
<li>for <code class="inline">array_finish</code>: <code class="inline">fn acc, old_acc -&gt; {Enum.reverse(acc), old_acc} end</code>
</li>
<li>for <code class="inline">object_start</code>: <code class="inline">fn _ -&gt; [] end</code>
</li>
<li><p>for <code class="inline">object_push</code>: <code class="inline">fn key, value, acc -&gt; [{key, value} | acc] end</code></p></li>
<li>for <code class="inline">object_finish</code>: <code class="inline">fn acc, old_acc -&gt; {Map.new(acc), old_acc} end</code>
</li>
<li>for <code class="inline">float</code>: <code class="inline">&amp;String.to_float/1</code>
</li>
<li>for <code class="inline">integer</code>: <code class="inline">&amp;String.to_integer/1</code>
</li>
<li>for <code class="inline">string</code>: <code class="inline">&amp;Function.identity/1</code>
</li>
<li>for <code class="inline">null</code>: the atom <code class="inline">nil</code>
</li>
</ul>
<p>For streaming decoding, see Erlang's <code class="inline">:json</code> module.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="decode!/1">decode!(binary)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L307" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec decode!(binary()) :: term()</pre> </div> <p>Decodes the given JSON but raises an exception in case of errors.</p>
<p>Returns the decoded content. See <a href="#decode/1"><code class="inline">decode/1</code></a> for possible errors.</p>
<h4 id="decode!/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; JSON.decode!("[null,123,\"string\",{\"key\":\"value\"}]")
[nil, 123, "string", %{"key" =&gt; "value"}]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="encode!/2">encode!(term, encoder \\ &amp;protocol_encode/2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L351" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec encode!(term(), encoder()) :: binary()</pre> </div> <p>Encodes the given term to JSON as a binary.</p>
<p>The second argument is a function that is recursively invoked to encode a term.</p>
<section role="note" class="admonition tip"><h4 class="admonition-title tip">IO and performance</h4>
<p>If you need to encode data to be sent over the network or written to the filesystem, consider using the more efficient <a href="#encode_to_iodata!/2"><code class="inline">encode_to_iodata!/2</code></a>.</p></section><h4 id="encode!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; JSON.encode!([123, "string", %{key: "value"}])
"[123,\"string\",{\"key\":\"value\"}]"</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="encode_to_iodata!/2">encode_to_iodata!(term, encoder \\ &amp;protocol_encode/2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L372" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec encode_to_iodata!(term(), encoder()) :: iodata()</pre> </div> <p>Encodes the given term to JSON as an iodata.</p>
<p>This is the most efficient format if the JSON is going to be used for IO purposes.</p>
<p>The second argument is a function that is recursively invoked to encode a term.</p>
<h4 id="encode_to_iodata!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; data = JSON.encode_to_iodata!([123, "string", %{key: "value"}])
iex&gt; IO.iodata_to_binary(data)
"[123,\"string\",{\"key\":\"value\"}]"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="protocol_encode/2">protocol_encode(value, encoder)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/json.ex#L384" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec protocol_encode(term(), encoder()) :: iodata()</pre> </div> <p>This is the default encode implementation passed to <a href="#encode!/1"><code class="inline">encode!/1</code></a>.</p>
<p>This function is most typically passed as second argument to <a href="#encode!/2"><code class="inline">encode!/2</code></a> and <a href="#encode_to_iodata!/2"><code class="inline">encode_to_iodata!/2</code></a>. The default implementation is an optimized dispatch to the <a href="json.encoder.html"><code class="inline">JSON.Encoder</code></a> protocol.</p> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/JSON.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/JSON.html</a>
  </p>
</div>
