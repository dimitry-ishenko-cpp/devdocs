<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">GenServer</span> <small>behaviour</small>  </h1> <section id="moduledoc"> <p>A behaviour module for implementing the server of a client-server relation.</p>
<p>A GenServer is a process like any other Elixir process and it can be used to keep state, execute code asynchronously and so on. The advantage of using a generic server process (GenServer) implemented using this module is that it will have a standard set of interface functions and include functionality for tracing and error reporting. It will also fit into a supervision tree.</p>
<pre data-language="elixir">graph BT
    C(Client #3) ~~~ B(Client #2) ~~~ A(Client #1)
    A &amp; B &amp; C --&gt;|request| GenServer
    GenServer -.-&gt;|reply| A &amp; B &amp; C</pre>
<h2 id="module-example" class="section-heading">  <span class="text">Example</span> </h2> <p>The GenServer behaviour abstracts the common client-server interaction. Developers are only required to implement the callbacks and functionality they are interested in.</p>
<p>Let's start with a code example and then explore the available callbacks. Imagine we want to implement a service with a GenServer that works like a stack, allowing us to push and pop elements. We'll customize a generic GenServer with our own module by implementing three callbacks.</p>
<p><a href="#c:init/1"><code class="inline">init/1</code></a> transforms our initial argument to the initial state for the GenServer. <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> fires when the server receives a synchronous <code class="inline">pop</code> message, popping an element from the stack and returning it to the user. <a href="#c:handle_cast/2"><code class="inline">handle_cast/2</code></a> will fire when the server receives an asynchronous <code class="inline">push</code> message, pushing an element onto the stack:</p>
<pre data-language="elixir">defmodule Stack do
  use GenServer

  # Callbacks

  @impl true
  def init(elements) do
    initial_state = String.split(elements, ",", trim: true)
    {:ok, initial_state}
  end

  @impl true
  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end
end</pre>
<p>We leave the process machinery of startup, message passing, and the message loop to the GenServer behaviour and focus only on the stack implementation. We can now use the GenServer API to interact with the service by creating a process and sending it messages:</p>
<pre data-language="elixir"># Start the server
{:ok, pid} = GenServer.start_link(Stack, "hello,world")

# This is the client
GenServer.call(pid, :pop)
#=&gt; "hello"

GenServer.cast(pid, {:push, "elixir"})
#=&gt; :ok

GenServer.call(pid, :pop)
#=&gt; "elixir"</pre>
<p>We start our <code class="inline">Stack</code> by calling <a href="#start_link/2"><code class="inline">start_link/2</code></a>, passing the module with the server implementation and its initial argument with a comma-separated list of elements. The GenServer behaviour calls the <a href="#c:init/1"><code class="inline">init/1</code></a> callback to establish the initial GenServer state. From this point on, the GenServer has control so we interact with it by sending two types of messages on the client. <strong>call</strong> messages expect a reply from the server (and are therefore synchronous) while <strong>cast</strong> messages do not.</p>
<p>Each call to <a href="#call/3"><code class="inline">GenServer.call/3</code></a> results in a message that must be handled by the <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> callback in the GenServer. A <a href="#cast/2"><code class="inline">cast/2</code></a> message must be handled by <a href="#c:handle_cast/2"><code class="inline">handle_cast/2</code></a>. <a href="genserver.html"><code class="inline">GenServer</code></a> supports 8 callbacks, but only <a href="#c:init/1"><code class="inline">init/1</code></a> is required.</p>
<section role="note" class="admonition info"><h4 class="admonition-title info"><code class="inline">use GenServer</code></h4>
<p>When you <code class="inline">use GenServer</code>, the <a href="genserver.html"><code class="inline">GenServer</code></a> module will set <code class="inline">@behaviour GenServer</code> and define a <code class="inline">child_spec/1</code> function, so your module can be used as a child in a supervision tree.</p></section><h2 id="module-client-server-apis" class="section-heading">  <span class="text">Client / Server APIs</span> </h2> <p>Although in the example above we have used <a href="#start_link/3"><code class="inline">GenServer.start_link/3</code></a> and friends to directly start and communicate with the server, most of the time we don't call the <a href="genserver.html"><code class="inline">GenServer</code></a> functions directly. Instead, we wrap the calls in new functions representing the public API of the server. These thin wrappers are called the <strong>client API</strong>.</p>
<p>Here is a better implementation of our Stack module:</p>
<pre data-language="elixir">defmodule Stack do
  use GenServer

  # Client

  def start_link(default) when is_binary(default) do
    GenServer.start_link(__MODULE__, default)
  end

  def push(pid, element) do
    GenServer.cast(pid, {:push, element})
  end

  def pop(pid) do
    GenServer.call(pid, :pop)
  end

  # Server (callbacks)

  @impl true
  def init(elements) do
    initial_state = String.split(elements, ",", trim: true)
    {:ok, initial_state}
  end

  @impl true
  def handle_call(:pop, _from, state) do
    [to_caller | new_state] = state
    {:reply, to_caller, new_state}
  end

  @impl true
  def handle_cast({:push, element}, state) do
    new_state = [element | state]
    {:noreply, new_state}
  end
end</pre>
<p>In practice, it is common to have both server and client functions in the same module. If the server and/or client implementations are growing complex, you may want to have them in different modules.</p>
<p>The following diagram summarizes the interactions between client and server. Both Client and Server are processes and communication happens via messages (continuous line). The Server &lt;-&gt; Module interaction happens when the GenServer process calls your code (dotted lines):</p>
<pre data-language="elixir">sequenceDiagram
    participant C as Client (Process)
    participant S as Server (Process)
    participant M as Module (Code)

    note right of C: Typically started by a supervisor
    C-&gt;&gt;+S: GenServer.start_link(module, arg, options)
    S--&gt;&gt;+M: init(arg)
    M--&gt;&gt;-S: {:ok, state} | :ignore | {:error, reason}
    S-&gt;&gt;-C: {:ok, pid} | :ignore | {:error, reason}

    note right of C: call is synchronous
    C-&gt;&gt;+S: GenServer.call(pid, message)
    S--&gt;&gt;+M: handle_call(message, from, state)
    M--&gt;&gt;-S: {:reply, reply, state} | {:stop, reason, reply, state}
    S-&gt;&gt;-C: reply

    note right of C: cast is asynchronous
    C-)S: GenServer.cast(pid, message)
    S--&gt;&gt;+M: handle_cast(message, state)
    M--&gt;&gt;-S: {:noreply, state} | {:stop, reason, state}

    note right of C: send is asynchronous
    C-)S: Kernel.send(pid, message)
    S--&gt;&gt;+M: handle_info(message, state)
    M--&gt;&gt;-S: {:noreply, state} | {:stop, reason, state}</pre>
<h2 id="module-how-to-supervise" class="section-heading">  <span class="text">How to supervise</span> </h2> <p>A <a href="genserver.html"><code class="inline">GenServer</code></a> is most commonly started under a supervision tree. When we invoke <code class="inline">use GenServer</code>, it automatically defines a <code class="inline">child_spec/1</code> function that allows us to start the <code class="inline">Stack</code> directly under a supervisor. To start a default stack of <code class="inline">["hello", "world"]</code> under a supervisor, we can do:</p>
<pre data-language="elixir">children = [
  {Stack, "hello,world"}
]

Supervisor.start_link(children, strategy: :one_for_all)</pre>
<p>Note that specifying a module <code class="inline">MyServer</code> would be the same as specifying the tuple <code class="inline">{MyServer, []}</code>.</p>
<p><code class="inline">use GenServer</code> also accepts a list of options which configures the child specification and therefore how it runs under a supervisor. The generated <code class="inline">child_spec/1</code> can be customized with the following options:</p>
<ul>
<li>
<code class="inline">:id</code> - the child specification identifier, defaults to the current module</li>
<li>
<code class="inline">:restart</code> - when the child should be restarted, defaults to <code class="inline">:permanent</code>
</li>
<li>
<code class="inline">:shutdown</code> - how to shut down the child, either immediately or by giving it time to shut down</li>
</ul>
<p>For example:</p>
<pre data-language="elixir">use GenServer, restart: :transient, shutdown: 10_000</pre>
<p>See the "Child specification" section in the <a href="supervisor.html"><code class="inline">Supervisor</code></a> module for more detailed information. The <code class="inline">@doc</code> annotation immediately preceding <code class="inline">use GenServer</code> will be attached to the generated <code class="inline">child_spec/1</code> function.</p>
<p>When stopping the GenServer, for example by returning a <code class="inline">{:stop, reason, new_state}</code> tuple from a callback, the exit reason is used by the supervisor to determine whether the GenServer needs to be restarted. See the "Exit reasons and restarts" section in the <a href="supervisor.html"><code class="inline">Supervisor</code></a> module.</p>
<h2 id="module-name-registration" class="section-heading">  <span class="text">Name registration</span> </h2> <p>Both <a href="#start_link/3"><code class="inline">start_link/3</code></a> and <a href="#start/3"><code class="inline">start/3</code></a> support the <a href="genserver.html"><code class="inline">GenServer</code></a> to register a name on start via the <code class="inline">:name</code> option. Registered names are also automatically cleaned up on termination. The supported values are:</p>
<ul>
<li><p>an atom - the GenServer is registered locally (to the current node) with the given name using <a href="process.html#register/2"><code class="inline">Process.register/2</code></a>.</p></li>
<li><p><code class="inline">{:global, term}</code> - the GenServer is registered globally with the given term using the functions in the <a href="https://www.erlang.org/doc/apps/kernel/global.html"><code class="inline">:global</code> module</a>.</p></li>
<li><p><code class="inline">{:via, module, term}</code> - the GenServer is registered with the given mechanism and name. The <code class="inline">:via</code> option expects a module that exports <code class="inline">register_name/2</code>, <code class="inline">unregister_name/1</code>, <code class="inline">whereis_name/1</code> and <a href="kernel.html#send/2"><code class="inline">send/2</code></a>. One such example is the <a href="https://www.erlang.org/doc/apps/kernel/global.html"><code class="inline">:global</code> module</a> which uses these functions for keeping the list of names of processes and their associated PIDs that are available globally for a network of Elixir nodes. Elixir also ships with a local, decentralized and scalable registry called <a href="registry.html"><code class="inline">Registry</code></a> for locally storing names that are generated dynamically.</p></li>
</ul>
<p>For example, we could start and register our <code class="inline">Stack</code> server locally as follows:</p>
<pre data-language="elixir"># Start the server and register it locally with name MyStack
{:ok, _} = GenServer.start_link(Stack, "hello", name: MyStack)

# Now messages can be sent directly to MyStack
GenServer.call(MyStack, :pop)
#=&gt; "hello"</pre>
<p>Once the server is started, the remaining functions in this module (<a href="#call/3"><code class="inline">call/3</code></a>, <a href="#cast/2"><code class="inline">cast/2</code></a>, and friends) will also accept an atom, or any <code class="inline">{:global, ...}</code> or <code class="inline">{:via, ...}</code> tuples. In general, the following formats are supported:</p>
<ul>
<li>a PID</li>
<li>an atom if the server is locally registered</li>
<li>
<code class="inline">{atom, node}</code> if the server is locally registered at another node</li>
<li>
<code class="inline">{:global, term}</code> if the server is globally registered</li>
<li>
<code class="inline">{:via, module, name}</code> if the server is registered through an alternative registry</li>
</ul>
<p>If there is an interest to register dynamic names locally, do not use atoms, as atoms are never garbage-collected and therefore dynamically generated atoms won't be garbage-collected. For such cases, you can set up your own local registry by using the <a href="registry.html"><code class="inline">Registry</code></a> module.</p>
<h2 id="module-receiving-regular-messages" class="section-heading">  <span class="text">Receiving "regular" messages</span> </h2> <p>The goal of a <a href="genserver.html"><code class="inline">GenServer</code></a> is to abstract the "receive" loop for developers, automatically handling system messages, supporting code change, synchronous calls and more. Therefore, you should never call your own "receive" inside the GenServer callbacks as doing so will cause the GenServer to misbehave.</p>
<p>Besides the synchronous and asynchronous communication provided by <a href="#call/3"><code class="inline">call/3</code></a> and <a href="#cast/2"><code class="inline">cast/2</code></a>, "regular" messages sent by functions such as <a href="kernel.html#send/2"><code class="inline">send/2</code></a>, <a href="process.html#send_after/4"><code class="inline">Process.send_after/4</code></a> and similar, can be handled inside the <a href="#c:handle_info/2"><code class="inline">handle_info/2</code></a> callback.</p>
<p><a href="#c:handle_info/2"><code class="inline">handle_info/2</code></a> can be used in many situations, such as handling monitor DOWN messages sent by <a href="process.html#monitor/1"><code class="inline">Process.monitor/1</code></a>. Another use case for <a href="#c:handle_info/2"><code class="inline">handle_info/2</code></a> is to perform periodic work, with the help of <a href="process.html#send_after/4"><code class="inline">Process.send_after/4</code></a>:</p>
<pre data-language="elixir">defmodule MyApp.Periodically do
  use GenServer

  def start_link(_) do
    GenServer.start_link(__MODULE__, %{})
  end

  @impl true
  def init(state) do
    # Schedule work to be performed on start
    schedule_work()

    {:ok, state}
  end

  @impl true
  def handle_info(:work, state) do
    # Do the desired work here
    # ...

    # Reschedule once more
    schedule_work()

    {:noreply, state}
  end

  defp schedule_work do
    # We schedule the work to happen in 2 hours (written in milliseconds).
    # Alternatively, one might write :timer.hours(2)
    Process.send_after(self(), :work, 2 * 60 * 60 * 1000)
  end
end</pre>
<h2 id="module-timeouts" class="section-heading">  <span class="text">Timeouts</span> </h2> <p>The return value of <a href="#c:init/1"><code class="inline">init/1</code></a> or any of the <code class="inline">handle_*</code> callbacks may include a timeout value in milliseconds; if not, <code class="inline">:infinity</code> is assumed. The timeout can be used to detect a lull in incoming messages.</p>
<p>The <code class="inline">timeout()</code> value is used as follows:</p>
<ul>
<li><p>If the process has any message already waiting when the <code class="inline">timeout()</code> value is returned, the timeout is ignored and the waiting message is handled as usual. This means that even a timeout of <code class="inline">0</code> milliseconds is not guaranteed to execute (if you want to take another action immediately and unconditionally, use a <code class="inline">:continue</code> instruction instead).</p></li>
<li><p>If any message arrives before the specified number of milliseconds elapse, the timeout is cleared and that message is handled as usual.</p></li>
<li><p>Otherwise, when the specified number of milliseconds have elapsed with no message arriving, <code class="inline">handle_info/2</code> is called with <code class="inline">:timeout</code> as the first argument.</p></li>
</ul>
<h2 id="module-when-not-to-use-a-genserver" class="section-heading">  <span class="text">When (not) to use a GenServer</span> </h2> <p>So far, we have learned that a <a href="genserver.html"><code class="inline">GenServer</code></a> can be used as a supervised process that handles sync and async calls. It can also handle system messages, such as periodic messages and monitoring events. GenServer processes may also be named.</p>
<p>A GenServer, or a process in general, must be used to model runtime characteristics of your system. A GenServer must never be used for code organization purposes.</p>
<p>In Elixir, code organization is done by modules and functions, processes are not necessary. For example, imagine you are implementing a calculator and you decide to put all the calculator operations behind a GenServer:</p>
<pre data-language="elixir">def add(a, b) do
  GenServer.call(__MODULE__, {:add, a, b})
end

def subtract(a, b) do
  GenServer.call(__MODULE__, {:subtract, a, b})
end

def handle_call({:add, a, b}, _from, state) do
  {:reply, a + b, state}
end

def handle_call({:subtract, a, b}, _from, state) do
  {:reply, a - b, state}
end</pre>
<p>This is an anti-pattern not only because it convolutes the calculator logic but also because you put the calculator logic behind a single process that will potentially become a bottleneck in your system, especially as the number of calls grow. Instead just define the functions directly:</p>
<pre data-language="elixir">def add(a, b) do
  a + b
end

def subtract(a, b) do
  a - b
end</pre>
<p>If you don't need a process, then you don't need a process. Use processes only to model runtime properties, such as mutable state, concurrency and failures, never for code organization.</p>
<h2 id="module-debugging-with-the-sys-module" class="section-heading">  <span class="text">Debugging with the :sys module</span> </h2> <p>GenServers, as <a href="https://www.erlang.org/doc/design_principles/spec_proc.html">special processes</a>, can be debugged using the <a href="https://www.erlang.org/doc/apps/stdlib/sys.html"><code class="inline">:sys</code> module</a>. Through various hooks, this module allows developers to introspect the state of the process and trace system events that happen during its execution, such as received messages, sent replies and state changes.</p>
<p>Let's explore the basic functions from the <a href="https://www.erlang.org/doc/apps/stdlib/sys.html"><code class="inline">:sys</code> module</a> used for debugging:</p>
<ul>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#get_state/2"><code class="inline">:sys.get_state/2</code></a> - allows retrieval of the state of the process. In the case of a GenServer process, it will be the callback module state, as passed into the callback functions as last argument.</li>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#get_status/2"><code class="inline">:sys.get_status/2</code></a> - allows retrieval of the status of the process. This status includes the process dictionary, if the process is running or is suspended, the parent PID, the debugger state, and the state of the behaviour module, which includes the callback module state (as returned by <a href="https://www.erlang.org/doc/apps/stdlib/sys.html#get_state/2"><code class="inline">:sys.get_state/2</code></a>). It's possible to change how this status is represented by defining the optional <a href="#c:format_status/1"><code class="inline">GenServer.format_status/1</code></a> callback.</li>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#trace/3"><code class="inline">:sys.trace/3</code></a> - prints all the system events to <code class="inline">:stdio</code>.</li>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#statistics/3"><code class="inline">:sys.statistics/3</code></a> - manages collection of process statistics.</li>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#no_debug/2"><code class="inline">:sys.no_debug/2</code></a> - turns off all debug handlers for the given process. It is very important to switch off debugging once we're done. Excessive debug handlers or those that should be turned off, but weren't, can seriously damage the performance of the system.</li>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#suspend/2"><code class="inline">:sys.suspend/2</code></a> - allows to suspend a process so that it only replies to system messages but no other messages. A suspended process can be reactivated via <a href="https://www.erlang.org/doc/apps/stdlib/sys.html#resume/2"><code class="inline">:sys.resume/2</code></a>.</li>
</ul>
<p>Let's see how we could use those functions for debugging the stack server we defined earlier.</p>
<pre data-language="elixir">iex&gt; {:ok, pid} = Stack.start_link("")
iex&gt; :sys.statistics(pid, true) # turn on collecting process statistics
iex&gt; :sys.trace(pid, true) # turn on event printing
iex&gt; Stack.push(pid, 1)
*DBG* &lt;0.122.0&gt; got cast {push,1}
*DBG* &lt;0.122.0&gt; new state [1]
:ok

iex&gt; :sys.get_state(pid)
[1]

iex&gt; Stack.pop(pid)
*DBG* &lt;0.122.0&gt; got call pop from &lt;0.80.0&gt;
*DBG* &lt;0.122.0&gt; sent 1 to &lt;0.80.0&gt;, new state []
1

iex&gt; :sys.statistics(pid, :get)
{:ok,
 [
   start_time: {{2016, 7, 16}, {12, 29, 41}},
   current_time: {{2016, 7, 16}, {12, 29, 50}},
   reductions: 117,
   messages_in: 2,
   messages_out: 0
 ]}

iex&gt; :sys.no_debug(pid) # turn off all debug handlers
:ok

iex&gt; :sys.get_status(pid)
{:status, #PID&lt;0.122.0&gt;, {:module, :gen_server},
 [
   [
     "$initial_call": {Stack, :init, 1},            # process dictionary
     "$ancestors": [#PID&lt;0.80.0&gt;, #PID&lt;0.51.0&gt;]
   ],
   :running,                                        # :running | :suspended
   #PID&lt;0.80.0&gt;,                                    # parent
   [],                                              # debugger state
   [
     header: 'Status for generic server &lt;0.122.0&gt;', # module status
     data: [
       {'Status', :running},
       {'Parent', #PID&lt;0.80.0&gt;},
       {'Logged events', []}
     ],
     data: [{'State', [1]}]
   ]
 ]}</pre>
<h2 id="module-learn-more" class="section-heading">  <span class="text">Learn more</span> </h2> <p>If you wish to find out more about GenServers, the Elixir Getting Started guide provides a tutorial-like introduction. The documentation and links in Erlang can also provide extra insight.</p>
<ul>
<li><a href="genservers.html">GenServer - Elixir's Getting Started Guide</a></li>
<li><a href="https://www.erlang.org/doc/apps/stdlib/gen_server.html"><code class="inline">:gen_server</code> module documentation</a></li>
<li><a href="https://www.erlang.org/doc/design_principles/gen_server_concepts.html">gen_server Behaviour - OTP Design Principles</a></li>
<li><a href="http://learnyousomeerlang.com/clients-and-servers">Clients and Servers - Learn You Some Erlang for Great Good!</a></li>
</ul> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:debug/0" data-no-tooltip translate="no">debug()</a> </dt> <dd class="summary-synopsis"><p>Debug options supported by the <code class="inline">start*</code> functions</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:from/0" data-no-tooltip translate="no">from()</a> </dt> <dd class="summary-synopsis"><p>Tuple describing the client of a call request.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:name/0" data-no-tooltip translate="no">name()</a> </dt> <dd class="summary-synopsis"><p>The GenServer name</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:on_start/0" data-no-tooltip translate="no">on_start()</a> </dt> <dd class="summary-synopsis"><p>Return values of <code class="inline">start*</code> functions</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:option/0" data-no-tooltip translate="no">option()</a> </dt> <dd class="summary-synopsis"><p>Option values used by the <code class="inline">start*</code> functions</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:options/0" data-no-tooltip translate="no">options()</a> </dt> <dd class="summary-synopsis"><p>Options used by the <code class="inline">start*</code> functions</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:server/0" data-no-tooltip translate="no">server()</a> </dt> <dd class="summary-synopsis"><p>The server reference.</p></dd> </div> </dl> <h2> Callbacks </h2>
<dl class="summary-callbacks summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#c:code_change/3" data-no-tooltip translate="no">code_change(old_vsn, state, extra)</a> </dt> <dd class="summary-synopsis"><p>Invoked to change the state of the <a href="genserver.html"><code class="inline">GenServer</code></a> when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:format_status/1" data-no-tooltip translate="no">format_status(status)</a> </dt> <dd class="summary-synopsis"><p>This function is called by a <a href="genserver.html"><code class="inline">GenServer</code></a> process in the following situations</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:format_status/2" data-no-tooltip translate="no">format_status(reason, pdict_and_state)</a> <span class="deprecated" title="Use format_status/1 callback instead">deprecated</span> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_call/3" data-no-tooltip translate="no">handle_call(request, from, state)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle synchronous <a href="#call/3"><code class="inline">call/3</code></a> messages. <a href="#call/3"><code class="inline">call/3</code></a> will block until a reply is received (unless the call times out or nodes are disconnected).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_cast/2" data-no-tooltip translate="no">handle_cast(request, state)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle asynchronous <a href="#cast/2"><code class="inline">cast/2</code></a> messages.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_continue/2" data-no-tooltip translate="no">handle_continue(continue_arg, state)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle continue instructions.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:handle_info/2" data-no-tooltip translate="no">handle_info(msg, state)</a> </dt> <dd class="summary-synopsis"><p>Invoked to handle all other messages.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:init/1" data-no-tooltip translate="no">init(init_arg)</a> </dt> <dd class="summary-synopsis"><p>Invoked when the server is started. <a href="#start_link/3"><code class="inline">start_link/3</code></a> or <a href="#start/3"><code class="inline">start/3</code></a> will block until it returns.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#c:terminate/2" data-no-tooltip translate="no">terminate(reason, state)</a> </dt> <dd class="summary-synopsis"><p>Invoked when the server is about to exit. It should do any cleanup required.</p></dd> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#abcast/3" data-no-tooltip translate="no">abcast(nodes \\ [node() | Node.list()], name, request)</a> </dt> <dd class="summary-synopsis"><p>Casts all servers locally registered as <code class="inline">name</code> at the specified nodes.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#call/3" data-no-tooltip translate="no">call(server, request, timeout \\ 5000)</a> </dt> <dd class="summary-synopsis"><p>Makes a synchronous call to the <code class="inline">server</code> and waits for its reply.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#cast/2" data-no-tooltip translate="no">cast(server, request)</a> </dt> <dd class="summary-synopsis"><p>Casts a request to the <code class="inline">server</code> without waiting for a response.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#multi_call/4" data-no-tooltip translate="no">multi_call(nodes \\ [node() | Node.list()], name, request, timeout \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Calls all servers locally registered as <code class="inline">name</code> at the specified <code class="inline">nodes</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reply/2" data-no-tooltip translate="no">reply(client, reply)</a> </dt> <dd class="summary-synopsis"><p>Replies to a client.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start/3" data-no-tooltip translate="no">start(module, init_arg, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Starts a <a href="genserver.html"><code class="inline">GenServer</code></a> process without links (outside of a supervision tree).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#start_link/3" data-no-tooltip translate="no">start_link(module, init_arg, options \\ [])</a> </dt> <dd class="summary-synopsis"><p>Starts a <a href="genserver.html"><code class="inline">GenServer</code></a> process linked to the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#stop/3" data-no-tooltip translate="no">stop(server, reason \\ :normal, timeout \\ :infinity)</a> </dt> <dd class="summary-synopsis"><p>Synchronously stops the server with the given <code class="inline">reason</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#whereis/1" data-no-tooltip translate="no">whereis(server)</a> </dt> <dd class="summary-synopsis"><p>Returns the <code class="inline">pid</code> or <code class="inline">{name, node}</code> of a GenServer process, <code class="inline">nil</code> otherwise.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:debug/0">debug()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L825" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type debug() :: [:trace | :log | :statistics | {:log_to_file, Path.t()}]</pre> </div> <p>Debug options supported by the <code class="inline">start*</code> functions</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:from/0">from()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L841" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type from() :: {pid(), tag :: term()}</pre> </div> <p>Tuple describing the client of a call request.</p>
<p><code class="inline">pid</code> is the PID of the caller and <code class="inline">tag</code> is a unique term used to identify the call.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:name/0">name()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L811" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type name() :: atom() | {:global, term()} | {:via, module(), term()}</pre> </div> <p>The GenServer name</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:on_start/0">on_start()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L808" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type on_start() ::
  {:ok, pid()} | :ignore | {:error, {:already_started, pid()} | term()}</pre> </div> <p>Return values of <code class="inline">start*</code> functions</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:option/0">option()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L817" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type option() ::
  {:debug, debug()}
  | {:name, name()}
  | {:timeout, timeout()}
  | {:spawn_opt, [Process.spawn_opt()]}
  | {:hibernate_after, timeout()}</pre> </div> <p>Option values used by the <code class="inline">start*</code> functions</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:options/0">options()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L814" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type options() :: [option()]</pre> </div> <p>Options used by the <code class="inline">start*</code> functions</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:server/0">server()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L833" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type server() :: pid() | name() | {atom(), node()}</pre> </div> <p>The server reference.</p>
<p>This is either a plain PID or a value representing a registered name. See the "Name registration" section of this document for more information.</p> </section> </section> </div> </section> <section id="callbacks" class="details-list"> <h1 class="section-heading">  <span class="text">Callbacks</span> </h1> <div class="callbacks-list"> <section class="detail"> <h3 class="detail-header" id="c:code_change/3">code_change(old_vsn, state, extra)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L756" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback code_change(old_vsn, state :: term(), extra :: term()) ::
  {:ok, new_state :: term()} | {:error, reason :: term()}
when old_vsn: term() | {:down, term()}</pre> </div> <p>Invoked to change the state of the <a href="genserver.html"><code class="inline">GenServer</code></a> when a different version of a module is loaded (hot code swapping) and the state's term structure should be changed.</p>
<p><code class="inline">old_vsn</code> is the previous version of the module (defined by the <code class="inline">@vsn</code> attribute) when upgrading. When downgrading the previous version is wrapped in a 2-tuple with first element <code class="inline">:down</code>. <code class="inline">state</code> is the current state of the <a href="genserver.html"><code class="inline">GenServer</code></a> and <code class="inline">extra</code> is any extra data required to change the state.</p>
<p>Returning <code class="inline">{:ok, new_state}</code> changes the state to <code class="inline">new_state</code> and the code change is successful.</p>
<p>Returning <code class="inline">{:error, reason}</code> fails the code change with reason <code class="inline">reason</code> and the state remains as the previous state.</p>
<p>If <a href="#c:code_change/3"><code class="inline">code_change/3</code></a> raises the code change fails and the loop will continue with its previous state. Therefore this callback does not usually contain side effects.</p>
<p>This callback is optional.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:format_status/1">format_status(status)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L790" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback format_status(status :: :gen_server.format_status()) ::
  new_status :: :gen_server.format_status()</pre> </div> <p>This function is called by a <a href="genserver.html"><code class="inline">GenServer</code></a> process in the following situations:</p>
<ul>
<li>
<a href="https://www.erlang.org/doc/apps/stdlib/sys.html#get_status/1"><code class="inline">:sys.get_status/1,2</code></a> is invoked to get the <a href="genserver.html"><code class="inline">GenServer</code></a> status.</li>
<li>The <a href="genserver.html"><code class="inline">GenServer</code></a> process terminates abnormally and logs an error.</li>
</ul>
<p>This callback is used to limit the status of the process returned by <a href="https://www.erlang.org/doc/apps/stdlib/sys.html#get_status/1"><code class="inline">:sys.get_status/1,2</code></a> or sent to logger.</p>
<p>The callback gets a map <code class="inline">status</code> describing the current status and shall return a map <code class="inline">new_status</code> with the same keys, but it may transform some values.</p>
<p>Two possible use cases for this callback is to remove sensitive information from the state to prevent it from being printed in log files, or to compact large irrelevant status items that would only clutter the logs.</p>
<h4 id="c:format_status/1-example" class="section-heading">  <span class="text">Example</span> </h4> <pre data-language="elixir">@impl GenServer
def format_status(status) do
  Map.new(status, fn
    {:state, state} -&gt; {:state, Map.delete(state, :private_key)}
    {:message, {:password, _}} -&gt; {:message, {:password, "redacted"}}
    key_value -&gt; key_value
  end)
end</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:format_status/2">format_status(reason, pdict_and_state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L795" class="source">Source</a>
</h3> <div class="deprecated"> This callback is deprecated. Use format_status/1 callback instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback format_status(reason, pdict_and_state :: list()) :: term()
when reason: :normal | :terminate</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_call/3">handle_call(request, from, state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L592" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_call(request :: term(), from(), state :: term()) ::
  {:reply, reply, new_state}
  | {:reply, reply, new_state,
     timeout() | :hibernate | {:continue, continue_arg :: term()}}
  | {:noreply, new_state}
  | {:noreply, new_state,
     timeout() | :hibernate | {:continue, continue_arg :: term()}}
  | {:stop, reason, reply, new_state}
  | {:stop, reason, new_state}
when reply: term(), new_state: term(), reason: term()</pre> </div> <p>Invoked to handle synchronous <a href="#call/3"><code class="inline">call/3</code></a> messages. <a href="#call/3"><code class="inline">call/3</code></a> will block until a reply is received (unless the call times out or nodes are disconnected).</p>
<p><code class="inline">request</code> is the request message sent by a <a href="#call/3"><code class="inline">call/3</code></a>, <code class="inline">from</code> is a 2-tuple containing the caller's PID and a term that uniquely identifies the call, and <code class="inline">state</code> is the current state of the <a href="genserver.html"><code class="inline">GenServer</code></a>.</p>
<p>Returning <code class="inline">{:reply, reply, new_state}</code> sends the response <code class="inline">reply</code> to the caller and continues the loop with new state <code class="inline">new_state</code>.</p>
<p>Returning <code class="inline">{:reply, reply, new_state, timeout}</code> is similar to <code class="inline">{:reply, reply, new_state}</code> except that it also sets a timeout. See the "Timeouts" section in the module documentation for more information.</p>
<p>Returning <code class="inline">{:reply, reply, new_state, :hibernate}</code> is similar to <code class="inline">{:reply, reply, new_state}</code> except the process is hibernated and will continue the loop once a message is in its message queue. However, if a message is already in the message queue, the process will continue the loop immediately. Hibernating a <a href="genserver.html"><code class="inline">GenServer</code></a> causes garbage collection and leaves a continuous heap that minimises the memory used by the process.</p>
<p>Hibernating should not be used aggressively as too much time could be spent garbage collecting, which would delay the processing of incoming messages. Normally it should only be used when you are not expecting new messages to immediately arrive and minimising the memory of the process is shown to be beneficial.</p>
<p>Returning <code class="inline">{:reply, reply, new_state, {:continue, continue_arg}}</code> is similar to <code class="inline">{:reply, reply, new_state}</code> except that <a href="#c:handle_continue/2"><code class="inline">handle_continue/2</code></a> will be invoked immediately after with <code class="inline">continue_arg</code> as the first argument and <code class="inline">state</code> as the second one.</p>
<p>Returning <code class="inline">{:noreply, new_state}</code> does not send a response to the caller and continues the loop with new state <code class="inline">new_state</code>. The response must be sent with <a href="#reply/2"><code class="inline">reply/2</code></a>.</p>
<p>There are three main use cases for not replying using the return value:</p>
<ul>
<li>To reply before returning from the callback because the response is known before calling a slow function.</li>
<li>To reply after returning from the callback because the response is not yet available.</li>
<li>To reply from another process, such as a task.</li>
</ul>
<p>When replying from another process the <a href="genserver.html"><code class="inline">GenServer</code></a> should exit if the other process exits without replying as the caller will be blocking awaiting a reply.</p>
<p>Returning <code class="inline">{:noreply, new_state, timeout | :hibernate | {:continue, continue_arg}}</code> is similar to <code class="inline">{:noreply, new_state}</code> except a timeout, hibernation or continue occurs as with a <code class="inline">:reply</code> tuple.</p>
<p>Returning <code class="inline">{:stop, reason, reply, new_state}</code> stops the loop and <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is called with reason <code class="inline">reason</code> and state <code class="inline">new_state</code>. Then, the <code class="inline">reply</code> is sent as the response to call and the process exits with reason <code class="inline">reason</code>.</p>
<p>Returning <code class="inline">{:stop, reason, new_state}</code> is similar to <code class="inline">{:stop, reason, reply, new_state}</code> except a reply is not sent.</p>
<p>This callback is optional. If one is not implemented, the server will fail if a call is performed against it.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_cast/2">handle_cast(request, state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L630" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_cast(request :: term(), state :: term()) ::
  {:noreply, new_state}
  | {:noreply, new_state,
     timeout() | :hibernate | {:continue, continue_arg :: term()}}
  | {:stop, reason :: term(), new_state}
when new_state: term()</pre> </div> <p>Invoked to handle asynchronous <a href="#cast/2"><code class="inline">cast/2</code></a> messages.</p>
<p><code class="inline">request</code> is the request message sent by a <a href="#cast/2"><code class="inline">cast/2</code></a> and <code class="inline">state</code> is the current state of the <a href="genserver.html"><code class="inline">GenServer</code></a>.</p>
<p>Returning <code class="inline">{:noreply, new_state}</code> continues the loop with new state <code class="inline">new_state</code>.</p>
<p>Returning <code class="inline">{:noreply, new_state, timeout}</code> is similar to <code class="inline">{:noreply, new_state}</code> except that it also sets a timeout. See the "Timeouts" section in the module documentation for more information.</p>
<p>Returning <code class="inline">{:noreply, new_state, :hibernate}</code> is similar to <code class="inline">{:noreply, new_state}</code> except the process is hibernated before continuing the loop. See <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> for more information.</p>
<p>Returning <code class="inline">{:noreply, new_state, {:continue, continue_arg}}</code> is similar to <code class="inline">{:noreply, new_state}</code> except <a href="#c:handle_continue/2"><code class="inline">handle_continue/2</code></a> will be invoked immediately after with <code class="inline">continue_arg</code> as the first argument and <code class="inline">state</code> as the second one.</p>
<p>Returning <code class="inline">{:stop, reason, new_state}</code> stops the loop and <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is called with the reason <code class="inline">reason</code> and state <code class="inline">new_state</code>. The process exits with reason <code class="inline">reason</code>.</p>
<p>This callback is optional. If one is not implemented, the server will fail if a cast is performed against it.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_continue/2">handle_continue(continue_arg, state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L664" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_continue(continue_arg, state :: term()) ::
  {:noreply, new_state}
  | {:noreply, new_state, timeout() | :hibernate | {:continue, continue_arg}}
  | {:stop, reason :: term(), new_state}
when new_state: term(), continue_arg: term()</pre> </div> <p>Invoked to handle continue instructions.</p>
<p>It is useful for performing work after initialization or for splitting the work in a callback in multiple steps, updating the process state along the way.</p>
<p>Return values are the same as <a href="#c:handle_cast/2"><code class="inline">handle_cast/2</code></a>.</p>
<p>This callback is optional. If one is not implemented, the server will fail if a continue instruction is used.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:handle_info/2">handle_info(msg, state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L647" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback handle_info(msg :: :timeout | term(), state :: term()) ::
  {:noreply, new_state}
  | {:noreply, new_state,
     timeout() | :hibernate | {:continue, continue_arg :: term()}}
  | {:stop, reason :: term(), new_state}
when new_state: term()</pre> </div> <p>Invoked to handle all other messages.</p>
<p><code class="inline">msg</code> is the message and <code class="inline">state</code> is the current state of the <a href="genserver.html"><code class="inline">GenServer</code></a>. When a timeout occurs the message is <code class="inline">:timeout</code>.</p>
<p>Return values are the same as <a href="#c:handle_cast/2"><code class="inline">handle_cast/2</code></a>.</p>
<p>This callback is optional. If one is not implemented, the received message will be logged.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:init/1">init(init_arg)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L522" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback init(init_arg :: term()) ::
  {:ok, state}
  | {:ok, state, timeout() | :hibernate | {:continue, continue_arg :: term()}}
  | :ignore
  | {:stop, reason :: term()}
when state: term()</pre> </div> <p>Invoked when the server is started. <a href="#start_link/3"><code class="inline">start_link/3</code></a> or <a href="#start/3"><code class="inline">start/3</code></a> will block until it returns.</p>
<p><code class="inline">init_arg</code> is the argument term (second argument) passed to <a href="#start_link/3"><code class="inline">start_link/3</code></a>.</p>
<p>Returning <code class="inline">{:ok, state}</code> will cause <a href="#start_link/3"><code class="inline">start_link/3</code></a> to return <code class="inline">{:ok, pid}</code> and the process to enter its loop.</p>
<p>Returning <code class="inline">{:ok, state, timeout}</code> is similar to <code class="inline">{:ok, state}</code>, except that it also sets a timeout. See the "Timeouts" section in the module documentation for more information.</p>
<p>Returning <code class="inline">{:ok, state, :hibernate}</code> is similar to <code class="inline">{:ok, state}</code> except the process is hibernated before entering the loop. See <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> for more information on hibernation.</p>
<p>Returning <code class="inline">{:ok, state, {:continue, continue_arg}}</code> is similar to <code class="inline">{:ok, state}</code> except that immediately after entering the loop, the <a href="#c:handle_continue/2"><code class="inline">handle_continue/2</code></a> callback will be invoked with <code class="inline">continue_arg</code> as the first argument and <code class="inline">state</code> as the second one.</p>
<p>Returning <code class="inline">:ignore</code> will cause <a href="#start_link/3"><code class="inline">start_link/3</code></a> to return <code class="inline">:ignore</code> and the process will exit normally without entering the loop or calling <a href="#c:terminate/2"><code class="inline">terminate/2</code></a>. If used when part of a supervision tree the parent supervisor will not fail to start nor immediately try to restart the <a href="genserver.html"><code class="inline">GenServer</code></a>. The remainder of the supervision tree will be started and so the <a href="genserver.html"><code class="inline">GenServer</code></a> should not be required by other processes. It can be started later with <a href="supervisor.html#restart_child/2"><code class="inline">Supervisor.restart_child/2</code></a> as the child specification is saved in the parent supervisor. The main use cases for this are:</p>
<ul>
<li>The <a href="genserver.html"><code class="inline">GenServer</code></a> is disabled by configuration but might be enabled later.</li>
<li>An error occurred and it will be handled by a different mechanism than the <a href="supervisor.html"><code class="inline">Supervisor</code></a>. Likely this approach involves calling <a href="supervisor.html#restart_child/2"><code class="inline">Supervisor.restart_child/2</code></a> after a delay to attempt a restart.</li>
</ul>
<p>Returning <code class="inline">{:stop, reason}</code> will cause <a href="#start_link/3"><code class="inline">start_link/3</code></a> to return <code class="inline">{:error, reason}</code> and the process to exit with reason <code class="inline">reason</code> without entering the loop or calling <a href="#c:terminate/2"><code class="inline">terminate/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="c:terminate/2">terminate(reason, state)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L732" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@callback terminate(reason, state :: term()) :: term()
when reason: :normal | :shutdown | {:shutdown, term()} | term()</pre> </div> <p>Invoked when the server is about to exit. It should do any cleanup required.</p>
<p><code class="inline">reason</code> is exit reason and <code class="inline">state</code> is the current state of the <a href="genserver.html"><code class="inline">GenServer</code></a>. The return value is ignored.</p>
<p><a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is useful for cleanup that requires access to the <a href="genserver.html"><code class="inline">GenServer</code></a>'s state. However, it is <strong>not guaranteed</strong> that <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is called when a <a href="genserver.html"><code class="inline">GenServer</code></a> exits. Therefore, important cleanup should be done using process links and/or monitors. A monitoring process will receive the same exit <code class="inline">reason</code> that would be passed to <a href="#c:terminate/2"><code class="inline">terminate/2</code></a>.</p>
<p><a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is called if:</p>
<ul>
<li><p>the <a href="genserver.html"><code class="inline">GenServer</code></a> traps exits (using <a href="process.html#flag/2"><code class="inline">Process.flag/2</code></a>) <em>and</em> the parent process (the one which called <code class="inline">start_link/1</code>) sends an exit signal</p></li>
<li>
<p>a callback (except <a href="#c:init/1"><code class="inline">init/1</code></a>) does one of the following:</p>
<ul>
<li><p>returns a <code class="inline">:stop</code> tuple</p></li>
<li><p>raises (via <a href="kernel.html#raise/2"><code class="inline">raise/2</code></a>) or exits (via <a href="kernel.html#exit/1"><code class="inline">exit/1</code></a>)</p></li>
<li><p>returns an invalid value</p></li>
</ul>
</li>
</ul>
<p>If part of a supervision tree, a <a href="genserver.html"><code class="inline">GenServer</code></a> will receive an exit signal from its parent process (its supervisor) when the tree is shutting down. The exit signal is based on the shutdown strategy in the child's specification, where this value can be:</p>
<ul>
<li><p><code class="inline">:brutal_kill</code>: the <a href="genserver.html"><code class="inline">GenServer</code></a> is killed and so <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is not called.</p></li>
<li><p>a timeout value, where the supervisor will send the exit signal <code class="inline">:shutdown</code> and the <a href="genserver.html"><code class="inline">GenServer</code></a> will have the duration of the timeout to terminate. If after duration of this timeout the process is still alive, it will be killed immediately.</p></li>
</ul>
<p>For a more in-depth explanation, please read the "Shutdown values (:shutdown)" section in the <a href="supervisor.html"><code class="inline">Supervisor</code></a> module.</p>
<p>If the <a href="genserver.html"><code class="inline">GenServer</code></a> receives an exit signal (that is not <code class="inline">:normal</code>) from any process when it is not trapping exits it will exit abruptly with the same reason and so not call <a href="#c:terminate/2"><code class="inline">terminate/2</code></a>. Note that a process does <em>NOT</em> trap exits by default and an exit signal is sent when a linked process exits or its node is disconnected.</p>
<p><a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is only called after the <a href="genserver.html"><code class="inline">GenServer</code></a> finishes processing all messages which arrived in its mailbox prior to the exit signal. If it receives a <code class="inline">:kill</code> signal before it finishes processing those, <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> will not be called. If <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> is called, any messages received after the exit signal will still be in the mailbox.</p>
<p>There is no cleanup needed when the <a href="genserver.html"><code class="inline">GenServer</code></a> controls a <code class="inline">port</code> (for example, <code class="inline">:gen_tcp.socket</code>) or <a href="file.html#t:io_device/0"><code class="inline">File.io_device/0</code></a>, because these will be closed on receiving a <a href="genserver.html"><code class="inline">GenServer</code></a>'s exit signal and do not need to be closed manually in <a href="#c:terminate/2"><code class="inline">terminate/2</code></a>.</p>
<p>If <code class="inline">reason</code> is neither <code class="inline">:normal</code>, <code class="inline">:shutdown</code>, nor <code class="inline">{:shutdown, term}</code> an error is logged.</p>
<p>This callback is optional.</p> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="abcast/3">abcast(nodes \\ [node() | Node.list()], name, request)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1181" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec abcast([node()], name :: atom(), term()) :: :abcast</pre> </div> <p>Casts all servers locally registered as <code class="inline">name</code> at the specified nodes.</p>
<p>This function returns immediately and ignores nodes that do not exist, or where the server name does not exist.</p>
<p>See <a href="#multi_call/4"><code class="inline">multi_call/4</code></a> for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="call/3">call(server, request, timeout \\ 5000)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1117" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec call(server(), term(), timeout()) :: term()</pre> </div> <p>Makes a synchronous call to the <code class="inline">server</code> and waits for its reply.</p>
<p>The client sends the given <code class="inline">request</code> to the server and waits until a reply arrives or a timeout occurs. <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> will be called on the server to handle the request.</p>
<p><code class="inline">server</code> can be any of the values described in the "Name registration" section of the documentation for this module.</p>
<h4 id="call/3-timeouts" class="section-heading">  <span class="text">Timeouts</span> </h4> <p><code class="inline">timeout</code> is an integer greater than zero which specifies how many milliseconds to wait for a reply, or the atom <code class="inline">:infinity</code> to wait indefinitely. The default value is <code class="inline">5000</code>. If no reply is received within the specified time, the function call fails and the caller exits. If the caller catches the failure and continues running, and the server is just late with the reply, it may arrive at any time later into the caller's message queue. The caller must in this case be prepared for this and discard any such garbage messages that are two-element tuples with a reference as the first element.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="cast/2">cast(server, request)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1147" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec cast(server(), term()) :: :ok</pre> </div> <p>Casts a request to the <code class="inline">server</code> without waiting for a response.</p>
<p>This function always returns <code class="inline">:ok</code> regardless of whether the destination <code class="inline">server</code> (or node) exists. Therefore it is unknown whether the destination <code class="inline">server</code> successfully handled the request.</p>
<p><code class="inline">server</code> can be any of the values described in the "Name registration" section of the documentation for this module.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="multi_call/4">multi_call(nodes \\ [node() | Node.list()], name, request, timeout \\ :infinity)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1228" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec multi_call([node()], name :: atom(), term(), timeout()) ::
  {replies :: [{node(), term()}], bad_nodes :: [node()]}</pre> </div> <p>Calls all servers locally registered as <code class="inline">name</code> at the specified <code class="inline">nodes</code>.</p>
<p>First, the <code class="inline">request</code> is sent to every node in <code class="inline">nodes</code>; then, the caller waits for the replies. This function returns a two-element tuple <code class="inline">{replies, bad_nodes}</code> where:</p>
<ul>
<li>
<code class="inline">replies</code> - is a list of <code class="inline">{node, reply}</code> tuples where <code class="inline">node</code> is the node that replied and <code class="inline">reply</code> is its reply</li>
<li>
<code class="inline">bad_nodes</code> - is a list of nodes that either did not exist or where a server with the given <code class="inline">name</code> did not exist or did not reply</li>
</ul>
<p><code class="inline">nodes</code> is a list of node names to which the request is sent. The default value is the list of all known nodes (including this node).</p>
<h4 id="multi_call/4-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Assuming the <code class="inline">Stack</code> GenServer mentioned in the docs for the <a href="genserver.html"><code class="inline">GenServer</code></a> module is registered as <code class="inline">Stack</code> in the <code class="inline">:"foo@my-machine"</code> and <code class="inline">:"bar@my-machine"</code> nodes:</p>
<pre data-language="elixir">GenServer.multi_call(Stack, :pop)
#=&gt; {[{:"foo@my-machine", :hello}, {:"bar@my-machine", :world}], []}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="reply/2">reply(client, reply)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1263" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reply(from(), term()) :: :ok</pre> </div> <p>Replies to a client.</p>
<p>This function can be used to explicitly send a reply to a client that called <a href="#call/3"><code class="inline">call/3</code></a> or <a href="#multi_call/4"><code class="inline">multi_call/4</code></a> when the reply cannot be specified in the return value of <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a>.</p>
<p><code class="inline">client</code> must be the <code class="inline">from</code> argument (the second argument) accepted by <a href="#c:handle_call/3"><code class="inline">handle_call/3</code></a> callbacks. <code class="inline">reply</code> is an arbitrary term which will be given back to the client as the return value of the call.</p>
<p>Note that <a href="#reply/2"><code class="inline">reply/2</code></a> can be called from any process, not just the GenServer that originally received the call (as long as that GenServer communicated the <code class="inline">from</code> argument somehow).</p>
<p>This function always returns <code class="inline">:ok</code>.</p>
<h4 id="reply/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">def handle_call(:reply_in_one_second, from, state) do
  Process.send_after(self(), {:reply, from}, 1_000)
  {:noreply, state}
end

def handle_info({:reply, from}, state) do
  GenServer.reply(from, :one_second_has_passed)
  {:noreply, state}
end</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="start/3">start(module, init_arg, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1032" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec start(module(), term(), options()) :: on_start()</pre> </div> <p>Starts a <a href="genserver.html"><code class="inline">GenServer</code></a> process without links (outside of a supervision tree).</p>
<p>See <a href="#start_link/3"><code class="inline">start_link/3</code></a> for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="start_link/3">start_link(module, init_arg, options \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1022" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec start_link(module(), term(), options()) :: on_start()</pre> </div> <p>Starts a <a href="genserver.html"><code class="inline">GenServer</code></a> process linked to the current process.</p>
<p>This is often used to start the <a href="genserver.html"><code class="inline">GenServer</code></a> as part of a supervision tree.</p>
<p>Once the server is started, the <a href="#c:init/1"><code class="inline">init/1</code></a> function of the given <code class="inline">module</code> is called with <code class="inline">init_arg</code> as its argument to initialize the server. To ensure a synchronized start-up procedure, this function does not return until <a href="#c:init/1"><code class="inline">init/1</code></a> has returned.</p>
<p>Note that a <a href="genserver.html"><code class="inline">GenServer</code></a> started with <a href="#start_link/3"><code class="inline">start_link/3</code></a> is linked to the parent process and will exit in case of crashes from the parent. The GenServer will also exit due to the <code class="inline">:normal</code> reasons in case it is configured to trap exits in the <a href="#c:init/1"><code class="inline">init/1</code></a> callback.</p>
<h4 id="start_link/3-options" class="section-heading">  <span class="text">Options</span> </h4> <ul>
<li><p><code class="inline">:name</code> - used for name registration as described in the "Name registration" section in the documentation for <a href="genserver.html"><code class="inline">GenServer</code></a></p></li>
<li><p><code class="inline">:timeout</code> - if present, the server is allowed to spend the given number of milliseconds initializing or it will be terminated and the start function will return <code class="inline">{:error, :timeout}</code></p></li>
<li><p><code class="inline">:debug</code> - if present, the corresponding function in the <a href="https://www.erlang.org/doc/apps/stdlib/sys.html"><code class="inline">:sys</code> module</a> is invoked</p></li>
<li><p><code class="inline">:spawn_opt</code> - if present, its value is passed as options to the underlying process as in <a href="process.html#spawn/4"><code class="inline">Process.spawn/4</code></a></p></li>
<li><p><code class="inline">:hibernate_after</code> - if present, the GenServer process awaits any message for the given number of milliseconds and if no message is received, the process goes into hibernation automatically (by calling <a href="https://www.erlang.org/doc/apps/stdlib/proc_lib.html#hibernate/3"><code class="inline">:proc_lib.hibernate/3</code></a>).</p></li>
</ul>
<h4 id="start_link/3-return-values" class="section-heading">  <span class="text">Return values</span> </h4> <p>If the server is successfully created and initialized, this function returns <code class="inline">{:ok, pid}</code>, where <code class="inline">pid</code> is the PID of the server. If a process with the specified server name already exists, this function returns <code class="inline">{:error, {:already_started, pid}}</code> with the PID of that process.</p>
<p>If the <a href="#c:init/1"><code class="inline">init/1</code></a> callback fails with <code class="inline">reason</code>, this function returns <code class="inline">{:error, reason}</code>. Otherwise, if it returns <code class="inline">{:stop, reason}</code> or <code class="inline">:ignore</code>, the process is terminated and this function returns <code class="inline">{:error, reason}</code> or <code class="inline">:ignore</code>, respectively.</p> </section> </section> <section class="detail">   <h3 class="detail-header" id="stop/3">stop(server, reason \\ :normal, timeout \\ :infinity)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1076" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec stop(server(), reason :: term(), timeout()) :: :ok</pre> </div> <p>Synchronously stops the server with the given <code class="inline">reason</code>.</p>
<p>The <a href="#c:terminate/2"><code class="inline">terminate/2</code></a> callback of the given <code class="inline">server</code> will be invoked before exiting. This function returns <code class="inline">:ok</code> if the server terminates with the given reason; if it terminates with another reason, the call exits.</p>
<p>This function keeps OTP semantics regarding error reporting. If the reason is any other than <code class="inline">:normal</code>, <code class="inline">:shutdown</code> or <code class="inline">{:shutdown, _}</code>, an error report is logged.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="whereis/1">whereis(server)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/gen_server.ex#L1284" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec whereis(server()) :: pid() | {atom(), node()} | nil</pre> </div> <p>Returns the <code class="inline">pid</code> or <code class="inline">{name, node}</code> of a GenServer process, <code class="inline">nil</code> otherwise.</p>
<p>To be precise, <code class="inline">nil</code> is returned whenever a <code class="inline">pid</code> or <code class="inline">{name, node}</code> cannot be returned. Note there is no guarantee the returned <code class="inline">pid</code> or <code class="inline">{name, node}</code> is alive, as a process could terminate immediately after it is looked up.</p>
<h4 id="whereis/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>For example, to lookup a server process, monitor it and send a cast to it:</p>
<pre data-language="elixir">process = GenServer.whereis(server)
monitor = Process.monitor(process)
GenServer.cast(process, :hello)</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/GenServer.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/GenServer.html</a>
  </p>
</div>
