<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">Logger</span>  </h1> <section id="moduledoc"> <p>A logger for Elixir applications.</p>
<p>This application is mostly a wrapper around Erlang's <a href="https://www.erlang.org/doc/apps/kernel/logger.html"><code class="inline">:logger</code></a> functionality, to provide message translation and formatting to Elixir terms.</p>
<p>Overall, you will find that <a href="logger.html"><code class="inline">Logger</code></a>:</p>
<ul>
<li><p>Provides all 7 syslog levels (although debug, info, warning, and error are the most commonly used).</p></li>
<li><p>Supports both message-based and structural logging.</p></li>
<li><p>Integrate with Erlang's <a href="https://www.erlang.org/doc/apps/kernel/logger.html"><code class="inline">:logger</code></a> and support custom filters and handlers.</p></li>
<li><p>Formats and truncates messages on the client to avoid clogging <a href="logger.html"><code class="inline">Logger</code></a> handlers.</p></li>
<li>
<p>Provides multiple forms of <a href="https://www.erlang.org/doc/apps/kernel/logger_chapter.html#protecting-the-handler-from-overload">overload protection</a>:</p>
<ul>
<li>keeps track of its message queue and switches to sync mode to apply back pressure or even drop messages</li>
<li>limits the number of logs emitted defaulting to 500 per second</li>
<li>optionally allows to terminate and restart it if the message queue length or memory thresholds are exceeded</li>
</ul>
</li>
<li><p>Allows overriding the logging level for a specific module, application or process.</p></li>
</ul>
<p>Logging is useful for tracking when an event of interest happens in your system. For example, it may be helpful to log whenever a user is deleted.</p>
<pre data-language="elixir">def delete_user(user) do
  Logger.info("Deleting user from the system: #{inspect(user)}")
  # ...
end</pre>
<p>The <a href="#info/2"><code class="inline">Logger.info/2</code></a> macro emits the provided message at the <code class="inline">:info</code> level. Note the arguments given to <a href="#info/2"><code class="inline">info/2</code></a> will only be evaluated if a message is logged. For instance, if the Logger level is set to <code class="inline">:warning</code>, <code class="inline">:info</code> messages are never logged and therefore the arguments given above won't even be executed.</p>
<p>There are additional macros for other levels.</p>
<p>Logger also allows log commands to be removed altogether via the <code class="inline">:compile_time_purge_matching</code> option (see below).</p>
<p>For dynamically logging messages, see <a href="#bare_log/3"><code class="inline">bare_log/3</code></a>. But note that <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> always evaluates its arguments (unless the argument is an anonymous function).</p>
<h2 id="module-levels" class="section-heading">  <span class="text">Levels</span> </h2> <p>The supported levels, ordered by importance, are:</p>
<ul>
<li>
<code class="inline">:emergency</code> - when system is unusable, panics</li>
<li>
<code class="inline">:alert</code> - for alerts, actions that must be taken immediately, ex. corrupted database</li>
<li>
<code class="inline">:critical</code> - for critical conditions</li>
<li>
<code class="inline">:error</code> - for errors</li>
<li>
<code class="inline">:warning</code> - for warnings</li>
<li>
<code class="inline">:notice</code> - for normal, but significant, messages</li>
<li>
<code class="inline">:info</code> - for information of any kind</li>
<li>
<code class="inline">:debug</code> - for debug-related messages</li>
</ul>
<p>For example, <code class="inline">:info</code> takes precedence over <code class="inline">:debug</code>. If your log level is set to <code class="inline">:info</code>, then all <code class="inline">:info</code>, <code class="inline">:notice</code> and above will be passed to handlers. If your log level is set to <code class="inline">:alert</code>, only <code class="inline">:alert</code> and <code class="inline">:emergency</code> will be printed.</p>
<h2 id="module-message" class="section-heading">  <span class="text">Message</span> </h2> <p>Logger can be used for logging both unstructured and structured data.</p>
<p>Unstructured data is a string or a list of strings:</p>
<pre data-language="elixir">Logger.info("hello world!")
Logger.info(["hello ", "world!"])</pre>
<p>Structured data, also known as reports, are keyword lists and maps:</p>
<pre data-language="elixir">Logger.info([new_user: user.id, account_type: :admin])
Logger.info(%{new_user: user.id, account_type: :admin})</pre>
<p>Log functions also accept a zero-arity anonymous function as a message:</p>
<pre data-language="elixir">Logger.info(fn -&gt; "hello world!" end)</pre>
<p>The anonymous function can return a message or a tuple containing the message and additional metadata (to be described in the next section).</p>
<p>In all cases, the arguments given to the <a href="logger.html"><code class="inline">Logger</code></a> macros are only evaluated if required by the current log level. The exception is the <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> function, which is the raw mechanism for logging.</p>
<h2 id="module-metadata" class="section-heading">  <span class="text">Metadata</span> </h2> <p>Whenever a message is logged, additional information can be given via metadata. Each log operation, such as <a href="#info/2"><code class="inline">Logger.info/2</code></a>, allows metadata to be given as an argument.</p>
<p>Furthermore, metadata can be set per process with <a href="#metadata/1"><code class="inline">Logger.metadata/1</code></a>.</p>
<p>Some metadata, however, may be added automatically by Logger whenever possible. Those are:</p>
<ul>
<li><p><code class="inline">:application</code> - the current application</p></li>
<li><p><code class="inline">:mfa</code> - the current module, function and arity</p></li>
<li><p><code class="inline">:file</code> - the current file</p></li>
<li><p><code class="inline">:line</code> - the current line</p></li>
<li><p><code class="inline">:pid</code> - the current process identifier</p></li>
<li><p><code class="inline">:initial_call</code> - the initial call that started the process</p></li>
<li><p><code class="inline">:registered_name</code> - the process registered name as an atom</p></li>
<li><p><code class="inline">:process_label</code> - (available from Erlang/OTP 27+) an arbitrary term which can be added to a process with <a href="https://hexdocs.pm/elixir/1.18.1/Process.html#set_label/1"><code class="inline">Process.set_label/1</code></a> for debugging purposes</p></li>
<li><p><code class="inline">:domain</code> - a list of domains for the logged message. For example, all Elixir reports default to <code class="inline">[:elixir]</code>. Erlang reports may start with <code class="inline">[:otp]</code> or <code class="inline">[:sasl]</code></p></li>
<li><p><code class="inline">:crash_reason</code> - a two-element tuple with the throw/error/exit reason as first argument and the stacktrace as second. A throw will always be <code class="inline">{:nocatch, term}</code>. An error is always an <a href="https://hexdocs.pm/elixir/1.18.1/Exception.html"><code class="inline">Exception</code></a> struct. All other entries are exits. The default formatter ignores this metadata by default but it can be useful to certain handlers, such as the ones that report errors to third-party services</p></li>
</ul>
<p>There are two special metadata keys, <code class="inline">:module</code> and <code class="inline">:function</code>, which extract the relevant bits from <code class="inline">:mfa</code>.</p>
<p>The metadata keys above may not always be available. The <code class="inline">:mfa</code>, <code class="inline">:file</code>, <code class="inline">:line</code>, and similar metadata are automatically included when using <a href="logger.html"><code class="inline">Logger</code></a> macros, but not when using <a href="#bare_log/3"><code class="inline">Logger.bare_log/3</code></a>. Other metadata, such as <code class="inline">:crash_reason</code>, <code class="inline">:initial_call</code>, and <code class="inline">:registered_name</code> are available only inside behaviours such as GenServer, Supervisor, and others.</p>
<p>It is also possible to pass metadata on a particular Logger invocation. For example, you might wish to include a custom <code class="inline">:error_code</code> metadata in your logs:</p>
<pre data-language="elixir">Logger.error("We have a problem", [error_code: :pc_load_letter])</pre>
<p>By default, no metadata is logged. We will learn how to enable that over the next sections.</p>
<h2 id="module-configuration" class="section-heading">  <span class="text">Configuration</span> </h2> <p><a href="logger.html"><code class="inline">Logger</code></a> supports a wide range of configurations.</p>
<p>This configuration is split in three categories:</p>
<ul>
<li><p>Boot configuration - this configuration is read when logger starts and configures how Elixir hooks into Erlang's own logger</p></li>
<li><p>Compile configuration - this must be set before your code is compiled</p></li>
<li><p>Runtime configuration - can be set before the <code class="inline">:logger</code> application is started, but may be changed during runtime</p></li>
</ul>
<h3 id="module-boot-configuration" class="section-heading">  <span class="text">Boot configuration</span> </h3> <p>When <a href="logger.html"><code class="inline">Logger</code></a> starts, it configures the <code class="inline">:default</code> log handler from Erlang to translate and format Elixir terms. As a developer, you are able to customize the default handler, the default formatter, and many other options.</p>
<p>The following configuration must be set via config files (such as <code class="inline">config/config.exs</code>), under the <code class="inline">:logger</code> key, before your application is started:</p>
<ul>
<li><p><code class="inline">:default_formatter</code> - a keyword list which configures the default formatter used by the default handler. See <a href="logger.formatter.html"><code class="inline">Logger.Formatter</code></a> for the full list of configuration.</p></li>
<li><p><code class="inline">:default_handler</code> - this option configures the default handler used for logging. The default handler is a <a href="https://www.erlang.org/doc/apps/kernel/logger_std_h.html"><code class="inline">:logger_std_h</code></a> instance which also supports file logging and log rotation. You can set it to <code class="inline">false</code> to disable the default logging altogether. See the examples below for more information.</p></li>
<li><p><code class="inline">:handle_otp_reports</code> - if Erlang/OTP message should be logged. Defaults to <code class="inline">true</code>.</p></li>
<li><p><code class="inline">:handle_sasl_reports</code> - if supervisor, crash, and progress reports should be logged. Defaults to <code class="inline">false</code>. This option only has an effect if <code class="inline">:handle_otp_reports</code> is true.</p></li>
<li><p><code class="inline">:metadata</code> - key-value pairs of global primary metadata to be included in all log messages. Defaults to <code class="inline">[]</code>. The default formatter writes to standard out and therefore cannot print all metadata. See <a href="logger.formatter.html#module-metadata"><code class="inline">Logger.Formatter</code>'s documentation</a> for more information.</p></li>
</ul>
<p>For example, to configure <a href="logger.html"><code class="inline">Logger</code></a> to redirect all Erlang messages using a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger,
  handle_otp_reports: true,
  handle_sasl_reports: true</pre>
<p>To configure the default formatter, for example, to use a different format and include some metadata:</p>
<pre data-language="elixir">config :logger, :default_formatter,
  format: "[$level] $message $metadata\n",
  metadata: [:error_code, :file]</pre>
<p>Or to configure default handler, for instance, to log into a file with built-in support for log rotation and compression:</p>
<pre data-language="elixir">config :logger, :default_handler,
  config: [
    file: ~c"system.log",
    filesync_repeat_interval: 5000,
    file_check: 5000,
    max_no_bytes: 10_000_000,
    max_no_files: 5,
    compress_on_rotate: true
  ]</pre>
<p>You can find a complete reference on all handler options <a href="https://www.erlang.org/doc/apps/kernel/logger_handler.html#t:config/0">on Erlang/OTP docs</a>. Here is Elixir's default configuration for the default handler:</p>
<pre data-language="elixir">[
  # Do not log messages from other nodes
  filters: [{&amp;:logger_filters.remote_gl/2, :stop}],
  filter_default: :log,
  formatter: &amp;Logger.default_formatter/0,
  level: :all,
  module: :logger_std_h
]</pre>
<p>The <code class="inline">:config</code> customizes a specific handler module. The default handler is <a href="https://www.erlang.org/doc/apps/kernel/logger_std_h.html"><code class="inline">:logger_std_h</code></a>, which logs to standard IO, and you call find all relevant configuration in its module documentation, including information overload protection.</p>
<p>You may also set <code class="inline">:default_handler</code> to false to disable the default logging altogether:</p>
<pre data-language="elixir">config :logger, :default_handler, false</pre>
<p>How to add more handlers besides the default one is covered in later sections.</p>
<section role="note" class="admonition tip"><h4 class="admonition-title tip">Keywords or maps</h4>
<p>While Erlang's logger expects <code class="inline">:config</code> to be a map, Elixir's Logger allows the default handler configuration to be set with keyword lists. For example, this allows your <code class="inline">config/*.exs</code> files, such as <code class="inline">config/dev.exs</code>, to override individual keys defined in <code class="inline">config/config.exs</code>.</p>
<p>When reading the handler configuration using Erlang's APIs, the configuration will always be read (and written) as a map.</p></section><h3 id="module-compile-configuration" class="section-heading">  <span class="text">Compile configuration</span> </h3> <p>The following configuration must be set via config files (such as <code class="inline">config/config.exs</code>) under the <code class="inline">:logger</code> application before your code is compiled:</p>
<ul>
<li><p><code class="inline">:always_evaluate_messages</code> - if messages should be <em>evaluated</em> even if the log level is lower than the minimum configured level. Defaults to <code class="inline">false</code>. This is useful for cases where the log level in your <em>test environment</em> is high (such as <code class="inline">:error</code>), which is common in order to avoid logs mixed with the test output. In such, cases, you might discover log messages that contain runtime errors only when your code is deployed to production, where the log level is lower (such as <code class="inline">:info</code>). These runtime errors could be caused by, for example, interpolating something that doesn't implement the <a href="https://hexdocs.pm/elixir/1.18.1/String.Chars.html"><code class="inline">String.Chars</code></a> protocol in the log message, such as <code class="inline">"PID: #{self()}"</code> (since PIDs cannot be converted to strings with <a href="https://hexdocs.pm/elixir/1.18.1/String.Chars.html"><code class="inline">String.Chars</code></a>).</p></li>
<li><p><code class="inline">:compile_time_application</code> - sets the <code class="inline">:application</code> metadata value to the configured value at compilation time. This configuration is automatically set by Mix and made available as metadata when logging.</p></li>
<li>
<p><code class="inline">:compile_time_purge_matching</code> - purges <em>at compilation time</em> all calls that match the given conditions. This means that <a href="logger.html"><code class="inline">Logger</code></a> calls with level lower than this option will be completely removed at compile time, accruing no overhead at runtime. This configuration expects a list of keyword lists. Each keyword list contains a metadata key and the matching value that should be purged. Some special keys are supported:</p>
<ul>
<li>
<code class="inline">:level_lower_than</code> - purges all messages with a lower logger level</li>
<li>
<code class="inline">:module</code> - purges all messages with the matching module</li>
<li>
<code class="inline">:function</code> - purges all messages with the "function/arity"</li>
</ul>
<p>Remember that if you want to purge log calls from a dependency, the dependency must be recompiled.</p>
</li>
</ul>
<p>For example, to purge all calls that happen at compile time with level lower than <code class="inline">:info</code> in a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger,
  compile_time_purge_matching: [
    [level_lower_than: :info]
  ]</pre>
<p>If you want to purge all log calls from an application named <code class="inline">:foo</code> and only keep errors from <code class="inline">Bar.foo/3</code>, you can set up two different matches:</p>
<pre data-language="elixir">config :logger,
  compile_time_purge_matching: [
    [application: :foo],
    [module: Bar, function: "foo/3", level_lower_than: :error]
  ]</pre>
<h3 id="module-runtime-configuration" class="section-heading">  <span class="text">Runtime Configuration</span> </h3> <p>All configuration below can be set via config files (such as <code class="inline">config/config.exs</code>) but also changed dynamically during runtime via <a href="#configure/1"><code class="inline">Logger.configure/1</code></a>.</p>
<ul>
<li>
<p><code class="inline">:level</code> - the logging level. Attempting to log any message with severity less than the configured level will simply cause the message to be ignored. Keep in mind that each handler may have its specific level, too. In addition to levels mentioned above it also supports 2 "meta-levels":</p>
<ul>
<li>
<code class="inline">:all</code> - all messages will be logged, conceptually identical to <code class="inline">:debug</code>
</li>
<li>
<code class="inline">:none</code> - no messages will be logged at all</li>
</ul>
</li>
<li><p><code class="inline">:translator_inspect_opts</code> - when translating OTP reports and errors, the last message and state must be inspected in the error reports. This configuration allow developers to change how much and how the data should be inspected.</p></li>
</ul>
<p>For example, to configure the <code class="inline">:level</code> options in a <code class="inline">config/config.exs</code> file:</p>
<pre data-language="elixir">config :logger, level: :warning</pre>
<p>Furthermore, <a href="logger.html"><code class="inline">Logger</code></a> allows messages sent by Erlang to be translated into an Elixir format via translators. Translators can be added at any time with the <a href="#add_translator/1"><code class="inline">add_translator/1</code></a> and <a href="#remove_translator/1"><code class="inline">remove_translator/1</code></a> APIs. Check <a href="logger.translator.html"><code class="inline">Logger.Translator</code></a> for more information.</p>
<h2 id="module-erlang-otp-handlers" class="section-heading">  <span class="text">Erlang/OTP handlers</span> </h2> <p>Handlers represent the ability to integrate into the logging system to handle each logged message/event. Elixir's Logger automatically sets a default handler based on Erlang's <code class="inline">:logger_std_h</code>, which you can configure using the <code class="inline">:default_handler</code> boot configuration outlined above. You may also attach additional handlers when you boot your application.</p>
<p>To do so, you must list a series of handlers under the <code class="inline">:logger</code> key of your application configuration. For example, to setup an additional handler that writes to a file:</p>
<pre data-language="elixir">config :my_app, :logger, [
  {:handler, :file_log, :logger_std_h, %{
     config: %{
       file: ~c"system.log",
       filesync_repeat_interval: 5000,
       file_check: 5000,
       max_no_bytes: 10_000_000,
       max_no_files: 5,
       compress_on_rotate: true
     },
     formatter: Logger.Formatter.new()
   }}
]</pre>
<p>Each handler has the shape <code class="inline">{:handler, name, handler_module, config_map}</code>. Once defined, a handler can be explicitly attached in your <a href="https://hexdocs.pm/elixir/1.18.1/Application.html#c:start/2"><code class="inline">Application.start/2</code></a> callback with <a href="#add_handlers/1"><code class="inline">add_handlers/1</code></a>:</p>
<pre data-language="elixir">Logger.add_handlers(:my_app)</pre>
<p>You can also add, remove, and update handlers at runtime with the help of the Erlang's <a href="https://www.erlang.org/doc/apps/kernel/logger.html"><code class="inline">:logger</code></a> module.</p>
<p>You may also develop your own handlers. Handlers run in the same process as the process logging the message/event. This gives developers flexibility but they should avoid performing any long running action in such handlers, as it may slow down the action being executed considerably. At the moment, there is no built-in overload protection for Erlang handlers, so it is your responsibility to implement it.</p>
<p>Alternatively, you can use the <a href="https://github.com/elixir-lang/logger_backends"><code class="inline">:logger_backends</code></a> project. It sets up a log handler with overload protection and allows incoming events to be dispatched to multiple backends.</p>
<h3 id="module-filtering" class="section-heading">  <span class="text">Filtering</span> </h3> <p>You can add filters to any handler. For example, to filter out logs that contain a particular string, you could create a module:</p>
<pre data-language="elixir">defmodule LogFilter do
  def filter(log_event, _opts) do
    case log_event do
      %{msg: msg} when is_binary(msg) -&gt;
        if msg =~ "password" do
          :stop
        else
          :ignore
        end

      _ -&gt;
        :ignore
    end
  end
end</pre>
<p>It may return <code class="inline">:log</code> (to log the message), <code class="inline">:stop</code> (to not log the message), or <code class="inline">:ignore</code> (to ignore the filter).</p>
<p>Then you can attach the filter, either as a primary filter (which applies to all handlers), or to a specific handler, when you start your application, such as in the <a href="https://hexdocs.pm/elixir/1.18.1/Application.html#c:start/2"><code class="inline">Application.start/2</code></a> callback:</p>
<pre data-language="elixir">:logger.add_primary_filter(:word_filter, {&amp;LogFilter.filter/2, []})</pre>
<h2 id="module-backends-and-backwards-compatibility" class="section-heading">  <span class="text">Backends and backwards compatibility</span> </h2> <p>Prior to Elixir v1.15, custom logging could be achieved with Logger backends. The main API for writing Logger backends have been moved to the <a href="https://github.com/elixir-lang/logger_backends"><code class="inline">:logger_backends</code></a> project. However, the backends API is still part of Elixir for backwards compatibility.</p>
<p>Important remarks:</p>
<ul>
<li><p>If the <code class="inline">:backends</code> key is set and it doesn't have the <code class="inline">:console</code> entry, we assume that you want to disable the built-in logging. You can force logging by setting <code class="inline">config :logger, :default_handler, []</code></p></li>
<li>
<p>The <code class="inline">:console</code> backend configuration is automatically mapped to the default handler and default formatter. Previously, you would set:</p>
<pre data-language="elixir">config :logger, :console,
  level: :error,
  format: "$time $message $metadata"</pre>
<p>This is now equivalent to:</p>
<pre data-language="elixir">config :logger, :default_handler,
  level: :error

config :logger, :default_formatter,
  format: "$time $message $metadata"</pre>
<p>All previous console configuration, except for <code class="inline">:level</code>, now go under <code class="inline">:default_formatter</code>.</p>
</li>
<li><p>If you want to use the previous <code class="inline">:console</code> implementation based on Logger Backends, you can still set <code class="inline">backends: [Logger.Backends.Console]</code> and place the configuration under <code class="inline">config :logger, Logger.Backends.Console</code>. Although consider using the <a href="https://github.com/elixir-lang/logger_backends"><code class="inline">:logger_backends</code></a> project in such cases, as <a href="logger.backends.console.html"><code class="inline">Logger.Backends.Console</code></a> itself will be deprecated in future releases</p></li>
<li><p><code class="inline">Logger.Backends</code> only receive <code class="inline">:debug</code>, <code class="inline">:info</code>, <code class="inline">:warning</code>, and <code class="inline">:error</code> messages. <code class="inline">:notice</code> maps to <code class="inline">:info</code>. <code class="inline">:warn</code> maps to <code class="inline">:warnings</code>. All others map to <code class="inline">:error</code></p></li>
</ul> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:level/0" data-no-tooltip translate="no">level()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:message/0" data-no-tooltip translate="no">message()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:metadata/0" data-no-tooltip translate="no">metadata()</a> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#t:report/0" data-no-tooltip translate="no">report()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add_backend/2" data-no-tooltip translate="no">add_backend(backend, opts \\ [])</a> <span class="deprecated" title="Use LoggerBackends.add/2 from :logger_backends dependency">deprecated</span> </dt> <dd class="summary-synopsis"><p>Adds a new backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#add_handlers/1" data-no-tooltip translate="no">add_handlers(app)</a> </dt> <dd class="summary-synopsis"><p>Adds the handlers configured in the <code class="inline">:logger</code> application parameter of the given <code class="inline">app</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#add_translator/1" data-no-tooltip translate="no">add_translator(translator)</a> </dt> <dd class="summary-synopsis"><p>Adds a new translator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#alert/2" data-no-tooltip translate="no">alert(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs an alert message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#bare_log/3" data-no-tooltip translate="no">bare_log(level, message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a message dynamically.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare_levels/2" data-no-tooltip translate="no">compare_levels(left, right)</a> </dt> <dd class="summary-synopsis"><p>Compares log levels.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure/1" data-no-tooltip translate="no">configure(options)</a> </dt> <dd class="summary-synopsis"><p>Configures the logger.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#configure_backend/2" data-no-tooltip translate="no">configure_backend(backend, options)</a> <span class="deprecated" title="Use LoggerBackends.configure/2 from :logger_backends dependency">deprecated</span> </dt> <dd class="summary-synopsis"><p>Configures the given backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#critical/2" data-no-tooltip translate="no">critical(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a critical message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#debug/2" data-no-tooltip translate="no">debug(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a debug message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#default_formatter/1" data-no-tooltip translate="no">default_formatter(overrides \\ [])</a> </dt> <dd class="summary-synopsis"><p>Returns the default formatter used by Logger.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_all_module_levels/0" data-no-tooltip translate="no">delete_all_module_levels()</a> </dt> <dd class="summary-synopsis"><p>Resets the logging level for all modules to the primary level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_application_level/1" data-no-tooltip translate="no">delete_application_level(appname)</a> </dt> <dd class="summary-synopsis"><p>Resets logging level for all modules in the given application to the primary level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_module_level/1" data-no-tooltip translate="no">delete_module_level(module)</a> </dt> <dd class="summary-synopsis"><p>Resets the logging level for a given module to the primary level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#delete_process_level/1" data-no-tooltip translate="no">delete_process_level(pid)</a> </dt> <dd class="summary-synopsis"><p>Resets logging level for the current process to the primary level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#disable/1" data-no-tooltip translate="no">disable(pid)</a> <span class="deprecated" title="Use Logger.put_process_level(pid, :none) instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Disables logging for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#emergency/2" data-no-tooltip translate="no">emergency(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs an emergency message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#enable/1" data-no-tooltip translate="no">enable(pid)</a> <span class="deprecated" title="Use Logger.delete_process_level(pid) instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Enables logging for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#enabled?/1" data-no-tooltip translate="no">enabled?(pid)</a> <span class="deprecated" title="Use Logger.get_process_level(pid) instead">deprecated</span> </dt> <dd class="summary-synopsis"><p>Returns whether the logging is enabled for a given process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#error/2" data-no-tooltip translate="no">error(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs an error message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#flush/0" data-no-tooltip translate="no">flush()</a> </dt> <dd class="summary-synopsis"><p>Flushes the logger.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_module_level/1" data-no-tooltip translate="no">get_module_level(mod)</a> </dt> <dd class="summary-synopsis"><p>Gets logging level for given module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#get_process_level/1" data-no-tooltip translate="no">get_process_level(pid)</a> </dt> <dd class="summary-synopsis"><p>Gets logging level for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#info/2" data-no-tooltip translate="no">info(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs an info message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#level/0" data-no-tooltip translate="no">level()</a> </dt> <dd class="summary-synopsis"><p>Retrieves the <a href="logger.html"><code class="inline">Logger</code></a> level.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#levels/0" data-no-tooltip translate="no">levels()</a> </dt> <dd class="summary-synopsis"><p>Returns all the available levels.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#log/3" data-no-tooltip translate="no">log(level, message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a message with the given <code class="inline">level</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#metadata/0" data-no-tooltip translate="no">metadata()</a> </dt> <dd class="summary-synopsis"><p>Reads the current process metadata.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#metadata/1" data-no-tooltip translate="no">metadata(keyword)</a> </dt> <dd class="summary-synopsis"><p>Alters the current process metadata according to the given keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#notice/2" data-no-tooltip translate="no">notice(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a notice message.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_application_level/2" data-no-tooltip translate="no">put_application_level(appname, level)</a> </dt> <dd class="summary-synopsis"><p>Puts logging level for modules in a given application.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_module_level/2" data-no-tooltip translate="no">put_module_level(mod, level)</a> </dt> <dd class="summary-synopsis"><p>Puts logging level for given module.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#put_process_level/2" data-no-tooltip translate="no">put_process_level(pid, level)</a> </dt> <dd class="summary-synopsis"><p>Puts logging level for the current process.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#remove_backend/2" data-no-tooltip translate="no">remove_backend(backend, opts \\ [])</a> <span class="deprecated" title="Use LoggerBackends.remove/2 from :logger_backends dependency">deprecated</span> </dt> <dd class="summary-synopsis"><p>Removes a backend.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#remove_translator/1" data-no-tooltip translate="no">remove_translator(translator)</a> </dt> <dd class="summary-synopsis"><p>Removes a translator.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#reset_metadata/1" data-no-tooltip translate="no">reset_metadata(keyword \\ [])</a> </dt> <dd class="summary-synopsis"><p>Resets the current process metadata to the given keyword list.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#warn/2" data-no-tooltip translate="no">warn(message_or_fun, metadata \\ [])</a> <span class="deprecated" title="Use Logger.warning/2 instead">deprecated</span> </dt> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#warning/2" data-no-tooltip translate="no">warning(message_or_fun, metadata \\ [])</a> </dt> <dd class="summary-synopsis"><p>Logs a warning message.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:level/0">level()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L473" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type level() ::
  :emergency
  | :alert
  | :critical
  | :error
  | :warning
  | :warn
  | :notice
  | :info
  | :debug</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:message/0">message()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L476" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type message() :: :unicode.chardata() | String.Chars.t() | report()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L477" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type metadata() :: keyword()</pre> </div> </section> </section> <section class="detail"> <h3 class="detail-header" id="t:report/0">report()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L475" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type report() :: map() | keyword()</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="add_backend/2">add_backend(backend, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L862" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use LoggerBackends.add/2 from :logger_backends dependency. </div> <section class="docstring"> <p>Adds a new backend.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="add_handlers/1">add_handlers(app)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L853" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec add_handlers(atom()) :: :ok | {:error, term()}</pre> </div> <p>Adds the handlers configured in the <code class="inline">:logger</code> application parameter of the given <code class="inline">app</code>.</p>
<p>This is used to register new handlers into the logging system. See <a href="#module-erlang-otp-handlers">the module documentation</a> for more information.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="add_translator/1">add_translator(translator)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L896" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec add_translator({module(), function :: atom()}) :: :ok</pre> </div> <p>Adds a new translator.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="alert/2">alert(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs an alert message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="alert/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.alert("this is an alert message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.alert([something: :reported, this: :alert])

# as map
Logger.alert(%{this: :alert, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.alert("this is an alert message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.alert("this is an alert message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="bare_log/3">bare_log(level, message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L932" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec bare_log(
  level(),
  message() | (-&gt; message() | {message(), keyword()}),
  keyword()
) :: :ok</pre> </div> <p>Logs a message dynamically.</p>
<p>Opposite to <a href="#log/3"><code class="inline">log/3</code></a>, <a href="#debug/2"><code class="inline">debug/2</code></a>, <a href="#info/2"><code class="inline">info/2</code></a>, and friends, the arguments given to <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> are always evaluated. However, you can pass anonymous functions to <a href="#bare_log/3"><code class="inline">bare_log/3</code></a> and they will only be evaluated if there is something to be logged.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare_levels/2">compare_levels(left, right)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L658" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compare_levels(level(), level()) :: :lt | :eq | :gt</pre> </div> <p>Compares log levels.</p>
<p>Receives two log levels and compares the <code class="inline">left</code> level against the <code class="inline">right</code> level and returns:</p>
<ul>
<li>
<code class="inline">:lt</code> if <code class="inline">left</code> is less than <code class="inline">right</code>
</li>
<li>
<code class="inline">:eq</code> if <code class="inline">left</code> and <code class="inline">right</code> are equal</li>
<li>
<code class="inline">:gt</code> if <code class="inline">left</code> is greater than <code class="inline">right</code>
</li>
</ul>
<h4 id="compare_levels/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; Logger.compare_levels(:debug, :warning)
:lt
iex&gt; Logger.compare_levels(:error, :info)
:gt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure/1">configure(options)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L684" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec configure(keyword()) :: :ok</pre> </div> <p>Configures the logger.</p>
<p>See the "Runtime Configuration" section in the <a href="logger.html"><code class="inline">Logger</code></a> module documentation for the available options. The changes done here are automatically persisted to the <code class="inline">:logger</code> application environment.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="configure_backend/2">configure_backend(backend, options)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L880" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use LoggerBackends.configure/2 from :logger_backends dependency. </div> <section class="docstring"> <p>Configures the given backend.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="critical/2">critical(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a critical message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="critical/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.critical("this is a critical message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.critical([something: :reported, this: :critical])

# as map
Logger.critical(%{this: :critical, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.critical("this is a critical message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.critical("this is a critical message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="debug/2">debug(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a debug message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="debug/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.debug("this is a debug message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.debug([something: :reported, this: :debug])

# as map
Logger.debug(%{this: :debug, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.debug("this is a debug message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.debug("this is a debug message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="default_formatter/1">default_formatter(overrides \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L524" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec default_formatter(keyword()) :: {module(), :logger.formatter_config()}</pre> </div> <p>Returns the default formatter used by Logger.</p>
<p>It returns a <a href="logger.formatter.html"><code class="inline">Logger.Formatter</code></a> built on the <code class="inline">:default_formatter</code> configuration:</p>
<pre data-language="elixir">config :logger, :default_formatter,
  format: "\n$time $metadata[$level] $message\n",
  metadata: [:user_id]</pre>
<p>In case of a list, a set of <code class="inline">overrides</code> can be given to merge into the list. See <a href="logger.formatter.html#new/1"><code class="inline">Logger.Formatter.new/1</code></a> for all options.</p>
<h4 id="default_formatter/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p><a href="logger.html"><code class="inline">Logger</code></a> will automatically load a default formatter into the default handler on boot. However, you can use this function if you wish to programmatically replace a handler formatter. For example, inside tests, you might want to change the formatter settings:</p>
<pre data-language="elixir">setup tags do
  formatter = Logger.default_formatter(colors: [enabled: false])
  :logger.update_handler_config(:default, :formatter, formatter)

  on_exit(fn -&gt;
    :logger.update_handler_config(:default, :formatter, Logger.default_formatter())
  end)
end</pre>
<p>However, note you should not invoke this function inside <code class="inline">config</code> files, as this function expects <a href="logger.html"><code class="inline">Logger</code></a> to already be configured and started. To start a brand new handler with this formatter, use <a href="logger.formatter.html#new/1"><code class="inline">Logger.Formatter.new/1</code></a> instead.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_all_module_levels/0">delete_all_module_levels()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L773" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_all_module_levels() :: :ok</pre> </div> <p>Resets the logging level for all modules to the primary level.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_application_level/1">delete_application_level(appname)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L799" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_application_level(application) ::
  :ok | {:error, {:not_loaded, application}}
when application: atom()</pre> </div> <p>Resets logging level for all modules in the given application to the primary level.</p>
<p>Equivalent of:</p>
<pre data-language="elixir">appname |&gt; Application.spec(:modules) |&gt; Logger.delete_module_level()</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_module_level/1">delete_module_level(module)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L766" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_module_level(module() | [module()]) :: :ok</pre> </div> <p>Resets the logging level for a given module to the primary level.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="delete_process_level/1">delete_process_level(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L838" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec delete_process_level(pid()) :: :ok</pre> </div> <p>Resets logging level for the current process to the primary level.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="disable/1">disable(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L611" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use Logger.put_process_level(pid, :none) instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec disable(pid()) :: :ok</pre> </div> <p>Disables logging for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p>
<p>Equivalent of:</p>
<pre data-language="elixir">put_process_level(pid, :none)</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="emergency/2">emergency(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs an emergency message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="emergency/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.emergency("this is an emergency message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.emergency([something: :reported, this: :emergency])

# as map
Logger.emergency(%{this: :emergency, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.emergency("this is an emergency message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.emergency("this is an emergency message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="enable/1">enable(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L595" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use Logger.delete_process_level(pid) instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec enable(pid()) :: :ok</pre> </div> <p>Enables logging for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p>
<p>Equivalent of:</p>
<pre data-language="elixir">delete_process_level(pid)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="enabled?/1">enabled?(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L623" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use Logger.get_process_level(pid) instead. </div> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec enabled?(pid()) :: boolean()</pre> </div> <p>Returns whether the logging is enabled for a given process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="error/2">error(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs an error message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="error/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.error("this is an error message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.error([something: :reported, this: :error])

# as map
Logger.error(%{this: :error, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.error("this is an error message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.error("this is an error message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="flush/0">flush()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L712" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec flush() :: :ok</pre> </div> <p>Flushes the logger.</p>
<p>This guarantees all logger handlers flush to disk or storage. This is useful for testing but it should be avoided in production, as it could force logger handlers to drop whatever they are doing and flush, even if continuing to buffer would be the most performant option.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_module_level/1">get_module_level(mod)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L759" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_module_level(module() | [module()]) :: [{module(), level() | :all | :none}]</pre> </div> <p>Gets logging level for given module.</p>
<p>The returned value will be the effective value used. If no value was set for a given module, then it will not be present in the returned list.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="get_process_level/1">get_process_level(pid)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L827" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec get_process_level(pid()) :: level() | :all | :none | nil</pre> </div> <p>Gets logging level for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p>
<p>The returned value will be the effective value used. If no value was set for a given process, then <code class="inline">nil</code> is returned.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="info/2">info(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs an info message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="info/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.info("this is an info message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.info([something: :reported, this: :info])

# as map
Logger.info(%{this: :info, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.info("this is an info message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.info("this is an info message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="level/0">level()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L633" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec level() :: level() | :all | :none</pre> </div> <p>Retrieves the <a href="logger.html"><code class="inline">Logger</code></a> level.</p>
<p>The <a href="logger.html"><code class="inline">Logger</code></a> level can be changed via <a href="#configure/1"><code class="inline">configure/1</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="levels/0">levels()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L487" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec levels() :: [level(), ...]</pre> </div> <p>Returns all the available levels.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="log/3">log(level, message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1052" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a message with the given <code class="inline">level</code>.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<p>The macros <a href="#debug/2"><code class="inline">debug/2</code></a>, <a href="#info/2"><code class="inline">info/2</code></a>, <a href="#notice/2"><code class="inline">notice/2</code></a>, <a href="#warning/2"><code class="inline">warning/2</code></a>, <a href="#error/2"><code class="inline">error/2</code></a>, <a href="#critical/2"><code class="inline">critical/2</code></a>, <a href="#alert/2"><code class="inline">alert/2</code></a>, and <a href="#emergency/2"><code class="inline">emergency/2</code></a> are preferred over this macro as they can automatically eliminate the call to <a href="logger.html"><code class="inline">Logger</code></a> altogether at compile time if desired (see the documentation for the <a href="logger.html"><code class="inline">Logger</code></a> module).</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="metadata/0">metadata()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L564" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec metadata() :: metadata()</pre> </div> <p>Reads the current process metadata.</p>
<p>This does not return the "global" logger metadata (set via the <code class="inline">:metadata</code> key in the <code class="inline">:logger</code> application config), but only the process metadata.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="metadata/1">metadata(keyword)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L541" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec metadata(metadata()) :: :ok</pre> </div> <p>Alters the current process metadata according to the given keyword list.</p>
<p>This function will merge the given keyword list into the existing metadata, with the exception of setting a key to <code class="inline">nil</code>, which will remove that key from the metadata.</p>
<p>Note some metadata keys are reserved and cannot be overridden. See <a href="#module-metadata">the module documentation</a> for more information.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="notice/2">notice(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a notice message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="notice/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.notice("this is a notice message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.notice([something: :reported, this: :notice])

# as map
Logger.notice(%{this: :notice, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.notice("this is a notice message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.notice("this is a notice message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_application_level/2">put_application_level(appname, level)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L787" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_application_level(atom(), level() | :all | :none) ::
  :ok | {:error, :not_loaded}</pre> </div> <p>Puts logging level for modules in a given application.</p>
<p>This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project.</p>
<p>Equivalent of:</p>
<pre data-language="elixir">appname |&gt; Application.spec(:modules) |&gt; Logger.put_module_level(level)</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_module_level/2">put_module_level(mod, level)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L748" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_module_level(module() | [module()], level() | :all | :none) ::
  :ok | {:error, term()}</pre> </div> <p>Puts logging level for given module.</p>
<p>This will take priority over the primary level set, so it can be used to increase or decrease verbosity of some parts of the project.</p>
<h4 id="put_module_level/2-example" class="section-heading">  <span class="text">Example</span> </h4> <pre data-language="elixir">defmodule Foo do
  require Logger

  def log, do: Logger.debug("foo")
end

Logger.configure(level: :error)
Logger.put_module_level(Foo, :all)

Foo.log()
# This will print the message even if global level is :error</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="put_process_level/2">put_process_level(pid, level)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L812" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec put_process_level(pid(), level() | :all | :none) :: :ok</pre> </div> <p>Puts logging level for the current process.</p>
<p>Currently the only accepted PID is <code class="inline">self()</code>.</p>
<p>Different from <a href="#put_module_level/2"><code class="inline">put_module_level/2</code></a>, the process level doesn't take priority over the global level, but instead works alongside it. Effectively, the higher logger level is used.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="remove_backend/2">remove_backend(backend, opts \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L871" class="source">Source</a>
</h3> <div class="deprecated"> This function is deprecated. Use LoggerBackends.remove/2 from :logger_backends dependency. </div> <section class="docstring"> <p>Removes a backend.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="remove_translator/1">remove_translator(translator)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L904" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec remove_translator({module(), function :: atom()}) :: :ok</pre> </div> <p>Removes a translator.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="reset_metadata/1">reset_metadata(keyword \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L575" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec reset_metadata(metadata()) :: :ok</pre> </div> <p>Resets the current process metadata to the given keyword list.</p> </section> </section> <section class="detail">  <h3 class="detail-header" id="warn/2">warn(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1037" class="source">Source</a>
</h3> <div class="deprecated"> This macro is deprecated. Use Logger.warning/2 instead. </div>  </section> <section class="detail">  <h3 class="detail-header" id="warning/2">warning(message_or_fun, metadata \\ [])<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/logger/lib/logger.ex#L1031" class="source">Source</a>
</h3> <section class="docstring"> <p>Logs a warning message.</p>
<p>Returns <code class="inline">:ok</code>.</p>
<h4 id="warning/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Logging a message (string or iodata):</p>
<pre data-language="elixir">Logger.warning("this is a warning message")</pre>
<p>Report message (maps or keywords):</p>
<pre data-language="elixir"># as keyword list
Logger.warning([something: :reported, this: :warning])

# as map
Logger.warning(%{this: :warning, something: :reported})</pre>
<p>Report message with metadata (maps or keywords):</p>
<pre data-language="elixir"># as a keyword list
Logger.warning("this is a warning message", [user_id: 42, request_id: "xU32kFa"])

# as map
Logger.warning("this is a warning message", %{user_id: 42, request_id: "xU32kFa"})</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="logger.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/logger/1.18.1/Logger.html" class="_attribution-link">https://hexdocs.pm/logger/1.18.1/Logger.html</a>
  </p>
</div>
