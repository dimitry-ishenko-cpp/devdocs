<div id="top-content"> <h1> <a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1" title="View Source" class="source" rel="help">Source</a> <span translate="no">NaiveDateTime</span>  </h1> <section id="moduledoc"> <p>A NaiveDateTime struct (without a time zone) and functions.</p>
<p>The NaiveDateTime struct contains the fields year, month, day, hour, minute, second, microsecond and calendar. New naive datetimes can be built with the <a href="#new/2"><code class="inline">new/2</code></a> and <a href="#new/8"><code class="inline">new/8</code></a> functions or using the <code class="inline">~N</code> (see <a href="kernel.html#sigil_N/2"><code class="inline">sigil_N/2</code></a>) sigil:</p>
<pre data-language="elixir">iex&gt; ~N[2000-01-01 23:00:07]
~N[2000-01-01 23:00:07]</pre>
<p>The date and time fields in the struct can be accessed directly:</p>
<pre data-language="elixir">iex&gt; naive = ~N[2000-01-01 23:00:07]
iex&gt; naive.year
2000
iex&gt; naive.second
7</pre>
<p>We call them "naive" because this datetime representation does not have a time zone. This means the datetime may not actually exist in certain areas in the world even though it is valid.</p>
<p>For example, when daylight saving changes are applied by a region, the clock typically moves forward or backward by one hour. This means certain datetimes never occur or may occur more than once. Since <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> is not validated against a time zone, such errors would go unnoticed.</p>
<p>Developers should avoid creating the NaiveDateTime structs directly and instead, rely on the functions provided by this module as well as the ones in third-party calendar libraries.</p>
<h2 id="module-comparing-naive-date-times" class="section-heading">  <span class="text">Comparing naive date times</span> </h2> <p>Comparisons in Elixir using <a href="kernel.html#==/2"><code class="inline">==/2</code></a>, <a href="kernel.html#%3E/2"><code class="inline">&gt;/2</code></a>, <a href="kernel.html#%3C/2"><code class="inline">&lt;/2</code></a> and similar are structural and based on the <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct fields. For proper comparison between naive datetimes, use the <a href="#compare/2"><code class="inline">compare/2</code></a> function. The existence of the <a href="#compare/2"><code class="inline">compare/2</code></a> function in this module also allows using <a href="enum.html#min/2"><code class="inline">Enum.min/2</code></a> and <a href="enum.html#max/2"><code class="inline">Enum.max/2</code></a> functions to get the minimum and maximum naive datetime of an <a href="enum.html"><code class="inline">Enum</code></a>. For example:</p>
<pre data-language="elixir">iex&gt; Enum.min([~N[2020-01-01 23:00:07], ~N[2000-01-01 23:00:07]], NaiveDateTime)
~N[2000-01-01 23:00:07]</pre>
<h2 id="module-using-epochs" class="section-heading">  <span class="text">Using epochs</span> </h2> <p>The <a href="#add/3"><code class="inline">add/3</code></a> and <a href="#diff/3"><code class="inline">diff/3</code></a> functions can be used for computing date times or retrieving the number of seconds between instants. For example, if there is an interest in computing the number of seconds from the Unix epoch (1970-01-01 00:00:00):</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.diff(~N[2010-04-17 14:00:00], ~N[1970-01-01 00:00:00])
1271512800

iex&gt; NaiveDateTime.add(~N[1970-01-01 00:00:00], 1_271_512_800)
~N[2010-04-17 14:00:00]</pre>
<p>Those functions are optimized to deal with common epochs, such as the Unix Epoch above or the Gregorian Epoch (0000-01-01 00:00:00).</p> </section> </div> <section id="summary" class="details-list"> <h1 class="section-heading">  <span class="text">Summary</span> </h1> <h2> Types </h2>
<dl class="summary-types summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#t:t/0" data-no-tooltip translate="no">t()</a> </dt> </div> </dl> <h2> Functions </h2>
<dl class="summary-functions summary">  <div class="summary-row"> <dt class="summary-signature"> <a href="#add/3" data-no-tooltip translate="no">add(naive_datetime, amount_to_add, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Adds a specified amount of time to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#after?/2" data-no-tooltip translate="no">after?(naive_datetime1, naive_datetime2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the first <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> is strictly later than the second.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#before?/2" data-no-tooltip translate="no">before?(naive_datetime1, naive_datetime2)</a> </dt> <dd class="summary-synopsis"><p>Returns <code class="inline">true</code> if the first <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> is strictly earlier than the second.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#beginning_of_day/1" data-no-tooltip translate="no">beginning_of_day(naive_datetime)</a> </dt> <dd class="summary-synopsis"><p>Calculates a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> that is the first moment for the given <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#compare/2" data-no-tooltip translate="no">compare(naive_datetime1, naive_datetime2)</a> </dt> <dd class="summary-synopsis"><p>Compares two <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert/2" data-no-tooltip translate="no">convert(ndt, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">naive_datetime</code> from one calendar to another.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#convert!/2" data-no-tooltip translate="no">convert!(naive_datetime, calendar)</a> </dt> <dd class="summary-synopsis"><p>Converts the given <code class="inline">naive_datetime</code> from one calendar to another.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#diff/3" data-no-tooltip translate="no">diff(naive_datetime1, naive_datetime2, unit \\ :second)</a> </dt> <dd class="summary-synopsis"><p>Subtracts <code class="inline">naive_datetime2</code> from <code class="inline">naive_datetime1</code>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#end_of_day/1" data-no-tooltip translate="no">end_of_day(naive_datetime)</a> </dt> <dd class="summary-synopsis"><p>Calculates a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> that is the last moment for the given <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl/3" data-no-tooltip translate="no">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang datetime tuple to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_erl!/3" data-no-tooltip translate="no">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts an Erlang datetime tuple to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_gregorian_seconds/3" data-no-tooltip translate="no">from_gregorian_seconds(seconds, microsecond_precision \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Converts a number of gregorian seconds to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601/2" data-no-tooltip translate="no">from_iso8601(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#from_iso8601!/2" data-no-tooltip translate="no">from_iso8601!(string, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#local_now/1" data-no-tooltip translate="no">local_now(calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the "local time" for the machine the Elixir program is running on.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/2" data-no-tooltip translate="no">new(date, time)</a> </dt> <dd class="summary-synopsis"><p>Builds a naive datetime from date and time structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new/8" data-no-tooltip translate="no">new(year, month, day, hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new ISO naive datetime.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/2" data-no-tooltip translate="no">new!(date, time)</a> </dt> <dd class="summary-synopsis"><p>Builds a naive datetime from date and time structs.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#new!/8" data-no-tooltip translate="no">new!(year, month, day, hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Builds a new ISO naive datetime.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#shift/2" data-no-tooltip translate="no">shift(naive_datetime, duration)</a> </dt> <dd class="summary-synopsis"><p>Shifts given <code class="inline">naive_datetime</code> by <code class="inline">duration</code> according to its calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_date/1" data-no-tooltip translate="no">to_date(map)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> into a <a href="date.html"><code class="inline">Date</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_erl/1" data-no-tooltip translate="no">to_erl(naive_datetime)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct to an Erlang datetime tuple.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_gregorian_seconds/1" data-no-tooltip translate="no">to_gregorian_seconds(map)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct to a number of gregorian seconds and microseconds.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_iso8601/2" data-no-tooltip translate="no">to_iso8601(naive_datetime, format \\ :extended)</a> </dt> <dd class="summary-synopsis"><p>Converts the given naive datetime to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_string/1" data-no-tooltip translate="no">to_string(naive_datetime)</a> </dt> <dd class="summary-synopsis"><p>Converts the given naive datetime to a string according to its calendar.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#to_time/1" data-no-tooltip translate="no">to_time(map)</a> </dt> <dd class="summary-synopsis"><p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> into <a href="time.html"><code class="inline">Time</code></a>.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#truncate/2" data-no-tooltip translate="no">truncate(naive_datetime, precision)</a> </dt> <dd class="summary-synopsis"><p>Returns the given naive datetime with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_now/1" data-no-tooltip translate="no">utc_now(calendar_or_time_unit \\ Calendar.ISO)</a> </dt> <dd class="summary-synopsis"><p>Returns the current naive datetime in UTC.</p></dd> </div> <div class="summary-row"> <dt class="summary-signature"> <a href="#utc_now/2" data-no-tooltip translate="no">utc_now(time_unit, calendar)</a> </dt> <dd class="summary-synopsis"><p>Returns the current naive datetime in UTC, supporting a specific calendar and precision.</p></dd> </div> </dl> </section> <section id="types" class="details-list"> <h1 class="section-heading">  <span class="text">Types</span> </h1> <div class="types-list"> <section class="detail"> <h3 class="detail-header" id="t:t/0">t()<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L76" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@type t() :: %NaiveDateTime{
  calendar: Calendar.calendar(),
  day: Calendar.day(),
  hour: Calendar.hour(),
  microsecond: Calendar.microsecond(),
  minute: Calendar.minute(),
  month: Calendar.month(),
  second: Calendar.second(),
  year: Calendar.year()
}</pre> </div> </section> </section> </div> </section> <section id="functions" class="details-list"> <h1 class="section-heading">  <span class="text">Functions</span> </h1> <div class="functions-list"> <section class="detail">  <h3 class="detail-header" id="add/3">add(naive_datetime, amount_to_add, unit \\ :second)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L451" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec add(
  Calendar.naive_datetime(),
  integer(),
  :day | :hour | :minute | System.time_unit()
) :: t()</pre> </div> <p>Adds a specified amount of time to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p>
<p>Accepts an <code class="inline">amount_to_add</code> in any <code class="inline">unit</code>. <code class="inline">unit</code> can be <code class="inline">:day</code>, <code class="inline">:hour</code>, <code class="inline">:minute</code>, <code class="inline">:second</code> or any subsecond precision from <a href="system.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. It defaults to <code class="inline">:second</code>. Negative values will move backwards in time.</p>
<p>This function always consider the unit to be computed according to the <a href="calendar.iso.html"><code class="inline">Calendar.ISO</code></a>.</p>
<h4 id="add/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>It uses seconds by default:</p>
<pre data-language="elixir"># adds seconds by default
iex&gt; NaiveDateTime.add(~N[2014-10-02 00:29:10], 2)
~N[2014-10-02 00:29:12]

# accepts negative offsets
iex&gt; NaiveDateTime.add(~N[2014-10-02 00:29:10], -2)
~N[2014-10-02 00:29:08]</pre>
<p>It can also work with subsecond precisions:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.add(~N[2014-10-02 00:29:10], 2_000, :millisecond)
~N[2014-10-02 00:29:12.000]</pre>
<p>As well as days/hours/minutes:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.add(~N[2015-02-28 00:29:10], 2, :day)
~N[2015-03-02 00:29:10]
iex&gt; NaiveDateTime.add(~N[2015-02-28 00:29:10], 36, :hour)
~N[2015-03-01 12:29:10]
iex&gt; NaiveDateTime.add(~N[2015-02-28 00:29:10], 60, :minute)
~N[2015-02-28 01:29:10]</pre>
<p>This operation merges the precision of the naive date time with the given unit:</p>
<pre data-language="elixir">iex&gt; result = NaiveDateTime.add(~N[2014-10-02 00:29:10], 21, :millisecond)
~N[2014-10-02 00:29:10.021]
iex&gt; result.microsecond
{21000, 3}</pre>
<p>Operations on top of gregorian seconds or the Unix epoch are optimized:</p>
<pre data-language="elixir"># from Gregorian seconds
iex&gt; NaiveDateTime.add(~N[0000-01-01 00:00:00], 63_579_428_950)
~N[2014-10-02 00:29:10]</pre>
<p>Passing a <a href="datetime.html"><code class="inline">DateTime</code></a> automatically converts it to <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>, discarding the time zone information:</p>
<pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; NaiveDateTime.add(dt, 21, :second)
~N[2000-02-29 23:00:28]</pre>
<p>To shift a naive datetime by a <a href="duration.html"><code class="inline">Duration</code></a> and according to its underlying calendar, use <a href="#shift/2"><code class="inline">NaiveDateTime.shift/2</code></a>.</p> </section> </section> <section class="detail"> <h3 class="detail-header" id="after?/2">after?(naive_datetime1, naive_datetime2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1236" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec after?(Calendar.naive_datetime(), Calendar.naive_datetime()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the first <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> is strictly later than the second.</p>
<h4 id="after?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.after?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])
true
iex&gt; NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])
false
iex&gt; NaiveDateTime.after?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="before?/2">before?(naive_datetime1, naive_datetime2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1217" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec before?(Calendar.naive_datetime(), Calendar.naive_datetime()) :: boolean()</pre> </div> <p>Returns <code class="inline">true</code> if the first <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> is strictly earlier than the second.</p>
<h4 id="before?/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2022-02-02 11:00:00])
true
iex&gt; NaiveDateTime.before?(~N[2021-01-01 11:00:00], ~N[2021-01-01 11:00:00])
false
iex&gt; NaiveDateTime.before?(~N[2022-02-02 11:00:00], ~N[2021-01-01 11:00:00])
false</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="beginning_of_day/1">beginning_of_day(naive_datetime)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1359" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec beginning_of_day(Calendar.naive_datetime()) :: t()</pre> </div> <p>Calculates a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> that is the first moment for the given <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p>
<p>To calculate the beginning of day of a <a href="datetime.html"><code class="inline">DateTime</code></a>, call this function, then convert back to a <a href="datetime.html"><code class="inline">DateTime</code></a>:</p>
<pre data-language="elixir">datetime
|&gt; NaiveDateTime.beginning_of_day()
|&gt; DateTime.from_naive(datetime.time_zone)</pre>
<p>Note that the beginning of the day may not exist or be ambiguous in a given timezone, so you must handle those cases accordingly.</p>
<h4 id="beginning_of_day/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.beginning_of_day(~N[2000-01-01 23:00:07.123456])
~N[2000-01-01 00:00:00.000000]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="compare/2">compare(naive_datetime1, naive_datetime2)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1185" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec compare(Calendar.naive_datetime(), Calendar.naive_datetime()) :: :lt | :eq | :gt</pre> </div> <p>Compares two <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> structs.</p>
<p>Returns <code class="inline">:gt</code> if first is later than the second and <code class="inline">:lt</code> for vice versa. If the two NaiveDateTime are equal <code class="inline">:eq</code> is returned.</p>
<h4 id="compare/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.compare(~N[2016-04-16 13:30:15], ~N[2016-04-28 16:19:25])
:lt
iex&gt; NaiveDateTime.compare(~N[2016-04-16 13:30:15.1], ~N[2016-04-16 13:30:15.01])
:gt</pre>
<p>This function can also be used to compare a DateTime without the time zone information:</p>
<pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; NaiveDateTime.compare(dt, ~N[2000-02-29 23:00:07])
:eq
iex&gt; NaiveDateTime.compare(dt, ~N[2000-01-29 23:00:07])
:gt
iex&gt; NaiveDateTime.compare(dt, ~N[2000-03-29 23:00:07])
:lt</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert/2">convert(ndt, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1263" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert(Calendar.naive_datetime(), Calendar.calendar()) ::
  {:ok, t()} | {:error, :incompatible_calendars}</pre> </div> <p>Converts the given <code class="inline">naive_datetime</code> from one calendar to another.</p>
<p>If it is not possible to convert unambiguously between the calendars (see <a href="calendar.html#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>), an <code class="inline">{:error, :incompatible_calendars}</code> tuple is returned.</p>
<h4 id="convert/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.convert(~N[2000-01-01 13:30:15], Calendar.Holocene)
{:ok, %NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,
                     hour: 13, minute: 30, second: 15, microsecond: {0, 0}}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="convert!/2">convert!(naive_datetime, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1326" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec convert!(Calendar.naive_datetime(), Calendar.calendar()) :: t()</pre> </div> <p>Converts the given <code class="inline">naive_datetime</code> from one calendar to another.</p>
<p>If it is not possible to convert unambiguously between the calendars (see <a href="calendar.html#compatible_calendars?/2"><code class="inline">Calendar.compatible_calendars?/2</code></a>), an ArgumentError is raised.</p>
<h4 id="convert!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <p>Imagine someone implements <code class="inline">Calendar.Holocene</code>, a calendar based on the Gregorian calendar that adds exactly 10,000 years to the current Gregorian year:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.convert!(~N[2000-01-01 13:30:15], Calendar.Holocene)
%NaiveDateTime{calendar: Calendar.Holocene, year: 12000, month: 1, day: 1,
               hour: 13, minute: 30, second: 15, microsecond: {0, 0}}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="diff/3">diff(naive_datetime1, naive_datetime2, unit \\ :second)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L532" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec diff(
  Calendar.naive_datetime(),
  Calendar.naive_datetime(),
  :day | :hour | :minute | System.time_unit()
) :: integer()</pre> </div> <p>Subtracts <code class="inline">naive_datetime2</code> from <code class="inline">naive_datetime1</code>.</p>
<p>The answer can be returned in any <code class="inline">:day</code>, <code class="inline">:hour</code>, <code class="inline">:minute</code>, or any <code class="inline">unit</code> available from <a href="system.html#t:time_unit/0"><code class="inline">System.time_unit/0</code></a>. The unit is measured according to <a href="calendar.iso.html"><code class="inline">Calendar.ISO</code></a> and defaults to <code class="inline">:second</code>.</p>
<p>Fractional results are not supported and are truncated.</p>
<h4 id="diff/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10])
2
iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:29:12], ~N[2014-10-02 00:29:10], :microsecond)
2_000_000

iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021])
0
iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:29:10.042], ~N[2014-10-02 00:29:10.021], :millisecond)
21

iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:29:10], ~N[2014-10-02 00:29:12])
-2
iex&gt; NaiveDateTime.diff(~N[-0001-10-02 00:29:10], ~N[-0001-10-02 00:29:12])
-2</pre>
<p>It can also compute the difference in days, hours, or minutes:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.diff(~N[2014-10-10 00:29:10], ~N[2014-10-02 00:29:10], :day)
8
iex&gt; NaiveDateTime.diff(~N[2014-10-02 12:29:10], ~N[2014-10-02 00:29:10], :hour)
12
iex&gt; NaiveDateTime.diff(~N[2014-10-02 00:39:10], ~N[2014-10-02 00:29:10], :minute)
10</pre>
<p>But it also rounds incomplete days to zero:</p>
<pre data-language="elixir">iex&gt; NaiveDateTime.diff(~N[2014-10-10 00:29:09], ~N[2014-10-02 00:29:10], :day)
7</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="end_of_day/1">end_of_day(naive_datetime)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1386" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec end_of_day(Calendar.naive_datetime()) :: t()</pre> </div> <p>Calculates a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> that is the last moment for the given <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>.</p>
<p>To calculate the end of day of a <a href="datetime.html"><code class="inline">DateTime</code></a>, call this function, then convert back to a <a href="datetime.html"><code class="inline">DateTime</code></a>:</p>
<pre data-language="elixir">datetime
|&gt; NaiveDateTime.end_of_day()
|&gt; DateTime.from_naive(datetime.time_zone)</pre>
<p>Note that the end of the day may not exist or be ambiguous in a given timezone, so you must handle those cases accordingly.</p>
<h4 id="end_of_day/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.end_of_day(~N[2000-01-01 23:00:07.123456])
~N[2000-01-01 23:59:59.999999]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl/3">from_erl(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1010" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl(
  :calendar.datetime(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Converts an Erlang datetime tuple to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p>
<p>Attempting to convert an invalid ISO calendar date will produce an error tuple.</p>
<h4 id="from_erl/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}})
{:ok, ~N[2000-01-01 13:30:15]}
iex&gt; NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, 5000)
{:ok, ~N[2000-01-01 13:30:15.005000]}
iex&gt; NaiveDateTime.from_erl({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})
{:ok, ~N[2000-01-01 13:30:15.005]}
iex&gt; NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})
{:error, :invalid_date}
iex&gt; NaiveDateTime.from_erl({{2000, 13, 1}, {13, 30, 15}})
{:error, :invalid_date}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_erl!/3">from_erl!(tuple, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1040" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_erl!(
  :calendar.datetime(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Converts an Erlang datetime tuple to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p>
<p>Raises if the datetime is invalid. Attempting to convert an invalid ISO calendar date will produce an error tuple.</p>
<h4 id="from_erl!/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}})
~N[2000-01-01 13:30:15]
iex&gt; NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, 5000)
~N[2000-01-01 13:30:15.005000]
iex&gt; NaiveDateTime.from_erl!({{2000, 1, 1}, {13, 30, 15}}, {5000, 3})
~N[2000-01-01 13:30:15.005]
iex&gt; NaiveDateTime.from_erl!({{2000, 13, 1}, {13, 30, 15}})
** (ArgumentError) cannot convert {{2000, 13, 1}, {13, 30, 15}} to naive datetime, reason: :invalid_date</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="from_gregorian_seconds/3">from_gregorian_seconds(seconds, microsecond_precision \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1066" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_gregorian_seconds(integer(), Calendar.microsecond(), Calendar.calendar()) ::
  t()</pre> </div> <p>Converts a number of gregorian seconds to a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct.</p>
<h4 id="from_gregorian_seconds/3-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.from_gregorian_seconds(1)
~N[0000-01-01 00:00:01]
iex&gt; NaiveDateTime.from_gregorian_seconds(63_755_511_991, {5000, 3})
~N[2020-05-01 00:26:31.005]
iex&gt; NaiveDateTime.from_gregorian_seconds(-1)
~N[-0001-12-31 23:59:59]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601/2">from_iso8601(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L851" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601(String.t(), Calendar.calendar()) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>Time zone offset may be included in the string but they will be simply discarded as such information is not included in naive date times.</p>
<p>As specified in the standard, the separator "T" may be omitted if desired as there is no ambiguity within this function.</p>
<p>Note leap seconds are not supported by the built-in Calendar.ISO.</p>
<h4 id="from_iso8601/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:07")
{:ok, ~N[2015-01-23 23:50:07]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07")
{:ok, ~N[2015-01-23 23:50:07]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07Z")
{:ok, ~N[2015-01-23 23:50:07]}

iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:07.0")
{:ok, ~N[2015-01-23 23:50:07.0]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:07,0123456")
{:ok, ~N[2015-01-23 23:50:07.012345]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:07.0123456")
{:ok, ~N[2015-01-23 23:50:07.012345]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123Z")
{:ok, ~N[2015-01-23 23:50:07.123]}

iex&gt; NaiveDateTime.from_iso8601("2015-01-23P23:50:07")
{:error, :invalid_format}
iex&gt; NaiveDateTime.from_iso8601("2015:01:23 23-50-07")
{:error, :invalid_format}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:07A")
{:error, :invalid_format}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23 23:50:61")
{:error, :invalid_time}
iex&gt; NaiveDateTime.from_iso8601("2015-01-32 23:50:07")
{:error, :invalid_date}

iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123+02:30")
{:ok, ~N[2015-01-23 23:50:07.123]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123+00:00")
{:ok, ~N[2015-01-23 23:50:07.123]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123-02:30")
{:ok, ~N[2015-01-23 23:50:07.123]}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123-00:00")
{:error, :invalid_format}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123-00:60")
{:error, :invalid_format}
iex&gt; NaiveDateTime.from_iso8601("2015-01-23T23:50:07.123-24:00")
{:error, :invalid_format}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="from_iso8601!/2">from_iso8601!(string, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L886" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec from_iso8601!(String.t(), Calendar.calendar()) :: t()</pre> </div> <p>Parses the extended "Date and time of day" format described by <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>Raises if the format is invalid.</p>
<h4 id="from_iso8601!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.from_iso8601!("2015-01-23T23:50:07.123Z")
~N[2015-01-23 23:50:07.123]
iex&gt; NaiveDateTime.from_iso8601!("2015-01-23T23:50:07,123Z")
~N[2015-01-23 23:50:07.123]
iex&gt; NaiveDateTime.from_iso8601!("2015-01-23P23:50:07")
** (ArgumentError) cannot parse "2015-01-23P23:50:07" as naive datetime, reason: :invalid_format</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="local_now/1">local_now(calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L184" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec local_now(Calendar.calendar()) :: t()</pre> </div> <p>Returns the "local time" for the machine the Elixir program is running on.</p>
<p>WARNING: This function can cause insidious bugs. It depends on the time zone configuration at run time. This can changed and be set to a time zone that has daylight saving jumps (spring forward or fall back).</p>
<p>This function can be used to display what the time is right now for the time zone configuration that the machine happens to have. An example would be a desktop program displaying a clock to the user. For any other uses it is probably a bad idea to use this function.</p>
<p>For most cases, use <a href="datetime.html#now/2"><code class="inline">DateTime.now/2</code></a> or <a href="datetime.html#utc_now/1"><code class="inline">DateTime.utc_now/1</code></a> instead.</p>
<p>Does not include fractional seconds.</p>
<h4 id="local_now/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; naive_datetime = NaiveDateTime.local_now()
iex&gt; naive_datetime.year &gt;= 2019
true</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new/2">new(date, time)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L349" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(Date.t(), Time.t()) :: {:ok, t()}</pre> </div> <p>Builds a naive datetime from date and time structs.</p>
<h4 id="new/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.new(~D[2010-01-13], ~T[23:00:07.005])
{:ok, ~N[2010-01-13 23:00:07.005]}</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new/8">new(year, month, day, hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L253" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new(
  Calendar.year(),
  Calendar.month(),
  Calendar.day(),
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: {:ok, t()} | {:error, atom()}</pre> </div> <p>Builds a new ISO naive datetime.</p>
<p>Expects all values to be integers. Returns <code class="inline">{:ok, naive_datetime}</code> if each entry fits its appropriate range, returns <code class="inline">{:error, reason}</code> otherwise.</p>
<h4 id="new/8-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.new(2000, 1, 1, 0, 0, 0)
{:ok, ~N[2000-01-01 00:00:00]}
iex&gt; NaiveDateTime.new(2000, 13, 1, 0, 0, 0)
{:error, :invalid_date}
iex&gt; NaiveDateTime.new(2000, 2, 29, 0, 0, 0)
{:ok, ~N[2000-02-29 00:00:00]}
iex&gt; NaiveDateTime.new(2000, 2, 30, 0, 0, 0)
{:error, :invalid_date}
iex&gt; NaiveDateTime.new(2001, 2, 29, 0, 0, 0)
{:error, :invalid_date}

iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1})
{:ok, ~N[2000-01-01 23:59:59.0]}
iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 999_999)
{:ok, ~N[2000-01-01 23:59:59.999999]}
iex&gt; NaiveDateTime.new(2000, 1, 1, 24, 59, 59, 999_999)
{:error, :invalid_time}
iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 60, 59, 999_999)
{:error, :invalid_time}
iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 60, 999_999)
{:error, :invalid_time}
iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, 1_000_000)
{:error, :invalid_time}

iex&gt; NaiveDateTime.new(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)
{:ok, ~N[2000-01-01 23:59:59.0]}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="new!/2">new!(date, time)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L380" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new!(Date.t(), Time.t()) :: t()</pre> </div> <p>Builds a naive datetime from date and time structs.</p>
<h4 id="new!/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.new!(~D[2010-01-13], ~T[23:00:07.005])
~N[2010-01-13 23:00:07.005]</pre> </section> </section> <section class="detail">   <h3 class="detail-header" id="new!/8">new!(year, month, day, hour, minute, second, microsecond \\ {0, 0}, calendar \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L318" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec new!(
  Calendar.year(),
  Calendar.month(),
  Calendar.day(),
  Calendar.hour(),
  Calendar.minute(),
  Calendar.second(),
  Calendar.microsecond() | non_neg_integer(),
  Calendar.calendar()
) :: t()</pre> </div> <p>Builds a new ISO naive datetime.</p>
<p>Expects all values to be integers. Returns <code class="inline">naive_datetime</code> if each entry fits its appropriate range, raises if time or date is invalid.</p>
<h4 id="new!/8-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.new!(2000, 1, 1, 0, 0, 0)
~N[2000-01-01 00:00:00]
iex&gt; NaiveDateTime.new!(2000, 2, 29, 0, 0, 0)
~N[2000-02-29 00:00:00]
iex&gt; NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1})
~N[2000-01-01 23:59:59.0]
iex&gt; NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, 999_999)
~N[2000-01-01 23:59:59.999999]
iex&gt; NaiveDateTime.new!(2000, 1, 1, 23, 59, 59, {0, 1}, Calendar.ISO)
~N[2000-01-01 23:59:59.0]
iex&gt; NaiveDateTime.new!(2000, 1, 1, 24, 59, 59, 999_999)
** (ArgumentError) cannot build naive datetime, reason: :invalid_time</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="shift/2">shift(naive_datetime, duration)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L608" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec shift(Calendar.naive_datetime(), Duration.duration()) :: t()</pre> </div> <p>Shifts given <code class="inline">naive_datetime</code> by <code class="inline">duration</code> according to its calendar.</p>
<p>Allowed units are: <code class="inline">:year</code>, <code class="inline">:month</code>, <code class="inline">:week</code>, <code class="inline">:day</code>, <code class="inline">:hour</code>, <code class="inline">:minute</code>, <code class="inline">:second</code>, <code class="inline">:microsecond</code>.</p>
<p>When using the default ISO calendar, durations are collapsed and applied in the order of months, then seconds and microseconds:</p>
<ul>
<li>when shifting by 1 year and 2 months the date is actually shifted by 14 months</li>
<li>weeks, days and smaller units are collapsed into seconds and microseconds</li>
</ul>
<p>When shifting by month, days are rounded down to the nearest valid date.</p>
<h4 id="shift/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.shift(~N[2016-01-31 00:00:00], month: 1)
~N[2016-02-29 00:00:00]
iex&gt; NaiveDateTime.shift(~N[2016-01-31 00:00:00], year: 4, day: 1)
~N[2020-02-01 00:00:00]
iex&gt; NaiveDateTime.shift(~N[2016-01-31 00:00:00], year: -2, day: 1)
~N[2014-02-01 00:00:00]
iex&gt; NaiveDateTime.shift(~N[2016-01-31 00:00:00], second: 45)
~N[2016-01-31 00:00:45]
iex&gt; NaiveDateTime.shift(~N[2016-01-31 00:00:00], microsecond: {100, 6})
~N[2016-01-31 00:00:00.000100]

# leap years
iex&gt; NaiveDateTime.shift(~N[2024-02-29 00:00:00], year: 1)
~N[2025-02-28 00:00:00]
iex&gt; NaiveDateTime.shift(~N[2024-02-29 00:00:00], year: 4)
~N[2028-02-29 00:00:00]

# rounding down
iex&gt; NaiveDateTime.shift(~N[2015-01-31 00:00:00], month: 1)
~N[2015-02-28 00:00:00]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_date/1">to_date(map)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L709" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_date(Calendar.naive_datetime()) :: Date.t()</pre> </div> <p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> into a <a href="date.html"><code class="inline">Date</code></a>.</p>
<p>Because <a href="date.html"><code class="inline">Date</code></a> does not hold time information, data will be lost during the conversion.</p>
<h4 id="to_date/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.to_date(~N[2002-01-13 23:00:07])
~D[2002-01-13]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_erl/1">to_erl(naive_datetime)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L978" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_erl(Calendar.naive_datetime()) :: :calendar.datetime()</pre> </div> <p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct to an Erlang datetime tuple.</p>
<p>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</p>
<p>WARNING: Loss of precision may occur, as Erlang time tuples only store hour/minute/second.</p>
<h4 id="to_erl/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.to_erl(~N[2000-01-01 13:30:15])
{{2000, 1, 1}, {13, 30, 15}}</pre>
<p>This function can also be used to convert a DateTime to an Erlang datetime tuple without the time zone information:</p>
<pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; NaiveDateTime.to_erl(dt)
{{2000, 2, 29}, {23, 00, 07}}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_gregorian_seconds/1">to_gregorian_seconds(map)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L1130" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_gregorian_seconds(Calendar.naive_datetime()) ::
  {integer(), non_neg_integer()}</pre> </div> <p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> struct to a number of gregorian seconds and microseconds.</p>
<h4 id="to_gregorian_seconds/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.to_gregorian_seconds(~N[0000-01-01 00:00:01])
{1, 0}
iex&gt; NaiveDateTime.to_gregorian_seconds(~N[2020-05-01 00:26:31.005])
{63_755_511_991, 5000}</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="to_iso8601/2">to_iso8601(naive_datetime, format \\ :extended)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L929" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_iso8601(Calendar.naive_datetime(), :basic | :extended) :: String.t()</pre> </div> <p>Converts the given naive datetime to <a href="https://en.wikipedia.org/wiki/ISO_8601">ISO 8601:2019</a>.</p>
<p>By default, <a href="#to_iso8601/2"><code class="inline">NaiveDateTime.to_iso8601/2</code></a> returns naive datetimes formatted in the "extended" format, for human readability. It also supports the "basic" format through passing the <code class="inline">:basic</code> option.</p>
<p>Only supports converting naive datetimes which are in the ISO calendar, attempting to convert naive datetimes from other calendars will raise.</p>
<h3 id="to_iso8601/2-examples" class="section-heading">  <span class="text">Examples</span> </h3> <pre data-language="elixir">iex&gt; NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13])
"2000-02-28T23:00:13"

iex&gt; NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001])
"2000-02-28T23:00:13.001"

iex&gt; NaiveDateTime.to_iso8601(~N[2000-02-28 23:00:13.001], :basic)
"20000228T230013.001"</pre>
<p>This function can also be used to convert a DateTime to ISO 8601 without the time zone information:</p>
<pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; NaiveDateTime.to_iso8601(dt)
"2000-02-29T23:00:07"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_string/1">to_string(naive_datetime)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L780" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_string(Calendar.naive_datetime()) :: String.t()</pre> </div> <p>Converts the given naive datetime to a string according to its calendar.</p>
<p>For redability, this function follows the RFC3339 suggestion of removing the "T" separator between the date and time components.</p>
<h3 id="to_string/1-examples" class="section-heading">  <span class="text">Examples</span> </h3> <pre data-language="elixir">iex&gt; NaiveDateTime.to_string(~N[2000-02-28 23:00:13])
"2000-02-28 23:00:13"
iex&gt; NaiveDateTime.to_string(~N[2000-02-28 23:00:13.001])
"2000-02-28 23:00:13.001"
iex&gt; NaiveDateTime.to_string(~N[-0100-12-15 03:20:31])
"-0100-12-15 03:20:31"</pre>
<p>This function can also be used to convert a DateTime to a string without the time zone information:</p>
<pre data-language="elixir">iex&gt; dt = %DateTime{year: 2000, month: 2, day: 29, zone_abbr: "CET",
...&gt;                hour: 23, minute: 0, second: 7, microsecond: {0, 0},
...&gt;                utc_offset: 3600, std_offset: 0, time_zone: "Europe/Warsaw"}
iex&gt; NaiveDateTime.to_string(dt)
"2000-02-29 23:00:07"</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="to_time/1">to_time(map)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L735" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec to_time(Calendar.naive_datetime()) :: Time.t()</pre> </div> <p>Converts a <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a> into <a href="time.html"><code class="inline">Time</code></a>.</p>
<p>Because <a href="time.html"><code class="inline">Time</code></a> does not hold date information, data will be lost during the conversion.</p>
<h4 id="to_time/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.to_time(~N[2002-01-13 23:00:07])
~T[23:00:07]</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="truncate/2">truncate(naive_datetime, precision)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L667" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec truncate(t(), :microsecond | :millisecond | :second) :: t()</pre> </div> <p>Returns the given naive datetime with the microsecond field truncated to the given precision (<code class="inline">:microsecond</code>, <code class="inline">:millisecond</code> or <code class="inline">:second</code>).</p>
<p>The given naive datetime is returned unchanged if it already has lower precision than the given precision.</p>
<h4 id="truncate/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :microsecond)
~N[2017-11-06 00:23:51.123456]

iex&gt; NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :millisecond)
~N[2017-11-06 00:23:51.123]

iex&gt; NaiveDateTime.truncate(~N[2017-11-06 00:23:51.123456], :second)
~N[2017-11-06 00:23:51]</pre> </section> </section> <section class="detail">  <h3 class="detail-header" id="utc_now/1">utc_now(calendar_or_time_unit \\ Calendar.ISO)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L111" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec utc_now(Calendar.calendar() | :native | :microsecond | :millisecond | :second) ::
  t()</pre> </div> <p>Returns the current naive datetime in UTC.</p>
<p>Prefer using <a href="datetime.html#utc_now/0"><code class="inline">DateTime.utc_now/0</code></a> when possible as, opposite to <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>, it will keep the time zone information.</p>
<p>You can also provide a time unit to automatically truncate the naive datetime. This is available since v1.15.0.</p>
<h4 id="utc_now/1-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; naive_datetime = NaiveDateTime.utc_now()
iex&gt; naive_datetime.year &gt;= 2016
true

iex&gt; naive_datetime = NaiveDateTime.utc_now(:second)
iex&gt; naive_datetime.microsecond
{0, 0}</pre> </section> </section> <section class="detail"> <h3 class="detail-header" id="utc_now/2">utc_now(time_unit, calendar)<a href="https://github.com/elixir-lang/elixir/blob/v1.18.1/lib/elixir/lib/calendar/naive_datetime.ex#L141" class="source">Source</a>
</h3> <section class="docstring"> <div class="specs"> <pre translate="no" data-language="elixir">@spec utc_now(:native | :microsecond | :millisecond | :second, Calendar.calendar()) ::
  t()</pre> </div> <p>Returns the current naive datetime in UTC, supporting a specific calendar and precision.</p>
<p>Prefer using <a href="datetime.html#utc_now/2"><code class="inline">DateTime.utc_now/2</code></a> when possible as, opposite to <a href="naivedatetime.html"><code class="inline">NaiveDateTime</code></a>, it will keep the time zone information.</p>
<h4 id="utc_now/2-examples" class="section-heading">  <span class="text">Examples</span> </h4> <pre data-language="elixir">iex&gt; naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)
iex&gt; naive_datetime.year &gt;= 2016
true

iex&gt; naive_datetime = NaiveDateTime.utc_now(:second, Calendar.ISO)
iex&gt; naive_datetime.microsecond
{0, 0}</pre> </section> </section> </div> </section> <footer class="footer"> <p> <span class="line"> <button class="a-main footer-button display-quick-switch" title="Search HexDocs packages"> Search HexDocs </button> <a href="elixir.epub.html" title="ePub version"> Download ePub version </a> </span> </p> <p class="built-using"> Built using <a href="https://github.com/elixir-lang/ex_doc" title="ExDoc" target="_blank" rel="help noopener" translate="no">ExDoc</a> (v0.36.1) for the <a href="https://elixir-lang.org" title="Elixir" target="_blank" translate="no">Elixir programming language</a> </p> </footer><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2012-2024 The Elixir Team<br>Licensed under the Apache License, Version 2.0.<br>
    <a href="https://hexdocs.pm/elixir/1.18.1/NaiveDateTime.html" class="_attribution-link">https://hexdocs.pm/elixir/1.18.1/NaiveDateTime.html</a>
  </p>
</div>
