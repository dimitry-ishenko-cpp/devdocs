<h1>Q</h1> <h2 id="promise-methods"> Promise Methods</h2> <p>Most promise methods have "static" counterparts on the main <code>Q</code> object, which will accept either a promise or a non-promise, and in the latter case create a fulfilled promise first. For example, <code>Q.when(5, onFulfilled)</code> is equivalent to <code>Q(5).then(onFulfilled)</code>. All others have static counterparts that are named the same as the promise method.</p> <p>Some methods are named the same as JavaScript reserved words, like <code>try</code>, <code>catch</code>, and <code>finally</code>. This helps show the very clear parallel between standard synchronous language constructs and asynchronous promise operations. However, such use of words as property names is only supported as of the ECMAScript 5 edition of the JavaScript language, which isn't implemented in certain older browsers like IE8, Safari 5, Android 2.2, or PhantomJS 1.8. If you're targeting those browsers, and aren't using a language like CoffeeScript that takes care of this for you, use their aliases instead, or escape them like <code>Q["try"](...)</code> or <code>promise["catch"](...)</code>.</p> <h3 id="core-promise-methods"> Core Promise Methods</h3> <h4 id="promise-then"> promise.then(onFulfilled, onRejected, onProgress)</h4> <p>The <code>then</code> method from the <a href="http://promises-aplus.github.com/promises-spec/">Promises/A+ specification</a>, with an additional progress handler.</p> <h4 id="promise-catch"> promise.catch(onRejected)</h4> <p><em>Alias:</em> <code>promise.fail</code> (for non-ES5 browsers)</p> <p>A sugar method, equivalent to <code>promise.then(undefined, onRejected)</code>.</p> <h4 id="promise-progress"> promise.progress(onProgress)</h4> <p><em>Deprecated:</em> <code>promise.observeEstimate</code> or a similar interface is due to replace this method in version 2. Progress does not compose well. <a href="https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion">https://github.com/kriskowal/gtor#progress-and-estimated-time-to-completion</a></p> <p>A sugar method, equivalent to <code>promise.then(undefined, undefined, onProgress)</code>. The <code>onProgress</code> handler receives values that were sent to this promise either from the <code>notify</code> method of the corresponding deferred, or from the promise that this promise became by virtue of being returned from a handler.</p> <h4 id="promise-finally"> promise.finally(callback)</h4> <p><em>Alias:</em> <code>promise.fin</code> (for non-ES5 browsers)</p> <p>Like a <code>finally</code> clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.</p> <p><code>finally</code> returns a promise, which will become resolved with the same fulfillment value or rejection reason as <code>promise</code>. However, if <code>callback</code> returns a promise, the resolution of the returned promise will be delayed until the promise returned from <code>callback</code> is finished. Furthermore, if the returned promise rejects, that rejection will be passed down the chain instead of the previous result.</p> <h4 id="promise-done"> promise.done(onFulfilled, onRejected, onProgress)</h4> <p>Much like <code>then</code>, but with different behavior around unhandled rejection. If there is an unhandled rejection, either because <code>promise</code> is rejected and no <code>onRejected</code> callback was provided, or because <code>onFulfilled</code> or <code>onRejected</code> threw an error or returned a rejected promise, the resulting rejection reason is thrown as an exception in a future turn of the event loop.</p> <p>This method should be used to terminate chains of promises that will not be passed elsewhere. Since exceptions thrown in <code>then</code> callbacks are consumed and transformed into rejections, exceptions at the end of the chain are easy to accidentally, silently ignore. By arranging for the exception to be thrown in a future turn of the event loop, so that it won't be caught, it causes an <code>onerror</code> event on the browser <code>window</code>, or an <code>uncaughtException</code> event on Node.js's <code>process</code> object.</p> <p>Exceptions thrown by <code>done</code> will have long stack traces, if <code>Q.longStackSupport</code> is set to <code>true</code>. If <code>Q.onerror</code> is set, exceptions will be delivered there instead of thrown in a future turn.</p> <p><em>The Golden Rule of <code>done</code> vs. <code>then</code> usage is: either <code>return</code> your promise to someone else, or if the chain ends with you, call <code>done</code> to terminate it. Terminating with <code>catch</code> is not sufficient because the catch handler may itself throw an error.</em></p> <h3 id="promise-for-object-methods"> Promise-for-Object Methods</h3> <h4 id="promise-get"> promise.get(propertyName)</h4> <p>Returns a promise to get the named property of an object. Essentially equivalent to</p> <pre data-language="js">promise.then(function (o) {
  return o[propertyName];
});</pre> <h4 id="promise-post"> promise.post(methodName, args)</h4> <p><em>Experimental Alias</em>: <code>promise.mapply</code></p> <p>Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is <code>this</code> in the function, just like a synchronous method call. Essentially equivalent to</p> <pre data-language="js">promise.then(function (o) {
  return o[methodName].apply(o, args);
});</pre> <h4 id="promise-invoke"> promise.invoke(methodName, ...args)</h4> <p><em>Alias:</em> <code>promise.send</code></p> <p><em>Experimental Alias</em>: <code>promise.mcall</code></p> <p>Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is <code>this</code> in the function, just like a synchronous method call.</p> <h4 id="promise-keys"> promise.keys()</h4> <p>Returns a promise for an array of the property names of an object. Essentially equivalent to</p> <pre data-language="js">promise.then(function (o) {
  return Object.keys(o);
});</pre> <h3 id="promise-for-function-methods"> Promise-for-Function Methods</h3> <h4 id="promise-fbind"> promise.fbind(...args) <em>(deprecated)</em> </h4> <p>Returns a new function that calls a function asynchronously with the given variadic arguments, and returns a promise. Notably, any synchronous return values or thrown exceptions are transformed, respectively, into fulfillment values or rejection reasons for the promise returned by this new function.</p> <p>This method is especially useful in its static form for wrapping functions to ensure that they are always asynchronous, and that any thrown exceptions (intentional or accidental) are appropriately transformed into a returned rejected promise. For example:</p> <pre data-language="js">var getUserData = Q.fbind(function (userName) {
  if (!userName) {
    throw new Error("userName must be truthy!");
  }

  if (localCache.has(userName)) {
    return localCache.get(userName);
  }

  return getUserFromCloud(userName);
});</pre> <h4 id="promise-fapply"> promise.fapply(args)</h4> <p>Returns a promise for the result of calling a function, with the given array of arguments. Essentially equivalent to</p> <pre data-language="js">promise.then(function (f) {
  return f.apply(undefined, args);
});</pre> <p>Note that this will result in the same return value/thrown exception translation as explained above for <code>fbind</code>.</p> <h4 id="promise-fcall"> promise.fcall(...args)</h4> <p><em>Static Alias:</em> <code>Q.try</code> (ES5 browsers only)</p> <p>Returns a promise for the result of calling a function, with the given variadic arguments. Has the same return value/thrown exception translation as explained above for <code>fbind</code>.</p> <p>In its static form, it is aliased as <code>Q.try</code>, since it has semantics similar to a <code>try</code> block (but handling both synchronous exceptions and asynchronous rejections). This allows code like</p> <pre data-language="js">Q
.try(function () {
  if (!isConnectedToCloud()) {
    throw new Error("The cloud is down!");
  }

  return syncToCloud();
})
.catch(function (error) {
  console.error("Couldn't sync to the cloud", error);
});</pre> <h3 id="promise-for-array-methods"> Promise-for-Array Methods</h3> <h4 id="promise-all"> promise.all()</h4> <p>Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.</p> <p>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all succeed. For example:</p> <pre data-language="js">Q.all([getFromDisk(), getFromCloud()]).done(function (values) {
  assert(values[0] === values[1]); // values[0] is fromDisk and values[1] is fromCloud
});</pre> <h4 id="promise-allsettled"> promise.allSettled()</h4> <p>Returns a promise that is fulfilled with an array of promise state snapshots, but only after all the original promises have settled, i.e. become either fulfilled or rejected.</p> <p>This method is often used in its static form on arrays of promises, in order to execute a number of operations concurrently and be notified when they all finish, regardless of success or failure. For example:</p> <pre data-language="js">Q.allSettled([saveToDisk(), saveToCloud()]).spread(function (disk, cloud) {
  console.log("saved to disk:", disk.state === "fulfilled");
  console.log("saved to cloud:", cloud.state === "fulfilled");
}).done();</pre> <p>The state snapshots will be in the same form as those retrieved via <a href="#promiseinspect"><code>promise.inspect</code></a>, i.e. either <code>{ state: "fulfilled", value: v }</code> or <code>{ state: "rejected", reason: r }</code>.</p> <h4 id="promise-spread"> promise.spread(onFulfilled, onRejected)</h4> <p>Like <code>then</code>, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls <code>onRejected</code> with the first rejected promise's rejection reason.</p> <p>This is especially useful in conjunction with <code>all</code>, for example:</p> <pre data-language="js">Q.all([getFromDisk(), getFromCloud()]).spread(function (diskVal, cloudVal) {
  assert(diskVal === cloudVal);
}).done();</pre> <h3 id="utility-methods"> Utility Methods</h3> <h4 id="promise-thenresolve"> promise.thenResolve(value)</h4> <p><em>No Static Counterpart</em></p> <p>A sugar method, equivalent to <code>promise.then(function () { return value; })</code>.</p> <h4 id="promise-thenreject"> promise.thenReject(reason)</h4> <p><em>No Static Counterpart</em></p> <p>A sugar method, equivalent to <code>promise.then(function () { throw reason; })</code>.</p> <h4 id="promise-tap"> promise.tap(onFulfilled)</h4> <p><em>Introduced in version 1.1.0 (November 2014)</em></p> <p>Attaches a handler that will observe the value of the promise when it becomes fulfilled, returning a promise for that same value, perhaps deferred but not replaced by the promise returned by the <code>onFulfilled</code> handler.</p> <pre data-language="js">Q("Hello, World!")
.delay(1000)
.tap(console.log)
.then(function (message) {
  expect(message).toBe("Hello, World!");
})</pre> <h4 id="promise-timeout"> promise.timeout(ms, message)</h4> <p>Returns a promise that will have the same result as <code>promise</code>, except that if <code>promise</code> is not fulfilled or rejected before <code>ms</code> milliseconds, the returned promise will be rejected with an <code>Error</code> with the given <code>message</code>. If <code>message</code> is not supplied, the message will be <code>"Timed out after " + ms + " ms"</code>.</p> <pre data-language="js">promise.timeout(10000).then(
  function (result) {
  // will be called if the promise resolves normally
  console.log(result);
  },
  function (err) {
  // will be called if the promise is rejected, or the 10 second timeout occurs
  console.log(err);
  }
);</pre> <h4 id="promise-delay"> promise.delay(ms)</h4> <p>Returns a promise that will have the same result as <code>promise</code>, but will only be fulfilled after at least <code>ms</code> milliseconds have passed. If <code>promise</code> is rejected, the resulting promise will be rejected immediately.</p> <h4 id="q-delay"> Q.delay(ms)</h4> <p>If the static version of <code>Q.delay</code> is passed only a single argument, it returns a promise that will be fulfilled with <code>undefined</code> after at least <code>ms</code> milliseconds have passed. (If it's called with two arguments, it uses the usual static-counterpart translation, i.e. <code>Q.delay(value, ms)</code> is equivalent to <code>Q(value).delay(ms)</code>.)</p> <p>This is a convenient way to insert a delay into a promise chain, or even simply to get a nicer syntax for <code>setTimeout</code>:</p> <pre data-language="js">Q.delay(150).then(doSomething);</pre> <h3 id="state-inspection-methods"> State Inspection Methods</h3> <h4 id="promise-isfulfilled"> promise.isFulfilled()</h4> <p>Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always <code>true</code>.</p> <h4 id="promise-isrejected"> promise.isRejected()</h4> <p>Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always <code>false</code>.</p> <h4 id="promise-ispending"> promise.isPending()</h4> <p>Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always <code>false</code>.</p> <h4 id="promise-inspect"> promise.inspect()</h4> <p>Returns a "state snapshot" object, which will be in one of three forms:</p> <ul> <li><code>{ state: "pending" }</code></li> <li><code>{ state: "fulfilled", value: &lt;fulfllment value&gt; }</code></li> <li><code>{ state: "rejected", reason: &lt;rejection reason&gt; }</code></li> </ul> <h2 id="promise-creation"> Promise Creation</h2> <h3 id="qdefer"> Q.defer()</h3> <p>Returns a "deferred" object with a:</p> <ul> <li> <code>promise</code> property</li> <li> <code>resolve(value)</code> method</li> <li> <code>reject(reason)</code> method</li> <li> <code>notify(value)</code> method</li> <li> <code>makeNodeResolver()</code> method</li> </ul> <p>The <code>resolve</code> and <code>reject</code> methods control the state of the <code>promise</code> property, which you can hand out to others while keeping the authority to modify its state to yourself. The <code>notify</code> method is for progress notification, and the <code>makeNodeResolver</code> method is for interfacing with Node.js (see below).</p> <p>In all cases where a promise is resolved (i.e. either fulfilled or rejected), the resolution is permanent and cannot be reset. Attempting to call <code>resolve</code>, <code>reject</code>, or <code>notify</code> if <code>promise</code> is already resolved will be a no-op.</p> <p>Deferreds are cool because they separate the promise part from the resolver part. So:</p> <ul> <li> <p>You can give the promise to any number of consumers and all of them will observe the resolution independently. Because the capability of observing a promise is separated from the capability of resolving the promise, none of the recipients of the promise have the ability to "trick" other recipients with misinformation (or indeed interfere with them in any way).</p> </li> <li> <p>You can give the resolver to any number of producers and whoever resolves the promise first wins. Furthermore, none of the producers can observe that they lost unless you give them the promise part too.</p> </li> </ul> <h4 id="deferred-resolve"> deferred.resolve(value)</h4> <p>Calling <code>resolve</code> with a pending promise causes <code>promise</code> to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).</p> <p>Calling <code>resolve</code> with a rejected promise causes <code>promise</code> to be rejected with the passed promise's rejection reason.</p> <p>Calling <code>resolve</code> with a fulfilled promise causes <code>promise</code> to be fulfilled with the passed promise's fulfillment value.</p> <p>Calling <code>resolve</code> with a non-promise value causes <code>promise</code> to be fulfilled with that value.</p> <h4 id="deferred-reject"> deferred.reject(reason)</h4> <p>Calling <code>reject</code> with a reason causes <code>promise</code> to be rejected with that reason.</p> <h4 id="deferred-notify"> deferred.notify(value)</h4> <p>Calling <code>notify</code> with a value causes <code>promise</code> to be notified of progress with that value. That is, any <code>onProgress</code> handlers registered with <code>promise</code> or promises derived from <code>promise</code> will be called with the progress value.</p> <h3 id="q-object"> Q object</h3> <h4 id="q"> Q(value)</h4> <p>If <code>value</code> is a Q promise, returns the promise.</p> <p>If <code>value</code> is a promise from another library it is coerced into a Q promise (where possible).</p> <p>If <code>value</code> is not a promise, returns a promise that is fulfilled with <code>value</code>.</p> <h4 id="q-reject"> Q.reject(reason)</h4> <p>Returns a promise that is rejected with <code>reason</code>.</p> <h4 id="q-promise"> Q.Promise(resolver)</h4> <p>Synchronously calls <code>resolver(resolve, reject, notify)</code> and returns a promise whose state is controlled by the functions passed to <code>resolver</code>. This is an alternative promise-creation API that has the same power as the deferred concept, but without introducing another conceptual entity.</p> <p>If <code>resolver</code> throws an exception, the returned promise will be rejected with that thrown exception as the rejection reason.</p> <p><strong>note</strong>: In the latest github, this method is called Q.Promise, but if you are using the npm package version 0.9.7 or below, the method is called Q.promise (lowercase vs uppercase p).</p> <h3 id="interfacing-with-nodejs-callbacks"> Interfacing with Node.js Callbacks</h3> <p>Q provides a number of functions for interfacing with Node.js style <code>(err, result)</code> callback APIs.</p> <p>Several of these are usually used in their static form, and thus listed here as such. Nevertheless, they also exist on each Q promise, in case you somehow have a promise for a Node.js-style function or for an object with Node.js-style methods.</p> <p>Note that if a Node.js-style API calls back with more than one non-error parameter (e.g. <a href="http://nodejs.org/api/child_process.html#child_process_child_process_execfile_file_args_options_callback"><code>child_process.execFile</code></a>), Q packages these into an array as the promise's fulfillment value when doing the translation.</p> <h4 id="q-nfbind"> Q.nfbind(nodeFunc, ...args)</h4> <p><em>Alias</em>: <code>Q.denodeify</code></p> <p>Creates a promise-returning function from a Node.js-style function, optionally binding it with the given variadic arguments. An example:</p> <pre data-language="js">var readFile = Q.nfbind(FS.readFile);

readFile("foo.txt", "utf-8").done(function (text) {

});</pre> <p>Note that if you have a <em>method</em> that uses the Node.js callback pattern, as opposed to just a <em>function</em>, you will need to bind its <code>this</code> value before passing it to <code>nfbind</code>, like so:</p> <pre data-language="js">var Kitty = mongoose.model("Kitty");
var findKitties = Q.nfbind(Kitty.find.bind(Kitty));</pre> <p>The better strategy for methods would be to use <code>Q.nbind</code>, as shown below.</p> <h4 id="q-nbind"> Q.nbind(nodeMethod, thisArg, ...args)</h4> <p>Creates a promise-returning function from a Node.js-style method, optionally binding it with the given variadic arguments. An example:</p> <pre data-language="js">var Kitty = mongoose.model("Kitty");
var findKitties = Q.nbind(Kitty.find, Kitty);

findKitties({ cute: true }).done(function (theKitties) {

});</pre> <h4 id="q-nfapply"> Q.nfapply(nodeFunc, args)</h4> <p>Calls a Node.js-style function with the given array of arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</p> <pre data-language="js">Q.nfapply(FS.readFile, ["foo.txt", "utf-8"]).done(function (text) {
});</pre> <p>Note that this example only works because <code>FS.readFile</code> is a <em>function</em> exported from a module, not a <em>method</em> on an object. For methods, e.g. <code>redisClient.get</code>, you must bind the method to an instance before passing it to <code>Q.nfapply</code> (or, generally, as an argument to any function call):</p> <pre data-language="js">Q.nfapply(redisClient.get.bind(redisClient), ["user:1:id"]).done(function (user) {
});</pre> <p>The better strategy for methods would be to use <code>Q.npost</code>, as shown below.</p> <h4 id="q-nfcall"> Q.nfcall(func, ...args)</h4> <p>Calls a Node.js-style function with the given variadic arguments, returning a promise that is fulfilled if the Node.js function calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</p> <pre data-language="js">Q.nfcall(FS.readFile, "foo.txt", "utf-8").done(function (text) {
});</pre> <p>The same warning about functions vs. methods applies for <code>nfcall</code> as it does for <code>nfapply</code>. In this case, the better strategy would be to use <code>Q.ninvoke</code>.</p> <h4 id="q-npost"> Q.npost(object, methodName, args)</h4> <p><em>Deprecated Alias</em>: <code>Q.nmapply</code></p> <p>Calls a Node.js-style method with the given arguments array, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</p> <pre data-language="js">Q.npost(redisClient, "get", ["user:1:id"]).done(function (user) {
});</pre> <h4 id="q-ninvoke"> Q.ninvoke(object, methodName, ...args)</h4> <p><em>Alias:</em> <code>Q.nsend</code></p> <p><em>Deprecated Alias</em>: <code>Q.nmcall</code></p> <p>Calls a Node.js-style method with the given variadic arguments, returning a promise that is fulfilled if the method calls back with a result, or rejected if it calls back with an error (or throws one synchronously). An example:</p> <pre data-language="js">Q.ninvoke(redisClient, "get", "user:1:id").done(function (user) {
});</pre> <h4 id="promise-nodeify"> promise.nodeify(callback)</h4> <p>If <code>callback</code> is a function, assumes it's a Node.js-style callback, and calls it as either <code>callback(rejectionReason)</code> when/if <code>promise</code> becomes rejected, or as <code>callback(null, fulfillmentValue)</code> when/if <code>promise</code> becomes fulfilled. If <code>callback</code> is not a function, simply returns <code>promise</code>.</p> <p>This method is useful for creating dual promise/callback APIs, i.e. APIs that return promises but also accept Node.js-style callbacks. For example:</p> <pre data-language="js">function createUser(userName, userData, callback) {
  return database.ensureUserNameNotTaken(userName)
  .then(function () {
    return database.saveUserData(userName, userData);
  })
  .nodeify(callback);
}</pre> <h4 id="deferred-makenoderesolver"> deferred.makeNodeResolver()</h4> <p>Returns a function suitable for passing to a Node.js API. That is, it has a signature <code>(err, result)</code> and will reject <code>deferred.promise</code> with <code>err</code> if <code>err</code> is given, or fulfill it with <code>result</code> if that is given.</p> <h3 id="generators"> Generators</h3> <p><em>This functionality is experimental.</em></p> <h4 id="q-async"> Q.async(generatorFunction)</h4> <p>This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support <code>yield</code>. See <a href="https://github.com/kriskowal/q/tree/v1/examples/async-generators">the generators example</a> for further information.</p> <h4 id="q-spawn"> Q.spawn(generatorFunction)</h4> <p>This immediately runs a generator function, and forwards any uncaught errors to <code>Q.onerror</code>. An uncaught error is deemed to occur if the function returns a rejected promise. Note that this automatically occurs if the generator function throws an error, e.g. by <code>yield</code>ing on a promise that becomes rejected without surrounding that code with a <code>try</code>/<code>catch</code>:</p> <pre data-language="js">Q.spawn(function* () {
  // If `createUser` returns a rejected promise, the rejection reason will
  // reach `Q.onerror`.
  var user = yield createUser();
  showUserInUI(user);
});</pre> <h3 id="error-handling-and-tracking"> Error Handling and Tracking</h3> <h4 id="q-onerror"> Q.onerror</h4> <p>A settable property that will intercept any uncaught errors that would otherwise be thrown in the next tick of the event loop, usually as a result of <code>done</code>. Can be useful for getting the full stack trace of an error in browsers, which is not usually possible with <code>window.onerror</code>.</p> <h4 id="q-getunhandledreasons"> Q.getUnhandledReasons()</h4> <p>Gets an array of reasons belonging to rejected promises that currently have not been handled, i.e. no <code>onRejected</code> callbacks have been called for them, they haven't been chained off of, etc. Generally these represent potentially-"lost" errors, so this array should be empty except possibly at times when you are passing a rejected promise around asynchronously so that someone can handle the rejection later.</p> <h4 id="q-stopunhandledrejectiontracking"> Q.stopUnhandledRejectionTracking()</h4> <p>Turns off unhandled rejection tracking, which provides a slight efficiency boost if you don't find that debug information helpful. It also prevents Q from printing any unhandled rejection reasons upon process exit in Node.js.</p> <h4 id="q-resetunhandledrejections"> Q.resetUnhandledRejections()</h4> <p>Resets Q's internal tracking of unhandled rejections, but keeps unhandled rejection tracking on. This method is exposed mainly for testing and diagnostic purposes, where you may have accumulated some unhandled rejections but want to re-start with a clean slate.</p> <h3 id="other"> Other</h3> <h4 id="q-ispromise"> Q.isPromise(value)</h4> <p>Returns whether the given value is a Q promise.</p> <h4 id="q-ispromisealike"> Q.isPromiseAlike(value)</h4> <p>Returns whether the given value is a promise (i.e. it's an object with a <code>then</code> function).</p> <h4 id="q-promised"> Q.promised(func)</h4> <p>Creates a new version of <code>func</code> that accepts any combination of promise and non-promise values, converting them to their fulfillment values before calling the original <code>func</code>. The returned version also always returns a promise: if <code>func</code> does a <code>return</code> or <code>throw</code>, then <code>Q.promised(func)</code> will return fulfilled or rejected promise, respectively.</p> <p>This can be useful for creating functions that accept either promises or non-promise values, and for ensuring that the function always returns a promise even in the face of unintentional thrown exceptions.</p> <h4 id="q-longstacksupport"> Q.longStackSupport</h4> <p>A settable property that lets you turn on long stack trace support. If turned on, "stack jumps" will be tracked across asynchronous promise operations, so that if an uncaught error is thrown by <code>done</code> or a rejection reason's <code>stack</code> property is inspected in a rejection callback, a long stack trace is produced.</p> <h3 id="custom-messaging-api-advanced"> Custom Messaging API (Advanced)</h3> <p>The <code>Q</code> promise constructor establishes the basic API for performing operations on objects: "get", "put", "del", "post", "apply", and "keys". This set of "operators" can be extended by creating promises that respond to messages with other operator names, and by sending corresponding messages to those promises.</p> <h4 id="promise-dispatch"> promise.dispatch(operator, args)</h4> <p>Sends an arbitrary message to a promise, with the given array of arguments.</p> <p>Care should be taken not to introduce control-flow hazards and security holes when forwarding messages to promises. The functions above, particularly <code>then</code>, are carefully crafted to prevent a poorly crafted or malicious promise from breaking the invariants like not applying callbacks multiple times or in the same turn of the event loop.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2017 Kristopher Michael Kowal<br>Licensed under the MIT License.<br>
    <a href="https://github.com/kriskowal/q/wiki/API-Reference" class="_attribution-link">https://github.com/kriskowal/q/wiki/API-Reference</a>
  </p>
</div>
