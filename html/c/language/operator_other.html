    <h1 id="firstHeading" class="firstHeading">Other operators</h1>            <p>A collection of operators that do not fit into any of the other major categories.</p>
<table class="wikitable"> <tr style="text-align:center"> <th> Operator </th> <th> Operator name </th> <th> Example </th> <th> Description </th>
</tr> <tr style="text-align:center"> <td> <code>(...)</code> </td> <td> <a href="#Function_call">function call</a> </td> <td> <code>f(...)</code> </td> <td> call the function <b>f</b>(), with zero or more arguments </td>
</tr> <tr style="text-align:center"> <td> <code>,</code> </td> <td> <a href="#Comma_operator">comma operator</a> </td> <td> <code>a, b</code> </td> <td> evaluate expression <b>a</b>, disregard its return value and complete any side-effects, then evaluate expression <b>b</b>, returning the type and the result of this evaluation </td>
</tr> <tr style="text-align:center"> <td> <code>(type)</code> </td> <td> <a href="cast.html" title="c/language/cast">type cast</a> </td> <td> <code>(type)a</code> </td> <td> cast the type of <b>a</b> to <b>type</b> </td>
</tr> <tr style="text-align:center"> <td> <code>? :</code> </td> <td> <a href="#Conditional_operator">conditional operator</a> </td> <td> <code>a ? b : c</code> </td> <td> if <b>a</b> is logically true (does not evaluate to zero) then evaluate expression <b>b</b>, otherwise evaluate expression <b>c</b> </td>
</tr> <tr style="text-align:center"> <td> <code>sizeof</code> </td> <td> <a href="sizeof.html" title="c/language/sizeof">sizeof operator</a> </td> <td> <code>sizeof a</code> </td> <td> the size in bytes of <b>a</b> </td>
</tr> <tr style="text-align:center"> <td> <code>_Alignof</code><br><span class="t-mark-rev t-since-c11">(since C11)</span> </td> <td> <a href="_alignof.html" title="c/language/ Alignof">_Alignof operator</a> </td> <td> <code>_Alignof(type)</code> </td> <td> the alignment required of <b>type</b> </td>
</tr> <tr style="text-align:center"> <td> <code>typeof</code> </td> <td> <a href="typeof.html" title="c/language/typeof">typeof operators</a> </td> <td> <code>typeof(a)</code> </td> <td> the type of <b>a</b> </td>
</tr>
</table>  <h3 id="Function_call"> Function call</h3> <p>The function call expression has the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">expression</span> <code>(</code> <span class="t-spar">argument-list</span> ï»¿<span class="t-mark">(optional)</span> <code>)</code> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">expression</span> </td> <td> - </td> <td> any expression of pointer-to-function type (after <a href="conversion.html#Lvalue_conversions" title="c/language/conversion">lvalue conversions</a>) </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">argument-list</span> </td> <td> - </td> <td> comma-separated list of expressions (which cannot be comma operators) of any complete object type. May be omitted when calling functions that take no arguments. </td>
</tr>
</table> <p>The behavior of the function call expression depends on whether the prototype of the function being called is <a href="scope.html" title="c/language/scope">in scope</a> at the point of call.</p>
<h4 id="Call_to_a_function_with_a_prototype"> Call to a function with a prototype</h4> <div class="t-li1">
<span class="t-li">1)</span> The number of parameters must equal the number of arguments (unless the ellipsis parameter is used).</div> <div class="t-li1">
<span class="t-li">2)</span> The type of each parameter must be a type such that <a href="conversion.html" title="c/language/conversion">implicit conversion as if by assignment</a> exists that converts the unqualified type of the corresponding argument to the type of the parameter.</div> <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td>  Additionally, for every parameter of <a href="array.html" title="c/language/array">array type</a> that uses the keyword <code>static</code> between <code>[</code> and <code>]</code>, the argument expression must designate a pointer to the element of an array with at least that many elements as specified in the size expression of the parameter. </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <div class="t-li1">
<span class="t-li">3)</span> The arguments are evaluated <a href="eval_order.html" title="c/language/eval order">in unspecified order and without sequencing</a>.</div> <div class="t-li1">
<span class="t-li">4)</span> <a href="operator_assignment.html" title="c/language/operator assignment">Assignment</a> is performed to copy the value of each argument to the corresponding function parameter, ignoring any type qualifiers on the parameter type and its possibly recursive elements or members, if any (note: the function can modify its parameters, and those changes do not affect the arguments; C function calls are only call-by-value). <ul><li> if there is a <a href="variadic.html" title="c/language/variadic">trailing ellipsis</a> parameter, <a href="https://en.cppreference.com/mwiki/index.php?title=conversion&amp;action=edit&amp;redlink=1" class="new" title="conversion (page does not exist)">Default argument promotions</a> are performed on the remaining arguments, which are made available to <code>va_list</code>.</li></ul>
</div> <div class="t-li1">
<span class="t-li">5)</span> Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression) <div class="c source-c"><pre data-language="c">void f(char* p, int x) {}
int main(void)
{
    f("abc", 3.14); // array to pointer and float to int conversions
}</pre></div>
</div> <table class="t-rev-begin"> <tr class="t-rev t-until-c23">
<td> <h4 id="Call_to_a_function_without_a_prototype"> Call to a function without a prototype</h4> <span class="t-li">1)</span> The arguments are evaluated <a href="eval_order.html" title="c/language/eval order">in unspecified order and without sequencing</a>. <span class="t-li">2)</span> <a href="conversion.html#Default_argument_promotions" title="c/language/conversion">Default argument promotions</a> are performed on every argument expression. <span class="t-li">3)</span> <a href="operator_assignment.html" title="c/language/operator assignment">Assignment</a> is performed to copy the value of each argument to the corresponding function parameter, ignoring any type qualifiers on the parameter type and its possibly recursive elements or members, if any. <span class="t-li">4)</span> Function is executed, and the value it returns becomes the value of the function call expression (if the function returns void, the function call expression is a void expression) <div class="c source-c"><pre data-language="c">void f(); // no prototype
int main(void)
{
    f(1, 1.0f); // UB unless f is defined to take an int and a double
}
void f(int a, double c) {}</pre></div> <p>The behavior of a function call to a function without a prototype is undefined if</p>
<ul>
<li> the number of arguments does not match the number of parameters. </li>
<li> the promoted types of the arguments are not <a href="type.html#Compatible_types" title="c/language/type">compatible</a> with the promoted types of the parameters except that </li>
<ul>
<li> signed and unsigned versions of the same integer type are considered compatible if the value of the argument is representable by both types. </li>
<li> pointers to void and pointers to (possibly cvr-qualified) character types are considered compatible </li>
</ul>
</ul>  </td> <td><span class="t-mark-rev t-until-c23">(until C23)</span></td>
</tr> </table> <h4 id="Notes"> Notes</h4> <p>The evaluations of <span class="t-spar">expression</span> that designates the function to be called and all arguments are <a href="eval_order.html" title="c/language/eval order">unsequenced</a> with respect to each other (but there is a sequence point before the body of the function begins executing)</p>
<div class="c source-c"><pre data-language="c">(*pf[f1()]) (f2(), f3() + f4()); // f1, f2, f3, f4 may be called in any order</pre></div> <p>Although function call is only defined for pointers to functions, it works with function designators due to the <a href="conversion.html#Function_to_pointer_conversion" title="c/language/conversion">function-to-pointer implicit conversion</a>.</p>
<div class="c source-c"><pre data-language="c">int f(void) { return 1; }
int (*pf)(void) = f;
 
int main(void)
{
    f();    // convert f to pointer, then call
    (&amp;f)(); // create a pointer to function, then call
 
    pf();    // call the function
    (*pf)(); // obtain the function designator, convert to pointer, then calls
 
    (****f)(); // convert to pointer, obtain the function, repeat 4x, then call
    (****pf)(); // also OK
}</pre></div> <p>Functions that ignore unused arguments, such as <code><a href="../io/fprintf.html" title="c/io/fprintf">printf</a></code>, must be called with a prototype in scope (the prototype of such functions necessarily uses the <a href="variadic.html" title="c/language/variadic">trailing ellipsis</a> parameter) to avoid invoking undefined behavior.</p>
<p>The current standard wording of the semantics of preparing function parameters is defective, because it specifies that parameters are assigned from arguments while calling, which incorrectly rejects const-qualified parameter or member types, and inappropriately applies the semantics of volatile which is unimplementable for function parameters on many platforms. A post-C11 defect report <a rel="nofollow" class="external text" href="https://open-std.org/JTC1/SC22/WG14/www/docs/n2396.htm#dr_427">DR427</a> proposed change of such semantics from assignment to initialization, but was closed as not-a-defect.</p>
<table class="t-rev-begin"> <tr class="t-rev t-until-c99">
<td> <p>A function call expression where <span class="t-spar">expression</span> consists entirely of an identifier and that identifier is undeclared acts as though the identifier is declared as</p>
<div class="c source-c"><pre data-language="c">extern int identifier(); // returns int and has no prototype</pre></div> <p>So the following complete program is valid C89:</p>
<div class="c source-c"><pre data-language="c">main()
{
    int n = atoi("123"); // implicitly declares atoi as int atoi()
}</pre></div> </td> <td><span class="t-mark-rev t-until-c99">(until C99)</span></td>
</tr> </table> <h3 id="Comma_operator"> Comma operator</h3> <p>The comma operator expression has the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">lhs</span> <code>,</code> <span class="t-spar">rhs</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">lhs</span> </td> <td> - </td> <td> any expression </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">rhs</span> </td> <td> - </td> <td> any expression other than another comma operator (in other words, comma operator's <a href="operator_precedence.html" title="c/language/operator precedence">associativity</a> is left-to-right) </td>
</tr>
</table> <p>First, the left operand, <span class="t-spar">lhs</span>, is evaluated and its result value is discarded.</p>
<p>Then, a <a href="eval_order.html" title="c/language/eval order">sequence point</a> takes place, so that all side effects of <span class="t-spar">lhs</span> are complete.</p>
<p>Then, the right operand, <span class="t-spar">rhs</span>, is evaluated and its result is returned by the comma operator as a <a href="value_category.html" title="c/language/value category">non-lvalue</a>.</p>
<h3 id="Notes_2"> Notes</h3> <p>The type of the <span class="t-spar">lhs</span> may be <code>void</code> (that is, it may be a call to a function that returns <code>void</code>, or it can be an expression <a href="cast.html" title="c/language/cast">cast</a> to <code>void</code>)</p>
<p>The comma operator may be lvalue in C++, but never in C</p>
<p>The comma operator may return a struct (the only other expressions that return structs are compound literals, function calls, assignments, and the conditional operator)</p>
<p>In the following contexts, the comma operator cannot appear at the top level of an expression because the comma has a different meaning:</p>
<ul>
<li> argument list in a function call </li>
<li> initializer expression or <a href="initialization.html" title="c/language/initialization">initializer list</a> </li>
<li> <a href="generic.html" title="c/language/generic">generic selection</a> </li>
</ul> <p>If the comma operator has to be used in such context, it must be parenthesized:</p>
<div class="c source-c"><pre data-language="c">// int n = 2,3; // error, comma assumed to begin the next declarator
// int a[2] = {1,2,3}; // error: more initializers than elements
int n = (2,3), a[2] = {(1,2),3}; // OK
 
f(a, (t=3, t+2), c); // OK, first, stores 3 in t, then calls f with three arguments</pre></div> <p>Top-level comma operator is also disallowed in array bounds</p>
<div class="c source-c"><pre data-language="c">// int a[2,3]; // error
int a[(2,3)]; // OK, VLA array of size 3 (VLA because (2,3) is not a constant expression)</pre></div> <p>Comma operator is not allowed in <a href="constant_expression.html" title="c/language/constant expression">constant expressions</a>, regardless of whether it's on the top level or not</p>
<div class="c source-c"><pre data-language="c">// static int n = (1,2); // Error: constant expression cannot call the comma operator</pre></div> <h3 id="Cast_operator"> Cast operator</h3> <p>See <a href="cast.html" title="c/language/cast">cast operator</a></p>
<h3 id="Conditional_operator"> Conditional operator</h3> <p>The conditional operator expression has the form</p>
<table class="t-sdsc-begin">  <tr class="t-sdsc"> <td class="t-sdsc-nopad"> <span class="t-spar">condition</span> <code>?</code> <span class="t-spar">expression-true</span> <code>:</code> <span class="t-spar">expression-false</span> </td> <td class="t-sdsc-nopad"> </td> <td class="t-sdsc-nopad"> </td>
</tr> 
</table> <p>where</p>
<table class="t-par-begin"> <tr class="t-par"> <td> <span class="t-spar">condition</span> </td> <td> - </td> <td> an expression of scalar type </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression-true</span> </td> <td> - </td> <td> the expression that will be evaluated if condition compares unequal to zero </td>
</tr> <tr class="t-par"> <td> <span class="t-spar">expression-false</span> </td> <td> - </td> <td> the expression that will be evaluated if condition compares equal to zero </td>
</tr>
</table> <p>Only the following expressions are allowed as <span class="t-spar">expression-true</span> and <span class="t-spar">expression-false</span></p>
<ul>
<li> two expressions of any <a href="arithmetic_types.html" title="c/language/arithmetic types">arithmetic type</a> </li>
<li> two expressions of the same <a href="struct.html" title="c/language/struct">struct</a> or <a href="union.html" title="c/language/union">union</a> type </li>
<li> two expressions of void type </li>
<li> two expressions of pointer type, pointing to types that are <a href="type.html#Compatible_types" title="c/language/type">compatible</a>, ignoring cvr-qualifiers </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <ul><li> two expressions of <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code> type </li></ul> </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> </table> <ul>
<li> one expression is a pointer and the other is the null pointer constant (such as <code><a href="../types/null.html" title="c/types/NULL">NULL</a></code>)<span class="t-rev-inl t-since-c23"><span>or a <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code> value</span><span><span class="t-mark-rev t-since-c23">(since C23)</span></span></span> </li>
<li> one expression is a pointer to object and the other is a pointer to void (possibly qualified) </li>
</ul> <div class="t-li1">
<span class="t-li">1)</span> First, evaluates <span class="t-spar">condition</span>. There is a <a href="eval_order.html" title="c/language/eval order">sequence point</a> after this evaluation.</div> <div class="t-li1">
<span class="t-li">2)</span> If the result of <span class="t-spar">condition</span> compares unequal to zero, executes <span class="t-spar">expression-true</span>, otherwise executes <span class="t-spar">expression-false</span>
</div> <div class="t-li1">
<span class="t-li">3)</span> Performs a <a href="conversion.html" title="c/language/conversion">conversion</a> from the result of the evaluation to the <i>common type</i>, defined as follows:</div> <div class="t-li2">
<span class="t-li">1)</span> if the expressions have arithmetic type, the common type is the type after <a href="conversion.html#Usual_arithmetic_conversions" title="c/language/conversion">usual arithmetic conversions</a>
</div> <div class="t-li2">
<span class="t-li">2)</span> if the expressions have struct/union type, the common type is that struct/union type</div> <div class="t-li2">
<span class="t-li">3)</span> if the expressions are both void, the entire conditional operator expression is a void expression</div> <div class="t-li2">
<span class="t-li">4)</span> if one is a pointer and the other is a null pointer constant<span class="t-rev-inl t-since-c23"><span>or a <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code> value</span><span><span class="t-mark-rev t-since-c23">(since C23)</span></span></span>, the type is the type of that pointer</div> <div class="t-li2">
<span class="t-li">5)</span> if both are pointers, the result is the pointer to the type that combines cvr-qualifiers of both pointed-to types (that is, if one is <code>const int*</code> and the other is <code>volatile int*</code>, the result is <code>const volatile int*</code>), and if the types were different, the pointed-to type is the <a href="types.html#Composite_type" title="c/language/types" class="mw-redirect">composite type</a>.</div> <div class="t-li2">
<span class="t-li">6)</span> if one is a pointer to void, the result is a pointer to void with combined cvr-qualifiers</div> <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <span class="t-li">7)</span> if both have <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code> type, the common type is also <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code> </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> </table> <div class="c source-c"><pre data-language="c">#define ICE(x) (sizeof(*(1 ? ((void*)((x) * 0l)) : (int*)1)))
 
// if x is an Integer Constant Expression then macro expands to
 
sizeof(*(1 ? NULL : (int *) 1))  // (void *)((x)*0l)) -&gt; NULL
 
// according to point (4) this further converts into
 
sizeof(int)
 
// if x is not an Integer Constant Expression then macro expands to
// according to point (6)
 
(sizeof(*(void *)(x))           // Error due incomplete type</pre></div> <h4 id="Notes_3"> Notes</h4> <p>The conditional operator is never an <a href="value_category.html" title="c/language/value category">lvalue expression</a>, although it may return objects of struct/union type. The only other expressions that may return structs are <a href="operator_assignment.html" title="c/language/operator assignment">assignment</a>, <a href="#Comma_operator">comma</a>, <a href="#Function_call">function call</a>, and <a href="compound_literal.html" title="c/language/compound literal">compound literal</a>.</p>
<p>Note that in C++, it may be an lvalue expression.</p>
<p>See <a href="operator_precedence.html" title="c/language/operator precedence">operator precedence</a> for the details on the relative precedence of this operator and assignment.</p>
<p>Conditional operator has right-to-left associativity, which allows chaining</p>
<div class="t-example"> <div class="c source-c"><pre data-language="c">#include &lt;assert.h&gt;
 
enum vehicle { bus, airplane, train, car, horse, feet };
 
enum vehicle choose(char arg)
{
    return arg == 'B' ? bus      :
           arg == 'A' ? airplane :
           arg == 'T' ? train    :
           arg == 'C' ? car      :
           arg == 'H' ? horse    :
                        feet     ;
}
 
int main(void)
{
    assert(choose('H') == horse &amp;&amp; choose('F') == feet);
}</pre></div> </div> <h3 id="sizeof_operator"> <code>sizeof</code> operator</h3> <p>See <a href="sizeof.html" title="c/language/sizeof">sizeof operator</a></p>
<h3 id="Alignof_operator"> <code>_Alignof</code> operator</h3> <p>See <a href="_alignof.html" title="c/language/ Alignof">_Alignof operator</a></p>
<h3 id="typeof_operators"> <code>typeof</code> operators</h3> <p>See <a href="typeof.html" title="c/language/typeof">typeof operators</a></p>
<h3 id="References"> References</h3>  <ul>
<li> C23 standard (ISO/IEC 9899:2023): </li>
<ul>
<li> 6.5.2.2 Function calls (p: TBD) </li>
<li> 6.5.3.4 The sizeof and _Alignof operators (p: TBD) </li>
<li> 6.5.4 Cast operators (p: TBD) </li>
<li> 6.5.15 Conditional operator (p: TBD) </li>
<li> 6.5.17 Comma operator (p: TBD) </li>
<li> 6.7.3.5 Typeof specifiers (p: 115-118) </li>
</ul>
<li> C17 standard (ISO/IEC 9899:2018): </li>
<ul>
<li> 6.5.2.2 Function calls (p: 58-59) </li>
<li> 6.5.3.4 The sizeof and _Alignof operators (p: 64-65) </li>
<li> 6.5.4 Cast operators (p: 65-66) </li>
<li> 6.5.15 Conditional operator (p: 71-72) </li>
<li> 6.5.17 Comma operator (p: 75) </li>
</ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul>
<li> 6.5.2.2 Function calls (p: 81-82) </li>
<li> 6.5.3.4 The sizeof and _Alignof operators (p: 90-91) </li>
<li> 6.5.4 Cast operators (p: 91) </li>
<li> 6.5.15 Conditional operator (p: 100) </li>
<li> 6.5.17 Comma operator (p: 105) </li>
</ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul>
<li> 6.5.2.2 Function calls (p: 71-72) </li>
<li> 6.5.3.4 The sizeof operator (p: 80-81) </li>
<li> 6.5.4 Cast operators (p: 81) </li>
<li> 6.5.15 Conditional operator (p: 90-91) </li>
<li> 6.5.17 Comma operator (p: 94) </li>
</ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul>
<li> 3.3.2.2 Function calls </li>
<li> 3.3.3.4 The sizeof operator </li>
<li> 3.3.4 Cast operators </li>
<li> 3.3.15 Conditional operator </li>
<li> 3.3.17 Comma operator </li>
</ul>
</ul>                                        <h3 id="See_also"> See also</h3> <ul><li> <a href="operator_precedence.html" title="c/language/operator precedence">Operator precedence</a> </li></ul> <table class="wikitable"> <tr style="text-align:center"> <th colspan="7"> Common operators </th>
</tr> <tr style="text-align:center"> <td> <a href="operator_assignment.html" title="c/language/operator assignment"> assignment</a> </td> <td> <a href="operator_incdec.html" title="c/language/operator incdec"> increment<br>decrement</a> </td> <td> <a href="operator_arithmetic.html" title="c/language/operator arithmetic"> arithmetic</a> </td> <td> <a href="operator_logical.html" title="c/language/operator logical"> logical</a> </td> <td> <a href="operator_comparison.html" title="c/language/operator comparison"> comparison</a> </td> <td> <a href="operator_member_access.html" title="c/language/operator member access"> member<br>access</a> </td> <td> <strong class="selflink"> other</strong> </td>
</tr> <tr style="text-align:center"> <td> <p><code>a = b a += b a -= b a *= b a /= b a %= b a &amp;= b a |= b a ^= b a &lt;&lt;= b a &gt;&gt;= b</code></p>
</td> <td> <p><code>++a --a a++ a--</code></p>
</td> <td> <p><code>+a -a a + b a - b a * b a / b a % b ~a a &amp; b a | b a ^ b a &lt;&lt; b a &gt;&gt; b</code></p>
</td> <td> <p><code>!a a &amp;&amp; b a || b</code></p>
</td> <td> <p><code>a == b a != b a &lt; b a &gt; b a &lt;= b a &gt;= b</code></p>
</td> <td> <p><code>a[b] *a &amp;a a-&gt;b a.b</code></p>
</td> <td> <p><code>a(...) a, b (type) a a ? b : c sizeof</code><br><br> <code>_Alignof</code><br><span class="t-mark-rev t-since-c11">(since C11)</span></p>
</td>
</tr> </table> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/cpp/language/operator_other" title="cpp/language/operator other">C++ documentation</a></span> for <span class=""><span>Other operators</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/c/language/operator_other" class="_attribution-link">https://en.cppreference.com/w/c/language/operator_other</a>
  </p>
</div>
