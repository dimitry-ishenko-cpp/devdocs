    <h1 id="firstHeading" class="firstHeading">Type</h1>            <p><small>(See also <a href="arithmetic_types.html" title="c/language/arithmetic types">arithmetic types</a> for the details on most built-in types and <a href="../types.html" title="c/types">the list of type-related utilities</a> that are provided by the C library.)</small></p>
<p><a href="object.html" title="c/language/object">Objects</a>, <a href="functions.html" title="c/language/functions">functions</a>, and <a href="expressions.html" title="c/language/expressions">expressions</a> have a property called <i>type</i>, which determines the interpretation of the binary value stored in an object or evaluated by the expression.</p>
<h3 id="Type_classification"> Type classification</h3> <p>The C type system consists of the following types:</p>
<ul>
<li>the type <code>void</code> </li>
<li>basic types </li>
<li>the type <code>char</code> </li>
<li>signed integer types </li>
<ul><li>standard: <code>signed char</code>, <code>short</code>, <code>int</code>, <code>long</code><span class="t-rev-inl t-since-c99"><span>, <code>long long</code></span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li></ul>
</ul>    <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <ul><li>bit-precise: <code>_BitInt(N)</code> where N is an integer constant expression that specifies the number of bits that are used to represent the type, including the sign bit. Each value of N designates a distinct type. </li></ul>  </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> <tr class="t-rev t-since-c99">
<td> <ul><li>extended: implementation defined, e.g. <code>__int128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li>unsigned integer types </li>
<ul><li>standard: <span class="t-rev-inl t-since-c99"><span><code>_Bool</code>,</span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> <code>unsigned char</code>, <code>unsigned short</code>, <code>unsigned int</code>, <code>unsigned long</code><span class="t-rev-inl t-since-c99"><span>, <code>unsigned long long</code></span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li></ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <ul><li>bit-precise: <code>unsigned _BitInt(N)</code> where N is an integer constant expression that specifies the number of bits that are used to represent the type. Each value of N designates a distinct type. This category includes the type <code>unsigned _BitInt(1)</code> which does not have a corresponding bit-precise signed integer type </li></ul>  </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> <tr class="t-rev t-since-c99">
<td> <ul><li>extended: implementation-defined, e.g. <code>__uint128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li>floating-point types </li>
<ul><li>real floating-point types: <code>float</code>, <code>double</code>, <code>long double</code> </li></ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c23">
<td> <ul><li>decimal real floating-point types: <code>_Decimal32</code>, <code>_Decimal64</code>, <code>_Decimal128</code> </li></ul>  </td> <td><span class="t-mark-rev t-since-c23">(since C23)</span></td>
</tr> <tr class="t-rev t-since-c99">
<td> <ul>
<li>complex types: <code>float _Complex</code>, <code>double _Complex</code>, <code>long double _Complex</code> </li>
<li>imaginary types: <code>float _Imaginary</code>, <code>double _Imaginary</code>, <code>long double _Imaginary</code> </li>
</ul>  </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul>
<li> <a href="enum.html" title="c/language/enum">enumerated types</a> </li>
<li> derived types </li>
<ul>
<li> <a href="array.html" title="c/language/array">array types</a> </li>
<li> <a href="struct.html" title="c/language/struct">structure types</a> </li>
<li> <a href="union.html" title="c/language/union">union types</a> </li>
<li> <a href="functions.html" title="c/language/functions">function types</a> </li>
<li> <a href="pointer.html" title="c/language/pointer">pointer types</a> </li>
</ul>
</ul>   <table class="t-rev-begin"> <tr class="t-rev t-since-c11">
<td> <ul><li> <a href="atomic.html" title="c/language/atomic">atomic types</a> </li></ul> </td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p>For every type listed above several qualified versions of its type may exist, corresponding to the combinations of one, two, or all three of the <a href="const.html" title="c/language/const"><code>const</code></a>, <a href="volatile.html" title="c/language/volatile"><code>volatile</code></a>, and <a href="restrict.html" title="c/language/restrict"><code>restrict</code></a> qualifiers (where allowed by the qualifier's semantics).</p>
<h4 id="Type_groups"> Type groups</h4> <ul>
<li> <i>object types</i>: all types that aren't function types </li>
<li> <i>character types</i>: <code>char</code>, <code>signed char</code>, <code>unsigned char</code> </li>
<li> <i>integer types</i>: <code>char</code>, signed integer types, unsigned integer types, enumerated types </li>
<li> <i>real types</i>: integer types and real floating types </li>
<li> <a href="arithmetic_types.html" title="c/language/arithmetic types">arithmetic types</a>: integer types and floating types </li>
<li> <i>scalar types</i>: arithmetic types, pointer types<span class="t-rev-inl t-since-c23"><span>, and <code><a href="../types/nullptr_t.html" title="c/types/nullptr t">nullptr_t</a></code></span><span><span class="t-mark-rev t-since-c23">(since C23)</span></span></span> </li>
<li> <i>aggregate types</i>: array types and structure types </li>
<li> <i>derived declarator types</i>: array types, function types, and pointer types </li>
</ul> <p>Constructing a complete object type such that the number of bytes in its object representation is not representable in the type <code><a href="../types/size_t.html" title="c/types/size t">size_t</a></code> (i.e. the result type of <a href="sizeof.html" title="c/language/sizeof"><code>sizeof</code></a> operator)<span class="t-rev-inl t-since-c99"><span>, including forming such a VLA type at runtime,</span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> is undefined behavior.</p>
<h3 id="Compatible_types"> Compatible types</h3> <p>In a C program, the declarations referring to the same object or function in <i>different translation units</i> do not have to use the same type. They only have to use sufficiently similar types, formally known as <i>compatible types</i>. Same applies to function calls and lvalue accesses; argument types must be <i>compatible</i> with parameter types and lvalue expression type must be <i>compatible</i> with the object type that is accessed.</p>
<p>The types <code>T</code> and <code>U</code> are compatible, if</p>
<ul>
<li> they are the same type (same name or aliases introduced by a <a href="typedef.html" title="c/language/typedef"><code>typedef</code></a>) </li>
<li> they are identically cvr-qualified versions of compatible unqualified types </li>
<li> they are pointer types and are pointing to compatible types </li>
<li> they are array types, and </li>
<ul>
<li> their element types are compatible, and </li>
<li> if both have constant size, that size is the same. Note: arrays of unknown bound are compatible with any array of compatible element type. <span class="t-rev-inl t-since-c99"><span>VLA is compatible with any array of compatible element type.</span><span><span class="t-mark-rev t-since-c99">(since C99)</span></span></span> </li>
</ul>
<li> they are both structure/union/enumeration types, and </li>
<li>
<span class="t-mark-rev t-since-c99">(C99)</span>if one is declared with a tag, the other must also be declared with the same tag. </li>
<li> if both are completed types, their members must correspond exactly in number, be declared with compatible types, and have matching names. </li>
<li> additionally, if they are enumerations, corresponding members must also have the same values. </li>
<li> additionally, if they are structures or unions, </li>
<ul>
<li> Corresponding members must be declared in the same order (structures only) </li>
<li> Corresponding <a href="bit_field.html" title="c/language/bit field">bit-fields</a> must have the same widths. </li>
</ul>
<li> one is an enumerated type and the other is that enumeration's underlying type </li>
<li> they are function types, and </li>
<ul>
<li> their return types are compatible </li>
<li> they both use parameter lists, the number of parameters (including the use of the ellipsis) is the same, and the corresponding parameter, after applying array-to-pointer and function-to-pointer type adjustments and after stripping top-level qualifiers, have compatible types </li>
</ul>
</ul>        <table class="t-rev-begin"> <tr class="t-rev t-until-c23">
<td> <ul>
<li> one is an old-style (parameter-less) definition, the other has a parameter list, the parameter list does not use an ellipsis and each parameter is compatible (after function parameter type adjustment) with the corresponding old-style parameter after default argument promotions </li>
<li> one is an old-style (parameter-less) declaration, the other has a parameter list, the parameter list does not use an ellipsis, and all parameters (after function parameter type adjustment) are unaffected by default argument promotions </li>
</ul> </td> <td><span class="t-mark-rev t-until-c23">(until C23)</span></td>
</tr> </table> <p>The type <code>char</code> is not compatible with <code>signed char</code> and not compatible with <code>unsigned char</code>.</p>
<p>If two declarations refer to the same object or function and do not use compatible types, the behavior of the program is undefined.</p>
<div class="c source-c"><pre data-language="c">// Translation Unit 1
struct S { int a; };
extern struct S *x; // compatible with TU2's x, but not with TU3's x
 
// Translation Unit 2
struct S;
extern struct S *x; // compatible with both x's
 
// Translation Unit 3
struct S { float a; };
extern struct S *x; // compatible with TU2's x, but not with TU1's x
 
// the behavior is undefined</pre></div> <div class="c source-c"><pre data-language="c">// Translation Unit 1
#include &lt;stdio.h&gt;
 
struct s { int i; }; // compatible with TU3's s, but not TU2's
extern struct s x = {0}; // compatible with TU3's x
extern void f(void); // compatible with TU2's f
 
int main()
{
    f();
    return x.i;
}
 
// Translation Unit 2
struct s { float f; }; // compatible with TU4's s, but not TU1's s
extern struct s y = {3.14}; // compatible with TU4's y
void f() // compatible with TU1's f
{
    return;
}
 
// Translation Unit 3
struct s { int i; }; // compatible with TU1's s, but not TU2's s
extern struct s x; // compatible with TU1's x
 
// Translation Unit 4
struct s { float f; }; // compatible with TU2's s, but not TU1's s
extern struct s y; // compatible with TU2's y
 
// the behavior is well-defined: only multiple declarations
// of objects and functions must have compatible types, not the types themselves</pre></div> <p>Note: C++ has no concept of compatible types. A C program that declares two types that are compatible but not identical in different translation units is not a valid C++ program.</p>
<h3 id="Composite_types"> Composite types</h3> <p>A composite type can be constructed from two types that are compatible; it is a type that is compatible with both of the two types and satisfies the following conditions:</p>
<ul>
<li>If both types are array types, the following rules are applied: </li>
<ul><li>If one type is an array of known constant size, the composite type is an array of that size. </li></ul>
</ul>  <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul>
<li>Otherwise, if one type is a VLA whose size is specified by an expression that is not evaluated, a program necessitating the composite type of both types has undefined behavior. </li>
<li>Otherwise, if one type is a VLA whose size is specified, the composite type is a VLA of that size. </li>
<li>Otherwise, if one type is a VLA of unspecified size, the composite type is a VLA of unspecified size. </li>
</ul> </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> </table> <ul><li>Otherwise, both types are arrays of unknown size and the composite type is an array of unknown size. </li></ul> The element type of the composite type is the composite type of the two element types.   <table class="t-rev-begin"> <tr class="t-rev t-until-c23">
<td> <ul><li>If only one type is a function type with a parameter type list (a function prototype), the composite type is a function prototype with the parameter type list. </li></ul> </td> <td><span class="t-mark-rev t-until-c23">(until C23)</span></td>
</tr> </table> <ul><li>If both types are function types with parameter type lists, the type of each parameter in the composite parameter type list is the composite type of the corresponding parameters. </li></ul> <p>These rules apply recursively to the types from which the two types are derived.</p>
<div class="c source-c"><pre data-language="c">// Given the following two file scope declarations:
int f(int (*)(), double (*)[3]);
int f(int (*)(char *), double (*)[]); // C23: Error: conflicting types for 'f'
// The resulting composite type for the function is:
int f(int (*)(char *), double (*)[3]);</pre></div> <p>For an identifier with internal or external <a href="storage_duration.html" title="c/language/storage duration">linkage</a> declared in a scope in which a prior declaration of that identifier is visible, if the prior declaration specifies internal or external linkage, the type of the identifier at the later declaration becomes the composite type.</p>
<h3 id="Incomplete_types"> Incomplete types</h3> <p>An incomplete type is an object type that lacks sufficient information to determine the size of the objects of that type. An incomplete type may be completed at some point in the translation unit.</p>
<p>The following types are incomplete:</p>
<ul>
<li> the type <code>void</code>. This type cannot be completed. </li>
<li> array type of unknown size. It can be completed by a later declaration that specifies the size. </li>
</ul> <div class="c source-c"><pre data-language="c">extern char a[]; // the type of a is incomplete (this typically appears in a header)
char a[10];      // the type of a is now complete (this typically appears in a source file)</pre></div> <ul><li> structure or union type of unknown content. It can be completed by a declaration of the same structure or union that defines its content later in the same scope. </li></ul> <div class="c source-c"><pre data-language="c">struct node
{
    struct node *next; // struct node is incomplete at this point
}; // struct node is complete at this point</pre></div> <h3 id="Type_names"> Type names</h3> <p>A type may have to be named in context other than the <a href="declarations.html" title="c/language/declarations">declaration</a>. In these situations, <i>type name</i> is used, which is, grammatically, exactly the same as a list of <i>type-specifiers</i> and <i>type-qualifiers</i>, followed by the <i>declarator</i> (see <a href="declarations.html" title="c/language/declarations">declarations</a>) as would be used to declare a single object or function of this type, except that the identifier is omitted:</p>
<div class="c source-c"><pre data-language="c">int n; // declaration of an int
sizeof(int); // use of type name
 
int *a[3]; // declaration of an array of 3 pointers to int
sizeof(int *[3]); // use of type name
 
int (*p)[3]; // declaration of a pointer to array of 3 int
sizeof(int (*)[3]); // use of type name
 
int (*a)[*] // declaration of pointer to VLA (in a function parameter)
sizeof(int (*)[*]) // use of type name (in a function parameter)
 
int *f(void); // declaration of function
sizeof(int *(void)); // use of type name
 
int (*p)(void); // declaration of pointer to function
sizeof(int (*)(void)); // use of type name
 
int (*const a[])(unsigned int, ...) = {0}; // array of pointers to functions
sizeof(int (*const [])(unsigned int, ...)); // use of type name</pre></div> <p>Except the redundant parentheses around the identifier are meaningful in a type-name and represent "function with no parameter specification":</p>
<div class="c source-c"><pre data-language="c">int (n); // declares n of type int
sizeof(int ()); // uses type "function returning int"</pre></div> <p>Type names are used in the following situations:</p>
<ul>
<li> <a href="cast.html" title="c/language/cast">cast</a> </li>
<li> <a href="sizeof.html" title="c/language/sizeof">sizeof</a> </li>
</ul> <table class="t-rev-begin"> <tr class="t-rev t-since-c99">
<td> <ul><li> <a href="compound_literal.html" title="c/language/compound literal">compound literal</a> </li></ul> </td> <td><span class="t-mark-rev t-since-c99">(since C99)</span></td>
</tr> <tr class="t-rev t-since-c11">
<td> <ul>
<li> <a href="generic.html" title="c/language/generic">generic selection</a> </li>
<li> <a href="_alignof.html" title="c/language/ Alignof">_Alignof</a> </li>
<li> <a href="_alignas.html" title="c/language/ Alignas">_Alignas</a> </li>
<li> <a href="atomic.html" title="c/language/atomic">_Atomic</a> (when used as a type specifier) </li>
</ul> </td> <td><span class="t-mark-rev t-since-c11">(since C11)</span></td>
</tr> </table> <p><br> A type name may introduce a new type:</p>
<div class="c source-c"><pre data-language="c">void* p = (void*)(struct X { int i; } *)0;
// type name "struct X {int i;}*" used in the cast expression
// introduces the new type "struct X"
struct X x = {1}; // struct X is now in scope</pre></div> <h3 id="References"> References</h3>  <ul>
<li> C23 standard (ISO/IEC 9899:2023): </li>
<ul>
<li> 6.2.5 Types (p: TBD) </li>
<li> 6.2.6 Representations of types (p: TBD) </li>
<li> 6.2.7 Compatible type and composite type (p: TBD) </li>
</ul>
<li> C17 standard (ISO/IEC 9899:2018): </li>
<ul>
<li> 6.2.5 Types (p: 31-33) </li>
<li> 6.2.6 Representations of types (p: 31-35) </li>
<li> 6.2.7 Compatible type and composite type (p: 35-36) </li>
</ul>
<li> C11 standard (ISO/IEC 9899:2011): </li>
<ul>
<li> 6.2.5 Types (p: 39-43) </li>
<li> 6.2.6 Representations of types (p: 44-46) </li>
<li> 6.2.7 Compatible type and composite type (p: 47-48) </li>
</ul>
<li> C99 standard (ISO/IEC 9899:1999): </li>
<ul>
<li> 6.2.5 Types (p: 33-37) </li>
<li> 6.2.6 Representations of types (p: 37-40) </li>
<li> 6.2.7 Compatible type and composite type (p: 40-41) </li>
</ul>
<li> C89/C90 standard (ISO/IEC 9899:1990): </li>
<ul>
<li> 3.1.2.5 Types </li>
<li> 3.1.2.6 Compatible type and composite type </li>
</ul>
</ul>                            <h3 id="See_also"> See also</h3> <table class="t-dsc-begin"> <tr class="t-dsc"> <td colspan="2"> <span><a href="https://en.cppreference.com/w/cpp/language/type" title="cpp/language/type">C++ documentation</a></span> for <span class=""><span>Type</span></span> </td>
</tr> </table>           <div class="_attribution">
  <p class="_attribution-p">
    &copy; cppreference.com<br>Licensed under the Creative Commons Attribution-ShareAlike Unported License v3.0.<br>
    <a href="https://en.cppreference.com/w/c/language/type" class="_attribution-link">https://en.cppreference.com/w/c/language/type</a>
  </p>
</div>
