<h1 id="connections">  Connections  </h1>   <p>You can connect to MongoDB with the <code>mongoose.connect()</code> method.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/myapp'</span>);
</pre> <p>This is the minimum needed to connect the <code>myapp</code> database running locally on the default port (27017). For local MongoDB databases, we recommend using <code>127.0.0.1</code> instead of <code>localhost</code>. That is because Node.js 18 and up prefer IPv6 addresses, which means, on many machines, Node.js will resolve <code>localhost</code> to the IPv6 address <code>::1</code> and Mongoose will be unable to connect, unless the mongodb instance is running with ipv6 enabled.</p> <p>You can also specify several more parameters in the <code>uri</code>:</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://username:password@host:port/database?options...'</span>);
</pre> <p>See the <a href="http://www.mongodb.com/docs/manual/reference/connection-string/">mongodb connection string spec</a> for more details.</p>  <h2 id="buffering">Operation Buffering</h2> <p>Mongoose lets you start using your models immediately, without waiting for mongoose to establish a connection to MongoDB.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/myapp'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">MyModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Test'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));
<span class="hljs-comment">// Works</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">MyModel</span>.<span class="hljs-title function_">findOne</span>();
</pre> <p>That's because mongoose buffers model function calls internally. This buffering is convenient, but also a common source of confusion. Mongoose will <em>not</em> throw any errors by default if you use a model without connecting.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyModel</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Test'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));
<span class="hljs-keyword">const</span> promise = <span class="hljs-title class_">MyModel</span>.<span class="hljs-title function_">findOne</span>();

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>() {
  mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/myapp'</span>);
}, <span class="hljs-number">60000</span>);

<span class="hljs-comment">// Will just hang until mongoose successfully connects</span>
<span class="hljs-keyword">await</span> promise;
</pre> <p>To disable buffering, turn off the <a href="guide.html#bufferCommands"><code>bufferCommands</code> option on your schema</a>. If you have <code>bufferCommands</code> on and your connection is hanging, try turning <code>bufferCommands</code> off to see if you haven't opened a connection properly. You can also disable <code>bufferCommands</code> globally:</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">set</span>(<span class="hljs-string">'bufferCommands'</span>, <span class="hljs-literal">false</span>);
</pre> <p>Note that buffering is also responsible for waiting until Mongoose creates collections if you use the <a href="guide.html#autoCreate"><code>autoCreate</code> option</a>. If you disable buffering, you should also disable the <code>autoCreate</code> option and use <a href="api/model.html#model_Model-createCollection"><code>createCollection()</code></a> to create <a href="guide.html#capped">capped collections</a> or <a href="guide.html#collation">collections with collations</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
}, {
  <span class="hljs-attr">capped</span>: { <span class="hljs-attr">size</span>: <span class="hljs-number">1024</span> },
  <span class="hljs-attr">bufferCommands</span>: <span class="hljs-literal">false</span>,
  <span class="hljs-attr">autoCreate</span>: <span class="hljs-literal">false</span> <span class="hljs-comment">// disable `autoCreate` since `bufferCommands` is false</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Model</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Test'</span>, schema);
<span class="hljs-comment">// Explicitly create the collection before using it</span>
<span class="hljs-comment">// so the collection is capped.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Model</span>.<span class="hljs-title function_">createCollection</span>();
</pre> <h2 id="error-handling">Error Handling</h2> <p>There are two classes of errors that can occur with a Mongoose connection.</p> <ul> <li>
<strong>Error on initial connection</strong>: If initial connection fails, Mongoose will emit an 'error' event and the promise <code>mongoose.connect()</code> returns will reject. However, Mongoose will <strong>not</strong> automatically try to reconnect.</li> <li>
<strong>Error after initial connection was established</strong>: Mongoose will attempt to reconnect, and it will emit an 'error' event.</li> </ul> <p>To handle initial connection errors, you should use <code>.catch()</code> or <code>try/catch</code> with async/await.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/test'</span>).
  <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-title function_">handleError</span>(error));

<span class="hljs-comment">// Or:</span>
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/test'</span>);
} <span class="hljs-keyword">catch</span> (error) {
  <span class="hljs-title function_">handleError</span>(error);
}
</pre> <p>To handle errors after initial connection was established, you should listen for error events on the connection. However, you still need to handle initial connection errors as shown above.</p> <pre data-language="javascript">mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">on</span>(<span class="hljs-string">'error'</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
  <span class="hljs-title function_">logError</span>(err);
});
</pre> <p>Note that Mongoose does not necessarily emit an 'error' event if it loses connectivity to MongoDB. You should listen to the <code>disconnected</code> event to report when Mongoose is disconnected from MongoDB.</p> <h2 id="options">Options</h2> <p>The <code>connect</code> method also accepts an <code>options</code> object which will be passed on to the underlying MongoDB driver.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(uri, options);
</pre> <p>A full list of options can be found on the <a href="https://mongodb.github.io/node-mongodb-native/4.2/interfaces/MongoClientOptions.html">MongoDB Node.js driver docs for <code>MongoClientOptions</code></a>. Mongoose passes options to the driver without modification, modulo a few exceptions that are explained below.</p> <ul> <li>
<code>bufferCommands</code> - This is a mongoose-specific option (not passed to the MongoDB driver) that disables <a href="https://mongoosejs.com/docs/faq.html#callback_never_executes">Mongoose's buffering mechanism</a>
</li> <li>
<code>user</code>/<code>pass</code> - The username and password for authentication. These options are Mongoose-specific, they are equivalent to the MongoDB driver's <code>auth.username</code> and <code>auth.password</code> options.</li> <li>
<code>autoIndex</code> - By default, mongoose will automatically build indexes defined in your schema when it connects. This is great for development, but not ideal for large production deployments, because index builds can cause performance degradation. If you set <code>autoIndex</code> to false, mongoose will not automatically build indexes for <strong>any</strong> model associated with this connection.</li> <li>
<code>dbName</code> - Specifies which database to connect to and overrides any database specified in the connection string. This is useful if you are unable to specify a default database in the connection string like with <a href="https://stackoverflow.com/questions/48917591/fail-to-connect-mongoose-to-atlas/48917626#48917626">some <code>mongodb+srv</code> syntax connections</a>.</li> </ul> <p>Below are some of the options that are important for tuning Mongoose.</p> <ul> <li>
<code>promiseLibrary</code> - Sets the <a href="http://mongodb.github.io/node-mongodb-native/3.1/api/MongoClient.html">underlying driver's promise library</a>.</li> <li>
<code>maxPoolSize</code> - The maximum number of sockets the MongoDB driver will keep open for this connection. By default, <code>maxPoolSize</code> is 100. Keep in mind that MongoDB only allows one operation per socket at a time, so you may want to increase this if you find you have a few slow queries that are blocking faster queries from proceeding. See <a href="http://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs">Slow Trains in MongoDB and Node.js</a>. You may want to decrease <code>maxPoolSize</code> if you are running into <a href="https://www.mongodb.com/docs/atlas/reference/atlas-limits/#connection-limits-and-cluster-tier">connection limits</a>.</li> <li>
<code>minPoolSize</code> - The minimum number of sockets the MongoDB driver will keep open for this connection. The MongoDB driver may close sockets that have been inactive for some time. You may want to increase <code>minPoolSize</code> if you expect your app to go through long idle times and want to make sure your sockets stay open to avoid slow trains when activity picks up.</li> <li>
<code>socketTimeoutMS</code> - How long the MongoDB driver will wait before killing a socket due to inactivity <em>after initial connection</em>. A socket may be inactive because of either no activity or a long-running operation. <code>socketTimeoutMS</code> defaults to 0, which means Node.js will not time out the socket due to inactivity. This option is passed to <a href="https://nodejs.org/api/net.html#net_socket_settimeout_timeout_callback">Node.js <code>socket#setTimeout()</code> function</a> after the MongoDB driver successfully completes.</li> <li>
<code>family</code> - Whether to connect using IPv4 or IPv6. This option passed to <a href="https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback">Node.js' <code>dns.lookup()</code></a> function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your <code>mongoose.connect(uri)</code> call takes a long time, try <code>mongoose.connect(uri, { family: 4 })</code>
</li> <li>
<code>authSource</code> - The database to use when authenticating with <code>user</code> and <code>pass</code>. In MongoDB, <a href="https://www.mongodb.com/docs/manual/tutorial/manage-users-and-roles/">users are scoped to a database</a>. If you are getting an unexpected login failure, you may need to set this option.</li> <li>
<code>serverSelectionTimeoutMS</code> - The MongoDB driver will try to find a server to send any given operation to, and keep retrying for <code>serverSelectionTimeoutMS</code> milliseconds. If not set, the MongoDB driver defaults to using <code>30000</code> (30 seconds).</li> <li>
<code>heartbeatFrequencyMS</code> - The MongoDB driver sends a heartbeat every <code>heartbeatFrequencyMS</code> to check on the status of the connection. A heartbeat is subject to <code>serverSelectionTimeoutMS</code>, so the MongoDB driver will retry failed heartbeats for up to 30 seconds by default. Mongoose only emits a <code>'disconnected'</code> event after a heartbeat has failed, so you may want to decrease this setting to reduce the time between when your server goes down and when Mongoose emits <code>'disconnected'</code>. We recommend you do <strong>not</strong> set this setting below 1000, too many heartbeats can lead to performance degradation.</li> </ul> <h2 id="serverselectiontimeoutms">serverSelectionTimeoutMS</h2> <p>The <code>serverSelectionTimeoutMS</code> option is extremely important: it controls how long the MongoDB Node.js driver will attempt to retry any operation before erroring out. This includes initial connection, like <code>await mongoose.connect()</code>, as well as any operations that make requests to MongoDB, like <code>save()</code> or <code>find()</code>.</p> <p>By default, <code>serverSelectionTimeoutMS</code> is 30000 (30 seconds). This means that, for example, if you call <code>mongoose.connect()</code> when your standalone MongoDB server is down, your <code>mongoose.connect()</code> call will only throw an error after 30 seconds.</p> <pre data-language="javascript"><span class="hljs-comment">// Throws an error "getaddrinfo ENOTFOUND doesnt.exist" after 30 seconds</span>
<span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://doesnt.exist:27017/test'</span>);
</pre> <p>Similarly, if your standalone MongoDB server goes down after initial connection, any <code>find()</code> or <code>save()</code> calls will error out after 30 seconds, unless your MongoDB server is restarted.</p> <p>While 30 seconds seems like a long time, <code>serverSelectionTimeoutMS</code> means you're unlikely to see any interruptions during a <a href="https://www.mongodb.com/docs/manual/replication/#automatic-failover">replica set failover</a>. If you lose your replica set primary, the MongoDB Node driver will ensure that any operations you send during the replica set election will eventually execute, assuming that the replica set election takes less than <code>serverSelectionTimeoutMS</code>.</p> <p>To get faster feedback on failed connections, you can reduce <code>serverSelectionTimeoutMS</code> to 5000 as follows. We don't recommend reducing <code>serverSelectionTimeoutMS</code> unless you are running a standalone MongoDB server rather than a replica set, or unless you are using a serverless runtime like <a href="lambda.html">AWS Lambda</a>.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(uri, {
  <span class="hljs-attr">serverSelectionTimeoutMS</span>: <span class="hljs-number">5000</span>
});
</pre> <p>There is no way to tune <code>serverSelectionTimeoutMS</code> independently for <code>mongoose.connect()</code> vs for queries. If you want to reduce <code>serverSelectionTimeoutMS</code> for queries and other operations, but still retry <code>mongoose.connect()</code> for longer, you are responsible for retrying the <code>connect()</code> calls yourself using a <code>for</code> loop or <a href="https://github.com/Automattic/mongoose/issues/12967#issuecomment-1411227968">a tool like p-retry</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> serverSelectionTimeoutMS = <span class="hljs-number">5000</span>;

<span class="hljs-comment">// Prints "Failed 0", "Failed 1", "Failed 2" and then throws an</span>
<span class="hljs-comment">// error. Exits after approximately 15 seconds.</span>
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://doesnt.exist:27017/test'</span>, {
      serverSelectionTimeoutMS
    });
    <span class="hljs-keyword">break</span>;
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Failed'</span>, i);
    <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">2</span>) {
      <span class="hljs-keyword">throw</span> err;
    }
  }
}
</pre> <h2 id="callback">Callback</h2> <p>The <code>connect()</code> function also accepts a callback parameter and returns a <a href="promises.html">promise</a>.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(uri, options, <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) {
  <span class="hljs-comment">// Check error in initial connection. There is no 2nd param to the callback.</span>
});

<span class="hljs-comment">// Or using promises</span>
mongoose.<span class="hljs-title function_">connect</span>(uri, options).<span class="hljs-title function_">then</span>(
  <span class="hljs-function">() =&gt;</span> { <span class="hljs-comment">/** ready to use. The `mongoose.connect()` promise resolves to mongoose instance. */</span> },
  <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> { <span class="hljs-comment">/** handle initial connection error */</span> }
);
</pre> <h2 id="connection-string-options">Connection String Options</h2> <p>You can also specify driver options in your connection string as <a href="https://en.wikipedia.org/wiki/Query_string">parameters in the query string</a> portion of the URI. This only applies to options passed to the MongoDB driver. You <strong>can't</strong> set Mongoose-specific options like <code>bufferCommands</code> in the query string.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/test?socketTimeoutMS=1000&amp;bufferCommands=false&amp;authSource=otherdb'</span>);
<span class="hljs-comment">// The above is equivalent to:</span>
mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/test'</span>, {
  <span class="hljs-attr">socketTimeoutMS</span>: <span class="hljs-number">1000</span>
  <span class="hljs-comment">// Note that mongoose will **not** pull `bufferCommands` from the query string</span>
});
</pre> <p>The disadvantage of putting options in the query string is that query string options are harder to read. The advantage is that you only need a single configuration option, the URI, rather than separate options for <code>socketTimeoutMS</code>, etc. Best practice is to put options that likely differ between development and production, like <code>replicaSet</code> or <code>ssl</code>, in the connection string, and options that should remain constant, like <code>socketTimeoutMS</code> or <code>maxPoolSize</code>, in the options object.</p> <p>The MongoDB docs have a full list of <a href="https://www.mongodb.com/docs/manual/reference/connection-string/">supported connection string options</a>. Below are some options that are often useful to set in the connection string because they are closely associated with the hostname and authentication information.</p> <ul> <li>
<code>authSource</code> - The database to use when authenticating with <code>user</code> and <code>pass</code>. In MongoDB, <a href="https://www.mongodb.com/docs/manual/tutorial/manage-users-and-roles/">users are scoped to a database</a>. If you are getting an unexpected login failure, you may need to set this option.</li> <li>
<code>family</code> - Whether to connect using IPv4 or IPv6. This option passed to <a href="https://nodejs.org/api/dns.html#dns_dns_lookup_hostname_options_callback">Node.js' <code>dns.lookup()</code></a> function. If you don't specify this option, the MongoDB driver will try IPv6 first and then IPv4 if IPv6 fails. If your <code>mongoose.connect(uri)</code> call takes a long time, try <code>mongoose.connect(uri, { family: 4 })</code>
</li> </ul> <h2 id="connection-events">Connection Events</h2> <p>Connections inherit from <a href="https://nodejs.org/api/events.html#events_class_eventemitter">Node.js' <code>EventEmitter</code> class</a>, and emit events when something happens to the connection, like losing connectivity to the MongoDB server. Below is a list of events that a connection may emit.</p> <ul> <li>
<code>connecting</code>: Emitted when Mongoose starts making its initial connection to the MongoDB server</li> <li>
<code>connected</code>: Emitted when Mongoose successfully makes its initial connection to the MongoDB server, or when Mongoose reconnects after losing connectivity. May be emitted multiple times if Mongoose loses connectivity.</li> <li>
<code>open</code>: Emitted after <code>'connected'</code> and <code>onOpen</code> is executed on all of this connection's models.</li> <li>
<code>disconnecting</code>: Your app called <a href="api/connection.html#connection_Connection-close"><code>Connection#close()</code></a> to disconnect from MongoDB</li> <li>
<code>disconnected</code>: Emitted when Mongoose lost connection to the MongoDB server. This event may be due to your code explicitly closing the connection, the database server crashing, or network connectivity issues.</li> <li>
<code>close</code>: Emitted after <a href="api/connection.html#connection_Connection-close"><code>Connection#close()</code></a> successfully closes the connection. If you call <code>conn.close()</code>, you'll get both a 'disconnected' event and a 'close' event.</li> <li>
<code>reconnected</code>: Emitted if Mongoose lost connectivity to MongoDB and successfully reconnected. Mongoose attempts to <a href="https://thecodebarbarian.com/managing-connections-with-the-mongodb-node-driver.html">automatically reconnect</a> when it loses connection to the database.</li> <li>
<code>error</code>: Emitted if an error occurs on a connection, like a <code>parseError</code> due to malformed data or a payload larger than <a href="https://www.mongodb.com/docs/manual/reference/limits/#BSON-Document-Size">16MB</a>.</li> <li>
<code>fullsetup</code>: Emitted when you're connecting to a replica set and Mongoose has successfully connected to the primary and at least one secondary.</li> <li>
<code>all</code>: Emitted when you're connecting to a replica set and Mongoose has successfully connected to all servers specified in your connection string.</li> </ul> <p>When you're connecting to a single MongoDB server (a "standalone"), Mongoose will emit 'disconnected' if it gets disconnected from the standalone server, and 'connected' if it successfully connects to the standalone. In a replica set, Mongoose will emit 'disconnected' if it loses connectivity to the replica set primary, and 'connected' if it manages to reconnect to the replica set primary.</p> <h2 id="keepAlive">A note about keepAlive</h2> <p>Before Mongoose 5.2.0, you needed to enable the <code>keepAlive</code> option to initiate <a href="https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html">TCP keepalive</a> to prevent <code>"connection closed"</code> errors errors. However, <code>keepAlive</code> has been <code>true</code> by default since Mongoose 5.2.0, and the <code>keepAlive</code> is deprecated as of Mongoose 7.2.0. Please remove <code>keepAlive</code> and <code>keepAliveInitialDelay</code> options from your Mongoose connections.</p> <h2 id="replicaset_connections">Replica Set Connections</h2> <p>To connect to a replica set you pass a comma delimited list of hosts to connect to rather than a single host.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span> [, options]);
</pre> <p>For example:</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://user:pw@host1.com:27017,host2.com:27017,host3.com:27017/testdb'</span>);
</pre> <p>To connect to a single node replica set, specify the <code>replicaSet</code> option.</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://host1:port1/?replicaSet=rsName'</span>);
</pre> <h2 id="server-selection">Server Selection</h2> <p>The underlying MongoDB driver uses a process known as <a href="https://github.com/mongodb/specifications/blob/master/source/server-selection/server-selection.rst">server selection</a> to connect to MongoDB and send operations to MongoDB. If the MongoDB driver can't find a server to send an operation to after <code>serverSelectionTimeoutMS</code>, you'll get the below error:</p> <pre data-language="javascript">MongoTimeoutError: Server selection timed out after 30000 ms
</pre> <p>You can configure the timeout using the <code>serverSelectionTimeoutMS</code> option to <code>mongoose.connect()</code>:</p> <pre data-language="javascript">mongoose.<span class="hljs-title function_">connect</span>(uri, {
  <span class="hljs-attr">serverSelectionTimeoutMS</span>: <span class="hljs-number">5000</span> <span class="hljs-comment">// Timeout after 5s instead of 30s</span>
});
</pre> <p>A <code>MongoTimeoutError</code> has a <code>reason</code> property that explains why server selection timed out. For example, if you're connecting to a standalone server with an incorrect password, <code>reason</code> will contain an "Authentication failed" error.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-keyword">const</span> uri = <span class="hljs-string">'mongodb+srv://username:badpw@cluster0-OMITTED.mongodb.net/'</span> +
  <span class="hljs-string">'test?retryWrites=true&amp;w=majority'</span>;
<span class="hljs-comment">// Prints "MongoServerError: bad auth Authentication failed."</span>
mongoose.<span class="hljs-title function_">connect</span>(uri, {
  <span class="hljs-attr">serverSelectionTimeoutMS</span>: <span class="hljs-number">5000</span>
}).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">reason</span>));
</pre> <h2 id="replicaset-hostnames">Replica Set Host Names</h2> <p>MongoDB replica sets rely on being able to reliably figure out the domain name for each member.<br>On Linux and OSX, the MongoDB server uses the output of the <a href="https://linux.die.net/man/1/hostname"><code>hostname</code> command</a> to figure out the domain name to report to the replica set. This can cause confusing errors if you're connecting to a remote MongoDB replica set running on a machine that reports its <code>hostname</code> as <code>localhost</code>:</p> <pre data-language="javascript">// Can get this error even if your connection string doesn't include
// `localhost` if `rs.conf()` reports that one replica set member has
// `localhost` as its host name.
MongooseServerSelectionError: connect ECONNREFUSED localhost:27017
</pre> <p>If you're experiencing a similar error, connect to the replica set using the <code>mongo</code> shell and run the <a href="https://www.mongodb.com/docs/manual/reference/method/rs.conf/"><code>rs.conf()</code></a> command to check the host names of each replica set member. Follow <a href="https://www.mongodb.com/docs/manual/tutorial/change-hostnames-in-a-replica-set/#change-hostnames-while-maintaining-replica-set-availability">this page's instructions to change a replica set member's host name</a>.</p> <p>You can also check the <code>reason.servers</code> property of <code>MongooseServerSelectionError</code> to see what the MongoDB Node driver thinks the state of your replica set is. The <code>reason.servers</code> property contains a <a href="https://masteringjs.io/tutorials/fundamentals/map">map</a> of server descriptions.</p> <pre data-language="javascript"><span class="hljs-keyword">if</span> (err.<span class="hljs-property">name</span> === <span class="hljs-string">'MongooseServerSelectionError'</span>) {
  <span class="hljs-comment">// Contains a Map describing the state of your replica set. For example:</span>
  <span class="hljs-comment">// Map(1) {</span>
  <span class="hljs-comment">//   'localhost:27017' =&gt; ServerDescription {</span>
  <span class="hljs-comment">//     address: 'localhost:27017',</span>
  <span class="hljs-comment">//     type: 'Unknown',</span>
  <span class="hljs-comment">//     ...</span>
  <span class="hljs-comment">//   }</span>
  <span class="hljs-comment">// }</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err.<span class="hljs-property">reason</span>.<span class="hljs-property">servers</span>);
}
</pre> <h2 id="mongos_connections">Multi-mongos support</h2> <p>You can also connect to multiple <a href="https://www.mongodb.com/docs/manual/reference/program/mongos/">mongos</a> instances for high availability in a sharded cluster. You do <a href="http://mongodb.github.io/node-mongodb-native/3.0/tutorials/connect/#connect-to-sharded-cluster">not need to pass any special options to connect to multiple mongos</a> in mongoose 5.x.</p> <pre data-language="javascript"><span class="hljs-comment">// Connect to 2 mongos servers</span>
mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://mongosA:27501,mongosB:27501'</span>, cb);
</pre> <h2 id="multiple_connections">Multiple connections</h2> <p>So far we've seen how to connect to MongoDB using Mongoose's default connection. Mongoose creates a <em>default connection</em> when you call <code>mongoose.connect()</code>. You can access the default connection using <code>mongoose.connection</code>.</p> <p>You may need multiple connections to MongoDB for several reasons. One reason is if you have multiple databases or multiple MongoDB clusters. Another reason is to work around <a href="https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs">slow trains</a>. The <code>mongoose.createConnection()</code> function takes the same arguments as <code>mongoose.connect()</code> and returns a new connection.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> conn = mongoose.<span class="hljs-title function_">createConnection</span>(<span class="hljs-string">'mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]'</span>, options);
</pre> <p>This <a href="api/connection.html#connection_Connection">connection</a> object is then used to create and retrieve <a href="api/model.html#model_Model">models</a>. Models are <strong>always</strong> scoped to a single connection.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">UserModel</span> = conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, userSchema);
</pre> <p>If you use multiple connections, you should make sure you export schemas, <strong>not</strong> models. Exporting a model from a file is called the <em>export model pattern</em>. The export model pattern is limited because you can only use one connection.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">email</span>: <span class="hljs-title class_">String</span> });

<span class="hljs-comment">// The alternative to the export model pattern is the export schema pattern.</span>
<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = userSchema;

<span class="hljs-comment">// Because if you export a model as shown below, the model will be scoped</span>
<span class="hljs-comment">// to Mongoose's default connection.</span>
<span class="hljs-comment">// module.exports = mongoose.model('User', userSchema);</span>
</pre> <p>If you use the export schema pattern, you still need to create models somewhere. There are two common patterns. First is to export a connection and register the models on the connection in the file:</p> <pre data-language="javascript"><span class="hljs-comment">// connections/fast.js</span>
<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-keyword">const</span> conn = mongoose.<span class="hljs-title function_">createConnection</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGODB_URI</span>);
conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">'../schemas/user'</span>));

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = conn;

<span class="hljs-comment">// connections/slow.js</span>
<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-keyword">const</span> conn = mongoose.<span class="hljs-title function_">createConnection</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGODB_URI</span>);
conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">'../schemas/user'</span>));
conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'PageView'</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">'../schemas/pageView'</span>));

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = conn;
</pre> <p>Another alternative is to register connections with a dependency injector or another <a href="https://thecodebarbarian.com/using-ramda-as-a-dependency-injector">inversion of control (IOC) pattern</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">connectionFactory</span>() {
  <span class="hljs-keyword">const</span> conn = mongoose.<span class="hljs-title function_">createConnection</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">MONGODB_URI</span>);

  conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">'../schemas/user'</span>));
  conn.<span class="hljs-title function_">model</span>(<span class="hljs-string">'PageView'</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">'../schemas/pageView'</span>));

  <span class="hljs-keyword">return</span> conn;
};
</pre> <h2 id="connection_pools">Connection Pools</h2> <p>Each <code>connection</code>, whether created with <code>mongoose.connect</code> or <code>mongoose.createConnection</code> are all backed by an internal configurable connection pool defaulting to a maximum size of 100. Adjust the pool size using your connection options:</p> <pre data-language="javascript"><span class="hljs-comment">// With object options</span>
mongoose.<span class="hljs-title function_">createConnection</span>(uri, { <span class="hljs-attr">maxPoolSize</span>: <span class="hljs-number">10</span> });

<span class="hljs-comment">// With connection string options</span>
<span class="hljs-keyword">const</span> uri = <span class="hljs-string">'mongodb://127.0.0.1:27017/test?maxPoolSize=10'</span>;
mongoose.<span class="hljs-title function_">createConnection</span>(uri);
</pre> <p>The connection pool size is important because <a href="https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs">MongoDB currently can only process one operation per socket</a>. So <code>maxPoolSize</code> functions as a cap on the number of concurrent operations.</p> <h2 id="multi-tenant-connections">Multi Tenant Connections</h2> <p>In the context of Mongoose, a multi-tenant architecture typically means a case where multiple different clients talk to MongoDB through a single Mongoose application. This typically means each client makes queries and executes updates through a single Mongoose application, but has a distinct MongoDB database within the same MongoDB cluster.</p> <p>We recommend reading <a href="https://medium.com/brightlab-techblog/multitenant-node-js-application-with-mongoose-mongodb-f8841a285b4f">this article about multi-tenancy with Mongoose</a>; it has a good description of how we define multi-tenancy and a more detailed overview of our recommended patterns.</p> <p>There are two patterns we recommend for multi-tenancy in Mongoose:</p> <ol> <li>Maintain one connection pool, switch between tenants using the <a href="api/connection.html#Connection.prototype.useDb()"><code>Connection.prototype.useDb()</code> method</a>.</li> <li>Maintain a separate connection pool per tenant, store connections in a map or <a href="https://masteringjs.io/tutorials/fundamentals/pojo">POJO</a>.</li> </ol> <p>The following is an example of pattern (1). We recommend pattern (1) for cases where you have a small number of tenants, or if each individual tenant's workload is light (approximately &lt; 1 request per second, all requests take &lt; 10ms of database processing time). Pattern (1) is simpler to implement and simpler to manage in production, because there is only 1 connection pool. But, under high load, you will likely run into issues where some tenants' operations slow down other tenants' operations due to <a href="https://thecodebarbarian.com/slow-trains-in-mongodb-and-nodejs">slow trains</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

mongoose.<span class="hljs-title function_">connect</span>(<span class="hljs-string">'mongodb://127.0.0.1:27017/main'</span>);
mongoose.<span class="hljs-title function_">set</span>(<span class="hljs-string">'debug'</span>, <span class="hljs-literal">true</span>);

mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, mongoose.<span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/users/:tenantId'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">const</span> db = mongoose.<span class="hljs-property">connection</span>.<span class="hljs-title function_">useDb</span>(<span class="hljs-string">`tenant_<span class="hljs-subst">${req.params.tenantId}</span>`</span>, {
    <span class="hljs-comment">// `useCache` tells Mongoose to cache connections by database name, so</span>
    <span class="hljs-comment">// `mongoose.connection.useDb('foo', { useCache: true })` returns the</span>
    <span class="hljs-comment">// same reference each time.</span>
    <span class="hljs-attr">useCache</span>: <span class="hljs-literal">true</span>
  });
  <span class="hljs-comment">// Need to register models every time a new connection is created</span>
  <span class="hljs-keyword">if</span> (!db.<span class="hljs-property">models</span>[<span class="hljs-string">'User'</span>]) {
    db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, mongoose.<span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));
  }
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'Find users from'</span>, db.<span class="hljs-property">name</span>);
  db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>).<span class="hljs-title function_">find</span>().
    <span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> res.<span class="hljs-title function_">json</span>({ users })).
    <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">message</span>: err.<span class="hljs-property">message</span> }));
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</pre> <p>The following is an example of pattern (2). Pattern (2) is more flexible and better for use cases with &gt; 10k tenants and &gt; 1 requests/second. Because each tenant has a separate connection pool, one tenants' slow operations will have minimal impact on other tenants. However, this pattern is harder to implement and manage in production. In particular, <a href="https://www.mongodb.com/blog/post/tuning-mongodb--linux-to-allow-for-tens-of-thousands-connections">MongoDB does have a limit on the number of open connections</a>, and <a href="https://www.mongodb.com/docs/atlas/reference/atlas-limits">MongoDB Atlas has separate limits on the number of open connections</a>, so you need to make sure the total number of sockets in your connection pools doesn't go over MongoDB's limits.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">'express'</span>);
<span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);

<span class="hljs-keyword">const</span> tenantIdToConnection = {};

<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">get</span>(<span class="hljs-string">'/users/:tenantId'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) {
  <span class="hljs-keyword">let</span> initialConnection = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();
  <span class="hljs-keyword">const</span> { tenantId } = req.<span class="hljs-property">params</span>;
  <span class="hljs-keyword">if</span> (!tenantIdToConnection[tenantId]) {
    tenantIdToConnection[tenantId] = mongoose.<span class="hljs-title function_">createConnection</span>(<span class="hljs-string">`mongodb://127.0.0.1:27017/tenant_<span class="hljs-subst">${tenantId}</span>`</span>);
    tenantIdToConnection[tenantId].<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, mongoose.<span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));
    initialConnection = tenantIdToConnection[tenantId].<span class="hljs-title function_">asPromise</span>();
  }
  <span class="hljs-keyword">const</span> db = tenantIdToConnection[tenantId];
  initialConnection.
    <span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>).<span class="hljs-title function_">find</span>()).
    <span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">users</span> =&gt;</span> res.<span class="hljs-title function_">json</span>({ users })).
    <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> res.<span class="hljs-title function_">status</span>(<span class="hljs-number">500</span>).<span class="hljs-title function_">json</span>({ <span class="hljs-attr">message</span>: err.<span class="hljs-property">message</span> }));
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
</pre> <h2 id="next">Next Up</h2> <p>Now that we've covered connections, let's take a look at <a href="models.html">models</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 LearnBoost<br>Licensed under the MIT License.<br>
    <a href="https://mongoosejs.com/docs/connections.html" class="_attribution-link">https://mongoosejs.com/docs/connections.html</a>
  </p>
</div>
