<h1 id="validation">  Validation  </h1>   <p>Before we get into the specifics of validation syntax, please keep the following rules in mind:</p> <ul> <li>Validation is defined in the <a href="schematypes.html">SchemaType</a>
</li> <li>Validation is <a href="middleware.html">middleware</a>. Mongoose registers validation as a <code>pre('save')</code> hook on every schema by default.</li> <li>Validation always runs as the <strong>first</strong> <code>pre('save')</code> hook. This means that validation doesn't run on any changes you make in <code>pre('save')</code> hooks.</li> <li>You can disable automatic validation before save by setting the <a href="guide.html#validateBeforeSave">validateBeforeSave</a> option</li> <li>You can manually run validation using <code>doc.validate()</code> or <code>doc.validateSync()</code>
</li> <li>You can manually mark a field as invalid (causing validation to fail) by using <a href="api/document.html#document_Document-invalidate"><code>doc.invalidate(...)</code></a>
</li> <li>Validators are not run on undefined values. The only exception is the <a href="api/schematype.html#schematype_SchemaType-required"><code>required</code> validator</a>.</li> <li>When you call <a href="api/model.html#model_Model-save">Model#save</a>, Mongoose also runs subdocument validation. If an error occurs, your <a href="api/model.html#model_Model-save">Model#save</a> promise rejects</li> <li>Validation is customizable</li> </ul> <pre data-language="javascript"><span class="hljs-keyword">const</span> schema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Cat</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Cat'</span>, schema);

<span class="hljs-comment">// This cat has no name :(</span>
<span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>();

<span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> cat.<span class="hljs-title function_">save</span>();
} <span class="hljs-keyword">catch</span> (err) {
  error = err;
}

assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'Path `name` is required.'</span>);

error = cat.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'Path `name` is required.'</span>);
</pre> <ul> <li><a href="#built-in-validators">Built-in Validators</a></li> <li><a href="#custom-error-messages">Custom Error Messages</a></li> <li><a href="#the-unique-option-is-not-a-validator">The <code>unique</code> Option is Not a Validator</a></li> <li><a href="#custom-validators">Custom Validators</a></li> <li><a href="#async-custom-validators">Async Custom Validators</a></li> <li><a href="#validation-errors">Validation Errors</a></li> <li><a href="#cast-errors">Cast Errors</a></li> <li><a href="#global-schematype-validation">Global SchemaType Validation</a></li> <li><a href="#required-validators-on-nested-objects">Required Validators On Nested Objects</a></li> <li><a href="#update-validators">Update Validators</a></li> <li><a href="#update-validators-and-this">Update Validators and <code>this</code></a></li> <li><a href="#update-validators-only-run-on-updated-paths">Update Validators Only Run On Updated Paths</a></li> <li><a href="#update-validators-only-run-for-some-operations">Update Validators Only Run For Some Operations</a></li> </ul> <h2 id="built-in-validators">  Built-in Validators  </h2> <p>Mongoose has several built-in validators.</p> <ul> <li>All <a href="schematypes.html">SchemaTypes</a> have the built-in <a href="api/schematype.html#schematype_SchemaType-required">required</a> validator. The required validator uses the <a href="api/schematype.html#schematype_SchemaType-checkRequired">SchemaType's <code>checkRequired()</code> function</a> to determine if the value satisfies the required validator.</li> <li>
<a href="schematypes.html#numbers">Numbers</a> have <a href="schematypes.html#number-validators"><code>min</code> and <code>max</code></a> validators.</li> <li>
<a href="schematypes.html#strings">Strings</a> have <a href="schematypes.html#string-validators"><code>enum</code>, <code>match</code>, <code>minLength</code>, and <code>maxLength</code></a> validators.</li> </ul> <p>Each of the validator links above provide more information about how to enable them and customize their error messages.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> breakfastSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">eggs</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">min</span>: [<span class="hljs-number">6</span>, <span class="hljs-string">'Too few eggs'</span>],
    <span class="hljs-attr">max</span>: <span class="hljs-number">12</span>
  },
  <span class="hljs-attr">bacon</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">required</span>: [<span class="hljs-literal">true</span>, <span class="hljs-string">'Why no bacon?'</span>]
  },
  <span class="hljs-attr">drink</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">enum</span>: [<span class="hljs-string">'Coffee'</span>, <span class="hljs-string">'Tea'</span>],
    <span class="hljs-attr">required</span>: <span class="hljs-keyword">function</span>() {
      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">bacon</span> &gt; <span class="hljs-number">3</span>;
    }
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Breakfast</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Breakfast'</span>, breakfastSchema);

<span class="hljs-keyword">const</span> badBreakfast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Breakfast</span>({
  <span class="hljs-attr">eggs</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">bacon</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">drink</span>: <span class="hljs-string">'Milk'</span>
});
<span class="hljs-keyword">let</span> error = badBreakfast.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'eggs'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'Too few eggs'</span>);
assert.<span class="hljs-title function_">ok</span>(!error.<span class="hljs-property">errors</span>[<span class="hljs-string">'bacon'</span>]);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'drink'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'`Milk` is not a valid enum value for path `drink`.'</span>);

badBreakfast.<span class="hljs-property">bacon</span> = <span class="hljs-number">5</span>;
badBreakfast.<span class="hljs-property">drink</span> = <span class="hljs-literal">null</span>;

error = badBreakfast.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'drink'</span>].<span class="hljs-property">message</span>, <span class="hljs-string">'Path `drink` is required.'</span>);

badBreakfast.<span class="hljs-property">bacon</span> = <span class="hljs-literal">null</span>;
error = badBreakfast.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'bacon'</span>].<span class="hljs-property">message</span>, <span class="hljs-string">'Why no bacon?'</span>);
</pre> <h2 id="custom-error-messages">  Custom Error Messages  </h2> <p>You can configure the error message for individual validators in your schema. There are two equivalent ways to set the validator error message:</p> <ul> <li>Array syntax: <code>min: [6, 'Must be at least 6, got {VALUE}']</code>
</li> <li>Object syntax: <code>enum: { values: ['Coffee', 'Tea'], message: '{VALUE} is not supported' }</code>
</li> </ul> <p>Mongoose also supports rudimentary templating for error messages. Mongoose replaces <code>{VALUE}</code> with the value being validated.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> breakfastSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">eggs</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">min</span>: [<span class="hljs-number">6</span>, <span class="hljs-string">'Must be at least 6, got {VALUE}'</span>],
    <span class="hljs-attr">max</span>: <span class="hljs-number">12</span>
  },
  <span class="hljs-attr">drink</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">enum</span>: {
      <span class="hljs-attr">values</span>: [<span class="hljs-string">'Coffee'</span>, <span class="hljs-string">'Tea'</span>],
      <span class="hljs-attr">message</span>: <span class="hljs-string">'{VALUE} is not supported'</span>
    }
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Breakfast</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Breakfast'</span>, breakfastSchema);

<span class="hljs-keyword">const</span> badBreakfast = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Breakfast</span>({
  <span class="hljs-attr">eggs</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">drink</span>: <span class="hljs-string">'Milk'</span>
});
<span class="hljs-keyword">const</span> error = badBreakfast.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'eggs'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'Must be at least 6, got 2'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'drink'</span>].<span class="hljs-property">message</span>, <span class="hljs-string">'Milk is not supported'</span>);
</pre> <h2 id="the-unique-option-is-not-a-validator">  The <code>unique</code> Option is Not a Validator  </h2> <p>A common gotcha for beginners is that the <code>unique</code> option for schemas is <em>not</em> a validator. It's a convenient helper for building <a href="https://www.mongodb.com/docs/manual/core/index-unique/">MongoDB unique indexes</a>. See the <a href="https://mongoosejs.com/docs/faq.html">FAQ</a> for more information.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> uniqueUsernameSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">username</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">unique</span>: <span class="hljs-literal">true</span>
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">U1</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'U1'</span>, uniqueUsernameSchema);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">U2</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'U2'</span>, uniqueUsernameSchema);

<span class="hljs-keyword">const</span> dup = [{ <span class="hljs-attr">username</span>: <span class="hljs-string">'Val'</span> }, { <span class="hljs-attr">username</span>: <span class="hljs-string">'Val'</span> }];
<span class="hljs-comment">// Race condition! This may save successfully, depending on whether</span>
<span class="hljs-comment">// MongoDB built the index before writing the 2 docs.</span>
<span class="hljs-variable constant_">U1</span>.<span class="hljs-title function_">create</span>(dup).
  <span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> {
  }).
  <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
  });

<span class="hljs-comment">// You need to wait for Mongoose to finish building the `unique`</span>
<span class="hljs-comment">// index before writing. You only need to build indexes once for</span>
<span class="hljs-comment">// a given collection, so you normally don't need to do this</span>
<span class="hljs-comment">// in production. But, if you drop the database between tests,</span>
<span class="hljs-comment">// you will need to use `init()` to wait for the index build to finish.</span>
<span class="hljs-variable constant_">U2</span>.<span class="hljs-title function_">init</span>().
  <span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable constant_">U2</span>.<span class="hljs-title function_">create</span>(dup)).
  <span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> {
    <span class="hljs-comment">// `U2.create()` will error, but will *not* be a mongoose validation error, it will be</span>
    <span class="hljs-comment">// a duplicate key error.</span>
    <span class="hljs-comment">// See: https://masteringjs.io/tutorials/mongoose/e11000-duplicate-key</span>
    assert.<span class="hljs-title function_">ok</span>(error);
    assert.<span class="hljs-title function_">ok</span>(!error.<span class="hljs-property">errors</span>);
    assert.<span class="hljs-title function_">ok</span>(error.<span class="hljs-property">message</span>.<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'duplicate key error'</span>) !== -<span class="hljs-number">1</span>);
  });
</pre> <h2 id="custom-validators">  Custom Validators  </h2> <p>If the built-in validators aren't enough, you can define custom validators to suit your needs.</p> <p>Custom validation is declared by passing a validation function. You can find detailed instructions on how to do this in the <a href="api/schematype.html#schematype_SchemaType-validate"><code>SchemaType#validate()</code> API docs</a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">phone</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">validate</span>: {
      <span class="hljs-attr">validator</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-regexp">/\d{3}-\d{3}-\d{4}/</span>.<span class="hljs-title function_">test</span>(v);
      },
      <span class="hljs-attr">message</span>: <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">${props.value}</span> is not a valid phone number!`</span>
    },
    <span class="hljs-attr">required</span>: [<span class="hljs-literal">true</span>, <span class="hljs-string">'User phone number required'</span>]
  }
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'user'</span>, userSchema);
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();
<span class="hljs-keyword">let</span> error;

user.<span class="hljs-property">phone</span> = <span class="hljs-string">'555.0123'</span>;
error = user.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'phone'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'555.0123 is not a valid phone number!'</span>);

user.<span class="hljs-property">phone</span> = <span class="hljs-string">''</span>;
error = user.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'phone'</span>].<span class="hljs-property">message</span>,
  <span class="hljs-string">'User phone number required'</span>);

user.<span class="hljs-property">phone</span> = <span class="hljs-string">'201-555-0123'</span>;
<span class="hljs-comment">// Validation succeeds! Phone number is defined</span>
<span class="hljs-comment">// and fits `DDD-DDD-DDDD`</span>
error = user.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">equal</span>(error, <span class="hljs-literal">null</span>);
</pre> <h2 id="async-custom-validators">  Async Custom Validators  </h2> <p>Custom validators can also be asynchronous. If your validator function returns a promise (like an <code>async</code> function), mongoose will wait for that promise to settle. If the returned promise rejects, or fulfills with the value <code>false</code>, Mongoose will consider that a validation error.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-comment">// You can also make a validator async by returning a promise.</span>
    <span class="hljs-attr">validate</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Oops!'</span>))
  },
  <span class="hljs-attr">email</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-comment">// There are two ways for an promise-based async validator to fail:</span>
    <span class="hljs-comment">// 1) If the promise rejects, Mongoose assumes the validator failed with the given error.</span>
    <span class="hljs-comment">// 2) If the promise resolves to `false`, Mongoose assumes the validator failed and creates an error with the given `message`.</span>
    <span class="hljs-attr">validate</span>: {
      <span class="hljs-attr">validator</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-attr">message</span>: <span class="hljs-string">'Email validation failed'</span>
    }
  }
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, userSchema);
<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();

user.<span class="hljs-property">email</span> = <span class="hljs-string">'test@test.co'</span>;
user.<span class="hljs-property">name</span> = <span class="hljs-string">'test'</span>;

<span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> user.<span class="hljs-title function_">validate</span>();
} <span class="hljs-keyword">catch</span> (err) {
  error = err;
}
assert.<span class="hljs-title function_">ok</span>(error);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>].<span class="hljs-property">message</span>, <span class="hljs-string">'Oops!'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'email'</span>].<span class="hljs-property">message</span>, <span class="hljs-string">'Email validation failed'</span>);
</pre> <h2 id="validation-errors">  Validation Errors  </h2> <p>Errors returned after failed validation contain an <code>errors</code> object whose values are <code>ValidatorError</code> objects. Each <a href="api/error.html#error_Error-ValidatorError">ValidatorError</a> has <code>kind</code>, <code>path</code>, <code>value</code>, and <code>message</code> properties. A ValidatorError also may have a <code>reason</code> property. If an error was thrown in the validator, this property will contain the error that was thrown.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> toySchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">color</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-keyword">const</span> validator = <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/red|white|gold/i</span>.<span class="hljs-title function_">test</span>(value);
};
toySchema.<span class="hljs-title function_">path</span>(<span class="hljs-string">'color'</span>).<span class="hljs-title function_">validate</span>(validator,
  <span class="hljs-string">'Color `{VALUE}` not valid'</span>, <span class="hljs-string">'Invalid color'</span>);
toySchema.<span class="hljs-title function_">path</span>(<span class="hljs-string">'name'</span>).<span class="hljs-title function_">validate</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) {
  <span class="hljs-keyword">if</span> (v !== <span class="hljs-string">'Turbo Man'</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">'Need to get a Turbo Man for Christmas'</span>);
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
}, <span class="hljs-string">'Name `{VALUE}` is not valid'</span>);

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Toy</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Toy'</span>, toySchema);

<span class="hljs-keyword">const</span> toy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Toy</span>({ <span class="hljs-attr">color</span>: <span class="hljs-string">'Green'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Power Ranger'</span> });

<span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> toy.<span class="hljs-title function_">save</span>();
} <span class="hljs-keyword">catch</span> (err) {
  error = err;
}

<span class="hljs-comment">// `error` is a ValidationError object</span>
<span class="hljs-comment">// `error.errors.color` is a ValidatorError object</span>
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">color</span>.<span class="hljs-property">message</span>, <span class="hljs-string">'Color `Green` not valid'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">color</span>.<span class="hljs-property">kind</span>, <span class="hljs-string">'Invalid color'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">color</span>.<span class="hljs-property">path</span>, <span class="hljs-string">'color'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">color</span>.<span class="hljs-property">value</span>, <span class="hljs-string">'Green'</span>);

<span class="hljs-comment">// If your validator throws an exception, mongoose will use the error</span>
<span class="hljs-comment">// message. If your validator returns `false`,</span>
<span class="hljs-comment">// mongoose will use the 'Name `Power Ranger` is not valid' message.</span>
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">name</span>.<span class="hljs-property">message</span>,
  <span class="hljs-string">'Need to get a Turbo Man for Christmas'</span>);
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">name</span>.<span class="hljs-property">value</span>, <span class="hljs-string">'Power Ranger'</span>);
<span class="hljs-comment">// If your validator threw an error, the `reason` property will contain</span>
<span class="hljs-comment">// the original error thrown, including the original stack trace.</span>
assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">name</span>.<span class="hljs-property">reason</span>.<span class="hljs-property">message</span>,
  <span class="hljs-string">'Need to get a Turbo Man for Christmas'</span>);

assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">name</span>, <span class="hljs-string">'ValidationError'</span>);
</pre> <h2 id="cast-errors">  Cast Errors  </h2> <p>Before running validators, Mongoose attempts to coerce values to the correct type. This process is called <em>casting</em> the document. If casting fails for a given path, the <code>error.errors</code> object will contain a <code>CastError</code> object.</p> <p>Casting runs before validation, and validation does not run if casting fails. That means your custom validators may assume <code>v</code> is <code>null</code>, <code>undefined</code>, or an instance of the type specified in your schema.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> vehicleSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">numWheels</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">18</span> }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vehicle</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Vehicle'</span>, vehicleSchema);

<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>({ <span class="hljs-attr">numWheels</span>: <span class="hljs-string">'not a number'</span> });
<span class="hljs-keyword">const</span> err = doc.<span class="hljs-title function_">validateSync</span>();

err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'CastError'</span>
<span class="hljs-comment">// 'Cast to Number failed for value "not a number" at path "numWheels"'</span>
err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">message</span>;
</pre> <p>By default, Mongoose cast error messages look like <code>Cast to Number failed for value "pie" at path "numWheels"</code>. You can overwrite Mongoose's default cast error message by the <code>cast</code> option on your SchemaType to a string as follows.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> vehicleSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">numWheels</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">cast</span>: <span class="hljs-string">'{VALUE} is not a number'</span>
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vehicle</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Vehicle'</span>, vehicleSchema);

<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>({ <span class="hljs-attr">numWheels</span>: <span class="hljs-string">'pie'</span> });
<span class="hljs-keyword">const</span> err = doc.<span class="hljs-title function_">validateSync</span>();

err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'CastError'</span>
<span class="hljs-comment">// "pie" is not a number</span>
err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">message</span>;
</pre> <p>Mongoose's cast error message templating supports the following parameters:</p> <ul> <li>
<code>{PATH}</code>: the path that failed to cast</li> <li>
<code>{VALUE}</code>: a string representation of the value that failed to cast</li> <li>
<code>{KIND}</code>: the type that Mongoose attempted to cast to, like <code>'String'</code> or <code>'Number'</code>
</li> </ul> <p>You can also define a function that Mongoose will call to get the cast error message as follows.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> vehicleSchema = <span class="hljs-keyword">new</span> mongoose.<span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">numWheels</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,
    <span class="hljs-attr">cast</span>: [<span class="hljs-literal">null</span>, <span class="hljs-function">(<span class="hljs-params">value, path, model, kind</span>) =&gt;</span> <span class="hljs-string">`"<span class="hljs-subst">${value}</span>" is not a number`</span>]
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Vehicle</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Vehicle'</span>, vehicleSchema);

<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vehicle</span>({ <span class="hljs-attr">numWheels</span>: <span class="hljs-string">'pie'</span> });
<span class="hljs-keyword">const</span> err = doc.<span class="hljs-title function_">validateSync</span>();

err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'CastError'</span>
<span class="hljs-comment">// "pie" is not a number</span>
err.<span class="hljs-property">errors</span>[<span class="hljs-string">'numWheels'</span>].<span class="hljs-property">message</span>;
</pre> <h2 id="global-schematype-validation">  Global SchemaType Validation  </h2> <p>In addition to defining custom validators on individual schema paths, you can also configure a custom validator to run on every instance of a given <code>SchemaType</code>. For example, the following code demonstrates how to make empty string <code>''</code> an invalid value for <em>all</em> string paths.</p> <pre data-language="javascript"><span class="hljs-comment">// Add a custom validator to all strings</span>
mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">String</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">'validate'</span>, <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v == <span class="hljs-literal">null</span> || v &gt; <span class="hljs-number">0</span>);

<span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">email</span>: <span class="hljs-title class_">String</span>
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, userSchema);

<span class="hljs-keyword">const</span> user = <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">''</span>, <span class="hljs-attr">email</span>: <span class="hljs-string">''</span> });

<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">await</span> user.<span class="hljs-title function_">validate</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err);
err.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>]; <span class="hljs-comment">// ValidatorError</span>
err.<span class="hljs-property">errors</span>[<span class="hljs-string">'email'</span>]; <span class="hljs-comment">// ValidatorError</span>
</pre> <h2 id="required-validators-on-nested-objects">  Required Validators On Nested Objects  </h2> <p>Defining validators on nested objects in mongoose is tricky, because nested objects are not fully fledged paths.</p> <pre data-language="javascript"><span class="hljs-keyword">let</span> personSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">first</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">last</span>: <span class="hljs-title class_">String</span>
  }
});

assert.<span class="hljs-title function_">throws</span>(<span class="hljs-keyword">function</span>() {
  <span class="hljs-comment">// This throws an error, because 'name' isn't a full fledged path</span>
  personSchema.<span class="hljs-title function_">path</span>(<span class="hljs-string">'name'</span>).required(<span class="hljs-literal">true</span>);
}, <span class="hljs-regexp">/Cannot.*'required'/</span>);

<span class="hljs-comment">// To make a nested object required, use a single nested schema</span>
<span class="hljs-keyword">const</span> nameSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">first</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">last</span>: <span class="hljs-title class_">String</span>
});

personSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: nameSchema,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>
  }
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Person'</span>, personSchema);

<span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>();
<span class="hljs-keyword">const</span> error = person.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">ok</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>]);
</pre> <h2 id="update-validators">  Update Validators  </h2> <p>In the above examples, you learned about document validation. Mongoose also supports validation for <a href="api/query.html#query_Query-update"><code>update()</code></a>, <a href="api/query.html#query_Query-updateOne"><code>updateOne()</code></a>, <a href="api/query.html#query_Query-updateMany"><code>updateMany()</code></a>, and <a href="api/query.html#query_Query-findOneAndUpdate"><code>findOneAndUpdate()</code></a> operations. Update validators are off by default - you need to specify the <code>runValidators</code> option.</p> <p>To turn on update validators, set the <code>runValidators</code> option for <code>update()</code>, <code>updateOne()</code>, <code>updateMany()</code>, or <code>findOneAndUpdate()</code>. Be careful: update validators are off by default because they have several caveats.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> toySchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">color</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Toy</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Toys'</span>, toySchema);

<span class="hljs-title class_">Toy</span>.<span class="hljs-property">schema</span>.<span class="hljs-title function_">path</span>(<span class="hljs-string">'color'</span>).<span class="hljs-title function_">validate</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-regexp">/red|green|blue/i</span>.<span class="hljs-title function_">test</span>(value);
}, <span class="hljs-string">'Invalid color'</span>);

<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">runValidators</span>: <span class="hljs-literal">true</span> };

<span class="hljs-keyword">let</span> error;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Toy</span>.<span class="hljs-title function_">updateOne</span>({}, { <span class="hljs-attr">color</span>: <span class="hljs-string">'not a color'</span> }, opts);
} <span class="hljs-keyword">catch</span> (err) {
  error = err;
}

assert.<span class="hljs-title function_">equal</span>(error.<span class="hljs-property">errors</span>.<span class="hljs-property">color</span>.<span class="hljs-property">message</span>, <span class="hljs-string">'Invalid color'</span>);
</pre> <h2 id="update-validators-and-this">  Update Validators and <code>this</code>  </h2> <p>There are a couple of key differences between update validators and document validators. In the color validation function below, <code>this</code> refers to the document being validated when using document validation. However, when running update validators, <code>this</code> refers to the query object instead of the document. Because queries have a neat <code>.get()</code> function, you can get the updated value of the property you want.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> toySchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">color</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
});

toySchema.<span class="hljs-title function_">path</span>(<span class="hljs-string">'color'</span>).<span class="hljs-title function_">validate</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
  <span class="hljs-comment">// When running in `validate()` or `validateSync()`, the</span>
  <span class="hljs-comment">// validator can access the document using `this`.</span>
  <span class="hljs-comment">// When running with update validators, `this` is the Query,</span>
  <span class="hljs-comment">// **not** the document being updated!</span>
  <span class="hljs-comment">// Queries have a `get()` method that lets you get the</span>
  <span class="hljs-comment">// updated value.</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>) &amp;&amp; <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'name'</span>).<span class="hljs-title function_">toLowerCase</span>().<span class="hljs-title function_">indexOf</span>(<span class="hljs-string">'red'</span>) !== -<span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> value === <span class="hljs-string">'red'</span>;
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Toy</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'ActionFigure'</span>, toySchema);

<span class="hljs-keyword">const</span> toy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Toy</span>({ <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Red Power Ranger'</span> });
<span class="hljs-comment">// Validation failed: color: Validator failed for path `color` with value `green`</span>
<span class="hljs-keyword">let</span> error = toy.<span class="hljs-title function_">validateSync</span>();
assert.<span class="hljs-title function_">ok</span>(error.<span class="hljs-property">errors</span>[<span class="hljs-string">'color'</span>]);

<span class="hljs-keyword">const</span> update = { <span class="hljs-attr">color</span>: <span class="hljs-string">'green'</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">'Red Power Ranger'</span> };
<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">runValidators</span>: <span class="hljs-literal">true</span> };

error = <span class="hljs-literal">null</span>;
<span class="hljs-keyword">try</span> {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Toy</span>.<span class="hljs-title function_">updateOne</span>({}, update, opts);
} <span class="hljs-keyword">catch</span> (err) {
  error = err;
}
<span class="hljs-comment">// Validation failed: color: Validator failed for path `color` with value `green`</span>
assert.<span class="hljs-title function_">ok</span>(error);
</pre> <h2 id="update-validators-only-run-on-updated-paths">  Update Validators Only Run On Updated Paths  </h2> <p>The other key difference is that update validators only run on the paths specified in the update. For instance, in the below example, because 'name' is not specified in the update operation, update validation will succeed.</p> <p>When using update validators, <code>required</code> validators <strong>only</strong> fail when you try to explicitly <code>$unset</code> the key.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> kittenSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">age</span>: <span class="hljs-title class_">Number</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Kitten</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Kitten'</span>, kittenSchema);

<span class="hljs-keyword">const</span> update = { <span class="hljs-attr">color</span>: <span class="hljs-string">'blue'</span> };
<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">runValidators</span>: <span class="hljs-literal">true</span> };
<span class="hljs-comment">// Operation succeeds despite the fact that 'name' is not specified</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Kitten</span>.<span class="hljs-title function_">updateOne</span>({}, update, opts);

<span class="hljs-keyword">const</span> unset = { <span class="hljs-attr">$unset</span>: { <span class="hljs-attr">name</span>: <span class="hljs-number">1</span> } };
<span class="hljs-comment">// Operation fails because 'name' is required</span>
<span class="hljs-keyword">const</span> err = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Kitten</span>.<span class="hljs-title function_">updateOne</span>({}, unset, opts).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">null</span>, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> err);
assert.<span class="hljs-title function_">ok</span>(err);
assert.<span class="hljs-title function_">ok</span>(err.<span class="hljs-property">errors</span>[<span class="hljs-string">'name'</span>]);
</pre> <h2 id="update-validators-only-run-for-some-operations">  Update Validators Only Run For Some Operations  </h2> <p>One final detail worth noting: update validators <strong>only</strong> run on the following update operators:</p> <ul> <li><code>$set</code></li> <li><code>$unset</code></li> <li><code>$push</code></li> <li><code>$addToSet</code></li> <li><code>$pull</code></li> <li><code>$pullAll</code></li> </ul> <p>For instance, the below update will succeed, regardless of the value of <code>number</code>, because update validators ignore <code>$inc</code>.</p> <p>Also, <code>$push</code>, <code>$addToSet</code>, <code>$pull</code>, and <code>$pullAll</code> validation does <strong>not</strong> run any validation on the array itself, only individual elements of the array.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> testSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">number</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">0</span> },
  <span class="hljs-attr">arr</span>: [{ <span class="hljs-attr">message</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">maxlength</span>: <span class="hljs-number">10</span> } }]
});

<span class="hljs-comment">// Update validators won't check this, so you can still `$push` 2 elements</span>
<span class="hljs-comment">// onto the array, so long as they don't have a `message` that's too long.</span>
testSchema.<span class="hljs-title function_">path</span>(<span class="hljs-string">'arr'</span>).<span class="hljs-title function_">validate</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">v</span>) {
  <span class="hljs-keyword">return</span> v.<span class="hljs-property">length</span> &lt; <span class="hljs-number">2</span>;
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Test</span> = db.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Test'</span>, testSchema);

<span class="hljs-keyword">let</span> update = { <span class="hljs-attr">$inc</span>: { <span class="hljs-attr">number</span>: <span class="hljs-number">1</span> } };
<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">runValidators</span>: <span class="hljs-literal">true</span> };

<span class="hljs-comment">// There will never be a validation error here</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">updateOne</span>({}, update, opts);

<span class="hljs-comment">// This will never error either even though the array will have at</span>
<span class="hljs-comment">// least 2 elements.</span>
update = { <span class="hljs-attr">$push</span>: [{ <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span> }, { <span class="hljs-attr">message</span>: <span class="hljs-string">'world'</span> }] };
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Test</span>.<span class="hljs-title function_">updateOne</span>({}, update, opts);
</pre> <h2 id="next-up">  Next Up  </h2> <p>Now that we've covered <code>Validation</code>, let's take a look at <a href="middleware.html">Middleware</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 LearnBoost<br>Licensed under the MIT License.<br>
    <a href="https://mongoosejs.com/docs/validation.html" class="_attribution-link">https://mongoosejs.com/docs/validation.html</a>
  </p>
</div>
