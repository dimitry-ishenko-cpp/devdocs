<h1 id="populate">  Populate  </h1>   <p>MongoDB has the join-like <a href="https://www.mongodb.com/docs/manual/reference/operator/aggregation/lookup/">$lookup</a> aggregation operator in versions &gt;= 3.2. Mongoose has a more powerful alternative called <code>populate()</code>, which lets you reference documents in other collections.</p> <p>Population is the process of automatically replacing the specified paths in the document with document(s) from other collection(s). We may populate a single document, multiple documents, a plain object, multiple plain objects, or all objects returned from a query. Let's look at some examples.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> mongoose = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mongoose'</span>);
<span class="hljs-keyword">const</span> { <span class="hljs-title class_">Schema</span> } = mongoose;

<span class="hljs-keyword">const</span> personSchema = <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">_id</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-title class_">Number</span>,
  <span class="hljs-attr">stories</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Story'</span> }]
});

<span class="hljs-keyword">const</span> storySchema = <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">author</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span> },
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">fans</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span> }]
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Story</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Story'</span>, storySchema);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Person</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Person'</span>, personSchema);
</pre> <p>So far we've created two <a href="models.html">Models</a>. Our <code>Person</code> model has its <code>stories</code> field set to an array of <code>ObjectId</code>s. The <code>ref</code> option is what tells Mongoose which model to use during population, in our case the <code>Story</code> model. All <code>_id</code>s we store here must be document <code>_id</code>s from the <code>Story</code> model.</p>  <h2 id="saving-refs">Saving refs</h2> <p>Saving refs to other documents works the same way you normally save properties, just assign the <code>_id</code> value:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>({
  <span class="hljs-attr">_id</span>: <span class="hljs-keyword">new</span> mongoose.<span class="hljs-property">Types</span>.<span class="hljs-title class_">ObjectId</span>(),
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Ian Fleming'</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">50</span>
});

<span class="hljs-keyword">await</span> author.<span class="hljs-title function_">save</span>();

<span class="hljs-keyword">const</span> story1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Story</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span>,
  <span class="hljs-attr">author</span>: author.<span class="hljs-property">_id</span> <span class="hljs-comment">// assign the _id from the person</span>
});

<span class="hljs-keyword">await</span> story1.<span class="hljs-title function_">save</span>();
<span class="hljs-comment">// that's it!</span>
</pre> <p>You can set the <code>ref</code> option on <code>ObjectId</code>, <code>Number</code>, <code>String</code>, and <code>Buffer</code> paths. <code>populate()</code> works with ObjectIds, numbers, strings, and buffers. However, we recommend using ObjectIds as <code>_id</code> properties (and thus ObjectIds for <code>ref</code> properties) unless you have a good reason not to. That is because MongoDB will set <code>_id</code> to an ObjectId if you create a new document without an <code>_id</code> property, so if you make your <code>_id</code> property a Number, you need to be extra careful not to insert a document without a numeric <code>_id</code>.</p> <h2 id="population">Population</h2> <p>So far we haven't done anything much different. We've merely created a <code>Person</code> and a <code>Story</code>. Now let's take a look at populating our story's <code>author</code> using the query builder:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'author'</span>).
  <span class="hljs-title function_">exec</span>();
<span class="hljs-comment">// prints "The author is Ian Fleming"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The author is %s'</span>, story.<span class="hljs-property">author</span>.<span class="hljs-property">name</span>);
</pre> <p>Populated paths are no longer set to their original <code>_id</code> , their value is replaced with the mongoose document returned from the database by performing a separate query before returning the results.</p> <p>Arrays of refs work the same way. Just call the <a href="api/query.html#query_Query-populate">populate</a> method on the query and an array of documents will be returned <em>in place</em> of the original <code>_id</code>s.</p> <h2 id="setting-populated-fields">Setting Populated Fields</h2> <p>You can manually populate a property by setting it to a document. The document must be an instance of the model your <code>ref</code> property refers to.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> });
story.<span class="hljs-property">author</span> = author;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(story.<span class="hljs-property">author</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// prints "Ian Fleming"</span>
</pre> <h2 id="checking-populated">Checking Whether a Field is Populated</h2> <p>You can call the <code>populated()</code> function to check whether a field is populated. If <code>populated()</code> returns a <a href="https://masteringjs.io/tutorials/fundamentals/truthy">truthy value</a>, you can assume the field is populated.</p> <pre data-language="javascript">story.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// truthy</span>

story.<span class="hljs-title function_">depopulate</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// Make `author` not populated anymore</span>
story.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// undefined</span>
</pre> <p>A common reason for checking whether a path is populated is getting the <code>author</code> id. However, for your convenience, Mongoose adds a <a href="api/mongoose.html#mongoose_Mongoose-set"><code>_id</code> getter to ObjectId instances</a> so you can use <code>story.author._id</code> regardless of whether <code>author</code> is populated.</p> <pre data-language="javascript">story.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// truthy</span>
story.<span class="hljs-property">author</span>.<span class="hljs-property">_id</span>; <span class="hljs-comment">// ObjectId</span>

story.<span class="hljs-title function_">depopulate</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// Make `author` not populated anymore</span>
story.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'author'</span>); <span class="hljs-comment">// undefined</span>

story.<span class="hljs-property">author</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">ObjectId</span>; <span class="hljs-comment">// true</span>
story.<span class="hljs-property">author</span>.<span class="hljs-property">_id</span>; <span class="hljs-comment">// ObjectId, because Mongoose adds a special getter</span>
</pre> <h2 id="doc-not-found">What If There's No Foreign Document?</h2> <p>Mongoose populate doesn't behave like conventional <a href="https://www.w3schools.com/sql/sql_join.asp">SQL joins</a>. When there's no document, <code>story.author</code> will be <code>null</code>. This is analogous to a <a href="https://www.w3schools.com/sql/sql_join_left.asp">left join</a> in SQL.</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">deleteMany</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ian Fleming'</span> });

<span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> }).<span class="hljs-title function_">populate</span>(<span class="hljs-string">'author'</span>);
story.<span class="hljs-property">author</span>; <span class="hljs-comment">// `null`</span>
</pre> <p>If you have an array of <code>authors</code> in your <code>storySchema</code>, <code>populate()</code> will give you an empty array instead.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> storySchema = <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">authors</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span> }],
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-comment">// Later</span>

<span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> }).<span class="hljs-title function_">populate</span>(<span class="hljs-string">'authors'</span>);
story.<span class="hljs-property">authors</span>; <span class="hljs-comment">// `[]`</span>
</pre> <h2 id="field-selection">Field Selection</h2> <p>What if we only want a few specific fields returned for the populated documents? This can be accomplished by passing the usual <a href="api/query.html#query_Query-select">field name syntax</a> as the second argument to the populate method:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-regexp">/casino royale/i</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'author'</span>, <span class="hljs-string">'name'</span>).
  <span class="hljs-title function_">exec</span>(); <span class="hljs-comment">// only return the Persons name</span>
<span class="hljs-comment">// prints "The author is Ian Fleming"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The author is %s'</span>, story.<span class="hljs-property">author</span>.<span class="hljs-property">name</span>);
<span class="hljs-comment">// prints "The authors age is null"</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The authors age is %s'</span>, story.<span class="hljs-property">author</span>.<span class="hljs-property">age</span>);
</pre> <h2 id="populating-multiple-paths">Populating Multiple Paths</h2> <p>What if we wanted to populate multiple paths at the same time?</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">find</span>({ <span class="hljs-comment">/* ... */</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'fans'</span>).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'author'</span>).
  <span class="hljs-title function_">exec</span>();
</pre> <p>If you call <code>populate()</code> multiple times with the same path, only the last one will take effect.</p> <pre data-language="javascript"><span class="hljs-comment">// The 2nd `populate()` call below overwrites the first because they</span>
<span class="hljs-comment">// both populate 'fans'.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">find</span>().
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'name'</span> }).
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'email'</span> });
<span class="hljs-comment">// The above is equivalent to:</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'email'</span> });
</pre> <h2 id="query-conditions">Query conditions and other options</h2> <p>What if we wanted to populate our fans array based on their age and select just their names?</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">find</span>().
  <span class="hljs-title function_">populate</span>({
    <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>,
    <span class="hljs-attr">match</span>: { <span class="hljs-attr">age</span>: { <span class="hljs-attr">$gte</span>: <span class="hljs-number">21</span> } },
    <span class="hljs-comment">// Explicitly exclude `_id`, see http://bit.ly/2aEfTdB</span>
    <span class="hljs-attr">select</span>: <span class="hljs-string">'name -_id'</span>
  }).
  <span class="hljs-title function_">exec</span>();
</pre> <p>The <code>match</code> option doesn't filter out <code>Story</code> documents. If there are no documents that satisfy <code>match</code>, you'll get a <code>Story</code> document with an empty <code>fans</code> array.</p> <p>For example, suppose you <code>populate()</code> a story's <code>author</code> and the <code>author</code> doesn't satisfy <code>match</code>. Then the story's <code>author</code> will be <code>null</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span> }).
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'author'</span>, <span class="hljs-attr">name</span>: { <span class="hljs-attr">$ne</span>: <span class="hljs-string">'Ian Fleming'</span> } }).
  <span class="hljs-title function_">exec</span>();
story.<span class="hljs-property">author</span>; <span class="hljs-comment">// `null`</span>
</pre> <p>In general, there is no way to make <code>populate()</code> filter stories based on properties of the story's <code>author</code>. For example, the below query won't return any results, even though <code>author</code> is populated.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> story = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-string">'author.name'</span>: <span class="hljs-string">'Ian Fleming'</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'author'</span>).
  <span class="hljs-title function_">exec</span>();
story; <span class="hljs-comment">// null</span>
</pre> <p>If you want to filter stories by their author's name, you should use <a href="https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-3">denormalization</a>.</p> <h2 id="limit-vs-perDocumentLimit">
<code>limit</code> vs. <code>perDocumentLimit</code>
</h2> <p>Populate does support a <code>limit</code> option, however, it currently does <strong>not</strong> limit on a per-document basis for backwards compatibility. For example, suppose you have 2 stories:</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">create</span>([
  { <span class="hljs-attr">title</span>: <span class="hljs-string">'Casino Royale'</span>, <span class="hljs-attr">fans</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>] },
  { <span class="hljs-attr">title</span>: <span class="hljs-string">'Live and Let Die'</span>, <span class="hljs-attr">fans</span>: [<span class="hljs-number">9</span>, <span class="hljs-number">10</span>] }
]);
</pre> <p>If you were to <code>populate()</code> using the <code>limit</code> option, you would find that the 2nd story has 0 fans:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> stories = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>({
  <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>,
  <span class="hljs-attr">options</span>: { <span class="hljs-attr">limit</span>: <span class="hljs-number">2</span> }
});

stories[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Casino Royale'</span>
stories[<span class="hljs-number">0</span>].<span class="hljs-property">fans</span>.<span class="hljs-property">length</span>; <span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 2nd story has 0 fans!</span>
stories[<span class="hljs-number">1</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Live and Let Die'</span>
stories[<span class="hljs-number">1</span>].<span class="hljs-property">fans</span>.<span class="hljs-property">length</span>; <span class="hljs-comment">// 0</span>
</pre> <p>That's because, in order to avoid executing a separate query for each document, Mongoose instead queries for fans using <code>numDocuments * limit</code> as the limit. If you need the correct <code>limit</code>, you should use the <code>perDocumentLimit</code> option (new in Mongoose 5.9.0). Just keep in mind that <code>populate()</code> will execute a separate query for each story, which may cause <code>populate()</code> to be slower.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> stories = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>({
  <span class="hljs-attr">path</span>: <span class="hljs-string">'fans'</span>,
  <span class="hljs-comment">// Special option that tells Mongoose to execute a separate query</span>
  <span class="hljs-comment">// for each `story` to make sure we get 2 fans for each story.</span>
  <span class="hljs-attr">perDocumentLimit</span>: <span class="hljs-number">2</span>
});

stories[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Casino Royale'</span>
stories[<span class="hljs-number">0</span>].<span class="hljs-property">fans</span>.<span class="hljs-property">length</span>; <span class="hljs-comment">// 2</span>

stories[<span class="hljs-number">1</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Live and Let Die'</span>
stories[<span class="hljs-number">1</span>].<span class="hljs-property">fans</span>.<span class="hljs-property">length</span>; <span class="hljs-comment">// 2</span>
</pre> <h2 id="refs-to-children">Refs to children</h2> <p>We may find however, if we use the <code>author</code> object, we are unable to get a list of the stories. This is because no <code>story</code> objects were ever 'pushed' onto <code>author.stories</code>.</p> <p>There are two perspectives here. First, you may want the <code>author</code> to know which stories are theirs. Usually, your schema should resolve one-to-many relationships by having a parent pointer in the 'many' side. But, if you have a good reason to want an array of child pointers, you can <code>push()</code> documents onto the array as shown below.</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> story1.<span class="hljs-title function_">save</span>();

author.<span class="hljs-property">stories</span>.<span class="hljs-title function_">push</span>(story1);
<span class="hljs-keyword">await</span> author.<span class="hljs-title function_">save</span>();
</pre> <p>This allows us to perform a <code>find</code> and <code>populate</code> combo:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Person</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ian Fleming'</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'stories'</span>).
  <span class="hljs-title function_">exec</span>(); <span class="hljs-comment">// only works if we pushed refs to children</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);
</pre> <p>It is debatable that we really want two sets of pointers as they may get out of sync. Instead we could skip populating and directly <code>find()</code> the stories we are interested in.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> stories = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Story</span>.
  <span class="hljs-title function_">find</span>({ <span class="hljs-attr">author</span>: author.<span class="hljs-property">_id</span> }).
  <span class="hljs-title function_">exec</span>();
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'The stories are an array: '</span>, stories);
</pre> <p>The documents returned from <a href="api/query.html#query_Query-populate">query population</a> become fully functional, <code>remove</code>able, <code>save</code>able documents unless the <a href="api/query.html#query_Query-lean">lean</a> option is specified. Do not confuse them with <a href="subdocs.html">sub docs</a>. Take caution when calling its remove method because you'll be removing it from the database, not just the array.</p> <h2 id="populate_an_existing_mongoose_document">Populating an existing document</h2> <p>If you have an existing mongoose document and want to populate some of its paths, you can use the <a href="api/document.html#document_Document-populate">Document#populate()</a> method.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Person</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Ian Fleming'</span> });

person.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'stories'</span>); <span class="hljs-comment">// null</span>

<span class="hljs-comment">// Call the `populate()` method on a document to populate a path.</span>
<span class="hljs-keyword">await</span> person.<span class="hljs-title function_">populate</span>(<span class="hljs-string">'stories'</span>);

person.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'stories'</span>); <span class="hljs-comment">// Array of ObjectIds</span>
person.<span class="hljs-property">stories</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Casino Royale'</span>
</pre> <p>The <code>Document#populate()</code> method does not support chaining. You need to call <code>populate()</code> multiple times, or with an array of paths, to populate multiple paths</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> person.<span class="hljs-title function_">populate</span>([<span class="hljs-string">'stories'</span>, <span class="hljs-string">'fans'</span>]);
person.<span class="hljs-title function_">populated</span>(<span class="hljs-string">'fans'</span>); <span class="hljs-comment">// Array of ObjectIds</span>
</pre> <h2 id="populate_multiple_documents">Populating multiple existing documents</h2> <p>If we have one or many mongoose documents or even plain objects (<em>like <a href="api/model.html#model_Model-mapReduce">mapReduce</a> output</em>), we may populate them using the <a href="api/model.html#model_Model-populate">Model.populate()</a> method. This is what <code>Document#populate()</code> and <code>Query#populate()</code> use to populate documents.</p> <h2 id="deep-populate">Populating across multiple levels</h2> <p>Say you have a user schema which keeps track of the user's friends.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">friends</span>: [{ <span class="hljs-attr">type</span>: <span class="hljs-title class_">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'User'</span> }]
});
</pre> <p>Populate lets you get a list of a user's friends, but what if you also wanted a user's friends of friends? Specify the <code>populate</code> option to tell mongoose to populate the <code>friends</code> array of all the user's friends:</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">User</span>.
  <span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Val'</span> }).
  <span class="hljs-title function_">populate</span>({
    <span class="hljs-attr">path</span>: <span class="hljs-string">'friends'</span>,
    <span class="hljs-comment">// Get friends of friends - populate the 'friends' array for every friend</span>
    <span class="hljs-attr">populate</span>: { <span class="hljs-attr">path</span>: <span class="hljs-string">'friends'</span> }
  });
</pre> <h2 id="cross-db-populate">Cross Database Populate</h2> <p>Let's say you have a schema representing events, and a schema representing conversations. Each event has a corresponding conversation thread.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> db1 = mongoose.<span class="hljs-title function_">createConnection</span>(<span class="hljs-string">'mongodb://127.0.0.1:27000/db1'</span>);
<span class="hljs-keyword">const</span> db2 = mongoose.<span class="hljs-title function_">createConnection</span>(<span class="hljs-string">'mongodb://127.0.0.1:27001/db2'</span>);

<span class="hljs-keyword">const</span> conversationSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">numMessages</span>: <span class="hljs-title class_">Number</span> });
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Conversation</span> = db2.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Conversation'</span>, conversationSchema);

<span class="hljs-keyword">const</span> eventSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">conversation</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">ObjectId</span>,
    <span class="hljs-attr">ref</span>: <span class="hljs-title class_">Conversation</span> <span class="hljs-comment">// `ref` is a **Model class**, not a string</span>
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Event</span> = db1.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Event'</span>, eventSchema);
</pre> <p>In the above example, events and conversations are stored in separate MongoDB databases. String <code>ref</code> will not work in this situation, because Mongoose assumes a string <code>ref</code> refers to a model name on the same connection. In the above example, the conversation model is registered on <code>db2</code>, not <code>db1</code>.</p> <pre data-language="javascript"><span class="hljs-comment">// Works</span>
<span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Event</span>.
  <span class="hljs-title function_">find</span>().
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'conversation'</span>);
</pre> <p>This is known as a "cross-database populate," because it enables you to populate across MongoDB databases and even across MongoDB instances.</p> <p>If you don't have access to the model instance when defining your <code>eventSchema</code>, you can also pass <a href="api/model.html#model_Model-populate">the model instance as an option to <code>populate()</code></a>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> events = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Event</span>.
  <span class="hljs-title function_">find</span>().
  <span class="hljs-comment">// The `model` option specifies the model to use for populating.</span>
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'conversation'</span>, <span class="hljs-attr">model</span>: <span class="hljs-title class_">Conversation</span> });
</pre> <h2 id="dynamic-ref">Dynamic References via <code>refPath</code>
</h2> <p>Mongoose can also populate from multiple collections based on the value of a property in the document. Let's say you're building a schema for storing comments. A user may comment on either a blog post or a product.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> commentSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">body</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">doc</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// Instead of a hardcoded model name in `ref`, `refPath` means Mongoose</span>
    <span class="hljs-comment">// will look at the `docModel` property to find the right model.</span>
    <span class="hljs-attr">refPath</span>: <span class="hljs-string">'docModel'</span>
  },
  <span class="hljs-attr">docModel</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">enum</span>: [<span class="hljs-string">'BlogPost'</span>, <span class="hljs-string">'Product'</span>]
  }
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Product</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Product'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }));
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPost</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'BlogPost'</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span> }));
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Comment</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Comment'</span>, commentSchema);
</pre> <p>The <code>refPath</code> option is a more sophisticated alternative to <code>ref</code>. If <code>ref</code> is a string, Mongoose will always query the same model to find the populated subdocs. With <code>refPath</code>, you can configure what model Mongoose uses for each document.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> book = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Product</span>.<span class="hljs-title function_">create</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'The Count of Monte Cristo'</span> });
<span class="hljs-keyword">const</span> post = <span class="hljs-keyword">await</span> <span class="hljs-title class_">BlogPost</span>.<span class="hljs-title function_">create</span>({ <span class="hljs-attr">title</span>: <span class="hljs-string">'Top 10 French Novels'</span> });

<span class="hljs-keyword">const</span> commentOnBook = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Comment</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">body</span>: <span class="hljs-string">'Great read'</span>,
  <span class="hljs-attr">doc</span>: book.<span class="hljs-property">_id</span>,
  <span class="hljs-attr">docModel</span>: <span class="hljs-string">'Product'</span>
});

<span class="hljs-keyword">const</span> commentOnPost = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Comment</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">body</span>: <span class="hljs-string">'Very informative'</span>,
  <span class="hljs-attr">doc</span>: post.<span class="hljs-property">_id</span>,
  <span class="hljs-attr">docModel</span>: <span class="hljs-string">'BlogPost'</span>
});

<span class="hljs-comment">// The below `populate()` works even though one comment references the</span>
<span class="hljs-comment">// 'Product' collection and the other references the 'BlogPost' collection.</span>
<span class="hljs-keyword">const</span> comments = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Comment</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">'doc'</span>).<span class="hljs-title function_">sort</span>({ <span class="hljs-attr">body</span>: <span class="hljs-number">1</span> });
comments[<span class="hljs-number">0</span>].<span class="hljs-property">doc</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// "The Count of Monte Cristo"</span>
comments[<span class="hljs-number">1</span>].<span class="hljs-property">doc</span>.<span class="hljs-property">title</span>; <span class="hljs-comment">// "Top 10 French Novels"</span>
</pre> <p>An alternative approach is to define separate <code>blogPost</code> and <code>product</code> properties on <code>commentSchema</code>, and then <code>populate()</code> on both properties.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> commentSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">body</span>: { <span class="hljs-attr">type</span>: <span class="hljs-title class_">String</span>, <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span> },
  <span class="hljs-attr">product</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">ref</span>: <span class="hljs-string">'Product'</span>
  },
  <span class="hljs-attr">blogPost</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>,
    <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">ref</span>: <span class="hljs-string">'BlogPost'</span>
  }
});

<span class="hljs-comment">// ...</span>

<span class="hljs-comment">// The below `populate()` is equivalent to the `refPath` approach, you</span>
<span class="hljs-comment">// just need to make sure you `populate()` both `product` and `blogPost`.</span>
<span class="hljs-keyword">const</span> comments = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Comment</span>.<span class="hljs-title function_">find</span>().
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'product'</span>).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'blogPost'</span>).
  <span class="hljs-title function_">sort</span>({ <span class="hljs-attr">body</span>: <span class="hljs-number">1</span> });
comments[<span class="hljs-number">0</span>].<span class="hljs-property">product</span>.<span class="hljs-property">name</span>; <span class="hljs-comment">// "The Count of Monte Cristo"</span>
comments[<span class="hljs-number">1</span>].<span class="hljs-property">blogPost</span>.<span class="hljs-property">title</span>; <span class="hljs-comment">// "Top 10 French Novels"</span>
</pre> <p>Defining separate <code>blogPost</code> and <code>product</code> properties works for this simple example. But, if you decide to allow users to also comment on articles or other comments, you'll need to add more properties to your schema. You'll also need an extra <code>populate()</code> call for every property, unless you use <a href="https://www.npmjs.com/package/mongoose-autopopulate">mongoose-autopopulate</a>. Using <code>refPath</code> means you only need 2 schema paths and one <code>populate()</code> call regardless of how many models your <code>commentSchema</code> can point to.</p> <h2 id="populate-virtuals">Populate Virtuals</h2> <p>So far you've only populated based on the <code>_id</code> field. However, that's sometimes not the right choice. For example, suppose you have 2 models: <code>Author</code> and <code>BlogPost</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AuthorSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">posts</span>: [{ <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'BlogPost'</span> }]
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPostSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">comments</span>: [{
    <span class="hljs-attr">author</span>: { <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Author'</span> },
    <span class="hljs-attr">content</span>: <span class="hljs-title class_">String</span>
  }]
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Author</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Author'</span>, <span class="hljs-title class_">AuthorSchema</span>, <span class="hljs-string">'Author'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPost</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'BlogPost'</span>, <span class="hljs-title class_">BlogPostSchema</span>, <span class="hljs-string">'BlogPost'</span>);
</pre> <p>The above is an example of <strong>bad schema design</strong>. Why? Suppose you have an extremely prolific author that writes over 10k blog posts. That <code>author</code> document will be huge, over 12kb, and large documents lead to performance issues on both server and client. The <a href="https://dev.to/swyx/4-things-i-learned-from-mastering-mongoose-js-25e#4-principle-of-least-cardinality">Principle of Least Cardinality</a> states that one-to-many relationships, like author to blog post, should be stored on the "many" side. In other words, blog posts should store their <code>author</code>, authors should <strong>not</strong> store all their <code>posts</code>.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">AuthorSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPostSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">author</span>: { <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Author'</span> },
  <span class="hljs-attr">comments</span>: [{
    <span class="hljs-attr">author</span>: { <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Author'</span> },
    <span class="hljs-attr">content</span>: <span class="hljs-title class_">String</span>
  }]
});
</pre> <p>Unfortunately, these two schemas, as written, don't support populating an author's list of blog posts. That's where <em>virtual populate</em> comes in. Virtual populate means calling <code>populate()</code> on a virtual property that has a <code>ref</code> option as shown below.</p> <pre data-language="javascript"><span class="hljs-comment">// Specifying a virtual with a `ref` property is how you enable virtual</span>
<span class="hljs-comment">// population</span>
<span class="hljs-title class_">AuthorSchema</span>.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">'posts'</span>, {
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'BlogPost'</span>,
  <span class="hljs-attr">localField</span>: <span class="hljs-string">'_id'</span>,
  <span class="hljs-attr">foreignField</span>: <span class="hljs-string">'author'</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Author</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Author'</span>, <span class="hljs-title class_">AuthorSchema</span>, <span class="hljs-string">'Author'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPost</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'BlogPost'</span>, <span class="hljs-title class_">BlogPostSchema</span>, <span class="hljs-string">'BlogPost'</span>);
</pre> <p>You can then <code>populate()</code> the author's <code>posts</code> as shown below.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> author = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">'posts'</span>);

author.<span class="hljs-property">posts</span>[<span class="hljs-number">0</span>].<span class="hljs-property">title</span>; <span class="hljs-comment">// Title of the first blog post</span>
</pre> <p>Keep in mind that virtuals are <em>not</em> included in <code>toJSON()</code> and <code>toObject()</code> output by default. If you want populate virtuals to show up when using functions like Express' <a href="https://masteringjs.io/tutorials/express/json"><code>res.json()</code> function</a> or <code>console.log()</code>, set the <code>virtuals: true</code> option on your schema's <code>toJSON</code> and <code>toObject()</code> options.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> authorSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({ <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> }, {
  <span class="hljs-attr">toJSON</span>: { <span class="hljs-attr">virtuals</span>: <span class="hljs-literal">true</span> }, <span class="hljs-comment">// So `res.json()` and other `JSON.stringify()` functions include virtuals</span>
  <span class="hljs-attr">toObject</span>: { <span class="hljs-attr">virtuals</span>: <span class="hljs-literal">true</span> } <span class="hljs-comment">// So `console.log()` and other functions that use `toObject()` include virtuals</span>
});
</pre> <p>If you're using populate projections, make sure <code>foreignField</code> is included in the projection.</p> <pre data-language="javascript"><span class="hljs-keyword">let</span> authors = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.
  <span class="hljs-title function_">find</span>({}).
  <span class="hljs-comment">// Won't work because the foreign field `author` is not selected</span>
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'posts'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'title'</span> }).
  <span class="hljs-title function_">exec</span>();

authors = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.
  <span class="hljs-title function_">find</span>({}).
  <span class="hljs-comment">// Works, foreign field `author` is selected</span>
  <span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'posts'</span>, <span class="hljs-attr">select</span>: <span class="hljs-string">'title author'</span> }).
  <span class="hljs-title function_">exec</span>();
</pre> <h2 id="count">Populate Virtuals: The Count Option</h2> <p>Populate virtuals also support counting the number of documents with matching <code>foreignField</code> as opposed to the documents themselves. Set the <code>count</code> option on your virtual:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">PersonSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">band</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">BandSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>
});
<span class="hljs-title class_">BandSchema</span>.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">'numMembers'</span>, {
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span>, <span class="hljs-comment">// The model to use</span>
  <span class="hljs-attr">localField</span>: <span class="hljs-string">'name'</span>, <span class="hljs-comment">// Find people where `localField`</span>
  <span class="hljs-attr">foreignField</span>: <span class="hljs-string">'band'</span>, <span class="hljs-comment">// is equal to `foreignField`</span>
  <span class="hljs-attr">count</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// And only get the number of docs</span>
});

<span class="hljs-comment">// Later</span>
<span class="hljs-keyword">const</span> doc = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Band</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Motley Crue'</span> }).
  <span class="hljs-title function_">populate</span>(<span class="hljs-string">'numMembers'</span>);
doc.<span class="hljs-property">numMembers</span>; <span class="hljs-comment">// 2</span>
</pre> <h2 id="match">Populate Virtuals: The Match Option</h2> <p>Another option for Populate virtuals is <code>match</code>. This option adds an extra filter condition to the query Mongoose uses to <code>populate()</code>:</p> <pre data-language="javascript"><span class="hljs-comment">// Same example as 'Populate Virtuals' section</span>
<span class="hljs-title class_">AuthorSchema</span>.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">'posts'</span>, {
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'BlogPost'</span>,
  <span class="hljs-attr">localField</span>: <span class="hljs-string">'_id'</span>,
  <span class="hljs-attr">foreignField</span>: <span class="hljs-string">'author'</span>,
  <span class="hljs-attr">match</span>: { <span class="hljs-attr">archived</span>: <span class="hljs-literal">false</span> } <span class="hljs-comment">// match option with basic query selector</span>
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Author</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Author'</span>, <span class="hljs-title class_">AuthorSchema</span>, <span class="hljs-string">'Author'</span>);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">BlogPost</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'BlogPost'</span>, <span class="hljs-title class_">BlogPostSchema</span>, <span class="hljs-string">'BlogPost'</span>);

<span class="hljs-comment">// After population</span>
<span class="hljs-keyword">const</span> author = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">'posts'</span>);

author.<span class="hljs-property">posts</span>; <span class="hljs-comment">// Array of not `archived` posts</span>
</pre> <p>You can also set the <code>match</code> option to a function. That allows configuring the <code>match</code> based on the document being populated. For example, suppose you only want to populate blog posts whose <code>tags</code> contain one of the author's <code>favoriteTags</code>.</p> <pre data-language="javascript"><span class="hljs-title class_">AuthorSchema</span>.<span class="hljs-title function_">virtual</span>(<span class="hljs-string">'posts'</span>, {
  <span class="hljs-attr">ref</span>: <span class="hljs-string">'BlogPost'</span>,
  <span class="hljs-attr">localField</span>: <span class="hljs-string">'_id'</span>,
  <span class="hljs-attr">foreignField</span>: <span class="hljs-string">'author'</span>,
  <span class="hljs-comment">// Add an additional filter `{ tags: author.favoriteTags }` to the populate query</span>
  <span class="hljs-comment">// Mongoose calls the `match` function with the document being populated as the</span>
  <span class="hljs-comment">// first argument.</span>
  <span class="hljs-attr">match</span>: <span class="hljs-function"><span class="hljs-params">author</span> =&gt;</span> ({ <span class="hljs-attr">tags</span>: author.<span class="hljs-property">favoriteTags</span> })
});
</pre> <p>You can overwrite the <code>match</code> option when calling <code>populate()</code> as follows.</p> <pre data-language="javascript"><span class="hljs-comment">// Overwrite the `match` option specified in `AuthorSchema.virtual()` for this</span>
<span class="hljs-comment">// single `populate()` call.</span>
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: posts, <span class="hljs-attr">match</span>: {} });
</pre> <p>You can also set the <code>match</code> option to a function in your <code>populate()</code> call. If you want to merge your <code>populate()</code> match option, rather than overwriting, use the following.</p> <pre data-language="javascript"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Author</span>.<span class="hljs-title function_">findOne</span>().<span class="hljs-title function_">populate</span>({
  <span class="hljs-attr">path</span>: posts,
  <span class="hljs-comment">// Add `isDeleted: false` to the virtual's default `match`, so the `match`</span>
  <span class="hljs-comment">// option would be `{ tags: author.favoriteTags, isDeleted: false }`</span>
  <span class="hljs-attr">match</span>: <span class="hljs-function">(<span class="hljs-params">author, virtual</span>) =&gt;</span> ({
    ...virtual.<span class="hljs-property">options</span>.<span class="hljs-title function_">match</span>(author),
    <span class="hljs-attr">isDeleted</span>: <span class="hljs-literal">false</span>
  })
});
</pre> <h2 id="populating-maps">Populating Maps</h2> <p><a href="schematypes.html#maps">Maps</a> are a type that represents an object with arbitrary string keys. For example, in the below schema, <code>members</code> is a map from strings to ObjectIds.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">BandSchema</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">members</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Map</span>,
    <span class="hljs-attr">of</span>: {
      <span class="hljs-attr">type</span>: <span class="hljs-string">'ObjectId'</span>,
      <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span>
    }
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Band</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Band'</span>, bandSchema);
</pre> <p>This map has a <code>ref</code>, which means you can use <code>populate()</code> to populate all the ObjectIds in the map. Suppose you have the below <code>band</code> document:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> person1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Vince Neil'</span> });
<span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Mick Mars'</span> });

<span class="hljs-keyword">const</span> band = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Band</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-string">'Motley Crue'</span>,
  <span class="hljs-attr">members</span>: {
    <span class="hljs-attr">singer</span>: person1.<span class="hljs-property">_id</span>,
    <span class="hljs-attr">guitarist</span>: person2.<span class="hljs-property">_id</span>
  }
});
</pre> <p>You can <code>populate()</code> every element in the map by populating the special path <code>members.$*</code>. <code>$*</code> is a special syntax that tells Mongoose to look at every key in the map.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> band = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Band</span>.<span class="hljs-title function_">findOne</span>({ <span class="hljs-attr">name</span>: <span class="hljs-string">'Motley Crue'</span> }).<span class="hljs-title function_">populate</span>(<span class="hljs-string">'members.$*'</span>);

band.<span class="hljs-property">members</span>.<span class="hljs-title function_">get</span>(<span class="hljs-string">'singer'</span>); <span class="hljs-comment">// { _id: ..., name: 'Vince Neil' }</span>
</pre> <p>You can also populate paths in maps of subdocuments using <code>$*</code>. For example, suppose you have the below <code>librarySchema</code>:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> librarySchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">books</span>: {
    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Map</span>,
    <span class="hljs-attr">of</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
      <span class="hljs-attr">title</span>: <span class="hljs-title class_">String</span>,
      <span class="hljs-attr">author</span>: {
        <span class="hljs-attr">type</span>: <span class="hljs-string">'ObjectId'</span>,
        <span class="hljs-attr">ref</span>: <span class="hljs-string">'Person'</span>
      }
    })
  }
});
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Library</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Library'</span>, librarySchema);
</pre> <p>You can <code>populate()</code> every book's author by populating <code>books.$*.author</code>:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> libraries = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Library</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>(<span class="hljs-string">'books.$*.author'</span>);
</pre> <h2 id="populate-middleware">Populate in Middleware</h2> <p>You can populate in either pre or post <a href="http://mongoosejs.com/docs/middleware.html">hooks</a>. If you want to always populate a certain field, check out the <a href="http://npmjs.com/package/mongoose-autopopulate">mongoose-autopopulate plugin</a>.</p> <pre data-language="javascript"><span class="hljs-comment">// Always attach `populate()` to `find()` calls</span>
<span class="hljs-title class_">MySchema</span>.<span class="hljs-title function_">pre</span>(<span class="hljs-string">'find'</span>, <span class="hljs-keyword">function</span>() {
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">populate</span>(<span class="hljs-string">'user'</span>);
});
</pre> <pre data-language="javascript"><span class="hljs-comment">// Always `populate()` after `find()` calls. Useful if you want to selectively populate</span>
<span class="hljs-comment">// based on the docs found.</span>
<span class="hljs-title class_">MySchema</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">'find'</span>, <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">docs</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> doc <span class="hljs-keyword">of</span> docs) {
    <span class="hljs-keyword">if</span> (doc.<span class="hljs-property">isPublic</span>) {
      <span class="hljs-keyword">await</span> doc.<span class="hljs-title function_">populate</span>(<span class="hljs-string">'user'</span>);
    }
  }
});
</pre> <pre data-language="javascript"><span class="hljs-comment">// `populate()` after saving. Useful for sending populated data back to the client in an</span>
<span class="hljs-comment">// update API endpoint</span>
<span class="hljs-title class_">MySchema</span>.<span class="hljs-title function_">post</span>(<span class="hljs-string">'save'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">doc, next</span>) {
  doc.<span class="hljs-title function_">populate</span>(<span class="hljs-string">'user'</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>() {
    <span class="hljs-title function_">next</span>();
  });
});
</pre> <h2 id="populating-multiple-paths-middleware">Populating Multiple Paths in Middleware</h2> <p>Populating multiple paths in middleware can be helpful when you always want to populate some fields. But, the implementation is just a tiny bit trickier than what you may think. Here's how you may expect it to work:</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> userSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">email</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">password</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">followers</span>: [{ <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'User'</span> }],
  <span class="hljs-attr">following</span>: [{ <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">Schema</span>.<span class="hljs-property">Types</span>.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'User'</span> }]
});

userSchema.<span class="hljs-title function_">pre</span>(<span class="hljs-string">'find'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">populate</span>(<span class="hljs-string">'followers following'</span>);
  <span class="hljs-title function_">next</span>();
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">User</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'User'</span>, userSchema);
</pre> <p>However, this will not work. By default, passing multiple paths to <code>populate()</code> in the middleware will trigger an infinite recursion, which means that it will basically trigger the same middleware for all of the paths provided to the <code>populate()</code> method - For example, <code>this.populate('followers following')</code> will trigger the same middleware for both <code>followers</code> and <code>following</code> fields and the request will just be left hanging in an infinite loop.</p> <p>To avoid this, we have to add the <code>_recursed</code> option, so that our middleware will avoid populating recursively. The example below will make it work as expected.</p> <pre data-language="javascript">userSchema.<span class="hljs-title function_">pre</span>(<span class="hljs-string">'find'</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">next</span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">options</span>.<span class="hljs-property">_recursed</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">next</span>();
  }
  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">populate</span>({ <span class="hljs-attr">path</span>: <span class="hljs-string">'followers following'</span>, <span class="hljs-attr">options</span>: { <span class="hljs-attr">_recursed</span>: <span class="hljs-literal">true</span> } });
  <span class="hljs-title function_">next</span>();
});
</pre> <p>Alternatively, you can check out the <a href="http://npmjs.com/package/mongoose-autopopulate">mongoose-autopopulate plugin</a>.</p> <h2 id="transform-populated-documents">Transform populated documents</h2> <p>You can manipulate populated documents using the <code>transform</code> option. If you specify a <code>transform</code> function, Mongoose will call this function on every populated document in the result with two arguments: the populated document, and the original id used to populate the document. This gives you more control over the result of the <code>populate()</code> execution. It is especially useful when you're populating multiple documents.</p> <p>The <a href="https://github.com/Automattic/mongoose/issues/3775">original motivation</a> for the <code>transform</code> option was to give the ability to leave the unpopulated <code>_id</code> if no document was found, instead of setting the value to <code>null</code>:</p> <pre data-language="javascript"><span class="hljs-comment">// With `transform`</span>
doc = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">findById</span>(doc).<span class="hljs-title function_">populate</span>([
  {
    <span class="hljs-attr">path</span>: <span class="hljs-string">'child'</span>,
    <span class="hljs-comment">// If `doc` is null, use the original id instead</span>
    <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params">doc, id</span>) =&gt;</span> doc == <span class="hljs-literal">null</span> ? id : doc
  }
]);

doc.<span class="hljs-property">child</span>; <span class="hljs-comment">// 634d1a5744efe65ae09142f9</span>
doc.<span class="hljs-property">children</span>; <span class="hljs-comment">// [ 634d1a67ac15090a0ca6c0ea, { _id: 634d1a4ddb804d17d95d1c7f, name: 'Luke', __v: 0 } ]</span>
</pre> <p>You can return any value from <code>transform()</code>. For example, you can use <code>transform()</code> to "flatten" populated documents as follows.</p> <pre data-language="javascript"><span class="hljs-keyword">let</span> doc = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">create</span>({ <span class="hljs-attr">children</span>: [{ <span class="hljs-attr">name</span>: <span class="hljs-string">'Luke'</span> }, { <span class="hljs-attr">name</span>: <span class="hljs-string">'Leia'</span> }] });

doc = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Parent</span>.<span class="hljs-title function_">findById</span>(doc).<span class="hljs-title function_">populate</span>([{
  <span class="hljs-attr">path</span>: <span class="hljs-string">'children'</span>,
  <span class="hljs-attr">transform</span>: <span class="hljs-function"><span class="hljs-params">doc</span> =&gt;</span> doc == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : doc.<span class="hljs-property">name</span>
}]);

doc.<span class="hljs-property">children</span>; <span class="hljs-comment">// ['Luke', 'Leia']</span>
</pre> <p>Another use case for <code>transform()</code> is setting <code>$locals</code> values on populated documents to pass parameters to getters and virtuals. For example, suppose you want to set a language code on your document for internationalization purposes as follows.</p> <pre data-language="javascript"><span class="hljs-keyword">const</span> internationalizedStringSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">en</span>: <span class="hljs-title class_">String</span>,
  <span class="hljs-attr">es</span>: <span class="hljs-title class_">String</span>
});

<span class="hljs-keyword">const</span> ingredientSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-comment">// Instead of setting `name` to just a string, set `name` to a map</span>
  <span class="hljs-comment">// of language codes to strings.</span>
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">type</span>: internationalizedStringSchema,
    <span class="hljs-comment">// When you access `name`, pull the document's locale</span>
    <span class="hljs-attr">get</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) {
      <span class="hljs-keyword">return</span> value[<span class="hljs-variable language_">this</span>.<span class="hljs-property">$locals</span>.<span class="hljs-property">language</span> || <span class="hljs-string">'en'</span>];
    }
  }
});

<span class="hljs-keyword">const</span> recipeSchema = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Schema</span>({
  <span class="hljs-attr">ingredients</span>: [{ <span class="hljs-attr">type</span>: mongoose.<span class="hljs-property">ObjectId</span>, <span class="hljs-attr">ref</span>: <span class="hljs-string">'Ingredient'</span> }]
});

<span class="hljs-keyword">const</span> <span class="hljs-title class_">Ingredient</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Ingredient'</span>, ingredientSchema);
<span class="hljs-keyword">const</span> <span class="hljs-title class_">Recipe</span> = mongoose.<span class="hljs-title function_">model</span>(<span class="hljs-string">'Recipe'</span>, recipeSchema);
</pre> <p>You can set the language code on all populated exercises as follows:</p> <pre data-language="javascript"><span class="hljs-comment">// Create some sample data</span>
<span class="hljs-keyword">const</span> { _id } = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Ingredient</span>.<span class="hljs-title function_">create</span>({
  <span class="hljs-attr">name</span>: {
    <span class="hljs-attr">en</span>: <span class="hljs-string">'Eggs'</span>,
    <span class="hljs-attr">es</span>: <span class="hljs-string">'Huevos'</span>
  }
});
<span class="hljs-keyword">await</span> <span class="hljs-title class_">Recipe</span>.<span class="hljs-title function_">create</span>({ <span class="hljs-attr">ingredients</span>: [_id] });

<span class="hljs-comment">// Populate with setting `$locals.language` for internationalization</span>
<span class="hljs-keyword">const</span> language = <span class="hljs-string">'es'</span>;
<span class="hljs-keyword">const</span> recipes = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Recipe</span>.<span class="hljs-title function_">find</span>().<span class="hljs-title function_">populate</span>({
  <span class="hljs-attr">path</span>: <span class="hljs-string">'ingredients'</span>,
  <span class="hljs-attr">transform</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">doc</span>) {
    doc.<span class="hljs-property">$locals</span>.<span class="hljs-property">language</span> = language;
    <span class="hljs-keyword">return</span> doc;
  }
});

<span class="hljs-comment">// Gets the ingredient's name in Spanish `name.es`</span>
recipes[<span class="hljs-number">0</span>].<span class="hljs-property">ingredients</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>; <span class="hljs-comment">// 'Huevos'</span>
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2010 LearnBoost<br>Licensed under the MIT License.<br>
    <a href="https://mongoosejs.com/docs/populate.html" class="_attribution-link">https://mongoosejs.com/docs/populate.html</a>
  </p>
</div>
