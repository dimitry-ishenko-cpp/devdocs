<h1 id="man-workflow-tips">Workflow Tips</h1>
<p>Here are some tips for working with Julia efficiently.</p>
<h2 id="REPL-based-workflow">
<a class="docs-heading-anchor" href="#REPL-based-workflow">REPL-based workflow</a>
</h2>
<p>As already elaborated in <a href="../../stdlib/repl/index.html#The-Julia-REPL">The Julia REPL</a>, Julia's REPL provides rich functionality that facilitates an efficient interactive workflow. Here are some tips that might further enhance your experience at the command line.</p>
<h3 id="A-basic-editor/REPL-workflow">
<a class="docs-heading-anchor" href="#A-basic-editor/REPL-workflow">A basic editor/REPL workflow</a>
</h3>
<p>The most basic Julia workflows involve using a text editor in conjunction with the <code>julia</code> command line. A common pattern includes the following elements:</p>
<ul>
<li>
<p><strong>Put code under development in a temporary module.</strong> Create a file, say <code>Tmp.jl</code>, and include within it</p>
<pre data-language="julia">module Tmp
export say_hello

say_hello() = println("Hello!")

# your other definitions here

end</pre>
</li>
<li>
<p><strong>Put your test code in another file.</strong> Create another file, say <code>tst.jl</code>, which looks like</p>
<pre data-language="julia">include("Tmp.jl")
import .Tmp
# using .Tmp # we can use `using` to bring the exported symbols in `Tmp` into our namespace

Tmp.say_hello()
# say_hello()

# your other test code here</pre>
<p>and includes tests for the contents of <code>Tmp</code>. Alternatively, you can wrap the contents of your test file in a module, as</p>
<pre data-language="julia">module Tst
    include("Tmp.jl")
    import .Tmp
    #using .Tmp

    Tmp.say_hello()
    # say_hello()

    # your other test code here
end</pre>
<p>The advantage is that your testing code is now contained in a module and does not use the global scope in <code>Main</code> for definitions, which is a bit more tidy.</p>
</li>
<li><p><code>include</code> the <code>tst.jl</code> file in the Julia REPL with <code>include("tst.jl")</code>.</p></li>
<li><p><strong>Lather. Rinse. Repeat.</strong> Explore ideas at the <code>julia</code> command prompt. Save good ideas in <code>tst.jl</code>. To execute <code>tst.jl</code> after it has been changed, just <code>include</code> it again.</p></li>
</ul>
<h2 id="Browser-based-workflow">
<a class="docs-heading-anchor" href="#Browser-based-workflow">Browser-based workflow</a>
</h2>
<p>There are a few ways to interact with Julia in a browser:</p>
<ul>
<li>Using Pluto notebooks through <a href="https://github.com/fonsp/Pluto.jl">Pluto.jl</a>
</li>
<li>Using Jupyter notebooks through <a href="https://github.com/JuliaLang/IJulia.jl">IJulia.jl</a>
</li>
</ul>
<h2 id="Revise-based-workflows">
<a class="docs-heading-anchor" href="#Revise-based-workflows">Revise-based workflows</a>
</h2>
<p>Whether you're at the REPL or in IJulia, you can typically improve your development experience with <a href="https://github.com/timholy/Revise.jl">Revise</a>. It is common to configure Revise to start whenever julia is started, as per the instructions in the <a href="https://timholy.github.io/Revise.jl/stable/">Revise documentation</a>. Once configured, Revise will track changes to files in any loaded modules, and to any files loaded in to the REPL with <code>includet</code> (but not with plain <code>include</code>); you can then edit the files and the changes take effect without restarting your julia session. A standard workflow is similar to the REPL-based workflow above, with the following modifications:</p>
<ol>
<li>
<p>Put your code in a module somewhere on your load path. There are several options for achieving this, of which two recommended choices are:</p>
<ul>
<li>
<p>For long-term projects, use <a href="https://github.com/invenia/PkgTemplates.jl">PkgTemplates</a>:</p>
<pre data-language="julia">using PkgTemplates
t = Template()
t("MyPkg")</pre>
<p>This will create a blank package, <code>"MyPkg"</code>, in your <code>.julia/dev</code> directory. Note that PkgTemplates allows you to control many different options through its <code>Template</code> constructor.</p>
<p>In step 2 below, edit <code>MyPkg/src/MyPkg.jl</code> to change the source code, and <code>MyPkg/test/runtests.jl</code> for the tests.</p>
</li>
<li>
<p>For "throw-away" projects, you can avoid any need for cleanup by doing your work in your temporary directory (e.g., <code>/tmp</code>).</p>
<p>Navigate to your temporary directory and launch Julia, then do the following:</p>
<pre data-language="julia">pkg&gt; generate MyPkg            # type ] to enter pkg mode
julia&gt; push!(LOAD_PATH, pwd())   # hit backspace to exit pkg mode</pre>
<p>If you restart your Julia session you'll have to re-issue that command modifying <code>LOAD_PATH</code>.</p>
<p>In step 2 below, edit <code>MyPkg/src/MyPkg.jl</code> to change the source code, and create any test file of your choosing.</p>
</li>
</ul>
</li>
<li>
<p>Develop your package</p>
<p><em>Before</em> loading any code, make sure you're running Revise: say <code>using Revise</code> or follow its documentation on configuring it to run automatically.</p>
<p>Then navigate to the directory containing your test file (here assumed to be <code>"runtests.jl"</code>) and do the following:</p>
<pre data-language="julia">julia&gt; using MyPkg

julia&gt; include("runtests.jl")</pre>
<p>You can iteratively modify the code in MyPkg in your editor and re-run the tests with <code>include("runtests.jl")</code>. You generally should not need to restart your Julia session to see the changes take effect (subject to a few <a href="https://timholy.github.io/Revise.jl/stable/limitations/">limitations</a>).</p>
</li>
</ol><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2023 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.10/manual/workflow-tips/" class="_attribution-link">https://docs.julialang.org/en/v1.10/manual/workflow-tips/</a>
  </p>
</div>
