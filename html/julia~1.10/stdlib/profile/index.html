<h1 id="lib-profiling">Profiling</h1>
<h2 id="CPU-Profiling">
<a class="docs-heading-anchor" href="#CPU-Profiling">CPU Profiling</a>
</h2>
<p>There are two main approaches to CPU profiling julia code:</p>
<h2 id="Via-@profile">
<a class="docs-heading-anchor" href="#Via-@profile">Via <code>@profile</code></a>
</h2>
<p>Where profiling is enabled for a given call via the <code>@profile</code> macro.</p>
<pre data-language="julia">julia&gt; using Profile

julia&gt; @profile foo()

julia&gt; Profile.print()
Overhead ╎ [+additional indent] Count File:Line; Function
=========================================================
    ╎147  @Base/client.jl:506; _start()
        ╎ 147  @Base/client.jl:318; exec_options(opts::Base.JLOptions)
...</pre>
<h2 id="Triggered-During-Execution">
<a class="docs-heading-anchor" href="#Triggered-During-Execution">Triggered During Execution</a>
</h2>
<p>Tasks that are already running can also be profiled for a fixed time period at any user-triggered time.</p>
<p>To trigger the profiling:</p>
<ul>
<li>MacOS &amp; FreeBSD (BSD-based platforms): Use <code>ctrl-t</code> or pass a <code>SIGINFO</code> signal to the julia process i.e. <code>% kill -INFO $julia_pid</code>
</li>
<li>Linux: Pass a <code>SIGUSR1</code> signal to the julia process i.e. <code>% kill -USR1 $julia_pid</code>
</li>
<li>Windows: Not currently supported.</li>
</ul>
<p>First, a single stack trace at the instant that the signal was thrown is shown, then a 1 second profile is collected, followed by the profile report at the next yield point, which may be at task completion for code without yield points e.g. tight loops.</p>
<p>Optionally set environment variable <code>JULIA_PROFILE_PEEK_HEAP_SNAPSHOT</code> to <code>1</code> to also automatically collect a <a href="#Heap-Snapshots">heap snapshot</a>.</p>
<pre data-language="julia">julia&gt; foo()
##== the user sends a trigger while foo is running ==##
load: 2.53  cmd: julia 88903 running 6.16u 0.97s

======================================================================================
Information request received. A stacktrace will print followed by a 1.0 second profile
======================================================================================

signal (29): Information request: 29
__psynch_cvwait at /usr/lib/system/libsystem_kernel.dylib (unknown line)
_pthread_cond_wait at /usr/lib/system/libsystem_pthread.dylib (unknown line)
...

======================================================================
Profile collected. A report will print if the Profile module is loaded
======================================================================

Overhead ╎ [+additional indent] Count File:Line; Function
=========================================================
Thread 1 Task 0x000000011687c010 Total snapshots: 572. Utilization: 100%
   ╎147 @Base/client.jl:506; _start()
       ╎ 147 @Base/client.jl:318; exec_options(opts::Base.JLOptions)
...

Thread 2 Task 0x0000000116960010 Total snapshots: 572. Utilization: 0%
   ╎572 @Base/task.jl:587; task_done_hook(t::Task)
      ╎ 572 @Base/task.jl:879; wait()
...</pre>
<h3 id="Customization">
<a class="docs-heading-anchor" href="#Customization">Customization</a>
</h3>
<p>The duration of the profiling can be adjusted via <a href="#Profile.set_peek_duration"><code>Profile.set_peek_duration</code></a></p>
<p>The profile report is broken down by thread and task. Pass a no-arg function to <code>Profile.peek_report[]</code> to override this. i.e. <code>Profile.peek_report[] = () -&gt; Profile.print()</code> to remove any grouping. This could also be overridden by an external profile data consumer.</p>
<h2 id="Reference">
<a class="docs-heading-anchor" href="#Reference">Reference</a>
</h2>
<h3 id="Profile.@profile">
<code>Profile.@profile</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">@profile</pre>
<p><code>@profile &lt;expression&gt;</code> runs your expression while taking periodic backtraces. These are appended to an internal buffer of backtraces.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L17-L22">source</a></section><p>The methods in <code>Profile</code> are not exported and need to be called e.g. as <code>Profile.print()</code>.</p>
<h3 id="Profile.clear">
<code>Profile.clear</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">clear()</pre>
<p>Clear any existing backtraces from the internal buffer.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L128-L132">source</a></section><h3 id="Profile.print">
<code>Profile.print</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">print([io::IO = stdout,] [data::Vector = fetch()], [lidict::Union{LineInfoDict, LineInfoFlatDict} = getdict(data)]; kwargs...)</pre>
<p>Prints profiling results to <code>io</code> (by default, <code>stdout</code>). If you do not supply a <code>data</code> vector, the internal buffer of accumulated backtraces will be used.</p>
<p>The keyword arguments can be any combination of:</p>
<ul>
<li><p><code>format</code> – Determines whether backtraces are printed with (default, <code>:tree</code>) or without (<code>:flat</code>) indentation indicating tree structure.</p></li>
<li><p><code>C</code> – If <code>true</code>, backtraces from C and Fortran code are shown (normally they are excluded).</p></li>
<li><p><code>combine</code> – If <code>true</code> (default), instruction pointers are merged that correspond to the same line of code.</p></li>
<li><p><code>maxdepth</code> – Limits the depth higher than <code>maxdepth</code> in the <code>:tree</code> format.</p></li>
<li><p><code>sortedby</code> – Controls the order in <code>:flat</code> format. <code>:filefuncline</code> (default) sorts by the source line, <code>:count</code> sorts in order of number of collected samples, and <code>:overhead</code> sorts by the number of samples incurred by each function by itself.</p></li>
<li><p><code>groupby</code> – Controls grouping over tasks and threads, or no grouping. Options are <code>:none</code> (default), <code>:thread</code>, <code>:task</code>, <code>[:thread, :task]</code>, or <code>[:task, :thread]</code> where the last two provide nested grouping.</p></li>
<li><p><code>noisefloor</code> – Limits frames that exceed the heuristic noise floor of the sample (only applies to format <code>:tree</code>). A suggested value to try for this is 2.0 (the default is 0). This parameter hides samples for which <code>n &lt;= noisefloor * √N</code>, where <code>n</code> is the number of samples on this line, and <code>N</code> is the number of samples for the callee.</p></li>
<li><p><code>mincount</code> – Limits the printout to only those lines with at least <code>mincount</code> occurrences.</p></li>
<li><p><code>recur</code> – Controls the recursion handling in <code>:tree</code> format. <code>:off</code> (default) prints the tree as normal. <code>:flat</code> instead compresses any recursion (by ip), showing the approximate effect of converting any self-recursion into an iterator. <code>:flatc</code> does the same but also includes collapsing of C frames (may do odd things around <code>jl_apply</code>).</p></li>
<li><p><code>threads::Union{Int,AbstractVector{Int}}</code> – Specify which threads to include snapshots from in the report. Note that this does not control which threads samples are collected on (which may also have been collected on another machine).</p></li>
<li><p><code>tasks::Union{Int,AbstractVector{Int}}</code> – Specify which tasks to include snapshots from in the report. Note that this does not control which tasks samples are collected within.</p></li>
</ul>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L164-L204">source</a></section><section><pre data-language="julia">print([io::IO = stdout,] data::Vector, lidict::LineInfoDict; kwargs...)</pre>
<p>Prints profiling results to <code>io</code>. This variant is used to examine results exported by a previous call to <a href="#Profile.retrieve"><code>retrieve</code></a>. Supply the vector <code>data</code> of backtraces and a dictionary <code>lidict</code> of line information.</p>
<p>See <code>Profile.print([io], data)</code> for an explanation of the valid keyword arguments.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L297-L305">source</a></section><h3 id="Profile.init">
<code>Profile.init</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">init(; n::Integer, delay::Real)</pre>
<p>Configure the <code>delay</code> between backtraces (measured in seconds), and the number <code>n</code> of instruction pointers that may be stored per thread. Each instruction pointer corresponds to a single line of code; backtraces generally consist of a long list of instruction pointers. Note that 6 spaces for instruction pointers per backtrace are used to store metadata and two NULL end markers. Current settings can be obtained by calling this function with no arguments, and each can be set independently using keywords or in the order <code>(n, delay)</code>.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L63-L71">source</a></section><h3 id="Profile.fetch">
<code>Profile.fetch</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">fetch(;include_meta = true) -&gt; data</pre>
<p>Return a copy of the buffer of profile backtraces. Note that the values in <code>data</code> have meaning only on this machine in the current session, because it depends on the exact memory addresses used in JIT-compiling. This function is primarily for internal use; <a href="#Profile.retrieve"><code>retrieve</code></a> may be a better choice for most users. By default metadata such as threadid and taskid is included. Set <code>include_meta</code> to <code>false</code> to strip metadata.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L586-L594">source</a></section><h3 id="Profile.retrieve">
<code>Profile.retrieve</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">retrieve(; kwargs...) -&gt; data, lidict</pre>
<p>"Exports" profiling results in a portable format, returning the set of all backtraces (<code>data</code>) and a dictionary that maps the (session-specific) instruction pointers in <code>data</code> to <code>LineInfo</code> values that store the file name, function name, and line number. This function allows you to save profiling results for future analysis.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L376-L383">source</a></section><h3 id="Profile.callers">
<code>Profile.callers</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">callers(funcname, [data, lidict], [filename=&lt;filename&gt;], [linerange=&lt;start:stop&gt;]) -&gt; Vector{Tuple{count, lineinfo}}</pre>
<p>Given a previous profiling run, determine who called a particular function. Supplying the filename (and optionally, range of line numbers over which the function is defined) allows you to disambiguate an overloaded method. The returned value is a vector containing a count of the number of calls and line information about the caller. One can optionally supply backtrace <code>data</code> obtained from <a href="#Profile.retrieve"><code>retrieve</code></a>; otherwise, the current internal profile buffer is used.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L506-L515">source</a></section><h3 id="Profile.clear_malloc_data">
<code>Profile.clear_malloc_data</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">clear_malloc_data()</pre>
<p>Clears any stored memory allocation data when running julia with <code>--track-allocation</code>. Execute the command(s) you want to test (to force JIT-compilation), then call <a href="#Profile.clear_malloc_data"><code>clear_malloc_data</code></a>. Then execute your command(s) again, quit Julia, and examine the resulting <code>*.mem</code> files.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L547-L554">source</a></section><h3 id="Profile.get_peek_duration">
<code>Profile.get_peek_duration</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">get_peek_duration()</pre>
<p>Get the duration in seconds of the profile "peek" that is triggered via <code>SIGINFO</code> or <code>SIGUSR1</code>, depending on platform.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L44-L48">source</a></section><h3 id="Profile.set_peek_duration">
<code>Profile.set_peek_duration</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">set_peek_duration(t::Float64)</pre>
<p>Set the duration in seconds of the profile "peek" that is triggered via <code>SIGINFO</code> or <code>SIGUSR1</code>, depending on platform.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L50-L54">source</a></section><h2 id="Memory-profiling">
<a class="docs-heading-anchor" href="#Memory-profiling">Memory profiling</a>
</h2>
<h3 id="Profile.Allocs.@profile">
<code>Profile.Allocs.@profile</code><span class="docstring-category">Macro</span>
</h3>
<section><pre data-language="julia">Profile.Allocs.@profile [sample_rate=0.1] expr</pre>
<p>Profile allocations that happen during <code>expr</code>, returning both the result and and AllocResults struct.</p>
<p>A sample rate of 1.0 will record everything; 0.0 will record nothing.</p>
<pre data-language="julia">julia&gt; Profile.Allocs.@profile sample_rate=0.01 peakflops()
1.03733270279065e11

julia&gt; results = Profile.Allocs.fetch()

julia&gt; last(sort(results.allocs, by=x-&gt;x.size))
Profile.Allocs.Alloc(Vector{Any}, Base.StackTraces.StackFrame[_new_array_ at array.c:127, ...], 5576)</pre>
<p>The best way to visualize these is currently with the <a href="https://github.com/JuliaPerf/PProf.jl">PProf.jl</a> package, by invoking <code>PProf.Allocs.pprof</code>.</p>
<div class="admonition is-info">

<div class="admonition-body">
<p>The current implementation of the Allocations Profiler does not capture types for all allocations. Allocations for which the profiler could not capture the type are represented as having type <code>Profile.Allocs.UnknownType</code>.</p>
<p>You can read more about the missing types and the plan to improve this, here: <a href="https://github.com/JuliaLang/julia/issues/43688">https://github.com/JuliaLang/julia/issues/43688</a>.</p>
</div>
</div>
<div class="admonition is-compat">

<div class="admonition-body"><p>The allocation profiler was added in Julia 1.8.</p></div>
</div>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Allocs.jl#L32-L65">source</a></section><p>The methods in <code>Profile.Allocs</code> are not exported and need to be called e.g. as <code>Profile.Allocs.fetch()</code>.</p>
<h3 id="Profile.Allocs.clear">
<code>Profile.Allocs.clear</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Profile.Allocs.clear()</pre>
<p>Clear all previously profiled allocation information from memory.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Allocs.jl#L103-L107">source</a></section><h3 id="Profile.Allocs.fetch">
<code>Profile.Allocs.fetch</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Profile.Allocs.fetch()</pre>
<p>Retrieve the recorded allocations, and decode them into Julia objects which can be analyzed.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Allocs.jl#L113-L118">source</a></section><h3 id="Profile.Allocs.start">
<code>Profile.Allocs.start</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Profile.Allocs.start(sample_rate::Real)</pre>
<p>Begin recording allocations with the given sample rate A sample rate of 1.0 will record everything; 0.0 will record nothing.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Allocs.jl#L84-L89">source</a></section><h3 id="Profile.Allocs.stop">
<code>Profile.Allocs.stop</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Profile.Allocs.stop()</pre>
<p>Stop recording allocations.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Allocs.jl#L94-L98">source</a></section><h2 id="Heap-Snapshots">
<a class="docs-heading-anchor" href="#Heap-Snapshots">Heap Snapshots</a>
</h2>
<h3 id="Profile.take_heap_snapshot">
<code>Profile.take_heap_snapshot</code><span class="docstring-category">Function</span>
</h3>
<section><pre data-language="julia">Profile.take_heap_snapshot(io::IOStream, all_one::Bool=false)
Profile.take_heap_snapshot(filepath::String, all_one::Bool=false)
Profile.take_heap_snapshot(all_one::Bool=false; dir::String)</pre>
<p>Write a snapshot of the heap, in the JSON format expected by the Chrome Devtools Heap Snapshot viewer (.heapsnapshot extension) to a file (<code>$pid_$timestamp.heapsnapshot</code>) in the current directory by default (or tempdir if the current directory is unwritable), or in <code>dir</code> if given, or the given full file path, or IO stream.</p>
<p>If <code>all_one</code> is true, then report the size of every object as one so they can be easily counted. Otherwise, report the actual size.</p>
<a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/3120989f39bb7ef7863c4aab8ab1227cf71eec66/usr/share/julia/stdlib/v1.10/Profile/src/Profile.jl#L1215-L1228">source</a></section><p>The methods in <code>Profile</code> are not exported and need to be called e.g. as <code>Profile.take_heap_snapshot()</code>.</p>
<pre data-language="julia">julia&gt; using Profile

julia&gt; Profile.take_heap_snapshot("snapshot.heapsnapshot")</pre>
<p>Traces and records julia objects on the heap. This only records objects known to the Julia garbage collector. Memory allocated by external libraries not managed by the garbage collector will not show up in the snapshot.</p>
<p>The resulting heap snapshot file can be uploaded to chrome devtools to be viewed. For more information, see the <a href="https://developer.chrome.com/docs/devtools/memory-problems/heap-snapshots/#view_snapshots">chrome devtools docs</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2009&ndash;2023 Jeff Bezanson, Stefan Karpinski, Viral B. Shah, and other contributors<br>Licensed under the MIT License.<br>
    <a href="https://docs.julialang.org/en/v1.10/stdlib/Profile/" class="_attribution-link">https://docs.julialang.org/en/v1.10/stdlib/Profile/</a>
  </p>
</div>
