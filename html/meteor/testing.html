<h1 class="title-page">Testing</h1> <div class="subtitle-page">How to test your Meteor application</div>    <h2 id="introduction">Introduction</h2> <p>Testing allows you to ensure your application works the way you think it does, especially as your codebase changes over time. If you have good tests, you can refactor and rewrite code with confidence. Tests are also the most concrete form of documentation of expected behavior, since other developers can figure out how to use your code by reading the tests.</p> <p>Automated testing is critical because it allows you to run a far greater set of tests much more often than you could manually, allowing you to catch regression errors immediately.</p> <h3 id="testing-types">Types of tests</h3> <p>Entire books have been written on the subject of testing, so we will simply touch on some basics of testing here. The important thing to consider when writing a test is what part of the application you are trying to test, and how you are verifying the behavior works.</p> <ul> <li>
<p><strong>Unit test</strong>: If you are testing one small module of your application, you are writing a unit test. You’ll need to <em>stub</em> and <em>mock</em> other modules that your module usually leverages in order to <em>isolate</em> each test. You’ll typically also need to <em>spy</em> on actions that the module takes to verify that they occur.</p> </li> <li>
<p><strong>Integration test</strong>: If you are testing that multiple modules behave properly in concert, you are writing an integration test. Such tests are much more complex and may require running code both on the client and on the server to verify that communication across that divide is working as expected. Typically an integration test will still isolate a part of the entire application and directly verify results in code.</p> </li> <li>
<p><strong>Acceptance test</strong>: If you want to write a test that can be run against any running version of your app and verifies at the browser level that the right things happen when you push the right buttons, then you are writing an acceptance test (sometimes called “end to end test”). Such tests typically try to hook into the application as little as possible, beyond perhaps setting up the right data to run a test against.</p> </li> <li>
<p><strong>Load test</strong>: Finally you may wish to test that your application works under typical load or see how much load it can handle before it falls over. This is called a load test or stress test. Such tests can be challenging to set up and typically aren’t run often but are very important for confidence before a big production launch.</p> </li> </ul> <h3 id="challenges-with-meteor">Challenges of testing in Meteor</h3> <p>In most ways, testing a Meteor app is no different from testing any other full stack JavaScript application. However, compared to more traditional backend or front-end focused frameworks, two factors can make testing a little more challenging:</p> <ul> <li>
<p><strong>Client/server data</strong>: Meteor’s data system makes it simple to bridge the client-server gap and often allows you to build your application without thinking about how data moves around. It becomes critical to test that your code does actually work correctly across that gap. In traditional frameworks where you spend a lot of time thinking about interfaces between client and server you can often get away with testing both sides of the interface in isolation, but Meteor’s <a href="#test-modes">full app test mode</a> makes it easy to write <a href="#full-app-integration-test">integration tests</a> that cover the full stack. Another challenge here is creating test data in the client context; we’ll discuss ways to do this in the <a href="#generating-test-data">section on generating test data</a> below.</p> </li> <li>
<p><strong>Reactivity</strong>: Meteor’s reactivity system is “eventually consistent” in the sense that when you change a reactive input to the system, you’ll see the user interface change to reflect this some time later. This can be a challenge when testing, but there are some ways to wait until those changes happen to verify the results, for example <code>Tracker.afterFlush()</code>.</p> </li> </ul> <h2 id="test-modes">The ‘meteor test’ command</h2> <p>The primary way to test your application in Meteor is the <code>meteor test</code> command.</p> <p>This loads your application in a special “test mode”. What this does is:</p> <ol> <li>
<em>Doesn’t</em> eagerly load <em>any</em> of our application code as Meteor normally would.</li> <li>
<em>Does</em> eagerly load any file in our application (including in <code>imports/</code> folders) that look like <code>*.test[s].*</code>, or <code>*.spec[s].*</code>
</li> <li>Sets the <code>Meteor.isTest</code> flag to be true.</li> <li>Starts up the test driver package (<a href="#driver-packages">see below</a>).</li> </ol> <blockquote> <p>The <a href="build-tool.html#what-it-does">Meteor build tool</a> and the <code>meteor test</code> command ignore any files located in any <code>tests/</code> directory. This allows you to put tests in this directory that you can run using a test runner outside of Meteor’s built-in test tools and still not have those files loaded in your application. See Meteor’s <a href="structure.html#load-order">default file load order</a> rules.</p> </blockquote> <p>What this means is that you can write tests in files with a certain filename pattern and know they’ll not be included in normal builds of your app. When your app runs in test mode, those files will be loaded (and nothing else will), and they can import the modules you want to test. As we’ll see this is ideal for <a href="#unit-testing">unit tests</a> and <a href="#simple-integration-test">simple integration tests</a>.</p> <p>Additionally, Meteor offers a “full application” test mode. You can run this with <code>meteor test --full-app</code>.</p> <p>This is similar to test mode, with key differences:</p> <ol> <li>It loads test files matching <code>*.app-test[s].*</code> and <code>*.app-spec[s].*</code>.</li> <li>It <strong>does</strong> eagerly load our application code as Meteor normally would.</li> <li>Sets the <code>Meteor.isAppTest</code> flag to be true (instead of the <code>Meteor.isTest</code> flag).</li> </ol> <p>This means that the entirety of your application (including for instance the web server and client side router) is loaded and will run as normal. This enables you to write much more <a href="#full-app-integration-test">complex integration tests</a> and also load additional files for <a href="#acceptance-testing">acceptance tests</a>.</p> <p>Note that there is another test command in the Meteor tool; <code>meteor test-packages</code> is a way of testing Atmosphere packages, which is discussed in the <a href="https://guide.meteor.com/writing-packages.html#testing">Writing Packages article</a>.</p> <h3 id="driver-packages">Driver packages</h3> <p>When you run a <code>meteor test</code> command, you must provide a <code>--driver-package</code> argument. A test driver is a mini-application that runs in place of your app and runs each of your defined tests, whilst reporting the results in some kind of user interface.</p> <p>There are two main kinds of test driver packages:</p> <ul> <li>
<strong>Web reporters</strong>: Meteor applications that display a special test reporting web UI that you can view the test results in.</li> </ul> <p><img src="https://guide.meteor.com/images/mocha-test-results.png"></p> <ul> <li>
<strong>Console reporters</strong>: These run completely on the command-line and are primary used for automated testing like <a href="#ci">continuous integration</a>.</li> </ul> <h3 id="mocha">Recommended: Mocha</h3> <p>In this article, we’ll use the popular <a href="https://mochajs.org" target="_blank" rel="external">Mocha</a> test runner alongside the <a href="http://chaijs.com" target="_blank" rel="external">Chai</a> assertion library to test our application. In order to write and run tests in Mocha, we need to add an appropriate test driver package.</p> <p>There are several options. Choose the ones that makes sense for your app. You may depend on more than one and set up different test commands for different situations.</p> <ul> <li>
<a href="https://atmospherejs.com/practicalmeteor/mocha" target="_blank" rel="external">practicalmeteor:mocha</a> Runs client and server package or app tests and displays all results in a browser. Use <a href="https://www.npmjs.com/package/spacejam" target="_blank" rel="external">spacejam</a> for command line / CI support.</li> <li>
<a href="https://atmospherejs.com/meteortesting/mocha" target="_blank" rel="external">meteortesting:mocha</a> Runs client and/or server package or app tests and reports all results in the server console. Supports various browsers for running client tests, including PhantomJS, Selenium ChromeDriver, and Electron. Can be used for running tests on a CI server. Has a watch mode.</li> </ul> <p>These packages don’t do anything in development or production mode. They declare themselves <code>testOnly</code> so they are not even loaded outside of testing. But when our app is run in <a href="#test-modes">test mode</a>, the test driver package takes over, executing test code on both the client and server, and rendering results to the browser.</p> <p>Here’s how we can add the <a href="https://atmospherejs.com/practicalmeteor/mocha" target="_blank" rel="external"><code>practicalmeteor:mocha</code></a> package to our app:</p> <pre class="highlight bash" data-language="bash">meteor add practicalmeteor:mocha</pre> <h2 id="test-files">Test Files</h2> <p>Test files themselves (for example a file named <code>todos-item.test.js</code> or <code>routing.app-specs.coffee</code>) can register themselves to be run by the test driver in the usual way for that testing library. For Mocha, that’s by using <code>describe</code> and <code>it</code>:</p> <pre class="highlight js" data-language="js">describe('my module', function () {
  it('does something that should be tested', function () {
    // This code will be executed by the test driver when the app is started

    // in the correct mode

  })
})</pre> <p>Note that arrow function use with Mocha <a href="http://mochajs.org/#arrow-functions" target="_blank" rel="external">is discouraged</a>.</p> <h2 id="test-data">Test data</h2> <p>When your app is run in test mode, it is initialized with a clean test database.</p> <p>If you are running a test that relies on using the database, and specifically the content of the database, you’ll need to perform some <em>setup</em> steps in your test to ensure the database is in the state you expect. There are some tools you can use to do this.</p> <p>To ensure the database is clean, the <a href="https://atmospherejs.com/xolvio/cleaner" target="_blank" rel="external"><code>xolvio:cleaner</code></a> package is useful. You can use it to reset the database in a <code>beforeEach</code> block:</p> <pre class="highlight js" data-language="js">
import { resetDatabase } from 'meteor/xolvio:cleaner';

describe('my module', function () {
  beforeEach(function () {
    resetDatabase();
  });
});</pre> <p>This technique will only work on the server. If you need to reset the database from a client test, you can use a method to do so:</p> <pre class="highlight js" data-language="js">
import { resetDatabase } from 'meteor/xolvio:cleaner';

// NOTE: Before writing a method like this you'll want to double check
// that this file is only going to be loaded in test mode!!
Meteor.methods({
  'test.resetDatabase': () =&gt; resetDatabase(),
});

describe('my module', function (done) {
  beforeEach(function (done) {
    // We need to wait until the method call is done before moving on, so we

    // use Mocha's async mechanism (calling a done callback)

    Meteor.call('test.resetDatabase', done);
  });
});</pre> <p>As we’ve placed the code above in a test file, it <em>will not</em> load in normal development or production mode (which would be an incredibly bad thing!). If you create a Atmosphere package with a similar feature, you should mark it as <code>testOnly</code> and it will similarly only load in test mode.</p> <h3 id="generating-test-data">Generating test data</h3> <p>Often it’s sensible to create a set of data to run your test against. You can use standard <code>insert()</code> calls against your collections to do this, but often it’s easier to create <em>factories</em> which help encode random test data. A great package to use to do this is <a href="https://atmospherejs.com/dburles/factory" target="_blank" rel="external"><code>dburles:factory</code></a>.</p> <p>In the <a href="https://github.com/meteor/todos" target="_blank" rel="external">Todos</a> example app, we define a factory to describe how to create a test todo item, using the <a href="https://www.npmjs.com/package/faker" target="_blank" rel="external"><code>faker</code></a> npm package:</p> <pre class="highlight js" data-language="js">
import faker from 'faker';

Factory.define('todo', Todos, {
  listId: () =&gt; Factory.get('list'),
  text: () =&gt; faker.lorem.sentence(),
  createdAt: () =&gt; new Date(),
});</pre> <p>To use the factory in a test, we simply call <code>Factory.create</code>:</p> <pre class="highlight js" data-language="js">// This creates a todo and a list in the database and returns the todo.

const todo = Factory.create('todo');

// If we have a list already, we can pass in the id and avoid creating another:

const list = Factory.create('list');

const todoInList = Factory.create('todo', { listId: list._id });</pre> <h3 id="mocking-the-database">Mocking the database</h3> <p>As <code>Factory.create</code> directly inserts documents into the collection that’s passed into the <code>Factory.define</code> function, it can be a problem to use it on the client. However there’s a neat isolation trick that you can do to replace the server-backed <code>Todos</code> <a href="collections.html#client-collections">client collection</a> with a mocked out <a href="#collections.html#local-collections">local collection</a>, that’s encoded in the <a href="https://atmospherejs.com/hwillson/stub-collections" target="_blank" rel="external"><code>hwillson:stub-collections</code></a> package.</p> <pre class="highlight js" data-language="js">
import StubCollections from 'meteor/hwillson:stub-collections';

import { Todos } from 'path/to/todos.js';

StubCollections.stub(Todos);

// Now Todos is stubbed to a simple local collection mock,
//   so for instance on the client we can do:
Todos.insert({ a: 'document' });

// Restore the `Todos` collection
StubCollections.restore();</pre> <p>In a Mocha test, it makes sense to use <code>stub-collections</code> in a <code>beforeEach</code>/<code>afterEach</code> block.</p> <h2 id="unit-testing">Unit testing</h2> <p>Unit testing is the process of isolating a section of code and then testing that the internals of that section work as you expect. As <a href="structure.html">we’ve split our code base up into ES2015 modules</a> it’s natural to test those modules one at a time.</p> <p>By isolating a module and simply testing its internal functionality, we can write tests that are <em>fast</em> and <em>accurate</em>—they can quickly tell you where a problem in your application lies. Note however that incomplete unit tests can often hide bugs because of the way they stub out dependencies. For that reason it’s useful to combine unit tests with slower (and perhaps less commonly run) integration and acceptance tests.</p> <h3 id="simple-blaze-unit-test">A simple Blaze unit test</h3> <p>In the <a href="https://github.com/meteor/todos" target="_blank" rel="external">Todos</a> example app, thanks to the fact that we’ve split our User Interface into <a href="ui-ux.html#components">smart and reusable components</a>, it’s natural to want to unit test some of our reusable components (we’ll see below how to <a href="#simple-integration-test">integration test</a> our smart components).</p> <p>To do so, we’ll use a very simple test helper that renders a Blaze component off-screen with a given data context. As we place it in <code>imports</code>, it won’t load in our app by in normal mode (as it’s not required anywhere).</p> <p><a href="https://github.com/meteor/todos/blob/master/imports/ui/test-helpers.js" target="_blank" rel="external"><code>imports/ui/test-helpers.js</code></a>:</p> <pre class="highlight js" data-language="js">
import { _ } from 'meteor/underscore';

import { Template } from 'meteor/templating';

import { Blaze } from 'meteor/blaze';

import { Tracker } from 'meteor/tracker';


const withDiv = function withDiv(callback) {
  const el = document.createElement('div');
  document.body.appendChild(el);
  try {
    callback(el);
  } finally {
    document.body.removeChild(el);
  }
};


export const withRenderedTemplate = function withRenderedTemplate(template, data, callback) {
  withDiv((el) =&gt; {
    const ourTemplate = _.isString(template) ? Template[template] : template;
    Blaze.renderWithData(ourTemplate, data, el);
    Tracker.flush();
    callback(el);
  });
};</pre> <p>A simple example of a reusable component to test is the <a href="https://github.com/meteor/todos/blob/master/imports/ui/components/todos-item.html" target="_blank" rel="external"><code>Todos_item</code></a> template. Here’s what a unit test looks like (you can see some <a href="https://github.com/meteor/todos/blob/master/imports/ui/components/client" target="_blank" rel="external">others in the app repository</a>).</p> <p><a href="https://github.com/meteor/todos/blob/master/imports/ui/components/client/todos-item.tests.js" target="_blank" rel="external"><code>imports/ui/components/client/todos-item.tests.js</code></a>:</p> <pre class="highlight js" data-language="js">/* eslint-env mocha */
/* eslint-disable func-names, prefer-arrow-callback */


import { Factory } from 'meteor/dburles:factory';

import { chai } from 'meteor/practicalmeteor:chai';

import { Template } from 'meteor/templating';

import { $ } from 'meteor/jquery';

import { Todos } from '../../../api/todos/todos';



import { withRenderedTemplate } from '../../test-helpers.js';

import '../todos-item.js';

describe('Todos_item', function () {
  beforeEach(function () {
    Template.registerHelper('_', key =&gt; key);
  });

  afterEach(function () {
    Template.deregisterHelper('_');
  });

  it('renders correctly with simple data', function () {
    const todo = Factory.build('todo', { checked: false });
    const data = {
      todo: Todos._transform(todo),
      onEditingChange: () =&gt; 0,
    };

    withRenderedTemplate('Todos_item', data, el =&gt; {
      chai.assert.equal($(el).find('input[type=text]').val(), todo.text);
      chai.assert.equal($(el).find('.list-item.checked').length, 0);
      chai.assert.equal($(el).find('.list-item.editing').length, 0);
    });
  });
});</pre> <p>Of particular interest in this test is the following:</p> <h4 id="unit-test-importing">Importing</h4> <p>When we run our app in test mode, only our test files will be eagerly loaded. In particular, this means that in order to use our templates, we need to import them! In this test, we import <code>todos-item.js</code>, which itself imports <code>todos.html</code> (yes, you do need to import the HTML files of your Blaze templates!)</p> <h4 id="unit-test-stubbing">Stubbing</h4> <p>To be a unit test, we must stub out the dependencies of the module. In this case, thanks to the way we’ve isolated our code into a reusable component, there’s not much to do; principally we need to stub out the <code>{{_}}</code> helper that’s created by the <a href="ui-ux.html#i18n"><code>tap:i18n</code></a> system. Note that we stub it out in a <code>beforeEach</code> and restore it the <code>afterEach</code>.</p> <p>If you’re testing code that makes use of globals, you’ll need to import those globals. For instance if you have a global <code>Todos</code> collection and are testing this file:</p> <pre class="highlight js" data-language="js">// logging.js

export function logTodos() {
  console.log(Todos.findOne());
}</pre> <p>then you’ll need to import <code>Todos</code> both in that file and in the test:</p> <pre class="highlight js" data-language="js">// logging.js

import { Todos } from './todos.js'


export function logTodos() {
  console.log(Todos.findOne());
}</pre> <pre class="highlight js" data-language="js">// logging.test.js

import { Todos } from './todos.js'

Todos.findOne = () =&gt; {
  return {text: "write a guide"}
}


import { logTodos } from './logging.js'

// then test logTodos
...</pre> <h4 id="unit-test-data">Creating data</h4> <p>We can use the <a href="#test-data">Factory package’s</a> <code>.build()</code> API to create a test document without inserting it into any collection. As we’ve been careful not to call out to any collections directly in the reusable component, we can pass the built <code>todo</code> document directly into the template.</p> <h3 id="simple-react-unit-test">A simple React unit test</h3> <p>We can also apply the same structure to testing React components and recommend the <a href="https://github.com/airbnb/enzyme" target="_blank" rel="external">Enzyme</a> package, which simulates a React component’s environment and allows you to query it using CSS selectors. A larger suite of tests is available in the <a href="https://github.com/meteor/todos/tree/react" target="_blank" rel="external">react branch of the Todos app</a>, but let’s look at a simple example for now:</p> <pre class="highlight js" data-language="js">
import { Factory } from 'meteor/dburles:factory';

import React from 'react';

import { shallow } from 'enzyme';

import { chai } from 'meteor/practicalmeteor:chai';

import TodoItem from './TodoItem.jsx';

describe('TodoItem', () =&gt; {
  it('should render', () =&gt; {
    const todo = Factory.build('todo', { text: 'testing', checked: false });
    const item = shallow(&lt;TodoItem todo={todo} /&gt;);

    chai.assert(item.hasClass('list-item'));
    chai.assert(!item.hasClass('checked'));
    chai.assert.equal(item.find('.editing').length, 0);
    chai.assert.equal(item.find('input[type="text"]').prop('defaultValue'), 'testing');
  });
});</pre> <p>The test is slightly simpler than the Blaze version above because the React sample app is not internationalized. Otherwise, it’s conceptually identical. We use Enzyme’s <code>shallow</code> function to render the <code>TodoItem</code> component, and the resulting object to query the document, and also to simulate user interactions. And here’s an example of simulating a user checking the todo item:</p> <pre class="highlight js" data-language="js">
import { Factory } from 'meteor/dburles:factory';

import React from 'react';

import { shallow } from 'enzyme';

import { sinon } from 'meteor/practicalmeteor:sinon';

import TodoItem from './TodoItem.jsx';

import { setCheckedStatus } from '../../api/todos/methods.js';

describe('TodoItem', () =&gt; {
  it('should update status when checked', () =&gt; {
    sinon.stub(setCheckedStatus, 'call');
    const todo = Factory.create('todo', { checked: false });
    const item = shallow(&lt;TodoItem todo={todo} /&gt;);


    item.find('input[type="checkbox"]').simulate('change', {
      target: { checked: true },
    });

    sinon.assert.calledWith(setCheckedStatus.call, {
      todoId: todo._id,
      newCheckedStatus: true,
    });

    setCheckedStatus.call.restore();
  });
});</pre> <p>In this case, the <code>TodoItem</code> component calls a <a href="methods.html">Meteor Method</a> <code>setCheckedStatus</code> when the user clicks, but this is a unit test so there’s no server running. So we stub it out using <a href="http://sinonjs.org" target="_blank" rel="external">Sinon</a>. After we simulate the click, we verify that the stub was called with the correct arguments. Finally, we clean up the stub and restore the original method behavior.</p> <h3 id="running-unit-tests">Running unit tests</h3> <p>To run the tests that our app defines, we run our app in <a href="#test-modes">test mode</a>:</p> <pre class="highlight plain" data-language="plain">meteor test --driver-package practicalmeteor:mocha</pre> <p>As we’ve defined a test file (<code>imports/todos/todos.tests.js</code>), what this means is that the file above will be eagerly loaded, adding the <code>'builds correctly from factory'</code> test to the Mocha registry.</p> <p>To run the tests, visit <a href="http://localhost:3000" target="_blank" rel="external">http://localhost:3000</a> in your browser. This kicks off <code>practicalmeteor:mocha</code>, which runs your tests both in the browser and on the server. It displays the test results in the browser in a Mocha test reporter:</p> <p><img src="https://guide.meteor.com/images/mocha-test-results.png"></p> <p>Usually, while developing an application, it makes sense to run <code>meteor test</code> on a second port (say <code>3100</code>), while also running your main application in a separate process:</p> <pre class="highlight bash" data-language="bash"># in one terminal window
meteor

# in another
meteor test --driver-package practicalmeteor:mocha --port 3100</pre> <p>Then you can open two browser windows to see the app in action while also ensuring that you don’t break any tests as you make changes.</p> <h3 id="isolation-techniques">Isolation techniques</h3> <p>In the <a href="#simple-blaze-unit-test">unit tests above</a> we saw a very limited example of how to isolate a module from the larger app. This is critical for proper unit testing. Some other utilities and techniques include:</p> <ul> <li>
<p>The <a href="https://atmospherejs.com/velocity/meteor-stubs" target="_blank" rel="external"><code>velocity:meteor-stubs</code></a> package, which creates simple stubs for most Meteor core objects.</p> </li> <li>
<p>Alternatively, you can also use tools like <a href="http://sinonjs.org" target="_blank" rel="external">Sinon</a> to stub things directly, as we’ll see for example in our <a href="#simple-integration-test">simple integration test</a>.</p> </li> <li>
<p>The <a href="https://atmospherejs.com/hwillson/stub-collections" target="_blank" rel="external"><code>hwillson:stub-collections</code></a> package we mentioned <a href="#mocking-the-database">above</a>.</p> </li> </ul> <p>There’s a lot of scope for better isolation and testing utilities.</p> <h4 id="testing-publications">Testing publications</h4> <p>Using the <a href="https://atmospherejs.com/johanbrook/publication-collector" target="_blank" rel="external"><code>johanbrook:publication-collector</code></a> package, you’re able to test individual publication’s output without needing to create a traditional subscription:</p> <pre class="highlight js" data-language="js">describe('lists.public', function () {
  it('sends all public lists', function (done) {
    // Set a user id that will be provided to the publish function as `this.userId`,

    // in case you want to test authentication.

    const collector = new PublicationCollector({userId: 'some-id'});

    // Collect the data published from the `lists.public` publication.

    collector.collect('lists.public', (collections) =&gt; {
      // `collections` is a dictionary with collection names as keys,

      // and their published documents as values in an array.

      // Here, documents from the collection 'Lists' are published.

      chai.assert.typeOf(collections.Lists, 'array');
      chai.assert.equal(collections.Lists.length, 3);
      done();
    });
  });
});</pre> <p>Note that user documents – ones that you would normally query with <code>Meteor.users.find()</code> – will be available as the key <code>users</code> on the dictionary passed from a <code>PublicationCollector.collect()</code> call. See the <a href="https://github.com/johanbrook/meteor-publication-collector/blob/master/tests/publication-collector.test.js" target="_blank" rel="external">tests</a> in the package for more details.</p> <h2 id="integration-testing">Integration testing</h2> <p>An integration test is a test that crosses module boundaries. In the simplest case, this simply means something very similar to a unit test, where you perform your isolation around multiple modules, creating a non-singular “system under test”.</p> <p>Although conceptually different to unit tests, such tests typically do not need to be run any differently to unit tests and can use the same <a href="#running-unit-tests"><code>meteor test</code> mode</a> and <a href="#isolation-techniques">isolation techniques</a> as we use for unit tests.</p> <p>However, an integration test that crosses the client-server boundary of a Meteor application (where the modules under test cross that boundary) requires a different testing infrastructure, namely Meteor’s “full app” testing mode.</p> <p>Let’s take a look at example of both kinds of tests.</p> <h3 id="simple-integration-test">Simple integration test</h3> <p>Our reusable components were a natural fit for a unit test; similarly our smart components tend to require an integration test to really be exercised properly, as the job of a smart component is to bring data together and supply it to a reusable component.</p> <p>In the <a href="https://github.com/meteor/todos" target="_blank" rel="external">Todos</a> example app, we have an integration test for the <code>Lists_show_page</code> smart component. This test simply ensures that when the correct data is present in the database, the template renders correctly – that it is gathering the correct data as we expect. It isolates the rendering tree from the more complex data subscription part of the Meteor stack. If we wanted to test that the subscription side of things was working in concert with the smart component, we’d need to write a <a href="#full-app-integration-test">full app integration test</a>.</p> <p><a href="https://github.com/meteor/todos/blob/master/imports/ui/components/client/todos-item.tests.js" target="_blank" rel="external"><code>imports/ui/components/client/todos-item.tests.js</code></a>:</p> <pre class="highlight js" data-language="js">/* eslint-env mocha */
/* eslint-disable func-names, prefer-arrow-callback */


import { Meteor } from 'meteor/meteor';

import { Factory } from 'meteor/dburles:factory';

import { Random } from 'meteor/random';

import { chai } from 'meteor/practicalmeteor:chai';

import StubCollections from 'meteor/hwillson:stub-collections';

import { Template } from 'meteor/templating';

import { _ } from 'meteor/underscore';

import { $ } from 'meteor/jquery';

import { FlowRouter } from 'meteor/kadira:flow-router';

import { sinon } from 'meteor/practicalmeteor:sinon';



import { withRenderedTemplate } from '../../test-helpers.js';

import '../lists-show-page.js';


import { Todos } from '../../../api/todos/todos.js';

import { Lists } from '../../../api/lists/lists.js';

describe('Lists_show_page', function () {
  const listId = Random.id();

  beforeEach(function () {
    StubCollections.stub([Todos, Lists]);
    Template.registerHelper('_', key =&gt; key);
    sinon.stub(FlowRouter, 'getParam', () =&gt; listId);
    sinon.stub(Meteor, 'subscribe', () =&gt; ({
      subscriptionId: 0,
      ready: () =&gt; true,
    }));
  });

  afterEach(function () {
    StubCollections.restore();
    Template.deregisterHelper('_');
    FlowRouter.getParam.restore();
    Meteor.subscribe.restore();
  });

  it('renders correctly with simple data', function () {
    Factory.create('list', { _id: listId });
    const timestamp = new Date();
    const todos = _.times(3, i =&gt; Factory.create('todo', {
      listId,
      createdAt: new Date(timestamp - (3 - i)),
    }));

    withRenderedTemplate('Lists_show_page', {}, el =&gt; {
      const todosText = todos.map(t =&gt; t.text).reverse();
      const renderedText = $(el).find('.list-items input[type=text]')
        .map((i, e) =&gt; $(e).val())
        .toArray();
      chai.assert.deepEqual(renderedText, todosText);
    });
  });
});</pre> <p>Of particular interest in this test is the following:</p> <h4 id="simple-integration-test-importing">Importing</h4> <p>As we’ll run this test in the same way that we did our unit test, we need to <code>import</code> the relevant modules under test in the same way that we <a href="#simple-integration-test-importing">did in the unit test</a>.</p> <h4 id="simple-integration-test-stubbing">Stubbing</h4> <p>As the system under test in our integration test has a larger surface area, we need to stub out a few more points of integration with the rest of the stack. Of particular interest here is our use of the <a href="#mocking-the-database"><code>hwillson:stub-collections</code></a> package and of <a href="http://sinonjs.org" target="_blank" rel="external">Sinon</a> to stub out Flow Router and our Subscription.</p> <h4 id="simple-integration-test-data">Creating data</h4> <p>In this test, we used <a href="#test-data">Factory package’s</a> <code>.create()</code> API, which inserts data into the real collection. However, as we’ve proxied all of the <code>Todos</code> and <code>Lists</code> collection methods onto a local collection (this is what <code>hwillson:stub-collections</code> is doing), we won’t run into any problems with trying to perform inserts from the client.</p> <p>This integration test can be run the exact same way as we ran <a href="#running-unit-tests">unit tests above</a>.</p> <h3 id="full-app-integration-test">Full-app integration test</h3> <p>In the <a href="https://github.com/meteor/todos" target="_blank" rel="external">Todos</a> example application, we have a integration test which ensures that we see the full contents of a list when we route to it, which demonstrates a few techniques of integration tests.</p> <p><a href="https://github.com/meteor/todos/blob/master/imports/startup/client/routes.app-test.js" target="_blank" rel="external"><code>imports/startup/client/routes.app-test.js</code></a>:</p> <pre class="highlight js" data-language="js">/* eslint-env mocha */
/* eslint-disable func-names, prefer-arrow-callback */


import { Meteor } from 'meteor/meteor';

import { Tracker } from 'meteor/tracker';

import { DDP } from 'meteor/ddp-client';

import { FlowRouter } from 'meteor/kadira:flow-router';

import { assert } from 'meteor/practicalmeteor:chai';

import { Promise } from 'meteor/promise';

import { $ } from 'meteor/jquery';


import { denodeify } from '../../utils/denodeify';

import { generateData } from './../../api/generate-data.app-tests.js';

import { Lists } from '../../api/lists/lists.js';

import { Todos } from '../../api/todos/todos.js';


// Utility -- returns a promise which resolves when all subscriptions are done

const waitForSubscriptions = () =&gt; new Promise(resolve =&gt; {
  const poll = Meteor.setInterval(() =&gt; {
    if (DDP._allSubscriptionsReady()) {
      Meteor.clearInterval(poll);
      resolve();
    }
  }, 200);
});

// Tracker.afterFlush runs code when all consequent of a tracker based change
//   (such as a route change) have occured. This makes it a promise.

const afterFlushPromise = denodeify(Tracker.afterFlush);


if (Meteor.isClient) {
  describe('data available when routed', () =&gt; {
    // First, ensure the data that we expect is loaded on the server

    //   Then, route the app to the homepage

    beforeEach(() =&gt; generateData()
      .then(() =&gt; FlowRouter.go('/'))
      .then(waitForSubscriptions)
    );

    describe('when logged out', () =&gt; {
      it('has all public lists at homepage', () =&gt; {
        assert.equal(Lists.find().count(), 3);
      });

      it('renders the correct list when routed to', () =&gt; {
        const list = Lists.findOne();
        FlowRouter.go('Lists.show', { _id: list._id });

        return afterFlushPromise()
          .then(waitForSubscriptions)
          .then(() =&gt; {
            assert.equal($('.title-wrapper').html(), list.name);
            assert.equal(Todos.find({ listId: list._id }).count(), 3);
          });
      });
    });
  });
}</pre> <p>Of note here:</p> <ul> <li>
<p>Before running, each test sets up the data it needs using the <code>generateData</code> helper (see <a href="#creating-integration-test-data">the section on creating integration test data</a> for more detail) then goes to the homepage.</p> </li> <li>
<p>Although Flow Router doesn’t take a done callback, we can use <code>Tracker.afterFlush</code> to wait for all its reactive consequences to occur.</p> </li> <li>
<p>Here we wrote a little utility (which could be abstracted into a general package) to wait for all the subscriptions which are created by the route change (the <code>todos.inList</code> subscription in this case) to become ready before checking their data.</p> </li> </ul> <h3 id="running-full-app-tests">Running full-app tests</h3> <p>To run the <a href="#test-modes">full-app tests</a> in our application, we run:</p> <pre class="highlight plain" data-language="plain">meteor test --full-app --driver-package practicalmeteor:mocha</pre> <p>When we connect to the test instance in a browser, we want to render a testing UI rather than our app UI, so the <code>mocha-web-reporter</code> package will hide any UI of our application and overlay it with its own. However the app continues to behave as normal, so we are able to route around and check the correct data is loaded.</p> <h3 id="creating-integration-test-data">Creating data</h3> <p>To create test data in full-app test mode, it usually makes sense to create some special test methods which we can call from the client side. Usually when testing a full app, we want to make sure the publications are sending through the correct data (as we do in this test), and so it’s not sufficient to stub out the collections and place synthetic data in them. Instead we’ll want to actually create data on the server and let it be published.</p> <p>Similar to the way we cleared the database using a method in the <code>beforeEach</code> in the <a href="#test-data">test data</a> section above, we can call a method to do that before running our tests. In the case of our routing tests, we’ve used a file called <a href="https://github.com/meteor/todos/blob/master/imports/api/generate-data.app-tests.js" target="_blank" rel="external"><code>imports/api/generate-data.app-tests.js</code></a> which defines this method (and will only be loaded in full app test mode, so is not available in general!):</p> <pre class="highlight js" data-language="js">// This file will be auto-imported in the app-test context,
// ensuring the method is always available


import { Meteor } from 'meteor/meteor';

import { Factory } from 'meteor/dburles:factory';

import { resetDatabase } from 'meteor/xolvio:cleaner';

import { Random } from 'meteor/random';

import { _ } from 'meteor/underscore';


import { denodeify } from '../utils/denodeify';


const createList = (userId) =&gt; {
  const list = Factory.create('list', { userId });
  _.times(3, () =&gt; Factory.create('todo', { listId: list._id }));
  return list;
};

// Remember to double check this is a test-only file before
// adding a method like this!
Meteor.methods({
  generateFixtures() {
    resetDatabase();

    // create 3 public lists

    _.times(3, () =&gt; createList());

    // create 3 private lists

    _.times(3, () =&gt; createList(Random.id()));
  },
});


let generateData;

if (Meteor.isClient) {
  // Create a second connection to the server to use to call

  // test data methods. We do this so there's no contention

  // with the currently tested user's connection.

  const testConnection = Meteor.connect(Meteor.absoluteUrl());

  generateData = denodeify((cb) =&gt; {
    testConnection.call('generateFixtures', cb);
  });
}


export { generateData };</pre> <p>Note that we’ve exported a client-side symbol <code>generateData</code> which is a promisified version of the method call, which makes it simpler to use this sequentially in tests.</p> <p>Also of note is the way we use a second DDP connection to the server in order to send these test “control” method calls.</p> <h2 id="acceptance-testing">Acceptance testing</h2> <p>Acceptance testing is the process of taking an unmodified version of our application and testing it from the “outside” to make sure it behaves in a way we expect. Typically if an app passes acceptance tests, we have done our job properly from a product perspective.</p> <p>As acceptance tests test the behavior of the application in a full browser context in a generic way, there are a range of tools that you can use to specify and run such tests. In this guide we’ll demonstrate using <a href="https://chimp.readme.io" target="_blank" rel="external">Chimp</a>, an acceptance testing tool with a few neat Meteor-specific features that makes it easy to use.</p> <p>Chimp requires node version 4 or 5. You can check your node version by running:</p> <pre class="highlight sh" data-language="sh">node -v</pre> <p>You can install version 4 from <a href="https://nodejs.org/en/download/" target="_blank" rel="external">nodejs.org</a> or version 5 with <code>brew install node</code>. Then we can install the Chimp tool globally using:</p> <pre class="highlight sh" data-language="sh">npm install --global chimp</pre> <blockquote> <p>Note that you can also install Chimp as a <code>devDependency</code> in your <code>package.json</code> but you may run into problems deploying your application as it includes binary dependencies. You can avoid such problems by running <code>meteor npm prune</code> to remove non-production dependencies before deploying.</p> </blockquote> <p>Chimp has a variety of options for setting it up, but we can add some npm scripts which will run the currently tests we define in Chimp’s two main modes. We can add them to our <code>package.json</code>:</p> <pre class="highlight json" data-language="json">{
  "scripts": {
    "chimp-watch": "chimp --ddp=http://localhost:3000 --watch --mocha --path=tests",
    "chimp-test": "chimp --mocha --path=tests"

  }
}</pre> <p>Chimp will now look in the <code>tests/</code> directory (otherwise ignored by the Meteor tool) for files in which you define acceptance tests. In the <a href="https://github.com/meteor/todos" target="_blank" rel="external">Todos</a> example app, we define a simple test that ensures we can click the “create list” button.</p> <p><a href="https://github.com/meteor/todos/blob/master/tests/lists.js" target="_blank" rel="external"><code>tests/lists.js</code></a>:</p> <pre class="highlight js" data-language="js">/* eslint-env mocha */
/* eslint-disable func-names, prefer-arrow-callback */

// These are Chimp globals
/* globals browser assert server */


function countLists() {
  browser.waitForExist('.list-todo');
  const elements = browser.elements('.list-todo');
  return elements.value.length;
};

describe('list ui', function () {
  beforeEach(function () {
    browser.url('http://localhost:3000');
    server.call('generateFixtures');
  });

  it('can create a list @watch', function () {
    const initialCount = countLists();

    browser.click('.js-new-list');

    assert.equal(countLists(), initialCount + 1);
  });
});</pre> <h3 id="running-acceptance-tests">Running acceptance tests</h3> <p>To run acceptance tests, we simply need to start our Meteor app as usual, and point Chimp at it.</p> <p>In one terminal, we can do:</p> <pre class="highlight bash" data-language="bash">meteor</pre> <p>In another:</p> <pre class="highlight bash" data-language="bash">meteor npm run chimp-watch</pre> <p>The <code>chimp-watch</code> command will then run the test in a browser, and continue to re-run it as we change the test or the application. (Note that the test assumes we are running the app on port <code>3000</code>).</p> <p>Thus it’s a good way to develop the test—this is why chimp has a feature where we mark tests with a <code>@watch</code> in the name to call out the tests we want to work on (running our entire acceptance test suite can be time consuming in a large application).</p> <p>The <code>chimp-test</code> command will run all of the tests <em>once only</em> and is good for testing that our suite passes, either as a manual step, or as part of a <a href="#ci">continuous integration</a> process.</p> <h3 id="creating-acceptance-test-data">Creating data</h3> <p>Although we can run the acceptance test against our “pure” Meteor app, as we’ve done above, it often makes sense to start our meteor server with a special test driver, <code>tmeasday:acceptance-test-driver</code>. (You’ll need to <code>meteor add</code> it to your app):</p> <pre class="highlight plain" data-language="plain">meteor test --full-app --driver-package tmeasday:acceptance-test-driver</pre> <p>The advantage of running our acceptance test suite pointed at an app that runs in full app test mode is that all of the <a href="#creating-integration-test-data">data generating methods</a> that we’ve created remain available. Otherwise the <code>acceptance-test-driver</code> does nothing.</p> <p>In Chimp tests, you have a DDP connection to the server available on the <code>server</code> variable. You can thus use <code>server.call()</code> (which is wrapped to be synchronous in Chimp tests) to call these methods. This is a convenient way to share data preparation code between acceptance and integration tests.</p> <h2 id="ci">Continuous Integration</h2> <p>Continuous integration testing is the process of running tests on every commit of your project.</p> <p>There are two principal ways to do it: on the developer’s machine before allowing them to push code to the central repository, and on a dedicated CI server after each push. Both techniques are useful, and both require running tests in a commandline-only fashion.</p> <h3 id="command-line">Command line</h3> <p>We’ve seen one example of running tests on the command line, using our <code>meteor npm run chimp-test</code> mode.</p> <p>We can also use a command-line driver for Mocha <a href="https://atmospherejs.com/meteortesting/mocha" target="_blank" rel="external"><code>meteortesting:mocha</code></a> to run our standard tests on the command line.</p> <p>Adding and using the package is straightforward:</p> <pre class="highlight bash" data-language="bash">meteor add meteortesting:mocha
meteor test --once --driver-package meteortesting:mocha</pre> <p>(The <code>--once</code> argument ensures the Meteor process stops once the test is done).</p> <p>We can also add that command to our <code>package.json</code> as a <code>test</code> script:</p> <pre class="highlight json" data-language="json">{
  "scripts": {
    "test": "meteor test --once --driver-package meteortesting:mocha"

  }
}</pre> <p>Now we can run the tests with <code>meteor npm test</code>.</p> <h3 id="using-circle-ci">CircleCI</h3> <p><a href="https://circleci.com" target="_blank" rel="external">CircleCI</a> is a great continuous integration service that allows us to run (possibly time consuming) tests on every push to a repository like GitHub. To use it with the commandline test we’ve defined above, we can follow their standard <a href="https://circleci.com/docs/getting-started" target="_blank" rel="external">getting started tutorial</a> and use a <code>circle.yml</code> file similar to this:</p> <pre class="highlight less" data-language="less">
machine:
  node:
    version: 0.10.43


dependencies:
  override:
    - curl https://install.meteor.com | /bin/sh

    - npm install

checkout:
  post:
    - git submodule update --init</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2011&ndash;2017 Meteor Development Group, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://guide.meteor.com/testing.html" class="_attribution-link">https://guide.meteor.com/testing.html</a>
  </p>
</div>
