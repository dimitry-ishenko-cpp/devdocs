<h1 class="title-page">Using npm Packages</h1>    <h2 id="npm-searching">Searching for packages</h2> <p>You can use the official search at <a href="https://www.npmjs.com/" target="_blank" rel="external">npmjs.com</a> or see results sorted by package quality (code quality, maintenance status, development velocity, popularity etc.) at <a href="https://npms.io/" target="_blank" rel="external">npms.io</a>. There are also sites that search certain types of packages, like <a href="https://js.coach/" target="_blank" rel="external">js.coach</a>‘s <a href="https://js.coach/react" target="_blank" rel="external">React</a> and <a href="https://js.coach/react-native" target="_blank" rel="external">React Native</a> sections.</p> <h2 id="client-npm">npm on the client</h2> <p>Tools like <a href="http://browserify.org" target="_blank" rel="external">browserify</a> and <a href="https://webpack.github.io" target="_blank" rel="external">webpack</a> are designed to provide a Node-like environment on the client so that many npm packages, even ones originally intended for the server, can run unmodified. Meteor’s ES2015 module system does this for you out of the box with no additional configuration necessary. In most cases, you can simply import npm dependencies from a client file, just as you would on the server.</p> <blockquote> <p>When creating a new application Meteor installs the <code>meteor-node-stubs</code> npm package to help provide this client browser compatibility. If you are upgrading an application to Meteor 1.3 you may have to run <code>meteor npm install --save meteor-node-stubs</code> manually.</p> </blockquote> <h2 id="installing-npm">Installing npm Packages</h2> <p>npm packages are configured in a <code>package.json</code> file at the root of your project. If you create a new Meteor project, you will have such a file created for you. If not you can run <code>meteor npm init</code> to create one.</p> <p>To install a package into your app you run the <code>npm install</code> command with the <code>--save</code> flag:</p> <pre class="highlight bash" data-language="bash">meteor npm install --save moment</pre> <p>This will both update your <code>package.json</code> with information about the dependency and download the package into your app’s local <code>node_modules/</code> directory. Typically, you don’t check the <code>node_modules/</code> directory into source control and your teammates run <code>meteor npm install</code> to get up to date when dependencies change:</p> <pre class="highlight bash" data-language="bash">meteor npm install</pre> <p>If the package is just a development dependency (i.e. it’s used for testing, linting or the like) then you should use <code>--save-dev</code>. That way if you have some kind of build script, it can do <code>npm install --production</code> and avoid installing packages it doesn’t need.</p> <p>For more information about <code>npm install</code>, check out the <a href="https://docs.npmjs.com/getting-started/installing-npm-packages-locally" target="_blank" rel="external">official documentation</a>.</p> <blockquote> <p>Meteor comes with npm bundled so that you can type <code>meteor npm</code> without worrying about installing it yourself. If you like, you can also use a globally installed npm to manage your packages.</p> </blockquote> <h2 id="using-npm">Using npm Packages</h2> <p>To use an npm package from a file in your application you simply <code>import</code> the name of the package:</p> <pre class="highlight js" data-language="js">
import moment from 'moment';

// this is equivalent to the standard node require:

const moment = require('moment');</pre> <p>This imports the default export from the package into the symbol <code>moment</code>.</p> <p>You can also import specific functions from a package using the destructuring syntax:</p> <pre class="highlight js" data-language="js">
import { isArray } from 'lodash';</pre> <p>You can also import other files or JS entry points from a package:</p> <pre class="highlight js" data-language="js">
import { parse } from 'graphql/language';</pre> <p>Some Meteor apps contain local Meteor packages (packages defined in the <code>packages/</code> directory of your app tree); this was an older recommendation from before Meteor had full ECMAScript support. If your app is laid out this way, you can also <code>require</code> or <code>import</code> npm packages installed in your app from within your local Meteor packages.</p> <h3 id="npm-styles">Importing styles from npm</h3> <p>Using any of Meteor’s <a href="build-tool.html#css">supported CSS pre-processors</a> you can import other style files provided by an NPM into your application using both relative and absolute paths. However, this will only work for the top-level app and will not work inside an Atmosphere package.</p> <p>Importing styles from an npm package with an absolute path using the <code>{}</code> syntax, for instance with Less:</p> <pre class="highlight less" data-language="less">
@import '{}/node_modules/npm-package-name/button.less';</pre> <p>Importing styles from an npm package with a relative path:</p> <pre class="highlight less" data-language="less">
@import '../../node_modules/npm-package-name/colors.less';</pre> <p>You can also import CSS directly from a JavaScript file to control load order if you have the <code>ecmascript</code> package installed:</p> <pre class="highlight js" data-language="js">
import 'npm-package-name/stylesheets/styles.css';</pre> <blockquote> <p>When importing CSS from a JavaScript file, that CSS is not bundled with the rest of the CSS processed with the Meteor Build tool, but instead is put in your app’s <code>&lt;head&gt;</code> tag inside <code>&lt;style&gt;...&lt;/style&gt;</code> after the main concatenated CSS file.</p> </blockquote> <h2 id="npm-shrinkwrap">npm Shrinkwrap</h2> <p><code>package.json</code> typically encodes a version range, and so each <code>npm install</code> command can sometimes lead to a different result if new versions have been published in the meantime. In order to ensure that you and the rest of your team are using the same exact same version of each package, it’s a good idea to use <code>npm shrinkwrap</code> after making any dependency changes to <code>package.json</code>:</p> <pre class="highlight bash" data-language="bash"># after installing
meteor npm install --save moment
meteor npm shrinkwrap</pre> <p>This will create an <code>npm-shrinkwrap.json</code> file containing the exact versions of each dependency, and you should check this file into source control. For even more precision (the contents of a given version of a package <em>can</em> change), and to avoid a reliance on the npm server during deployment, you should consider using <a href="#npm-shrinkpack"><code>npm shrinkpack</code></a>.</p> <h2 id="async-callbacks">Asyncronous Callbacks</h2> <p>Many npm packages rely on an asynchronous, callback or promise-based coding style. For several reasons, Meteor is currently built around a synchronous-looking but still non-blocking style using <a href="https://github.com/laverdet/node-fibers" target="_blank" rel="external">Fibers</a>.</p> <p>The global Meteor server context and every method and publication initialize a new fiber so that they can run concurrently. Many Meteor APIs, for example collections, rely on running inside a fiber. They also rely on an internal Meteor mechanism that tracks server “environment” state, like the currently executing method. This means you need to initialize your own fiber and environment to use asynchronous Node code inside a Meteor app. Let’s look at an example of some code that won’t work, using the code example from the <a href="https://github.com/mikedeboer/node-github" target="_blank" rel="external">node-github repository</a>:</p> <pre class="highlight js" data-language="js">// Inside a Meteor method definition
updateGitHubFollowers() {
  github.user.getFollowingFromUser({
    user: 'stubailo'

  }, (err, res) =&gt; {
    // Using a collection here will throw an error

    // because the asynchronous code is not in a fiber

    Followers.insert(res);
  });
}</pre> <p>Let’s look at a few ways to resolve this issue.</p> <h3 id="bind-environment"><code>Meteor.bindEnvironment</code></h3> <p>In most cases, simply wrapping the callback in <code>Meteor.bindEnvironment</code> will do the trick. This function both wraps the callback in a fiber, and does some work to maintain Meteor’s server-side environment tracking. Here’s the same code with <code>Meteor.bindEnvironment</code>:</p> <pre class="highlight js" data-language="js">// Inside a Meteor method definition
updateGitHubFollowers() {
  github.user.getFollowingFromUser({
    user: 'stubailo'

  }, Meteor.bindEnvironment((err, res) =&gt; {
    // Everything is good now

    Followers.insert(res);
  }));
}</pre> <p>However, this won’t work in all cases - since the code runs asynchronously, we can’t use anything we got from an API in the method return value. We need a different approach that will convert the async API to a synchronous-looking one that will allow us to return a value.</p> <h3 id="wrap-async"><code>Meteor.wrapAsync</code></h3> <p>Many npm packages adopt the convention of taking a callback that accepts <code>(err, res)</code> arguments. If your asynchronous function fits this description, like the one above, you can use <code>Meteor.wrapAsync</code> to convert to a fiberized API that uses return values and exceptions instead of callbacks, like so:</p> <pre class="highlight js" data-language="js">// Setup sync API

const getFollowingFromUserFiber =
  Meteor.wrapAsync(github.user.getFollowingFromUser, github.user);

// Inside a Meteor method definition
updateGitHubFollowers() {
  const res = getFollowingFromUserFiber({
    user: 'stubailo'

  });

  Followers.insert(res);

  // Return how many followers we have

  return res.length;
}</pre> <p>If you wanted to refactor this and create a completely fiber-wrapper GitHub client, you could write some logic to loop over all of the methods available and call <code>Meteor.wrapAsync</code> on them, creating a new object with the same shape but with a more Meteor-compatible API.</p> <h3 id="promises">Promises</h3> <p>Recently, a lot of npm packages have been moving to Promises instead of callbacks for their API. This means you actually get a return value from the asynchronous function, but it’s just an empty shell where the real value is filled in later.</p> <p>The good news is that Promises can be used with the new ES2015 <code>async/await</code> syntax (available in the <code>ecmascript</code> package since Meteor 1.3) in a natural and synchronous-looking style on both the client and the server.</p> <p>If you declare your function <code>async</code> (which ends up meaning it returns a Promise itself), then you can use the <code>await</code> keyword to wait on other promise inside. This makes it very easy to serially call Promise-based libraries:</p> <pre class="highlight js" data-language="js">
async function sendTextMessage(user) {
  const toNumber = await phoneLookup.findFromEmail(user.emails[0].address);
  return await client.sendMessage({
    to: toNumber,
    from: '+14506667788',
    body: 'Hello world!'

  });
}</pre> <h2 id="npm-shrinkpack">Shrinkpack</h2> <p><a href="https://github.com/JamieMason/shrinkpack" target="_blank" rel="external">Shrinkpack</a> is a tool that gives you more bulletproof and repeatable builds than you get by using <a href="#npm-shrinkwrap"><code>npm shrinkwrap</code></a> alone.</p> <p>Essentially it copies a tarball of the contents of each of your npm dependencies into your application source repository. This is essentially a more robust version of the <code>npm-shrinkwrap.json</code> file that shrinkwrap creates, because it means your application’s npm dependencies can be assembled without the need or reliance on the npm servers being available or reliable. This is good for repeatable builds especially when deploying.</p> <p>To use shrinkpack, first globally install it:</p> <pre class="highlight bash" data-language="bash">npm install -g shrinkpack</pre> <p>Then use it directly after you shrinkwrap</p> <pre class="highlight bash" data-language="bash">meteor npm install --save moment
meteor npm shrinkwrap
shrinkpack</pre> <p>You should then check the generated <code>node_shrinkwrap/</code> directory into source control, but ensure it is ignored by your text editor.</p> <p><strong>NOTE</strong>: Although this is a good idea for projects with a lot of npm dependencies, it will not affect Atmosphere dependencies, even if they themselves have direct npm dependencies.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2011&ndash;2017 Meteor Development Group, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://guide.meteor.com/using-npm-packages.html" class="_attribution-link">https://guide.meteor.com/using-npm-packages.html</a>
  </p>
</div>
