<h1 class="title-page">Users and Accounts</h1> <div class="subtitle-page">How to build user login functionality into a Meteor app. Let your users log in with passwords, Facebook, Google, GitHub, and more.</div>    <p>After reading this article, you’ll know:</p> <ol> <li>What features in core Meteor enable user accounts</li> <li>How to use accounts-ui for a quick prototype</li> <li>How to use the useraccounts family of packages to build your login UI</li> <li>How to build a fully-featured password login experience</li> <li>How to enable login through OAuth providers like Facebook</li> <li>How to add custom data to Meteor’s users collection</li> <li>How to manage user roles and permissions</li> </ol> <h2 id="core-meteor">Features in core Meteor</h2> <p>Before we get into all of the different user-facing accounts functionality you can add with Meteor, let’s go over some of the features built into the Meteor DDP protocol and <code>accounts-base</code> package. These are the parts of Meteor that you’ll definitely need to be aware of if you have any user accounts in your app; most of everything else is optional and added/removed via packages.</p> <h3 id="userid-ddp">userId in DDP</h3> <p>DDP is Meteor’s built-in pub/sub and RPC protocol. You can read about how to use it in the <a href="data-loading.html">Data Loading</a> and <a href="methods.html">Methods</a> articles. In addition to the concepts of data loading and method calls, DDP has one more feature built in - the idea of a <code>userId</code> field on a connection. This is the place where login state is tracked, regardless of which accounts UI package or login service you are using.</p> <p>This built-in feature means that you always get <code>this.userId</code> inside Methods and Publications, and can access the user ID on the client. This is a great starting point for building your own custom accounts system, but most developers won’t need to worry about the mechanics, since you’ll mostly be interacting with the <code>accounts-base</code> package instead.</p> <h3 id="accounts-base"><code>accounts-base</code></h3> <p>This package is the core of Meteor’s developer-facing user accounts functionality. This includes:</p> <ol> <li>A users collection with a standard schema, accessed through <a href="http://docs.meteor.com/#/full/meteor_users" target="_blank" rel="external"><code>Meteor.users</code></a>, and the client-side singletons <a href="http://docs.meteor.com/#/full/meteor_userid" target="_blank" rel="external"><code>Meteor.userId()</code></a> and <a href="http://docs.meteor.com/#/full/meteor_user" target="_blank" rel="external"><code>Meteor.user()</code></a>, which represent the login state on the client.</li> <li>A variety of helpful other generic methods to keep track of login state, log out, validate users, etc. Visit the <a href="http://docs.meteor.com/#/full/accounts_api" target="_blank" rel="external">Accounts section of the docs</a> to find a complete list.</li> <li>An API for registering new login handlers, which is used by all of the other accounts packages to integrate with the accounts system. There isn’t any official documentation for this API, but you can <a href="https://web.archive.org/web/20160913210817/https://meteorhacks.com/extending-meteor-accounts" target="_blank" rel="external">read more about it on the MeteorHacks blog</a>.</li> </ol> <p>Usually, you don’t need to include <code>accounts-base</code> yourself since it’s added for you if you use <code>accounts-password</code> or similar, but it’s good to be aware of what is what.</p> <h2 id="accounts-ui">Fast prototyping with <code>accounts-ui</code>
</h2> <p>Often, a complicated accounts system is not the first thing you want to build when you’re starting out with a new app, so it’s useful to have something you can just drop in quickly. This is where <code>accounts-ui</code> comes in - it’s just one line that you drop into your app to get an accounts system. To add it:</p> <pre class="highlight js" data-language="js">meteor add accounts-ui</pre> <p>Then just include it anywhere in a Blaze template:</p> <pre class="highlight html" data-language="html">{{&gt; loginButtons}}</pre> <p>Then, make sure to pick a login provider; they will automatically integrate with <code>accounts-ui</code>:</p> <pre class="highlight sh" data-language="sh"># pick one or more of the below
meteor add accounts-password
meteor add accounts-facebook
meteor add accounts-google
meteor add accounts-github
meteor add accounts-twitter
meteor add accounts-meetup
meteor add accounts-meteor-developer</pre> <p>Now just open your app, follow the configuration steps, and you’re good to go - if you’ve done the <a href="https://www.meteor.com/tutorials/blaze/adding-user-accounts" target="_blank" rel="external">Meteor tutorial</a>, you’ve already seen this in action. Of course, in a production application, you probably want a more custom user interface and some logic to have a more tailored UX, but that’s why we have the rest of this guide.</p> <p>Here are a couple of screenshots of <code>accounts-ui</code> so you know what to expect:</p> <p><img src="https://guide.meteor.com/images/accounts-ui.png"></p> <h2 id="useraccounts">Customizable UI: useraccounts</h2> <p>Once you’ve gotten your initial prototype up and running with <code>accounts-ui</code>, you’ll want to move to something more powerful and configurable so that you can better integrate your login flow with the rest of your app. The <a href="https://github.com/meteor-useraccounts/core/blob/master/Guide.md" target="_blank" rel="external"><code>useraccounts</code> family of packages</a> is the most powerful set of accounts management UI controls available for Meteor today. If you need even more customization, you can also roll your own system, but it’s worth trying <code>useraccounts</code> first.</p> <h3 id="useraccounts-flexibility">Use any router or UI framework</h3> <p>The first thing to understand about <code>useraccounts</code> is that the core accounts management logic is independent of the HTML templates and routing packages. This means you can use <a href="https://atmospherejs.com/useraccounts/core" target="_blank" rel="external"><code>useraccounts:core</code></a> to build your own set of login templates. Generally, you’ll want to pick one login template package and one login routing package. The options for templates include:</p> <ul> <li>
<a href="https://atmospherejs.com/useraccounts/unstyled" target="_blank" rel="external"><code>useraccounts:unstyled</code></a> which lets you bring your own CSS; this one is used in the Todos example app to make the login UI blend seamlessly with the rest of the app.</li> <li>Pre-built templates for <a href="https://github.com/meteor-useraccounts/core/blob/master/Guide.md#available-versions" target="_blank" rel="external">Bootstrap, Semantic UI, Materialize, and more</a>. These templates don’t come with the actual CSS framework, so you can pick your favorite Bootstrap package, for example.</li> </ul> <p>While it’s optional and the basic functionality will work without it, it’s also a good idea to pick a router integration:</p> <ul> <li>
<a href="https://atmospherejs.com/useraccounts/flow-routing" target="_blank" rel="external">Flow Router</a>, the router <a href="routing.html">recommended in this guide</a>.</li> <li>
<a href="https://atmospherejs.com/useraccounts/iron-routing" target="_blank" rel="external">Iron Router</a>, another popular router in the Meteor community.</li> </ul> <p>In the example app we are using the Flow Router integration with great success. Some of the later sections will cover how to customize the routes and templates to fit your app better.</p> <h3 id="useraccounts-drop-in">Drop-in UI without routing</h3> <p>If you don’t want to configure routing for your login flow, you can just drop in a self-managing accounts screen. Wherever you want the accounts UI template to render, just include the <code>atForm</code> template, like so:</p> <pre class="highlight html" data-language="html">{{&gt; atForm}}</pre> <p>Once you configure routing according to <a href="#useraccounts-customizing-routes">the section below</a>, you’ll want to remove this inclusion.</p> <h3 id="useraccounts-customizing-templates">Customizing templates</h3> <p>For some apps, the off-the-shelf login templates provided by the various <code>useraccounts</code> UI packages will work as-is, but most apps will want to customize some of the presentation. There’s a simple way to do that using the template replacement functionality of the <code>aldeed:template-extension</code> package.</p> <p>First, figure out which template you want to replace by looking at the source code of the package. For example, in the <code>useraccounts:unstyled</code> package, the templates are listed <a href="https://github.com/meteor-useraccounts/unstyled/tree/master/lib" target="_blank" rel="external">in this directory on GitHub</a>. By squinting at the file names and looking for some of the HTML strings, we can figure out that we might be interested in replacing the <code>atPwdFormBtn</code> template. Let’s take a look at the original template:</p> <pre class="highlight html" data-language="html">&lt;template name="atPwdFormBtn"&gt;
  &lt;button type="submit" class="at-btn submit {{submitDisabled}}" id="at-btn"&gt;

    {{buttonText}}
  &lt;/button&gt;

&lt;/template&gt;</pre> <p>Once you’ve identified which template you need to replace, define a new template. In this case, we want to modify the class on the button to work with the CSS for the rest of the app. There are a few things to keep in mind when overriding a template:</p> <ol> <li>Render the helpers in the same way the previous template did. In this case we are using <code>buttonText</code>.</li> <li>Keep any <code>id</code> attributes, like <code>at-btn</code>, since those are used for event handling.</li> </ol> <p>Here’s what our new override template looks like:</p> <pre class="highlight html" data-language="html">&lt;template name="override-atPwdFormBtn"&gt;
  &lt;button type="submit" class="btn-primary" id="at-btn"&gt;

    {{buttonText}}
  &lt;/button&gt;

&lt;/template&gt;</pre> <p>Then, use the <code>replaces</code> function on the template to override the existing template from <code>useraccounts</code>:</p> <pre class="highlight js" data-language="js">Template['override-atPwdFormBtn'].replaces('atPwdFormBtn');</pre> <h3 id="useraccounts-customizing-routes">Customizing routes</h3> <p>In addition to having control over the templates, you’ll want to be able to control the routing and URLs for the different views offered by <code>useraccounts</code>. Since Flow Router is the officially recommended routing option for Meteor, we’ll go over that in particular.</p> <p>First, we need to configure the layout we want to use when rendering the accounts templates:</p> <pre class="highlight js" data-language="js">AccountsTemplates.configure({
  defaultTemplate: 'Auth_page',
  defaultLayout: 'App_body',
  defaultContentRegion: 'main',
  defaultLayoutRegions: {}
});</pre> <p>In this case, we want to use the <code>App_body</code> layout template for all of the accounts-related pages. This template has a content region called <code>main</code>. Now, let’s configure some routes:</p> <pre class="highlight js" data-language="js">// Define these routes in a file loaded on both client and server
AccountsTemplates.configureRoute('signIn', {
  name: 'signin',
  path: '/signin'

});

AccountsTemplates.configureRoute('signUp', {
  name: 'join',
  path: '/join'

});

AccountsTemplates.configureRoute('forgotPwd');

AccountsTemplates.configureRoute('resetPwd', {
  name: 'resetPwd',
  path: '/reset-password'

});</pre> <p>Note that we have specified a password reset route. Normally, we would have to configure Meteor’s accounts system to send this route in password reset emails, but the <code>useraccounts:flow-routing</code> package does it for us. <a href="#email-flows">Read more about configuring email flows below.</a></p> <p>Now that the routes are setup on the server, they can be accessed from the browser (e.g. <code>example.com/reset-password</code>). To create links to these routes in a template, it’s best to use a helper method provided by the router. For Flow Router, the <a href="https://github.com/arillo/meteor-flow-router-helpers/" target="_blank" rel="external"><code>arillo:flow-router-helpers</code></a> package provides a <code>pathFor</code> helper for just this purpose. Once installed, the following is possible in a template:</p> <pre class="highlight html" data-language="html">&lt;div class="btns-group"&gt;
  &lt;a href="{{pathFor 'signin'}}.html" class="btn-secondary"&gt;Sign In&lt;/a&gt;

  &lt;a href="{{pathFor 'join'}}.html" class="btn-secondary"&gt;Join&lt;/a&gt;

&lt;/div&gt;</pre> <p>You can find a complete list of different available routes in the <a href="https://github.com/meteor-useraccounts/flow-routing#routes" target="_blank" rel="external">documentation the <code>useraccounts:flow-routing</code></a>.</p> <h3 id="useraccounts-further-customization">Further customization</h3> <p><code>useraccounts</code> offers many other customization options beyond templates and routing. Read the <a href="https://github.com/meteor-useraccounts/core/blob/master/Guide.md" target="_blank" rel="external"><code>useraccounts</code> guide</a> to learn about all of the other options.</p> <h2 id="accounts-password">Password login</h2> <p>Meteor comes with a secure and fully-featured password login system out of the box. To use it, add the package:</p> <pre class="highlight sh" data-language="sh">meteor add accounts-password</pre> <p>To see what options are available to you, read the complete description of the <a href="http://docs.meteor.com/#/full/accounts_passwords" target="_blank" rel="external"><code>accounts-password</code> API in the Meteor docs</a>.</p> <h3 id="requiring-username-email">Requiring username or email</h3> <blockquote> <p>Note: You don’t have to do this if you’re using <code>useraccounts</code>. It disables the regular Meteor client-side account creation functions for you and does custom validation.</p> </blockquote> <p>By default, the <code>Accounts.createUser</code> function provided by <code>accounts-password</code> allows you to create an account with a username, email, or both. Most apps expect a specific combination of the two, so you will certainly want to validate the new user creation:</p> <pre class="highlight js" data-language="js">// Ensuring every user has an email address, should be in server-side code
Accounts.validateNewUser((user) =&gt; {
  new SimpleSchema({
    _id: { type: String },
    emails: { type: Array },
    'emails.$': { type: Object },
    'emails.$.address': { type: String },
    'emails.$.verified': { type: Boolean },
    createdAt: { type: Date },
    services: { type: Object, blackbox: true }
  }).validate(user);

  // Return true to allow user creation to proceed

  return true;
});</pre> <h3 id="multiple-emails">Multiple emails</h3> <p>Often, users might want to associate multiple email addresses with the same account. <code>accounts-password</code> addresses this case by storing the email addresses as an array in the user collection. There are some handy API methods to deal with <a href="http://docs.meteor.com/api/passwords.html#Accounts-addEmail" target="_blank" rel="external">adding</a>, <a href="http://docs.meteor.com/api/passwords.html#Accounts-removeEmail" target="_blank" rel="external">removing</a>, and <a href="http://docs.meteor.com/api/passwords.html#Accounts-verifyEmail" target="_blank" rel="external">verifying</a> emails.</p> <p>One useful thing to add for your app can be the concept of a “primary” email address. This way, if the user has added multiple emails, you know where to send confirmation emails and similar.</p> <h3 id="case-sensitivity">Case sensitivity</h3> <p>Before Meteor 1.2, all email addresses and usernames in the database were considered to be case-sensitive. This meant that if you registered an account as <code>AdaLovelace@example.com</code>, and then tried to log in with <code>adalovelace@example.com</code>, you’d see an error indicating that no user with that email exists. Of course, this can be quite confusing, so we decided to improve things in Meteor 1.2. But the situation was not as simple as it seemed; since MongoDB doesn’t have a concept of case-insensitive indexes, it was impossible to guarantee unique emails at the database level. For this reason, we have some special APIs for querying and updating users which manage the case-sensitivity problem at the application level.</p> <h4 id="case-sensitivity-in-my-app">What does this mean for my app?</h4> <p>Just follow one simple rule: don’t query the database by <code>username</code> or <code>email</code> directly. Instead, use the <a href="http://docs.meteor.com/api/passwords.html#Accounts-findUserByUsername" target="_blank" rel="external"><code>Accounts.findUserByUsername</code></a> and <a href="http://docs.meteor.com/api/passwords.html#Accounts-findUserByEmail" target="_blank" rel="external"><code>Accounts.findUserByEmail</code></a> methods provided by Meteor. This will run a query for you that is case-insensitive, so you will always find the user you are looking for.</p> <h3 id="email-flows">Email flows</h3> <p>When you have a login system for your app based on user emails, that opens up the possibility for email-based account flows. The common thing between all of these workflows is that they involve sending a unique link to the user’s email address, which does something special when it is clicked. Let’s look at some common examples that Meteor’s <code>accounts-password</code> package supports out of the box:</p> <ol> <li>
<strong>Password reset.</strong> When the user clicks the link in their email, they are taken to a page where they can enter a new password for their account.</li> <li>
<strong>User enrollment.</strong> A new user is created by an administrator, but no password is set. When the user clicks the link in their email, they are taken to a page where they can set a new password for their account. Very similar to password reset.</li> <li>
<strong>Email verification.</strong> When the user clicks the link in their email, the application records that this email does indeed belong to the correct user.</li> </ol> <p>Here, we’ll talk about how to manage the whole process manually from start to finish.</p> <h4 id="default-email-flow">Email works out of the box with accounts UI packages</h4> <p>If you want something that just works out of the box, you can use <code>accounts-ui</code> or <code>useraccounts</code> which basically do everything for you. Only follow the directions below if you definitely want to build all parts of the email flow yourself.</p> <h4 id="sending-email">Sending the email</h4> <p><code>accounts-password</code> comes with handy functions that you can call from the server to send an email. They are named for exactly what they do:</p> <ol> <li><a href="http://docs.meteor.com/#/full/accounts_sendresetpasswordemail" target="_blank" rel="external"><code>Accounts.sendResetPasswordEmail</code></a></li> <li><a href="http://docs.meteor.com/#/full/accounts_sendenrollmentemail" target="_blank" rel="external"><code>Accounts.sendEnrollmentEmail</code></a></li> <li><a href="http://docs.meteor.com/#/full/accounts_sendverificationemail" target="_blank" rel="external"><code>Accounts.sendVerificationEmail</code></a></li> </ol> <p>The email is generated using the email templates from <a href="http://docs.meteor.com/#/full/accounts_emailtemplates" target="_blank" rel="external">Accounts.emailTemplates</a>, and include links generated with <code>Accounts.urls</code>. We’ll go into more detail about customizing the email content and URL later.</p> <h4 id="identifying-link-click">Identifying when the link is clicked</h4> <p>When the user receives the email and clicks the link inside, their web browser will take them to your app. Now, you need to be able to identify these special links and act appropriately. If you haven’t customized the link URL, then you can use some built-in callbacks to identify when the app is in the middle of an email flow.</p> <p>Normally, when the Meteor client connects to the server, the first thing it does is pass the <em>login resume token</em> to re-establish a previous login. However, when these callbacks from the email flow are triggered, the resume token is not sent until your code signals that it has finished handling the request by calling the <code>done</code> function that is passed into the registered callback. This means that if you were previously logged in as user A, and then you clicked the reset password link for user B, but then you cancelled the password reset flow by calling <code>done()</code>, the client would log in as A again.</p> <ol> <li><a href="http://docs.meteor.com/#/full/Accounts-onResetPasswordLink" target="_blank" rel="external"><code>Accounts.onResetPasswordLink</code></a></li> <li><a href="http://docs.meteor.com/#/full/Accounts-onEnrollmentLink" target="_blank" rel="external"><code>Accounts.onEnrollmentLink</code></a></li> <li><a href="http://docs.meteor.com/#/full/Accounts-onEmailVerificationLink" target="_blank" rel="external"><code>Accounts.onEmailVerificationLink</code></a></li> </ol> <p>Here’s how you would use one of these functions:</p> <pre class="highlight js" data-language="js">Accounts.onResetPasswordLink((token, done) =&gt; {
  // Display the password reset UI, get the new password...


  Accounts.resetPassword(token, newPassword, (err) =&gt; {
    if (err) {
      // Display error

    } else {
      // Resume normal operation

      done();
    }
  });
})</pre> <p>If you want a different URL for your reset password page, you need to customize it using the <code>Accounts.urls</code> option:</p> <pre class="highlight js" data-language="js">Accounts.urls.resetPassword = (token) =&gt; {
  return Meteor.absoluteUrl(`reset-password/${token}`);
};</pre> <p>If you have customized the URL, you will need to add a new route to your router that handles the URL you have specified, and the default <code>Accounts.onResetPasswordLink</code> and friends won’t work for you.</p> <h4 id="completing-email-flow">Displaying an appropriate UI and completing the process</h4> <p>Now that you know that the user is attempting to reset their password, set an initial password, or verify their email, you should display an appropriate UI to allow them to do so. For example, you might want to show a page with a form for the user to enter their new password.</p> <p>When the user submits the form, you need to call the appropriate function to commit their change to the database. Each of these functions takes the new value and the token you got from the event in the previous step.</p> <ol> <li>
<a href="http://docs.meteor.com/#/full/accounts_resetpassword" target="_blank" rel="external"><code>Accounts.resetPassword</code></a> - this one should be used both for resetting the password, and enrolling a new user; it accepts both kinds of tokens.</li> <li><a href="http://docs.meteor.com/#/full/accounts_verifyemail" target="_blank" rel="external"><code>Accounts.verifyEmail</code></a></li> </ol> <p>After you have called one of the two functions above or the user has cancelled the process, call the <code>done</code> function you got in the link callback. This will tell Meteor to get out of the special state it enters when you’re doing one of the email account flows.</p> <h3 id="customizing-emails">Customizing accounts emails</h3> <p>You will probably want to customize the emails <code>accounts-password</code> will send on your behalf. This can be easily done through the <a href="http://docs.meteor.com/#/full/accounts_emailtemplates" target="_blank" rel="external"><code>Accounts.emailTemplates</code> API</a>. Below is some example code from the Todos app:</p> <pre class="highlight js" data-language="js">Accounts.emailTemplates.siteName = "Meteor Guide Todos Example";
Accounts.emailTemplates.from = "Meteor Todos Accounts &lt;accounts@example.com&gt;";

Accounts.emailTemplates.resetPassword = {
  subject(user) {
    return "Reset your password on Meteor Todos";
  },
  text(user, url) {
    return `Hello!

Click the link below to reset your password on Meteor Todos.
${url}
If you didn't request this email, please ignore it.
Thanks,
The Meteor Todos team
`
  },
  html(user, url) {
    // This is where HTML email content would go.

    // See the section about html emails below.

  }
};</pre> <p>As you can see, we can use the ES2015 template string functionality to generate a multi-line string that includes the password reset URL. We can also set a custom <code>from</code> address and email subject.</p> <h4 id="html-emails">HTML emails</h4> <p>If you’ve ever needed to deal with sending pretty HTML emails from an app, you know that it can quickly become a nightmare. Compatibility of popular email clients with basic HTML features like CSS is notoriously spotty, so it is hard to author something that works at all. Start with a <a href="https://github.com/leemunroe/responsive-html-email-template" target="_blank" rel="external">responsive email template</a> or <a href="http://foundation.zurb.com/emails/email-templates.html" target="_blank" rel="external">framework</a>, and then use a tool to convert your email content into something that is compatible with all email clients. <a href="http://blog.mailgun.com/transactional-html-email-templates/" target="_blank" rel="external">This blog post by Mailgun covers some of the main issues with HTML email.</a> In theory, a community package could extend Meteor’s build system to do the email compilation for you, but at the time of writing we were not aware of any such packages.</p> <h2 id="oauth">OAuth login</h2> <p>In the distant past, it could have been a huge headache to get Facebook or Google login to work with your app. Thankfully, most popular login providers have standardized around some version of <a href="https://en.wikipedia.org/wiki/OAuth" target="_blank" rel="external">OAuth</a>, and Meteor supports some of the most popular login services out of the box.</p> <h3 id="supported-login-services">Facebook, Google, and more</h3> <p>Here’s a complete list of login providers for which Meteor actively maintains core packages:</p> <ol> <li>Facebook with <code>accounts-facebook</code>
</li> <li>Google with <code>accounts-google</code>
</li> <li>GitHub with <code>accounts-github</code>
</li> <li>Twitter with <code>accounts-twitter</code>
</li> <li>Meetup with <code>accounts-meetup</code>
</li> <li>Meteor Developer Accounts with <code>accounts-meteor-developer</code>
</li> </ol> <p>There is a package for logging in with Weibo, but it is no longer being actively maintained.</p> <h3 id="oauth-logging-in">Logging in</h3> <p>If you are using an off-the-shelf login UI like <code>accounts-ui</code> or <code>useraccounts</code>, you don’t need to write any code after adding the relevant package from the list above. If you are building a login experience from scratch, you can log in programmatically using the <a href="http://docs.meteor.com/#/full/meteor_loginwithexternalservice" target="_blank" rel="external"><code>Meteor.loginWith&lt;Service&gt;</code></a> function. It looks like this:</p> <pre class="highlight js" data-language="js">Meteor.loginWithFacebook({
  requestPermissions: ['user_friends', 'public_profile', 'email']
}, (err) =&gt; {
  if (err) {
    // handle error

  } else {
    // successful login!

  }
});</pre> <h3 id="oauth-configuration">Configuring OAuth</h3> <p>There are a few points to know about configuring OAuth login:</p> <ol> <li>
<strong>Client ID and secret.</strong> It’s best to keep your OAuth secret keys outside of your source code, and pass them in through Meteor.settings. Read how in the <a href="security.html#api-keys-oauth">Security article</a>.</li> <li>
<strong>Redirect URL.</strong> On the OAuth provider’s side, you’ll need to specify a <em>redirect URL</em>. The URL will look like: <code>https://www.example.com/_oauth/facebook</code>. Replace <code>facebook</code> with the name of the service you are using. Note that you will need to configure two URLs - one for your production app, and one for your development environment, where the URL might be something like <code>http://localhost:3000/_oauth/facebook</code>.</li> <li>
<strong>Permissions.</strong> Each login service provider should have documentation about which permissions are available. For example, <a href="https://developers.facebook.com/docs/facebook-login/permissions" target="_blank" rel="external">here is the page for Facebook</a>. If you want additional permissions to the user’s data when they log in, pass some of these strings in the <code>requestPermissions</code> option to <code>Meteor.loginWithFacebook</code> or <a href="http://docs.meteor.com/#/full/accounts_ui_config" target="_blank" rel="external"><code>Accounts.ui.config</code></a>. In the next section we’ll talk about how to retrieve that data.</li> </ol> <h3 id="oauth-calling-api">Calling service API for more data</h3> <p>If your app supports or even requires login with an external service such as Facebook, it’s natural to also want to use that service’s API to request additional data about that user. For example, you might want to get a list of a Facebook user’s photos.</p> <p>First, you’ll need to request the relevant permissions when logging in the user. See the <a href="#oauth-configuration">section above</a> for how to pass those options.</p> <p>Then, you need to get the user’s access token. You can find this token in the <code>Meteor.users</code> collection under the <code>services</code> field. For example, if you wanted to get a particular user’s Facebook access token:</p> <pre class="highlight js" data-language="js">// Given a userId, get the user's Facebook access token

const user = Meteor.users.findOne(userId);

const fbAccessToken = user.services.facebook.accessToken;</pre> <p>For more details about the data stored in the user database, read the section below about accessing user data.</p> <p>Now that you have the access token, you need to actually make a request to the appropriate API. Here you have two options:</p> <ol> <li>Use the <a href="http://docs.meteor.com/#/full/http" target="_blank" rel="external"><code>http</code> package</a> to access the service’s API directly. You’ll probably need to pass the access token from above in a header. For details you’ll need to search the API documentation for the service.</li> <li>Use a package from Atmosphere or npm that wraps the API into a nice JavaScript interface. For example, if you’re trying to load data from Facebook you could use the <a href="https://www.npmjs.com/package/fbgraph" target="_blank" rel="external">fbgraph</a> npm package. Read more about how to use npm with your app in the <a href="build-tool.html#npm">Build System article</a>.</li> </ol> <h2 id="displaying-user-data">Loading and displaying user data</h2> <p>Meteor’s accounts system, as implemented in <code>accounts-base</code>, also includes a database collection and generic functions for getting data about users.</p> <h3 id="current-user">Currently logged in user</h3> <p>Once a user is logged into your app with one of the methods described above, it is useful to be able to identify which user is logged in, and get the data provided during the registration process.</p> <h4 id="current-user-client">On the client: Meteor.userId()</h4> <p>For code that runs on the client, the global <code>Meteor.userId()</code> reactive function will give you the ID of the currently logged in user.</p> <p>In addition to that core API, there are some helpful shorthand helpers: <code>Meteor.user()</code>, which is exactly equal to calling <code>Meteor.users.findOne(Meteor.userId())</code>, and the <code>{{currentUser}}</code> Blaze helper that returns the value of <code>Meteor.user()</code>.</p> <p>Note that there is a benefit to restricting the places you access the current user to make your UI more testable and modular. Read more about this in the <a href="ui-ux.html#global-stores">UI article</a>.</p> <h4 id="current-user-server">On the server: this.userId</h4> <p>On the server, each connection has a different logged in user, so there is no global logged-in user state by definition. Since Meteor tracks the environment for each Method call, you can still use the <code>Meteor.userId()</code> global, which returns a different value depending on which Method you call it from, but you can run into edge cases when dealing with asynchronous code. Also, <code>Meteor.userId()</code> won’t work inside publications.</p> <p>We suggest using the <code>this.userId</code> property on the context of Methods and publications instead, and passing that around through function arguments to wherever you need it.</p> <pre class="highlight js" data-language="js">// Accessing this.userId inside a publication
Meteor.publish('lists.private', function() {
  if (!this.userId) {
    return this.ready();
  }

  return Lists.find({
    userId: this.userId
  }, {
    fields: Lists.publicFields
  });
});</pre> <pre class="highlight js" data-language="js">// Accessing this.userId inside a Method
Meteor.methods({
  'todos.updateText'({ todoId, newText }) {
    new SimpleSchema({
      todoId: { type: String },
      newText: { type: String }
    }).validate({ todoId, newText }),

    const todo = Todos.findOne(todoId);

    if (!todo.editableBy(this.userId)) {
      throw new Meteor.Error('todos.updateText.unauthorized',
        'Cannot edit todos in a private list that is not yours');
    }

    Todos.update(todoId, {
      $set: { text: newText }
    });
  }
});</pre> <h3 id="meteor-users-collection">The Meteor.users collection</h3> <p>Meteor comes with a default MongoDB collection for user data. It’s stored in the database under the name <code>users</code>, and is accessible in your code through <code>Meteor.users</code>. The schema of a user document in this collection will depend on which login service was used to create the account. Here’s an example of a user that created their account with <code>accounts-password</code>:</p> <pre class="highlight js" data-language="js">{
  "_id": "DQnDpEag2kPevSdJY",
  "createdAt": "2015-12-10T22:34:17.610Z",
  "services": {
    "password": {
      "bcrypt": "XXX"

    },
    "resume": {
      "loginTokens": [
        {
          "when": "2015-12-10T22:34:17.615Z",
          "hashedToken": "XXX"

        }
      ]
    }
  },
  "emails": [
    {
      "address": "ada@lovelace.com",
      "verified": false

    }
  ]
}</pre> <p>Here’s what the same user would look like if they instead logged in with Facebook:</p> <pre class="highlight js" data-language="js">{
  "_id": "Ap85ac4r6Xe3paeAh",
  "createdAt": "2015-12-10T22:29:46.854Z",
  "services": {
    "facebook": {
      "accessToken": "XXX",
      "expiresAt": 1454970581716,
      "id": "XXX",
      "email": "ada@lovelace.com",
      "name": "Ada Lovelace",
      "first_name": "Ada",
      "last_name": "Lovelace",
      "link": "https://www.facebook.com/app_scoped_user_id/XXX/",
      "gender": "female",
      "locale": "en_US",
      "age_range": {
        "min": 21

      }
    },
    "resume": {
      "loginTokens": [
        {
          "when": "2015-12-10T22:29:46.858Z",
          "hashedToken": "XXX"

        }
      ]
    }
  },
  "profile": {
    "name": "Sashko Stubailo"

  }
}</pre> <p>Note that the schema is different when users register with different login services. There are a few things to be aware of when dealing with this collection:</p> <ol> <li>User documents in the database have secret data like access keys and hashed passwords. When <a href="#publish-custom-data">publishing user data to the client</a>, be extra careful not to include anything that client shouldn’t be able to see.</li> <li>DDP, Meteor’s data publication protocol, only knows how to resolve conflicts in top-level fields. This means that you can’t have one publication send <code>services.facebook.first_name</code> and another send <code>services.facebook.locale</code> - one of them will win, and only one of the fields will actually be available on the client. The best way to fix this is to denormalize the data you want onto custom top-level fields, as described in the section about <a href="#custom-user-data">custom user data</a>.</li> <li>The OAuth login service packages populate <code>profile.name</code>. We don’t recommend using this but, if you plan to, make sure to deny client-side writes to <code>profile</code>. See the section about the <a href="#dont-use-profile"><code>profile</code> field on users</a>.</li> <li>When finding users by email or username, make sure to use the case-insensitive functions provided by <code>accounts-password</code>. See the <a href="#case-sensitivity">section about case-sensitivity</a> for more details.</li> </ol> <h2 id="custom-user-data">Custom data about users</h2> <p>As your app gets more complex, you will invariably need to store some data about individual users, and the most natural place to put that data is in additional fields on the <code>Meteor.users</code> collection described above. In a more normalized data situation it would be a good idea to keep Meteor’s user data and yours in two separate tables, but since MongoDB doesn’t deal well with data associations it makes sense to just use one collection.</p> <h3 id="top-level-fields">Add top-level fields onto the user document</h3> <p>The best way to store your custom data onto the <code>Meteor.users</code> collection is to add a new uniquely-named top-level field on the user document. For example, if you wanted to add a mailing address to a user, you could do it like this:</p> <pre class="highlight js" data-language="js">// Using address schema from schema.org
// https://schema.org/PostalAddress

const newMailingAddress = {
  addressCountry: 'US',
  addressLocality: 'Seattle',
  addressRegion: 'WA',
  postalCode: '98052',
  streetAddress: "20341 Whitworth Institute 405 N. Whitworth"

};

Meteor.users.update(userId, {
  $set: {
    mailingAddress: newMailingAddress
  }
});</pre> <p>You can use any field name other than those <a href="http://docs.meteor.com/api/accounts.html#Meteor-users" target="_blank" rel="external">used by the Accounts system</a>.</p> <h3 id="adding-fields-on-registration">Adding fields on user registration</h3> <p>The code above is just code that you could run on the server inside a Meteor Method to set someone’s mailing address. Sometimes, you want to set a field when the user first creates their account, for example to initialize a default value or compute something from their social data. You can do this using <a href="http://docs.meteor.com/#/full/accounts_oncreateuser" target="_blank" rel="external"><code>Accounts.onCreateUser</code></a>:</p> <pre class="highlight js" data-language="js">// Generate user initials after Facebook login
Accounts.onCreateUser((options, user) =&gt; {
  if (! user.services.facebook) {
    throw new Error('Expected login with Facebook only.');
  }

  const { first_name, last_name } = user.services.facebook;
  user.initials = first_name[0].toUpperCase() + last_name[0].toUpperCase();

  // We still want the default hook's 'profile' behavior.

  if (options.profile) {
    user.profile = options.profile;
  }
  
  // Don't forget to return the new user object at the end!

  return user;
});</pre> <p>Note that the <code>user</code> object provided doesn’t have an <code>_id</code> field yet. If you need to do something with the new user’s ID inside this function, a useful trick can be to generate the ID yourself:</p> <pre class="highlight js" data-language="js">// Generate a todo list for each new user
Accounts.onCreateUser((options, user) =&gt; {
  // Generate a user ID ourselves

  user._id = Random.id(); // Need to add the `random` package


  // Use the user ID we generated

  Lists.createListForUser(user._id);

  // Don't forget to return the new user object at the end!

  return user;
});</pre> <h3 id="dont-use-profile">Don’t use profile</h3> <p>There’s a tempting existing field called <code>profile</code> that is added by default when a new user registers. This field was historically intended to be used as a scratch pad for user-specific data - maybe their image avatar, name, intro text, etc. Because of this, <strong>the <code>profile</code> field on every user is automatically writeable by that user from the client</strong>. It’s also automatically published to the client for that particular user.</p> <p>It turns out that having a field writeable by default without making that super obvious might not be the best idea. There are many stories of new Meteor developers storing fields such as <code>isAdmin</code> on <code>profile</code>… and then a malicious user can easily set that to true whenever they want, making themselves an admin. Even if you aren’t concerned about this, it isn’t a good idea to let malicious users store arbitrary amounts of data in your database.</p> <p>Rather than dealing with the specifics of this field, it can be helpful to just ignore its existence entirely. You can safely do that as long as you deny all writes from the client:</p> <pre class="highlight js" data-language="js">// Deny all client-side updates to user documents
Meteor.users.deny({
  update() { return true; }
});</pre> <p>Even ignoring the security implications of <code>profile</code>, it isn’t a good idea to put all of your app’s custom data onto one field. As discussed in the <a href="collections.html#schema-design">Collections article</a>, Meteor’s data transfer protocol doesn’t do deeply nested diffing of fields, so it’s a good idea to flatten out your objects into many top-level fields on the document.</p> <h3 id="publish-custom-data">Publishing custom data</h3> <p>If you want to access the custom data you’ve added to the <code>Meteor.users</code> collection in your UI, you’ll need to publish it to the client. Mostly, you can just follow the advice in the <a href="data-loading.html#publications">Data Loading</a> and <a href="security.html#publications">Security</a> articles.</p> <p>The most important thing to keep in mind is that user documents are certain to contain private data about your users. In particular, the user document includes hashed password data and access keys for external APIs. This means it’s critically important to <a href="http://guide.meteor.com/security.html#fields">filter the fields</a> of the user document that you send to any client.</p> <p>Note that in Meteor’s publication and subscription system, it’s totally fine to publish the same document multiple times with different fields - they will get merged internally and the client will see a consistent document with all of the fields together. So if you just added one custom field, you should just write a publication with that one field. Let’s look at an example of how we might publish the <code>initials</code> field from above:</p> <pre class="highlight js" data-language="js">Meteor.publish('Meteor.users.initials', function ({ userIds }) {
  // Validate the arguments to be what we expect

  new SimpleSchema({
    userIds: { type: [String] }
  }).validate({ userIds });

  // Select only the users that match the array of IDs passed in

  const selector = {
    _id: { $in: userIds }
  };

  // Only return one field, `initials`

  const options = {
    fields: { initials: 1 }
  };

  return Meteor.users.find(selector, options);
});</pre> <p>This publication will let the client pass an array of user IDs it’s interested in, and get the initials for all of those users.</p> <h2 id="roles-and-permissions">Roles and permissions</h2> <p>One of the main reasons you might want to add a login system to your app is to have permissions for your data. For example, if you were running a forum, you would want administrators or moderators to be able to delete any post, but normal users can only delete their own. This uncovers two different types of permissions:</p> <ol> <li>Role-based permissions</li> <li>Per-document permissions</li> </ol> <h3 id="alanning-roles">alanning:roles</h3> <p>The most popular package for role-based permissions in Meteor is <a href="https://atmospherejs.com/alanning/roles" target="_blank" rel="external"><code>alanning:roles</code></a>. For example, here is how you would make a user into an administrator, or a moderator:</p> <pre class="highlight js" data-language="js">// Give Alice the 'admin' role
Roles.addUsersToRoles(aliceUserId, 'admin', Roles.GLOBAL_GROUP);

// Give Bob the 'moderator' role for a particular category
Roles.addUsersToRoles(bobsUserId, 'moderator', categoryId);</pre> <p>Now, let’s say you wanted to check if someone was allowed to delete a particular forum post:</p> <pre class="highlight js" data-language="js">
const forumPost = Posts.findOne(postId);


const canDelete = Roles.userIsInRole(userId,
  ['admin', 'moderator'], forumPost.categoryId);


if (! canDelete) {
  throw new Meteor.Error('unauthorized',
    'Only admins and moderators can delete posts.');
}

Posts.remove(postId);</pre> <p>Note that we can check for multiple roles at once, and if someone has a role in the <code>GLOBAL_GROUP</code>, they are considered as having that role in every group. In this case, the groups were by category ID, but you could use any unique identifier to make a group.</p> <p>Read more in the <a href="https://atmospherejs.com/alanning/roles" target="_blank" rel="external"><code>alanning:roles</code> package documentation</a>.</p> <h3 id="per-document-permissions">Per-document permissions</h3> <p>Sometimes, it doesn’t make sense to abstract permissions into “groups” - you just want documents to have owners and that’s it. In this case, you can use a simpler strategy using collection helpers.</p> <pre class="highlight js" data-language="js">Lists.helpers({
  // ...

  editableBy(userId) {
    if (!this.userId) {
      return true;
    }

    return this.userId === userId;
  },
  // ...

});</pre> <p>Now, we can call this simple function to determine if a particular user is allowed to edit this list:</p> <pre class="highlight js" data-language="js">
const list = Lists.findOne(listId);


if (! list.editableBy(userId)) {
  throw new Meteor.Error('unauthorized',
    'Only list owners can edit private lists.');
}</pre> <p>Learn more about how to use collection helpers in the <a href="collections.html#collection-helpers">Collections article</a>.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2011&ndash;2017 Meteor Development Group, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://guide.meteor.com/accounts.html" class="_attribution-link">https://guide.meteor.com/accounts.html</a>
  </p>
</div>
