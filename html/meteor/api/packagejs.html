<h1 class="title-page">Package.js</h1> <div class="subtitle-page">Documentation of Meteor's package API.</div>    <p>A package is a directory containing a package.js file, which contains roughly three major sections: a basic description, a package definition, and a test definition. By default, the directory name is the name of the package.</p> <p>The <code>package.js</code> file below is an example of how to use the packaging API. The rest of this section will explain the specific API commands in greater detail.</p> <pre class="highlight js" data-language="js">// Information about this package:
Package.describe({
  // Short two-sentence summary

  summary: 'What this does',
  // Version number

  version: '1.0.0',
  // Optional, default is package directory name

  name: 'username:package-name',
  // Optional GitHub URL to your source repository

  git: 'https://github.com/something/something.git'

});

// This defines your actual package:
Package.onUse((api) =&gt; {
  // If no version is specified for an `api.use` dependency, use the one defined

  // in Meteor 1.4.3.1.

  api.versionsFrom('1.4.3.1');
  // Use the `underscore` package, but only on the server. Version not

  // specified, so it will be as of Meteor 1.4.3.1.

  api.use('underscore', 'server');
  // Use `kadira:flow-router`, version 2.12.1 or newer.

  api.use('kadira:flow-router@2.12.1');
  // Give users of this package access to active-route's JavaScript helpers.

  api.imply('zimme:active-route@2.3.2')
  // Export the object `Email` to packages or apps that use this package.

  api.export('Email', 'server');
  // Specify the source code for the package.

  api.addFiles('email.js', 'server');
  // When using `ecmascript` or `modules` packages, you can use this instead of

  // `api.export` and `api.addFiles`.

  api.mainModule('email.js', 'server');
});

// This defines the tests for the package:
Package.onTest((api) =&gt; {
  // Sets up a dependency on this package.

  api.use('username:package-name');
  // Use the Mocha test framework.

  api.use('practicalmeteor:mocha@2.4.5_2');
  // Specify the source code for the package tests.

  api.addFiles('email_tests.js', 'server');
});

// This lets you use npm packages in your package:
Npm.depends({
  simplesmtp: '0.3.10',
  'stream-buffers': '0.2.5'

});</pre> <p><code>api.mainModule</code> is documented in the <a href="http://docs.meteor.com/packages/modules.html#Modular-package-structure">modules</a> section.</p> <p>Build plugins are created with <a href="#PackageNamespace-registerBuildPlugin"><code>Package.registerBuildPlugin</code></a>. See the coffeescript package for an example. Build plugins are fully-fledged Meteor programs in their own right and have their own namespace, package dependencies, source files and npm requirements.</p> <blockquote> <p>You can use <a href="#writingpackages">local packages</a> to define custom build plugins for your app, with one caveat. In published packages, build plugins are already bundled with their transitive dependencies. So if you want a dependency of a build plugin to be satisfied by a local package, you must use a local copy of the package that defines the plugin (even if you make no changes to that package) so that Meteor will pick up the local dependency.</p> </blockquote> <p>Provide basic package information with <code>Package.describe(options)</code>. To publish a package, you must define <code>summary</code> and <code>version</code>.</p>  <h2 class="api-heading" id="PackageNamespace-describe"> <div class="locus"> package.js </div> <code>Package.describe(options)</code>  </h2>   <p>Provide basic package information.</p>  <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>summary</code> <span class="type">String</span> </dt> <dd> <p>A concise 1-2 sentence description of the package, required for publication.</p> </dd> <dt> <code>version</code> <span class="type">String</span> </dt> <dd> <p>The (extended) <a href="http://www.semver.org" target="_blank" rel="external">semver</a> version for your package. Additionally, Meteor allows a wrap number: a positive integer that follows the version number. If you are porting another package that uses semver versioning, you may want to use the original version, postfixed with <code>_wrapnumber</code>. For example, <code>1.2.3_1</code> or <code>2.4.5-rc1_4</code>. Wrap numbers sort after the original numbers: <code>1.2.3</code> &lt; <code>1.2.3_1</code> &lt; <code>1.2.3_2</code> &lt; <code>1.2.4-rc.0</code>. If no version is specified, this field defaults to <code>0.0.0</code>. If you want to publish your package to the package server, you must specify a version.</p> </dd> <dt> <code>name</code> <span class="type">String</span> </dt> <dd> <p>Optional name override. By default, the package name comes from the name of its directory.</p> </dd> <dt> <code>git</code> <span class="type">String</span> </dt> <dd> <p>Optional Git URL to the source repository.</p> </dd> <dt> <code>documentation</code> <span class="type">String</span> </dt> <dd> <p>Optional Filepath to documentation. Set to 'README.md' by default. Set this to null to submit no documentation.</p> </dd> <dt> <code>debugOnly</code> <span class="type">Boolean</span> </dt> <dd> <p>A package with this flag set to true will not be bundled into production builds. This is useful for packages meant to be used in development only.</p> </dd> <dt> <code>prodOnly</code> <span class="type">Boolean</span> </dt> <dd> <p>A package with this flag set to true will ONLY be bundled into production builds.</p> </dd> <dt> <code>testOnly</code> <span class="type">Boolean</span> </dt> <dd> <p>A package with this flag set to true will ONLY be bundled as part of <code>meteor test</code>.</p> </dd> </dl>   <p>Define dependencies and expose package methods with the <code>Package.onUse</code> handler. This section lets you define what packages your package depends on, what packages are implied by your package, and what object your package is exported to.</p>  <h2 class="api-heading" id="PackageNamespace-onUse"> <div class="locus"> package.js </div> <code>Package.onUse(func)</code>  </h2>   <p>Define package dependencies and expose package methods.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>func</code> <span class="type">Function</span> </dt> <dd> <p>A function that takes in the package control <code>api</code> object, which keeps track of dependencies and exports.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-versionsFrom"> <div class="locus"> package.js </div> <code>api.versionsFrom(meteorRelease)</code>  </h3>   <p>Use versions of core packages from a release. Unless provided, all packages will default to the versions released along with <code>meteorRelease</code>. This will save you from having to figure out the exact versions of the core packages you want to use. For example, if the newest release of meteor is <code>METEOR@0.9.0</code> and it includes <code>jquery@1.0.0</code>, you can write <code>api.versionsFrom('METEOR@0.9.0')</code> in your package, and when you later write <code>api.use('jquery')</code>, it will be equivalent to <code>api.use('jquery@1.0.0')</code>. You may specify an array of multiple releases, in which case the default value for constraints will be the "or" of the versions from each release: <code>api.versionsFrom(['METEOR@0.9.0',
'METEOR@0.9.5'])</code> may cause <code>api.use('jquery')</code> to be interpreted as <code>api.use('jquery@1.0.0 || 2.0.0')</code>.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>meteorRelease</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Specification of a release: track@version. Just 'version' (e.g. <code>"0.9.0"</code>) is sufficient if using the default release track <code>METEOR</code>. Can be an array of specifications.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-use"> <div class="locus"> package.js </div> <code>api.use(packageNames, [architecture], [options])</code>  </h3>   <p>Depend on package <code>packagename</code>.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>packageNames</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Packages being depended on. Package names may be suffixed with an @version tag.</p> <p>In general, you must specify a package's version (e.g., <code>'accounts@1.0.0'</code> to use version 1.0.0 or a higher compatible version (ex: 1.0.1, 1.5.0, etc.) of the <code>accounts</code> package). If you are sourcing core packages from a Meteor release with <code>versionsFrom</code>, you may leave off version names for core packages. You may also specify constraints, such as <code>my:forms@=1.0.0</code> (this package demands <code>my:forms</code> at <code>1.0.0</code> exactly), or <code>my:forms@1.0.0 || =2.0.1</code> (<code>my:forms</code> at <code>1.x.y</code>, or exactly <code>2.0.1</code>).</p> </dd> <dt> <code>architecture</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>If you only use the package on the server (or the client), you can pass in the second argument (e.g., <code>'server'</code>, <code>'client'</code>, <code>'web.browser'</code>, <code>'web.cordova'</code>) to specify what architecture the package is used with. You can specify multiple architectures by passing in an array, for example <code>['web.cordova', 'os.linux']</code>.</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>weak</code> <span class="type">Boolean</span> </dt> <dd> <p>Establish a weak dependency on a package. If package A has a weak dependency on package B, it means that including A in an app does not force B to be included too — but, if B is included or by another package, then B will load before A. You can use this to make packages that optionally integrate with or enhance other packages if those packages are present. When you weakly depend on a package you don't see its exports. You can detect if the possibly-present weakly-depended-on package is there by seeing if <code>Package.foo</code> exists, and get its exports from the same place.</p> </dd> <dt> <code>unordered</code> <span class="type">Boolean</span> </dt> <dd> <p>It's okay to load this dependency after your package. (In general, dependencies specified by <code>api.use</code> are loaded before your package.) You can use this option to break circular dependencies.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-imply"> <div class="locus"> package.js </div> <code>api.imply(packageNames, [architecture])</code>  </h3>   <p>Give users of this package access to another package (by passing in the string <code>packagename</code>) or a collection of packages (by passing in an array of strings [<code>packagename1</code>, <code>packagename2</code>]</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>packageNames</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Name of a package, or array of package names, with an optional @version component for each.</p> </dd> <dt> <code>architecture</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>If you only use the package on the server (or the client), you can pass in the second argument (e.g., <code>'server'</code>, <code>'client'</code>, <code>'web.browser'</code>, <code>'web.cordova'</code>) to specify what architecture the package is used with. You can specify multiple architectures by passing in an array, for example <code>['web.cordova',
'os.linux']</code>.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-export"> <div class="locus"> package.js </div> <code>api.export(exportedObjects, [architecture], [exportOptions], exportOptions.testOnly)</code>  </h3>   <p>Export package-level variables in your package. The specified variables (declared without <code>var</code> in the source code) will be available to packages that use your package. If your package sets the <code>debugOnly</code>, <code>prodOnly</code> or <code>testOnly</code> options to <code>true</code> when it calls <code>Package.describe()</code>, then packages that use your package will need to use <code>Package["package-name"].ExportedVariableName</code> to access the value of an exported variable.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>exportedObjects</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Name of the object to export, or an array of object names.</p> </dd> <dt> <code>architecture</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>If you only want to export the object on the server (or the client), you can pass in the second argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the export is used with. You can specify multiple architectures by passing in an array, for example <code>['web.cordova',
'os.linux']</code>.</p> </dd> <dt> <code>exportOptions</code> <span class="type">Object</span> </dt>  <dt> <code>exportOptions.testOnly</code> <span class="type">Boolean</span> </dt> <dd> <p>If true, this symbol will only be exported when running tests for this package.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-addFiles"> <div class="locus"> package.js </div> <code>api.addFiles(filenames, [architecture], [options])</code>  </h3>   <p>Specify source code files for your package.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>filenames</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Paths to the source files.</p> </dd> <dt> <code>architecture</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>If you only want to use the file on the server (or the client), you can pass this argument (e.g., 'server', 'client', 'web.browser', 'web.cordova') to specify what architecture the file is used with. You can specify multiple architectures by passing in an array, for example <code>['web.cordova', 'os.linux']</code>. By default, the file will be loaded on both server and client.</p> </dd> </dl> <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>bare</code> <span class="type">Boolean</span> </dt> <dd> <p>If this file is JavaScript code or will be compiled into JavaScript code by a build plugin, don't wrap the resulting file in a closure. Has the same effect as putting a file into the <code>client/compatibility</code> directory in an app.</p> </dd> </dl>    <h3 class="api-heading" id="PackageAPI-addAssets"> <div class="locus"> package.js </div> <code>api.addAssets(filenames, architecture)</code>  </h3>   <p>Specify asset files for your package. They can be accessed via the <a href="#assets">Assets API</a> from the server, or at the URL <code>/packages/username_package-name/file-name</code> from the client, depending on the architecture passed.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>filenames</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Paths to the asset files.</p> </dd> <dt> <code>architecture</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Specify where this asset should be available (e.g., 'server', 'client', 'web.browser', 'web.cordova'). You can specify multiple architectures by passing in an array, for example <code>['web.cordova', 'os.linux']</code>.</p> </dd> </dl>   <p>Set up your tests with the <code>Package.onTest</code> handler, which has an interface that’s parallel to that of the <code>onUse</code> handler. The tests will need to depend on the package that you have just created. For example, if your package is the <code>email</code> package, you have to call <code>api.use('email')</code> in order to test the package.</p> <p>If you used <code>meteor create</code> to set up your package, Meteor will create the required scaffolding in <code>package.js</code>, and you’ll only need to add unit test code in the <code>_test.js</code> file that was created.</p>  <h2 class="api-heading" id="PackageNamespace-onTest"> <div class="locus"> package.js </div> <code>Package.onTest(func)</code>  </h2>   <p>Define dependencies and expose package methods for unit tests.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>func</code> <span class="type">Function</span> </dt> <dd> <p>A function that takes in the package control 'api' object, which keeps track of dependencies and exports.</p> </dd> </dl>   <p>Meteor packages can include NPM packages and Cordova plugins by using <code>Npm.depends</code> and <code>Cordova.depends</code> in the <code>package.js</code> file.</p>  <h2 class="api-heading" id="PackageNpm-depends"> <div class="locus"> package.js </div> <code>Npm.depends(dependencies)</code>  </h2>   <p>Specify which <a href="https://www.npmjs.org/" target="_blank" rel="external">NPM</a> packages your Meteor package depends on.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>dependencies</code> <span class="type">Object</span> </dt> <dd> <p>An object where the keys are package names and the values are one of:</p> <ol> <li>Version numbers in string form</li> <li>Http(s) URLs to a git commit by SHA.</li> <li>Git URLs in the format described <a href="https://docs.npmjs.com/files/package.json#git-urls-as-dependencies" target="_blank" rel="external">here</a>
</li> </ol> <p>Https URL example:</p> <pre class="prettyprint source lang-js" data-language="js">Npm.depends({
  moment: "2.8.3",
  async: "https://github.com/caolan/async/archive/71fa2638973dafd8761fa5457c472a312cc820fe.tar.gz"
});</pre>
<p>Git URL example:</p> <pre class="prettyprint source lang-js" data-language="js">Npm.depends({
  moment: "2.8.3",
  async: "git+https://github.com/caolan/async#master"
});</pre> </dd> </dl>    <h2 class="api-heading" id="Npm-require"> <div class="locus"> Server </div> <code>Npm.require</code>  </h2>   <p>Require a package that was specified using <code>Npm.depends()</code>.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>name</code> <span class="type">String</span> </dt> <dd> <p>The name of the package to require.</p> </dd> </dl>    <h2 class="api-heading" id="PackageCordova-depends"> <div class="locus"> package.js </div> <code>Cordova.depends(dependencies)</code>  </h2>   <p>Specify which <a href="http://cordova.apache.org/" target="_blank" rel="external">Cordova / PhoneGap</a> plugins your Meteor package depends on.</p> <p>Plugins are installed from <a href="http://plugins.cordova.io/" target="_blank" rel="external">plugins.cordova.io</a>, so the plugins and versions specified must exist there. Alternatively, the version can be replaced with a GitHub tarball URL as described in the <a href="https://guide.meteor.com/mobile.html#cordova-plugins" target="_blank" rel="external">Cordova</a> page of the Meteor wiki on GitHub.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>dependencies</code> <span class="type">Object</span> </dt> <dd> <p>An object where the keys are plugin names and the values are version numbers or GitHub tarball URLs in string form. Example:</p> <pre class="prettyprint source lang-js" data-language="js">Cordova.depends({
  "org.apache.cordova.camera": "0.3.0"
});</pre>
<p>Alternatively, with a GitHub URL:</p> <pre class="prettyprint source lang-js" data-language="js">Cordova.depends({
  "org.apache.cordova.camera":
    "https://github.com/apache/cordova-plugin-camera/tarball/d84b875c449d68937520a1b352e09f6d39044fbf"
});</pre> </dd> </dl>    <h2 class="api-heading" id="PackageNamespace-registerBuildPlugin"> <div class="locus"> package.js </div> <code>Package.registerBuildPlugin([options])</code>  </h2>   <p>Define a build plugin. A build plugin extends the build process for apps and packages that use this package. For example, the <code>coffeescript</code> package uses a build plugin to compile CoffeeScript source files into JavaScript.</p>  <h4 class="subheading">Options</h4> <dl class="args"> <dt> <code>name</code> <span class="type">String</span> </dt> <dd> <p>A cosmetic name, must be unique in the package.</p> </dd> <dt> <code>use</code> <span class="type">String or Array of Strings</span> </dt> <dd> <p>Meteor packages that this plugin uses, independent of the packages specified in <a href="#pack_onUse">api.onUse</a>.</p> </dd> <dt> <code>sources</code> <span class="type">Array of Strings</span> </dt> <dd> <p>The source files that make up the build plugin, independent from <a href="#pack_addFiles">api.addFiles</a>.</p> </dd> <dt> <code>npmDependencies</code> <span class="type">Object</span> </dt> <dd> <p>An object where the keys are NPM package names, and the values are the version numbers of required NPM packages, just like in <a href="#Npm-depends">Npm.depends</a>.</p> </dd> </dl>    <h3 class="api-heading" id="Plugin-registerSourceHandler"> <div class="locus"> Build Plugin </div> <code>Plugin.registerSourceHandler(fileExtension, handler)</code>  </h3>   <p>Inside a build plugin source file specified in <a href="#Package-registerBuildPlugin">Package.registerBuildPlugin</a>, add a handler to compile files with a certain file extension.</p>  <h4 class="subheading">Arguments</h4> <dl class="args"> <dt> <code>fileExtension</code> <span class="type">String</span> </dt> <dd> <p>The file extension that this plugin should handle, without the first dot. Examples: <code>"coffee"</code>, <code>"coffee.md"</code>.</p> </dd> <dt> <code>handler</code> <span class="type">Function</span> </dt> <dd> <p>A function that takes one argument, a CompileStep object.</p> <p>Documentation for CompileStep is available <a href="https://github.com/meteor/meteor/wiki/CompileStep-API-for-Build-Plugin-Source-Handlers" target="_blank" rel="external">on the GitHub Wiki</a>.</p> </dd> </dl>   <h2 id="build-plugin-api">Build Plugins API</h2> <p>Meteor packages can provide build plugins - programs that integrate with the build tool Isobuild used to compile and bundle your application.</p> <p>Starting with Meteor 1.2, the API used to plug into the build process is called “Build Plugins”. There are 3 phases when a package’s plugin can run: linting, compilation and minification. Here is an overview of operations Isobuild performs on the application and packages source:</p> <ol> <li>Gather source files from the app folder or read <code>package.js</code> file for a package.</li> <li>Lint all source files and print the linting warnings.</li> <li>Compile the source files like CoffeeScript, ES2015, Less, or Templates to plain JavaScript and CSS.</li> <li>Link the JavaScript files: wrap them into closures and provide necessary package imports.</li> <li>Minify JavaScript and CSS files. Can also include concatenation of all files.</li> </ol> <p>Build plugins fill the phases 2, 3 and 5.</p> <p>Usually build plugins implement a class that is given a list of files to process. Commonly, such files have the following methods:</p> <ul> <li>
<code>getContentsAsBuffer</code> - Returns the full contents of the file as a buffer.</li> <li>
<code>getContentsAsString</code> - Returns the full contents of the file as a string.</li> <li>
<code>getPackageName</code> - Returns the name of the package or <code>null</code> if the file is not in a package.</li> <li>
<code>getPathInPackage</code> - Returns the relative path of file to the package or app root directory. The returned path always uses forward slashes.</li> <li>
<code>getSourceHash</code> - Returns a hash string for the file that can be used to implement caching.</li> <li>
<code>getArch</code> - Returns the architecture that is targeted while processing this file.</li> <li>
<code>getBasename</code> - Returns the filename of the file.</li> <li>
<code>getDirname</code> - Returns the directory path relative to the package or app root. The returned path always uses forward slashes.</li> <li>
<code>error</code> - Call this method to raise a compilation or linting error for the file.</li> </ul> <h3 id="build-plugin-linters">Linters</h3> <p>Linters are programs that check the code for undeclared variables or find code that doesn’t correspond to certain style guidelines. Some of the popular examples of linters are <a href="http://jshint.com/about/" target="_blank" rel="external">JSHint</a> and <a href="http://eslint.org/" target="_blank" rel="external">ESLint</a>. Some of the non-JavaScript linter examples include <a href="http://www.coffeelint.org/" target="_blank" rel="external">CoffeeLint</a> for CoffeeScript and <a href="http://csslint.net/" target="_blank" rel="external">CSSLint</a> for CSS.</p> <p>To register a linter build plugin in your package, you need to do a couple of things in your <code>package.js</code>:</p> <ul> <li>depend on the <code>isobuild:linter-plugin@1.0.0</code> package</li> <li>register a build plugin: <code>Package.registerBuildPlugin({ name, sources, ... });</code> (see <a href="#">docs</a>)</li> </ul> <p>In your build plugin sources, register a Linter Plugin: provide details such as a name, list of extensions and filenames the plugin will handle and a factory function that returns an instance of a linter class. Example:</p> <pre class="highlight js" data-language="js">Plugin.registerLinter({
  extensions: ['js'],
  filenames: ['.linterrc']
}, () =&gt; new MyLinter);</pre> <p>In this example, we register a linter that runs on all <code>js</code> files and also reads a file named <code>.linterrc</code> to get a configuration.</p> <p>The <code>MyLinter</code> class should now implement the <code>processFilesForPackage</code> method. The method should accept two arguments: a list of files and an options object.</p> <pre class="highlight js" data-language="js">
class MyLinter {
  processFilesForPackage(files, options) {
    files.forEach((file) =&gt; {
      // Lint the file.

      const lint = lintFile(file.getContentsAsString());

      if (lint) {
        // If there are linting errors, output them.

        const { message, line, column } = lint;
        file.error({ message, line, column });
      }
    });
  }
}</pre> <p>The globals are passed in the options object so that the linters can omit the warnings about the package imports that look like global variables.</p> <p>Each file in the list is an object that has all the methods provided by all build plugins, described above.</p> <p>See an example of a linting plugin implemented in Core: <a href="https://github.com/meteor/meteor/tree/devel/packages/jshint" target="_blank" rel="external">jshint</a>.</p> <h3 id="build-plugin-compilers">Compilers</h3> <p>Compilers are programs that take the source files and output JavaScript or CSS. They also can output parts of HTML that is added to the <code>&lt;head&gt;</code> tag and static assets. Examples for the compiler plugins are: CoffeeScript, Babel.js, JSX compilers, Pug templating compiler and others.</p> <p>To register a compiler plugin in your package, you need to do the following in your <code>package.js</code> file:</p> <ul> <li>depend on the <code>isobuild:compiler-plugin@1.0.0</code> package</li> <li>register a build plugin: <code>Package.registerBuildPlugin({ name, sources, ... });</code> (see <a href="#">docs</a>)</li> </ul> <p>In your build plugin source, register a Compiler Plugin: similar to other types of build plugins, provide the details, extensions and filenames and a factory function that returns an instance of the compiler. Ex.:</p> <pre class="highlight js" data-language="js">Plugin.registerCompiler({
  extensions: ['pug', 'tpl.pug'],
  filenames: []
}, () =&gt; new PugCompiler);</pre> <p>The compiler class must implement the <code>processFilesForTarget</code> method that is given the source files for a target (server or client part of the package/app).</p> <pre class="highlight js" data-language="js">
class PugCompiler {
  processFilesForTarget(files) {
    files.forEach((file) =&gt; {
      // Process and add the output.

      const output = compilePug(file.getContentsAsString());

      file.addJavaScript({
        data: output,
        path: `${file.getPathInPackage()}.js`

      });
    });
  }
}</pre> <p>Besides the common methods available on the input files’ class, the following methods are available:</p> <ul> <li>
<code>getExtension</code> - Returns the extension that matched the compiler plugin. The longest prefix is preferred.</li> <li>
<code>getDeclaredExports</code> - Returns a list of symbols declared as exports in this target. The result of <code>api.export('symbol')</code> calls in target’s control file such as package.js.</li> <li>
<code>getDisplayPath</code> Returns a relative path that can be used to form error messages or other display properties. Can be used as an input to a source map.</li> <li>
<code>addStylesheet</code> - Web targets only. Add a stylesheet to the document. Not available for linter build plugins.</li> <li>
<code>addJavaScript</code> - Add JavaScript code. The code added will only see the namespaces imported by this package as runtime dependencies using <a href="#PackageAPI-use">‘api.use’</a>. If the file being compiled was added with the bare flag, the resulting JavaScript won’t be wrapped in a closure.</li> <li>
<code>addAsset</code> - Add a file to serve as-is to the browser or to include on the browser, depending on the target. On the web, it will be served at the exact path requested. For server targets, it can be retrieved using <code>Assets.getText</code> or <code>Assets.getBinary</code>.</li> <li>
<code>addHtml</code> - Works in web targets only. Add markup to the <code>head</code> or <code>body</code> section of the document.</li> </ul> <p>Meteor implements a couple of compilers as Core packages, good examples would be the <a href="https://github.com/meteor/meteor/tree/devel/packages/templating" target="_blank" rel="external">Blaze templating</a> package and the <a href="https://github.com/meteor/meteor/tree/devel/packages/ecmascript" target="_blank" rel="external">ecmascript</a> package (compiles ES2015+ to JavaScript that can run in the browsers).</p> <h3 id="build-plugin-minifiers">Minifiers</h3> <p>Minifiers run last after the sources has been compiled and JavaScript code has been linked. Minifiers are only ran for the client programs (<code>web.browser</code> and <code>web.cordova</code>).</p> <p>There are two types of minifiers one can add: a minifier processing JavaScript (registered extensions: <code>['js']</code>) and a minifier processing CSS (extensions: <code>['css']</code>).</p> <p>To register a minifier plugin in your package, add the following in your <code>package.js</code> file:</p> <ul> <li>depend on <code>isobuild:minifier-plugin@1.0.0</code> package</li> <li>register a build plugin: <code>Package.registerBuildPlugin({ name, sources, ... });</code> (see <a href="#">docs</a>)</li> </ul> <p>In your build plugin source, register a Minifier Plugin. Similar to Linter and Compiler plugin, specify the interested extensions (<code>css</code> or <code>js</code>). The factory function returns an instance of the minifier class.</p> <pre class="highlight js" data-language="js">Plugin.registerMinifier({
  extensions: ['js']
}, () =&gt; new UglifyJsMinifier);</pre> <p>The minifier class must implement the method <code>processFilesForBundle</code>. The first argument is a list of processed files and the options object specifies if the minifier is ran in production mode or development mode.</p> <pre class="highlight js" data-language="js">
class UglifyJsMinifier {
  processFilesForBundle(files, options) {
    const { minifyMode } = options;

    if (minifyMode === 'development') {
      // Don't minify in development.

      file.forEach((file) =&gt; {
        file.addJavaScript({
          data: file.getContentsAsBuffer(),
          sourceMap: file.getSourceMap(),
          path: file.getPathInBundle()
        });
      });

      return;
    }

    // Minify in production.

    files.forEach((file) =&gt; {
      file.addJavaScript({
        data: uglifyjs.minify(file.getContentsAsBuffer()),
        path: file.getPathInBundle()
      });
    });
  }
}</pre> <p>In this example, we re-add the same files in the development mode to avoid unnecessary work and then we minify the files in production mode.</p> <p>Besides the common input files’ methods, these methods are available:</p> <ul> <li>
<code>getPathInBundle</code> - returns a path of the processed file in the bundle.</li> <li>
<code>getSourceMap</code> - returns the source-map for the processed file if there is such.</li> <li>
<code>addJavaScript</code> - same as compilers</li> <li>
<code>addStylesheet</code> - same as compilers</li> </ul> <p>Right now, Meteor Core ships with the <code>standard-minifiers</code> package that can be replaced with a custom one. The <a href="https://github.com/meteor/meteor/tree/devel/packages/standard-minifiers" target="_blank" rel="external">source</a> of the package is a good example how to build your own minification plugin.</p> <h3 id="build-plugin-caching">Caching</h3> <p>Since the API allows build plugins to process multiple files at once, we encourage package authors to implement at least some in-memory caching for their plugins. Using the <code>getSourceHash</code> function for linters and compilers will allow quick incremental recompilations if the file is not reprocessed even when the contents didn’t change.</p> <p>For the fast rebuilds between the Isobuild process runs, plugins can implement on-disk caching. If a plugin implements the <code>setDiskCacheDirectory</code> method, it will be called from time to time with a new path on disk where the plugin can write its offline cache. The folder is correctly reset when the plugin is rebuilt or cache should be invalidated for any reason (for example, picked package versions set has changed).</p> <h4 id="build-plugin-caching-compiler">Caching Compiler</h4> <p>There is a core package called <code>caching-compiler</code> that implements most of the common logic of keeping both in-memory and on-disk caches. The easiest way to implement caching correctly is to subclass the <code>CachingCompiler</code> or <code>MultiFileCachingCompiler</code> class from this package in your build plugin. <code>CachingCompiler</code> is for compilers that consider each file completely independently; <code>MultiFileCachingCompiler</code> is for compilers that allow files to reference each other. To get this class in your plugin namespace, add a dependency to the plugin definition:</p> <pre class="highlight js" data-language="js">Package.registerBuildPlugin({
  name: 'compileGG',
  use: ['caching-compiler@1.0.0'],
  sources: ['plugin/compile-gg.js']
});</pre> <h3 id="build-plugin-file-system">Accessing File System</h3> <p>Since the build plugins run as part of the Meteor tool, they follow the same file-system access convention - all file system paths always look like a Unix path: using forward slashes and having a root at ‘/‘, even on Windows. For example: paths <code>/usr/bin/program</code> and <code>/C/Program Files/Program/program.exe</code> are valid paths, and <code>C:\Program Files\Program\program.exe</code> is not.</p> <p>So whenever you get a path in your build plugin implementation, via <code>getPathInPackage</code> or in an argument of the <code>setDiskCacheDirectory</code> method, the path will be a Unix path.</p> <p>Now, on running on Windows, the usual node modules <code>fs</code> and <code>path</code> expect to get a DOS path. To assist you to write correct code, the <code>Plugin</code> symbol provides its own versions of <code>fs</code> and <code>path</code> that you can use instead (note that all methods on <code>fs</code> are fiberized and sync versions prefer using Fibers rather than freezing the whole event loop).</p> <p>Also <code>Plugin</code> provides helper functions <code>convertToStandardPath</code> and <code>convertToOSPath</code> to convert to a Unix path or to the path expected by the node libraries regardless of the path origin.</p> <p>Example:</p> <pre class="highlight js" data-language="js">// On Windows

const fs = Plugin.fs;

const path = Plugin.path;


const filePath = path.join('/C/Program Files', 'Program/file.txt');

console.log(filePath); // Prints '/C/Program Files/Program/file.txt'


fs.writeFileSync(filePath, 'Hello.'); // Writes to 'C:\Program Files\Program\file.txt'



console.log(Plugin.convertToOsPath(filePath)); // Prints 'C:\Program Files\Program\file.txt'
</pre> <h2 id="isobuild-features">Isobuild Feature Packages</h2> <p>Starting with Meteor 1.2, packages can declare that they need a version of the Meteor tool whose Isobuild build system supports a certain feature. For example, packages must write <code>api.use('isobuild:compiler-plugin@1.0.0')</code> in order to call <code>Plugin.registerCompiler</code>. This means that a package can transition from the old <code>registerSourceHandler</code> API to <code>registerCompiler</code> and Version Solver will properly prevent the <code>registerCompiler</code> version from being chosen by older tools that don’t know how to handle it.</p> <p>This is the known Isobuild feature “packages” sorted by the first release of Meteor which supports them.</p> <h3 id="isobuild-features-1.2">Introduced in Meteor 1.2</h3> <ul> <li>
<code>compiler-plugin@1.0.0</code>: Allows use of <code>Plugin.registerCompiler</code>.</li> <li>
<code>linter-plugin@1.0.0</code>: Allows use of <code>Plugin.registerLinter</code>.</li> <li>
<code>minifier-plugin@1.0.0</code>: Allows use of <code>Plugin.registerMinifier</code>.</li> <li>
<code>isopack-2@1.0.0</code>: This package is published only in <code>isopack-2</code> format and won’t work in versions of Meteor that don’t support that format.</li> <li>
<code>prod-only@1.0.0</code>: Allows use of the <code>prodOnly</code> flag in <code>Package.describe</code>.</li> <li>
<code>isobuild:cordova@5.4.0</code>: This package depends on a specific version of Cordova, most likely as a result of the Cordova plugins it depends on.</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2011&ndash;2017 Meteor Development Group, Inc.<br>Licensed under the MIT License.<br>
    <a href="https://docs.meteor.com/api/packagejs.html" class="_attribution-link">https://docs.meteor.com/api/packagejs.html</a>
  </p>
</div>
