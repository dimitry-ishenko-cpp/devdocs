<h1 id="explicit-namespaces">6.3.4. Explicit namespaces in import/export</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="explicit-namespaces-in-import-export"> <dt id="extension-ExplicitNamespaces">
<code>ExplicitNamespaces</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> <p>Enable use of explicit namespaces in module export lists.</p> </dd>
</dl> <p>In an import or export list, such as</p> <pre data-language="haskell">module M( f, (++) ) where ...
  import N( f, (++) )
  ...
</pre> <p>the entities <code>f</code> and <code>(++)</code> are <em>values</em>. However, with type operators (<a class="reference internal" href="type_operators.html#type-operators"><span class="std std-ref">Type operators</span></a>) it becomes possible to declare <code>(++)</code> as a <em>type constructor</em>. In that case, how would you export or import it?</p> <p>The <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> extension allows you to prefix the name of a type constructor in an import or export list with “<code>type</code>” to disambiguate this case, thus:</p> <pre data-language="haskell">module M( f, type (++) ) where ...
  import N( f, type (++) )
  ...
module N( f, type (++) ) where
  data family a ++ b = L a | R b
</pre> <p>The extension <a class="reference internal" href="#extension-ExplicitNamespaces"><code>ExplicitNamespaces</code></a> is implied by <a class="reference internal" href="type_operators.html#extension-TypeOperators"><code>TypeOperators</code></a> and (for some reason) by <a class="reference internal" href="type_families.html#extension-TypeFamilies"><code>TypeFamilies</code></a>.</p> <p>In addition, with <a class="reference internal" href="pattern_synonyms.html#extension-PatternSynonyms"><code>PatternSynonyms</code></a> you can prefix the name of a data constructor in an import or export list with the keyword <code>pattern</code>, to allow the import or export of a data constructor without its parent type constructor (see <a class="reference internal" href="pattern_synonyms.html#patsyn-impexp"><span class="std std-ref">Import and export of pattern synonyms</span></a>).</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/explicit_namespaces.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/explicit_namespaces.html</a>
  </p>
</div>
