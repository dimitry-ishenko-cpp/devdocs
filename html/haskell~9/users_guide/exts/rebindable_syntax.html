<h1 id="rebindable-syntax">6.2.10. Rebindable syntax and the implicit Prelude import</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="rebindable-syntax-and-the-implicit-prelude-import"> <dt id="extension-NoImplicitPrelude">
<code>NoImplicitPrelude</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Don’t import <code>Prelude</code> by default.</p> </dd>
</dl> <p>GHC normally imports <code>Prelude.hi</code> files for you. If you’d rather it didn’t, then give it a <code>-XNoImplicitPrelude</code> option. The idea is that you can then import a Prelude of your own. (But don’t call it <code>Prelude</code>; the Haskell module namespace is flat, and you must not conflict with any Prelude module.)</p> <dl class="extension"> <dt id="extension-RebindableSyntax">
<code>RebindableSyntax</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.0.1</td> </tr>  </table> <p>Enable rebinding of a variety of usually-built-in operations.</p> </dd>
</dl> <p>Suppose you are importing a Prelude of your own in order to define your own numeric class hierarchy. It completely defeats that purpose if the literal “1” means “<code>Prelude.fromInteger 1</code>”, which is what the Haskell Report specifies. So the <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> extension causes the following pieces of built-in syntax to refer to <em>whatever is in scope</em>, not the Prelude versions:</p> <ul class="simple"> <li>An integer literal <code>368</code> means “<code>fromInteger (368::Integer)</code>”, rather than “<code>Prelude.fromInteger (368::Integer)</code>”.</li> <li>Fractional literals are handled in just the same way, except that the translation is <code>fromRational (3.68::Rational)</code>.</li> <li>String literals are also handled the same way, except that the translation is <code>fromString ("368"::String)</code>.</li> <li>The equality test in an overloaded numeric pattern uses whatever <code>(==)</code> is in scope.</li> <li>The subtraction operation, and the greater-than-or-equal test, in <code>n+k</code> patterns use whatever <code>(-)</code> and <code>(&gt;=)</code> are in scope.</li> <li>Negation (e.g. “<code>- (f x)</code>”) means “<code>negate (f x)</code>”, both in numeric patterns, and expressions.</li> <li>Conditionals (e.g. “<code>if</code> e1 <code>then</code> e2 <code>else</code> e3”) means “<code>ifThenElse</code> e1 e2 e3”. However <code>case</code> expressions are unaffected.</li> <li>“Do” notation is translated using whatever functions <code>(&gt;&gt;=)</code>, <code>(&gt;&gt;)</code>, and <code>fail</code>, are in scope (not the Prelude versions). List comprehensions, <code>mdo</code> (<a class="reference internal" href="recursive_do.html#recursive-do-notation"><span class="std std-ref">The recursive do-notation</span></a>), and parallel array comprehensions, are unaffected.</li> <li>Arrow notation (see <a class="reference internal" href="arrows.html#arrow-notation"><span class="std std-ref">Arrow notation</span></a>) uses whatever <code>arr</code>, <code>(&gt;&gt;&gt;)</code>, <code>first</code>, <code>app</code>, <code>(|||)</code> and <code>loop</code> functions are in scope. But unlike the other constructs, the types of these functions must match the Prelude types very closely. Details are in flux; if you want to use this, ask!</li> <li>List notation, such as <code>[x,y]</code> or <code>[m..n]</code> can also be treated via rebindable syntax if you use <code>-XOverloadedLists</code>; see <a class="reference internal" href="overloaded_lists.html#overloaded-lists"><span class="std std-ref">Overloaded lists</span></a>.</li> <li>An overloaded label “<code>#foo</code>” means “<code>fromLabel @"foo"</code>”, rather than “<code>GHC.OverloadedLabels.fromLabel @"foo"</code>” (see <a class="reference internal" href="overloaded_labels.html#overloaded-labels"><span class="std std-ref">Overloaded labels</span></a>).</li> </ul> <p><a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> implies <a class="reference internal" href="#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a>.</p> <p>In all cases (apart from arrow notation), the static semantics should be that of the desugared form, even if that is a little unexpected. For example, the static semantics of the literal <code>368</code> is exactly that of <code>fromInteger (368::Integer)</code>; it’s fine for <code>fromInteger</code> to have any of the types:</p> <pre data-language="haskell">fromInteger :: Integer -&gt; Integer
fromInteger :: forall a. Foo a =&gt; Integer -&gt; a
fromInteger :: Num a =&gt; a -&gt; Integer
fromInteger :: Integer -&gt; Bool -&gt; Bool
</pre> <p>Be warned: this is an experimental facility, with fewer checks than usual. Use <code>-dcore-lint</code> to typecheck the desugared program. If Core Lint is happy you should be all right.</p>  <h2 id="things-unaffected-by-rebindablesyntax">6.2.10.1. Things unaffected by RebindableSyntax</h2> <p><a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> does not apply to any code generated from a <code>deriving</code> clause or declaration. To see why, consider the following code:</p> <pre data-language="haskell">{-# LANGUAGE RebindableSyntax, OverloadedStrings #-}
newtype Text = Text String

fromString :: String -&gt; Text
fromString = Text

data Foo = Foo deriving Show
</pre> <p>This will generate code to the effect of:</p> <pre data-language="haskell">instance Show Foo where
  showsPrec _ Foo = showString "Foo"
</pre> <p>But because <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> and <a class="reference internal" href="overloaded_strings.html#extension-OverloadedStrings"><code>OverloadedStrings</code></a> are enabled, the <code>"Foo"</code> string literal would now be of type <code>Text</code>, not <code>String</code>, which <code>showString</code> doesn’t accept! This causes the generated <code>Show</code> instance to fail to typecheck. It’s hard to imagine any scenario where it would be desirable have <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> behavior within derived code, so GHC simply ignores <a class="reference internal" href="#extension-RebindableSyntax"><code>RebindableSyntax</code></a> entirely when checking derived code.</p>    <h1 id="id1">6.2.11. Postfix operators</h1> <dl class="extension" id="postfix-operators"> <dt id="extension-PostfixOperators">
<code>PostfixOperators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10.1</td> </tr>  </table> <p>Allow the use of post-fix operators</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-PostfixOperators"><code>PostfixOperators</code></a> extension enables a small extension to the syntax of left operator sections, which allows you to define postfix operators. The extension is this: for any expression <code>e</code> and operator <code>(!)</code>, the left section</p> <pre data-language="haskell">(e !)
</pre> <p>is equivalent (from the point of view of both type checking and execution) to the expression</p> <pre data-language="haskell">((!) e)
</pre> <p>The strict Haskell 98 interpretation is that the section is equivalent to</p> <pre data-language="haskell">(\y -&gt; (!) e y)
</pre> <p>That is, the operator must be a function of two arguments. GHC allows it to take only one argument, and that in turn allows you to write the function postfix.</p> <p>The extension does not extend to the left-hand side of function definitions; you must define such a function in prefix form.</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/rebindable_syntax.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/rebindable_syntax.html</a>
  </p>
</div>
