<h1 id="ffi">6.17. Foreign function interface (FFI)</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="foreign-function-interface-ffi"> <dt id="extension-ForeignFunctionInterface">
<code>ForeignFunctionInterface</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of the Haskell foreign function interface.</p> </dd>
</dl> <p>GHC (mostly) conforms to the Haskell Foreign Function Interface as specified in the Haskell Report. Refer to the <a class="reference external" href="https://www.haskell.org/onlinereport/haskell2010/haskellch8.html">relevant chapter</a> of the Haskell Report for more details.</p> <p>FFI support is enabled by default, but can be enabled or disabled explicitly with the <a class="reference internal" href="#extension-ForeignFunctionInterface"><code>ForeignFunctionInterface</code></a> flag.</p> <p>GHC implements a number of GHC-specific extensions to the FFI Chapter of the Haskell 2010 Report. These extensions are described in <a class="reference internal" href="#ffi-ghcexts"><span class="std std-ref">GHC extensions to the FFI Chapter</span></a>, but please note that programs using these features are not portable. Hence, these features should be avoided where possible.</p> <p>The FFI libraries are documented in the accompanying library documentation; see for example the <a class="reference external" href="../../libraries/base-4.17.0.0/foreign.html">Foreign</a> module.</p>  <h2 id="ghc-differences-to-the-ffi-chapter">6.17.1. GHC differences to the FFI Chapter</h2>  <h3 id="guaranteed-call-safety">6.17.1.1. Guaranteed call safety</h3> <p>The Haskell 2010 Report specifies that <code>safe</code> FFI calls must allow foreign calls to safely call into Haskell code. In practice, this means that called functions also have to assume heap-allocated Haskell values may move around arbitrarily in order to allow for GC.</p> <p>This greatly constrains library authors since it implies that it is not safe to pass any heap object reference to a <code>safe</code> foreign function call. For instance, it is often desirable to pass <a class="reference internal" href="#pinned-byte-arrays"><span class="std std-ref">unpinned</span></a> <code>ByteArray#</code>s directly to native code to avoid making an otherwise-unnecessary copy. However, this can not be done safely for <code>safe</code> calls since the array might be moved by the garbage collector in the middle of the call.</p> <p>The Chapter <em>does</em> allow for implementations to move objects around during <code>unsafe</code> calls as well. So strictly Haskell 2010-conforming programs cannot pass heap-allocated references to <code>unsafe</code> FFI calls either.</p> <p>GHC, since version 8.4, <strong>guarantees</strong> that garbage collection will never occur during an <code>unsafe</code> call, even in the bytecode interpreter, and further guarantees that <code>unsafe</code> calls will be performed in the calling thread. Making it safe to pass heap-allocated objects to unsafe functions.</p> <p>In previous releases, GHC would take advantage of the freedom afforded by the Chapter by performing <code>safe</code> foreign calls in place of <code>unsafe</code> calls in the bytecode interpreter. This meant that some packages which worked when compiled would fail under GHCi (e.g. <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/13730">#13730</a>). But this is no longer the case in recent releases.</p>   <h3 id="interactions-between-safe-calls-and-bound-threads">6.17.1.2. Interactions between <code>safe</code> calls and bound threads</h3> <p>A <code>safe</code> call calling into haskell is run on a bound thread by the RTS. This means any nesting of <code>safe</code> calls will be executed on the same operating system thread. <em>Sequential</em> <code>safe</code> calls however do not enjoy this luxury and may be run on arbitrary OS threads.</p> <p>This behaviour is considered an implementation detail and code relying on thread local state should instead use one of the interfaces provided in <a class="reference external" href="../../libraries/base-4.17.0.0/control-concurrent.html">Control.Concurrent</a> to make this explicit.</p> <p>For information on what bound threads are, see the documentation for the <a class="reference external" href="../../libraries/base-4.17.0.0/control-concurrent.html">Control.Concurrent</a>.</p> <p>For more details on the implementation see the Paper: “Extending the Haskell Foreign Function Interface with Concurrency”. Last known to be accessible <a class="reference external" href="https://www.microsoft.com/en-us/research/wp-content/uploads/2004/09/conc-ffi.pdf">here</a>.</p>   <h3 id="varargs-not-supported-by-ccall-calling-convention">6.17.1.3. Varargs not supported by <code>ccall</code> calling convention</h3> <p>Note that functions requiring varargs arguments are unsupported by the <code>ccall</code> calling convention. Foreign imports needing to call such functions should rather use the <code>capi</code> convention, giving an explicit signature for the needed call-pattern. For instance, one could write:</p> <pre data-language="haskell">foreign import "capi" "printf"
    my_printf :: Ptr CChar -&gt; CInt -&gt; IO ()

printInt :: CInt -&gt; IO ()
printInt n = my_printf "printed number %d" n
</pre>    <h2 id="ffi-ghcexts">6.17.2. GHC extensions to the FFI Chapter</h2> <p id="ghc-extensions-to-the-ffi-chapter">The FFI features that are described in this section are specific to GHC. Your code will not be portable to other compilers if you use them.</p>  <h3 id="ffi-unlifted-types">6.17.2.1. Unlifted FFI Types</h3> <dl class="extension" id="unlifted-ffi-types"> <dt id="extension-UnliftedFFITypes">
<code>UnliftedFFITypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> </dd>
</dl> <p>The following unlifted unboxed types may be used as basic foreign types (see FFI Chapter, Section 8.6) for both <code>safe</code> and <code>unsafe</code> foreign calls: <code>Int#</code>, <code>Word#</code>, <code>Char#</code>, <code>Float#</code>, <code>Double#</code>, <code>Addr#</code>, and <code>StablePtr# a</code>. Several unlifted boxed types may be used as arguments to FFI calls, subject to these restrictions:</p> <ul class="simple"> <li>Valid arguments for <code>foreign import unsafe</code> FFI calls: <code>Array#</code>, <code>SmallArray#</code>, <code>ArrayArray#</code>, <code>ByteArray#</code>, and the mutable counterparts of these types.</li> <li>Valid arguments for <code>foreign import safe</code> FFI calls: <code>ByteArray#</code> and <code>MutableByteArray#</code>. The byte array must be <a class="reference internal" href="#pinned-byte-arrays"><span class="std std-ref">pinned</span></a>.</li> <li>Mutation: In both <code>foreign import unsafe</code> and <code>foreign import safe</code> FFI calls, it is safe to mutate a <code>MutableByteArray</code>. Mutating any other type of array leads to undefined behavior. Reason: Mutable arrays of heap objects record writes for the purpose of garbage collection. An array of heap objects is passed to a foreign C function, the runtime does not record any writes. Consequently, it is not safe to write to an array of heap objects in a foreign function. Since the runtime has no facilities for tracking mutation of a <code>MutableByteArray#</code>, these can be safely mutated in any foreign function.</li> <li>Note that <code>safe</code> FFI calls don’t take any measures to keep their arguments alive while the called C function runs. For arguments who’s live time doesn’t extend past the FFI call <code>keepAlive#</code> or a <code>StablePtr</code> should be used to ensure the argument isn’t garbage collected before the call finishes.</li> </ul> <p>None of these restrictions are enforced at compile time. Failure to heed these restrictions will lead to runtime errors that can be very difficult to track down. (The errors likely will not manifest until garbage collection happens.) In tabular form, these restrictions are:</p> <table class="colwidths-auto docutils" id="id9"> <caption><span class="caption-text">Restrictions on unlifted boxed arguments passed to foreign C calls. Cells marked as “Unsound” represent combinations that lead to undefined runtime behavior. GHC does not reject such unsound programs at compile time.</span></caption> <thead valign="bottom"> <tr>
<th class="head"> </th> <th class="head" colspan="4">When value is used as argument to FFI call that is</th> </tr> <tr>
<th class="head"> </th> <th class="head" colspan="2"><code>foreign import safe</code></th> <th class="head" colspan="2"><code>foreign import unsafe</code></th> </tr> <tr>
<th class="head">Argument Type</th> <th class="head">reads are</th> <th class="head">writes are</th> <th class="head">reads are</th> <th class="head">writes are</th> </tr> </thead>  <tr>
<td><code>Array#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td><code>MutableArray#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td><code>SmallArray#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td><code>MutableSmallArray#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td><code>ArrayArray#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td><code>MutableArrayArray#</code></td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td>unpinned <code>ByteArray#</code>
</td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td>unpinned <code>MutableByteArray#</code>
</td> <td>Unsound</td> <td>Unsound</td> <td>Sound</td> <td>Sound</td> </tr> <tr>
<td>pinned <code>ByteArray#</code>
</td> <td>Sound</td> <td>Unsound</td> <td>Sound</td> <td>Unsound</td> </tr> <tr>
<td>pinned <code>MutableByteArray#</code>
</td> <td>Sound</td> <td>Sound</td> <td>Sound</td> <td>Sound</td> </tr>  </table> <p>When passing any of the unlifted array types as an argument to a foreign C call, a foreign function sees a pointer that refers to the payload of the array, not to the <code>StgArrBytes</code>/<code>StgMutArrPtrs</code>/<code>StgSmallMutArrPtrs</code> heap object containing it <a class="footnote-reference" href="#id5" id="id1">[1]</a>. By contrast, a <a class="reference internal" href="#ffi-prim"><span class="std std-ref">foreign Cmm call</span></a>, introduced by <code>foreign import prim</code>, sees the heap object, not just the payload. This means that, in some situations, the foreign C function might not need any knowledge of the RTS closure types. The following example sums the first three bytes in a <code>MutableByteArray#</code> <a class="footnote-reference" href="#id6" id="id2">[2]</a> without using anything from <code>Rts.h</code>:</p> <pre data-language="haskell">// C source
uint8_t add_triplet(uint8_t* arr) {
  return (arr[0] + arr[1] + arr[2]);
}

-- Haskell source
foreign import ccall unsafe "add_triplet"
  addTriplet :: MutableByteArray# RealWorld -&gt; IO Word8
</pre> <p>In other situations, the C function may need knowledge of the RTS closure types. The following example sums the first element of each <code>ByteArray#</code> (interpreting the bytes as an array of <code>CInt</code>) element of an <code>ArrayArray##</code> <a class="footnote-reference" href="#id7" id="id3">[3]</a>:</p> <pre data-language="haskell">// C source, must include the RTS to make the struct StgArrBytes
// available along with its fields: ptrs and payload.
#include "Rts.h"
int sum_first (StgArrBytes **bufs) {
  StgArrBytes **bufs = (StgArrBytes**)bufsTmp;
  int res = 0;
  for(StgWord ix = 0;ix &lt; arr-&gt;ptrs;ix++) {
    res = res + ((int*)(bufs[ix]-&gt;payload))[0];
  }
  return res;
}

-- Haskell source, all elements in the argument array must be
-- either ByteArray# or MutableByteArray#. This is not enforced
-- by the type system in this example since ArrayArray is untyped.
foreign import ccall unsafe "sum_first"
  sumFirst :: ArrayArray# -&gt; IO CInt
</pre> <p>Although GHC allows the user to pass all unlifted boxed types to foreign functions, some of them are not amenable to useful work. Although <code>Array#</code> is unlifted, the elements in its payload are lifted, and a foreign C function cannot safely force thunks. Consequently, a foreign C function may not dereference any of the addresses that comprise the payload of the <code>Array#</code>.</p>   <h3 id="ffi-newtype-io">6.17.2.2. Newtype wrapping of the IO monad</h3> <p id="newtype-wrapping-of-the-io-monad">The FFI spec requires the IO monad to appear in various places, but it can sometimes be convenient to wrap the IO monad in a <code>newtype</code>, thus:</p> <pre data-language="haskell">newtype MyIO a = MIO (IO a)
</pre> <p>(A reason for doing so might be to prevent the programmer from calling arbitrary IO procedures in some part of the program.)</p> <p>The Haskell FFI already specifies that arguments and results of foreign imports and exports will be automatically unwrapped if they are newtypes (Section 3.2 of the FFI addendum). GHC extends the FFI by automatically unwrapping any newtypes that wrap the IO monad itself. More precisely, wherever the FFI specification requires an <code>IO</code> type, GHC will accept any newtype-wrapping of an <code>IO</code> type. For example, these declarations are OK:</p> <pre data-language="haskell">foreign import foo :: Int -&gt; MyIO Int
foreign import "dynamic" baz :: (Int -&gt; MyIO Int) -&gt; CInt -&gt; MyIO Int
</pre>   <h3 id="ffi-foralls">6.17.2.3. Explicit “forall”s in foreign types</h3> <p id="explicit-forall-s-in-foreign-types">The type variables in the type of a foreign declaration may be quantified with an explicit <code>forall</code> by using the <a class="reference internal" href="explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> language extension, as in the following example:</p> <pre data-language="haskell">{-# LANGUAGE ExplicitForAll #-}
foreign import ccall "mmap" c_mmap :: forall a. CSize -&gt; IO (Ptr a)
</pre> <p>Note that an explicit <code>forall</code> must appear at the front of the type signature and is not permitted to appear nested within the type, as in the following (erroneous) examples:</p> <pre data-language="haskell">foreign import ccall "mmap" c_mmap' :: CSize -&gt; forall a. IO (Ptr a)
foreign import ccall quux :: (forall a. Ptr a) -&gt; IO ()
</pre>   <h3 id="ffi-prim">6.17.2.4. Primitive imports</h3> <dl class="extension" id="primitive-imports"> <dt id="extension-GHCForeignImportPrim">
<code>GHCForeignImportPrim</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> </dd>
</dl> <p>With <a class="reference internal" href="#extension-GHCForeignImportPrim"><code>GHCForeignImportPrim</code></a>, GHC extends the FFI with an additional calling convention <code>prim</code>, e.g.:</p> <pre data-language="haskell">foreign import prim "foo" foo :: ByteArray# -&gt; (# Int#, Int# #)
</pre> <p>This is used to import functions written in Cmm code that follow an internal GHC calling convention. The arguments and results must be unboxed types, except that an argument may be of type <code>Any</code> (by way of <code>unsafeCoerce#</code>) and the result type is allowed to be an unboxed tuple or the type <code>Any</code>.</p> <p>This feature is not intended for use outside of the core libraries that come with GHC. For more details see the <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/wikis/commentary/prim-ops">GHC developer wiki</a>.</p>   <h3 id="ffi-interruptible">6.17.2.5. Interruptible foreign calls</h3> <dl class="extension" id="interruptible-foreign-calls"> <dt id="extension-InterruptibleFFI">
<code>InterruptibleFFI</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2.1</td> </tr>  </table> </dd>
</dl> <p>This concerns the interaction of foreign calls with <code>Control.Concurrent.throwTo</code>. Normally when the target of a <code>throwTo</code> is involved in a foreign call, the exception is not raised until the call returns, and in the meantime the caller is blocked. This can result in unresponsiveness, which is particularly undesirable in the case of user interrupt (e.g. Control-C). The default behaviour when a Control-C signal is received (<code>SIGINT</code> on Unix) is to raise the <code>UserInterrupt</code> exception in the main thread; if the main thread is blocked in a foreign call at the time, then the program will not respond to the user interrupt.</p> <p>The problem is that it is not possible in general to interrupt a foreign call safely. However, GHC does provide a way to interrupt blocking <em>system</em> calls which works for most system calls on both Unix and Windows.</p> <p>When the <code>InterruptibleFFI</code> extension is enabled, a foreign call can be annotated with <code>interruptible</code> instead of <code>safe</code> or <code>unsafe</code>:</p> <pre data-language="haskell">foreign import ccall interruptible
   "sleep" sleepBlock :: CUint -&gt; IO CUint
</pre> <p><code>interruptible</code> behaves exactly as <code>safe</code>, except that when a <code>throwTo</code> is directed at a thread in an interruptible foreign call, irrespective of the masking state, the exception is added to the blocked exceptions queue of the target thread and an OS-specific mechanism will be used to attempt to cause the foreign call to return:</p> <dl class="docutils"> <dt>Unix systems</dt> <dd>The thread making the foreign call is sent a <code>SIGPIPE</code> signal using <code>pthread_kill()</code>. This is usually enough to cause a blocking system call to return with <code>EINTR</code> (GHC by default installs an empty signal handler for <code>SIGPIPE</code>, to override the default behaviour which is to terminate the process immediately).</dd> <dt>Windows systems</dt> <dd>[Vista and later only] The RTS calls the Win32 function <code>CancelSynchronousIo</code>, which will cause a blocking I/O operation to return with the error <code>ERROR_OPERATION_ABORTED</code>.</dd> </dl> <p>Once the system call is successfully interrupted, the surrounding code must return control out of the <code>foreign import</code>, back into Haskell code, so that any blocked exception can be raised if the masking state of the thread allows it. Being under mask gives the Haskell code an opportunity to detect and react to the interrupt error code from the c call.</p> <p>If the foreign code simply retries the system call directly without returning back to Haskell, then the intended effect of <code>interruptible</code> disappears and functions like <a class="reference external" href="../../libraries/base-4.17.0.0/system-timeout.html#v:timeout">System.Timeout.timeout</a> will not work.</p> <p>Finally, after the <code>interruptible</code> foreign call returns into Haskell, the Haskell code should allow exceptions to be raised (<code>Control.Exception</code>’s <code>allowInterrupt</code>, or <code>interruptible yield</code> for non-<code>-threaded</code>, see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/8684">#8684</a>), and implement the <code>EINTR</code>-retrying in Haskell (e.g. using e.g. <a class="reference external" href="../../libraries/base-4.17.0.0/foreign-c-error.html#v:throwErrnoIfMinus1Retry">Foreign.C.Error.throwErrnoIfMinus1Retry</a>).</p> <p>Be especially careful when using <code>interruptible</code> to check that the called foreign function is prepared to deal with the consequences of the call being interrupted. On Unix it is considered good practice to always check for <code>EINTR</code> after system calls, so you can expect it not to crash (but in that case <code>interruptible</code> will not work as intended unless the code then returns all the way up to Haskell as described above). But on Windows it is not typically common practice to handle <code>ERROR_OPERATION_ABORTED</code>.</p> <p>The approach works <em>only</em> for foreign code that does I/O (system calls), not for CPU-intensive computations that do not do any system calls. This is because the only way by which the foreign code can observe interruption is by system calls returning interruption error codes. To be able to interrupt long-running foreign code doing no system calls, the code must likely be changed to explicitly check for intended early termination.</p>   <h3 id="ffi-capi">6.17.2.6. The CAPI calling convention</h3> <dl class="extension" id="the-capi-calling-convention"> <dt id="extension-CApiFFI">
<code>CApiFFI</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6.1</td> </tr>  </table> </dd>
</dl> <p>The <code>CApiFFI</code> extension allows a calling convention of <code>capi</code> to be used in foreign declarations, e.g.</p> <pre data-language="haskell">foreign import capi "header.h f" f :: CInt -&gt; IO CInt
</pre> <p>Rather than generating code to call <code>f</code> according to the platform’s ABI, we instead call <code>f</code> using the C API defined in the header <code>header.h</code>. Thus <code>f</code> can be called even if it may be defined as a CPP <code>#define</code> rather than a proper function.</p> <p>When using <code>capi</code>, it is also possible to import values, rather than functions. For example,</p> <pre data-language="haskell">foreign import capi "pi.h value pi" c_pi :: CDouble
</pre> <p>will work regardless of whether <code>pi</code> is defined as</p> <pre data-language="c">const double pi = 3.14;
</pre> <p>or with</p> <pre data-language="c">#define pi 3.14
</pre> <p>In order to tell GHC the C type that a Haskell type corresponds to when it is used with the CAPI, a <code>CTYPE</code> pragma can be used on the type definition. The header which defines the type can optionally also be specified. The syntax looks like:</p> <pre data-language="haskell">data    {-# CTYPE "unistd.h" "useconds_t" #-} T = ...
newtype {-# CTYPE            "useconds_t" #-} T = ...
</pre>   <h3 id="hs-thread-done">6.17.2.7. <code>hs_thread_done()</code>
</h3> <pre data-language="c">void hs_thread_done(void);
</pre> <p>GHC allocates a small amount of thread-local memory when a thread calls a Haskell function via a <code>foreign export</code>. This memory is not normally freed until <code>hs_exit()</code>; the memory is cached so that subsequent calls into Haskell are fast. However, if your application is long-running and repeatedly creates new threads that call into Haskell, you probably want to arrange that this memory is freed in those threads that have finished calling Haskell functions. To do this, call <code>hs_thread_done()</code> from the thread whose memory you want to free.</p> <p>Calling <code>hs_thread_done()</code> is entirely optional. You can call it as often or as little as you like. It is safe to call it from a thread that has never called any Haskell functions, or one that never will. If you forget to call it, the worst that can happen is that some memory remains allocated until <code>hs_exit()</code> is called. If you call it too often, the worst that can happen is that the next call to a Haskell function incurs some extra overhead.</p>   <h3 id="ffi-stable-ptr-extras">6.17.2.8. Freeing many stable pointers efficiently</h3> <p id="freeing-many-stable-pointers-efficiently">The standard function <code>hs_free_stable_ptr</code> locks the stable pointer table, frees the given stable pointer, and then unlocks the stable pointer table again. When freeing many stable pointers at once, it is usually more efficient to lock and unlock the table only once.</p> <pre data-language="c">extern void hs_lock_stable_ptr_table (void);

extern void hs_unlock_stable_ptr_table (void);

extern void hs_free_stable_ptr_unsafe (HsStablePtr sp);
</pre> <p><code>hs_free_stable_ptr_unsafe</code> must be used <em>only</em> when the table has been locked using <code>hs_lock_stable_ptr_table</code>. It must be unlocked afterwards using <code>hs_unlock_stable_ptr_table</code>. The Haskell garbage collector cannot run while the table is locked, so it should be unlocked promptly. The following operations are forbidden while the stable pointer table is locked:</p> <ul class="simple"> <li>Calling any Haskell function, whether or not that function manipulates stable pointers.</li> <li>Calling any FFI function that deals with the stable pointer table except for arbitrarily many calls to <code>hs_free_stable_ptr_unsafe</code> and the final call to <code>hs_unlock_stable_ptr_table</code>.</li> <li>Calling <code>hs_free_fun_ptr</code>.</li> </ul> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">GHC versions before 8.8 defined undocumented functions <code>hs_lock_stable_tables</code> and <code>hs_unlock_stable_tables</code> instead of <code>hs_lock_stable_ptr_table</code> and <code>hs_unlock_stable_ptr_table</code>. Those names are now deprecated.</p> </div>    <h2 id="ffi-ghc">6.17.3. Using the FFI with GHC</h2> <p id="using-the-ffi-with-ghc">The following sections also give some hints and tips on the use of the foreign function interface in GHC.</p>  <h3 id="foreign-export-ghc">6.17.3.1. Using <code>foreign export</code> and <code>foreign import ccall "wrapper"</code> with GHC</h3> <p id="using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">When GHC compiles a module (say <code>M.hs</code>) which uses <code>foreign export</code> or <code>foreign import "wrapper"</code>, it generates a <code>M_stub.h</code> for use by C programs.</p> <p>For a plain <code>foreign export</code>, the file <code>M_stub.h</code> contains a C prototype for the foreign exported function. For example, if we compile the following module:</p> <pre data-language="haskell">module Foo where

foreign export ccall foo :: Int -&gt; IO Int

foo :: Int -&gt; IO Int
foo n = return (length (f n))

f :: Int -&gt; [Int]
f 0 = []
f n = n:(f (n-1))
</pre> <p>Then <code>Foo_stub.h</code> will contain something like this:</p> <pre data-language="c">#include "HsFFI.h"
extern HsInt foo(HsInt a0);
</pre> <p>To invoke <code>foo()</code> from C, just <code>#include "Foo_stub.h"</code> and call <code>foo()</code>.</p> <p>The <code>Foo_stub.h</code> file can be redirected using the <code>-stubdir</code> option; see <a class="reference internal" href="../separate_compilation.html#options-output"><span class="std std-ref">Redirecting the compilation output(s)</span></a>.</p>  <h4 id="using-own-main">6.17.3.1.1. Using your own <code>main()</code>
</h4> <p id="using-your-own-main">Normally, GHC’s runtime system provides a <code>main()</code>, which arranges to invoke <code>Main.main</code> in the Haskell program. However, you might want to link some Haskell code into a program which has a main function written in another language, say C. In order to do this, you have to initialize the Haskell runtime system explicitly.</p> <p>Let’s take the example from above, and invoke it from a standalone C program. Here’s the C code:</p> <pre data-language="c">#include &lt;stdio.h&gt;
#include "HsFFI.h"

#if defined(__GLASGOW_HASKELL__)
#include "Foo_stub.h"
#endif

int main(int argc, char *argv[])
{
  int i;

  hs_init(&amp;argc, &amp;argv);

  for (i = 0; i &lt; 5; i++) {
    printf("%d\n", foo(2500));
  }

  hs_exit();
  return 0;
}
</pre> <p>We’ve surrounded the GHC-specific bits with <code>#if defined(__GLASGOW_HASKELL__)</code>; the rest of the code should be portable across Haskell implementations that support the FFI standard.</p> <p>The call to <code>hs_init()</code> initializes GHC’s runtime system. Do NOT try to invoke any Haskell functions before calling <code>hs_init()</code>: bad things will undoubtedly happen.</p> <p>We pass references to <code>argc</code> and <code>argv</code> to <code>hs_init()</code> so that it can separate out any arguments for the RTS (i.e. those arguments between <code>+RTS...-RTS</code>).</p> <p>After we’ve finished invoking our Haskell functions, we can call <code>hs_exit()</code>, which terminates the RTS.</p> <p>There can be multiple calls to <code>hs_init()</code>, but each one should be matched by one (and only one) call to <code>hs_exit()</code>. The outermost <code>hs_exit()</code> will actually de-initialise the system. Note that currently GHC’s runtime cannot reliably re-initialise after this has happened; see <a class="reference internal" href="../bugs.html#infelicities-ffi"><span class="std std-ref">The Foreign Function Interface</span></a>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">When linking the final program, it is normally easiest to do the link using GHC, although this isn’t essential. If you do use GHC, then don’t forget the flag <a class="reference internal" href="../phases.html#ghc-flag--no-hs-main"><code>-no-hs-main</code></a>, otherwise GHC will try to link to the <code>Main</code> Haskell module.</p> </div> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">On Windows hs_init treats argv as UTF8-encoded. Passing other encodings might lead to unexpected results. Passing NULL as argv is valid but can lead to &lt;unknown&gt; showing up in error messages instead of the name of the executable.</p> </div> <p>To use <code>+RTS</code> flags with <code>hs_init()</code>, we have to modify the example slightly. By default, GHC’s RTS will only accept “safe” <code>+RTS</code> flags (see <a class="reference internal" href="../phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), and the <a class="reference internal" href="#"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> link-time flag overrides this. However, <a class="reference internal" href="#"><code>-rtsopts[=⟨none|some|all|ignore|ignoreAll⟩]</code></a> has no effect when <a class="reference internal" href="../phases.html#ghc-flag--no-hs-main"><code>-no-hs-main</code></a> is in use (and the same goes for <a class="reference internal" href="#"><code>-with-rtsopts=⟨opts⟩</code></a>). To set these options we have to call a GHC-specific API instead of <code>hs_init()</code>:</p> <pre data-language="c">#include &lt;stdio.h&gt;
#include "HsFFI.h"

#if defined(__GLASGOW_HASKELL__)
#include "Foo_stub.h"
#include "Rts.h"
#endif

int main(int argc, char *argv[])
{
  int i;

#if __GLASGOW_HASKELL__ &gt;= 703
  {
      RtsConfig conf = defaultRtsConfig;
      conf.rts_opts_enabled = RtsOptsAll;
      hs_init_ghc(&amp;argc, &amp;argv, conf);
  }
#else
  hs_init(&amp;argc, &amp;argv);
#endif

  for (i = 0; i &lt; 5; i++) {
    printf("%d\n", foo(2500));
  }

  hs_exit();
  return 0;
}
</pre> <p>Note two changes: we included <code>Rts.h</code>, which defines the GHC-specific external RTS interface, and we called <code>hs_init_ghc()</code> instead of <code>hs_init()</code>, passing an argument of type <code>RtsConfig</code>. <code>RtsConfig</code> is a struct with various fields that affect the behaviour of the runtime system. Its definition is:</p> <pre data-language="c">typedef struct {
    RtsOptsEnabledEnum rts_opts_enabled;
    const char *rts_opts;
} RtsConfig;

extern const RtsConfig defaultRtsConfig;

typedef enum {
    RtsOptsNone,         // +RTS causes an error
    RtsOptsSafeOnly,     // safe RTS options allowed; others cause an error
    RtsOptsAll           // all RTS options allowed
  } RtsOptsEnabledEnum;
</pre> <p>There is a default value <code>defaultRtsConfig</code> that should be used to initialise variables of type <code>RtsConfig</code>. More fields will undoubtedly be added to <code>RtsConfig</code> in the future, so in order to keep your code forwards-compatible it is best to initialise with <code>defaultRtsConfig</code> and then modify the required fields, as in the code sample above.</p>   <h4 id="ffi-library">6.17.3.1.2. Making a Haskell library that can be called from foreign code</h4> <p id="making-a-haskell-library-that-can-be-called-from-foreign-code">The scenario here is much like in <a class="reference internal" href="#using-own-main"><span class="std std-ref">Using your own main()</span></a>, except that the aim is not to link a complete program, but to make a library from Haskell code that can be deployed in the same way that you would deploy a library of C code.</p> <p>The main requirement here is that the runtime needs to be initialized before any Haskell code can be called, so your library should provide initialisation and deinitialisation entry points, implemented in C or C++. For example:</p> <pre data-language="c">#include &lt;stdlib.h&gt;
#include "HsFFI.h"

HsBool mylib_init(void){
  int argc = 3;
  char *argv[] = { "mylib", "+RTS", "-A32m", NULL };
  char **pargv = argv;

  // Initialize Haskell runtime
  hs_init(&amp;argc, &amp;pargv);

  // do any other initialization here and
  // return false if there was a problem
  return HS_BOOL_TRUE;
}

void mylib_end(void){
  hs_exit();
}
</pre> <p>The initialisation routine, <code>mylib_init</code>, calls <code>hs_init()</code> as normal to initialise the Haskell runtime, and the corresponding deinitialisation function <code>mylib_end()</code> calls <code>hs_exit()</code> to shut down the runtime.</p>    <h3 id="glasgow-foreign-headers">6.17.3.2. Using header files</h3> <p id="using-header-files">C functions are normally declared using prototypes in a C header file. Earlier versions of GHC (6.8.3 and earlier) <code>#include</code>d the header file in the C source file generated from the Haskell code, and the C compiler could therefore check that the C function being called via the FFI was being called at the right type.</p> <p>GHC no longer includes external header files when compiling via C, so this checking is not performed. The change was made for compatibility with the <a class="reference internal" href="../codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> (<a class="reference internal" href="../phases.html#ghc-flag--fllvm"><code>-fasm</code></a>) and to comply strictly with the FFI specification, which requires that FFI calls are not subject to macro expansion and other CPP conversions that may be applied when using C header files. This approach also simplifies the inlining of foreign calls across module and package boundaries: there’s no need for the header file to be available when compiling an inlined version of a foreign call, so the compiler is free to inline foreign calls in any context.</p> <p>The <code>-#include</code> option is now deprecated, and the <code>include-files</code> field in a Cabal package specification is ignored.</p>   <h3 id="memory-allocation">6.17.3.3. Memory Allocation</h3> <p>The FFI libraries provide several ways to allocate memory for use with the FFI, and it isn’t always clear which way is the best. This decision may be affected by how efficient a particular kind of allocation is on a given compiler/platform, so this section aims to shed some light on how the different kinds of allocation perform with GHC.</p> <dl class="docutils"> <dt>
<code>alloca</code> </dt> <dd>
<p class="first">Useful for short-term allocation when the allocation is intended to scope over a given <code>IO</code> computation. This kind of allocation is commonly used when marshalling data to and from FFI functions.</p> <p class="last">In GHC, <code>alloca</code> is implemented using <code>MutableByteArray#</code>, so allocation and deallocation are fast: much faster than C’s <code>malloc/free</code>, but not quite as fast as stack allocation in C. Use <code>alloca</code> whenever you can.</p> </dd> <dt>
<code>mallocForeignPtr</code> </dt> <dd>
<p class="first">Useful for longer-term allocation which requires garbage collection. If you intend to store the pointer to the memory in a foreign data structure, then <code>mallocForeignPtr</code> is <em>not</em> a good choice, however.</p> <p class="last">In GHC, <code>mallocForeignPtr</code> is also implemented using <code>MutableByteArray#</code>. Although the memory is pointed to by a <code>ForeignPtr</code>, there are no actual finalizers involved (unless you add one with <code>addForeignPtrFinalizer</code>), and the deallocation is done using GC, so <code>mallocForeignPtr</code> is normally very cheap.</p> </dd> <dt>
<code>malloc/free</code> </dt> <dd>If all else fails, then you need to resort to <code>Foreign.malloc</code> and <code>Foreign.free</code>. These are just wrappers around the C functions of the same name, and their efficiency will depend ultimately on the implementations of these functions in your platform’s C library. We usually find <code>malloc</code> and <code>free</code> to be significantly slower than the other forms of allocation above.</dd> <dt>
<code>Foreign.Marshal.Pool</code> </dt> <dd>Pools are currently implemented using <code>malloc/free</code>, so while they might be a more convenient way to structure your memory allocation than using one of the other forms of allocation, they won’t be any more efficient. We do plan to provide an improved-performance implementation of Pools in the future, however.</dd> </dl>   <h3 id="ffi-threads">6.17.3.4. Multi-threading and the FFI</h3> <p id="multi-threading-and-the-ffi">In order to use the FFI in a multi-threaded setting, you must use the <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a> option (see <a class="reference internal" href="../phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>  <h4 id="foreign-imports-and-multi-threading">6.17.3.4.1. Foreign imports and multi-threading</h4> <p>When you call a <code>foreign import</code>ed function that is annotated as <code>safe</code> (the default) in a single-threaded runtime (the program was linked without using <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>), then other Haskell threads will be blocked until the call returns.</p> <p>In the multi-threaded runtime (the program was linked using <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>), <code>foreign import</code>ed functions run concurrently (both <code>safe</code> and <code>unsafe</code>), but a similar effect can happen when you call an <code>unsafe</code> function, and a global garbage collection is triggered in another thread. In this situation, the garbage collector cannot proceed, and this can lead to performance issues that often appear under high load, as other threads are more active and thus more prone to trigger global garbage collection.</p> <p>This means that if you need to make a foreign call to a function that takes a long time or potentially blocks, then you should mark it <code>safe</code> and use <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>. Some library functions make such calls internally; their documentation should indicate when this is the case.</p> <p>On the other hand, a foreign call to a function that is guaranteed to take a short time, and does not call back into Haskell can be marked <code>unsafe</code>. This works both for the single-threaded and the multi-threaded runtime. When considering what “a short time” is, a foreign function that does comparable work to what Haskell code does between each heap allocation (not very much), is a good candidate.</p> <p>Outside these two clear cases for <code>safe</code> and <code>unsafe</code> foreign functions, there is a trade-off between whole-program throughput and efficiency of the individual foreign function call.</p> <p>If you are making foreign calls from multiple Haskell threads and using <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>, make sure that the foreign code you are calling is thread-safe. In particularly, some GUI libraries are not thread-safe and require that the caller only invokes GUI methods from a single thread. If this is the case, you may need to restrict your GUI operations to a single Haskell thread, and possibly also use a bound thread (see <a class="reference internal" href="#haskell-threads-and-os-threads"><span class="std std-ref">The relationship between Haskell threads and OS threads</span></a>).</p> <p>Note that foreign calls made by different Haskell threads may execute in <em>parallel</em>, even when the <code>+RTS -N</code> flag is not being used (<a class="reference internal" href="../using-concurrent.html#parallel-options"><span class="std std-ref">RTS options for SMP parallelism</span></a>). The <a class="reference internal" href="#"><code>-N ⟨x⟩</code></a> flag controls parallel execution of Haskell threads, but there may be an arbitrary number of foreign calls in progress at any one time, regardless of the <code>+RTS -N</code> value.</p> <p>If a call is annotated as <code>interruptible</code> and the program was multithreaded, the call may be interrupted in the event that the Haskell thread receives an exception. The mechanism by which the interrupt occurs is platform dependent, but is intended to cause blocking system calls to return immediately with an interrupted error code. The underlying operating system thread is not to be destroyed. See <a class="reference internal" href="#ffi-interruptible"><span class="std std-ref">Interruptible foreign calls</span></a> for more details.</p>   <h4 id="haskell-threads-and-os-threads">6.17.3.4.2. The relationship between Haskell threads and OS threads</h4> <p id="the-relationship-between-haskell-threads-and-os-threads">Normally there is no fixed relationship between Haskell threads and OS threads. This means that when you make a foreign call, that call may take place in an unspecified OS thread. Furthermore, there is no guarantee that multiple calls made by one Haskell thread will be made by the same OS thread.</p> <p>This usually isn’t a problem, and it allows the GHC runtime system to make efficient use of OS thread resources. However, there are cases where it is useful to have more control over which OS thread is used, for example when calling foreign code that makes use of thread-local state. For cases like this, we provide <em>bound threads</em>, which are Haskell threads tied to a particular OS thread. For information on bound threads, see the documentation for the <a class="reference external" href="../../libraries/base-4.17.0.0/control-concurrent.html">Control.Concurrent</a> module.</p>   <h4 id="foreign-exports-and-multi-threading">6.17.3.4.3. Foreign exports and multi-threading</h4> <p>When the program is linked with <a class="reference internal" href="../phases.html#ghc-flag--threaded"><code>-threaded</code></a>, then you may invoke <code>foreign export</code>ed functions from multiple OS threads concurrently. The runtime system must be initialised as usual by calling <code>hs_init()</code>, and this call must complete before invoking any <code>foreign export</code>ed functions.</p>   <h4 id="hs-exit">6.17.3.4.4. On the use of <code>hs_exit()</code>
</h4> <p id="on-the-use-of-hs-exit"><code>hs_exit()</code> normally causes the termination of any running Haskell threads in the system, and when <code>hs_exit()</code> returns, there will be no more Haskell threads running. The runtime will then shut down the system in an orderly way, generating profiling output and statistics if necessary, and freeing all the memory it owns.</p> <p>It isn’t always possible to terminate a Haskell thread forcibly: for example, the thread might be currently executing a foreign call, and we have no way to force the foreign call to complete. What’s more, the runtime must assume that in the worst case the Haskell code and runtime are about to be removed from memory (e.g. if this is a <a class="reference internal" href="../win32-dlls.html#win32-dlls"><span class="std std-ref">Windows DLL</span></a>, <code>hs_exit()</code> is normally called before unloading the DLL). So <code>hs_exit()</code> <em>must</em> wait until all outstanding foreign calls return before it can return itself.</p> <p>The upshot of this is that if you have Haskell threads that are blocked in foreign calls, then <code>hs_exit()</code> may hang (or possibly busy-wait) until the calls return. Therefore it’s a good idea to make sure you don’t have any such threads in the system when calling <code>hs_exit()</code>. This includes any threads doing I/O, because I/O may (or may not, depending on the type of I/O and the platform) be implemented using blocking foreign calls.</p> <p>The GHC runtime treats program exit as a special case, to avoid the need to wait for blocked threads when a standalone executable exits. Since the program and all its threads are about to terminate at the same time that the code is removed from memory, it isn’t necessary to ensure that the threads have exited first. If you want this fast and loose version of <code>hs_exit()</code>, you can call:</p> <pre data-language="c">void hs_exit_nowait(void);
</pre> <p>instead. This is particularly useful if you have foreign libraries that need to call <code>hs_exit()</code> at program exit (perhaps via a C++ destructor): in this case you should use <code>hs_exit_nowait()</code>, because the thread that called <code>exit()</code> and is running C++ destructors is in a foreign call from Haskell that will never return, so <code>hs_exit()</code> would deadlock.</p>   <h4 id="hs-try-putmvar">6.17.3.4.5. Waking up Haskell threads from C</h4> <p id="waking-up-haskell-threads-from-c">Sometimes we want to be able to wake up a Haskell thread from some C code. For example, when using a callback-based C API, we register a C callback and then we need to wait for the callback to run.</p> <p>One way to do this is to create a <code>foreign export</code> that will do whatever needs to be done to wake up the Haskell thread - perhaps <code>putMVar</code> - and then call this from our C callback. There are a couple of problems with this:</p> <ol class="arabic simple"> <li>Calling a foreign export has a lot of overhead: it creates a complete new Haskell thread, for example.</li> <li>The call may block for a long time if a GC is in progress. We can’t use this method if the C API we’re calling doesn’t allow blocking in the callback.</li> </ol> <p>For these reasons GHC provides an external API to <code>tryPutMVar</code>, <code>hs_try_putmvar</code>, which you can use to cheaply and asynchronously wake up a Haskell thread from C/C++.</p> <pre data-language="c">void hs_try_putmvar (int capability, HsStablePtr sp);
</pre> <p>The C call <code>hs_try_putmvar(cap, mvar)</code> is equivalent to the Haskell call <code>tryPutMVar mvar ()</code>, except that it is</p> <ul class="simple"> <li>non-blocking: takes a bounded, short, amount of time</li> <li>asynchronous: the actual putMVar may be performed after the call returns (for example, if the RTS is currently garbage collecting). That’s why <code>hs_try_putmvar()</code> doesn’t return a result to say whether the put succeeded. It is your responsibility to ensure that the <code>MVar</code> is empty; if it is full, <code>hs_try_putmvar()</code> will have no effect.</li> </ul> <p><strong>Example</strong>. Suppose we have a C/C++ function to call that will return and then invoke a callback at some point in the future, passing us some data. We want to wait in Haskell for the callback to be called, and retrieve the data. We can do it like this:</p> <pre data-language="haskell">import GHC.Conc (newStablePtrPrimMVar, PrimMVar)

makeExternalCall = mask_ $ do
  mvar &lt;- newEmptyMVar
  sp &lt;- newStablePtrPrimMVar mvar
  fp &lt;- mallocForeignPtr
  withForeignPtr fp $ \presult -&gt; do
    cap &lt;- threadCapability =&lt;&lt; myThreadId
    scheduleCallback sp cap presult
    takeMVar mvar `onException`
      forkIO (do takeMVar mvar; touchForeignPtr fp)
    peek presult

foreign import ccall "scheduleCallback"
    scheduleCallback :: StablePtr PrimMVar
                     -&gt; Int
                     -&gt; Ptr Result
                     -&gt; IO ()
</pre> <p>And inside <code>scheduleCallback</code>, we create a callback that will in due course store the result data in the <code>Ptr Result</code>, and then call <code>hs_try_putmvar()</code>.</p> <p>There are a few things to note here.</p> <ul> <li>There’s a special function to create the <code>StablePtr</code>: <code>newStablePtrPrimMVar</code>, because the RTS needs a <code>StablePtr</code> to the primitive <code>MVar#</code> object, and we can’t create that directly. Do <em>not</em> just use <code>newStablePtr</code> on the <code>MVar</code>: your program will crash. </li> <li>The <code>StablePtr</code> is freed by <code>hs_try_putmvar()</code>. This is because it would otherwise be difficult to arrange to free the <code>StablePtr</code> reliably: we can’t free it in Haskell, because if the <code>takeMVar</code> is interrupted by an asynchronous exception, then the callback will fire at a later time. We can’t free it in C, because we don’t know when to free it (not when <code>hs_try_putmvar()</code> returns, because that is an async call that uses the <code>StablePtr</code> at some time in the future). </li> <li>The <code>mask_</code> is to avoid asynchronous exceptions before the <code>scheduleCallback</code> call, which would leak the <code>StablePtr</code>. </li> <li>
<p class="first">We find out the current capability number and pass it to C. This is passed back to <code>hs_try_putmvar</code>, and helps the RTS to know which capability it should try to perform the <code>tryPutMVar</code> on. If you don’t care, you can pass <code>-1</code> for the capability to <code>hs_try_putmvar</code>, and it will pick an arbitrary one.</p> <p>Picking the right capability will help avoid unnecessary context switches. Ideally you should pass the capability that the thread that will be woken up last ran on, which you can find by calling <code>threadCapability</code> in Haskell.</p> </li> <li>If you want to also pass some data back from the C callback to Haskell, this is best done by first allocating some memory in Haskell to receive the data, and passing the address to C, as we did in the above example. </li> <li>
<code>takeMVar</code> can be interrupted by an asynchronous exception. If this happens, the callback in C will still run at some point in the future, will still write the result, and will still call <code>hs_try_putmvar()</code>. Therefore we have to arrange that the memory for the result stays alive until the callback has run, so if an exception is thrown during <code>takeMVar</code> we fork another thread to wait for the callback and hold the memory alive using <code>touchForeignPtr</code>. </li> </ul> <p>For a fully working example, see <code>testsuite/tests/concurrent/should_run/hs_try_putmvar001.hs</code> in the GHC source tree.</p>    <h3 id="ffi-floating-point">6.17.3.5. Floating point and the FFI</h3> <p id="floating-point-and-the-ffi">The standard C99 <code>fenv.h</code> header provides operations for inspecting and modifying the state of the floating point unit. In particular, the rounding mode used by floating point operations can be changed, and the exception flags can be tested.</p> <p>In Haskell, floating-point operations have pure types, and the evaluation order is unspecified. So strictly speaking, since the <code>fenv.h</code> functions let you change the results of, or observe the effects of floating point operations, use of <code>fenv.h</code> renders the behaviour of floating-point operations anywhere in the program undefined.</p> <p>Having said that, we <em>can</em> document exactly what GHC does with respect to the floating point state, so that if you really need to use <code>fenv.h</code> then you can do so with full knowledge of the pitfalls:</p> <ul class="simple"> <li>GHC completely ignores the floating-point environment, the runtime neither modifies nor reads it.</li> <li>The floating-point environment is not saved over a normal thread context-switch. So if you modify the floating-point state in one thread, those changes may be visible in other threads. Furthermore, testing the exception state is not reliable, because a context switch may change it. If you need to modify or test the floating point state and use threads, then you must use bound threads (<code>Control.Concurrent.forkOS</code>), because a bound thread has its own OS thread, and OS threads do save and restore the floating-point state.</li> <li>It is safe to modify the floating-point unit state temporarily during a foreign call, because foreign calls are never pre-empted by GHC.</li> </ul>   <h3 id="id4">6.17.3.6. Pinned Byte Arrays</h3> <p id="pinned-byte-arrays">A pinned byte array is one that the garbage collector is not allowed to move. Consequently, it has a stable address that can be safely requested with <code>byteArrayContents#</code>. Not that being pinned doesn’t prevent the byteArray from being gc’ed in the same fashion a regular byte array would be. There are a handful of primitive functions in <a class="reference external" href="../../libraries/base-4.17.0.0/ghc-exts.html">GHC.Exts</a> used to enforce or check for pinnedness: <code>isByteArrayPinned#</code>, <code>isMutableByteArrayPinned#</code>, and <code>newPinnedByteArray#</code>. A byte array can be pinned as a result of three possible causes:</p> <ol class="arabic simple"> <li>It was allocated by <code>newPinnedByteArray#</code>.</li> <li>It is large. Currently, GHC defines large object to be one that is at least as large as 80% of a 4KB block (i.e. at least 3277 bytes).</li> <li>It has been copied into a compact region. The documentation for <code>ghc-compact</code> and <code>compact</code> describes this process.</li> </ol> <table class="docutils footnote" frame="void" id="id5" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id1">[1]</a></td>
<td>Prior to GHC 8.10, when passing an <code>ArrayArray#</code> argument to a foreign function, the foreign function would see a pointer to the <code>StgMutArrPtrs</code> rather than just the payload.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id6" rules="none">   <tr>
<td class="label">[2]</td>
<td>
<em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id8">2</a>)</em> In practice, the FFI should not be used for a task as simple as reading bytes from a <code>MutableByteArray#</code>. Users should prefer <code>GHC.Exts.readWord8Array#</code> for this.</td>
</tr>  </table> <table class="docutils footnote" frame="void" id="id7" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[3]</a></td>
<td>As in <a class="footnote-reference" href="#id6" id="id8">[2]</a>, the FFI is not actually needed for this. <code>GHC.Exts</code> includes primitives for reading from on <code>ArrayArray#</code>.</td>
</tr>  </table>    </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/ffi.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/ffi.html</a>
  </p>
</div>
