<h1 id="id1">6.8.7. Functional dependencies</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="functional-dependencies"> <dt id="extension-FunctionalDependencies">
<code>FunctionalDependencies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="multi_param_type_classes.html#extension-MultiParamTypeClasses"><code>MultiParamTypeClasses</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8.1</td> </tr>  </table> <p>Allow use of functional dependencies in class declarations.</p> </dd>
</dl> <p>Functional dependencies are implemented as described by Mark Jones in <a class="reference internal" href="#jones2000" id="id2">[Jones2000]</a>.</p> <p>Functional dependencies are introduced by a vertical bar in the syntax of a class declaration; e.g.</p> <pre data-language="haskell">class (Monad m) =&gt; MonadState s m | m -&gt; s where ...

class Foo a b c | a b -&gt; c where ...
</pre> <p>More documentation can be found in the <a class="reference external" href="https://wiki.haskell.org/Functional_dependencies">Haskell Wiki</a>.</p> <table class="docutils citation" frame="void" id="jones2000" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id2">[Jones2000]</a></td>
<td>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fundeps.html">Type Classes with Functional Dependencies</a>”, Mark P. Jones, In <em>Proceedings of the 9th European Symposium on Programming</em>, ESOP 2000, Berlin, Germany, March 2000, Springer-Verlag LNCS 1782, .</td>
</tr>  </table>  <h2 id="rules-for-functional-dependencies">6.8.7.1. Rules for functional dependencies</h2> <p>In a class declaration, all of the class type variables must be reachable (in the sense mentioned in <a class="reference internal" href="flexible_contexts.html#flexible-contexts"><span class="std std-ref">Loosening restrictions on class contexts</span></a>) from the free variables of each method type. For example:</p> <pre data-language="haskell">class Coll s a where
  empty  :: s
  insert :: s -&gt; a -&gt; s
</pre> <p>is not OK, because the type of <code>empty</code> doesn’t mention <code>a</code>. Functional dependencies can make the type variable reachable:</p> <pre data-language="haskell">class Coll s a | s -&gt; a where
  empty  :: s
  insert :: s -&gt; a -&gt; s
</pre> <p>Alternatively <code>Coll</code> might be rewritten</p> <pre data-language="haskell">class Coll s a where
  empty  :: s a
  insert :: s a -&gt; a -&gt; s a
</pre> <p>which makes the connection between the type of a collection of <code>a</code>’s (namely <code>(s a)</code>) and the element type <code>a</code>. Occasionally this really doesn’t work, in which case you can split the class like this:</p> <pre data-language="haskell">class CollE s where
  empty  :: s

class CollE s =&gt; Coll s a where
  insert :: s -&gt; a -&gt; s
</pre>   <h2 id="background-on-functional-dependencies">6.8.7.2. Background on functional dependencies</h2> <p>The following description of the motivation and use of functional dependencies is taken from the Hugs user manual, reproduced here (with minor changes) by kind permission of Mark Jones.</p> <p>Consider the following class, intended as part of a library for collection types:</p> <pre data-language="haskell">class Collects e ce where
    empty  :: ce
    insert :: e -&gt; ce -&gt; ce
    member :: e -&gt; ce -&gt; Bool
</pre> <p>The type variable <code>e</code> used here represents the element type, while <code>ce</code> is the type of the container itself. Within this framework, we might want to define instances of this class for lists or characteristic functions (both of which can be used to represent collections of any equality type), bit sets (which can be used to represent collections of characters), or hash tables (which can be used to represent any collection whose elements have a hash function). Omitting standard implementation details, this would lead to the following declarations:</p> <pre data-language="haskell">instance Eq e =&gt; Collects e [e] where ...
instance Eq e =&gt; Collects e (e -&gt; Bool) where ...
instance Collects Char BitSet where ...
instance (Hashable e, Collects a ce)
           =&gt; Collects e (Array Int ce) where ...
</pre> <p>All this looks quite promising; we have a class and a range of interesting implementations. Unfortunately, there are some serious problems with the class declaration. First, the empty function has an ambiguous type:</p> <pre data-language="haskell">empty :: Collects e ce =&gt; ce
</pre> <p>By “ambiguous” we mean that there is a type variable <code>e</code> that appears on the left of the <code>=&gt;</code> symbol, but not on the right. The problem with this is that, according to the theoretical foundations of Haskell overloading, we cannot guarantee a well-defined semantics for any term with an ambiguous type.</p> <p>We can sidestep this specific problem by removing the empty member from the class declaration. However, although the remaining members, insert and member, do not have ambiguous types, we still run into problems when we try to use them. For example, consider the following two functions:</p> <pre data-language="haskell">f x y = insert x . insert y
g     = f True 'a'
</pre> <p>for which GHC infers the following types:</p> <pre data-language="haskell">f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
g :: (Collects Bool c, Collects Char c) =&gt; c -&gt; c
</pre> <p>Notice that the type for <code>f</code> allows the two parameters <code>x</code> and <code>y</code> to be assigned different types, even though it attempts to insert each of the two values, one after the other, into the same collection. If we’re trying to model collections that contain only one type of value, then this is clearly an inaccurate type. Worse still, the definition for g is accepted, without causing a type error. As a result, the error in this code will not be flagged at the point where it appears. Instead, it will show up only when we try to use <code>g</code>, which might even be in a different module.</p>  <h3 id="an-attempt-to-use-constructor-classes">6.8.7.2.1. An attempt to use constructor classes</h3> <p>Faced with the problems described above, some Haskell programmers might be tempted to use something like the following version of the class declaration:</p> <pre data-language="haskell">class Collects e c where
   empty  :: c e
   insert :: e -&gt; c e -&gt; c e
   member :: e -&gt; c e -&gt; Bool
</pre> <p>The key difference here is that we abstract over the type constructor <code>c</code> that is used to form the collection type <code>c e</code>, and not over that collection type itself, represented by <code>ce</code> in the original class declaration. This avoids the immediate problems that we mentioned above: empty has type <code>Collects e c =&gt; c e</code>, which is not ambiguous.</p> <p>The function <code>f</code> from the previous section has a more accurate type:</p> <pre data-language="haskell">f :: (Collects e c) =&gt; e -&gt; e -&gt; c e -&gt; c e
</pre> <p>The function <code>g</code> from the previous section is now rejected with a type error as we would hope because the type of <code>f</code> does not allow the two arguments to have different types. This, then, is an example of a multiple parameter class that does actually work quite well in practice, without ambiguity problems. There is, however, a catch. This version of the <code>Collects</code> class is nowhere near as general as the original class seemed to be: only one of the four instances for <code>Collects</code> given above can be used with this version of Collects because only one of them—the instance for lists—has a collection type that can be written in the form <code>c
e</code>, for some type constructor <code>c</code>, and element type <code>e</code>.</p>   <h3 id="adding-functional-dependencies">6.8.7.2.2. Adding functional dependencies</h3> <p>To get a more useful version of the <code>Collects</code> class, GHC provides a mechanism that allows programmers to specify dependencies between the parameters of a multiple parameter class (For readers with an interest in theoretical foundations and previous work: The use of dependency information can be seen both as a generalisation of the proposal for “parametric type classes” that was put forward by Chen, Hudak, and Odersky, or as a special case of Mark Jones’s later framework for “improvement” of qualified types. The underlying ideas are also discussed in a more theoretical and abstract setting in a manuscript <a class="reference internal" href="#jones1999" id="id3">[Jones1999]</a>, where they are identified as one point in a general design space for systems of implicit parameterisation). To start with an abstract example, consider a declaration such as:</p> <pre data-language="haskell">class C a b where ...
</pre> <table class="docutils citation" frame="void" id="jones1999" rules="none">   <tr>
<td class="label"><a class="fn-backref" href="#id3">[Jones1999]</a></td>
<td>“<a class="reference external" href="https://web.cecs.pdx.edu/~mpj/pubs/fdtr.html">Exploring the Design Space for Type-based Implicit Parameterization</a>”, Mark P. Jones, Oregon Graduate Institute of Science &amp; Technology, Technical Report, July 1999.</td>
</tr>  </table> <p>which tells us simply that <code>C</code> can be thought of as a binary relation on types (or type constructors, depending on the kinds of <code>a</code> and <code>b</code>). Extra clauses can be included in the definition of classes to add information about dependencies between parameters, as in the following examples:</p> <pre data-language="haskell">class D a b | a -&gt; b where ...
class E a b | a -&gt; b, b -&gt; a where ...
</pre> <p>The notation <code>a -&gt; b</code> used here between the <code>|</code> and <code>where</code> symbols — not to be confused with a function type — indicates that the <code>a</code> parameter uniquely determines the <code>b</code> parameter, and might be read as “<code>a</code> determines <code>b</code>.” Thus <code>D</code> is not just a relation, but actually a (partial) function. Similarly, from the two dependencies that are included in the definition of <code>E</code>, we can see that <code>E</code> represents a (partial) one-to-one mapping between types.</p> <p>More generally, dependencies take the form <code>x1 ... xn -&gt; y1 ... ym</code>, where <code>x1</code>, …, <code>xn</code>, and <code>y1</code>, …, <code>yn</code> are type variables with n&gt;0 and m&gt;=0, meaning that the <code>y</code> parameters are uniquely determined by the <code>x</code> parameters. Spaces can be used as separators if more than one variable appears on any single side of a dependency, as in <code>t -&gt; a b</code>. Note that a class may be annotated with multiple dependencies using commas as separators, as in the definition of <code>E</code> above. Some dependencies that we can write in this notation are redundant, and will be rejected because they don’t serve any useful purpose, and may instead indicate an error in the program. Examples of dependencies like this include <code>a -&gt; a</code>, <code>a -&gt; a a</code>, <code>a -&gt;</code>, etc. There can also be some redundancy if multiple dependencies are given, as in <code>a-&gt;b</code>, <code>b-&gt;c</code>, <code>a-&gt;c</code>, and in which some subset implies the remaining dependencies. Examples like this are not treated as errors. Note that dependencies appear only in class declarations, and not in any other part of the language. In particular, the syntax for instance declarations, class constraints, and types is completely unchanged.</p> <p>By including dependencies in a class declaration, we provide a mechanism for the programmer to specify each multiple parameter class more precisely. The compiler, on the other hand, is responsible for ensuring that the set of instances that are in scope at any given point in the program is consistent with any declared dependencies. For example, the following pair of instance declarations cannot appear together in the same scope because they violate the dependency for <code>D</code>, even though either one on its own would be acceptable:</p> <pre data-language="haskell">instance D Bool Int where ...
instance D Bool Char where ...
</pre> <p>Note also that the following declaration is not allowed, even by itself:</p> <pre data-language="haskell">instance D [a] b where ...
</pre> <p>The problem here is that this instance would allow one particular choice of <code>[a]</code> to be associated with more than one choice for <code>b</code>, which contradicts the dependency specified in the definition of <code>D</code>. More generally, this means that, in any instance of the form:</p> <pre data-language="haskell">instance D t s where ...
</pre> <p>for some particular types <code>t</code> and <code>s</code>, the only variables that can appear in <code>s</code> are the ones that appear in <code>t</code>, and hence, if the type <code>t</code> is known, then <code>s</code> will be uniquely determined.</p> <p>The benefit of including dependency information is that it allows us to define more general multiple parameter classes, without ambiguity problems, and with the benefit of more accurate types. To illustrate this, we return to the collection class example, and annotate the original definition of <code>Collects</code> with a simple dependency:</p> <pre data-language="haskell">class Collects e ce | ce -&gt; e where
   empty  :: ce
   insert :: e -&gt; ce -&gt; ce
   member :: e -&gt; ce -&gt; Bool
</pre> <p>The dependency <code>ce -&gt; e</code> here specifies that the type <code>e</code> of elements is uniquely determined by the type of the collection <code>ce</code>. Note that both parameters of Collects are of kind <code>Type</code>; there are no constructor classes here. Note too that all of the instances of <code>Collects</code> that we gave earlier can be used together with this new definition.</p> <p>What about the ambiguity problems that we encountered with the original definition? The empty function still has type <code>Collects e ce =&gt; ce</code>, but it is no longer necessary to regard that as an ambiguous type: Although the variable <code>e</code> does not appear on the right of the <code>=&gt;</code> symbol, the dependency for class <code>Collects</code> tells us that it is uniquely determined by <code>ce</code>, which does appear on the right of the <code>=&gt;</code> symbol. Hence the context in which empty is used can still give enough information to determine types for both <code>ce</code> and <code>e</code>, without ambiguity. More generally, we need only regard a type as ambiguous if it contains a variable on the left of the <code>=&gt;</code> that is not uniquely determined (either directly or indirectly) by the variables on the right.</p> <p>Dependencies also help to produce more accurate types for user defined functions, and hence to provide earlier detection of errors, and less cluttered types for programmers to work with. Recall the previous definition for a function <code>f</code>:</p> <pre data-language="haskell">f x y = insert x y = insert x . insert y
</pre> <p>for which we originally obtained a type:</p> <pre data-language="haskell">f :: (Collects a c, Collects b c) =&gt; a -&gt; b -&gt; c -&gt; c
</pre> <p>Given the dependency information that we have for <code>Collects</code>, however, we can deduce that <code>a</code> and <code>b</code> must be equal because they both appear as the second parameter in a <code>Collects</code> constraint with the same first parameter <code>c</code>. Hence we can infer a shorter and more accurate type for <code>f</code>:</p> <pre data-language="haskell">f :: (Collects a c) =&gt; a -&gt; a -&gt; c -&gt; c
</pre> <p>In a similar way, the earlier definition of <code>g</code> will now be flagged as a type error.</p> <p>Although we have given only a few examples here, it should be clear that the addition of dependency information can help to make multiple parameter classes more useful in practice, avoiding ambiguity problems, and allowing more general sets of instance declarations.</p>    </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/functional_dependencies.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/functional_dependencies.html</a>
  </p>
</div>
