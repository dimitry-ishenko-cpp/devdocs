<h1 id="linear-types">6.4.17. Linear types</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension"> <dt id="extension-LinearTypes">
<code>LinearTypes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.0.1</td> </tr>  </table> <p>Enable the linear arrow <code>a %1 -&gt; b</code> and the multiplicity-polymorphic arrow <code>a %m -&gt; b</code>.</p> </dd>
</dl> <p><strong>This extension is currently considered experimental, expect bugs, warts, and bad error messages; everything down to the syntax is subject to change</strong>. See, in particular, <a class="reference internal" href="#linear-types-limitations"><span class="std std-ref">Limitations</span></a> below. We encourage you to experiment with this extension and report issues in the GHC bug tracker <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues">the GHC bug tracker</a>, adding the tag <code>LinearTypes</code>.</p> <p>A function <code>f</code> is linear if: when its result is consumed <em>exactly once</em>, then its argument is consumed <em>exactly once</em>. Intuitively, it means that in every branch of the definition of <code>f</code>, its argument <code>x</code> must be used exactly once. Which can be done by</p> <ul class="simple"> <li>Returning <code>x</code> unmodified</li> <li>Passing <code>x</code> to a <em>linear</em> function</li> <li>Pattern-matching on <code>x</code> and using each argument exactly once in the same fashion.</li> <li>Calling it as a function and using the result exactly once in the same fashion.</li> </ul> <p>With <code>-XLinearTypes</code>, you can write <code>f :: a %1 -&gt; b</code> to mean that <code>f</code> is a linear function from <code>a</code> to <code>b</code>. If <a class="reference internal" href="unicode_syntax.html#extension-UnicodeSyntax"><code>UnicodeSyntax</code></a> is enabled, the <code>%1 -&gt;</code> arrow can be written as <code>⊸</code>.</p> <p>To allow uniform handling of linear <code>a %1 -&gt; b</code> and unrestricted <code>a
-&gt; b</code> functions, there is a new function type <code>a %m -&gt; b</code>. Here, <code>m</code> is a type of new kind <code>Multiplicity</code>. We have:</p> <pre data-language="haskell">data Multiplicity = One | Many  -- Defined in GHC.Types

type a %1 -&gt; b = a %One  -&gt; b
type a  -&gt; b = a %Many -&gt; b
</pre> <p>(See <a class="reference internal" href="data_kinds.html#promotion"><span class="std std-ref">Datatype promotion</span></a>).</p> <p>We say that a variable whose multiplicity constraint is <code>Many</code> is <em>unrestricted</em>.</p> <p>The multiplicity-polymorphic arrow <code>a %m -&gt; b</code> is available in a prefix version as <code>GHC.Exts.FUN m a b</code>, which can be applied partially. See, however <a class="reference internal" href="#linear-types-limitations"><span class="std std-ref">Limitations</span></a>.</p> <p>Linear and multiplicity-polymorphic arrows are <em>always declared</em>, never inferred. That is, if you don’t give an appropriate type signature to a function, it will be inferred as being a regular function of type <code>a -&gt; b</code>.</p>  <h2 id="data-types">6.4.17.1. Data types</h2> <p>By default, all fields in algebraic data types are linear (even if <code>-XLinearTypes</code> is not turned on). Given</p> <pre data-language="haskell">data T1 a = MkT1 a
</pre> <p>the value <code>MkT1 x</code> can be constructed and deconstructed in a linear context:</p> <pre data-language="haskell">construct :: a %1 -&gt; T1 a
construct x = MkT1 x

deconstruct :: T1 a %1 -&gt; a
deconstruct (MkT1 x) = x  -- must consume `x` exactly once
</pre> <p>When used as a value, <code>MkT1</code> is given a multiplicity-polymorphic type: <code>MkT1 :: forall {m} a. a %m -&gt; T1 a</code>. This makes it possible to use <code>MkT1</code> in higher order functions. The additional multiplicity argument <code>m</code> is marked as inferred (see <a class="reference internal" href="type_applications.html#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>), so that there is no conflict with visible type application. When displaying types, unless <code>-XLinearTypes</code> is enabled, multiplicity polymorphic functions are printed as regular functions (see <a class="reference internal" href="#printing-linear-types"><span class="std std-ref">Printing multiplicity-polymorphic types</span></a>); therefore constructors appear to have regular function types.</p> <pre data-language="haskell">mkList :: [a] -&gt; [T1 a]
mkList xs = map MkT1 xs
</pre> <p>Hence the linearity of type constructors is invisible when <code>-XLinearTypes</code> is off.</p> <p>Whether a data constructor field is linear or not can be customized using the GADT syntax. Given</p> <pre data-language="haskell">data T2 a b c where
    MkT2 :: a -&gt; b %1 -&gt; c %1 -&gt; T2 a b c -- Note unrestricted arrow in the first argument
</pre> <p>the value <code>MkT2 x y z</code> can be constructed only if <code>x</code> is unrestricted. On the other hand, a linear function which is matching on <code>MkT2 x y z</code> must consume <code>y</code> and <code>z</code> exactly once, but there is no restriction on <code>x</code>.</p> <p>It is also possible to define a multiplicity-polymorphic field:</p> <pre data-language="haskell">data T3 a m where
    MkT3 :: a %m -&gt; T3 a m
</pre> <p>While linear fields are generalized (<code>MkT1 :: forall {m} a. a %m -&gt; T1 a</code> in the previous example), multiplicity-polymorphic fields are not; it is not possible to directly use <code>MkT3</code> as a function <code>a -&gt; T3 a One</code>.</p> <p>If <a class="reference internal" href="#extension-LinearTypes"><code>LinearTypes</code></a> is disabled, all fields are considered to be linear fields, including GADT fields defined with the <code>-&gt;</code> arrow.</p> <p>In a <code>newtype</code> declaration, the field must be linear. Attempting to write an unrestricted newtype constructor with GADT syntax results in an error.</p>   <h2 id="printing-linear-types">6.4.17.2. Printing multiplicity-polymorphic types</h2> <p id="printing-multiplicity-polymorphic-types">If <a class="reference internal" href="#extension-LinearTypes"><code>LinearTypes</code></a> is disabled, multiplicity variables in types are defaulted to <code>Many</code> when printing, in the same manner as described in <a class="reference internal" href="representation_polymorphism.html#printing-representation-polymorphic-types"><span class="std std-ref">Printing representation-polymorphic types</span></a>. In other words, without <a class="reference internal" href="#extension-LinearTypes"><code>LinearTypes</code></a>, multiplicity-polymorphic functions <code>a %m -&gt; b</code> are printed as normal Haskell2010 functions <code>a -&gt; b</code>. This allows existing libraries to be generalized to linear types in a backwards-compatible manner; the general types are visible only if the user has enabled <a class="reference internal" href="#extension-LinearTypes"><code>LinearTypes</code></a>. (Note that a library can declare a linear function in the contravariant position, i.e. take a linear function as an argument. In this case, linearity cannot be hidden; it is an essential part of the exposed interface.)</p>   <h2 id="linear-types-limitations">6.4.17.3. Limitations</h2> <p id="limitations">Linear types are still considered experimental and come with several limitations. If you have read the full design in the proposal (see <a class="reference internal" href="#linear-types-references"><span class="std std-ref">Design and further reading</span></a> below), here is a run down of the missing pieces.</p> <ul> <li>Multiplicity polymorphism is incomplete and experimental. You may have success using it, or you may not. Expect it to be really unreliable. (Multiplicity multiplication is not supported yet.) </li> <li>There is currently no support for multiplicity annotations such as <code>x :: a %p</code>, <code>\(x :: a %p) -&gt; ...</code>. </li> <li>A <code>case</code> expression may consume its scrutinee <code>One</code> time, or <code>Many</code> times. But the inference is still experimental, and may over-eagerly guess that it ought to consume the scrutinee <code>Many</code> times. </li> <li>
<p class="first">All <code>let</code> and <code>where</code> statements consume their right hand side <code>Many</code> times. That is, the following will not type check:</p> <pre data-language="haskell">g :: A %1 -&gt; (A, B)
h :: A %1 -&gt; B %1 -&gt; C

f :: A %1 -&gt; C
f x =
  let (y, z) = g x in h y z
</pre> <p>This can be worked around by defining extra functions which are specified to be linear, such as:</p> <pre data-language="haskell">g :: A %1 -&gt; (A, B)
h :: A %1 -&gt; B %1 -&gt; C

f :: A %1 -&gt; C
f x = f' (g x)
  where
    f' :: (A, B) %1 -&gt; C
    f' (y, z) = h y z
</pre> </li> <li>There is no support for linear pattern synonyms. </li> <li>
<code>@</code>-patterns and view patterns are not linear. </li> <li>The projection function for a record with a single linear field should be multiplicity-polymorphic; currently it’s unrestricted. </li> <li>Attempting to use of linear types in Template Haskell will probably not work. </li> </ul>   <h2 id="linear-types-references">6.4.17.4. Design and further reading</h2> <ul class="simple" id="design-and-further-reading"> <li>The design for this extension is described in details in the <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0111-linear-types.rst">Linear types proposal</a>
</li> <li>This extension has been originally conceived of in the paper <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/linear-haskell-practical-linearity-higher-order-polymorphic-language/">Linear Haskell: practical linearity in a higher-order polymorphic language</a> (POPL 2018)</li> <li>There is a <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/-/wikis/linear-types">wiki page dedicated to the linear types extension</a>
</li> </ul>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/linear_types.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/linear_types.html</a>
  </p>
</div>
