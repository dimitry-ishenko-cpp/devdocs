<h1 id="id1">6.4.14. Visible type application</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="visible-type-application"> <dt id="extension-TypeApplications">
<code>TypeApplications</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Allow the use of type application syntax.</p> </dd>
</dl> <p>The <a class="reference internal" href="#extension-TypeApplications"><code>TypeApplications</code></a> extension allows you to use <em>visible type application</em> in expressions. Here is an example: <code>show (read @Int "5")</code>. The <code>@Int</code> is the visible type application; it specifies the value of the type variable in <code>read</code>’s type.</p> <p>A visible type application is preceded with an <code>@</code> sign. (To disambiguate the syntax, the <code>@</code> must be preceded with a non-identifier letter, usually a space. For example, <code>read@Int 5</code> would not parse.) It can be used whenever the full polymorphic type of the function is known. If the function is an identifier (the common case), its type is considered known only when the identifier has been given a type signature. If the identifier does not have a type signature, visible type application cannot be used.</p> <p>GHC also permits visible kind application, where users can declare the kind arguments to be instantiated in kind-polymorphic cases. Its usage parallels visible type application in the term level, as specified above.</p> <p>In addition to visible type application in terms and types, the type application syntax can be used in patterns matching a data constructor to bind type variables in that constructor’s type.</p>  <h2 id="inferred-vs-specified">6.4.14.1. Inferred vs. specified type variables</h2> <p id="inferred-vs-specified-type-variables">GHC tracks a distinction between what we call <em>inferred</em> and <em>specified</em> type variables. Only specified type variables are available for instantiation with visible type application. An example illustrates this well:</p> <pre data-language="haskell">f :: (Eq b, Eq a) =&gt; a -&gt; b -&gt; Bool
f x y = (x == x) &amp;&amp; (y == y)

g x y = (x == x) &amp;&amp; (y == y)
</pre> <p>The functions <code>f</code> and <code>g</code> have the same body, but only <code>f</code> is given a type signature. When GHC is figuring out how to process a visible type application, it must know what variable to instantiate. It thus must be able to provide an ordering to the type variables in a function’s type.</p> <p>If the user has supplied a type signature, as in <code>f</code>, then this is easy: we just take the ordering from the type signature, going left to right and using the first occurrence of a variable to choose its position within the ordering. Thus, the variables in <code>f</code> will be <code>b</code>, then <code>a</code>.</p> <p>In contrast, there is no reliable way to do this for <code>g</code>; we will not know whether <code>Eq a</code> or <code>Eq b</code> will be listed first in the constraint in <code>g</code>’s type. In order to have visible type application be robust between releases of GHC, we thus forbid its use with <code>g</code>.</p> <p>We say that the type variables in <code>f</code> are <em>specified</em>, while those in <code>g</code> are <em>inferred</em>. The general rule is this: if the user has written a type variable in the source program, it is <em>specified</em>; if not, it is <em>inferred</em>.</p> <p>This rule applies in datatype declarations, too. For example, if we have <code>data Proxy a = Proxy</code> (and <a class="reference internal" href="poly_kinds.html#extension-PolyKinds"><code>PolyKinds</code></a> is enabled), then <code>a</code> will be assigned kind <code>k</code>, where <code>k</code> is a fresh kind variable. Because <code>k</code> was not written by the user, it will be unavailable for type application in the type of the constructor <code>Proxy</code>; only the <code>a</code> will be available.</p> <p>Inferred variables are printed in braces. Thus, the type of the data constructor <code>Proxy</code> from the previous example is <code>forall {k} (a :: k). Proxy a</code>. We can observe this behavior in a GHCi session:</p> <pre data-language="haskell">&gt; :set -XTypeApplications -fprint-explicit-foralls
&gt; let myLength1 :: Foldable f =&gt; f a -&gt; Int; myLength1 = length
&gt; :type myLength1
myLength1 :: forall (f :: * -&gt; *) a. Foldable f =&gt; f a -&gt; Int
&gt; let myLength2 = length
&gt; :type myLength2
myLength2 :: forall {t :: * -&gt; *} {a}. Foldable t =&gt; t a -&gt; Int
&gt; :type myLength2 @[]

&lt;interactive&gt;:1:1: error:
    • Cannot apply expression of type ‘t0 a0 -&gt; Int’
      to a visible type argument ‘[]’
    • In the expression: myLength2 @[]
</pre> <p>Notice that since <code>myLength1</code> was defined with an explicit type signature, <a class="reference internal" href="../ghci.html#ghci-cmd-:type"><code>:type</code></a> reports that all of its type variables are available for type application. On the other hand, <code>myLength2</code> was not given a type signature. As a result, all of its type variables are surrounded with braces, and trying to use visible type application with <code>myLength2</code> fails.</p>   <h2 id="index-1">6.4.14.2. Ordering of specified variables</h2> <p id="ordering-of-specified-variables">In the simple case of the previous section, we can say that specified variables appear in left-to-right order. However, not all cases are so simple. Here are the rules in the subtler cases:</p> <ul> <li>If an identifier’s type has a <code>forall</code>, then the order of type variables as written in the <code>forall</code> is retained. </li> <li>
<p class="first">If any of the variables depend on other variables (that is, if some of the variables are <em>kind</em> variables), the variables are reordered so that kind variables come before type variables, preserving the left-to-right order as much as possible. That is, GHC performs a stable topological sort on the variables. Example:</p> <pre data-language="haskell">h :: Proxy (a :: (j, k)) -&gt; Proxy (b :: Proxy a) -&gt; ()
  -- as if h :: forall j k a b. ...
</pre> <p>In this example, <code>a</code> depends on <code>j</code> and <code>k</code>, and <code>b</code> depends on <code>a</code>. Even though <code>a</code> appears lexically before <code>j</code> and <code>k</code>, <code>j</code> and <code>k</code> are quantified first, because <code>a</code> depends on <code>j</code> and <code>k</code>. Note further that <code>j</code> and <code>k</code> are not reordered with respect to each other, even though doing so would not violate dependency conditions.</p> <p>A “stable topological sort” here, we mean that we perform this algorithm (which we call <em>ScopedSort</em>):</p> <ul class="simple"> <li>Work left-to-right through the input list of type variables, with a cursor.</li> <li>If variable <code>v</code> at the cursor is depended on by any earlier variable <code>w</code>, move <code>v</code> immediately before the leftmost such <code>w</code>.</li> </ul> </li> <li>Class methods’ type arguments include the class type variables, followed by any variables an individual method is polymorphic in. So, <code>class Monad m where return :: a -&gt; m a</code> means that <code>return</code>’s type arguments are <code>m, a</code>. </li> <li>With the <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code>RankNTypes</code></a> extension (<a class="reference internal" href="scoped_type_variables.html#universal-quantification"><span class="std std-ref">Lexically scoped type variables</span></a>), it is possible to declare type arguments somewhere other than the beginning of a type. For example, we can have <code>pair :: forall a. a -&gt; forall b. b -&gt; (a, b)</code> and then say <code>pair @Bool True @Char</code> which would have type <code>Char -&gt; (Bool, Char)</code>. </li> <li>Partial type signatures (<a class="reference internal" href="partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>) work nicely with visible type application. If you want to specify only the second type argument to <code>wurble</code>, then you can say <code>wurble @_ @Int</code>. The first argument is a wildcard, just like in a partial type signature. However, if used in a visible type application/visible kind application, it is <em>not</em> necessary to specify <a class="reference internal" href="partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> and your code will not generate a warning informing you of the omitted type. </li> </ul> <p>The section in this manual on kind polymorphism describes how variables in type and class declarations are ordered (<a class="reference internal" href="poly_kinds.html#inferring-variable-order"><span class="std std-ref">Inferring the order of variables in a type/class declaration</span></a>).</p>   <h2 id="id2">6.4.14.3. Manually defining inferred variables</h2> <p id="manually-defining-inferred-variables">Since the 9.0.1 release, GHC permits labelling the user-written type or kind variables as <em>inferred</em>, in contrast to the default of <em>specified</em>. By writing the type variable binder in braces as <code>{tyvar}</code> or <code>{tyvar :: kind}</code>, the new variable will be classified as inferred, not specified. Doing so gives the programmer control over which variables can be manually instantiated and which can’t. Note that the braces do not influence scoping: variables in braces are still brought into scope just the same. Consider for example:</p> <pre data-language="haskell">myConst :: forall {a} b. a -&gt; b -&gt; a
myConst x _ = x
</pre> <p>In this example, despite both variables appearing in a type signature, <code>a</code> is an inferred variable while <code>b</code> is specified. This means that the expression <code>myConst @Int</code> has type <code>forall {a}. a -&gt; Int -&gt; a</code>.</p> <p>The braces are allowed in the following places:</p> <ul> <li>In the type signatures of functions, variables, class methods, as well as type annotations on expressions. Consider the example above. </li> <li>
<p class="first">In data constructor declarations, using the GADT syntax. Consider:</p> <pre data-language="haskell">data T a where MkT :: forall {k} (a :: k). Proxy a -&gt; T a
</pre> <p>The constructor <code>MkT</code> defined in this example is kind polymorphic, which is emphasized to the reader by explicitly abstracting over the <code>k</code> variable. As this variable is marked as inferred, it can not be manually instantiated.</p> </li> <li>
<p class="first">In existential variable quantifications, e.g.:</p> <pre data-language="haskell">data HList = HNil
           | forall {a}. HCons a HList
</pre> </li> <li>
<p class="first">In pattern synonym signatures. Consider for instance:</p> <pre data-language="haskell">data T a where MkT :: forall a b. a -&gt; b -&gt; T a

pattern Pat :: forall {c}. () =&gt; forall {d}. c -&gt; d -&gt; T c
pattern Pat x y = MkT x y
</pre> <p>Note that in this example, <code>a</code> is a universal variable in the data type <code>T</code>, where <code>b</code> is existential. When writing the pattern synonym, both types are allowed to be specified or inferred.</p> </li> <li>
<p class="first">On the right-hand side of a type synonym, e.g.:</p> <pre data-language="haskell">type Foo = forall a {b}. Either a b
</pre> </li> <li>
<p class="first">In type signatures on variables bound in RULES, e.g.:</p> <pre data-language="haskell">{-# RULES "parametricity" forall (f :: forall {a}. a -&gt; a). map f = id #-}
</pre> </li> </ul> <p>The braces are <em>not</em> allowed in the following places:</p> <ul> <li>
<p class="first">In visible dependent quantifiers. Consider:</p> <pre data-language="haskell">data T :: forall {k} -&gt; k -&gt; Type
</pre> <p>This example is rejected, as a visible argument should by definition be explicitly applied. Making them inferred (and thus not appliable) would be conflicting.</p> </li> <li>
<p class="first">In SPECIALISE pragmas or in instance declaration heads, e.g.:</p> <pre data-language="haskell">instance forall {a}. Eq (Maybe a) where ...
</pre> <p>The reason for this is, essentially, that none of these define a new construct. This means that no new type is being defined where specificity could play a role.</p> </li> <li>On the left-hand sides of type declarations, such as classes, data types, etc. </li> </ul> <p>Note that while specified and inferred type variables have different properties vis-à-vis visible type application, they do not otherwise affect GHC’s notion of equality over types. For example, given the following definitions:</p> <pre data-language="haskell">id1 :: forall a. a -&gt; a
id1 x = x

id2 :: forall {a}. a -&gt; a
id2 x = x

app1 :: (forall a. a -&gt; a) -&gt; b -&gt; b
app1 g x = g x

app2 :: (forall {a}. a -&gt; a) -&gt; b -&gt; b
app2 g x = g x
</pre> <p>GHC will deem all of <code>app1 id1</code>, <code>app1 id2</code>, <code>app2 id1</code>, and <code>app2 id2</code> to be well typed.</p>   <h2 id="id3">6.4.14.4. Type Applications in Patterns</h2> <p id="type-applications-in-patterns">The type application syntax can be used in patterns that match a data constructor. The syntax can’t be used with record patterns or infix patterns. This is useful in particular to bind existential type variables associated with a GADT data constructor as in the following example:</p> <pre data-language="haskell">{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeApplications #-}
import Data.Proxy

data Foo where
  Foo :: forall a. (Show a, Num a) =&gt; Foo

test :: Foo -&gt; String
test x = case x of
  Foo @t -&gt; show @t 0

main :: IO ()
main = print $ test (Foo @Float)
</pre> <p>In this example, the case in <code>test`</code> is binding an existential variable introduced by <code>Foo</code> that otherwise could not be named and used.</p> <p>It’s possible to bind variables to any part of the type arguments to a constructor; there is no need for them to be existential. In addition, it’s possible to “match” against part of the type argument using type constructors.</p> <p>For a somewhat-contrived example:</p> <pre data-language="haskell">foo :: (Num a) =&gt; Maybe [a] -&gt; String
foo (Nothing @[t]) = show (0 :: t)
foo (Just @[t] xs) = show (sum xs :: t)
</pre> <p>Here, we’re binding the type variable t to be the type of the elements of the list type which is itself the argument to Maybe.</p> <p>The order of the type arguments specified by the type applications in a pattern is the same as that for an expression: either the order as given by the user in an explicit <code>forall</code> in the definition of the data constructor, or if that is not present, the order in which the type variables appear in its type signature from left to right.</p> <p>For example if we have the following declaration in GADT syntax:</p> <pre data-language="haskell">data Foo :: * -&gt; * where
  A :: forall s t. [(t,s)] -&gt; Foo (t,s)
  B :: (t,s) -&gt; Foo (t,s)
</pre> <p>Then the type arguments to <code>A</code> will match first <code>s</code> and then <code>t</code>, while the type arguments to <code>B</code> will match first <code>t</code> and then <code>s</code>.</p> <p>Type arguments appearing in patterns can influence the inferred type of a definition:</p> <pre data-language="haskell">foo (Nothing @Int) = 0
foo (Just x) = x
</pre> <p>will have inferred type:</p> <pre data-language="haskell">foo :: Maybe Int -&gt; Int
</pre> <p>which is more restricted than what it would be without the application:</p> <pre data-language="haskell">foo :: Num a =&gt; Maybe a -&gt; a
</pre> <p>For more information and detail regarding type applications in patterns, see the paper <a class="reference external" href="https://arxiv.org/pdf/1806.03476">Type variables in patterns</a> by Eisenberg, Breitner and Peyton Jones. Relative to that paper, the implementation in GHC for now at least makes one additional conservative restriction, that type variables occurring in patterns must not already be in scope, and so are always new variables that only bind whatever type is matched, rather than ever referring to a variable from an outer scope. Type wildcards <code>_</code> may be used in any place where no new variable needs binding.</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/type_applications.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/type_applications.html</a>
  </p>
</div>
