<h1 id="mono-local-binds">6.12.2. Let-generalisation</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="let-generalisation"> <dt id="extension-MonoLocalBinds">
<code>MonoLocalBinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12.1</td> </tr>  </table> <p>Infer less polymorphic types for local bindings by default.</p> </dd>
</dl> <p>An ML-style language usually generalises the type of any let-bound or where-bound variable, so that it is as polymorphic as possible. With the extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> GHC implements a slightly more conservative policy, for reasons descibed in Section 4.2 of <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/">OutsideIn(X): Modular type inference with local assumptions</a>, and a <a class="reference external" href="https://www.haskell.org/ghc/blog/20100930-LetGeneralisationInGhc7.html">related blog post</a>.</p> <p>The extension <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> is implied by <a class="reference internal" href="type_families.html#extension-TypeFamilies"><code>TypeFamilies</code></a> and <a class="reference internal" href="gadt.html#extension-GADTs"><code>GADTs</code></a>. You can switch it off again with <a class="reference internal" href="#extension-MonoLocalBinds"><code>NoMonoLocalBinds</code></a> but type inference becomes less predictable if you do so. (Read the paper!)</p> <p>To a first approximation, with <a class="reference internal" href="#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> <em>top-level bindings are generalised, but local (i.e. nested) bindings are not</em>. The idea is that, at top level, the type environment has no free type variables, and so the difficulties described in these papers do not arise. But GHC implements a slightly more complicated rule because, for stylistic reasons, programmers sometimes write local bindings that make no use of local variables, so the binding could equally well be top-level. It seems reasonable to generalise these.</p> <p>So here are the exact rules used by MonoLocalBinds. With MonoLocalBinds, a binding group will be <em>generalised</em> if and only if</p> <ul class="simple"> <li>It is a top-level binding group, or</li> <li>Each of its free variables (excluding the variables bound by the group itself) is <em>closed</em> (see next bullet), or</li> <li>Any of its binders has a partial type signature (see Partial Type Signatures). Adding a partial type signature <code>f :: _</code>, (or, more generally, <code>f :: _ =&gt; _</code>) provides a per-binding way to ask GHC to perform let-generalisation, even though MonoLocalBinds is on.</li> </ul> <p>Even if the binding is generalised, it may not be generalised over all its free type variables, either because it mentions locally-bound variables, or because of the Monomorphism Restriction (Haskell Report, Section 4.5.5)</p> <p><em>Closed variables</em>. The key idea is that: <em>if a variable is closed, then its type definitely has no free type variables</em>. A variable <code>f</code> is called <em>closed</em> if and only if</p> <ul class="simple"> <li>The variable <code>f</code> is imported from another module, or</li> <li>The variable <code>f</code> is let-bound, and one of the following holds:<ul> <li>
<code>f</code> has an explicit, complete (i.e. not partial) type signature that has no free type variables, or</li> <li>its binding group is generalised over all its free type variables, so that <code>f</code>’s type has no free type variables.</li> </ul> </li> </ul> <p>Note that a signature like f :: a -&gt; a is equivalent to <code>f :: forall a. a -&gt; a</code>, assuming <code>a</code> is not in scope. Hence <code>f</code> is closed, since it has a complete type signature with no free variables.</p> <p>Example 1</p> <pre data-language="haskell">g v = ...
    where
      f1 x = x+1
      f2 y = f1 (y*2)
</pre> <p><code>f1</code> has free variable <code>(+)</code>, but it is imported and hence closed. So <code>f1</code>’s binding is generalised. As a result, its type <code>f1 :: forall a. Num a =&gt; a -&gt; a</code> has no free type variables, so <code>f1</code> is closed. Hence <code>f2</code>’s binding is generalised (since its free variables, <code>f1</code> and <code>(*)</code> are both closed).</p> <p>Example 2</p> <pre data-language="haskell">f3 x = let g y = x+y in ....
</pre> <p>The binding for <code>g</code> has a free variable <code>x</code> that is lambda-bound, and hence not closed. So <code>g</code>’s binding is not generalised.</p> <p><em>Top-level bindings</em>. The Monomorphism Restriction can cause even top-level bindings not to be generalised, and hence even the top-level type environment can have free type variables. However, top-level bindings are nevertheless always generalised. To see why, consider</p> <pre data-language="haskell">module M( f ) where
  x = 5
  f v = (v,x)
</pre> <p>The binding <code>x=5</code> falls under the Monomorphism Restriction, so that binding is not generalised, and hence <code>f</code>’s binding is not closed. If, as a result, we did not generalise <code>f</code>, we would end up exporting <code>f :: Any -&gt; (Any, Integer)</code>, defaulting <code>x</code>’s type to <code>Integer</code> and <code>v</code>’s type to <code>Any</code>. This is counter-intuitive and undesirable, so we always generalise top-level bindings.</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/let_generalisation.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/let_generalisation.html</a>
  </p>
</div>
