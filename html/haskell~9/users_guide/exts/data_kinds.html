<h1 id="promotion">6.4.10. Datatype promotion</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="datatype-promotion"> <dt id="extension-DataKinds">
<code>DataKinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Allow promotion of data types to kind level.</p> </dd>
</dl> <p>This section describes <em>data type promotion</em>, an extension to the kind system that complements kind polymorphism. It is enabled by <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, and described in more detail in the paper <a class="reference external" href="https://dreixel.net/research/pdf/ghp.pdf">Giving Haskell a Promotion</a>, which appeared at TLDI 2012.</p>  <h2 id="motivation">6.4.10.1. Motivation</h2> <p>Standard Haskell has a rich type language. Types classify terms and serve to avoid many common programming mistakes. The kind language, however, is relatively simple, distinguishing only regular types (kind <code>Type</code>) and type constructors (e.g. kind <code>Type -&gt; Type -&gt; Type</code>). In particular when using advanced type system features, such as type families (<a class="reference internal" href="type_families.html#type-families"><span class="std std-ref">Type families</span></a>) or GADTs (<a class="reference internal" href="gadt.html#gadt"><span class="std std-ref">Generalised Algebraic Data Types (GADTs)</span></a>), this simple kind system is insufficient, and fails to prevent simple errors. Consider the example of type-level natural numbers, and length-indexed vectors:</p> <pre data-language="haskell">data Ze
data Su n

data Vec :: Type -&gt; Type -&gt; Type where
  Nil  :: Vec a Ze
  Cons :: a -&gt; Vec a n -&gt; Vec a (Su n)
</pre> <p>The kind of <code>Vec</code> is <code>Type -&gt; Type -&gt; Type</code>. This means that, e.g., <code>Vec Int Char</code> is a well-kinded type, even though this is not what we intend when defining length-indexed vectors.</p> <p>With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, the example above can then be rewritten to:</p> <pre data-language="haskell">data Nat = Ze | Su Nat

data Vec :: Type -&gt; Nat -&gt; Type where
  Nil  :: Vec a Ze
  Cons :: a -&gt; Vec a n -&gt; Vec a (Su n)
</pre> <p>With the improved kind of <code>Vec</code>, things like <code>Vec Int Char</code> are now ill-kinded, and GHC will report an error.</p>   <h2 id="overview">6.4.10.2. Overview</h2> <p>With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, GHC automatically promotes every datatype to be a kind and its (value) constructors to be type constructors. The following types</p> <pre data-language="haskell">data Nat = Zero | Succ Nat

data List a = Nil | Cons a (List a)

data Pair a b = MkPair a b

data Sum a b = L a | R b
</pre> <p>give rise to the following kinds and type constructors:</p> <pre data-language="haskell">Nat :: Type
Zero :: Nat
Succ :: Nat -&gt; Nat

List :: Type -&gt; Type
Nil  :: forall k. List k
Cons :: forall k. k -&gt; List k -&gt; List k

Pair  :: Type -&gt; Type -&gt; Type
MkPair :: forall k1 k2. k1 -&gt; k2 -&gt; Pair k1 k2

Sum :: Type -&gt; Type -&gt; Type
L :: k1 -&gt; Sum k1 k2
R :: k2 -&gt; Sum k1 k2
</pre> <p>Virtually all data constructors, even those with rich kinds, can be promoted. There are only a couple of exceptions to this rule:</p> <ul> <li>Data family instance constructors cannot be promoted at the moment. GHC’s type theory just isn’t up to the task of promoting data families, which requires full dependent types. </li> <li>
<p class="first">Data constructors with contexts that contain non-equality constraints cannot be promoted. For example:</p> <pre data-language="haskell">data Foo :: Type -&gt; Type where
  MkFoo1 :: a ~ Int         =&gt; Foo a    -- promotable
  MkFoo2 :: a ~~ Int        =&gt; Foo a    -- promotable
  MkFoo3 :: Show a          =&gt; Foo a    -- not promotable
</pre> <p><code>MkFoo1</code> and <code>MkFoo2</code> can be promoted, since their contexts only involve equality-oriented constraints. However, <code>MkFoo3</code>’s context contains a non-equality constraint <code>Show a</code>, and thus cannot be promoted.</p> </li> </ul>   <h2 id="promotion-syntax">6.4.10.3. Distinguishing between types and constructors</h2> <p id="distinguishing-between-types-and-constructors">Consider</p> <pre data-language="haskell">data P = MkP    -- 1

data Prom = P   -- 2
</pre> <p>The name <code>P</code> on the type level will refer to the type <code>P</code> (which has a constructor <code>MkP</code>) rather than the promoted data constructor <code>P</code> of kind <code>Prom</code>. To refer to the latter, prefix it with a single quote mark: <code>'P</code>.</p> <p>This syntax can be used even if there is no ambiguity (i.e. there’s no type <code>P</code> in scope).</p> <p>GHC supports <a class="reference internal" href="../using-warnings.html#ghc-flag--Wunticked-promoted-constructors"><code>-Wunticked-promoted-constructors</code></a> that warns whenever a promoted data constructor is written without a quote mark. As of GHC 9.4, this warning is no longer enabled by <a class="reference internal" href="../using-warnings.html#ghc-flag--Wall"><code>-Wall</code></a>; we no longer recommend quote marks as a preferred default (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/20531">#20531</a>).</p> <p>Just as in the case of Template Haskell (<a class="reference internal" href="template_haskell.html#th-syntax"><span class="std std-ref">Syntax</span></a>), GHC gets confused if you put a quote mark before a data constructor whose second character is a quote mark. In this case, just put a space between the promotion quote and the data constructor:</p> <pre data-language="haskell">data T = A'
type S = 'A'   -- ERROR: looks like a character
type R = ' A'  -- OK: promoted `A'`
</pre>   <h2 id="type-level-literals">6.4.10.4. Type-level literals</h2> <p><a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a> enables the use of numeric and string literals at the type level. For more information, see <a class="reference internal" href="type_literals.html#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a>.</p>   <h2 id="promoted-lists-and-tuples">6.4.10.5. Promoted list and tuple types</h2> <p id="promoted-list-and-tuple-types">With <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>, Haskell’s list and tuple types are natively promoted to kinds, and enjoy the same convenient syntax at the type level, albeit prefixed with a quote:</p> <pre data-language="haskell">data HList :: [Type] -&gt; Type where
  HNil  :: HList '[]
  HCons :: a -&gt; HList t -&gt; HList (a ': t)

data Tuple :: (Type,Type) -&gt; Type where
  Tuple :: a -&gt; b -&gt; Tuple '(a,b)

foo0 :: HList '[]
foo0 = HNil

foo1 :: HList '[Int]
foo1 = HCons (3::Int) HNil

foo2 :: HList [Int, Bool]
foo2 = ...
</pre> <p>For type-level lists of <em>two or more elements</em>, such as the signature of <code>foo2</code> above, the quote may be omitted because the meaning is unambiguous. But for lists of one or zero elements (as in <code>foo0</code> and <code>foo1</code>), the quote is required, because the types <code>[]</code> and <code>[Int]</code> have existing meanings in Haskell.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">The declaration for <code>HCons</code> also requires <a class="reference internal" href="type_operators.html#extension-TypeOperators"><code>TypeOperators</code></a> because of infix type operator <code>(':)</code></p> </div>   <h2 id="promotion-existentials">6.4.10.6. Promoting existential data constructors</h2> <p id="promoting-existential-data-constructors">Note that we do promote existential data constructors that are otherwise suitable. For example, consider the following:</p> <pre data-language="haskell">data Ex :: Type where
  MkEx :: forall a. a -&gt; Ex
</pre> <p>Both the type <code>Ex</code> and the data constructor <code>MkEx</code> get promoted, with the polymorphic kind <code>'MkEx :: forall k. k -&gt; Ex</code>. Somewhat surprisingly, you can write a type family to extract the member of a type-level existential:</p> <pre data-language="haskell">type family UnEx (ex :: Ex) :: k
type instance UnEx (MkEx x) = x
</pre> <p>At first blush, <code>UnEx</code> seems poorly-kinded. The return kind <code>k</code> is not mentioned in the arguments, and thus it would seem that an instance would have to return a member of <code>k</code> <em>for any</em> <code>k</code>. However, this is not the case. The type family <code>UnEx</code> is a kind-indexed type family. The return kind <code>k</code> is an implicit parameter to <code>UnEx</code>. The elaborated definitions are as follows (where implicit parameters are denoted by braces):</p> <pre data-language="haskell">type family UnEx {k :: Type} (ex :: Ex) :: k
type instance UnEx {k} (MkEx @k x) = x
</pre> <p>Thus, the instance triggers only when the implicit parameter to <code>UnEx</code> matches the implicit parameter to <code>MkEx</code>. Because <code>k</code> is actually a parameter to <code>UnEx</code>, the kind is not escaping the existential, and the above code is valid.</p> <p>See also <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/7347">#7347</a>.</p>   <h2 id="id1">6.4.10.7. Constraints in kinds</h2> <p id="constraints-in-kinds">Kinds can (with <a class="reference internal" href="#extension-DataKinds"><code>DataKinds</code></a>) contain type constraints. However, only equality constraints are supported.</p> <p>Here is an example of a constrained kind:</p> <pre data-language="haskell">type family IsTypeLit a where
  IsTypeLit Nat    = True
  IsTypeLit Symbol = True
  IsTypeLit a      = False

data T :: forall a. (IsTypeLit a ~ True) =&gt; a -&gt; Type where
  MkNat    :: T 42
  MkSymbol :: T "Don't panic!"
</pre> <p>The declarations above are accepted. However, if we add <code>MkOther :: T Int</code>, we get an error that the equality constraint is not satisfied; <code>Int</code> is not a type literal. Note that explicitly quantifying with <code>forall a</code> is necessary in order for <code>T</code> to typecheck (see <a class="reference internal" href="poly_kinds.html#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>).</p>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/data_kinds.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/data_kinds.html</a>
  </p>
</div>
