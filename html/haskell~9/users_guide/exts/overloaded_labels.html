<h1 id="id1">6.9.7. Overloaded labels</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="overloaded-labels"> <dt id="extension-OverloadedLabels">
<code>OverloadedLabels</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enable use of the <code>#foo</code> overloaded label syntax.</p> </dd>
</dl> <p>GHC supports <em>overloaded labels</em>, a form of identifier whose interpretation may depend both on its type and on its literal text. When the <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> extension is enabled, an overloaded label can be written with a prefix hash, for example <code>#foo</code>. The type of this expression is <code>IsLabel "foo" a =&gt; a</code>.</p> <p>The class <code>IsLabel</code> is defined as:</p> <pre data-language="haskell">class IsLabel (x :: Symbol) a where
  fromLabel :: a
</pre> <p>This is rather similar to the class <code>IsString</code> (see <a class="reference internal" href="overloaded_strings.html#overloaded-strings"><span class="std std-ref">Overloaded string literals</span></a>), but with an additional type parameter that makes the text of the label available as a type-level string (see <a class="reference internal" href="type_literals.html#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a>). Note that <code>fromLabel</code> had an extra <code>Proxy# x</code> argument in GHC 8.0, but this was removed in GHC 8.2 as a type application (see <a class="reference internal" href="type_applications.html#visible-type-application"><span class="std std-ref">Visible type application</span></a>) can be used instead.</p> <p>There are no predefined instances of this class. It is not in scope by default, but can be brought into scope by importing <a class="reference external" href="../../libraries/base-4.17.0.0/ghc-overloadedlabels.html">GHC.OverloadedLabels</a>. Unlike <code>IsString</code>, there are no special defaulting rules for <code>IsLabel</code>.</p> <p>During typechecking, GHC will replace an occurrence of an overloaded label like <code>#foo</code> with <code>fromLabel @"foo"</code>. This will have some type <code>alpha</code> and require the solution of a class constraint <code>IsLabel "foo" alpha</code>.</p> <p>The intention is for <code>IsLabel</code> to be used to support overloaded record fields and perhaps anonymous records. Thus, it may be given instances for base datatypes (in particular <code>(-&gt;)</code>) in the future.</p> <p>If <a class="reference internal" href="rebindable_syntax.html#extension-RebindableSyntax"><code>RebindableSyntax</code></a> is enabled, overloaded labels will be desugared using whatever <code>fromLabel</code> function is in scope, rather than always using <code>GHC.OverloadedLabels.fromLabel</code>.</p> <p>When writing an overloaded label, there must be no space between the hash sign and the following identifier. The <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code>MagicHash</code></a> extension makes use of postfix hash signs; if <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> and <a class="reference internal" href="magic_hash.html#extension-MagicHash"><code>MagicHash</code></a> are both enabled then <code>x#y</code> means <code>x# y</code>, but if only <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> is enabled then it means <code>x #y</code>. The <a class="reference internal" href="primitives.html#extension-UnboxedTuples"><code>UnboxedTuples</code></a> extension makes <code>(#</code> a single lexeme, so when <a class="reference internal" href="primitives.html#extension-UnboxedTuples"><code>UnboxedTuples</code></a> is enabled you must write a space between an opening parenthesis and an overloaded label. To avoid confusion, you are strongly encouraged to put a space before the hash when using <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a>.</p> <p>When using <a class="reference internal" href="#extension-OverloadedLabels"><code>OverloadedLabels</code></a> (or other extensions that make use of hash signs) in a <code>.hsc</code> file (see <a class="reference internal" href="../utils.html#hsc2hs"><span class="std std-ref">Writing Haskell interfaces to C code: hsc2hs</span></a>), the hash signs must be doubled (write <code>##foo</code> instead of <code>#foo</code>) to avoid them being treated as <code>hsc2hs</code> directives.</p> <p>Here is an extension of the record access example in <a class="reference internal" href="type_literals.html#type-level-literals"><span class="std std-ref">Type-Level Literals</span></a> showing how an overloaded label can be used as a record selector:</p> <pre data-language="haskell">{-# LANGUAGE DataKinds, KindSignatures, MultiParamTypeClasses,
             FunctionalDependencies, FlexibleInstances,
             OverloadedLabels, ScopedTypeVariables #-}

import GHC.OverloadedLabels (IsLabel(..))
import GHC.TypeLits (Symbol)

data Label (l :: Symbol) = Get

class Has a l b | a l -&gt; b where
  from :: a -&gt; Label l -&gt; b

data Point = Point Int Int deriving Show

instance Has Point "x" Int where from (Point x _) _ = x
instance Has Point "y" Int where from (Point _ y) _ = y

instance Has a l b =&gt; IsLabel l (a -&gt; b) where
  fromLabel x = from x (Get :: Label l)

example = #x (Point 1 2)
</pre>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/overloaded_labels.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/overloaded_labels.html</a>
  </p>
</div>
