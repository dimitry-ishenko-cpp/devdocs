<h1 id="id1">6.4.11. Kind polymorphism</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <dl class="extension" id="kind-polymorphism"> <dt id="extension-TypeInType">
<code>TypeInType</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, <a class="reference internal" href="data_kinds.html#extension-DataKinds"><code>DataKinds</code></a>, <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a>
</td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>The extension <a class="reference internal" href="#extension-TypeInType"><code>TypeInType</code></a> is now deprecated: its sole effect is to switch on <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> (and hence <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a>) and <a class="reference internal" href="data_kinds.html#extension-DataKinds"><code>DataKinds</code></a>.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-PolyKinds">
<code>PolyKinds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4.1</td> </tr>  </table> <p>Allow kind polymorphic types.</p> </dd>
</dl> <p>This section describes GHC’s kind system, as it appears in version 8.0 and beyond. The kind system as described here is always in effect, with or without extensions, although it is a conservative extension beyond standard Haskell. The extensions above simply enable syntax and tweak the inference algorithm to allow users to take advantage of the extra expressiveness of GHC’s kind system.</p>  <h2 id="overview-of-kind-polymorphism">6.4.11.1. Overview of kind polymorphism</h2> <p>Consider inferring the kind for</p> <pre data-language="haskell">data App f a = MkApp (f a)
</pre> <p>In Haskell 98, the inferred kind for <code>App</code> is <code>(Type -&gt; Type) -&gt; Type -&gt;
Type</code>. But this is overly specific, because another suitable Haskell 98 kind for <code>App</code> is <code>((Type -&gt; Type) -&gt; Type) -&gt; (Type -&gt; Type) -&gt; Type</code>, where the kind assigned to <code>a</code> is <code>Type -&gt; Type</code>. Indeed, without kind signatures (<a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a>), it is necessary to use a dummy constructor to get a Haskell compiler to infer the second kind. With kind polymorphism (<a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>), GHC infers the kind <code>forall k. (k -&gt; Type) -&gt; k -&gt;
Type</code> for <code>App</code>, which is its most general kind.</p> <p>Thus, the chief benefit of kind polymorphism is that we can now infer these most general kinds and use <code>App</code> at a variety of kinds:</p> <pre data-language="haskell">App Maybe Int   -- `k` is instantiated to Type

data T a = MkT (a Int)    -- `a` is inferred to have kind (Type -&gt; Type)
App T Maybe     -- `k` is instantiated to (Type -&gt; Type)
</pre>   <h2 id="overview-of-type-in-type">6.4.11.2. Overview of Type-in-Type</h2> <p>GHC 8 extends the idea of kind polymorphism by declaring that types and kinds are indeed one and the same. Nothing within GHC distinguishes between types and kinds. Another way of thinking about this is that the type <code>Bool</code> and the “promoted kind” <code>Bool</code> are actually identical. (Note that term <code>True</code> and the type <code>'True</code> are still distinct, because the former can be used in expressions and the latter in types.) This lack of distinction between types and kinds is a hallmark of dependently typed languages. Full dependently typed languages also remove the difference between expressions and types, but doing that in GHC is a story for another day.</p> <p>One simplification allowed by combining types and kinds is that the type of <code>Type</code> is just <code>Type</code>. It is true that the <code>Type :: Type</code> axiom can lead to non-termination, but this is not a problem in GHC, as we already have other means of non-terminating programs in both types and expressions. This decision (among many, many others) <em>does</em> mean that despite the expressiveness of GHC’s type system, a “proof” you write in Haskell is not an irrefutable mathematical proof. GHC promises only partial correctness, that if your programs compile and run to completion, their results indeed have the types assigned. It makes no claim about programs that do not finish in a finite amount of time.</p> <p>To learn more about this decision and the design of GHC under the hood please see the <a class="reference external" href="https://www.seas.upenn.edu/~sweirich/papers/fckinds.pdf">paper</a> introducing this kind system to GHC/Haskell.</p>   <h2 id="principles-of-kind-inference">6.4.11.3. Principles of kind inference</h2> <p>Generally speaking, when <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> is on, GHC tries to infer the most general kind for a declaration. In many cases (for example, in a datatype declaration) the definition has a right-hand side to inform kind inference. But that is not always the case. Consider</p> <pre data-language="haskell">type family F a
</pre> <p>Type family declarations have no right-hand side, but GHC must still infer a kind for <code>F</code>. Since there are no constraints, it could infer <code>F :: forall k1 k2. k1 -&gt; k2</code>, but that seems <em>too</em> polymorphic. So GHC defaults those entirely-unconstrained kind variables to <code>Type</code> and we get <code>F :: Type -&gt; Type</code>. You can still declare <code>F</code> to be kind-polymorphic using kind signatures:</p> <pre data-language="haskell">type family F1 a                -- F1 :: Type -&gt; Type
type family F2 (a :: k)         -- F2 :: forall k. k -&gt; Type
type family F3 a :: k           -- F3 :: forall k. Type -&gt; k
type family F4 (a :: k1) :: k2  -- F4 :: forall k1 k2. k1 -&gt; k2
</pre> <p>The general principle is this:</p> <ul class="simple"> <li>When there is a right-hand side, GHC infers the most polymorphic kind consistent with the right-hand side. Examples: ordinary data type and GADT declarations, class declarations. In the case of a class declaration the role of “right hand side” is played by the class method signatures.</li> <li>When there is no right hand side, GHC defaults argument and result kinds to <code>Type</code>, except when directed otherwise by a kind signature. Examples: data and open type family declarations.</li> </ul> <p>This rule has occasionally-surprising consequences (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10132">#10132</a>).</p> <pre data-language="haskell">class C a where    -- Class declarations are generalised
                   -- so C :: forall k. k -&gt; Constraint
  data D1 a        -- No right hand side for these two family
  type F1 a        -- declarations, but the class forces (a :: k)
                   -- so   D1, F1 :: forall k. k -&gt; Type

data D2 a   -- No right-hand side so D2 :: Type -&gt; Type
type F2 a   -- No right-hand side so F2 :: Type -&gt; Type
</pre> <p>The kind-polymorphism from the class declaration makes <code>D1</code> kind-polymorphic, but not so <code>D2</code>; and similarly <code>F1</code>, <code>F2</code>.</p>   <h2 id="kind-inference-in-type-signatures">6.4.11.4. Kind inference in type signatures</h2> <p>When kind-checking a type, GHC considers only what is written in that type when figuring out how to generalise the type’s kind.</p> <p>For example, consider these definitions (with <a class="reference internal" href="scoped_type_variables.html#extension-ScopedTypeVariables"><code>ScopedTypeVariables</code></a>):</p> <pre data-language="haskell">data Proxy a    -- Proxy :: forall k. k -&gt; Type
p :: forall a. Proxy a
p = Proxy :: Proxy (a :: Type)
</pre> <p>GHC reports an error, saying that the kind of <code>a</code> should be a kind variable <code>k</code>, not <code>Type</code>. This is because, by looking at the type signature <code>forall a. Proxy a</code>, GHC assumes <code>a</code>’s kind should be generalised, not restricted to be <code>Type</code>. The function definition is then rejected for being more specific than its type signature.</p>   <h2 id="id2">6.4.11.5. Explicit kind quantification</h2> <p id="explicit-kind-quantification">Enabled by <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, GHC supports explicit kind quantification, as in these examples:</p> <pre data-language="haskell">data Proxy :: forall k. k -&gt; Type
f :: (forall k (a :: k). Proxy a -&gt; ()) -&gt; Int
</pre> <p>Note that the second example has a <code>forall</code> that binds both a kind <code>k</code> and a type variable <code>a</code> of kind <code>k</code>. In general, there is no limit to how deeply nested this sort of dependency can work. However, the dependency must be well-scoped: <code>forall (a :: k) k. ...</code> is an error.</p>   <h2 id="inferring-variable-order">6.4.11.6. Inferring the order of variables in a type/class declaration</h2> <p id="inferring-the-order-of-variables-in-a-type-class-declaration">It is possible to get intricate dependencies among the type variables introduced in a type or class declaration. Here is an example:</p> <pre data-language="haskell">data T a (b :: k) c = MkT (a c)
</pre> <p>After analysing this declaration, GHC will discover that <code>a</code> and <code>c</code> can be kind-polymorphic, with <code>a :: k2 -&gt; Type</code> and <code>c :: k2</code>. We thus infer the following kind:</p> <pre data-language="haskell">T :: forall {k2 :: Type} (k :: Type). (k2 -&gt; Type) -&gt; k -&gt; k2 -&gt; Type
</pre> <p>Note that <code>k2</code> is placed <em>before</em> <code>k</code>, and that <code>k</code> is placed <em>before</em> <code>a</code>. Also, note that <code>k2</code> is written here in braces. As explained with <a class="reference internal" href="type_applications.html#extension-TypeApplications"><code>TypeApplications</code></a> (<a class="reference internal" href="type_applications.html#inferred-vs-specified"><span class="std std-ref">Inferred vs. specified type variables</span></a>), type and kind variables that GHC generalises over, but not written in the original program, are not available for visible type application. (These are called <em>inferred</em> variables.) Such variables are written in braces.</p> <p>The general principle is this:</p>  <ul class="simple"> <li>Variables not available for type application come first.</li> <li>Then come variables the user has written, implicitly brought into scope in a type variable’s kind.</li> <li>Lastly come the normal type variables of a declaration.</li> <li>Variables not given an explicit ordering by the user are sorted according to ScopedSort (<a class="reference internal" href="type_applications.html#scopedsort"><span class="std std-ref">Ordering of specified variables</span></a>).</li> </ul>  <p>With the <code>T</code> example above, we could bind <code>k</code> <em>after</em> <code>a</code>; doing so would not violate dependency concerns. However, it would violate our general principle, and so <code>k</code> comes first.</p> <p>Sometimes, this ordering does not respect dependency. For example:</p> <pre data-language="haskell">data T2 k (a :: k) (c :: Proxy '[a, b])
</pre> <p>It must be that <code>a</code> and <code>b</code> have the same kind. Note also that <code>b</code> is implicitly declared in <code>c</code>’s kind. Thus, according to our general principle, <code>b</code> must come <em>before</em> <code>k</code>. However, <code>b</code> <em>depends on</em> <code>k</code>. We thus reject <code>T2</code> with a suitable error message.</p> <p>In associated types, we order the type variables as if the type family was a top-level declaration, ignoring the visibilities of the class’s type variable binders. Here is an example:</p> <pre data-language="haskell">class C (a :: k) b where
  type F (c :: j) (d :: Proxy m) a b
</pre> <p>We infer these kinds:</p> <pre data-language="haskell">C :: forall {k1 :: Type} (k :: Type). k -&gt; k1 -&gt; Constraint
F :: forall {k1 :: Type} {k2 :: Type} {k3 :: Type} j (m :: k1).
     j -&gt; Proxy m -&gt; k2 -&gt; k3 -&gt; Type
</pre> <p>Note that the kind of <code>a</code> is specified in the kind of <code>C</code> but inferred in the kind of <code>F</code>.</p> <p>The “general principle” described here is meant to make all this more predictable for users. It would not be hard to extend GHC to relax this principle. If you should want a change here, consider writing a <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/">proposal</a> to do so.</p>   <h2 id="index-0">6.4.11.7. Complete user-supplied kind signatures and polymorphic recursion</h2> <dl class="extension" id="complete-user-supplied-kind-signatures-and-polymorphic-recursion"> <dt id="extension-CUSKs">
<code>CUSKs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10.1</td> </tr>  </table> </dd>
</dl> <p>NB! This is a legacy feature, see <a class="reference internal" href="#extension-StandaloneKindSignatures"><code>StandaloneKindSignatures</code></a> for the modern replacement.</p> <p>Just as in type inference, kind inference for recursive types can only use <em>monomorphic</em> recursion. Consider this (contrived) example:</p> <pre data-language="haskell">data T m a = MkT (m a) (T Maybe (m a))
-- GHC infers kind  T :: (Type -&gt; Type) -&gt; Type -&gt; Type
</pre> <p>The recursive use of <code>T</code> forced the second argument to have kind <code>Type</code>. However, just as in type inference, you can achieve polymorphic recursion by giving a <em>complete user-supplied kind signature</em> (or CUSK) for <code>T</code>. A CUSK is present when all argument kinds and the result kind are known, without any need for inference. For example:</p> <pre data-language="haskell">data T (m :: k -&gt; Type) :: k -&gt; Type where
  MkT :: m a -&gt; T Maybe (m a) -&gt; T m a
</pre> <p>The complete user-supplied kind signature specifies the polymorphic kind for <code>T</code>, and this signature is used for all the calls to <code>T</code> including the recursive ones. In particular, the recursive use of <code>T</code> is at kind <code>Type</code>.</p> <p>What exactly is considered to be a “complete user-supplied kind signature” for a type constructor? These are the forms:</p> <ul> <li>
<p class="first">For a datatype, every type variable must be annotated with a kind. In a GADT-style declaration, there may also be a kind signature (with a top-level <code>::</code> in the header), but the presence or absence of this annotation does not affect whether or not the declaration has a complete signature.</p> <pre data-language="haskell">data T1 :: (k -&gt; Type) -&gt; k -&gt; Type       where ...
-- Yes;  T1 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T2 (a :: k -&gt; Type) :: k -&gt; Type     where ...
-- Yes;  T2 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T3 (a :: k -&gt; Type) (b :: k) :: Type where ...
-- Yes;  T3 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T4 (a :: k -&gt; Type) (b :: k)      where ...
-- Yes;  T4 :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data T5 a (b :: k) :: Type             where ...
-- No;  kind is inferred

data T6 a b                         where ...
-- No;  kind is inferred
</pre> </li> <li>
<p class="first">For a datatype with a top-level <code>::</code>: all kind variables introduced after the <code>::</code> must be explicitly quantified.</p> <pre data-language="haskell">data T1 :: k -&gt; Type            -- No CUSK: `k` is not explicitly quantified
data T2 :: forall k. k -&gt; Type  -- CUSK: `k` is bound explicitly
data T3 :: forall (k :: Type). k -&gt; Type   -- still a CUSK
</pre> </li> <li>
<p class="first">For a newtype, the rules are the same as they are for a data type unless <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> is enabled. With <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a>, the type constructor only has a CUSK if a kind signature is present. As with a datatype with a top-level <code>::</code>, all kind variables introduced after the <code>::</code> must be explicitly quantified</p> <pre data-language="haskell">{-# LANGUAGE UnliftedNewtypes #-}
newtype N1 where                 -- No; missing kind signature
newtype N2 :: TYPE IntRep where  -- Yes; kind signature present
newtype N3 (a :: Type) where     -- No; missing kind signature
newtype N4 :: k -&gt; Type where    -- No; `k` is not explicitly quantified
newtype N5 :: forall (k :: Type). k -&gt; Type where -- Yes; good signature
</pre> </li> <li>For a class, every type variable must be annotated with a kind. </li> <li>
<p class="first">For a type synonym, every type variable and the result type must all be annotated with kinds:</p> <pre data-language="haskell">type S1 (a :: k) = (a :: k)    -- Yes   S1 :: forall k. k -&gt; k
type S2 (a :: k) = a           -- No    kind is inferred
type S3 (a :: k) = Proxy a     -- No    kind is inferred
</pre> <p>Note that in <code>S2</code> and <code>S3</code>, the kind of the right-hand side is rather apparent, but it is still not considered to have a complete signature – no inference can be done before detecting the signature.</p> </li> <li>
<p class="first">An un-associated open type or data family declaration <em>always</em> has a CUSK; un-annotated type variables default to kind <code>Type</code>:</p> <pre data-language="haskell">data family D1 a                  -- D1 :: Type -&gt; Type
data family D2 (a :: k)           -- D2 :: forall k. k -&gt; Type
data family D3 (a :: k) :: Type   -- D3 :: forall k. k -&gt; Type
type family S1 a :: k -&gt; Type     -- S1 :: forall k. Type -&gt; k -&gt; Type
</pre> </li> <li>
<p class="first">An associated type or data family declaration has a CUSK precisely if its enclosing class has a CUSK.</p> <pre data-language="haskell">class C a where                -- no CUSK
  type AT a b                  -- no CUSK, b is defaulted

class D (a :: k) where         -- yes CUSK
  type AT2 a b                 -- yes CUSK, b is defaulted
</pre> </li> <li>A closed type family has a complete signature when all of its type variables are annotated and a return kind (with a top-level <code>::</code>) is supplied. </li> </ul> <p>It is possible to write a datatype that syntactically has a CUSK (according to the rules above) but actually requires some inference. As a very contrived example, consider</p> <pre data-language="haskell">data Proxy a           -- Proxy :: forall k. k -&gt; Type
data X (a :: Proxy k)
</pre> <p>According to the rules above <code>X</code> has a CUSK. Yet, the kind of <code>k</code> is undetermined. It is thus quantified over, giving <code>X</code> the kind <code>forall k1 (k :: k1). Proxy k -&gt; Type</code>.</p> <p>The detection of CUSKs is enabled by the <a class="reference internal" href="#extension-CUSKs"><code>CUSKs</code></a> flag, which is switched on by default. This extension is scheduled for deprecation to be replaced with <a class="reference internal" href="#extension-StandaloneKindSignatures"><code>StandaloneKindSignatures</code></a>.</p>   <h2 id="index-1">6.4.11.8. Standalone kind signatures and polymorphic recursion</h2> <dl class="extension" id="standalone-kind-signatures-and-polymorphic-recursion"> <dt id="extension-StandaloneKindSignatures">
<code>StandaloneKindSignatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-CUSKs"><code>NoCUSKs</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10.1</td> </tr>  </table> </dd>
</dl> <p>Just as in type inference, kind inference for recursive types can only use <em>monomorphic</em> recursion. Consider this (contrived) example:</p> <pre data-language="haskell">data T m a = MkT (m a) (T Maybe (m a))
-- GHC infers kind  T :: (Type -&gt; Type) -&gt; Type -&gt; Type
</pre> <p>The recursive use of <code>T</code> forced the second argument to have kind <code>Type</code>. However, just as in type inference, you can achieve polymorphic recursion by giving a <em>standalone kind signature</em> for <code>T</code>:</p> <pre data-language="haskell">type T :: (k -&gt; Type) -&gt; k -&gt; Type
data T m a = MkT (m a) (T Maybe (m a))
</pre> <p>The standalone kind signature specifies the polymorphic kind for <code>T</code>, and this signature is used for all the calls to <code>T</code> including the recursive ones. In particular, the recursive use of <code>T</code> is at kind <code>Type</code>.</p> <p>While a standalone kind signature determines the kind of a type constructor, it does not determine its arity. This is of particular importance for type families and type synonyms, as they cannot be partially applied. See <a class="reference internal" href="type_families.html#type-family-declarations"><span class="std std-ref">Type family declarations</span></a> for more information about arity.</p> <p>The arity can be specified using explicit binders and inline kind annotations:</p> <pre data-language="haskell">-- arity F0 = 0
type F0 :: forall k. k -&gt; Type
type family F0 :: forall k. k -&gt; Type

-- arity F1 = 1
type F1 :: forall k. k -&gt; Type
type family F1 :: k -&gt; Type

-- arity F2 = 2
type F2 :: forall k. k -&gt; Type
type family F2 a :: Type
</pre> <p>In absence of an inline kind annotation, the inferred arity includes all explicitly bound parameters and all immediately following invisible parameters:</p> <pre data-language="haskell">-- arity FD1 = 1
type FD1 :: forall k. k -&gt; Type
type FD1

-- arity FD2 = 2
type FD2 :: forall k. k -&gt; Type
type FD2 a
</pre> <p>Note that <code>F0</code>, <code>F1</code>, <code>F2</code>, <code>FD1</code>, and <code>FD2</code> all have identical standalone kind signatures. The arity is inferred from the type family header.</p> <p>The kind variables bound by an outermost <code>forall</code> in a standalone kind signature scope only over the kind in that signature. Unlike term-level type signatures (see <a class="reference internal" href="scoped_type_variables.html#decl-type-sigs"><span class="std std-ref">Declaration type signatures</span></a>), the outermost kind variables do <em>not</em> scope over the corresponding declaration. For example, given this class declaration:</p> <pre data-language="haskell">class C (a :: k) where
  m :: Proxy k -&gt; Proxy a -&gt; String
</pre> <p>The following would <em>not</em> be an equivalent definition of <code>C</code>:</p> <pre data-language="haskell">type C :: forall k. k -&gt; Constraint
class C a where
  m :: Proxy k -&gt; Proxy a -&gt; String
</pre> <p>Because the <code>k</code> from the standalone kind signature does not scope over <code>C</code>’s definition, the <code>k</code> in <code>m</code>’s type signature is no longer the kind of <code>a</code>, but rather a completely distinct kind. It’s as if you had written this:</p> <pre data-language="haskell">type C :: forall k. k -&gt; Constraint
class C (a :: kindOfA) where
  m :: forall k. Proxy k -&gt; Proxy (a :: kindOfA) -&gt; String
</pre> <p>To avoid this issue, <code>C</code>’s definition must be given an inline kind annotation like so:</p> <pre data-language="haskell">type C :: forall k. k -&gt; Constraint
class C (a :: k) where
  m :: Proxy k -&gt; Proxy a -&gt; String
</pre>   <h2 id="standalone-kind-signatures-and-declaration-headers">6.4.11.9. Standalone kind signatures and declaration headers</h2> <p>GHC requires that in the presence of a standalone kind signature, data declarations must bind all their inputs. For example:</p> <pre data-language="haskell">type Prox1 :: k -&gt; Type
data Prox1 a = MkProx1
  -- OK.

type Prox2 :: k -&gt; Type
data Prox2 = MkProx2
  -- Error:
  --   • Expected a type, but found something with kind ‘k -&gt; Type’
  --   • In the data type declaration for ‘Prox2’
</pre> <p>GADT-style data declarations may either bind their inputs or use an inline signature in addition to the standalone kind signature:</p> <pre data-language="haskell">type GProx1 :: k -&gt; Type
data GProx1 a where MkGProx1 :: GProx1 a
  -- OK.

type GProx2 :: k -&gt; Type
data GProx2 where MkGProx2 :: GProx2 a
  -- Error:
  --   • Expected a type, but found something with kind ‘k -&gt; Type’
  --   • In the data type declaration for ‘GProx2’

type GProx3 :: k -&gt; Type
data GProx3 :: k -&gt; Type where MkGProx3 :: GProx3 a
  -- OK.

type GProx4 :: k -&gt; Type
data GProx4 :: w where MkGProx4 :: GProx4 a
  -- OK, w ~ (k -&gt; Type)
</pre> <p>Classes are subject to the same rules:</p> <pre data-language="haskell">type C1 :: Type -&gt; Constraint
class C1 a
  -- OK.

type C2 :: Type -&gt; Constraint
class C2
  -- Error:
  --   • Couldn't match expected kind ‘Constraint’
  --                 with actual kind ‘Type -&gt; Constraint’
  --   • In the class declaration for ‘C2’
</pre> <p>On the other hand, type families are exempt from this rule:</p> <pre data-language="haskell">type F :: Type -&gt; Type
type family F
  -- OK.
</pre> <p>Data families are tricky territory. Their headers are exempt from this rule, but their instances are not:</p> <pre data-language="haskell">type T :: k -&gt; Type
data family T
  -- OK.

data instance T Int = MkT1
  -- OK.

data instance T = MkT3
  -- Error:
  --   • Expecting one more argument to ‘T’
  --     Expected a type, but ‘T’ has kind ‘k0 -&gt; Type’
  --   • In the data instance declaration for ‘T’
</pre> <p>This also applies to GADT-style data instances:</p> <pre data-language="haskell">data instance T (a :: Nat) where MkN4 :: T 4
                                 MKN9 :: T 9
  -- OK.

data instance T :: Symbol -&gt; Type where MkSN :: T "Neptune"
                                        MkSJ :: T "Jupiter"
  -- OK.

data instance T where MkT4 :: T x
  -- Error:
  --   • Expecting one more argument to ‘T’
  --     Expected a type, but ‘T’ has kind ‘k0 -&gt; Type’
  --   • In the data instance declaration for ‘T’
</pre>   <h2 id="kind-inference-in-data-type-declarations">6.4.11.10. Kind inference in data type declarations</h2> <p>Consider the declaration</p> <pre data-language="haskell">data T1 f a = MkT1 (f a)
data T2 f a where
  MkT2 :: f a -&gt; T f a
</pre> <p>In both cases GHC looks at the data constructor declarations to give constraints on the kind of <code>T</code>, yielding</p> <pre data-language="haskell">T1, T2 :: forall k. (k -&gt; Type) -&gt; k -&gt; Type
</pre> <p>Consider the type</p> <pre data-language="haskell">type G :: forall k. k -&gt; Type
data G (a :: k) where
  GInt    :: G Int
  GMaybe  :: G Maybe
</pre> <p>This datatype <code>G</code> is GADT-like in both its kind and its type. Suppose you have <code>g :: G a</code>, where <code>a :: k</code>. Then pattern matching to discover that <code>g</code> is in fact <code>GMaybe</code> tells you both that <code>k ~ (Type -&gt; Type)</code> and <code>a ~ Maybe</code>. The definition for <code>G</code> requires that <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a> be in effect, but pattern-matching on <code>G</code> requires no extension beyond <a class="reference internal" href="gadt.html#extension-GADTs"><code>GADTs</code></a>. That this works is actually a straightforward extension of regular GADTs and a consequence of the fact that kinds and types are the same.</p> <p>Note that the datatype <code>G</code> is used at different kinds in its body, and therefore that kind-indexed GADTs use a form of polymorphic recursion. It is thus only possible to use this feature if you have provided a complete user-supplied kind signature (CUSK) for the datatype (<a class="reference internal" href="#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>), or a standalone kind signature (<a class="reference internal" href="#standalone-kind-signatures"><span class="std std-ref">Standalone kind signatures and polymorphic recursion</span></a>); in the case of <code>G</code> we both. If you wish to see the kind indexing explicitly, you can do so by enabling <a class="reference internal" href="../using.html#ghc-flag--fprint-explicit-kinds"><code>-fprint-explicit-kinds</code></a> and querying <code>G</code> with GHCi’s <a class="reference internal" href="../ghci.html#ghci-cmd-:info"><code>:info</code></a> command:</p> <pre data-language="haskell">&gt; :set -fprint-explicit-kinds
&gt; :info G
type role G nominal nominal
type G :: forall k. k -&gt; Type
data G @k a where
  GInt   :: G @Type Int
  GMaybe :: G @(Type -&gt; Type) Maybe
</pre> <p>where you can see the GADT-like nature of the two constructors.</p>   <h2 id="kind-inference-data-family-instances">6.4.11.11. Kind inference for data/newtype instance declarations</h2> <p id="kind-inference-for-data-newtype-instance-declarations">Consider these declarations</p> <pre data-language="haskell">data family T :: forall k. (k-&gt;Type) -&gt; k -&gt; Type

data instance T p q where
   MkT :: forall r. r Int -&gt; T r Int
</pre> <p>Here <code>T</code> has an invisible kind argument; and perhaps it is instantiated to <code>Type</code> in the instance, thus:</p> <pre data-language="haskell">data instance T @Type (p :: Type-&gt;Type) (q :: Type) where
   MkT :: forall r. r Int -&gt; T r Int
</pre> <p>Or perhaps we intended the specialisation to be in the GADT data constructor, thus:</p> <pre data-language="haskell">data instance T @k (p :: k-&gt;Type) (q :: k) where
   MkT :: forall r. r Int -&gt; T @Type r Int
</pre> <p>It gets more complicated if there are multiple constructors. In general, there is no principled way to tell which type specialisation comes from the data instance, and which from the individual GADT data constructors.</p> <p>So GHC implements this rule: in data/newtype instance declararations (unlike ordinary data/newtype declarations) we do <em>not</em> look at the constructor declarations when inferring the shape of the instance header. The principle is that <em>the instantiation of the data instance should be apparent from the header alone</em>. This principle makes the program easier to understand, and avoids the swamp of complexity indicated above.</p>   <h2 id="kind-inference-in-class-instance-declarations">6.4.11.12. Kind inference in class instance declarations</h2> <p>Consider the following example of a poly-kinded class and an instance for it:</p> <pre data-language="haskell">class C a where
  type F a

instance C b where
  type F b = b -&gt; b
</pre> <p>In the class declaration, nothing constrains the kind of the type <code>a</code>, so it becomes a poly-kinded type variable <code>(a :: k)</code>. Yet, in the instance declaration, the right-hand side of the associated type instance <code>b -&gt; b</code> says that <code>b</code> must be of kind <code>Type</code>. GHC could theoretically propagate this information back into the instance head, and make that instance declaration apply only to type of kind <code>Type</code>, as opposed to types of any kind. However, GHC does <em>not</em> do this.</p> <p>In short: GHC does <em>not</em> propagate kind information from the members of a class instance declaration into the instance declaration head.</p> <p>This lack of kind inference is simply an engineering problem within GHC, but getting it to work would make a substantial change to the inference infrastructure, and it’s not clear the payoff is worth it. If you want to restrict <code>b</code>’s kind in the instance above, just use a kind signature in the instance head.</p>   <h2 id="kind-inference-in-type-synonyms-and-type-family-instances">6.4.11.13. Kind inference in type synonyms and type family instances</h2> <p>Consider the scoping rules for type synonyms and type family instances, such as these:</p> <pre data-language="haskell">type          TS a (b :: k) = &lt;rhs&gt;
type instance TF a (b :: k) = &lt;rhs&gt;
</pre> <p>The basic principle is that all variables mentioned on the right hand side <code>&lt;rhs&gt;</code> must be bound on the left hand side:</p> <pre data-language="haskell">type TS a (b :: k) = (k, a, Proxy b)    -- accepted
type TS a (b :: k) = (k, a, Proxy b, z) -- rejected: z not in scope
</pre> <p>But there is one exception: free variables mentioned in the outermost kind signature on the right hand side are quantified implicitly. Thus, in the following example the variables <code>a</code>, <code>b</code>, and <code>k</code> are all in scope on the right hand side of <code>S</code>:</p> <pre data-language="haskell">type S a b = &lt;rhs&gt; :: k -&gt; k
</pre> <p>The reason for this exception is that there may be no other way to bind <code>k</code>. For example, suppose we wanted <code>S</code> to have the following kind with an <em>invisible</em> parameter <code>k</code>:</p> <pre data-language="haskell">S :: forall k. Type -&gt; Type -&gt; k -&gt; k
</pre> <p>In this case, we could not simply bind <code>k</code> on the left-hand side, as <code>k</code> would become a <em>visible</em> parameter:</p> <pre data-language="haskell">type S k a b = &lt;rhs&gt; :: k -&gt; k
S :: forall k -&gt; Type -&gt; Type -&gt; k -&gt; k
</pre> <p>Note that we only look at the <em>outermost</em> kind signature to decide which variables to quantify implicitly. As a counter-example, consider <code>M1</code>:</p> <pre data-language="haskell">type M1 = Just (Nothing :: Maybe k)    -- rejected: k not in scope
</pre> <p>Here, the kind signature is hidden inside <code>Just</code>, and there is no outermost kind signature. We can fix this example by providing an outermost kind signature:</p> <pre data-language="haskell">type M2 = Just (Nothing :: Maybe k) :: Maybe (Maybe k)
</pre> <p>Here, <code>k</code> is brought into scope by <code>:: Maybe (Maybe k)</code>.</p> <p>A kind signature is considered to be outermost regardless of redundant parentheses:</p> <pre data-language="haskell">type P =    Nothing :: Maybe a    -- accepted
type P = (((Nothing :: Maybe a))) -- accepted
</pre> <p>Closed type family instances are subject to the same rules:</p> <pre data-language="haskell">type family F where
  F = Nothing :: Maybe k            -- accepted

type family F where
  F = Just (Nothing :: Maybe k)     -- rejected: k not in scope

type family F where
  F = Just (Nothing :: Maybe k) :: Maybe (Maybe k)  -- accepted

type family F :: Maybe (Maybe k) where
  F = Just (Nothing :: Maybe k)     -- rejected: k not in scope

type family F :: Maybe (Maybe k) where
  F @k = Just (Nothing :: Maybe k)  -- accepted
</pre> <p>Kind variables can also be quantified in <em>visible</em> positions. Consider the following two examples:</p> <pre data-language="haskell">data ProxyKInvis (a :: k)
data ProxyKVis k (a :: k)
</pre> <p>In the first example, the kind variable <code>k</code> is an <em>invisible</em> argument to <code>ProxyKInvis</code>. In other words, a user does not need to instantiate <code>k</code> explicitly, as kind inference automatically determines what <code>k</code> should be. For instance, in <code>ProxyKInvis True</code>, <code>k</code> is inferred to be <code>Bool</code>. This is reflected in the kind of <code>ProxyKInvis</code>:</p> <pre data-language="haskell">ProxyKInvis :: forall k. k -&gt; Type
</pre> <p>In the second example, <code>k</code> is a <em>visible</em> argument to <code>ProxyKVis</code>. That is to say, <code>k</code> is an argument that users must provide explicitly when applying <code>ProxyKVis</code>. For example, <code>ProxyKVis Bool True</code> is a well formed type.</p> <p>What is the kind of <code>ProxyKVis</code>? One might say <code>forall k. Type -&gt; k -&gt; Type</code>, but this isn’t quite right, since this would allow incorrect things like <code>ProxyKVis Bool Int</code>, which should be rejected due to the fact that <code>Int</code> is not of kind <code>Bool</code>. The key observation is that the kind of the second argument <em>depends</em> on the first argument. GHC indicates this dependency in the syntax that it gives for the kind of <code>ProxyKVis</code>:</p> <pre data-language="haskell">ProxyKVis :: forall k -&gt; k -&gt; Type
</pre> <p>This kind is similar to the kind of <code>ProxyKInvis</code>, but with a key difference: the type variables quantified by the <code>forall</code> are followed by an arrow (<code>-&gt;</code>), not a dot (<code>.</code>). This is a visible, dependent quantifier. It is visible in that the user must pass in a type for <code>k</code> explicitly, and it is dependent in the sense that <code>k</code> appears later in the kind of <code>ProxyKVis</code>. As a counterpart, the <code>k</code> binder in <code>forall k. k -&gt; Type</code> can be thought of as an <em>invisible</em>, dependent quantifier.</p> <p>GHC permits writing kinds with this syntax, provided that the <code>ExplicitForAll</code> and <code>PolyKinds</code> language extensions are enabled. Just like the invisible <code>forall</code>, one can put explicit kind signatures on visibly bound kind variables, so the following is syntactically valid:</p> <pre data-language="haskell">ProxyKVis :: forall (k :: Type) -&gt; k -&gt; Type
</pre> <p>Currently, the ability to write visible, dependent quantifiers is limited to kinds. Consequently, visible dependent quantifiers are rejected in any context that is unambiguously the type of a term. They are also rejected in the types of data constructors.</p>   <h2 id="kind-inference-in-closed-type-families">6.4.11.14. Kind inference in closed type families</h2> <p>Although all open type families are considered to have a complete user-supplied kind signature (<a class="reference internal" href="#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a>), we can relax this condition for closed type families, where we have equations on which to perform kind inference. GHC will infer kinds for the arguments and result types of a closed type family.</p> <p>GHC supports <em>kind-indexed</em> type families, where the family matches both on the kind and type. GHC will <em>not</em> infer this behaviour without a complete user-supplied kind signature or standalone kind signature (see <a class="reference internal" href="#standalone-kind-signatures"><span class="std std-ref">Standalone kind signatures and polymorphic recursion</span></a>), because doing so would sometimes infer non-principal types. Indeed, we can see kind-indexing as a form of polymorphic recursion, where a type is used at a kind other than its most general in its own definition.</p> <p>For example:</p> <pre data-language="haskell">type family F1 a where
  F1 True  = False
  F1 False = True
  F1 x     = x
-- F1 fails to compile: kind-indexing is not inferred

type family F2 (a :: k) where
  F2 True  = False
  F2 False = True
  F2 x     = x
-- F2 fails to compile: no complete signature

type family F3 (a :: k) :: k where
  F3 True  = False
  F3 False = True
  F3 x     = x
-- OK
</pre>   <h2 id="higher-rank-kinds">6.4.11.15. Higher-rank kinds</h2> <p>In concert with <a class="reference internal" href="rank_polymorphism.html#extension-RankNTypes"><code>RankNTypes</code></a>, GHC supports higher-rank kinds. Here is an example:</p> <pre data-language="haskell">-- Heterogeneous propositional equality
data (a :: k1) :~~: (b :: k2) where
  HRefl :: a :~~: a

class HTestEquality (t :: forall k. k -&gt; Type) where
  hTestEquality :: forall k1 k2 (a :: k1) (b :: k2). t a -&gt; t b -&gt; Maybe (a :~~: b)
</pre> <p>Note that <code>hTestEquality</code> takes two arguments where the type variable <code>t</code> is applied to types of different kinds. That type variable must then be polykinded. Accordingly, the kind of <code>HTestEquality</code> (the class) is <code>(forall k. k -&gt; Type) -&gt; Constraint</code>, a higher-rank kind.</p> <p>A big difference with higher-rank kinds as compared with higher-rank types is that <code>forall</code>s in kinds <em>cannot</em> be moved. This is best illustrated by example. Suppose we want to have an instance of <code>HTestEquality</code> for <code>(:~~:)</code>.</p> <pre data-language="haskell">instance HTestEquality ((:~~:) a) where
  hTestEquality HRefl HRefl = Just HRefl
</pre> <p>With the declaration of <code>(:~~:)</code> above, it gets kind <code>forall k1 k2. k1 -&gt; k2 -&gt; Type</code>. Thus, the type <code>(:~~:) a</code> has kind <code>k2 -&gt; Type</code> for some <code>k2</code>. GHC cannot then <em>regeneralize</em> this kind to become <code>forall k2. k2 -&gt; Type</code> as desired. Thus, the instance is rejected as ill-kinded.</p> <p>To allow for such an instance, we would have to define <code>(:~~:)</code> as follows:</p> <pre data-language="haskell">data (:~~:) :: forall k1. k1 -&gt; forall k2. k2 -&gt; Type where
  HRefl :: a :~~: a
</pre> <p>In this redefinition, we give an explicit kind for <code>(:~~:)</code>, deferring the choice of <code>k2</code> until after the first argument (<code>a</code>) has been given. With this declaration for <code>(:~~:)</code>, the instance for <code>HTestEquality</code> is accepted.</p>   <h2 id="the-kind-type">6.4.11.16. The kind <code>Type</code>
</h2> <dl class="extension"> <dt id="extension-StarIsType">
<code>StarIsType</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6.1</td> </tr>  </table> <p>Treat the unqualified uses of the <code>*</code> type operator as nullary and desugar to <code>Data.Kind.Type</code>.</p> </dd>
</dl> <p>The kind <code>Type</code> (imported from <code>Data.Kind</code>) classifies ordinary types. With <a class="reference internal" href="#extension-StarIsType"><code>StarIsType</code></a> (currently enabled by default), <code>*</code> is desugared to <code>Type</code>, but using this legacy syntax is not recommended due to conflicts with <a class="reference internal" href="type_operators.html#extension-TypeOperators"><code>TypeOperators</code></a>. This also applies to <code>★</code>, the Unicode variant of <code>*</code>.</p>   <h2 id="inferring-dependency-in-datatype-declarations">6.4.11.17. Inferring dependency in datatype declarations</h2> <p>If a type variable <code>a</code> in a datatype, class, or type family declaration depends on another such variable <code>k</code> in the same declaration, two properties must hold:</p> <ul class="simple"> <li>
<code>a</code> must appear after <code>k</code> in the declaration, and</li> <li>
<code>k</code> must appear explicitly in the kind of <em>some</em> type variable in that declaration.</li> </ul> <p>The first bullet simply means that the dependency must be well-scoped. The second bullet concerns GHC’s ability to infer dependency. Inferring this dependency is difficult, and GHC currently requires the dependency to be made explicit, meaning that <code>k</code> must appear in the kind of a type variable, making it obvious to GHC that dependency is intended. For example:</p> <pre data-language="haskell">data Proxy k (a :: k)            -- OK: dependency is "obvious"
data Proxy2 k a = P (Proxy k a)  -- ERROR: dependency is unclear
</pre> <p>In the second declaration, GHC cannot immediately tell that <code>k</code> should be a dependent variable, and so the declaration is rejected.</p> <p>It is conceivable that this restriction will be relaxed in the future, but it is (at the time of writing) unclear if the difficulties around this scenario are theoretical (inferring this dependency would mean our type system does not have principal types) or merely practical (inferring this dependency is hard, given GHC’s implementation). So, GHC takes the easy way out and requires a little help from the user.</p>   <h2 id="inferring-dependency-in-user-written-foralls">6.4.11.18. Inferring dependency in user-written <code>forall</code>s</h2> <p>A programmer may use <code>forall</code> in a type to introduce new quantified type variables. These variables may depend on each other, even in the same <code>forall</code>. However, GHC requires that the dependency be inferrable from the body of the <code>forall</code>. Here are some examples:</p> <pre data-language="haskell">data Proxy k (a :: k) = MkProxy   -- just to use below

f :: forall k a. Proxy k a        -- This is just fine. We see that (a :: k).
f = undefined

g :: Proxy k a -&gt; ()              -- This is to use below.
g = undefined

data Sing a
h :: forall k a. Sing k -&gt; Sing a -&gt; ()  -- No obvious relationship between k and a
h _ _ = g (MkProxy :: Proxy k a)  -- This fails. We didn't know that a should have kind k.
</pre> <p>Note that in the last example, it’s impossible to learn that <code>a</code> depends on <code>k</code> in the body of the <code>forall</code> (that is, the <code>Sing k -&gt; Sing a -&gt; ()</code>). And so GHC rejects the program.</p>   <h2 id="kind-defaulting-without-polykinds">6.4.11.19. Kind defaulting without PolyKinds</h2> <p>Without <a class="reference internal" href="#extension-PolyKinds"><code>PolyKinds</code></a>, GHC refuses to generalise over kind variables. It thus defaults kind variables to <code>Type</code> when possible; when this is not possible, an error is issued.</p> <p>Here is an example of this in action:</p> <pre data-language="haskell">{-# LANGUAGE PolyKinds #-}
import Data.Kind (Type)
data Proxy a = P   -- inferred kind: Proxy :: k -&gt; Type
data Compose f g x = MkCompose (f (g x))
  -- inferred kind: Compose :: (b -&gt; Type) -&gt; (a -&gt; b) -&gt; a -&gt; Type

-- separate module having imported the first
{-# LANGUAGE NoPolyKinds, DataKinds #-}
z = Proxy :: Proxy MkCompose
</pre> <p>In the last line, we use the promoted constructor <code>MkCompose</code>, which has kind</p> <pre data-language="haskell">forall (a :: Type) (b :: Type) (f :: b -&gt; Type) (g :: a -&gt; b) (x :: a).
  f (g x) -&gt; Compose f g x
</pre> <p>Now we must infer a type for <code>z</code>. To do so without generalising over kind variables, we must default the kind variables of <code>MkCompose</code>. We can easily default <code>a</code> and <code>b</code> to <code>Type</code>, but <code>f</code> and <code>g</code> would be ill-kinded if defaulted. The definition for <code>z</code> is thus an error.</p>   <h2 id="pretty-printing-in-the-presence-of-kind-polymorphism">6.4.11.20. Pretty-printing in the presence of kind polymorphism</h2> <p>With kind polymorphism, there is quite a bit going on behind the scenes that may be invisible to a Haskell programmer. GHC supports several flags that control how types are printed in error messages and at the GHCi prompt. See the <a class="reference internal" href="../using.html#pretty-printing-types"><span class="std std-ref">discussion of type pretty-printing options</span></a> for further details. If you are using kind polymorphism and are confused as to why GHC is rejecting (or accepting) your program, we encourage you to turn on these flags, especially <a class="reference internal" href="../using.html#ghc-flag--fprint-explicit-kinds"><code>-fprint-explicit-kinds</code></a>.</p>   <h2 id="datatype-return-kinds">6.4.11.21. Datatype return kinds</h2> <p>With <a class="reference internal" href="kind_signatures.html#extension-KindSignatures"><code>KindSignatures</code></a>, we can give the kind of a datatype written in GADT-syntax (see <a class="reference internal" href="gadt_syntax.html#extension-GADTSyntax"><code>GADTSyntax</code></a>). For example:</p> <pre data-language="haskell">data T :: Type -&gt; Type where ...
</pre> <p>There are a number of restrictions around these <em>return kinds</em>. The text below considers <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> and data families (enabled by <a class="reference internal" href="type_families.html#extension-TypeFamilies"><code>TypeFamilies</code></a>). The discussion also assumes familiarity with <a class="reference internal" href="representation_polymorphism.html#runtime-rep"><span class="std std-ref">representation polymorphism</span></a>.</p> <ol class="arabic"> <li>
<code>data</code> and <code>data instance</code> declarations must have return kinds that end in <code>TYPE LiftedRep</code>. (Recall that <code>Type</code> is just a synonym for <code>TYPE LiftedRep</code>.) By “end in”, we refer to the kind left over after all arguments (introduced either by <code>forall</code> or <code>-&gt;</code>) are stripped off and type synonyms expanded. Note that no type family expansion is done when performing this check. </li> <li>
<p class="first">If <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> is enabled, then <code>newtype</code> and <code>newtype instance</code> declarations must have return kinds that end in <code>TYPE rep</code> for some <code>rep</code>. The <code>rep</code> may mention type families, but the <code>TYPE</code> must be apparent without type family expansion. (Type synonym expansion is acceptable.)</p> <p>If <a class="reference internal" href="primitives.html#extension-UnliftedNewtypes"><code>UnliftedNewtypes</code></a> is not enabled, then <code>newtype</code> and <code>newtype instance</code> declarations have the same restrictions as <code>data</code> declarations.</p> </li> <li>A <code>data</code> or <code>newtype</code> instance actually can have <em>two</em> return kinds. The first is the kind derived by applying the data family to the patterns provided in the instance declaration. The second is given by a kind annotation. Both return kinds must satisfy the restrictions above. </li> </ol> <p>Examples:</p> <pre data-language="haskell" id="index-2">data T1 :: Type             -- good: Type expands to TYPE LiftedRep
data T2 :: TYPE LiftedRep   -- good
data T3 :: forall k. k -&gt; Type -&gt; Type  -- good: arguments are dropped

type LR = LiftedRep
data T3 :: TYPE LR          -- good: we look through type synonyms

type family F a where
  F Int = LiftedRep

data T4 :: TYPE (F Int)     -- bad: we do not look through type families

type family G a where
  G Int = Type

data T5 :: G Int            -- bad: we do not look through type families

-- assume -XUnliftedNewtypes
newtype T6 :: Type where ...             -- good
newtype T7 :: TYPE (F Int) where ...     -- good
newtype T8 :: G Int where ...            -- bad

data family DF a :: Type
data instance DF Int :: Type             -- good
data instance DF Bool :: TYPE LiftedRep  -- good
data instance DF Char :: G Int           -- bad

data family DF2 k :: k                   -- good
data family DF2 Type                     -- good
data family DF2 Bool                     -- bad
data family DF2 (G Int)                  -- bad for 2 reasons:
                                         --  a type family can't be in a pattern, and
                                         --  the kind fails the restrictions here
</pre>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/poly_kinds.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/poly_kinds.html</a>
  </p>
</div>
