<h1 id="id1">6.13. Template Haskell</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <p id="template-haskell">Template Haskell allows you to do compile-time meta-programming in Haskell. The background to the main technical innovations is discussed in “<a class="reference external" href="https://research.microsoft.com/~simonpj/papers/meta-haskell/">Template Meta-programming for Haskell</a>” (Proc Haskell Workshop 2002).</p> <p>The <a class="reference external" href="https://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a> page on the GHC Wiki has a wealth of information. You may also consult the Haddock reference documentation <a class="reference external" href="../../libraries/template-haskell-2.19.0.0/language-haskell-th.html">Language.Haskell.TH</a>. Many changes to the original design are described in <a class="reference external" href="https://www.haskell.org/ghc/docs/papers/th2.ps">Notes on Template Haskell version 2</a>. Not all of these changes are in GHC, however.</p> <p>The first example from that paper is set out below (<a class="reference internal" href="#th-example"><span class="std std-ref">A Template Haskell Worked Example</span></a>) as a worked example to help get you started.</p> <p>The documentation here describes the realisation of Template Haskell in GHC. It is not detailed enough to understand Template Haskell; see the <a class="reference external" href="https://haskell.org/haskellwiki/Template_Haskell">Wiki page</a>.</p>  <h2 id="th-syntax">6.13.1. Syntax</h2> <dl class="extension" id="syntax"> <dt id="extension-TemplateHaskell">
<code>TemplateHaskell</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a></td> </tr> <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.0. Typed splices introduced in GHC 7.8.1.</td> </tr>  </table> <p>Enable Template Haskell’s splice and quotation syntax.</p> </dd>
</dl> <dl class="extension"> <dt id="extension-TemplateHaskellQuotes">
<code>TemplateHaskellQuotes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0.1</td> </tr>  </table> <p>Enable only Template Haskell’s quotation syntax.</p> </dd>
</dl> <p>Template Haskell has the following new syntactic constructions. You need to use the extension <a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a> to switch these syntactic extensions on. Alternatively, the <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a> extension can be used to enable the quotation subset of Template Haskell (i.e. without top-level splices). The <a class="reference internal" href="#extension-TemplateHaskellQuotes"><code>TemplateHaskellQuotes</code></a> extension is considered safe under <a class="reference internal" href="safe_haskell.html#safe-haskell"><span class="std std-ref">Safe Haskell</span></a> while <a class="reference internal" href="#extension-TemplateHaskell"><code>TemplateHaskell</code></a> is not.</p> <ul> <li>
<p class="first">A splice is written <code>$x</code>, where <code>x</code> is an arbitrary expression. There must be no space between the “$” and the expression. This use of “$” overrides its meaning as an infix operator, just as “M.x” overrides the meaning of “.” as an infix operator. If you want the infix operator, put spaces around it.</p> <p>A top-level splice can occur in place of</p> <ul class="simple"> <li>an expression; the spliced expression must have type <code>Q Exp</code>
</li> <li>a pattern; the spliced pattern must have type <code>Q Pat</code>
</li> <li>a type; the spliced expression must have type <code>Q Type</code>
</li> <li>a list of declarations at top level; the spliced expression must have type <code>Q [Dec]</code>
</li> </ul> <p>Inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module. Note that declaration splices are not allowed anywhere except at top level (outside any other declarations).</p> <p>The <code>Q</code> monad is a monad defined in <a class="reference external" href="../../libraries/template-haskell-2.19.0.0/language-haskell-th-syntax.html">Language.Haskell.TH.Syntax</a> which supports several useful operations during code generation such as reporting errors or looking up identifiers in the environment.</p> </li> <li>
<p class="first">A expression quotation is written in Oxford brackets, thus:</p> <ul class="simple"> <li>
<code>[| ... |]</code>, or <code>[e| ... |]</code>, where the “…” is an expression; the quotation has type <code>Quote m =&gt; m Exp</code>.</li> <li>
<code>[d| ... |]</code>, where the “…” is a list of top-level declarations; the quotation has type <code>Quote m =&gt; m [Dec]</code>.</li> <li>
<code>[t| ... |]</code>, where the “…” is a type; the quotation has type <code>Quote m =&gt; m Type</code>.</li> <li>
<code>[p| ... |]</code>, where the “…” is a pattern; the quotation has type <code>Quote m =&gt; m Pat</code>.</li> </ul> <p>The <code>Quote</code> type class (<a class="reference external" href="../../libraries/template-haskell-2.19.0.0/language-haskell-th-syntax.html#t:Quote">Language.Haskell.TH.Syntax.Quote</a>) is the minimal interface necessary to implement the desugaring of quotations. The <code>Q</code> monad is an instance of <code>Quote</code> but contains many more operations which are not needed for defining quotations.</p> <p>See <a class="reference internal" href="partial_type_signatures.html#pts-where"><span class="std std-ref">Where can they occur?</span></a> for using partial type signatures in quotations.</p> </li> <li>
<p class="first">Splices can be nested inside quotation brackets. For example the fragment representing <code>1 + 2</code> can be constructed using nested splices:</p> <pre data-language="haskell">oneC, twoC, plusC  :: Quote m =&gt; m Exp
oneC = [| 1 |]

twoC = [| 2 |]

plusC = [| $oneC + $twoC |]
</pre> </li> <li>
<p class="first">The precise type of a quotation depends on the types of the nested splices inside it:</p> <pre data-language="haskell">-- Add a redundant constraint to demonstrate that constraints on the
-- monad used to build the representation are propagated when using nested
-- splices.
f :: (Quote m, C m) =&gt; m Exp
f = [| 5 | ]

-- f is used in a nested splice so the constraint on f, namely C, is propagated
-- to a constraint on the whole representation.
g :: (Quote m, C m) =&gt; m Exp
g = [| $f + $f |]
</pre> <p>Remember, a top-level splice still requires its argument to be of type <code>Q Exp</code>. So then splicing in <code>g</code> will cause <code>m</code> to be instantiated to <code>Q</code>:</p> <pre data-language="haskell">h :: Int
h = $(g) -- m ~ Q
</pre> </li> <li>
<p class="first">A <em>typed</em> expression splice is written <code>$$x</code>, where <code>x</code> is is an arbitrary expression.</p> <p>A top-level typed expression splice can occur in place of an expression; the spliced expression must have type <code>Code Q a</code></p> <p><strong>NOTE</strong>: Currently typed splices may inhibit the unused identifier warning for identifiers in scope. See <code>#16524 &lt;https://gitlab.haskell.org/ghc/ghc/-/issues/16524&gt;</code></p> </li> <li>
<p class="first">A <em>typed</em> expression quotation is written as <code>[|| ... ||]</code>, or <code>[e|| ... ||]</code>, where the “…” is an expression; if the “…” expression has type <code>a</code>, then the quotation has type <code>Quote m =&gt; Code m a</code>.</p> <p>It is possible to extract a value of type <code>m Exp</code> from <code>Code m a</code> using the <code>unTypeCode :: Code m a -&gt; m Exp</code> function.</p> </li> <li>
<p class="first">A quasi-quotation can appear in a pattern, type, expression, or declaration context and is also written in Oxford brackets:</p> <ul class="simple"> <li>
<code>[varid| ... |]</code>, where the “…” is an arbitrary string; a full description of the quasi-quotation facility is given in <a class="reference internal" href="#th-quasiquotation"><span class="std std-ref">Template Haskell Quasi-quotation</span></a>.</li> </ul> </li> <li>
<p class="first">A name can be quoted with either one or two prefix single quotes:</p> <ul> <li>
<p class="first"><code>'f</code> has type <code>Name</code>, and names the function <code>f</code>. Similarly <code>'C</code> has type <code>Name</code> and names the data constructor <code>C</code>. In general <code>'</code>⟨thing⟩ interprets ⟨thing⟩ in an expression context.</p> <p>A name whose second character is a single quote (sadly) cannot be quoted in this way, because it will be parsed instead as a quoted character. For example, if the function is called <code>f'7</code> (which is a legal Haskell identifier), an attempt to quote it as <code>'f'7</code> would be parsed as the character literal <code>'f'</code> followed by the numeric literal <code>7</code>. There is no current escape mechanism in this (unusual) situation.</p> </li> <li>
<code>''T</code> has type <code>Name</code>, and names the type constructor <code>T</code>. That is, <code>''</code>⟨thing⟩ interprets ⟨thing⟩ in a type context. </li> </ul> <p>These <code>Names</code> can be used to construct Template Haskell expressions, patterns, declarations etc. They may also be given as an argument to the <code>reify</code> function.</p> </li> <li>
<p class="first">It is possible for a splice to expand to an expression that contain names which are not in scope at the site of the splice. As an example, consider the following code:</p> <pre data-language="haskell">module Bar where

import Language.Haskell.TH

add1 :: Quote m =&gt; Int -&gt; m Exp
add1 x = [| x + 1 |]
</pre> <p>Now consider a splice using <code>add1</code> in a separate module:</p> <pre data-language="haskell">module Foo where

import Bar

two :: Int
two = $(add1 1)
</pre> <p>Template Haskell cannot know what the argument to <code>add1</code> will be at the function’s definition site, so a lifting mechanism is used to promote <code>x</code> into a value of type <code>Quote m =&gt; m Exp</code>. This functionality is exposed to the user as the <code>Lift</code> typeclass in the <code>Language.Haskell.TH.Syntax</code> module. If a type has a <code>Lift</code> instance, then any of its values can be lifted to a Template Haskell expression:</p> <pre data-language="haskell">class Lift t where
    lift :: Quote m =&gt; t -&gt; m Exp
    liftTyped :: Quote m =&gt; t -&gt; Code m t
</pre> <p>In general, if GHC sees an expression within Oxford brackets (e.g., <code>[|
foo bar |]</code>, then GHC looks up each name within the brackets. If a name is global (e.g., suppose <code>foo</code> comes from an import or a top-level declaration), then the fully qualified name is used directly in the quotation. If the name is local (e.g., suppose <code>bar</code> is bound locally in the function definition <code>mkFoo bar = [| foo bar |]</code>), then GHC uses <code>lift</code> on it (so GHC pretends <code>[| foo bar |]</code> actually contains <code>[|
foo $(lift bar) |]</code>). Local names, which are not in scope at splice locations, are actually evaluated when the quotation is processed.</p> <p>The <code>template-haskell</code> library provides <code>Lift</code> instances for many common data types. Furthermore, it is possible to derive <code>Lift</code> instances automatically by using the <a class="reference internal" href="deriving_extra.html#extension-DeriveLift"><code>DeriveLift</code></a> language extension. See <a class="reference internal" href="deriving_extra.html#deriving-lift"><span class="std std-ref">Deriving Lift instances</span></a> for more information.</p> </li> <li>
<p class="first">You may omit the <code>$(...)</code> in a top-level declaration splice. Simply writing an expression (rather than a declaration) implies a splice. For example, you can write</p> <pre data-language="haskell">module Foo where
import Bar

f x = x

$(deriveStuff 'f)   -- Uses the $(...) notation

g y = y+1

deriveStuff 'g      -- Omits the $(...)

h z = z-1
</pre> <p>This abbreviation makes top-level declaration slices quieter and less intimidating.</p> </li> <li>
<p class="first">Pattern splices introduce variable binders but scoping of variables in expressions inside the pattern’s scope is only checked when a splice is run. Note that pattern splices that occur outside of any quotation brackets are run at compile time. Pattern splices occurring inside a quotation bracket are <em>not</em> run at compile time; they are run when the bracket is spliced in, sometime later. For example,</p> <pre data-language="haskell">mkPat :: Quote m =&gt; m Pat
mkPat = [p| (x, y) |]

-- in another module:
foo :: (Char, String) -&gt; String
foo $(mkPat) = x : z

bar :: Quote m =&gt; m Exp
bar = [| \ $(mkPat) -&gt; x : w |]
</pre> <p>will fail with <code>z</code> being out of scope in the definition of <code>foo</code> but it will <em>not</em> fail with <code>w</code> being out of scope in the definition of <code>bar</code>. That will only happen when <code>bar</code> is spliced.</p> </li> <li>
<p class="first">A pattern quasiquoter <em>may</em> generate binders that scope over the right-hand side of a definition because these binders are in scope lexically. For example, given a quasiquoter <code>haskell</code> that parses Haskell, in the following code, the <code>y</code> in the right-hand side of <code>f</code> refers to the <code>y</code> bound by the <code>haskell</code> pattern quasiquoter, <em>not</em> the top-level <code>y = 7</code>.</p> <pre data-language="haskell">y :: Int
y = 7

f :: Int -&gt; Int -&gt; Int
f n = \ [haskell|y|] -&gt; y+n
</pre> </li> <li>
<p class="first">Top-level declaration splices break up a source file into <em>declaration groups</em>. A <em>declaration group</em> is the group of declarations created by a top-level declaration splice, plus those following it, down to but not including the next top-level declaration splice. N.B. only top-level splices delimit declaration groups, not expression splices. The first declaration group in a module includes all top-level definitions down to but not including the first top-level declaration splice.</p> <p>Each declaration group is mutually recursive only within the group. Declaration groups can refer to definitions within previous groups, but not later ones.</p> <p>Accordingly, the type environment seen by <code>reify</code> includes all the top-level declarations up to the end of the immediately preceding declaration group, but no more.</p> <p>Unlike normal declaration splices, declaration quasiquoters do not cause a break. These quasiquoters are expanded before the rest of the declaration group is processed, and the declarations they generate are merged into the surrounding declaration group. Consequently, the type environment seen by <code>reify</code> from a declaration quasiquoter will not include anything from the quasiquoter’s declaration group.</p> <p>Concretely, consider the following code</p> <pre data-language="haskell">module M where

import ...

f x = x

$(th1 4)

h y = k y y $(blah1)

[qq|blah|]

k x y z = x + y + z

$(th2 10)

w z = $(blah2)
</pre> <p>In this example, a <code>reify</code> inside…</p> <ol class="arabic simple"> <li>The splice <code>$(th1 ...)</code> would see the definition of <code>f</code> - the splice is top-level and thus all definitions in the previous declaration group are visible (that is, all definitions in the module up-to, but not including, the splice itself).</li> <li>The splice <code>$(blah1)</code> cannot refer to the function <code>w</code> - <code>w</code> is part of a later declaration group, and thus invisible, similarly, <code>$(blah1)</code> cannot see the definition of <code>h</code> (since it is part of the same declaration group as <code>$(blah1)</code>. However, the splice <code>$(blah1)</code> can see the definition of <code>f</code> (since it is in the immediately preceding declaration group).</li> <li>The splice <code>$(th2 ...)</code> would see the definition of <code>f</code>, all the bindings created by <code>$(th1 ...)</code>, the definition of <code>h</code> and all bindings created by <code>[qq|blah|]</code> (they are all in previous declaration groups).</li> <li>The body of <code>h</code> <em>can</em> refer to the function <code>k</code> appearing on the other side of the declaration quasiquoter, as quasiquoters do not cause a declaration group to be broken up.</li> <li>The <code>qq</code> quasiquoter would be able to see the definition of <code>f</code> from the preceding declaration group, but not the definitions of <code>h</code> or <code>k</code>, or any definitions from subsequent declaration groups.</li> <li>The splice <code>$(blah2)</code> would see the same definitions as the splice <code>$(th2 ...)</code> (but <em>not</em> any bindings it creates).</li> </ol> <p>Note that since an expression splice is unable to refer to declarations in the same declaration group, we can introduce a top-level (empty) splice to break up the declaration group</p> <pre data-language="haskell">module M where

data D = C1 | C2

f1 = $(th1 ...)

$(return [])

f2 = $(th2 ...)
</pre> <p>Here</p> <ol class="arabic simple"> <li>The splice <code>$(th1 ...)</code> <em>cannot</em> refer to <code>D</code> - it is in the same declaration group.</li> <li>The declaration group containing <code>D</code> is terminated by the empty top-level declaration splice <code>$(return [])</code> (recall, <code>Q</code> is a Monad, so we may simply <code>return</code> the empty list of declarations).</li> <li>Since the declaration group containing <code>D</code> is in the previous declaration group, the splice <code>$(th2 ...)</code> <em>can</em> refer to <code>D</code>.</li> </ol> </li> <li>
<p class="first">Expression quotations accept most Haskell language constructs. However, there are some GHC-specific extensions which expression quotations currently do not support, including</p> <ul class="simple"> <li>Type holes in typed splices (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10945">#10945</a> and <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/10946">#10946</a>)</li> </ul> </li> </ul> <p>(Compared to the original paper, there are many differences of detail. The syntax for a declaration splice uses “<code>$</code>” not “<code>splice</code>”. The type of the enclosed expression must be <code>Quote m =&gt; m [Dec]</code>, not <code>[Q Dec]</code>. Typed expression splices and quotations are supported.)</p> <dl class="ghc-flag"> <dt id="ghc-flag--fenable-th-splice-warnings">
<code>-fenable-th-splice-warnings</code> </dt> <dd>
<p>Template Haskell splices won’t be checked for warnings, because the code causing the warning might originate from a third-party library and possibly was not written by the user. If you want to have warnings for splices anyway, pass <a class="reference internal" href="#ghc-flag--fenable-th-splice-warnings"><code>-fenable-th-splice-warnings</code></a>.</p> </dd>
</dl>   <h2 id="th-usage">6.13.2. Using Template Haskell</h2> <ul id="using-template-haskell"> <li>The data types and monadic constructor functions for Template Haskell are in the library <a class="reference external" href="../../libraries/template-haskell-2.19.0.0/language-haskell-th-syntax.html">Language.Haskell.TH.Syntax</a>. </li> <li>You can only run a function at compile time if it is imported from another module. That is, you can’t define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it’s hard to implement.) </li> <li>
<p class="first">You can only run a function at compile time if it is imported from another module <em>that is not part of a mutually-recursive group of modules that includes the module currently being compiled</em>. Furthermore, all of the modules of the mutually-recursive group must be reachable by non-SOURCE imports from the module where the splice is to be run.</p> <p>For example, when compiling module A, you can only run Template Haskell functions imported from B if B does not import A (directly or indirectly). The reason should be clear: to run B we must compile and run A, but we are currently type-checking A.</p> </li> <li>If you are building GHC from source, you need at least a stage-2 bootstrap compiler to run Template Haskell splices and quasi-quotes. A stage-1 compiler will only accept regular quotes of Haskell. Reason: TH splices and quasi-quotes compile and run a program, and then looks at the result. So it’s important that the program it compiles produces results whose representations are identical to those of the compiler itself. </li> </ul> <p>Template Haskell works in any mode (<a class="reference internal" href="../using.html#ghc-flag---make"><code>--make</code></a>, <a class="reference internal" href="../using.html#ghc-flag---interactive"><code>--interactive</code></a>, or file-at-a-time). There used to be a restriction to the former two, but that restriction has been lifted.</p>   <h2 id="th-view-gen-code">6.13.3. Viewing Template Haskell generated code</h2> <p id="viewing-template-haskell-generated-code">The flag <a class="reference internal" href="../debugging.html#ghc-flag--ddump-splices"><code>-ddump-splices</code></a> shows the expansion of all top-level declaration splices, both typed and untyped, as they happen. As with all dump flags, the default is for this output to be sent to stdout. For a non-trivial program, you may be interested in combining this with the <a class="reference internal" href="../debugging.html#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a> flag (see <a class="reference internal" href="../debugging.html#dumping-output"><span class="std std-ref">Dumping out compiler intermediate structures</span></a>. For each file using Template Haskell, this will show the output in a <code>.dump-splices</code> file.</p> <p>The flag <a class="reference internal" href="../debugging.html#ghc-flag--dth-dec-file"><code>-dth-dec-file</code></a> dumps the expansions of all top-level TH declaration splices, both typed and untyped, in the file <code>M.th.hs</code> for each module <code>M</code> being compiled. Note that other types of splices (expressions, types, and patterns) are not shown. Application developers can check this into their repository so that they can grep for identifiers that were defined in Template Haskell. This is similar to using <a class="reference internal" href="../debugging.html#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a> with <a class="reference internal" href="../debugging.html#ghc-flag--ddump-splices"><code>-ddump-splices</code></a> but it always generates a file instead of being coupled to <a class="reference internal" href="../debugging.html#ghc-flag--ddump-to-file"><code>-ddump-to-file</code></a>. The format is also different: it does not show code from the original file, instead it only shows generated code and has a comment for the splice location of the original file.</p> <p>Below is a sample output of <a class="reference internal" href="../debugging.html#ghc-flag--ddump-splices"><code>-ddump-splices</code></a></p> <pre data-language="haskell">TH_pragma.hs:(6,4)-(8,26): Splicing declarations
  [d| foo :: Int -&gt; Int
      foo x = x + 1 |]
======&gt;
  foo :: Int -&gt; Int
  foo x = (x + 1)
</pre> <p>Below is the output of the same sample using <a class="reference internal" href="../debugging.html#ghc-flag--dth-dec-file"><code>-dth-dec-file</code></a></p> <pre data-language="haskell">-- TH_pragma.hs:(6,4)-(8,26): Splicing declarations
foo :: Int -&gt; Int
foo x = (x + 1)
</pre>   <h2 id="th-example">6.13.4. A Template Haskell Worked Example</h2> <p id="a-template-haskell-worked-example">To help you get over the confidence barrier, try out this skeletal worked example. First cut and paste the two modules below into <code>Main.hs</code> and <code>Printf.hs</code>:</p> <pre data-language="haskell">{- Main.hs -}
module Main where

-- Import our template "pr"
import Printf ( pr )

-- The splice operator $ takes the Haskell source code
-- generated at compile time by "pr" and splices it into
-- the argument of "putStrLn".
main = putStrLn ( $(pr "Hello") )


{- Printf.hs -}
module Printf where

-- Skeletal printf from the paper.
-- It needs to be in a separate module to the one where
-- you intend to use it.

-- Import some Template Haskell syntax
import Language.Haskell.TH

-- Describe a format string
data Format = D | S | L String

-- Parse a format string.  This is left largely to you
-- as we are here interested in building our first ever
-- Template Haskell program and not in building printf.
parse :: String -&gt; [Format]
parse s   = [ L s ]

-- Generate Haskell source code from a parsed representation
-- of the format string.  This code will be spliced into
-- the module which calls "pr", at compile time.
gen :: Quote m =&gt; [Format] -&gt; m Exp
gen [D]   = [| \n -&gt; show n |]
gen [S]   = [| \s -&gt; s |]
gen [L s] = stringE s

-- Here we generate the Haskell code for the splice
-- from an input format string.
pr :: Quote m =&gt; String -&gt; m Exp
pr s = gen (parse s)
</pre> <p>Now run the compiler,</p> <pre data-language="none">$ ghc --make -XTemplateHaskell main.hs -o main
</pre> <p>Run <code>main</code> and here is your output:</p> <pre data-language="none">$ ./main
Hello
</pre>   <h2 id="th-rs">6.13.5. Template Haskell quotes and Rebindable Syntax</h2> <p id="template-haskell-quotes-and-rebindable-syntax">Rebindable syntax does not play well with untyped TH quotes: applying the rebindable syntax rules would go against the lax nature of untyped quotes that are accepted even in the presence of unbound identifiers (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/18102">#18102</a>). Applying the rebindable syntax rules to them would force the code that defines the said quotes to have all the necessary functions (e.g <code>ifThenElse</code> or <code>fromInteger</code>) in scope, instead of delaying the resolution of those symbols to the code that splices the quoted Haskell syntax, as is usually done with untyped TH. For this reason, even if a module has untyped TH quotes with <code>RebindableSyntax</code> enabled, GHC turns off rebindable syntax while processing the quotes. The code that splices the quotes is however free to turn on <code>RebindableSyntax</code> to have the usual rules applied to the resulting code.</p> <p>Typed TH quotes on the other hand are perfectly compatible with the eager application of rebindable syntax rules, and GHC will therefore process any such quotes according to the rebindable syntax rules whenever the <code>RebindableSyntax</code> extension is turned on in the modules where such quotes appear.</p>   <h2 id="th-profiling">6.13.6. Using Template Haskell with Profiling</h2> <p id="using-template-haskell-with-profiling">Template Haskell relies on GHC’s built-in bytecode compiler and interpreter to run the splice expressions. The bytecode interpreter runs the compiled expression on top of the same runtime on which GHC itself is running; this means that the compiled code referred to by the interpreted expression must be compatible with this runtime, and in particular this means that object code that is compiled for profiling <em>cannot</em> be loaded and used by a splice expression, because profiled object code is only compatible with the profiling version of the runtime.</p> <p>This causes difficulties if you have a multi-module program containing Template Haskell code and you need to compile it for profiling, because GHC cannot load the profiled object code and use it when executing the splices.</p> <p>Fortunately GHC provides two workarounds.</p> <p>The first option is to compile the program twice:</p> <ol class="arabic"> <li>Compile the program or library first the normal way, without <a class="reference internal" href="../profiling.html#ghc-flag--prof"><code>-prof</code></a>. </li> <li>Then compile it again with <a class="reference internal" href="../profiling.html#ghc-flag--prof"><code>-prof</code></a>, and additionally use <code>-osuf
p_o</code> to name the object files differently (you can choose any suffix that isn’t the normal object suffix here). GHC will automatically load the object files built in the first step when executing splice expressions. If you omit the <a class="reference internal" href="#"><code>-osuf ⟨suffix⟩</code></a> flag when building with <a class="reference internal" href="../profiling.html#ghc-flag--prof"><code>-prof</code></a> and Template Haskell is used, GHC will emit an error message. </li> </ol> <p id="index-1">The second option is to add the flag <a class="reference internal" href="../ghci.html#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a> (see <a class="reference internal" href="../ghci.html#external-interpreter"><span class="std std-ref">Running the interpreter in a separate process</span></a>), which runs the interpreter in a separate process, wherein it can load and run the profiled code directly. There’s no need to compile the code twice, just add <a class="reference internal" href="../ghci.html#ghc-flag--fexternal-interpreter"><code>-fexternal-interpreter</code></a> and it should just work. (this option is experimental in GHC 8.0.x, but it may become the default in future releases).</p>   <h2 id="th-quasiquotation">6.13.7. Template Haskell Quasi-quotation</h2> <dl class="extension" id="template-haskell-quasi-quotation"> <dt id="extension-QuasiQuotes">
<code>QuasiQuotes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10.1</td> </tr>  </table> <p>Enable Template Haskell Quasi-quotation syntax.</p> </dd>
</dl> <p>Quasi-quotation allows patterns and expressions to be written using programmer-defined concrete syntax; the motivation behind the extension and several examples are documented in “<a class="reference external" href="https://www.cs.tufts.edu/comp/150FP/archive/geoff-mainland/quasiquoting.pdf">Why It’s Nice to be Quoted: Quasiquoting for Haskell</a>” (Proc Haskell Workshop 2007). The example below shows how to write a quasiquoter for a simple expression language.</p> <p>Here are the salient features</p> <ul> <li>
<p class="first">A quasi-quote has the form <code>[quoter| string |]</code>.</p> <ul class="simple"> <li>The ⟨quoter⟩ must be the name of an imported quoter, either qualified or unqualified; it cannot be an arbitrary expression.</li> <li>The ⟨quoter⟩ cannot be “<code>e</code>”, “<code>t</code>”, “<code>d</code>”, or “<code>p</code>”, since those overlap with Template Haskell quotations.</li> <li>There must be no spaces in the token <code>[quoter|</code>.</li> <li>The quoted ⟨string⟩ can be arbitrary, and may contain newlines.</li> <li>The quoted ⟨string⟩ finishes at the first occurrence of the two-character sequence <code>"|]"</code>. Absolutely no escaping is performed. If you want to embed that character sequence in the string, you must invent your own escape convention (such as, say, using the string <code>"|~]"</code> instead), and make your quoter function interpret <code>"|~]"</code> as <code>"|]"</code>. One way to implement this is to compose your quoter with a pre-processing pass to perform your escape conversion. See the discussion in <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/5348">#5348</a> for details.</li> </ul> </li> <li>
<p class="first">A quasiquote may appear in place of</p> <ul class="simple"> <li>An expression</li> <li>A pattern</li> <li>A type</li> <li>A top-level declaration</li> </ul> <p>(Only the first two are described in the paper.)</p> </li> <li>
<p class="first">A quoter is a value of type <a class="reference external" href="../../libraries/template-haskell-2.19.0.0/language-haskell-th-quote.html#t:QuasiQuoter">Language.Haskell.TH.Quote.QuasiQuoter</a>, which is defined thus:</p> <pre data-language="haskell">data QuasiQuoter = QuasiQuoter { quoteExp  :: String -&gt; Q Exp,
                                 quotePat  :: String -&gt; Q Pat,
                                 quoteType :: String -&gt; Q Type,
                                 quoteDec  :: String -&gt; Q [Dec] }
</pre> <p>That is, a quoter is a tuple of four parsers, one for each of the contexts in which a quasi-quote can occur.</p> </li> <li>A quasi-quote is expanded by applying the appropriate parser to the string enclosed by the Oxford brackets. The context of the quasi-quote (expression, pattern, type, declaration) determines which of the parsers is called. </li> <li>Unlike normal declaration splices of the form <code>$(...)</code>, declaration quasi-quotes do not cause a declaration group break. See <a class="reference internal" href="#th-syntax"><span class="std std-ref">Syntax</span></a> for more information. </li> </ul> <div class="admonition warning" id="quasi-quotes-list-comprehension-ambiguity"> <p class="first admonition-title">Warning</p> <p id="index-2"><a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> introduces an unfortunate ambiguity with list comprehension syntax. Consider the following,</p> <pre data-language="haskell">let x = [v| v &lt;- [0..10]]
</pre> <p class="last">Without <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> this is parsed as a list comprehension. With <a class="reference internal" href="#extension-QuasiQuotes"><code>QuasiQuotes</code></a> this is parsed as a quasi-quote; however, this parse will fail due to the lack of a closing <code>|]</code>. See <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/11679">#11679</a>.</p> </div> <p>The example below shows quasi-quotation in action. The quoter <code>expr</code> is bound to a value of type <code>QuasiQuoter</code> defined in module <code>Expr</code>. The example makes use of an antiquoted variable <code>n</code>, indicated by the syntax <code>'int:n</code> (this syntax for anti-quotation was defined by the parser’s author, <em>not</em> by GHC). This binds <code>n</code> to the integer value argument of the constructor <code>IntExpr</code> when pattern matching. Please see the referenced paper for further details regarding anti-quotation as well as the description of a technique that uses SYB to leverage a single parser of type <code>String -&gt; a</code> to generate both an expression parser that returns a value of type <code>Q Exp</code> and a pattern parser that returns a value of type <code>Q Pat</code>.</p> <p>Quasiquoters must obey the same stage restrictions as Template Haskell, e.g., in the example, <code>expr</code> cannot be defined in <code>Main.hs</code> where it is used, but must be imported.</p> <pre data-language="haskell">{- ------------- file Main.hs --------------- -}
module Main where

import Expr

main :: IO ()
main = do { print $ eval [expr|1 + 2|]
          ; case IntExpr 1 of
              { [expr|'int:n|] -&gt; print n
              ;  _              -&gt; return ()
              }
          }


{- ------------- file Expr.hs --------------- -}
module Expr where

import qualified Language.Haskell.TH as TH
import Language.Haskell.TH.Quote

data Expr  =  IntExpr Integer
           |  AntiIntExpr String
           |  BinopExpr BinOp Expr Expr
           |  AntiExpr String
    deriving(Show, Typeable, Data)

data BinOp  =  AddOp
            |  SubOp
            |  MulOp
            |  DivOp
    deriving(Show, Typeable, Data)

eval :: Expr -&gt; Integer
eval (IntExpr n)        = n
eval (BinopExpr op x y) = (opToFun op) (eval x) (eval y)
  where
    opToFun AddOp = (+)
    opToFun SubOp = (-)
    opToFun MulOp = (*)
    opToFun DivOp = div

expr = QuasiQuoter { quoteExp = parseExprExp, quotePat =  parseExprPat }

-- Parse an Expr, returning its representation as
-- either a Q Exp or a Q Pat. See the referenced paper
-- for how to use SYB to do this by writing a single
-- parser of type String -&gt; Expr instead of two
-- separate parsers.

parseExprExp :: String -&gt; Q Exp
parseExprExp ...

parseExprPat :: String -&gt; Q Pat
parseExprPat ...
</pre> <p>Now run the compiler:</p> <pre data-language="none">$ ghc --make -XQuasiQuotes Main.hs -o main
</pre> <p>Run “main” and here is your output:</p> <pre data-language="none">$ ./main
3
1
</pre>   </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/template_haskell.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/template_haskell.html</a>
  </p>
</div>
