<h1 id="runtime-rep">6.4.12. Representation polymorphism</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <p id="representation-polymorphism">In order to allow full flexibility in how kinds are used, it is necessary to use the kind system to differentiate between boxed, lifted types (normal, everyday types like <code>Int</code> and <code>[Bool]</code>) and unboxed, primitive types (<a class="reference internal" href="primitives.html#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a>) like <code>Int#</code>. We thus have so-called representation polymorphism.</p> <p>Here are the key definitions, all available from <code>GHC.Exts</code>:</p> <pre data-language="haskell">TYPE :: RuntimeRep -&gt; Type   -- highly magical, built into GHC

data Levity = Lifted    -- for things like `Int`
            | Unlifted  -- for things like `Array#`

data RuntimeRep = BoxedRep Levity  -- for anything represented by a GC-managed pointer
                | IntRep           -- for `Int#`
                | TupleRep [RuntimeRep]  -- unboxed tuples, indexed by the representations of the elements
                | SumRep [RuntimeRep]    -- unboxed sums, indexed by the representations of the disjuncts
                | ...

type LiftedRep = BoxedRep Lifted

type Type = TYPE LiftedRep    -- Type is just an ordinary type synonym
</pre> <p>The idea is that we have a new fundamental type constant <code>TYPE</code>, which is parameterised by a <code>RuntimeRep</code>. We thus get <code>Int# :: TYPE IntRep</code> and <code>Bool :: TYPE LiftedRep</code>. Anything with a type of the form <code>TYPE x</code> can appear to either side of a function arrow <code>-&gt;</code>. We can thus say that <code>-&gt;</code> has type <code>TYPE r1 -&gt; TYPE r2 -&gt; TYPE LiftedRep</code>. The result is always lifted because all functions are lifted in GHC.</p>  <h2 id="levity-polymorphism">6.4.12.1. Levity polymorphism</h2> <p>A special case of representation polymorphism is levity polymorphism, where we abstract over a variable of kind <code>Levity</code>, such as:</p> <pre data-language="haskell">example :: forall (l :: Levity) (a :: TYPE (BoxedRep l)). (Int -&gt; a) -&gt; a
example f = f 42
</pre> <p>With <a class="reference internal" href="primitives.html#extension-UnliftedDatatypes"><code>UnliftedDatatypes</code></a>, we can even declare levity-polymorphic data types:</p> <pre data-language="haskell">type PEither :: Type -&gt; Type -&gt; TYPE (BoxedRep l)
data PEither l r = PLeft l | PRight r
</pre>   <h2 id="representation-polymorphism-restrictions">6.4.12.2. No representation-polymorphic variables or arguments</h2> <p id="no-representation-polymorphic-variables-or-arguments">If GHC didn’t have to compile programs that run in the real world, that would be the end of the story. But representation polymorphism can cause quite a bit of trouble for GHC’s code generator. Consider</p> <pre data-language="haskell">bad :: forall (r1 :: RuntimeRep) (r2 :: RuntimeRep)
              (a :: TYPE r1) (b :: TYPE r2).
       (a -&gt; b) -&gt; a -&gt; b
bad f x = f x
</pre> <p>This seems like a generalisation of the standard <code>$</code> operator. If we think about compiling this to runnable code, though, problems appear. In particular, when we call <code>bad</code>, we must somehow pass <code>x</code> into <code>bad</code>. How wide (that is, how many bits) is <code>x</code>? Is it a pointer? What kind of register (floating-point or integral) should <code>x</code> go in? It’s all impossible to say, because <code>x</code>’s type, <code>a :: TYPE r1</code> is representation-polymorphic. We thus forbid such constructions, via the following straightforward rule:</p>  No variable may have a representation-polymorphic type. <p>This eliminates <code>bad</code> because the variable <code>x</code> would have a representation-polymorphic type.</p> <p>However, not all is lost. We can still do this:</p> <pre data-language="haskell">($) :: forall r (a :: Type) (b :: TYPE r).
       (a -&gt; b) -&gt; a -&gt; b
f $ x = f x
</pre> <p>Here, only <code>b</code> is representation-polymorphic. There are no variables with a representation-polymorphic type. And the code generator has no trouble with this. Indeed, this is the true type of GHC’s <code>$</code> operator, slightly more general than the Haskell 98 version.</p> <p>Because the code generator must store and move arguments as well as variables, the logic above applies equally well to function arguments, which may not be representation-polymorphic.</p>   <h2 id="representation-polymorphic-bottoms">6.4.12.3. Representation-polymorphic bottoms</h2> <p>We can use representation polymorphism to good effect with <code>error</code> and <code>undefined</code>, whose types are given here:</p> <pre data-language="haskell">undefined :: forall (r :: RuntimeRep) (a :: TYPE r).
             HasCallStack =&gt; a
error :: forall (r :: RuntimeRep) (a :: TYPE r).
         HasCallStack =&gt; String -&gt; a
</pre> <p>These functions do not bind a representation-polymorphic variable, and so are accepted. Their polymorphism allows users to use these to conveniently stub out functions that return unboxed types.</p>   <h2 id="id1">6.4.12.4. Printing representation-polymorphic types</h2> <dl class="ghc-flag" id="printing-representation-polymorphic-types"> <dt id="ghc-flag--fprint-explicit-runtime-reps">
<code>-fprint-explicit-runtime-reps</code> </dt> <dd>
<p>Print <code>RuntimeRep</code> and <code>Levity</code> parameters as they appear; otherwise, they are defaulted to <code>LiftedRep</code> and <code>Lifted</code>, respectively.</p> </dd>
</dl> <p>Most GHC users will not need to worry about representation polymorphism or unboxed types. For these users, seeing the representation polymorphism in the type of <code>$</code> is unhelpful. And thus, by default, it is suppressed, by supposing all type variables of type <code>RuntimeRep</code> to be <code>LiftedRep</code> when printing, and printing <code>TYPE LiftedRep</code> as <code>Type</code> (or <code>*</code> when <a class="reference internal" href="poly_kinds.html#extension-StarIsType"><code>StarIsType</code></a> is on).</p> <p>Should you wish to see representation polymorphism in your types, enable the flag <a class="reference internal" href="#ghc-flag--fprint-explicit-runtime-reps"><code>-fprint-explicit-runtime-reps</code></a>. For example,</p>  <pre data-language="none">ghci&gt; :t ($)
($) :: (a -&gt; b) -&gt; a -&gt; b
ghci&gt; :set -fprint-explicit-runtime-reps
ghci&gt; :t ($)
($)
  :: forall (r :: GHC.Types.RuntimeRep) a (b :: TYPE r).
     (a -&gt; b) -&gt; a -&gt; b
</pre>    </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/representation_polymorphism.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/exts/representation_polymorphism.html</a>
  </p>
</div>
