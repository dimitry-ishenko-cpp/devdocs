<h1 id="options-sanity">5.2. Warnings and sanity-checking</h1>
<div class="_sphinx"> <div itemprop="articleBody">   <p id="warnings-and-sanity-checking">GHC has a number of options that select which types of non-fatal error messages, otherwise known as warnings, can be generated during compilation. Some options control individual warnings and others control collections of warnings. To turn off an individual warning <code>-W&lt;wflag&gt;</code>, use <code>-Wno-&lt;wflag&gt;</code>. To reverse <code>-Werror</code>, which makes all warnings into errors, use <code>-Wwarn</code>.</p> <div class="admonition note"> <p class="first admonition-title">Note</p> <p class="last">In GHC &lt; 8 the syntax for <code>-W&lt;wflag&gt;</code> was <code>-fwarn-&lt;wflag&gt;</code> (e.g. <code>-fwarn-incomplete-patterns</code>). This spelling is deprecated, but still accepted for backwards compatibility. Likewise, <code>-Wno-&lt;wflag&gt;</code> used to be <code>fno-warn-&lt;wflag&gt;</code> (e.g. <code>-fno-warn-incomplete-patterns</code>).</p> </div> <dl class="ghc-flag"> <dt id="ghc-flag--Wdefault">
<code>-Wdefault</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>By default, you get a standard set of warnings which are generally likely to indicate bugs in your program. These are:</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Woverlapping-patterns"><code>-Woverlapping-patterns</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wwarnings-deprecations"><code>-Wwarnings-deprecations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeprecations"><code>-Wdeprecations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeprecated-flags"><code>-Wdeprecated-flags</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunrecognised-pragmas"><code>-Wunrecognised-pragmas</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wduplicate-exports"><code>-Wduplicate-exports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wderiving-defaults"><code>-Wderiving-defaults</code></a></li> <li><a class="reference internal" href="#ghc-flag--Woverflowed-literals"><code>-Woverflowed-literals</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wempty-enumerations"><code>-Wempty-enumerations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-fields"><code>-Wmissing-fields</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-methods"><code>-Wmissing-methods</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wwrong-do-bind"><code>-Wwrong-do-bind</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wsimplifiable-class-constraints"><code>-Wsimplifiable-class-constraints</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wtyped-holes"><code>-Wtyped-holes</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdeferred-type-errors"><code>-Wdeferred-type-errors</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wpartial-type-signatures"><code>-Wpartial-type-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunsupported-calling-conventions"><code>-Wunsupported-calling-conventions</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdodgy-foreign-imports"><code>-Wdodgy-foreign-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Winline-rule-shadowing"><code>-Winline-rule-shadowing</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunsupported-llvm-version"><code>-Wunsupported-llvm-version</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissed-extra-shared-lib"><code>-Wmissed-extra-shared-lib</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wtabs"><code>-Wtabs</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunrecognised-warning-flags"><code>-Wunrecognised-warning-flags</code></a></li> <li><a class="reference internal" href="#ghc-flag--Winaccessible-code"><code>-Winaccessible-code</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wstar-binder"><code>-Wstar-binder</code></a></li> <li><a class="reference internal" href="#ghc-flag--Woperator-whitespace-ext-conflict"><code>-Woperator-whitespace-ext-conflict</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wambiguous-fields"><code>-Wambiguous-fields</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunicode-bidirectional-format-characters"><code>-Wunicode-bidirectional-format-characters</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wforall-identifier"><code>-Wforall-identifier</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wgadt-mono-local-binds"><code>-Wgadt-mono-local-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wtype-equality-requires-operators"><code>-Wtype-equality-requires-operators</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <p>The following flags are simple ways to select standard “packages” of warnings:</p> <dl class="ghc-flag"> <dt id="ghc-flag--W">
<code>-W</code> </dt> <dd>
<p>Provides the standard warnings plus</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-binds"><code>-Wunused-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-foralls"><code>-Wunused-foralls</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-imports"><code>-Wunused-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wdodgy-exports"><code>-Wdodgy-exports</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wdodgy-imports"><code>-Wdodgy-imports</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunbanged-strict-patterns"><code>-Wunbanged-strict-patterns</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wextra">
<code>-Wextra</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#ghc-flag--W"><code>-W</code></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wall">
<code>-Wall</code> </dt> <dd>
<p>Turns on all warning options that indicate potentially suspicious code. The warnings that are <em>not</em> enabled by <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a> are</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wmonomorphism-restriction"><code>-Wmonomorphism-restriction</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wimplicit-prelude"><code>-Wimplicit-prelude</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-export-lists"><code>-Wmissing-export-lists</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-import-lists"><code>-Wmissing-import-lists</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-home-modules"><code>-Wmissing-home-modules</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Widentities"><code>-Widentities</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wredundant-constraints</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissed-specialisations"><code>-Wmissed-specialisations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wall-missed-specialisations"><code>-Wall-missed-specialisations</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wcpp-undef"><code>-Wcpp-undef</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wduplicate-constraints"><code>-Wduplicate-constraints</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wmissing-deriving-strategies"><code>-Wmissing-deriving-strategies</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-packages"><code>-Wunused-packages</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a></li> <li><a class="reference internal" href="exts/safe_haskell.html#ghc-flag--Wsafe"><code>-Wsafe</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wimplicit-lift"><code>-Wimplicit-lift</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wmissing-kind-signatures"><code>-Wmissing-kind-signatures</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunticked-promoted-constructors"><code>-Wunticked-promoted-constructors</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Weverything">
<code>-Weverything</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>Turns on every single warning supported by the compiler.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wcompat">
<code>-Wcompat</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>Turns on warnings that will be enabled by default in the future, but remain off in normal compilations for the time being. This allows library authors eager to make their code future compatible to adapt to new features before they even generate warnings.</p> <p>This currently enables</p> <table class="hlist"><tr>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wsemigroup"><code>-Wsemigroup</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wnoncanonical-monoid-instances"><code>-Wnoncanonical-monoid-instances</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wstar-is-type"><code>-Wstar-is-type</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wcompat-unqualified-imports"><code>-Wcompat-unqualified-imports</code></a></li> </ul> </td>
<td>
<ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wtype-equality-out-of-scope"><code>-Wtype-equality-out-of-scope</code></a></li> </ul> </td>
</tr></table> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wno-compat">
<code>-Wno-compat</code> </dt> <dd>
<p>Disables all warnings enabled by <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--w">
<code>-w</code> </dt> <dd>
<p>Turns off all warnings, including the standard ones and those that <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a> doesn’t enable.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnot">
<code>-Wnot</code> </dt> <dd>
<p>Deprecated alias for <a class="reference internal" href="#ghc-flag--w"><code>-w</code></a></p> </dd>
</dl> <p>These options control which warnings are considered fatal and cause compilation to abort.</p> <dl class="ghc-flag"> <dt id="ghc-flag--Werror">
<code>-Werror</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8 (<code>-Wwarn</code>)</td> </tr>  </table> <p>Makes any warning into a fatal error. Useful so that you don’t miss warnings when doing batch compilation. To reverse <code>-Werror</code> and stop treating any warnings as errors use <code>-Wwarn</code>, or use <code>-Wwarn=&lt;wflag&gt;</code> to stop treating specific warnings as errors.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-Werror=⟨wflag⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Implies:</th>
<td class="field-body"><code>-W&lt;wflag&gt;</code></td> </tr>  </table> <p>Makes a specific warning into a fatal error. The warning will be enabled if it hasn’t been enabled yet. Can be reversed with <code>-Wwarn=&lt;wflag&gt;</code>.</p> <p><code>-Werror=compat</code> has the same effect as <code>-Werror=...</code> for each warning flag in the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwarn">
<code>-Wwarn</code> </dt> <dd>
<p>Warnings are treated only as warnings, not as errors. This is the default, but can be useful to negate a <a class="reference internal" href="#ghc-flag--Wwarn"><code>-Werror</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt>
<code>-Wwarn=⟨wflag⟩</code> </dt> <dd>
<p>Causes a specific warning to be treated as normal warning, not fatal error.</p> <p>Note that it doesn’t fully negate the effects of <code>-Werror=&lt;wflag&gt;</code> - the warning will still be enabled.</p> <p><code>-Wwarn=compat</code> has the same effect as <code>-Wwarn=...</code> for each warning flag in the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <p>When a warning is emitted, the specific warning flag which controls it is shown.</p> <dl class="ghc-flag"> <dt id="ghc-flag--fshow-warning-groups">
<code>-fshow-warning-groups</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>When showing which flag controls a warning, also show the respective warning group flag(s) that warning is contained in.</p> </dd>
</dl> <p>The full set of warning options is described below. To turn off any warning, simply give the corresponding <code>-Wno-...</code> option on the command line. For backwards compatibility with GHC versions prior to 8.0, all these warnings can still be controlled with <code>-f(no-)warn-*</code> instead of <code>-W(no-)*</code>.</p> <dl class="ghc-flag"> <dt id="ghc-flag--Wunrecognised-warning-flags">
<code>-Wunrecognised-warning-flags</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Enables warnings when the compiler encounters a <code>-W...</code> flag that is not recognised.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wcompat-unqualified-imports">
<code>-Wcompat-unqualified-imports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p>Warns on unqualified imports of core library modules which are subject to change in future GHC releases. Currently the following modules are covered by this warning:</p>  <ul class="simple"> <li>
<code>Data.List</code> due to the future addition of <code>Data.List.singleton</code> and specialisation of exports to the <code>[]</code> type. See the <a class="reference external" href="https://groups.google.com/forum/#!topic/haskell-core-libraries/q3zHLmzBa5E">mailing list</a> for details.</li> </ul>  <p>This warning can be addressed by either adding an explicit import list or using a <code>qualified</code> import.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wprepositive-qualified-module">
<code>-Wprepositive-qualified-module</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p>Normally, imports are qualified prepositively: <code>import qualified M</code>. By using <a class="reference internal" href="exts/import_qualified_post.html#extension-ImportQualifiedPost"><code>ImportQualifiedPost</code></a>, the qualified keyword can be used after the module name. Like so: <code>import M qualified</code>. This will warn when the first, prepositive syntax is used.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtyped-holes">
<code>-Wtyped-holes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Determines whether the compiler reports typed holes warnings. Has no effect unless typed holes errors are deferred until runtime. See <a class="reference internal" href="exts/typed_holes.html#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeferred-type-errors">
<code>-Wdeferred-type-errors</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Causes a warning to be reported when a type error is deferred until runtime. See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-type-errors">
<code>-fdefer-type-errors</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6</td> </tr> <tr>
<th class="field-name">Implies:</th>
<td class="field-body">
<a class="reference internal" href="#ghc-flag--fdefer-typed-holes"><code>-fdefer-typed-holes</code></a>, <a class="reference internal" href="#ghc-flag--fdefer-out-of-scope-variables"><code>-fdefer-out-of-scope-variables</code></a>
</td> </tr>  </table> <p>Defer as many type errors as possible until runtime. At compile time you get a warning (instead of an error). At runtime, if you use a value that depends on a type error, you get a runtime error; but you can run any type-correct parts of your code just fine. See <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-typed-holes">
<code>-fdefer-typed-holes</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10</td> </tr>  </table> <p>Defer typed holes errors (errors about names with a leading underscore (e.g., “_”, “_foo”, “_bar”)) until runtime. This will turn the errors produced by <a class="reference internal" href="exts/typed_holes.html#typed-holes"><span class="std std-ref">typed holes</span></a> into warnings. Using a value that depends on a typed hole produces a runtime error, the same as <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> (which implies this option). See <a class="reference internal" href="exts/typed_holes.html#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a>.</p> <p>Implied by <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a>. See also <a class="reference internal" href="#ghc-flag--Wtyped-holes"><code>-Wtyped-holes</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fdefer-out-of-scope-variables">
<code>-fdefer-out-of-scope-variables</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>Defer variable out-of-scope errors (errors about names without a leading underscore) until runtime. This will turn variable-out-of-scope errors into warnings. Using a value that depends on an out-of-scope variable produces a runtime error, the same as <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a> (which implies this option). See <a class="reference internal" href="exts/typed_holes.html#typed-holes"><span class="std std-ref">Typed Holes</span></a> and <a class="reference internal" href="exts/defer_type_errors.html#defer-type-errors"><span class="std std-ref">Deferring type errors to runtime</span></a>.</p> <p>Implied by <a class="reference internal" href="#ghc-flag--fdefer-type-errors"><code>-fdefer-type-errors</code></a>. See also <a class="reference internal" href="#ghc-flag--Wdeferred-out-of-scope-variables"><code>-Wdeferred-out-of-scope-variables</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeferred-out-of-scope-variables">
<code>-Wdeferred-out-of-scope-variables</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>Warn when a deferred out-of-scope variable is encountered.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wpartial-type-signatures">
<code>-Wpartial-type-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Determines whether the compiler reports holes in partial type signatures as warnings. Has no effect unless <a class="reference internal" href="exts/partial_type_signatures.html#extension-PartialTypeSignatures"><code>PartialTypeSignatures</code></a> is enabled, which controls whether errors should be generated for holes in types or not. See <a class="reference internal" href="exts/partial_type_signatures.html#partial-type-signatures"><span class="std std-ref">Partial Type Signatures</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fhelpful-errors">
<code>-fhelpful-errors</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>When a name or package is not found in scope, make suggestions for the name or package you might have meant instead.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunrecognised-pragmas">
<code>-Wunrecognised-pragmas</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Causes a warning to be emitted when a pragma that GHC doesn’t recognise is used. As well as pragmas that GHC itself uses, GHC also recognises pragmas known to be used by other tools, e.g. <code>OPTIONS_HUGS</code> and <code>DERIVE</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmisplaced-pragmas">
<code>-Wmisplaced-pragmas</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p>Warn when a pragma that should only appear in the header of a module, such as a <code>LANGUAGE</code> or <code>OPTIONS_GHC</code> pragma, appears in the body of the module instead.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissed-specialisations">
<code>-Wmissed-specialisations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Emits a warning if GHC cannot specialise an overloaded function, usually because the function needs an <code>INLINABLE</code> pragma. Reports when the situation arises during specialisation of an imported function.</p> <p>This form is intended to catch cases where an imported function that is marked as <code>INLINABLE</code> (presumably to enable specialisation) cannot be specialised as it calls other functions that are themselves not specialised.</p> <p>Note that this warning will not throw errors if used with <a class="reference internal" href="#ghc-flag--Wwarn"><code>-Werror</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissed-specializations">
<code>-Wmissed-specializations</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#ghc-flag--Wmissed-specialisations"><code>-Wmissed-specialisations</code></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wall-missed-specialisations">
<code>-Wall-missed-specialisations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Emits a warning if GHC cannot specialise an overloaded function, usually because the function needs an <code>INLINABLE</code> pragma. Reports all such situations.</p> <p>Note that this warning will not throw errors if used with <a class="reference internal" href="#ghc-flag--Wwarn"><code>-Werror</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wall-missed-specializations">
<code>-Wall-missed-specializations</code> </dt> <dd>
<p>Alias for <a class="reference internal" href="#ghc-flag--Wall-missed-specialisations"><code>-Wall-missed-specialisations</code></a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwarnings-deprecations">
<code>-Wwarnings-deprecations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-1">Causes a warning to be emitted when a module, function or type with a <code>WARNING</code> or <code>DEPRECATED pragma</code> is used. See <a class="reference internal" href="exts/pragmas.html#warning-deprecated-pragma"><span class="std std-ref">WARNING and DEPRECATED pragmas</span></a> for more details on the pragmas.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeprecations">
<code>-Wdeprecations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-2">Causes a warning to be emitted when a module, function or type with a <code>WARNING</code> or <code>DEPRECATED pragma</code> is used. See <a class="reference internal" href="exts/pragmas.html#warning-deprecated-pragma"><span class="std std-ref">WARNING and DEPRECATED pragmas</span></a> for more details on the pragmas. An alias for <a class="reference internal" href="#ghc-flag--Wwarnings-deprecations"><code>-Wwarnings-deprecations</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monad-instances">
<code>-Wnoncanonical-monad-instances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>Warn if noncanonical <code>Applicative</code> or <code>Monad</code> instances declarations are detected.</p> <p>When this warning is enabled, the following conditions are verified:</p> <p>In <code>Monad</code> instances declarations warn if any of the following conditions does not hold:</p>  <ul class="simple"> <li>If <code>return</code> is defined it must be canonical (i.e. <code>return = pure</code>).</li> <li>If <code>(&gt;&gt;)</code> is defined it must be canonical (i.e. <code>(&gt;&gt;) = (*&gt;)</code>).</li> </ul>  <p>Moreover, in <code>Applicative</code> instance declarations:</p>  <ul class="simple"> <li>Warn if <code>pure</code> is defined backwards (i.e. <code>pure = return</code>).</li> <li>Warn if <code>(*&gt;)</code> is defined backwards (i.e. <code>(*&gt;) = (&gt;&gt;)</code>).</li> </ul>  </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monadfail-instances">
<code>-Wnoncanonical-monadfail-instances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>This warning is deprecated. It no longer has any effect since GHC 8.8. It was used during the transition period of the MonadFail proposal, to detect when an instance of the <code>Monad</code> class was not defined via <code>MonadFail</code>, or when a <code>MonadFail</code> instance was defined backwards, using the method in <code>Monad</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wnoncanonical-monoid-instances">
<code>-Wnoncanonical-monoid-instances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>Warn if noncanonical <code>Semigroup</code> or <code>Monoid</code> instances declarations are detected.</p> <p>When this warning is enabled, the following conditions are verified:</p> <p>In <code>Monoid</code> instances declarations warn if any of the following conditions does not hold:</p>  <ul class="simple"> <li>If <code>mappend</code> is defined it must be canonical (i.e. <code>mappend = (Data.Semigroup.&lt;&gt;)</code>).</li> </ul>  <p>Moreover, in <code>Semigroup</code> instance declarations:</p>  <ul class="simple"> <li>Warn if <code>(&lt;&gt;)</code> is defined backwards (i.e. <code>(&lt;&gt;) = mappend</code>).</li> </ul>  <p>This warning is off by default. However, it is part of the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-monadfail-instances">
<code>-Wmissing-monadfail-instances</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p>This warning is deprecated. It no longer has any effect since GHC 8.8. It was used during the transition period of the MonadFail proposal, to warn when a failable pattern is used in a do-block that does not have a <code>MonadFail</code> instance.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wsemigroup">
<code>-Wsemigroup</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-3">Warn when definitions are in conflict with the future inclusion of <code>Semigroup</code> into the standard typeclasses.</p>  <ol class="arabic simple"> <li>Instances of <code>Monoid</code> should also be instances of <code>Semigroup</code>
</li> <li>The <code>Semigroup</code> operator <code>(&lt;&gt;)</code> will be in <code>Prelude</code>, which clashes with custom local definitions of such an operator</li> </ol>  <p>Being part of the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdeprecated-flags">
<code>-Wdeprecated-flags</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-4">Causes a warning to be emitted when a deprecated command-line flag is used.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunsupported-calling-conventions">
<code>-Wunsupported-calling-conventions</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.6</td> </tr>  </table> <p>Causes a warning to be emitted for foreign declarations that use unsupported calling conventions. In particular, if the <code>stdcall</code> calling convention is used on an architecture other than i386 then it will be treated as <code>ccall</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-foreign-imports">
<code>-Wdodgy-foreign-imports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.10</td> </tr>  </table> <p>Causes a warning to be emitted for foreign imports of the following form:</p> <pre data-language="haskell">foreign import "f" f :: FunPtr t
</pre> <p>on the grounds that it probably should be</p> <pre data-language="haskell">foreign import "&amp;f" f :: FunPtr t
</pre> <p>The first form declares that <code>f</code> is a (pure) C function that takes no arguments and returns a pointer to a C function with type <code>t</code>, whereas the second form declares that <code>f</code> itself is a C function with type <code>t</code>. The first declaration is usually a mistake, and one that is hard to debug because it results in a crash, hence this warning.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-exports">
<code>-Wdodgy-exports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12</td> </tr>  </table> <p>Causes a warning to be emitted when a datatype <code>T</code> is exported with all constructors, i.e. <code>T(..)</code>, but is it just a type synonym.</p> <p>Also causes a warning to be emitted when a module is re-exported, but that module exports nothing.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wdodgy-imports">
<code>-Wdodgy-imports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8</td> </tr>  </table> <p>Causes a warning to be emitted in the following cases:</p> <ul class="simple"> <li>When a datatype <code>T</code> is imported with all constructors, i.e. <code>T(..)</code>, but has been exported abstractly, i.e. <code>T</code>.</li> <li>When an <code>import</code> statement hides an entity that is not exported.</li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woverflowed-literals">
<code>-Woverflowed-literals</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr>  </table> <p>Causes a warning to be emitted if a literal will overflow, e.g. <code>300 :: Word8</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wempty-enumerations">
<code>-Wempty-enumerations</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr>  </table> <p>Causes a warning to be emitted if an enumeration is empty, e.g. <code>[5 .. 3]</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wderiving-defaults">
<code>-Wderiving-defaults</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p>Causes a warning when both <a class="reference internal" href="exts/derive_any_class.html#extension-DeriveAnyClass"><code>DeriveAnyClass</code></a> and <a class="reference internal" href="exts/newtype_deriving.html#extension-GeneralizedNewtypeDeriving"><code>GeneralizedNewtypeDeriving</code></a> are enabled and no explicit deriving strategy is in use. For example, this would result a warning:</p> <pre data-language="haskell">class C a
newtype T a = MkT a deriving C
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wduplicate-constraints">
<code>-Wduplicate-constraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr>  </table> <p id="index-5">Have the compiler warn about duplicate constraints in a type signature. For example</p> <pre data-language="haskell">f :: (Eq a, Show a, Eq a) =&gt; a -&gt; a
</pre> <p>The warning will indicate the duplicated <code>Eq a</code> constraint.</p> <p>This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wredundant-constraints</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wredundant-constraints">
<code>-Wredundant-constraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-6">Have the compiler warn about redundant constraints in a type signature. In particular:</p> <ul> <li>
<p class="first">A redundant constraint within the type signature itself:</p> <pre data-language="haskell">f :: (Eq a, Ord a) =&gt; a -&gt; a
</pre> <p>The warning will indicate the redundant <code>Eq a</code> constraint: it is subsumed by the <code>Ord a</code> constraint.</p> </li> <li>
<p class="first">A constraint in the type signature is not used in the code it covers:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a -&gt; Bool
f x y = True
</pre> <p>The warning will indicate the redundant <code>Eq a</code> constraint: : it is not used by the definition of <code>f</code>.)</p> </li> </ul> <p>Similar warnings are given for a redundant constraint in an instance declaration.</p> <p>When turning on, you can suppress it on a per-module basis with <a class="reference internal" href="#ghc-flag--Wredundant-constraints"><code>-Wno-redundant-constraints</code></a>. Occasionally you may specifically want a function to have a more constrained signature than necessary, perhaps to leave yourself wiggle-room for changing the implementation without changing the API. In that case, you can suppress the warning on a per-function basis, using a call in a dead binding. For example:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a -&gt; Bool
f x y = True
where
    _ = x == x  -- Suppress the redundant-constraint warning for (Eq a)
</pre> <p>Here the call to <code>(==)</code> makes GHC think that the <code>(Eq a)</code> constraint is needed, so no warning is issued.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wduplicate-exports">
<code>-Wduplicate-exports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-7">Have the compiler warn about duplicate entries in export lists. This is useful information if you maintain large export lists, and want to avoid the continued export of a definition after you’ve deleted (one) mention of it in the export list.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Whi-shadowing">
<code>-Whi-shadowing</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04, deprecated</td> </tr>  </table> <p id="index-8">Causes the compiler to emit a warning when a module or interface file in the current directory is shadowing one with the same module name in a library or other directory.</p> <p>This flag was not implemented correctly and is now deprecated. It will be removed in a later version of GHC.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Widentities">
<code>-Widentities</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2</td> </tr>  </table> <p>Causes the compiler to emit a warning when a Prelude numeric conversion converts a type <code>T</code> to the same type <code>T</code>; such calls are probably no-ops and can be omitted. The functions checked for are: <code>toInteger</code>, <code>toRational</code>, <code>fromIntegral</code>, and <code>realToFrac</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wimplicit-kind-vars">
<code>-Wimplicit-kind-vars</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p>This warning is deprecated. It no longer has any effect since GHC 8.10. It was used to detect if a kind variable is not explicitly quantified over. For instance, the following would produce a warning:</p> <pre data-language="haskell">f :: forall (a :: k). Proxy a
</pre> <p>This is now an error and can be fixed by explicitly quantifying over <code>k</code>:</p> <pre data-language="haskell">f :: forall k (a :: k). Proxy a
</pre> <p>or</p> <pre data-language="haskell">f :: forall {k} (a :: k). Proxy a
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wimplicit-lift">
<code>-Wimplicit-lift</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr>  </table> <p>Template Haskell quotes referring to local variables bound outside of the quote are implicitly converted to use <code>lift</code>. For example, <code>f x = [| reverse x |]</code> becomes <code>f x = [| reverse $(lift x) |])</code>. This flag issues a warning for every such implicit addition of <code>lift</code>. This can be useful when debugging more complex staged programs, where an implicit <code>lift</code> can accidentally conceal a variable used at a wrong stage.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wimplicit-prelude">
<code>-Wimplicit-prelude</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-9">Have the compiler warn if the Prelude is implicitly imported. This happens unless either the Prelude module is explicitly imported with an <code>import
... Prelude ...</code> line, or this implicit import is disabled (either by <a class="reference internal" href="exts/rebindable_syntax.html#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a> or a <code>LANGUAGE NoImplicitPrelude</code> pragma).</p> <p>Note that no warning is given for syntax that implicitly refers to the Prelude, even if <a class="reference internal" href="exts/rebindable_syntax.html#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a> would change whether it refers to the Prelude. For example, no warning is given when <code>368</code> means <code>Prelude.fromInteger (368::Prelude.Integer)</code> (where <code>Prelude</code> refers to the actual Prelude module, regardless of the imports of the module being compiled).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-patterns">
<code>-Wincomplete-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">5.04</td> </tr>  </table> <p id="index-10">The option <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> warns about places where a pattern-match might fail at runtime. The function <code>g</code> below will fail when applied to non-empty lists, so the compiler will emit a warning about this when <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a> is enabled.</p> <pre data-language="haskell">g [] = 2
</pre> <p>This option isn’t enabled by default because it can be a bit noisy, and it doesn’t always indicate a bug in the program. However, it’s generally considered good practice to cover all the cases in your functions, and it is switched on by <a class="reference internal" href="#ghc-flag--W"><code>-W</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-uni-patterns">
<code>-Wincomplete-uni-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.2</td> </tr>  </table> <p>The flag <a class="reference internal" href="#ghc-flag--Wincomplete-uni-patterns"><code>-Wincomplete-uni-patterns</code></a> is similar to <a class="reference internal" href="#ghc-flag--Wincomplete-patterns"><code>-Wincomplete-patterns</code></a>, except that it applies only to lambda-expressions and pattern bindings, constructs that only allow a single pattern:</p> <pre data-language="haskell">h = \[] -&gt; 2
Just k = f y
</pre> <p>Furthermore, this flag also applies to lazy patterns, since they are syntactic sugar for pattern bindings. For example, <code>f ~(Just x) = (x,x)</code> is equivalent to <code>f y = let Just x = y in (x,x)</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--fmax-pmcheck-models=⟨n⟩">
<code>-fmax-pmcheck-models=⟨n⟩</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">30</td> </tr>  </table> <p>The pattern match checker works by assigning symbolic values to each pattern. We call each such assignment a ‘model’. Now, each pattern match clause leads to potentially multiple splits of that model, encoding different ways for the pattern match to fail. For example, when matching <code>x</code> against <code>Just 4</code>, we split each incoming matching model into two uncovered sub-models: One where <code>x</code> is <code>Nothing</code> and one where <code>x</code> is <code>Just y</code> but <code>y</code> is not <code>4</code>.</p> <p>This can be exponential in the arity of the pattern and in the number of guards in some cases. The <a class="reference internal" href="#ghc-flag--fmax-pmcheck-models=%E2%9F%A8n%E2%9F%A9"><code>-fmax-pmcheck-models=⟨n⟩</code></a> limit makes sure we scale polynomially in the number of patterns, by forgetting refined information gained from a partially successful match. For the above example, if we had a limit of 1, we would continue checking the next clause with the original, unrefined model.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wincomplete-record-updates">
<code>-Wincomplete-record-updates</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.4</td> </tr>  </table> <p id="index-11">The function <code>f</code> below will fail when applied to <code>Bar</code>, so the compiler will emit a warning about this when <a class="reference internal" href="#ghc-flag--Wincomplete-record-updates"><code>-Wincomplete-record-updates</code></a> is enabled.</p> <pre data-language="haskell">data Foo = Foo { x :: Int }
         | Bar

f :: Foo -&gt; Foo
f foo = foo { x = 6 }
</pre> <p>This option isn’t enabled by default because it can be very noisy, and it often doesn’t indicate a bug in the program.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-deriving-strategies">
<code>-Wmissing-deriving-strategies</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8.1</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p>The datatype below derives the <code>Eq</code> typeclass, but doesn’t specify a strategy. When <a class="reference internal" href="#ghc-flag--Wmissing-deriving-strategies"><code>-Wmissing-deriving-strategies</code></a> is enabled, the compiler will emit a warning about this.</p> <pre data-language="haskell">data Foo a = Foo a
  deriving (Eq)
</pre> <p>The compiler will warn here that the deriving clause doesn’t specify a strategy. If the warning is enabled, but <a class="reference internal" href="exts/deriving_strategies.html#extension-DerivingStrategies"><code>DerivingStrategies</code></a> is not enabled, the compiler will suggest turning on the <a class="reference internal" href="exts/deriving_strategies.html#extension-DerivingStrategies"><code>DerivingStrategies</code></a> extension.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-fields">
<code>-Wmissing-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-12">This option is on by default, and warns you whenever the construction of a labelled field constructor isn’t complete, missing initialisers for one or more fields. While not an error (the missing fields are initialised with bottoms), it is often an indication of a programmer error.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-export-lists">
<code>-Wmissing-export-lists</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4</td> </tr>  </table> <p id="index-13">This flag warns if you declare a module without declaring an explicit export list. For example</p> <pre data-language="haskell">module M where

  p x = x
</pre> <p>The <a class="reference internal" href="#ghc-flag--Wmissing-export-lists"><code>-Wmissing-export-lists</code></a> flag will warn that <code>M</code> does not declare an export list. Declaring an explicit export list for <code>M</code> enables GHC dead code analysis, prevents accidental export of names and can ease optimizations like inlining.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-import-lists">
<code>-Wmissing-import-lists</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.0</td> </tr>  </table> <p id="index-14">This flag warns if you use an unqualified <code>import</code> declaration that does not explicitly list the entities brought into scope. For example</p> <pre data-language="haskell">module M where
  import X( f )
  import Y
  import qualified Z
  p x = f x x
</pre> <p>The <a class="reference internal" href="#ghc-flag--Wmissing-import-lists"><code>-Wmissing-import-lists</code></a> flag will warn about the import of <code>Y</code> but not <code>X</code> If module <code>Y</code> is later changed to export (say) <code>f</code>, then the reference to <code>f</code> in <code>M</code> will become ambiguous. No warning is produced for the import of <code>Z</code> because extending <code>Z</code>’s exports would be unlikely to produce ambiguity in <code>M</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-methods">
<code>-Wmissing-methods</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-15">This option warns you whenever an instance declaration is missing one or more methods, and the corresponding class declaration has no default declaration for them.</p> <p>The <code>MINIMAL</code> pragma can be used to change which combination of methods will be required for instances of a particular class. See <a class="reference internal" href="exts/pragmas.html#minimal-pragma"><span class="std std-ref">MINIMAL pragma</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-signatures">
<code>-Wmissing-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-16">If you would like GHC to check that every top-level function/value has a type signature, use the <a class="reference internal" href="#ghc-flag--Wmissing-signatures"><code>-Wmissing-signatures</code></a> option. As part of the warning GHC also reports the inferred type.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-exported-sigs">
<code>-Wmissing-exported-sigs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10</td> </tr>  </table> <p id="index-17">This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-exported-signatures">
<code>-Wmissing-exported-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-18">If you would like GHC to check that every exported top-level function/value has a type signature, but not check unexported values, use the <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a> option. If this option is used in conjunction with <a class="reference internal" href="#ghc-flag--Wmissing-signatures"><code>-Wmissing-signatures</code></a> then every top-level function/value must have a type signature. As part of the warning GHC also reports the inferred type.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-local-sigs">
<code>-Wmissing-local-sigs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.0</td> </tr>  </table> <p id="index-19">This option is now deprecated in favour of <a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-local-signatures">
<code>-Wmissing-local-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-20">If you use the <a class="reference internal" href="#ghc-flag--Wmissing-local-signatures"><code>-Wmissing-local-signatures</code></a> flag GHC will warn you about any polymorphic local bindings. As part of the warning GHC also reports the inferred type. The option is off by default.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-pattern-synonym-signatures">
<code>-Wmissing-pattern-synonym-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-21">If you would like GHC to check that every pattern synonym has a type signature, use the <a class="reference internal" href="#ghc-flag--Wmissing-pattern-synonym-signatures"><code>-Wmissing-pattern-synonym-signatures</code></a> option. If this option is used in conjunction with <a class="reference internal" href="#ghc-flag--Wmissing-exported-signatures"><code>-Wmissing-exported-signatures</code></a> then only exported pattern synonyms must have a type signature. GHC also reports the inferred type.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-kind-signatures">
<code>-Wmissing-kind-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-22">If you would like GHC to check that every data, type family, type-class definition has a <a class="reference internal" href="exts/poly_kinds.html#standalone-kind-signatures"><span class="std std-ref">standalone kind signature</span></a> or a <a class="reference internal" href="exts/poly_kinds.html#complete-kind-signatures"><span class="std std-ref">CUSK</span></a>, use the <a class="reference internal" href="#ghc-flag--Wmissing-kind-signatures"><code>-Wmissing-kind-signatures</code></a> option. You can specify the kind via <a class="reference internal" href="exts/poly_kinds.html#extension-StandaloneKindSignatures"><code>StandaloneKindSignatures</code></a> or <a class="reference internal" href="exts/poly_kinds.html#extension-CUSKs"><code>CUSKs</code></a>.</p> <p>Note that <a class="reference internal" href="#ghc-flag--Wmissing-kind-signatures"><code>-Wmissing-kind-signatures</code></a> does not warn about associated type families, as GHC considers an associated type family declaration to have a CUSK if its enclosing class has a CUSK. (See <a class="reference internal" href="exts/poly_kinds.html#complete-kind-signatures"><span class="std std-ref">Complete user-supplied kind signatures and polymorphic recursion</span></a> for more on this point.) Therefore, giving the parent class a standalone kind signature or CUSK is sufficient to fix the warning for the class’s associated type families as well.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-exported-pattern-synonym-signatures">
<code>-Wmissing-exported-pattern-synonym-signatures</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-23">If you would like GHC to check that every exported pattern synonym has a type signature, but not check unexported pattern synonyms, use the <a class="reference internal" href="#ghc-flag--Wmissing-exported-pattern-synonym-signatures"><code>-Wmissing-exported-pattern-synonym-signatures</code></a> option. If this option is used in conjunction with <a class="reference internal" href="#ghc-flag--Wmissing-pattern-synonym-signatures"><code>-Wmissing-pattern-synonym-signatures</code></a> then every pattern synonym must have a type signature. As part of the warning GHC also reports the inferred type.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wname-shadowing">
<code>-Wname-shadowing</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-24">This option causes a warning to be emitted whenever an inner-scope value has the same name as an outer-scope value, i.e. the inner value shadows the outer one. This can catch typographical errors that turn into hard-to-find bugs, e.g., in the inadvertent capture of what would be a recursive call in <code>f = ... let f = id in ... f ...</code>.</p> <p>The warning is suppressed for names beginning with an underscore. For example</p> <pre data-language="haskell">f x = do { _ignore &lt;- this; _ignore &lt;- that; return (the other) }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Worphans">
<code>-Worphans</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.4</td> </tr>  </table> <p id="index-25">These flags cause a warning to be emitted whenever the module contains an “orphan” instance declaration or rewrite rule. An instance declaration is an orphan if it appears in a module in which neither the class nor the type being instanced are declared in the same module. A rule is an orphan if it is a rule for a function declared in another module. A module containing any orphans is called an orphan module.</p> <p>The trouble with orphans is that GHC must pro-actively read the interface files for all orphan modules, just in case their instances or rules play a role, whether or not the module’s interface would otherwise be of any use. See <a class="reference internal" href="separate_compilation.html#orphan-modules"><span class="std std-ref">Orphan modules and instance declarations</span></a> for details.</p> <p>The flag <a class="reference internal" href="#ghc-flag--Worphans"><code>-Worphans</code></a> warns about user-written orphan rules or instances.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woverlapping-patterns">
<code>-Woverlapping-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-26">By default, the compiler will warn you if a set of patterns are overlapping, e.g.,</p> <pre data-language="haskell">f :: String -&gt; Int
f []     = 0
f (_:xs) = 1
f "2"    = 2
</pre> <p>where the last pattern match in <code>f</code> won’t ever be reached, as the second pattern overlaps it. More often than not, redundant patterns is a programmer mistake/error, so this option is enabled by default.</p> <p>If the programmer is dead set on keeping a redundant clause, for example to prevent bitrot, they can make use of a guard scrutinising <code>GHC.Exts.considerAccessible</code> to prevent the checker from flagging the parent clause as redundant:</p> <pre data-language="haskell">g :: String -&gt; Int
g []                       = 0
g (_:xs)                   = 1
g "2" | considerAccessible = 2 -- No warning!
</pre> <p>Note that <code>considerAccessible</code> should come as the last statement of the guard in order not to impact the results of the checker. E.g., if you write</p> <pre data-language="haskell">h :: Bool -&gt; Int
h x = case (x, x) of
  (True,  True)  -&gt; 1
  (False, False) -&gt; 2
  (True,  False) | considerAccessible, False &lt;- x -&gt; 3
</pre> <p>The pattern-match checker takes you by your word, will conclude that <code>False &lt;- x</code> might fail and warn that the pattern-match is inexhaustive. Put <code>considerAccessible</code> last to avoid such confusions.</p> <p>Note that due to technical limitations, <code>considerAccessible</code> will not suppress <a class="reference internal" href="#ghc-flag--Winaccessible-code"><code>-Winaccessible-code</code></a> warnings.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Winaccessible-code">
<code>-Winaccessible-code</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p id="index-27">By default, the compiler will warn you if types make a branch inaccessible. This generally requires GADTs or similar extensions.</p> <p>Take, for example, the following program</p> <pre data-language="haskell">{-# LANGUAGE GADTs #-}

data Foo a where
 Foo1 :: Foo Char
 Foo2 :: Foo Int

data TyEquality a b where
        Refl :: TyEquality a a

checkTEQ :: Foo t -&gt; Foo u -&gt; Maybe (TyEquality t u)
checkTEQ x y = error "unimportant"

step2 :: Bool
step2 = case checkTEQ Foo1 Foo2 of
         Just Refl -&gt; True -- Inaccessible code
         Nothing -&gt; False
</pre> <p>The <code>Just Refl</code> case in <code>step2</code> is inaccessible, because in order for <code>checkTEQ</code> to be able to produce a <code>Just</code>, <code>t ~ u</code> must hold, but since we’re passing <code>Foo1</code> and <code>Foo2</code> here, it follows that <code>t ~
Char</code>, and <code>u ~ Int</code>, and thus <code>t ~ u</code> cannot hold.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wstar-is-type">
<code>-Wstar-is-type</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p>The use of <code>*</code> to denote the kind of inhabited types relies on the <a class="reference internal" href="exts/poly_kinds.html#extension-StarIsType"><code>StarIsType</code></a> extension, which in a future release will be turned off by default and then possibly removed. The reasons for this and the deprecation schedule are described in <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0143-remove-star-kind.rst">GHC proposal #143</a>.</p> <p>This warning allows to detect such uses of <code>*</code> before the actual breaking change takes place. The recommended fix is to replace <code>*</code> with <code>Type</code> imported from <code>Data.Kind</code>.</p> <p>Being part of the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wstar-binder">
<code>-Wstar-binder</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.6</td> </tr>  </table> <p>Under <a class="reference internal" href="exts/poly_kinds.html#extension-StarIsType"><code>StarIsType</code></a>, a <code>*</code> in types is not an operator nor even a name, it is special syntax that stands for <code>Data.Kind.Type</code>. This means that an expression like <code>Either * Char</code> is parsed as <code>Either (*)
Char</code> and not <code>(*) Either Char</code>.</p> <p>In binding positions, we have similar parsing rules. Consider the following example</p> <pre data-language="haskell">{-# LANGUAGE TypeOperators, TypeFamilies, StarIsType #-}

type family a + b
type family a * b
</pre> <p>While <code>a + b</code> is parsed as <code>(+) a b</code> and becomes a binding position for the <code>(+)</code> type operator, <code>a * b</code> is parsed as <code>a (*) b</code> and is rejected.</p> <p>As a workaround, we allow to bind <code>(*)</code> in prefix form:</p> <pre data-language="haskell">type family (*) a b
</pre> <p>This is a rather fragile arrangement, as generally a programmer expects <code>(*) a b</code> to be equivalent to <code>a * b</code>. With <a class="reference internal" href="#ghc-flag--Wstar-binder"><code>-Wstar-binder</code></a> we warn when this special treatment of <code>(*)</code> takes place.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wsimplifiable-class-constraints">
<code>-Wsimplifiable-class-constraints</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">on</td> </tr>  </table> <p id="index-28">Warn about class constraints in a type signature that can be simplified using a top-level instance declaration. For example:</p> <pre data-language="haskell">f :: Eq [a] =&gt; a -&gt; a
</pre> <p>Here the <code>Eq [a]</code> in the signature overlaps with the top-level instance for <code>Eq [a]</code>. GHC goes to some efforts to use the former, but if it should use the latter, it would then have an insoluble <code>Eq a</code> constraint. Best avoided by instead writing:</p> <pre data-language="haskell">f :: Eq a =&gt; a -&gt; a
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtabs">
<code>-Wtabs</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8</td> </tr>  </table> <p id="index-29">Have the compiler warn if there are tabs in your source file.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtype-defaults">
<code>-Wtype-defaults</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-30">Have the compiler warn/inform you where in your source the Haskell defaulting mechanism for numeric types kicks in. This is useful information when converting code from a context that assumed one default into one with another, e.g., the ‘default default’ for Haskell 1.4 caused the otherwise unconstrained value <code>1</code> to be given the type <code>Int</code>, whereas Haskell 98 and later defaults it to <code>Integer</code>. This may lead to differences in performance and behaviour, hence the usefulness of being non-silent about this.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmonomorphism-restriction">
<code>-Wmonomorphism-restriction</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.8</td> </tr> <tr>
<th class="field-name">Default:</th>
<td class="field-body">off</td> </tr>  </table> <p id="index-31">Have the compiler warn/inform you where in your source the Haskell Monomorphism Restriction is applied. If applied silently the MR can give rise to unexpected behaviour, so it can be helpful to have an explicit warning that it is being applied.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunsupported-llvm-version">
<code>-Wunsupported-llvm-version</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr>  </table> <p>Warn when using <a class="reference internal" href="phases.html#ghc-flag--fllvm"><code>-fllvm</code></a> with an unsupported version of LLVM.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissed-extra-shared-lib">
<code>-Wmissed-extra-shared-lib</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8</td> </tr>  </table> <p>Warn when GHCi can’t load a shared lib it deduced it should load when loading a package and analyzing the extra-libraries stanza of the target package description.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunticked-promoted-constructors">
<code>-Wunticked-promoted-constructors</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10</td> </tr>  </table> <p id="index-32">Warn if a promoted data constructor is used without a tick preceding its name.</p> <p>For example:</p> <pre data-language="haskell">data Nat = Succ Nat | Zero

data Vec n s where
  Nil  :: Vec Zero a
  Cons :: a -&gt; Vec n a -&gt; Vec (Succ n) a
</pre> <p>Will raise two warnings because <code>Zero</code> and <code>Succ</code> are not written as <code>'Zero</code> and <code>'Succ</code>.</p> <p>This also applies to list literals since 9.4. For example:</p> <pre data-language="haskell">type L = [Int, Char, Bool]
</pre> <p>will raise a warning, because <code>[Int, Char, Bool]</code> is a promoted list which lacks a tick.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-binds">
<code>-Wunused-binds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-33">Report any function definitions (and local bindings) which are unused. An alias for</p> <ul class="simple"> <li><a class="reference internal" href="#ghc-flag--Wunused-top-binds"><code>-Wunused-top-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-local-binds"><code>-Wunused-local-binds</code></a></li> <li><a class="reference internal" href="#ghc-flag--Wunused-pattern-binds"><code>-Wunused-pattern-binds</code></a></li> </ul> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-top-binds">
<code>-Wunused-top-binds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-34">Report any function definitions which are unused.</p> <p>More precisely, warn if a binding brings into scope a variable that is not used, except if the variable’s name starts with an underscore. The “starts-with-underscore” condition provides a way to selectively disable the warning.</p> <p>A variable is regarded as “used” if</p> <ul class="simple"> <li>It is exported, or</li> <li>It appears in the right hand side of a binding that binds at least one used variable that is used</li> </ul> <p>For example:</p> <pre data-language="haskell">module A (f) where
f = let (p,q) = rhs1 in t p  -- No warning: q is unused, but is locally bound
t = rhs3                     -- No warning: f is used, and hence so is t
g = h x                      -- Warning: g unused
h = rhs2                     -- Warning: h is only used in the
                             -- right-hand side of another unused binding
_w = True                    -- No warning: _w starts with an underscore
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-local-binds">
<code>-Wunused-local-binds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-35">Report any local definitions which are unused. For example:</p> <pre data-language="haskell">module A (f) where
f = let (p,q) = rhs1 in t p  -- Warning: q is unused
g = h x                      -- No warning: g is unused, but is a top-level binding
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-pattern-binds">
<code>-Wunused-pattern-binds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-36">Warn if a pattern binding binds no variables at all, unless it is a lone wild-card pattern, or a banged pattern. For example:</p> <pre data-language="haskell">Just _ = rhs3    -- Warning: unused pattern binding
(_, _) = rhs4    -- Warning: unused pattern binding
_  = rhs3        -- No warning: lone wild-card pattern
!() = rhs4       -- No warning: banged pattern; behaves like seq
</pre> <p>In general a lazy pattern binding <code>p = e</code> is a no-op if <code>p</code> does not bind any variables. The motivation for allowing lone wild-card patterns is they are not very different from <code>_v = rhs3</code>, which elicits no warning; and they can be useful to add a type constraint, e.g. <code>_ = x::Int</code>. A banged pattern (see <a class="reference internal" href="exts/strict.html#bang-patterns"><span class="std std-ref">Bang patterns and Strict Haskell</span></a>) is <em>not</em> a no-op, because it forces evaluation, and is useful as an alternative to <code>seq</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-imports">
<code>-Wunused-imports</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-37">Report any modules that are explicitly imported but never used. However, the form <code>import M()</code> is never reported as an unused import, because it is a useful idiom for importing instance declarations, which are anonymous in Haskell.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-matches">
<code>-Wunused-matches</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">at least 5.04</td> </tr>  </table> <p id="index-38">Report all unused variables which arise from term-level pattern matches, including patterns consisting of a single variable. For instance <code>f x y = []</code> would report <code>x</code> and <code>y</code> as unused. The warning is suppressed if the variable name begins with an underscore, thus:</p> <pre data-language="haskell">f _x = True
</pre> <p>Note that <a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a> does not warn about variables which arise from type-level patterns, as found in type family and data family instances. This must be enabled separately through the <a class="reference internal" href="#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> flag.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-do-bind">
<code>-Wunused-do-bind</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12</td> </tr>  </table> <p id="index-39">Report expressions occurring in <code>do</code> and <code>mdo</code> blocks that appear to silently throw information away. For instance <code>do { mapM popInt xs ; return 10 }</code> would report the first statement in the <code>do</code> block as suspicious, as it has the type <code>StackM [Int]</code> and not <code>StackM ()</code>, but that <code>[Int]</code> value is not bound to anything. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</p> <pre data-language="haskell">do { _ &lt;- mapM popInt xs ; return 10 }
</pre> <p>Of course, in this particular situation you can do even better:</p> <pre data-language="haskell">do { mapM_ popInt xs ; return 10 }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-type-patterns">
<code>-Wunused-type-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-40">Report all unused implicitly bound type variables which arise from patterns in type family and data family instances. For instance:</p> <pre data-language="haskell">type instance F x y = []
</pre> <p>would report <code>x</code> and <code>y</code> as unused on the right hand side. The warning is suppressed if the type variable name begins with an underscore, like so:</p> <pre data-language="haskell">type instance F _x _y = []
</pre> <p>When <a class="reference internal" href="exts/explicit_forall.html#extension-ExplicitForAll"><code>ExplicitForAll</code></a> is enabled, explicitly quantified type variables may also be identified as unused. For instance:</p> <pre data-language="haskell">type instance forall x y. F x y = []
</pre> <p>would still report <code>x</code> and <code>y</code> as unused on the right hand side</p> <p>Unlike <a class="reference internal" href="#ghc-flag--Wunused-matches"><code>-Wunused-matches</code></a>, <a class="reference internal" href="#ghc-flag--Wunused-type-patterns"><code>-Wunused-type-patterns</code></a> is not implied by <a class="reference internal" href="#ghc-flag--Wall"><code>-Wall</code></a>. The rationale for this decision is that unlike term-level pattern names, type names are often chosen expressly for documentation purposes, so using underscores in type names can make the documentation harder to read.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-foralls">
<code>-Wunused-foralls</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.0</td> </tr>  </table> <p id="index-41">Report all unused type variables which arise from explicit, user-written <code>forall</code> statements. For instance:</p> <pre data-language="haskell">g :: forall a b c. (b -&gt; b)
</pre> <p>would report <code>a</code> and <code>c</code> as unused.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-record-wildcards">
<code>-Wunused-record-wildcards</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p id="index-42">Report all record wildcards where none of the variables bound implicitly are used. For instance:</p> <pre data-language="haskell">data P = P { x :: Int, y :: Int }

f1 :: P -&gt; Int
f1 P{..} = 1 + 3
</pre> <p>would report that the <code>P{..}</code> match is unused.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wredundant-bang-patterns">
<code>-Wredundant-bang-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr>  </table> <p id="index-43">Report dead bang patterns, where dead bangs are bang patterns that under no circumstances can force a thunk that wasn’t already forced. Dead bangs are a form of redundant bangs. The new check is performed in pattern-match coverage checker along with other checks (namely, redundant and inaccessible RHSs). Given</p> <pre data-language="haskell">f :: Bool -&gt; Int
f True = 1
f !x   = 2
</pre> <p>The bang pattern on <code>!x</code> is dead. By the time the <code>x</code> in the second equation is reached, <code>x</code> will already have been forced due to the first equation (<code>f True = 1</code>). Moreover, there is no way to reach the second equation without going through the first one.</p> <p>Note that <code>-Wredundant-bang-patterns</code> will not warn about dead bangs that appear on a redundant clause. That is because in that case, it is recommended to delete the clause wholly, including its leading pattern match.</p> <p>Dead bang patterns are redundant. But there are bang patterns which are redundant that aren’t dead, for example:</p> <pre data-language="haskell">f !() = 0
</pre> <p>the bang still forces the argument, before we attempt to match on <code>()</code>. But it is redundant with the forcing done by the <code>()</code> match. Currently such redundant bangs are not considered dead, and <code>-Wredundant-bang-patterns</code> will not warn about them.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wredundant-record-wildcards">
<code>-Wredundant-record-wildcards</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p id="index-44">Report all record wildcards where the wild card match binds no patterns. For instance:</p> <pre data-language="haskell">data P = P { x :: Int, y :: Int }

f1 :: P -&gt; Int
f1 P{x,y,..} = x + y
</pre> <p>would report that the <code>P{x, y, ..}</code> match has a redundant use of <code>..</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wredundant-strictness-flags">
<code>-Wredundant-strictness-flags</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4</td> </tr>  </table> <p>Report strictness flags applied to unlifted types. An unlifted type is always strict, and applying a strictness flag has no effect.</p> <p>For example:</p> <pre data-language="haskell">data T = T !Int#
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wwrong-do-bind">
<code>-Wwrong-do-bind</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">6.12</td> </tr>  </table> <p id="index-45">Report expressions occurring in <code>do</code> and <code>mdo</code> blocks that appear to lack a binding. For instance <code>do { return (popInt 10) ; return 10 }</code> would report the first statement in the <code>do</code> block as suspicious, as it has the type <code>StackM (StackM Int)</code> (which consists of two nested applications of the same monad constructor), but which is not then “unpacked” by binding the result. The warning is suppressed by explicitly mentioning in the source code that your program is throwing something away:</p> <pre data-language="haskell">do { _ &lt;- return (popInt 10) ; return 10 }
</pre> <p>For almost all sensible programs this will indicate a bug, and you probably intended to write:</p> <pre data-language="haskell">do { popInt 10 ; return 10 }
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Winline-rule-shadowing">
<code>-Winline-rule-shadowing</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.8</td> </tr>  </table> <p>Warn if a rewrite RULE might fail to fire because the function might be inlined before the rule has a chance to fire. See <a class="reference internal" href="exts/rewrite_rules.html#rules-inline"><span class="std std-ref">How rules interact with INLINE/NOINLINE pragmas</span></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wcpp-undef">
<code>-Wcpp-undef</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p>This flag passes <code>-Wundef</code> to the C pre-processor (if its being used) which causes the pre-processor to warn on uses of the <code>#if</code> directive on undefined identifiers.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunbanged-strict-patterns">
<code>-Wunbanged-strict-patterns</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p>This flag warns whenever you write a pattern that binds a variable whose type is unlifted, and yet the pattern is not a bang pattern nor a bare variable. See <a class="reference internal" href="exts/primitives.html#glasgow-unboxed"><span class="std std-ref">Unboxed types</span></a> for information about unlifted types.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-home-modules">
<code>-Wmissing-home-modules</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.2</td> </tr>  </table> <p>When a module provided by the package currently being compiled (i.e. the “home” package) is imported, but not explicitly listed in command line as a target. Useful for Cabal to ensure GHC won’t pick up modules, not listed neither in <code>exposed-modules</code>, nor in <code>other-modules</code>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wpartial-fields">
<code>-Wpartial-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.4</td> </tr>  </table> <p>The option <a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a> warns about record fields that could fail when accessed via a lacking constructor. The function <code>f</code> below will fail when applied to <code>Bar</code>, so the compiler will emit a warning at its definition when <a class="reference internal" href="#ghc-flag--Wpartial-fields"><code>-Wpartial-fields</code></a> is enabled.</p> <p>The warning is suppressed if the field name begins with an underscore.</p> <pre data-language="haskell">data Foo = Foo { f :: Int } | Bar
</pre> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunused-packages">
<code>-Wunused-packages</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.10</td> </tr>  </table> <p>The option <a class="reference internal" href="#ghc-flag--Wunused-packages"><code>-Wunused-packages</code></a> warns about packages, specified on command line via <a class="reference internal" href="#"><code>-package ⟨pkg⟩</code></a> or <a class="reference internal" href="#"><code>-package-id ⟨unit-id⟩</code></a>, but were not needed during compilation. If the warning fires it means the specified package wasn’t needed for compilation.</p> <p>This warning interacts poorly with GHCi because most invocations will pass a large number of <code>-package</code> arguments on the initial load. Therefore if you modify the targets using <code>:load</code> or <code>:cd</code> then the warning will be silently disabled if it’s enabled (see <a class="reference external" href="https://gitlab.haskell.org/ghc/ghc/issues/21110">#21110</a>).</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Winvalid-haddock">
<code>-Winvalid-haddock</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.0</td> </tr>  </table> <p>When the <code>-haddock</code> option is enabled, GHC collects documentation comments and associates them with declarations, function arguments, data constructors, and other syntactic elements. Documentation comments in invalid positions are discarded:</p> <pre data-language="haskell">myValue =
  -- | Invalid (discarded) comment in an expression
  2 + 2
</pre> <p>This warning informs you about discarded documentation comments. It has no effect when <a class="reference internal" href="using.html#ghc-flag--haddock"><code>-haddock</code></a> is disabled.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woperator-whitespace-ext-conflict">
<code>-Woperator-whitespace-ext-conflict</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr>  </table> <p>When <a class="reference internal" href="exts/template_haskell.html#extension-TemplateHaskell"><code>TemplateHaskell</code></a> is enabled, <code>f $x</code> is parsed as <code>f</code> applied to an untyped splice. But when the extension is disabled, the expression is parsed as a use of the <code>$</code> infix operator.</p> <p>To make it easy to read <code>f $x</code> without checking the enabled extensions, one could rewrite it as <code>f $ x</code>, which is what this warning suggests.</p> <p>Currently, it detects the following cases:</p> <ul class="simple"> <li>
<code>$x</code> could mean an untyped splice under <a class="reference internal" href="exts/template_haskell.html#extension-TemplateHaskell"><code>TemplateHaskell</code></a>
</li> <li>
<code>$$x</code> could mean a typed splice under <a class="reference internal" href="exts/template_haskell.html#extension-TemplateHaskell"><code>TemplateHaskell</code></a>
</li> <li>
<code>%m</code> could mean a multiplicity annotation under <a class="reference internal" href="exts/linear_types.html#extension-LinearTypes"><code>LinearTypes</code></a>
</li> </ul> <p>It only covers extensions that currently exist. If you want to enforce a stricter policy and always require whitespace around all infix operators, use <a class="reference internal" href="#ghc-flag--Woperator-whitespace"><code>-Woperator-whitespace</code></a>.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Woperator-whitespace">
<code>-Woperator-whitespace</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr>  </table> <p>There are four types of infix operator occurrences, as defined by <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0229-whitespace-bang-patterns.rst">GHC Proposal #229</a>:</p> <pre data-language="haskell">a ! b   -- a loose infix occurrence
a!b     -- a tight infix occurrence
a !b    -- a prefix occurrence
a! b    -- a suffix occurrence
</pre> <p>A loose infix occurrence of any operator is always parsed as an infix operator, but other occurrence types may be assigned a special meaning. For example, a prefix <code>!</code> denotes a bang pattern, and a prefix <code>$</code> denotes a <a class="reference internal" href="exts/template_haskell.html#extension-TemplateHaskell"><code>TemplateHaskell</code></a> splice.</p> <p>This warning encourages the use of loose infix occurrences of all infix operators, to prevent possible conflicts with future language extensions.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wauto-orphans">
<code>-Wauto-orphans</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.4</td> </tr>  </table> <p>Does nothing.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wmissing-space-after-bang">
<code>-Wmissing-space-after-bang</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">8.8</td> </tr>  </table> <p>Does nothing.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wderiving-typeable">
<code>-Wderiving-typeable</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">7.10</td> </tr>  </table> <p>This flag warns when <code>Typeable</code> is listed in a deriving clause or derived with <a class="reference internal" href="exts/standalone_deriving.html#extension-StandaloneDeriving"><code>StandaloneDeriving</code></a>.</p> <p>Since GHC 7.10, <code>Typeable</code> is automatically derived for all types. Thus, deriving <code>Typeable</code> yourself is redundant.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wambiguous-fields">
<code>-Wambiguous-fields</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.2</td> </tr>  </table> <p>When <a class="reference internal" href="exts/duplicate_record_fields.html#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> is enabled, the option <a class="reference internal" href="#ghc-flag--Wambiguous-fields"><code>-Wambiguous-fields</code></a> warns about occurrences of fields in selectors or updates that depend on the deprecated mechanism for type-directed disambiguation. This mechanism will be removed in a future GHC release, at which point these occurrences will be rejected as ambiguous. See the proposal <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0366-no-ambiguous-field-access.rst">DuplicateRecordFields without ambiguous field access</a> and the documentation on <a class="reference internal" href="exts/duplicate_record_fields.html#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> for further details.</p> <p>This warning has no effect when <a class="reference internal" href="exts/duplicate_record_fields.html#extension-DuplicateRecordFields"><code>DuplicateRecordFields</code></a> is disabled.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wforall-identifier">
<code>-Wforall-identifier</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4</td> </tr>  </table> <p>In a future GHC release, <code>forall</code> will become a keyword regardless of enabled extensions. This will make definitions such as the following illegal:</p> <pre data-language="haskell">-- from constraints-0.13
forall :: forall p. (forall a. Dict (p a)) -&gt; Dict (Forall p)
forall d = ...
</pre> <p>Library authors are advised to use a different identifier, such as <code>forAll</code>, <code>forall_</code>, or <code>for_all</code>:</p> <pre data-language="haskell">forall_ :: forall p. (forall a. Dict (p a)) -&gt; Dict (Forall p)
forall_ d = ...
</pre> <p>The warning is only triggered at definition sites where it can be addressed by using a different name.</p> <p>Users of a library that exports <code>forall</code> as an identifier cannot address the issue themselves, so the warning is not reported at use sites.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wunicode-bidirectional-format-characters">
<code>-Wunicode-bidirectional-format-characters</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.0.2</td> </tr>  </table> <p>Explicit unicode bidirectional formatting characters can cause source code to be rendered misleadingly in many viewers. We warn if any such character is present in the source.</p> <p>Specifically, the characters disallowed by this warning are those which are a part of the ‘Explicit Formatting` category of the <a class="reference external" href="https://www.unicode.org/reports/tr9/#Bidirectional_Character_Types">Unicode Bidirectional Character Type Listing</a></p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wgadt-mono-local-binds">
<code>-Wgadt-mono-local-binds</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4.1</td> </tr>  </table> <p>This warning is triggered on pattern matching involving GADTs, if <a class="reference internal" href="exts/let_generalisation.html#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> is disabled. Type inference can be fragile in this case.</p> <p>See the <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/outsideinx-modular-type-inference-with-local-assumptions/">OutsideIn(X)</a> paper (section 4.2) and <a class="reference internal" href="exts/let_generalisation.html#mono-local-binds"><span class="std std-ref">Let-generalisation</span></a> for more details.</p> <p>To resolve this warning, you can enable <a class="reference internal" href="exts/let_generalisation.html#extension-MonoLocalBinds"><code>MonoLocalBinds</code></a> or an extension implying it (<a class="reference internal" href="exts/gadt.html#extension-GADTs"><code>GADTs</code></a> or <a class="reference internal" href="exts/type_families.html#extension-TypeFamilies"><code>TypeFamilies</code></a>).</p> <p>The warning is also triggered when matching on GADT-like pattern synonyms (i.e. pattern synonyms containing equalities in provided constraints).</p> <p>In previous versions of GHC (9.2 and below), it was an error to pattern match on a GADT if neither <a class="reference internal" href="exts/gadt.html#extension-GADTs"><code>GADTs</code></a> nor <a class="reference internal" href="exts/type_families.html#extension-TypeFamilies"><code>TypeFamilies</code></a> were enabled.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtype-equality-out-of-scope">
<code>-Wtype-equality-out-of-scope</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4.1</td> </tr>  </table> <p>In accordance with <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0371-non-magical-eq.md">GHC Proposal #371</a>, the type equality syntax <code>a ~ b</code> is no longer built-in. Instead, <code>~</code> is a regular type operator that can be imported from <code>Data.Type.Equality</code> or <code>Prelude</code>.</p> <p>To minimize breakage, a compatibility fallback is provided: whenever <code>~</code> is used but is not in scope, the compiler assumes that it stands for a type equality constraint. The warning is triggered by any code that relies on this fallback. It can be addressed by bringing <code>~</code> into scope explicitly.</p> <p>The likely culprit is that you use <a class="reference internal" href="exts/rebindable_syntax.html#extension-NoImplicitPrelude"><code>NoImplicitPrelude</code></a> and a custom Prelude. In this case, consider updating your custom Prelude to re-export <code>~</code> from <code>Data.Type.Equality</code>.</p> <p>Being part of the <a class="reference internal" href="#ghc-flag--Wno-compat"><code>-Wcompat</code></a> option group, this warning is off by default, but will be switched on in a future GHC release.</p> </dd>
</dl> <dl class="ghc-flag"> <dt id="ghc-flag--Wtype-equality-requires-operators">
<code>-Wtype-equality-requires-operators</code> </dt> <dd>
<table class="docutils field-list" frame="void" rules="none"> <col class="field-name"> <col class="field-body">  <tr>
<th class="field-name">Since:</th>
<td class="field-body">9.4.1</td> </tr>  </table> <p>In accordance with <a class="reference external" href="https://github.com/ghc-proposals/ghc-proposals/blob/master/proposals/0371-non-magical-eq.md">GHC Proposal #371</a>, the type equality syntax <code>a ~ b</code> is no longer built-in. Instead, <code>~</code> is a regular type operator that requires the <a class="reference internal" href="exts/type_operators.html#extension-TypeOperators"><code>TypeOperators</code></a> extension.</p> <p>To minimize breakage, <code>~</code> specifically (unlike other type operators) can be used even when <a class="reference internal" href="exts/type_operators.html#extension-TypeOperators"><code>TypeOperators</code></a> is disabled. The warning is triggered whenever this happens, and can be addressed by enabling the extension.</p> </dd>
</dl> <p>If you’re feeling really paranoid, the <a class="reference internal" href="debugging.html#ghc-flag--dcore-lint"><code>-dcore-lint</code></a> option is a good choice. It turns on heavyweight intra-pass sanity-checking within GHC. (It checks GHC’s sanity, not yours.)</p>  </div> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2002&ndash;2007 The University Court of the University of Glasgow. All rights reserved.<br>Licensed under the Glasgow Haskell Compiler License.<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/using-warnings.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/users_guide/using-warnings.html</a>
  </p>
</div>
