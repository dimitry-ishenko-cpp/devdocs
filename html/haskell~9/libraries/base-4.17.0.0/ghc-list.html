<h1 class="caption">GHC.List</h1>
<div class="_haskell-api">
<table class="info">
<tr>
<th valign="top">Copyright</th>
<td>(c) The University of Glasgow 1994-2002</td>
</tr>
<tr>
<th>License</th>
<td>see libraries/base/LICENSE</td>
</tr>
<tr>
<th>Maintainer</th>
<td>cvs-ghc@haskell.org</td>
</tr>
<tr>
<th>Stability</th>
<td>internal</td>
</tr>
<tr>
<th>Portability</th>
<td>non-portable (GHC Extensions)</td>
</tr>
<tr>
<th>Safe Haskell</th>
<td>Trustworthy</td>
</tr>
<tr>
<th>Language</th>
<td>Haskell2010</td>
</tr>
</table>
<div id="table-of-contents"><div id="contents-list">
<h4 class="caption" onclick="window.scrollTo(0,0)">Contents</h4>
<ul><li><a href="#g:1">GHC List fusion</a></li></ul>
</div></div>
<div id="description">
<h4 class="caption">Description</h4>
<p>The List data type and its operations</p>
</div>
<p class="src"><a id="v:foldr" class="def">foldr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#foldr" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>, applied to a binary operator, a starting value (typically the right-identity of the operator), and a list, reduces the list using the binary operator, from right to left:</p>
<pre>foldr f z [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn `f` z)...)</pre>
<p class="src"><a id="v:foldr-39-" class="def">foldr'</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldr%27" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:foldr-39-" title="GHC.List">foldr'</a></code> is a variant of <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code> that begins list reduction from the last element and evaluates the accumulator strictly as it unwinds the stack back to the beginning of the list. The input list <em>must</em> be finite, otherwise <code><a href="ghc-list.html#v:foldr-39-" title="GHC.List">foldr'</a></code> runs out of space (<em>diverges</em>).</p>
<p>Note that if the function that combines the accumulated value with each element is strict in the accumulator, other than a possible improvement in the constant factor, you get the same <span class="mathjax">\(\mathcal{O}(n)\)</span> space cost as with just <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>.</p>
<p>If you want a strict right fold in constant space, you need a structure that supports faster than <span class="mathjax">\(\mathcal{O}(n)\)</span> access to the right-most element, such as <code>Seq</code> from the <code>containers</code> package.</p>
<p>Use of this function is a hint that the <code>[]</code> structure may be a poor fit for the task at hand. If the order in which the elements are combined is not important, use <code><a href="ghc-list.html#v:foldl-39-" title="GHC.List">foldl'</a></code> instead.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr' (+) [1..4]  -- Use foldl' instead!
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldr' (&amp;&amp;) [True, False, True, True] -- Use foldr instead!
</strong>False
&gt;&gt;&gt; <strong class="userinput">foldr' (||) [False, False, True, True] -- Use foldr instead!
</strong>True
</pre>
<p class="src"><a id="v:foldr1" class="def">foldr1</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldr1" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:foldr1" title="GHC.List">foldr1</a></code> is a variant of <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code> that has no starting value argument, and thus must be applied to non-empty lists. Note that unlike <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>, the accumulated value must be of the same type as the list elements.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldr1 (+) [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldr1 (+) []
</strong>*** Exception: Prelude.foldr1: empty list
&gt;&gt;&gt; <strong class="userinput">foldr1 (-) [1..4]
</strong>-2
&gt;&gt;&gt; <strong class="userinput">foldr1 (&amp;&amp;) [True, False, True, True]
</strong>False
&gt;&gt;&gt; <strong class="userinput">foldr1 (||) [False, False, True, True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">force $ foldr1 (+) [1..]
</strong>*** Exception: stack overflow
</pre>
<p class="src"><a id="v:foldl" class="def">foldl</a> :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>, applied to a binary operator, a starting value (typically the left-identity of the operator), and a list, reduces the list using the binary operator, from left to right:</p>
<pre>foldl f z [x1, x2, ..., xn] == (...((z `f` x1) `f` x2) `f`...) `f` xn</pre>
<p>The list must be finite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl (+) 0 [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldl (+) 42 []
</strong>42
&gt;&gt;&gt; <strong class="userinput">foldl (-) 100 [1..4]
</strong>90
&gt;&gt;&gt; <strong class="userinput">foldl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>"dcbafoo"
&gt;&gt;&gt; <strong class="userinput">foldl (+) 0 [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:foldl-39-" class="def">foldl'</a> :: forall a b. (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl%27" class="link">Source</a> </p>
<p>A strict version of <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>.</p>
<p class="src"><a id="v:foldl1" class="def">foldl1</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl1" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:foldl1" title="GHC.List">foldl1</a></code> is a variant of <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code> that has no starting value argument, and thus must be applied to non-empty lists. Note that unlike <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>, the accumulated value must be of the same type as the list elements.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..4]
</strong>10
&gt;&gt;&gt; <strong class="userinput">foldl1 (+) []
</strong>*** Exception: Prelude.foldl1: empty list
&gt;&gt;&gt; <strong class="userinput">foldl1 (-) [1..4]
</strong>-8
&gt;&gt;&gt; <strong class="userinput">foldl1 (&amp;&amp;) [True, False, True, True]
</strong>False
&gt;&gt;&gt; <strong class="userinput">foldl1 (||) [False, False, True, True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">foldl1 (+) [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:null" class="def">null</a> :: [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#null" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Test whether a list is empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">null []
</strong>True
&gt;&gt;&gt; <strong class="userinput">null [1]
</strong>False
&gt;&gt;&gt; <strong class="userinput">null [1..]
</strong>False
</pre>
<p class="src"><a id="v:length" class="def">length</a> :: [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#length" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:length" title="GHC.List">length</a></code> returns the length of a finite list as an <code><a href="data-int.html#t:Int" title="Data.Int">Int</a></code>. It is an instance of the more general <code><a href="data-list.html#v:genericLength" title="Data.List">genericLength</a></code>, the result type of which may be any kind of number.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">length []
</strong>0
&gt;&gt;&gt; <strong class="userinput">length ['a', 'b', 'c']
</strong>3
&gt;&gt;&gt; <strong class="userinput">length [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:elem" class="def">elem</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#elem" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:elem" title="GHC.List">elem</a></code> is the list membership predicate, usually written in infix form, e.g., <code>x `elem` xs</code>. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from an element equal to <code>x</code> found at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `elem` []
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1,2,3,4,5]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `elem` [1..]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `elem` [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:notElem" class="def">notElem</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <span class="fixity">infix 4</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#notElem" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:notElem" title="GHC.List">notElem</a></code> is the negation of <code><a href="ghc-list.html#v:elem" title="GHC.List">elem</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">3 `notElem` []
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2]
</strong>True
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1,2,3,4,5]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [1..]
</strong>False
&gt;&gt;&gt; <strong class="userinput">3 `notElem` [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:maximum" class="def">maximum</a> :: (<a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a>) =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#maximum" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:maximum" title="GHC.List">maximum</a></code> returns the maximum value from a list, which must be non-empty, finite, and of an ordered type. It is a special case of <code><a href="data-list.html#v:maximumBy" title="Data.List">maximumBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">maximum []
</strong>*** Exception: Prelude.maximum: empty list
&gt;&gt;&gt; <strong class="userinput">maximum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">maximum [55, -12, 7, 0, -89]
</strong>55
&gt;&gt;&gt; <strong class="userinput">maximum [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:minimum" class="def">minimum</a> :: (<a href="data-ord.html#t:Ord" title="Data.Ord">Ord</a> a, <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a>) =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#minimum" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:minimum" title="GHC.List">minimum</a></code> returns the minimum value from a list, which must be non-empty, finite, and of an ordered type. It is a special case of <code><a href="data-list.html#v:minimumBy" title="Data.List">minimumBy</a></code>, which allows the programmer to supply their own comparison function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">minimum []
</strong>*** Exception: Prelude.minimum: empty list
&gt;&gt;&gt; <strong class="userinput">minimum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">minimum [55, -12, 7, 0, -89]
</strong>-89
&gt;&gt;&gt; <strong class="userinput">minimum [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:sum" class="def">sum</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#sum" class="link">Source</a> </p>
<p>The <code><a href="ghc-list.html#v:sum" title="GHC.List">sum</a></code> function computes the sum of a finite list of numbers.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">sum []
</strong>0
&gt;&gt;&gt; <strong class="userinput">sum [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">sum [1..10]
</strong>55
&gt;&gt;&gt; <strong class="userinput">sum [4.1, 2.0, 1.7]
</strong>7.8
&gt;&gt;&gt; <strong class="userinput">sum [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:product" class="def">product</a> :: <a href="prelude.html#t:Num" title="Prelude">Num</a> a =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#product" class="link">Source</a> </p>
<p>The <code><a href="ghc-list.html#v:product" title="GHC.List">product</a></code> function computes the product of a finite list of numbers.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">product []
</strong>1
&gt;&gt;&gt; <strong class="userinput">product [42]
</strong>42
&gt;&gt;&gt; <strong class="userinput">product [1..10]
</strong>3628800
&gt;&gt;&gt; <strong class="userinput">product [4.1, 2.0, 1.7]
</strong>13.939999999999998
&gt;&gt;&gt; <strong class="userinput">product [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:and" class="def">and</a> :: [<a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#and" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:and" title="GHC.List">and</a></code> returns the conjunction of a Boolean list. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the list must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">and []
</strong>True
&gt;&gt;&gt; <strong class="userinput">and [True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">and [False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">and [True, True, False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">and (False : repeat True) -- Infinite list [False,True,True,True,True,True,True...
</strong>False
&gt;&gt;&gt; <strong class="userinput">and (repeat True)
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:or" class="def">or</a> :: [<a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#or" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:or" title="GHC.List">or</a></code> returns the disjunction of a Boolean list. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">or []
</strong>False
&gt;&gt;&gt; <strong class="userinput">or [True]
</strong>True
&gt;&gt;&gt; <strong class="userinput">or [False]
</strong>False
&gt;&gt;&gt; <strong class="userinput">or [True, True, False]
</strong>True
&gt;&gt;&gt; <strong class="userinput">or (True : repeat False) -- Infinite list [True,False,False,False,False,False,False...
</strong>True
&gt;&gt;&gt; <strong class="userinput">or (repeat False)
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:any" class="def">any</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#any" class="link">Source</a> </p>
<p>Applied to a predicate and a list, <code><a href="ghc-list.html#v:any" title="GHC.List">any</a></code> determines if any element of the list satisfies the predicate. For the result to be <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, the list must be finite; <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, however, results from a <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code> value for the predicate applied to an element at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) []
</strong>False
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1,2,3,4,5]
</strong>True
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [1..]
</strong>True
&gt;&gt;&gt; <strong class="userinput">any (&gt; 3) [0, -1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:all" class="def">all</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#all" class="link">Source</a> </p>
<p>Applied to a predicate and a list, <code><a href="ghc-list.html#v:all" title="GHC.List">all</a></code> determines if all elements of the list satisfy the predicate. For the result to be <code><a href="data-bool.html#v:True" title="Data.Bool">True</a></code>, the list must be finite; <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code>, however, results from a <code><a href="data-bool.html#v:False" title="Data.Bool">False</a></code> value for the predicate applied to an element at a finite index of a finite or infinite list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) []
</strong>True
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1,2,3,4,5]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [1..]
</strong>False
&gt;&gt;&gt; <strong class="userinput">all (&gt; 3) [4..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:foldl1-39-" class="def">foldl1'</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; (a -&gt; a -&gt; a) -&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#foldl1%27" class="link">Source</a> </p>
<p>A strict version of <code><a href="ghc-list.html#v:foldl1" title="GHC.List">foldl1</a></code>.</p>
<p class="src"><a id="v:concat" class="def">concat</a> :: [[a]] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#concat" class="link">Source</a> </p>
<p>Concatenate a list of lists.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concat []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">concat [[42]]
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">concat [[1,2,3], [4,5], [6], []]
</strong>[1,2,3,4,5,6]
</pre>
<p class="src"><a id="v:concatMap" class="def">concatMap</a> :: (a -&gt; [b]) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#concatMap" class="link">Source</a> </p>
<p>Map a function returning a list over a list and concatenate the results. <code><a href="ghc-list.html#v:concatMap" title="GHC.List">concatMap</a></code> can be seen as the composition of <code><a href="ghc-list.html#v:concat" title="GHC.List">concat</a></code> and <code><a href="ghc-list.html#v:map" title="GHC.List">map</a></code>.</p>
<pre>concatMap f xs == (concat . map f) xs</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">concatMap (\i -&gt; [-i,i]) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">concatMap (\i -&gt; [-i,i]) [1,2,3]
</strong>[-1,1,-2,2,-3,3]
</pre>
<p class="src"><a id="v:map" class="def">map</a> :: (a -&gt; b) -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#map" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:map" title="GHC.List">map</a></code> <code>f xs</code> is the list obtained by applying <code>f</code> to each element of <code>xs</code>, i.e.,</p>
<pre>map f [x1, x2, ..., xn] == [f x1, f x2, ..., f xn]
map f [x1, x2, ...] == [f x1, f x2, ...]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">map (+1) [1, 2, 3]
</strong>[2,3,4]
</pre>
<p class="src"><a id="v:-43--43-" class="def">(++)</a> :: [a] -&gt; [a] -&gt; [a] <span class="fixity">infixr 5</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#%2B%2B" class="link">Source</a> </p>
<p>Append two lists, i.e.,</p>
<pre>[x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]
[x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]</pre>
<p>If the first list is not finite, the result is the first list.</p>
<p>WARNING: This function takes linear time in the number of elements of the first list.</p>
<p class="src"><a id="v:filter" class="def">filter</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#filter" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:filter" title="GHC.List">filter</a></code>, applied to a predicate and a list, returns the list of those elements that satisfy the predicate; i.e.,</p>
<pre>filter p xs = [ x | x &lt;- xs, p x]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">filter odd [1, 2, 3]
</strong>[1,3]
</pre>
<p class="src"><a id="v:lookup" class="def">lookup</a> :: <a href="data-eq.html#t:Eq" title="Data.Eq">Eq</a> a =&gt; a -&gt; [(a, b)] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> b <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#lookup" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:lookup" title="GHC.List">lookup</a></code> <code>key assocs</code> looks up a key in an association list.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">lookup 2 []
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first")]
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">lookup 2 [(1, "first"), (2, "second"), (3, "third")]
</strong>Just "second"
</pre>
<p class="src"><a id="v:head" class="def">head</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#head" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the first element of a list, which must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">head [1, 2, 3]
</strong>1
&gt;&gt;&gt; <strong class="userinput">head [1..]
</strong>1
&gt;&gt;&gt; <strong class="userinput">head []
</strong>*** Exception: Prelude.head: empty list
</pre>
<p>WARNING: This function is partial. You can use case-matching, <code><a href="ghc-list.html#v:uncons" title="GHC.List">uncons</a></code> or <code><a href="data-maybe.html#v:listToMaybe" title="Data.Maybe">listToMaybe</a></code> instead.</p>
<p class="src"><a id="v:last" class="def">last</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#last" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Extract the last element of a list, which must be finite and non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">last [1, 2, 3]
</strong>3
&gt;&gt;&gt; <strong class="userinput">last [1..]
</strong>* Hangs forever *
&gt;&gt;&gt; <strong class="userinput">last []
</strong>*** Exception: Prelude.last: empty list
</pre>
<p>WARNING: This function is partial. You can use <code><a href="ghc-list.html#v:reverse" title="GHC.List">reverse</a></code> with case-matching, <code><a href="ghc-list.html#v:uncons" title="GHC.List">uncons</a></code> or <code><a href="data-maybe.html#v:listToMaybe" title="Data.Maybe">listToMaybe</a></code> instead.</p>
<p class="src"><a id="v:tail" class="def">tail</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#tail" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Extract the elements after the head of a list, which must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">tail [1, 2, 3]
</strong>[2,3]
&gt;&gt;&gt; <strong class="userinput">tail [1]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">tail []
</strong>*** Exception: Prelude.tail: empty list
</pre>
<p>WARNING: This function is partial. You can use case-matching or <code><a href="ghc-list.html#v:uncons" title="GHC.List">uncons</a></code> instead.</p>
<p class="src"><a id="v:init" class="def">init</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#init" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. Return all the elements of a list except the last one. The list must be non-empty.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">init [1, 2, 3]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">init [1]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">init []
</strong>*** Exception: Prelude.init: empty list
</pre>
<p>WARNING: This function is partial. You can use <code><a href="ghc-list.html#v:reverse" title="GHC.List">reverse</a></code> with case-matching or <code><a href="ghc-list.html#v:uncons" title="GHC.List">uncons</a></code> instead.</p>
<p class="src"><a id="v:uncons" class="def">uncons</a> :: [a] -&gt; <a href="data-maybe.html#t:Maybe" title="Data.Maybe">Maybe</a> (a, [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#uncons" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(1)\)</span>. Decompose a list into its head and tail.</p>
<ul>
<li>If the list is empty, returns <code><a href="data-maybe.html#v:Nothing" title="Data.Maybe">Nothing</a></code>.</li>
<li>If the list is non-empty, returns <code><a href="data-maybe.html#v:Just" title="Data.Maybe">Just</a> (x, xs)</code>, where <code>x</code> is the head of the list and <code>xs</code> its tail.</li>
</ul>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">uncons []
</strong>Nothing
&gt;&gt;&gt; <strong class="userinput">uncons [1]
</strong>Just (1,[])
&gt;&gt;&gt; <strong class="userinput">uncons [1, 2, 3]
</strong>Just (1,[2,3])
</pre>
<p><span class="version">Since: base-4.8.0.0</span></p>
<p class="src"><a id="v:-33--33-" class="def">(!!)</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a <span class="fixity">infixl 9</span> <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#%21%21" class="link">Source</a> </p>
<p>List index (subscript) operator, starting from 0. It is an instance of the more general <code><a href="data-list.html#v:genericIndex" title="Data.List">genericIndex</a></code>, which takes an index of any integral type.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 0
</strong>'a'
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 2
</strong>'c'
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! 3
</strong>*** Exception: Prelude.!!: index too large
&gt;&gt;&gt; <strong class="userinput">['a', 'b', 'c'] !! (-1)
</strong>*** Exception: Prelude.!!: negative index
</pre>
<p>WARNING: This function is partial. You can use &lt;<code>atMay</code> <a href="#">https://hackage.haskell.org/package/safe-0.3.19/docs/Safe.html#v:atMay&gt;</a> instead.</p>
<p class="src"><a id="v:scanl" class="def">scanl</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:scanl" title="GHC.List">scanl</a></code> is similar to <code><a href="ghc-list.html#v:foldl" title="GHC.List">foldl</a></code>, but returns a list of successive reduced values from the left:</p>
<pre>scanl f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]</pre>
<p>Note that</p>
<pre>last (scanl f z xs) == foldl f z xs</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl (+) 0 [1..4]
</strong>[0,1,3,6,10]
&gt;&gt;&gt; <strong class="userinput">scanl (+) 42 []
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">scanl (-) 100 [1..4]
</strong>[100,99,97,94,90]
&gt;&gt;&gt; <strong class="userinput">scanl (\reversedString nextChar -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["foo","afoo","bafoo","cbafoo","dcbafoo"]
&gt;&gt;&gt; <strong class="userinput">scanl (+) 0 [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:scanl1" class="def">scanl1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:scanl1" title="GHC.List">scanl1</a></code> is a variant of <code><a href="ghc-list.html#v:scanl" title="GHC.List">scanl</a></code> that has no starting value argument:</p>
<pre>scanl1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanl1 (+) [1..4]
</strong>[1,3,6,10]
&gt;&gt;&gt; <strong class="userinput">scanl1 (+) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">scanl1 (-) [1..4]
</strong>[1,-1,-4,-8]
&gt;&gt;&gt; <strong class="userinput">scanl1 (&amp;&amp;) [True, False, True, True]
</strong>[True,False,False,False]
&gt;&gt;&gt; <strong class="userinput">scanl1 (||) [False, False, True, True]
</strong>[False,False,True,True]
&gt;&gt;&gt; <strong class="userinput">scanl1 (+) [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:scanl-39-" class="def">scanl'</a> :: (b -&gt; a -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanl%27" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. A strict version of <code><a href="ghc-list.html#v:scanl" title="GHC.List">scanl</a></code>.</p>
<p class="src"><a id="v:scanr" class="def">scanr</a> :: (a -&gt; b -&gt; b) -&gt; b -&gt; [a] -&gt; [b] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanr" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:scanr" title="GHC.List">scanr</a></code> is the right-to-left dual of <code><a href="ghc-list.html#v:scanl" title="GHC.List">scanl</a></code>. Note that the order of parameters on the accumulating function are reversed compared to <code><a href="ghc-list.html#v:scanl" title="GHC.List">scanl</a></code>. Also note that</p>
<pre>head (scanr f z xs) == foldr f z xs.</pre>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr (+) 0 [1..4]
</strong>[10,9,7,4,0]
&gt;&gt;&gt; <strong class="userinput">scanr (+) 42 []
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">scanr (-) 100 [1..4]
</strong>[98,-97,99,-96,100]
&gt;&gt;&gt; <strong class="userinput">scanr (\nextChar reversedString -&gt; nextChar : reversedString) "foo" ['a', 'b', 'c', 'd']
</strong>["abcdfoo","bcdfoo","cdfoo","dfoo","foo"]
&gt;&gt;&gt; <strong class="userinput">force $ scanr (+) 0 [1..]
</strong>*** Exception: stack overflow
</pre>
<p class="src"><a id="v:scanr1" class="def">scanr1</a> :: (a -&gt; a -&gt; a) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#scanr1" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(n)\)</span>. <code><a href="ghc-list.html#v:scanr1" title="GHC.List">scanr1</a></code> is a variant of <code><a href="ghc-list.html#v:scanr" title="GHC.List">scanr</a></code> that has no starting value argument.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">scanr1 (+) [1..4]
</strong>[10,9,7,4]
&gt;&gt;&gt; <strong class="userinput">scanr1 (+) []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">scanr1 (-) [1..4]
</strong>[-2,3,-1,4]
&gt;&gt;&gt; <strong class="userinput">scanr1 (&amp;&amp;) [True, False, True, True]
</strong>[False,False,True,True]
&gt;&gt;&gt; <strong class="userinput">scanr1 (||) [True, True, False, False]
</strong>[True,True,False,False]
&gt;&gt;&gt; <strong class="userinput">force $ scanr1 (+) [1..]
</strong>*** Exception: stack overflow
</pre>
<p class="src"><a id="v:iterate" class="def">iterate</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#iterate" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:iterate" title="GHC.List">iterate</a></code> <code>f x</code> returns an infinite list of repeated applications of <code>f</code> to <code>x</code>:</p>
<pre>iterate f x == [x, f x, f (f x), ...]</pre>
<p>Note that <code><a href="ghc-list.html#v:iterate" title="GHC.List">iterate</a></code> is lazy, potentially leading to thunk build-up if the consumer doesn't force each iterate. See <code><a href="ghc-list.html#v:iterate-39-" title="GHC.List">iterate'</a></code> for a strict variant of this function.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate not True
</strong>[True,False,True,False...
&gt;&gt;&gt; <strong class="userinput">take 10 $ iterate (+3) 42
</strong>[42,45,48,51,54,57,60,63...
</pre>
<p class="src"><a id="v:iterate-39-" class="def">iterate'</a> :: (a -&gt; a) -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#iterate%27" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:iterate-39-" title="GHC.List">iterate'</a></code> is the strict version of <code><a href="ghc-list.html#v:iterate" title="GHC.List">iterate</a></code>.</p>
<p>It forces the result of each application of the function to weak head normal form (WHNF) before proceeding.</p>
<p class="src"><a id="v:repeat" class="def">repeat</a> :: a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#repeat" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:repeat" title="GHC.List">repeat</a></code> <code>x</code> is an infinite list, with <code>x</code> the value of every element.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 20 $ repeat 17
</strong>[17,17,17,17,17,17,17,17,17...
</pre>
<p class="src"><a id="v:replicate" class="def">replicate</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; a -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#replicate" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:replicate" title="GHC.List">replicate</a></code> <code>n x</code> is a list of length <code>n</code> with <code>x</code> the value of every element. It is an instance of the more general <code><a href="data-list.html#v:genericReplicate" title="Data.List">genericReplicate</a></code>, in which <code>n</code> may be of any integral type.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">replicate 0 True
</strong>[]
&gt;&gt;&gt; <strong class="userinput">replicate (-1) True
</strong>[]
&gt;&gt;&gt; <strong class="userinput">replicate 4 True
</strong>[True,True,True,True]
</pre>
<p class="src"><a id="v:cycle" class="def">cycle</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#cycle" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:cycle" title="GHC.List">cycle</a></code> ties a finite list into a circular one, or equivalently, the infinite repetition of the original list. It is the identity on infinite lists.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">cycle []
</strong>*** Exception: Prelude.cycle: empty list
&gt;&gt;&gt; <strong class="userinput">take 20 $ cycle [42]
</strong>[42,42,42,42,42,42,42,42,42,42...
&gt;&gt;&gt; <strong class="userinput">take 20 $ cycle [2, 5, 7]
</strong>[2,5,7,2,5,7,2,5,7,2,5,7...
</pre>
<p class="src"><a id="v:take" class="def">take</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#take" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:take" title="GHC.List">take</a></code> <code>n</code>, applied to a list <code>xs</code>, returns the prefix of <code>xs</code> of length <code>n</code>, or <code>xs</code> itself if <code>n &gt;= <a href="ghc-list.html#v:length" title="GHC.List">length</a> xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">take 5 "Hello World!"
</strong>"Hello"
&gt;&gt;&gt; <strong class="userinput">take 3 [1,2,3,4,5]
</strong>[1,2,3]
&gt;&gt;&gt; <strong class="userinput">take 3 [1,2]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">take 3 []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take (-1) [1,2]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">take 0 [1,2]
</strong>[]
</pre>
<p>It is an instance of the more general <code><a href="data-list.html#v:genericTake" title="Data.List">genericTake</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:drop" class="def">drop</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#drop" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:drop" title="GHC.List">drop</a></code> <code>n xs</code> returns the suffix of <code>xs</code> after the first <code>n</code> elements, or <code>[]</code> if <code>n &gt;= <a href="ghc-list.html#v:length" title="GHC.List">length</a> xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">drop 6 "Hello World!"
</strong>"World!"
&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2,3,4,5]
</strong>[4,5]
&gt;&gt;&gt; <strong class="userinput">drop 3 [1,2]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">drop 3 []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">drop (-1) [1,2]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">drop 0 [1,2]
</strong>[1,2]
</pre>
<p>It is an instance of the more general <code><a href="data-list.html#v:genericDrop" title="Data.List">genericDrop</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:splitAt" class="def">splitAt</a> :: <a href="data-int.html#t:Int" title="Data.Int">Int</a> -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#splitAt" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:splitAt" title="GHC.List">splitAt</a></code> <code>n xs</code> returns a tuple where first element is <code>xs</code> prefix of length <code>n</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">splitAt 6 "Hello World!"
</strong>("Hello ","World!")
&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3,4,5]
</strong>([1,2,3],[4,5])
&gt;&gt;&gt; <strong class="userinput">splitAt 1 [1,2,3]
</strong>([1],[2,3])
&gt;&gt;&gt; <strong class="userinput">splitAt 3 [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">splitAt 4 [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">splitAt 0 [1,2,3]
</strong>([],[1,2,3])
&gt;&gt;&gt; <strong class="userinput">splitAt (-1) [1,2,3]
</strong>([],[1,2,3])
</pre>
<p>It is equivalent to <code>(<a href="ghc-list.html#v:take" title="GHC.List">take</a> n xs, <a href="ghc-list.html#v:drop" title="GHC.List">drop</a> n xs)</code> when <code>n</code> is not <code>_|_</code> (<code>splitAt _|_ xs = _|_</code>). <code><a href="ghc-list.html#v:splitAt" title="GHC.List">splitAt</a></code> is an instance of the more general <code><a href="data-list.html#v:genericSplitAt" title="Data.List">genericSplitAt</a></code>, in which <code>n</code> may be of any integral type.</p>
<p class="src"><a id="v:takeWhile" class="def">takeWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#takeWhile" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:takeWhile" title="GHC.List">takeWhile</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns the longest prefix (possibly empty) of <code>xs</code> of elements that satisfy <code>p</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>[1,2]
&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 9) [1,2,3]
</strong>[1,2,3]
&gt;&gt;&gt; <strong class="userinput">takeWhile (&lt; 0) [1,2,3]
</strong>[]
</pre>
<p class="src"><a id="v:dropWhile" class="def">dropWhile</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#dropWhile" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:dropWhile" title="GHC.List">dropWhile</a></code> <code>p xs</code> returns the suffix remaining after <code><a href="ghc-list.html#v:takeWhile" title="GHC.List">takeWhile</a></code> <code>p xs</code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 3) [1,2,3,4,5,1,2,3]
</strong>[3,4,5,1,2,3]
&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 9) [1,2,3]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">dropWhile (&lt; 0) [1,2,3]
</strong>[1,2,3]
</pre>
<p class="src"><a id="v:span" class="def">span</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#span" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:span" title="GHC.List">span</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of <code>xs</code> of elements that satisfy <code>p</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">span (&lt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2],[3,4,1,2,3,4])
&gt;&gt;&gt; <strong class="userinput">span (&lt; 9) [1,2,3]
</strong>([1,2,3],[])
&gt;&gt;&gt; <strong class="userinput">span (&lt; 0) [1,2,3]
</strong>([],[1,2,3])
</pre>
<p><code><a href="ghc-list.html#v:span" title="GHC.List">span</a></code> <code>p xs</code> is equivalent to <code>(<a href="ghc-list.html#v:takeWhile" title="GHC.List">takeWhile</a> p xs, <a href="ghc-list.html#v:dropWhile" title="GHC.List">dropWhile</a> p xs)</code></p>
<p class="src"><a id="v:break" class="def">break</a> :: (a -&gt; <a href="data-bool.html#t:Bool" title="Data.Bool">Bool</a>) -&gt; [a] -&gt; ([a], [a]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#break" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:break" title="GHC.List">break</a></code>, applied to a predicate <code>p</code> and a list <code>xs</code>, returns a tuple where first element is longest prefix (possibly empty) of <code>xs</code> of elements that <em>do not satisfy</em> <code>p</code> and second element is the remainder of the list:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">break (&gt; 3) [1,2,3,4,1,2,3,4]
</strong>([1,2,3],[4,1,2,3,4])
&gt;&gt;&gt; <strong class="userinput">break (&lt; 9) [1,2,3]
</strong>([],[1,2,3])
&gt;&gt;&gt; <strong class="userinput">break (&gt; 9) [1,2,3]
</strong>([1,2,3],[])
</pre>
<p><code><a href="ghc-list.html#v:break" title="GHC.List">break</a></code> <code>p</code> is equivalent to <code><a href="ghc-list.html#v:span" title="GHC.List">span</a> (<a href="data-bool.html#v:not" title="Data.Bool">not</a> . p)</code>.</p>
<p class="src"><a id="v:reverse" class="def">reverse</a> :: [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#reverse" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:reverse" title="GHC.List">reverse</a></code> <code>xs</code> returns the elements of <code>xs</code> in reverse order. <code>xs</code> must be finite.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">reverse []
</strong>[]
&gt;&gt;&gt; <strong class="userinput">reverse [42]
</strong>[42]
&gt;&gt;&gt; <strong class="userinput">reverse [2,5,7]
</strong>[7,5,2]
&gt;&gt;&gt; <strong class="userinput">reverse [1..]
</strong>* Hangs forever *
</pre>
<p class="src"><a id="v:zip" class="def">zip</a> :: [a] -&gt; [b] -&gt; [(a, b)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zip" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="ghc-list.html#v:zip" title="GHC.List">zip</a></code> takes two lists and returns a list of corresponding pairs.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1, 2] ['a', 'b']
</strong>[(1,'a'),(2,'b')]
</pre>
<p>If one input list is shorter than the other, excess elements of the longer list are discarded, even if one of the lists is infinite:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [1] ['a', 'b']
</strong>[(1,'a')]
&gt;&gt;&gt; <strong class="userinput">zip [1, 2] ['a']
</strong>[(1,'a')]
&gt;&gt;&gt; <strong class="userinput">zip [] [1..]
</strong>[]
&gt;&gt;&gt; <strong class="userinput">zip [1..] []
</strong>[]
</pre>
<p><code><a href="ghc-list.html#v:zip" title="GHC.List">zip</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zip [] undefined
</strong>[]
&gt;&gt;&gt; <strong class="userinput">zip undefined []
</strong>*** Exception: Prelude.undefined
...
</pre>
<p><code><a href="ghc-list.html#v:zip" title="GHC.List">zip</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zip3" class="def">zip3</a> :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zip3" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:zip3" title="GHC.List">zip3</a></code> takes three lists and returns a list of triples, analogous to <code><a href="ghc-list.html#v:zip" title="GHC.List">zip</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith" class="def">zipWith</a> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zipWith" class="link">Source</a> </p>
<p><span class="mathjax">\(\mathcal{O}(\min(m,n))\)</span>. <code><a href="ghc-list.html#v:zipWith" title="GHC.List">zipWith</a></code> generalises <code><a href="ghc-list.html#v:zip" title="GHC.List">zip</a></code> by zipping with the function given as the first argument, instead of a tupling function.</p>
<pre>zipWith (,) xs ys == zip xs ys
zipWith f [x1,x2,x3..] [y1,y2,y3..] == [f x1 y1, f x2 y2, f x3 y3..]</pre>
<p>For example, <code><a href="ghc-list.html#v:zipWith" title="GHC.List">zipWith</a> (+)</code> is applied to two lists to produce the list of corresponding sums:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">zipWith (+) [1, 2, 3] [4, 5, 6]
</strong>[5,7,9]
</pre>
<p><code><a href="ghc-list.html#v:zipWith" title="GHC.List">zipWith</a></code> is right-lazy:</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">let f = undefined
</strong>&gt;&gt;&gt; <strong class="userinput">zipWith f [] undefined
</strong>[]
</pre>
<p><code><a href="ghc-list.html#v:zipWith" title="GHC.List">zipWith</a></code> is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<p class="src"><a id="v:zipWith3" class="def">zipWith3</a> :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#zipWith3" class="link">Source</a> </p>
<p>The <code><a href="ghc-list.html#v:zipWith3" title="GHC.List">zipWith3</a></code> function takes a function which combines three elements, as well as three lists and returns a list of the function applied to corresponding elements, analogous to <code><a href="ghc-list.html#v:zipWith" title="GHC.List">zipWith</a></code>. It is capable of list fusion, but it is restricted to its first list argument and its resulting list.</p>
<pre>zipWith3 (,,) xs ys zs == zip3 xs ys zs
zipWith3 f [x1,x2,x3..] [y1,y2,y3..] [z1,z2,z3..] == [f x1 y1 z1, f x2 y2 z2, f x3 y3 z3..]</pre>
<p class="src"><a id="v:unzip" class="def">unzip</a> :: [(a, b)] -&gt; ([a], [b]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#unzip" class="link">Source</a> </p>
<p><code><a href="ghc-list.html#v:unzip" title="GHC.List">unzip</a></code> transforms a list of pairs into a list of first components and a list of second components.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip []
</strong>([],[])
&gt;&gt;&gt; <strong class="userinput">unzip [(1, 'a'), (2, 'b')]
</strong>([1,2],"ab")
</pre>
<p class="src"><a id="v:unzip3" class="def">unzip3</a> :: [(a, b, c)] -&gt; ([a], [b], [c]) <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#unzip3" class="link">Source</a> </p>
<p>The <code><a href="ghc-list.html#v:unzip3" title="GHC.List">unzip3</a></code> function takes a list of triples and returns three lists, analogous to <code><a href="ghc-list.html#v:unzip" title="GHC.List">unzip</a></code>.</p>
<pre class="screen">&gt;&gt;&gt; <strong class="userinput">unzip3 []
</strong>([],[],[])
&gt;&gt;&gt; <strong class="userinput">unzip3 [(1, 'a', True), (2, 'b', False)]
</strong>([1,2],"ab",[True,False])
</pre>
<p class="src"><a id="v:errorEmptyList" class="def">errorEmptyList</a> :: <a href="ghc-stack.html#t:HasCallStack" title="GHC.Stack">HasCallStack</a> =&gt; <a href="data-string.html#t:String" title="Data.String">String</a> -&gt; a <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.List.html#errorEmptyList" class="link">Source</a> </p>
<a href="#g:1" id="g:1"><h2>GHC List fusion</h2></a><p class="src"><a id="v:augment" class="def">augment</a> :: forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a] -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#augment" class="link">Source</a> </p>
<p>A list producer that can be fused with <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>. This function is merely</p>
<pre>   augment g xs = g (:) xs</pre>
<p>but GHC's simplifier will transform an expression of the form <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a> k z (<a href="ghc-list.html#v:augment" title="GHC.List">augment</a> g xs)</code>, which may arise after inlining, to <code>g k (<a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a> k z xs)</code>, which avoids producing an intermediate list.</p>
<p class="src"><a id="v:build" class="def">build</a> :: forall a. (forall b. (a -&gt; b -&gt; b) -&gt; b -&gt; b) -&gt; [a] <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/src/GHC.Base.html#build" class="link">Source</a> </p>
<p>A list producer that can be fused with <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a></code>. This function is merely</p>
<pre>   build g = g (:) []</pre>
<p>but GHC's simplifier will transform an expression of the form <code><a href="ghc-list.html#v:foldr" title="GHC.List">foldr</a> k z (<a href="ghc-list.html#v:build" title="GHC.List">build</a> g)</code>, which may arise after inlining, to <code>g k z</code>, which avoids producing an intermediate list.</p>
</div><div class="_attribution">
  <p class="_attribution-p">
    &copy; The University of Glasgow and others<br>Licensed under a BSD-style license (see top of the page).<br>
    <a href="https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/GHC-List.html" class="_attribution-link">https://downloads.haskell.org/~ghc/9.4.2/docs/libraries/base-4.17.0.0/GHC-List.html</a>
  </p>
</div>
