<h1>1. Overview</h1>  <blockquote> <p>ğŸ“ PnP is a feature of Yarn, donâ€™t confuse it with <a href="https://pnpm.js.org">pnpm</a>, which is a different, standalone JavaScript package manager.</p> </blockquote> <p>Plugâ€™nâ€™Play is an alternative installation strategy unveiled in September 2018. It presents interesting characteristics that make suitable for a large panel of projects, and is designed for compatibility with the current ecosystem.</p> <p>The way regular installs work is simple: Yarn generates a <code>node_modules</code> directory that Node is then able to consume. In this context, Node doesnâ€™t know the first thing about what a package is: it only reasons in terms of files. â€œDoes this file exist here? No? Letâ€™s look in the parent <code>node_modules</code> then. Does it exist here? Still no? Too badâ€¦ parent folder it is!â€ - and it does this until it matches something that matches one of the possibilities. Thatâ€™s vastly inefficient.</p> <p>When you think about it, Yarn knows everything about your dependency tree - it even installs it! So why is Node tasked with locating your packages on the disk? Why donâ€™t we simply query Yarn, and let it tell us where to look for a package X required by a package Y? Thatâ€™s what Plugâ€™nâ€™Play (abbreviated PnP) is. Instead of generating a <code>node_modules</code> directory and leaving the resolution to Node, we now generate a single <code>.pnp.js</code> file and let Yarn tell us where to find our packages. Doing this provides a lot of benefits:</p> <ul> <li> <p>The <code>node_modules</code> directory contains a gargantuan amount of files. Generating it makes up for more than 70% of the time needed to run <code>yarn install</code> with a hot cache. Because the copy is I/O bound, itâ€™s not like package managers can really optimize it either - we can use hardlinks or copy-on-write, but even then we still need to make a bunch of syscalls that slow us down dramatically.</p> </li> <li> <p>Because Node has no concept of â€œpackageâ€, it doesnâ€™t know whether a file is <em>meant</em> to be accessed, on top of being available. Itâ€™s entirely possible that code you wrote will work in development but break in production because you forgot to list one of your dependencies in your <code>package.json</code> - and you wonâ€™t know it until it becomes a problem and you lose a day investigating the issue.</p> </li> <li> <p>Even at runtime, the Node resolution needs to make a bunch of <code>stat</code> and <code>readdir</code> calls in order to figure out where should a resolution end up. Itâ€™s extremely wasteful, and is part of the reason why booting a Node application takes so much time - before even starting executing it, Node has to spend its time querying the filesystem for information that Yarn could have given it already.</p> </li> <li> <p>Finally, the very design of the <code>node_modules</code> folder is impractical in that it doesnâ€™t allow to dedupe packages as efficiently as one would hope. Because two packages with the same name but different versions cannot coexist in the same directory, we canâ€™t guarantee a perfect hoisting. Similarly, because the <code>node_modules</code> are deeply nested in a way that depend on the project dependencies, they cannot be shared from one project to the other.</p> </li> </ul> <p>All those problems and more are solved by Plugâ€™nâ€™Play.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2016&ndash;present Yarn Contributors<br>Licensed under the BSD License.<br>
    <a href="https://classic.yarnpkg.com/en/docs/pnp" class="_attribution-link">https://classic.yarnpkg.com/en/docs/pnp</a>
  </p>
</div>
