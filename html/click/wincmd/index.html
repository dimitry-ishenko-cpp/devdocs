<h1>Windows Console Notes</h1> <details class="changelog"> <summary>Changelog</summary><div class="versionadded"> <p><span class="versionmodified added">New in version 6.0.</span></p> </div> </details><p>Click emulates output streams on Windows to support unicode to the Windows console through separate APIs and we perform different decoding of parameters.</p> <p>Here is a brief overview of how this works and what it means to you.</p> <section id="unicode-arguments"> <h2>Unicode Arguments</h2> <p>Click internally is generally based on the concept that any argument can come in as either byte string or unicode string and conversion is performed to the type expected value as late as possible. This has some advantages as it allows us to accept the data in the most appropriate form for the operating system and Python version.</p> <p>This caused some problems on Windows where initially the wrong encoding was used and garbage ended up in your input data. We not only fixed the encoding part, but we also now extract unicode parameters from <code>sys.argv</code>.</p> <p>There is also another limitation with this: if <code>sys.argv</code> was modified prior to invoking a click handler, we have to fall back to the regular byte input in which case not all unicode values are available but only a subset of the codepage used for parameters.</p> </section> <section id="unicode-output-and-input"> <h2>Unicode Output and Input</h2> <p>Unicode output and input on Windows is implemented through the concept of a dispatching text stream. What this means is that when click first needs a text output (or input) stream on windows it goes through a few checks to figure out of a windows console is connected or not. If no Windows console is present then the text output stream is returned as such and the encoding for that stream is set to <code>utf-8</code> like on all platforms.</p> <p>However if a console is connected the stream will instead be emulated and use the cmd.exe unicode APIs to output text information. In this case the stream will also use <code>utf-16-le</code> as internal encoding. However there is some hackery going on that the underlying raw IO buffer is still bypassing the unicode APIs and byte output through an indirection is still possible.</p> <ul class="simple"> <li>This unicode support is limited to <code>click.echo</code>, <code>click.prompt</code> as well as <code>click.get_text_stream</code>.</li> <li>Depending on if unicode values or byte strings are passed the control flow goes completely different places internally which can have some odd artifacts if data partially ends up being buffered. Click attempts to protect against that by manually always flushing but if you are mixing and matching different string types to <code>stdout</code> or <code>stderr</code> you will need to manually flush.</li> <li>The raw output stream is set to binary mode, which is a global operation on Windows, so <code>print</code> calls will be affected. Prefer <code>click.echo</code> over <code>print</code>.</li> <li>On Windows 7 and below, there is a limitation where at most 64k characters can be written in one call in binary mode. In this situation, <code>sys.stdout</code> and <code>sys.stderr</code> are replaced with wrappers that work around the limitation.</li> </ul> <p>Another important thing to note is that the Windows consoleâ€™s default fonts do not support a lot of characters which means that you are mostly limited to international letters but no emojis or special characters.</p> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; Copyright 2014 Pallets.<br>Licensed under the BSD 3-Clause License.<br>We are not supported nor endorsed by Pallets.<br>
    <a href="https://click.palletsprojects.com/en/8.1.x/wincmd/" class="_attribution-link">https://click.palletsprojects.com/en/8.1.x/wincmd/</a>
  </p>
</div>
