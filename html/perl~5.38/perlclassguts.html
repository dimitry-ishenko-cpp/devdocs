<h1>perlclassguts</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> </li> <li> <a class="text-decoration-none" href="#DATA-STORAGE">DATA STORAGE</a> <ul> <li> <a class="text-decoration-none" href="#Classes">Classes</a> </li> <li> <a class="text-decoration-none" href="#Fields">Fields</a> </li> <li> <a class="text-decoration-none" href="#Methods">Methods</a> </li> <li> <a class="text-decoration-none" href="#Instances">Instances</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#API">API</a> <ul> <li> <a class="text-decoration-none" href="#Class-Manipulation">Class Manipulation</a> <ul> <li> <a class="text-decoration-none" href="#class_setup_stash">class_setup_stash</a> </li> <li> <a class="text-decoration-none" href="#class_seal_stash">class_seal_stash</a> </li> <li> <a class="text-decoration-none" href="#class_add_field">class_add_field</a> </li> <li> <a class="text-decoration-none" href="#class_add_ADJUST">class_add_ADJUST</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#Field-Manipulation">Field Manipulation</a> <ul> <li> <a class="text-decoration-none" href="#class_prepare_initfield_parse">class_prepare_initfield_parse</a> </li> <li> <a class="text-decoration-none" href="#class_set_field_defop">class_set_field_defop</a> </li> <li> <a class="text-decoration-none" href="#padadd_FIELD">padadd_FIELD</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#Method-Manipulation">Method Manipulation</a> <ul> <li> <a class="text-decoration-none" href="#class_prepare_method_parse">class_prepare_method_parse</a> </li> <li> <a class="text-decoration-none" href="#class_wrap_method_body">class_wrap_method_body</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#Object-Instances">Object Instances</a> <ul> <li> <a class="text-decoration-none" href="#SVt_PVOBJ">SVt_PVOBJ</a> </li> <li> <a class="text-decoration-none" href="#ObjectMAXFIELD">ObjectMAXFIELD</a> </li> <li> <a class="text-decoration-none" href="#ObjectFIELDS">ObjectFIELDS</a> </li> </ul> </li> </ul> </li> <li> <a class="text-decoration-none" href="#OPCODES">OPCODES</a> <ul> <li> <a class="text-decoration-none" href="#OP_METHSTART">OP_METHSTART</a> </li> <li> <a class="text-decoration-none" href="#OP_INITFIELD">OP_INITFIELD</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#COMPILE-TIME-BEHAVIOUR">COMPILE-TIME BEHAVIOUR</a> <ul> <li> <a class="text-decoration-none" href="#ADJUST-Phasers">ADJUST Phasers</a> </li> <li> <a class="text-decoration-none" href="#Attributes">Attributes</a> </li> <li> <a class="text-decoration-none" href="#Field-Initializing-Expressions">Field Initializing Expressions</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#RUNTIME-BEHAVIOUR">RUNTIME BEHAVIOUR</a> <ul> <li> <a class="text-decoration-none" href="#Constructor">Constructor</a> </li> <li> <a class="text-decoration-none" href="#$self-Access-During-Methods">$self Access During Methods</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>perlclassguts - Internals of how <code>feature 'class'</code> and class syntax works</p> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>This document provides in-depth information about the way in which the perl interpreter implements the <code>feature 'class'</code> syntax and overall behaviour. It is not intended as an end-user guide on how to use the feature. For that, see <a href="perlclass.html">perlclass</a>.</p> <p>The reader is assumed to be generally familiar with the perl interpreter internals overall. For a more general overview of these details, see also <a href="perlguts.html">perlguts</a>.</p> <h2 id="DATA-STORAGE">
DATA STORAGE</h2> <h3 id="Classes">Classes</h3> <p>A class is fundamentally a package, and exists in the symbol table as an HV with an aux structure in exactly the same way as a non-class package. It is distinguished from a non-class package by the fact that the <code>HvSTASH_IS_CLASS()</code> macro will return true on it.</p> <p>Extra information relating to it being a class is stored in the <code>struct xpvhv_aux</code> structure attached to the stash, in the following fields:</p> <pre data-language="perl"><code>HV          *xhv_class_superclass;
CV          *xhv_class_initfields_cv;
AV          *xhv_class_adjust_blocks;
PADNAMELIST *xhv_class_fields;
PADOFFSET    xhv_class_next_fieldix;
HV          *xhv_class_param_map;</code></pre> <ul> <li>
<p><code>xhv_class_superclass</code> will be <code>NULL</code> for a class with no superclass. It will point directly to the stash of the parent class if one has been set with the <code>:isa()</code> class attribute.</p> </li> <li>
<p><code>xhv_class_initfields_cv</code> will contain a <code>CV *</code> pointing to a function to be invoked as part of the constructor of this class or any subclass thereof. This CV is responsible for initializing all the fields defined by this class for a new instance. This CV will be an anonymous real function - i.e. while it has no name and no GV, it is <i>not</i> a protosub and may be directly invoked.</p> </li> <li>
<p><code>xhv_class_adjust_blocks</code> may point to an AV containing CV pointers to each of the <code>ADJUST</code> blocks defined on the class. If the class has a superclass, this array will additionally contain duplicate pointers of the CVs of its parent class. The AV is created lazily the first time an element is pushed to it; it is valid for there not to be one, and this pointer will be <code>NULL</code> in that case.</p> <p>The CVs are stored directly, not via RVs. Each CV will be an anonymous real function.</p> </li> <li>
<p><code>xhv_class_fields</code> will point to a <code>PADNAMELIST</code> containing <code>PADNAME</code>s, each being one defined field of the class. They are stored in order of declaration. Note however, that the index into this array will not necessarily be equal to the <code>fieldix</code> of each field, because in the case of a subclass, the array will begin at zero but the index of the first field in it will be non-zero if its parent class contains any fields at all.</p> <p>For more information on how individual fields are represented, see <a href="#Fields">"Fields"</a>.</p> </li> <li>
<p><code>xhv_class_next_fieldix</code> gives the field index that will be assigned to the next field to be added to the class. It is only useful at compile-time.</p> </li> <li>
<p><code>xhv_class_param_map</code> may point to an HV which maps field <code>:param</code> attribute names to the field index of the field with that name. This mapping is copied from parent classes; each class will contain the sum total of all its parents in addition to its own.</p> </li> </ul> <h3 id="Fields">Fields</h3> <p>A field is still fundamentally a lexical variable declared in a scope, and exists in the <code>PADNAMELIST</code> of its corresponding CV. Methods and other method-like CVs can still capture them exactly as they can with regular lexicals. A field is distinguished from other kinds of pad entry in that the <code>PadnameIsFIELD()</code> macro will return true on it.</p> <p>Extra information relating to it being a field is stored in an additional structure accessible via the <code>PadnameFIELDINFO()</code> macro on the padname. This structure has the following fields:</p> <pre data-language="perl"><code>PADOFFSET  fieldix;
HV        *fieldstash;
OP        *defop;
SV        *paramname;
bool       def_if_undef;
bool       def_if_false;</code></pre> <ul> <li>
<p><code>fieldix</code> stores the "field index" of the field; that is, the index into the instance field array where this field's value will be stored. Note that the first index in the array is not specially reserved. The first field in a class will start from field index 0.</p> </li> <li>
<p><code>fieldstash</code> stores a pointer to the stash of the class that defined this field. This is necessary in case there are multiple classes defined within the same scope; it is used to disambiguate the fields of each.</p> <pre data-language="perl"><code>{
    class C1; field $x;
    class C2; field $x;
}</code></pre> </li> <li>
<p><code>defop</code> may store a pointer to a defaulting expression optree for this field. Defaulting expressions are optional; this field may be <code>NULL</code>.</p> </li> <li>
<p><code>paramname</code> may point to a regular string SV containing the <code>:param</code> name attribute given to the field. If none, it will be <code>NULL</code>.</p> </li> <li>
<p>One of <code>def_if_undef</code> and <code>def_if_false</code> will be true if the defaulting expression was set using the <code>//=</code> or <code>||=</code> operators respectively.</p> </li> </ul> <h3 id="Methods">Methods</h3> <p>A method is still fundamentally a CV, and has the same basic representation as one. It has an optree and a pad, and is stored via a GV in the stash of its containing package. It is distinguished from a non-method CV by the fact that the <code>CvIsMETHOD()</code> macro will return true on it.</p> <p>(Note: This macro should not be confused with the one that was previously called <code>CvMETHOD()</code>. That one does not relate to the class system, and was renamed to <code>CvNOWARN_AMBIGUOUS()</code> to avoid this confusion.)</p> <p>There is currently no extra information that needs to be stored about a method CV, so the structure does not add any new fields.</p> <h3 id="Instances">Instances</h3> <p>Object instances are represented by an entirely new SV type, whose base type is <code>SVt_PVOBJ</code>. This should still be blessed into its class stash and wrapped in an RV in the usual manner for classical object.</p> <p>As these are their own unique container type, distinct from hashes or arrays, the core <code>builtin::reftype</code> function returns a new value when asked about these. That value is <code>"OBJECT"</code>.</p> <p>Internally, such an object is an array of SV pointers whose size is fixed at creation time (because the number of fields in a class is known after compilation). An object instance stores the max field index within it (for basic error-checking on access), and a fixed-size array of SV pointers storing the individual field values.</p> <p>Fields of array and hash type directly store AV or HV pointers into the array; they are not stored via an intervening RV.</p> <h2 id="API">API</h2> <p>The data structures described above are supported by the following API functions.</p> <h3 id="Class-Manipulation">
Class Manipulation</h3> <h4 id="class_setup_stash">class_setup_stash</h4> <pre data-language="perl"><code>void class_setup_stash(HV *stash);</code></pre> <p>Called by the parser on encountering the <code>class</code> keyword. It upgrades the stash into being a class and prepares it for receiving class-specific items like methods and fields.</p> <h4 id="class_seal_stash">class_seal_stash</h4> <pre data-language="perl"><code>void class_seal_stash(HV *stash);</code></pre> <p>Called by the parser at the end of a <code>class</code> block, or for unit classes its containing scope. This function performs various finalisation activities that are required before instances of the class can be constructed, but could not have been done until all the information about the members of the class is known.</p> <p>Any additions to or modifications of the class under compilation must be performed between these two function calls. Classes cannot be modified once they have been sealed.</p> <h4 id="class_add_field">class_add_field</h4> <pre data-language="perl"><code>void class_add_field(HV *stash, PADNAME *pn);</code></pre> <p>Called by <i>pad.c</i> as part of defining a new field name in the current pad. Note that this function does <i>not</i> create the padname; that must already be done by <i>pad.c</i>. This API function simply informs the class that the new field name has been created and is now available for it.</p> <h4 id="class_add_ADJUST">class_add_ADJUST</h4> <pre data-language="perl"><code>void class_add_ADJUST(HV *stash, CV *cv);</code></pre> <p>Called by the parser once it has parsed and constructed a CV for a new <code>ADJUST</code> block. This gets added to the list stored by the class.</p> <h3 id="Field-Manipulation">
Field Manipulation</h3> <h4 id="class_prepare_initfield_parse">class_prepare_initfield_parse</h4> <pre data-language="perl"><code>void class_prepare_initfield_parse();</code></pre> <p>Called by the parser just before parsing an initializing expression for a field variable. This makes use of a suspended compcv to combine all the field initializing expressions into the same CV.</p> <h4 id="class_set_field_defop">class_set_field_defop</h4> <pre data-language="perl"><code>void class_set_field_defop(PADNAME *pn, OPCODE defmode, OP *defop);</code></pre> <p>Called by the parser after it has parsed an initializing expression for the field. Sets the defaulting expression and mode of application. <code>defmode</code> should either be zero, or one of <code>OP_ORASSIGN</code> or <code>OP_DORASSIGN</code> depending on the defaulting mode.</p> <h4 id="padadd_FIELD">padadd_FIELD</h4> <pre data-language="perl"><code class="plaintext">#define padadd_FIELD</code></pre> <p>This flag constant tells the <code>pad_add_name_*</code> family of functions that the new name should be added as a field. There is no need to call <code>class_add_field()</code>; this will be done automatically.</p> <h3 id="Method-Manipulation">
Method Manipulation</h3> <h4 id="class_prepare_method_parse">class_prepare_method_parse</h4> <pre data-language="perl"><code>void class_prepare_method_parse(CV *cv);</code></pre> <p>Called by the parser after <code>start_subparse()</code> but immediately before doing anything else. This prepares the <code>PL_compcv</code> for parsing a method; arranging for the <code>CvIsMETHOD</code> test to be true, adding the <code>$self</code> lexical, and any other activities that may be required.</p> <h4 id="class_wrap_method_body">class_wrap_method_body</h4> <pre data-language="perl"><code>OP *class_wrap_method_body(OP *o);</code></pre> <p>Called by the parser at the end of parsing a method body into an optree but just before wrapping it in the eventual CV. This function inserts extra ops into the optree to make the method work correctly.</p> <h3 id="Object-Instances">
Object Instances</h3> <h4 id="SVt_PVOBJ">SVt_PVOBJ</h4> <pre data-language="perl"><code class="plaintext">#define SVt_PVOBJ</code></pre> <p>An SV type constant used for comparison with the <code>SvTYPE()</code> macro.</p> <h4 id="ObjectMAXFIELD">ObjectMAXFIELD</h4> <pre data-language="perl"><code>SSize_t ObjectMAXFIELD(sv);</code></pre> <p>A function-like macro that obtains the maximum valid field index that can be accessed from the <code>ObjectFIELDS</code> array.</p> <h4 id="ObjectFIELDS">ObjectFIELDS</h4> <pre data-language="perl"><code>SV **ObjectFIELDS(sv);</code></pre> <p>A function-like macro that obtains the fields array directly out of an object instance. Fields can be accessed by their field index, from 0 up to the maximum valid index given by <code>ObjectMAXFIELD</code>.</p> <h2 id="OPCODES">OPCODES</h2> <h3 id="OP_METHSTART">OP_METHSTART</h3> <pre data-language="perl"><code>newUNOP_AUX(OP_METHSTART, ...);</code></pre> <p>An <code>OP_METHSTART</code> is an <code>UNOP_AUX</code> which must be present at the start of a method CV in order to make it work properly. This is inserted by <code>class_wrap_method_body()</code>, and even appears before any optree fragment associated with signature argument checking or extraction.</p> <p>This op is responsible for shifting the value of <code>$self</code> out of the arguments list and binding any field variables that the method requires access to into the pad. The AUX vector will contain details of the field/pad index pairings required.</p> <p>This op also performs sanity checking on the invocant value. It checks that it is definitely an object reference of a compatible class type. If not, an exception is thrown.</p> <p>If the <code>op_private</code> field includes the <code>OPpINITFIELDS</code> flag, this indicates that the op begins the special <code>xhv_class_initfields_cv</code> CV. In this case it should additionally take the second value from the arguments list, which should be a plain HV pointer (<i>directly</i>, not via RV). and bind it to the second pad slot, where the generated optree will expect to find it.</p> <h3 id="OP_INITFIELD">OP_INITFIELD</h3> <p>An <code>OP_INITFIELD</code> is only invoked as part of the <code>xhv_class_initfields_cv</code> CV during the construction phase of an instance. This is the time that the individual SVs that make up the mutable fields of the instance (including AVs and HVs) are actually assigned into the <code>ObjectFIELDS</code> array. The <code>OPpINITFIELD_AV</code> and <code>OPpINITFIELD_HV</code> private flags indicate whether it is creating an AV or HV; if neither is set then an SV is created.</p> <p>If the op has the <code>OPf_STACKED</code> flag it expects to find an initializing value on the stack. For SVs this is the topmost SV on the data stack. For AVs and HVs it expects a marked list.</p> <h2 id="COMPILE-TIME-BEHAVIOUR">
COMPILE-TIME BEHAVIOUR</h2> <h3 id="ADJUST-Phasers">
<code>ADJUST</code> Phasers</h3> <p>During compiletime, parsing of an <code>ADJUST</code> phaser is handled in a fundamentally different way to the existing perl phasers (<code>BEGIN</code>, etc...)</p> <p>Rather than taking the usual route, the tokenizer recognises that the <code>ADJUST</code> keyword introduces a phaser block. The parser then parses the body of this block similarly to how it would parse an (anonymous) method body, creating a CV that has no name GV. This is then inserted directly into the class information by calling <code>class_add_ADJUST</code>, entirely bypassing the symbol table.</p> <h3 id="Attributes">Attributes</h3> <p>During compilation, attributes of both classes and fields are handled in a different way to existing perl attributes on subroutines and lexical variables.</p> <p>The parser still forms an <code>OP_LIST</code> optree of <code>OP_CONST</code> nodes, but these are passed to the <code>class_apply_attributes</code> or <code>class_apply_field_attributes</code> functions. Rather than using a class lookup for a method in the class being parsed, a fixed internal list of known attributes is used to find functions to apply the attribute to the class or field. In future this may support user-supplied extension attribute, though at present it only recognises ones defined by the core itself.</p> <h3 id="Field-Initializing-Expressions">
Field Initializing Expressions</h3> <p>During compilation, the parser makes use of a suspended compcv when parsing the defaulting expression for a field. All the expressions for all the fields in the class share the same suspended compcv, which is then compiled up into the same internal CV called by the constructor to initialize all the fields provided by that class.</p> <h2 id="RUNTIME-BEHAVIOUR">
RUNTIME BEHAVIOUR</h2> <h3 id="Constructor">Constructor</h3> <p>The generated constructor for a class itself is an XSUB which performs three tasks in order: it creates the instance SV itself, invokes the field initializers, then invokes the ADJUST block CVs. The constructor for any class is always the same basic shape, regardless of whether the class has a superclass or not.</p> <p>The field initializers are collected into a generated optree-based CV called the field initializer CV. This is the CV which contains all the optree fragments for the field initializing expressions. When invoked, the field initializer CV might make a chained call to the superclass initializer if one exists, before invoking all of the individual field initialization ops. The field initializer CV is invoked with two items on the stack; being the instance SV and a direct HV containing the constructor parameters. Note carefully: this HV is passed <i>directly</i>, not via an RV reference. This is permitted because both the caller and the callee are directly generated code and not arbitrary pure-perl subroutines.</p> <p>The ADJUST block CVs are all collected into a single flat list, merging all of the ones defined by the superclass as well. They are all invoked in order, after the field initializer CV.</p> <h3 id="$self-Access-During-Methods">
<code>$self</code> Access During Methods</h3> <p>When <code>class_prepare_method_parse()</code> is called, it arranges that the pad of the new CV body will begin with a lexical called <code>$self</code>. Because the pad should be freshly-created at this point, this will have the pad index of 1. The function checks this and aborts if that is not true.</p> <p>Because of this fact, code within the body of a method or method-like CV can reliably use pad index 1 to obtain the invocant reference. The <code>OP_INITFIELD</code> opcode also relies on this fact.</p> <p>In similar fashion, during the <code>xhv_class_initfields_cv</code> the next pad slot is relied on to store the constructor parameters HV, at pad index 2.</p> <h2 id="AUTHORS">AUTHORS</h2> <p>Paul Evans</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/perlclassguts" class="_attribution-link">https://perldoc.perl.org/5.38.0/perlclassguts</a>
  </p>
</div>
