<h1>Win32API::File</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> <ul> <li> <a class="text-decoration-none" href="#Object-Oriented/Tied-Handle-Interface">Object Oriented/Tied Handle Interface</a> </li> <li> <a class="text-decoration-none" href="#Exports">Exports</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#BUGS">BUGS</a> </li> <li> <a class="text-decoration-none" href="#AUTHOR">AUTHOR</a> </li> <li> <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>Win32API::File - Low-level access to Win32 system API calls for files/dirs.</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code>use Win32API::File 0.08 qw( :ALL );

MoveFile( $Source, $Destination )
  or  die "Can't move $Source to $Destination: ",fileLastError(),"\n";
MoveFileEx( $Source, $Destination, MOVEFILE_REPLACE_EXISTING() )
  or  die "Can't move $Source to $Destination: ",fileLastError(),"\n";
[...]</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>This provides fairly low-level access to the Win32 System API calls dealing with files and directories.</p> <p>To pass in <code>NULL</code> as the pointer to an optional buffer, pass in an empty list reference, <code>[]</code>.</p> <p>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</p> <p>All functions, unless otherwise noted, return a true value for success and a false value for failure and set <code>$^E</code> on failure.</p> <h3 id="Object-Oriented/Tied-Handle-Interface">
Object Oriented/Tied Handle Interface</h3> <p>WARNING: this is new code, use at your own risk.</p> <p>This version of <code>Win32API::File</code> can be used like an <code>IO::File</code> object:</p> <pre data-language="perl"><code>my $file = Win32API::File-&gt;new("+&gt; foo");
binmode $file;
print $file "hello there\n";
seek $file, 0, 0;
my $line = &lt;$file&gt;;
$file-&gt;close;</code></pre> <p>It also supports tying via a win32 handle (for example, from <code>createFile()</code>):</p> <pre data-language="perl"><code>tie FILE, 'Win32API::File', $win32_handle;
print FILE "...";</code></pre> <p>It has not been extensively tested yet and buffered I/O is not yet implemented.</p> <h3 id="Exports">Exports</h3> <p>Nothing is exported by default. The following tags can be used to have large sets of symbols exported: <code>":Func"</code>, <code>":FuncA"</code>, <code>":FuncW"</code>, <code>":Misc"</code>, <code>":DDD_"</code>, <code>":DRIVE_"</code>, <code>":FILE_"</code>, <code>":FILE_ATTRIBUTE_"</code>, <code>":FILE_FLAG_"</code>, <code>":FILE_SHARE_"</code>, <code>":FILE_TYPE_"</code>, <code>":FS_"</code>, <code>":FSCTL_"</code>, <code>":HANDLE_FLAG_"</code>, <code>":IOCTL_STORAGE_"</code>, <code>":IOCTL_DISK_"</code>, <code>":GENERIC_"</code>, <code>":MEDIA_TYPE"</code>, <code>":MOVEFILE_"</code>, <code>":SECURITY_"</code>, <code>":SEM_"</code>, and <code>":PARTITION_"</code>.</p> <dl> <dt id='":Func"'>
<code>":Func"</code>
</dt> <dd> <p>The basic function names: <code>attrLetsToBits</code>, <code>createFile</code>, <code>fileConstant</code>, <code>fileLastError</code>, <code>getLogicalDrives</code>, <code>setFilePointer</code>, <code>getFileSize</code>, <code>CloseHandle</code>, <code>CopyFile</code>, <code>CreateFile</code>, <code>DefineDosDevice</code>, <code>DeleteFile</code>, <code>DeviceIoControl</code>, <code>FdGetOsFHandle</code>, <code>GetDriveType</code>, <code>GetFileAttributes</code>, <code>GetFileSize</code>, <code>GetFileType</code>, <code>GetHandleInformation</code>, <code>GetLogicalDrives</code>, <code>GetLogicalDriveStrings</code>, <code>GetOsFHandle</code>, <code>GetOverlappedResult</code>, <code>GetVolumeInformation</code>, <code>IsContainerPartition</code>, <code>IsRecognizedPartition</code>, <code>MoveFile</code>, <code>MoveFileEx</code>, <code>OsFHandleOpen</code>, <code>OsFHandleOpenFd</code>, <code>QueryDosDevice</code>, <code>ReadFile</code>, <code>SetErrorMode</code>, <code>SetFilePointer</code>, <code>SetHandleInformation</code>, and <code>WriteFile</code>.</p> <dl> <dt id="attrLetsToBits">attrLetsToBits</dt>  <dt id="$uBits=-attrLetsToBits(-$sAttributeLetters-)">
<code>$uBits= attrLetsToBits( $sAttributeLetters )</code>
</dt> <dd> <p>Converts a string of file attribute letters into an unsigned value with the corresponding bits set. <code>$sAttributeLetters</code> should contain zero or more letters from <code>"achorst"</code>:</p> <dl> <dt id='"a"'>
<code>"a"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_ARCHIVE</code></p> </dd> <dt id='"c"'>
<code>"c"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_COMPRESSED</code></p> </dd> <dt id='"h"'>
<code>"h"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_HIDDEN</code></p> </dd> <dt id='"o"'>
<code>"o"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_OFFLINE</code></p> </dd> <dt id='"r"'>
<code>"r"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_READONLY</code></p> </dd> <dt id='"s"'>
<code>"s"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_SYSTEM</code></p> </dd> <dt id='"t"'>
<code>"t"</code>
</dt> <dd> <p><code>FILE_ATTRIBUTE_TEMPORARY</code></p> </dd> </dl> </dd> <dt id="createFile">createFile</dt>  <dt id="$hObject=-createFile(-$sPath-)">
<code>$hObject= createFile( $sPath )</code>
</dt>  <dt id="$hObject=-createFile(-$sPath,-$rvhvOptions-)">
<code>$hObject= createFile( $sPath, $rvhvOptions )</code>
</dt>  <dt id="$hObject=-createFile(-$sPath,-$svAccess-)">
<code>$hObject= createFile( $sPath, $svAccess )</code>
</dt>  <dt id="$hObject=-createFile(-$sPath,-$svAccess,-$rvhvOptions-)">
<code>$hObject= createFile( $sPath, $svAccess, $rvhvOptions )</code>
</dt>  <dt id="$hObject=-createFile(-$sPath,-$svAccess,-$svShare-)">
<code>$hObject= createFile( $sPath, $svAccess, $svShare )</code>
</dt>  <dt id="$hObject=-createFile(-$sPath,-$svAccess,-$svShare,-$rvhvOptions-)">
<code>$hObject= createFile( $sPath, $svAccess, $svShare, $rvhvOptions )</code>
</dt> <dd> <p>This is a Perl-friendly wrapper around <code>CreateFile</code>.</p> <p>On failure, <code>$hObject</code> gets set to a false value and <code>regLastError()</code> and <code>$^E</code> are set to the reason for the failure. Otherwise, <code>$hObject</code> gets set to a Win32 native file handle which is always a true value [returns <code>"0 but true"</code> in the impossible(?) case of the handle having a value of <code>0</code>].</p> <p><code>$sPath</code> is the path to the file [or device, etc.] to be opened. See <code>CreateFile</code> for more information on possible special values for <code>$sPath</code>.</p> <p><code>$svAccess</code> can be a number containing the bit mask representing the specific type(s) of access to the file that you desire. See the <code>$uAccess</code> parameter to <code>CreateFile</code> for more information on these values.</p> <p>More likely, <code>$svAccess</code> is a string describing the generic type of access you desire and possibly the file creation options to use. In this case, <code>$svAccess</code> should contain zero or more characters from <code>"qrw"</code> [access desired], zero or one character each from <code>"ktn"</code> and <code>"ce"</code>, and optional white space. These letters stand for, respectively, "Query access", "Read access", "Write access", "Keep if exists", "Truncate if exists", "New file only", "Create if none", and "Existing file only". Case is ignored.</p> <p>You can pass in <code>"?"</code> for <code>$svAccess</code> to have an error message displayed summarizing its possible values. This is very handy when doing on-the-fly programming using the Perl debugger:</p> <pre data-language="perl"><code>    Win32API::File::createFile:  $svAccess can use the following:
	One or more of the following:
	    q -- Query access (same as 0)
	    r -- Read access (GENERIC_READ)
	    w -- Write access (GENERIC_WRITE)
	At most one of the following:
	    k -- Keep if exists
	    t -- Truncate if exists
	    n -- New file only (fail if file already exists)
	At most one of the following:
	    c -- Create if doesn't exist
	    e -- Existing file only (fail if doesn't exist)
      ''   is the same as 'q  k e'
      'r'  is the same as 'r  k e'
      'w'  is the same as 'w  t c'
      'rw' is the same as 'rw k c'
      'rt' or 'rn' implies 'c'.
      Or $access can be numeric.</code></pre> <p><code>$svAccess</code> is designed to be "do what I mean", so you can skip the rest of its explanation unless you are interested in the complex details. Note that, if you want write access to a device, you need to specify <code>"k"</code> [and perhaps <code>"e"</code>, as in <code>"w ke"</code> or <code>"rw ke"</code>] since Win32 suggests <code>OPEN_EXISTING</code> be used when opening a device.</p> <dl> <dt id='"q"'>
<code>"q"</code>
</dt> <dd> <p>Stands for "Query access". This is really a no-op since you always have query access when you open a file. You can specify <code>"q"</code> to document that you plan to query the file [or device, etc.]. This is especially helpful when you don't want read nor write access since something like <code>"q"</code> or <code>"q ke"</code> may be easier to understand than just <code>""</code> or <code>"ke"</code>.</p> </dd> <dt id='"r"1'>
<code>"r"</code>
</dt> <dd> <p>Stands for "Read access". Sets the <code>GENERIC_READ</code> bit(s) in the <code>$uAccess</code> that is passed to <code>CreateFile</code>. This is the default access if the <code>$svAccess</code> parameter is missing [or if it is <code>undef</code> and <code>$rvhvOptions</code> doesn't specify an <code>"Access"</code> option].</p> </dd> <dt id='"w"'>
<code>"w"</code>
</dt> <dd> <p>Stands for "Write access". Sets the <code>GENERIC_WRITE</code> bit(s) in the <code>$uAccess</code> that is passed to <code>CreateFile</code>.</p> </dd> <dt id='"k"'>
<code>"k"</code>
</dt> <dd> <p>Stands for "Keep if exists". If the requested file exists, then it is opened. This is the default unless <code>GENERIC_WRITE</code> access has been requested but <code>GENERIC_READ</code> access has not been requested. Contrast with <code>"t"</code> and <code>"n"</code>.</p> </dd> <dt id='"t"1'>
<code>"t"</code>
</dt> <dd> <p>Stands for "Truncate if exists". If the requested file exists, then it is truncated to zero length and then opened. This is the default if <code>GENERIC_WRITE</code> access has been requested and <code>GENERIC_READ</code> access has not been requested. Contrast with <code>"k"</code> and <code>"n"</code>.</p> </dd> <dt id='"n"'>
<code>"n"</code>
</dt> <dd> <p>Stands for "New file only". If the requested file exists, then it is not opened and the <code>createFile</code> call fails. Contrast with <code>"k"</code> and <code>"t"</code>. Can't be used with <code>"e"</code>.</p> </dd> <dt id='"c"1'>
<code>"c"</code>
</dt> <dd> <p>Stands for "Create if none". If the requested file does not exist, then it is created and then opened. This is the default if <code>GENERIC_WRITE</code> access has been requested or if <code>"t"</code> or <code>"n"</code> was specified. Contrast with <code>"e"</code>.</p> </dd> <dt id='"e"'>
<code>"e"</code>
</dt> <dd> <p>Stands for "Existing file only". If the requested file does not exist, then nothing is opened and the <code>createFile</code> call fails. This is the default unless <code>GENERIC_WRITE</code> access has been requested or <code>"t"</code> or <code>"n"</code> was specified. Contrast with <code>"c"</code>. Can't be used with <code>"n"</code>.</p> </dd> </dl> <p>The characters from <code>"ktn"</code> and <code>"ce"</code> are combined to determine the what value for <code>$uCreate</code> to pass to <code>CreateFile</code> [unless overridden by <code>$rvhvOptions</code>]:</p> <dl> <dt id='"kc"'>
<code>"kc"</code>
</dt> <dd> <p><code>OPEN_ALWAYS</code></p> </dd> <dt id='"ke"'>
<code>"ke"</code>
</dt> <dd> <p><code>OPEN_EXISTING</code></p> </dd> <dt id='"tc"'>
<code>"tc"</code>
</dt> <dd> <p><code>TRUNCATE_EXISTING</code></p> </dd> <dt id='"te"'>
<code>"te"</code>
</dt> <dd> <p><code>CREATE_ALWAYS</code></p> </dd> <dt id='"nc"'>
<code>"nc"</code>
</dt> <dd> <p><code>CREATE_NEW</code></p> </dd> <dt id='"ne"'>
<code>"ne"</code>
</dt> <dd> <p>Illegal.</p> </dd> </dl> <p><code>$svShare</code> controls how the file is shared, that is, whether other processes can have read, write, and/or delete access to the file while we have it opened. <code>$svShare</code> will usually be a string containing zero or more characters from <code>"rwd"</code> but can also be a numeric bit mask.</p> <p><code>"r"</code> sets the <code>FILE_SHARE_READ</code> bit which allows other processes to have read access to the file. <code>"w"</code> sets the <code>FILE_SHARE_WRITE</code> bit which allows other processes to have write access to the file. <code>"d"</code> sets the <code>FILE_SHARE_DELETE</code> bit which allows other processes to have delete access to the file [ignored under Windows 95].</p> <p>The default for <code>$svShare</code> is <code>"rw"</code> which provides the same sharing as using regular perl <code>open()</code>.</p> <p>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to <code>createFile</code> will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to <code>createFile</code> will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</p> <p><code>$rvhvOptions</code> is a reference to a hash where any keys must be from the list <code>qw( Access Create Share Attributes Flags Security Model )</code>. The meaning of the value depends on the key name, as described below. Any option values in <code>$rvhvOptions</code> override the settings from <code>$svAccess</code> and <code>$svShare</code> if they conflict.</p> <dl> <dt id="Flags-=&gt;-$uFlags">
Flags =&gt; $uFlags</dt> <dd> <p><code>$uFlags</code> is an unsigned value having any of the <code>FILE_FLAG_*</code> or <code>FILE_ATTRIBUTE_*</code> bits set. Any <code>FILE_ATTRIBUTE_*</code> bits set via the <code>Attributes</code> option are logically <code>or</code>ed with these bits. Defaults to <code>0</code>.</p> <p>If opening the client side of a named pipe, then you can also specify <code>SECURITY_SQOS_PRESENT</code> along with one of the other <code>SECURITY_*</code> constants to specify the security quality of service to be used.</p> </dd> <dt id="Attributes-=&gt;-$sAttributes">
Attributes =&gt; $sAttributes</dt> <dd> <p>A string of zero or more characters from <code>"achorst"</code> [see <code>attrLetsToBits</code> for more information] which are converted to <code>FILE_ATTRIBUTE_*</code> bits to be set in the <code>$uFlags</code> argument passed to <code>CreateFile</code>.</p> </dd> <dt id="Security-=&gt;-$pSecurityAttributes">
Security =&gt; $pSecurityAttributes</dt> <dd> <p><code>$pSecurityAttributes</code> should contain a <code>SECURITY_ATTRIBUTES</code> structure packed into a string or <code>[]</code> [the default].</p> </dd> <dt id="Model-=&gt;-$hModelFile">
Model =&gt; $hModelFile</dt> <dd> <p><code>$hModelFile</code> should contain a handle opened with <code>GENERIC_READ</code> access to a model file from which file attributes and extended attributes are to be copied. Or <code>$hModelFile</code> can be <code>0</code> [the default].</p> </dd> <dt id="Access-=&gt;-$sAccess">
Access =&gt; $sAccess</dt>  <dt id="Access-=&gt;-$uAccess">
Access =&gt; $uAccess</dt> <dd> <p><code>$sAccess</code> should be a string of zero or more characters from <code>"qrw"</code> specifying the type of access desired: "query" or <code>0</code>, "read" or <code>GENERIC_READ</code> [the default], or "write" or <code>GENERIC_WRITE</code>.</p> <p><code>$uAccess</code> should be an unsigned value containing bits set to indicate the type of access desired. <code>GENERIC_READ</code> is the default.</p> </dd> <dt id="Create-=&gt;-$sCreate">
Create =&gt; $sCreate</dt>  <dt id="Create-=&gt;-$uCreate">
Create =&gt; $uCreate</dt> <dd> <p><code>$sCreate</code> should be a string containing zero or one character from <code>"ktn"</code> and zero or one character from <code>"ce"</code>. These stand for "Keep if exists", "Truncate if exists", "New file only", "Create if none", and "Existing file only". These are translated into a <code>$uCreate</code> value.</p> <p><code>$uCreate</code> should be one of <code>OPEN_ALWAYS</code>, <code>OPEN_EXISTING</code>, <code>TRUNCATE_EXISTING</code>, <code>CREATE_ALWAYS</code>, or <code>CREATE_NEW</code>.</p> </dd> <dt id="Share-=&gt;-$sShare">
Share =&gt; $sShare</dt>  <dt id="Share-=&gt;-$uShare">
Share =&gt; $uShare</dt> <dd> <p><code>$sShare</code> should be a string with zero or more characters from <code>"rwd"</code> that is translated into a <code>$uShare</code> value. <code>"rw"</code> is the default.</p> <p><code>$uShare</code> should be an unsigned value having zero or more of the following bits set: <code>FILE_SHARE_READ</code>, <code>FILE_SHARE_WRITE</code>, and <code>FILE_SHARE_DELETE</code>. <code>FILE_SHARE_READ|FILE_SHARE_WRITE</code> is the default.</p> </dd> </dl> <p>Examples:</p> <pre data-language="perl"><code>$hFlop= createFile( "//./A:", "r", "r" )
  or  die "Can't prevent others from writing to floppy: $^E\n";
$hDisk= createFile( "//./C:", "rw ke", "" )
  or  die "Can't get exclusive access to C: $^E\n";
$hDisk= createFile( $sFilePath, "ke",
  { Access=&gt;FILE_READ_ATTRIBUTES } )
  or  die "Can't read attributes of $sFilePath: $^E\n";
$hTemp= createFile( "$ENV{Temp}/temp.$$", "wn", "",
  { Attributes=&gt;"hst", Flags=&gt;FILE_FLAG_DELETE_ON_CLOSE() } )
  or  die "Can't create temporary file, temp.$$: $^E\n";</code></pre> </dd> <dt id="getLogicalDrives">getLogicalDrives</dt>  <dt id="@roots=-getLogicalDrives()">
<code>@roots= getLogicalDrives()</code>
</dt> <dd> <p>Returns the paths to the root directories of all logical drives currently defined. This includes all types of drive letters, such as floppies, CD-ROMs, hard disks, and network shares. A typical return value on a poorly equipped computer would be <code>("A:\\","C:\\")</code>.</p> </dd> <dt id="CloseHandle">CloseHandle</dt>  <dt id="CloseHandle(-$hObject-)">
<code>CloseHandle( $hObject )</code>
</dt> <dd> <p>Closes a Win32 native handle, such as one opened via <code>CreateFile</code>. Like most routines, returns a true value if successful and a false value [and sets <code>$^E</code> and <code>regLastError()</code>] on failure.</p> </dd> <dt id="CopyFile">CopyFile</dt>  <dt id="CopyFile(-$sOldFileName,-$sNewFileName,-$bFailIfExists-)">
<code>CopyFile( $sOldFileName, $sNewFileName, $bFailIfExists )</code>
</dt> <dd> <p><code>$sOldFileName</code> is the path to the file to be copied. <code>$sNewFileName</code> is the path to where the file should be copied. Note that you can <b>NOT</b> just specify a path to a directory in <code>$sNewFileName</code> to copy the file to that directory using the same file name.</p> <p>If <code>$bFailIfExists</code> is true and <code>$sNewFileName</code> is the path to a file that already exists, then <code>CopyFile</code> will fail. If <code>$bFailIfExists</code> is false, then the copy of the <code>$sOldFileNmae</code> file will overwrite the <code>$sNewFileName</code> file if it already exists.</p> <p>Like most routines, returns a true value if successful and a false value [and sets <code>$^E</code> and <code>regLastError()</code>] on failure.</p> </dd> <dt id="CreateFile">CreateFile</dt>  <dt id="$hObject=-CreateFile(-$sPath,-$uAccess,-$uShare,-$pSecAttr,-$uCreate,-$uFlags,-$hModel-)">
<code>$hObject= CreateFile( $sPath, $uAccess, $uShare, $pSecAttr, $uCreate, $uFlags, $hModel )</code>
</dt> <dd> <p>On failure, <code>$hObject</code> gets set to a false value and <code>$^E</code> and <code>fileLastError()</code> are set to the reason for the failure. Otherwise, <code>$hObject</code> gets set to a Win32 native file handle which is always a true value [returns <code>"0 but true"</code> in the impossible(?) case of the handle having a value of <code>0</code>].</p> <p><code>$sPath</code> is the path to the file [or device, etc.] to be opened.</p> <p><code>$sPath</code> can use <code>"/"</code> or <code>"\\"</code> as path delimiters and can even mix the two. We will usually only use <code>"/"</code> in our examples since using <code>"\\"</code> is usually harder to read.</p> <p>Under Windows NT, <code>$sPath</code> can start with <code>"//?/"</code> to allow the use of paths longer than <code>MAX_PATH</code> [for UNC paths, replace the leading <code>"//"</code> with <code>"//?/UNC/"</code>, as in <code>"//?/UNC/Server/Share/Dir/File.Ext"</code>].</p> <p><code>$sPath</code> can start with <code>"//./"</code> to indicate that the rest of the path is the name of a "DOS device." You can use <code>QueryDosDevice</code> to list all current DOS devices and can add or delete them with <code>DefineDosDevice</code>. If you get the source-code distribution of this module from CPAN, then it includes an example script, <i>ex/ListDevs.plx</i> that will list all current DOS devices and their "native" definition. Again, note that this doesn't work under Win95 nor Win98.</p> <p>The most common such DOS devices include:</p> <dl> <dt id='"//./PhysicalDrive0"'>
<code>"//./PhysicalDrive0"</code>
</dt> <dd> <p>Your entire first hard disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of your hard disk and to use <code>DeviceIoControl</code> to perform miscellaneous queries and operations to the hard disk. Writing raw sectors and certain other operations can seriously damage your files or the function of your computer.</p> <p>Locking this for exclusive access [by specifying <code>0</code> for <code>$uShare</code>] doesn't prevent access to the partitions on the disk nor their file systems. So other processes can still access any raw sectors within a partition and can use the file system on the disk as usual.</p> </dd> <dt id='"//./C:"'>
<code>"//./C:"</code>
</dt> <dd> <p>Your <i>C:</i> partition. Doesn't work under Windows 95. This allows you to read or write raw sectors of that partition and to use <code>DeviceIoControl</code> to perform miscellaneous queries and operations to the partition. Writing raw sectors and certain other operations can seriously damage your files or the function of your computer.</p> <p>Locking this for exclusive access doesn't prevent access to the physical drive that the partition is on so other processes can still access the raw sectors that way. Locking this for exclusive access <b>does</b> prevent other processes from opening the same raw partition and <b>does</b> prevent access to the file system on it. It even prevents the current process from accessing the file system on that partition.</p> </dd> <dt id='"//./A:"'>
<code>"//./A:"</code>
</dt> <dd> <p>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use <code>DeviceIoControl</code> to perform miscellaneous queries and operations to the floppy disk or drive.</p> <p>Locking this for exclusive access prevents all access to the floppy.</p> </dd> <dt id='"//./PIPE/PipeName"'>
<code>"//./PIPE/PipeName"</code>
</dt> <dd> <p>A named pipe, created via <code>CreateNamedPipe</code>.</p> </dd> </dl> <p><code>$uAccess</code> is an unsigned value with bits set indicating the type of access desired. Usually either <code>0</code> ["query" access], <code>GENERIC_READ</code>, <code>GENERIC_WRITE</code>, <code>GENERIC_READ|GENERIC_WRITE</code>, or <code>GENERIC_ALL</code>. More specific types of access can be specified, such as <code>FILE_APPEND_DATA</code> or <code>FILE_READ_EA</code>.</p> <p><code>$uShare</code> controls how the file is shared, that is, whether other processes can have read, write, and/or delete access to the file while we have it opened. <code>$uShare</code> is an unsigned value with zero or more of these bits set: <code>FILE_SHARE_READ</code>, <code>FILE_SHARE_WRITE</code>, and <code>FILE_SHARE_DELETE</code>.</p> <p>If another process currently has read, write, and/or delete access to the file and you don't allow that level of sharing, then your call to <code>CreateFile</code> will fail. If you requested read, write, and/or delete access and another process already has the file open but doesn't allow that level of sharing, then your call to <code>createFile</code> will fail. Once you have the file open, if another process tries to open it with read, write, and/or delete access and you don't allow that level of sharing, then that process won't be allowed to open the file.</p> <p><code>$pSecAttr</code> should either be <code>[]</code> [for <code>NULL</code>] or a <code>SECURITY_ATTRIBUTES</code> data structure packed into a string. For example, if <code>$pSecDesc</code> contains a <code>SECURITY_DESCRIPTOR</code> structure packed into a string, perhaps via:</p> <pre data-language="perl"><code>RegGetKeySecurity( $key, 4, $pSecDesc, 1024 );</code></pre> <p>then you can set <code>$pSecAttr</code> via:</p> <pre data-language="perl"><code>$pSecAttr= pack( "L P i", 12, $pSecDesc, $bInheritHandle );</code></pre> <p><code>$uCreate</code> is one of the following values: <code>OPEN_ALWAYS</code>, <code>OPEN_EXISTING</code>, <code>TRUNCATE_EXISTING</code>, <code>CREATE_ALWAYS</code>, and <code>CREATE_NEW</code>.</p> <p><code>$uFlags</code> is an unsigned value with zero or more bits set indicating attributes to associate with the file [<code>FILE_ATTRIBUTE_*</code> values] or special options [<code>FILE_FLAG_*</code> values].</p> <p>If opening the client side of a named pipe, then you can also set <code>$uFlags</code> to include <code>SECURITY_SQOS_PRESENT</code> along with one of the other <code>SECURITY_*</code> constants to specify the security quality of service to be used.</p> <p><code>$hModel</code> is <code>0</code> [or <code>[]</code>, both of which mean <code>NULL</code>] or a Win32 native handle opened with <code>GENERIC_READ</code> access to a model file from which file attributes and extended attributes are to be copied if a new file gets created.</p> <p>Examples:</p> <pre data-language="perl"><code>$hFlop= CreateFile( "//./A:", GENERIC_READ(),
  FILE_SHARE_READ(), [], OPEN_EXISTING(), 0, [] )
  or  die "Can't prevent others from writing to floppy: $^E\n";
$hDisk= CreateFile( $sFilePath, FILE_READ_ATTRIBUTES(),
  FILE_SHARE_READ()|FILE_SHARE_WRITE(), [], OPEN_EXISTING(), 0, [] )
  or  die "Can't read attributes of $sFilePath: $^E\n";
$hTemp= CreateFile( "$ENV{Temp}/temp.$$", GENERIC_WRITE(), 0,
  CREATE_NEW(), FILE_FLAG_DELETE_ON_CLOSE()|attrLetsToBits("hst"), [] )
  or  die "Can't create temporary file, temp.$$: $^E\n";</code></pre> </dd> <dt id="DefineDosDevice">DefineDosDevice</dt>  <dt id="DefineDosDevice(-$uFlags,-$sDosDeviceName,-$sTargetPath-)">
<code>DefineDosDevice( $uFlags, $sDosDeviceName, $sTargetPath )</code>
</dt> <dd> <p>Defines a new DOS device, overrides the current definition of a DOS device, or deletes a definition of a DOS device. Like most routines, returns a true value if successful and a false value [and sets <code>$^E</code> and <code>regLastError()</code>] on failure.</p> <p><code>$sDosDeviceName</code> is the name of a DOS device for which we'd like to add or delete a definition.</p> <p><code>$uFlags</code> is an unsigned value with zero or more of the following bits set:</p> <dl> <dt id="DDD_RAW_TARGET_PATH"><code>DDD_RAW_TARGET_PATH</code></dt> <dd> <p>Indicates that <code>$sTargetPath</code> will be a raw Windows NT object name. This usually means that <code>$sTargetPath</code> starts with <code>"\\Device\\"</code>. Note that you cannot use <code>"/"</code> in place of <code>"\\"</code> in raw target path names.</p> </dd> <dt id="DDD_REMOVE_DEFINITION"><code>DDD_REMOVE_DEFINITION</code></dt> <dd> <p>Requests that a definition be deleted. If <code>$sTargetPath</code> is <code>[]</code> [for <code>NULL</code>], then the most recently added definition for <code>$sDosDeviceName</code> is removed. Otherwise the most recently added definition matching <code>$sTargetPath</code> is removed.</p> <p>If the last definition is removed, then the DOS device name is also deleted.</p> </dd> <dt id="DDD_EXACT_MATCH_ON_REMOVE"><code>DDD_EXACT_MATCH_ON_REMOVE</code></dt> <dd> <p>When deleting a definition, this bit causes each <code>$sTargetPath</code> to be compared to the full-length definition when searching for the most recently added match. If this bit is not set, then <code>$sTargetPath</code> only needs to match a prefix of the definition.</p> </dd> </dl> <p><code>$sTargetPath</code> is the DOS device's specific definition that you wish to add or delete. For <code>DDD_RAW_TARGET_PATH</code>, these usually start with <code>"\\Device\\"</code>. If the <code>DDD_RAW_TARGET_PATH</code> bit is not set, then <code>$sTargetPath</code> is just an ordinary path to some file or directory, providing the functionality of the <b>subst</b> command.</p> </dd> <dt id="DeleteFile">DeleteFile</dt>  <dt id="DeleteFile(-$sFileName-)">
<code>DeleteFile( $sFileName )</code>
</dt> <dd> <p>Deletes the named file. Compared to Perl's <code>unlink</code>, <code>DeleteFile</code> has the advantage of not deleting read-only files. For <b>some</b> versions of Perl, <code>unlink</code> silently calls <code>chmod</code> whether it needs to or not before deleting the file so that files that you have protected by marking them as read-only are not always protected from Perl's <code>unlink</code>.</p> <p>Like most routines, returns a true value if successful and a false value [and sets <code>$^E</code> and <code>regLastError()</code>] on failure.</p> </dd> <dt id="DeviceIoControl">DeviceIoControl</dt>  <dt id="DeviceIoControl(-$hDevice,-$uIoControlCode,-$pInBuf,-$lInBuf,-$opOutBuf,-$lOutBuf,-$olRetBytes,-$pOverlapped-)">
<code>DeviceIoControl( $hDevice, $uIoControlCode, $pInBuf, $lInBuf, $opOutBuf, $lOutBuf, $olRetBytes, $pOverlapped )</code>
</dt> <dd> <p>Requests a special operation on an I/O [input/output] device, such as ejecting a tape or formatting a disk. Like most routines, returns a true value if successful and a false value [and sets <code>$^E</code> and <code>regLastError()</code>] on failure.</p> <p><code>$hDevice</code> is a Win32 native file handle to a device [return value from <code>CreateFile</code>].</p> <p><code>$uIoControlCode</code> is an unsigned value [a <code>IOCTL_*</code> or <code>FSCTL_*</code> constant] indicating the type query or other operation to be performed.</p> <p><code>$pInBuf</code> is <code>[]</code> [for <code>NULL</code>] or a data structure packed into a string. The type of data structure depends on the <code>$uIoControlCode</code> value. <code>$lInBuf</code> is <code>0</code> or the length of the structure in <code>$pInBuf</code>. If <code>$pInBuf</code> is not <code>[]</code> and <code>$lInBuf</code> is <code>0</code>, then <code>$lInBuf</code> will automatically be set to <code>length($pInBuf)</code> for you.</p> <p><code>$opOutBuf</code> is <code>[]</code> [for <code>NULL</code>] or will be set to contain a returned data structure packed into a string. <code>$lOutBuf</code> indicates how much space to allocate in <code>$opOutBuf</code> for <code>DeviceIoControl</code> to store the data structure. If <code>$lOutBuf</code> is a number and <code>$opOutBuf</code> already has a buffer allocated for it that is larger than <code>$lOutBuf</code> bytes, then this larger buffer size will be passed to <code>DeviceIoControl</code>. However, you can force a specific buffer size to be passed to <code>DeviceIoControl</code> by prepending a <code>"="</code> to the front of <code>$lOutBuf</code>.</p> <p><code>$olRetBytes</code> is <code>[]</code> or is a scalar to receive the number of bytes written to <code>$opOutBuf</code>. Even when <code>$olRetBytes</code> is <code>[]</code>, a valid pointer to a <code>DWORD</code> [and not <code>NULL</code>] is passed to <code>DeviceIoControl</code>. In this case, <code>[]</code> just means that you don't care about the value that might be written to <code>$olRetBytes</code>, which is usually the case since you can usually use <code>length($opOutBuf)</code> instead.</p> <p><code>$pOverlapped</code> is <code>[]</code> or is a <code>OVERLAPPED</code> structure packed into a string. This is only useful if <code>$hDevice</code> was opened with the <code>FILE_FLAG_OVERLAPPED</code> flag set.</p> </dd> <dt id="FdGetOsFHandle">FdGetOsFHandle</dt>  <dt id="$hNativeHandle=-FdGetOsFHandle(-$ivFd-)">
<code>$hNativeHandle= FdGetOsFHandle( $ivFd )</code>
</dt> <dd> <p><code>FdGetOsFHandle</code> simply calls <code>_get_osfhandle()</code>. It was renamed to better fit in with the rest the function names of this module, in particular to distinguish it from <code>GetOsFHandle</code>. It takes an integer file descriptor [as from Perl's <code>fileno</code>] and returns the Win32 native file handle associated with that file descriptor or <code>INVALID_HANDLE_VALUE</code> if <code>$ivFd</code> is not an open file descriptor.</p> <p>When you call Perl's <code>open</code> to set a Perl file handle [like <code>STDOUT</code>], Perl calls C's <code>fopen</code> to set a stdio <code>FILE *</code>. C's <code>fopen</code> calls something like Unix's <code>open</code>, that is, Win32's <code>_sopen</code>, to get an integer file descriptor [where 0 is for <code>STDIN</code>, 1 for <code>STDOUT</code>, etc.]. Win32's <code>_sopen</code> calls <code>CreateFile</code> to set a <code>HANDLE</code>, a Win32 native file handle. So every Perl file handle [like <code>STDOUT</code>] has an integer file descriptor associated with it that you can get via <code>fileno</code>. And, under Win32, every file descriptor has a Win32 native file handle associated with it. <code>FdGetOsFHandle</code> lets you get access to that.</p> <p><code>$hNativeHandle</code> is set to <code>INVALID_HANDLE_VALUE</code> [and <code>lastFileError()</code> and <code>$^E</code> are set] if <code>FdGetOsFHandle</code> fails. See also <code>GetOsFHandle</code> which provides a friendlier interface.</p> </dd> <dt id="fileConstant">fileConstant</dt>  <dt id="$value=-fileConstant(-$sConstantName-)">
<code>$value= fileConstant( $sConstantName )</code>
</dt> <dd> <p>Fetch the value of a constant. Returns <code>undef</code> if <code>$sConstantName</code> is not the name of a constant supported by this module. Never sets <code>$!</code> nor <code>$^E</code>.</p> <p>This function is rarely used since you will usually get the value of a constant by having that constant imported into your package by listing the constant name in the <code>use Win32API::File</code> statement and then simply using the constant name in your code [perhaps followed by <code>()</code>]. This function is useful for verifying constant names not in Perl code, for example, after prompting a user to type in a constant name.</p> </dd> <dt id="fileLastError">fileLastError</dt>  <dt id="$svError=-fileLastError();">
<code>$svError= fileLastError();</code>
</dt>  <dt id="fileLastError(-$uError-);">
<code>fileLastError( $uError );</code>
</dt> <dd> <p>Returns the last error encountered by a routine from this module. It is just like <code>$^E</code> except it isn't changed by anything except routines from this module. Ideally you could just use <code>$^E</code>, but current versions of Perl often overwrite <code>$^E</code> before you get a chance to check it and really old versions of Perl don't really support <code>$^E</code> under Win32.</p> <p>Just like <code>$^E</code>, in a numeric context <code>fileLastError()</code> returns the numeric error value while in a string context it returns a text description of the error [actually it returns a Perl scalar that contains both values so <code>$x= fileLastError()</code> causes <code>$x</code> to give different values in string vs. numeric contexts].</p> <p>The last form sets the error returned by future calls to <code>fileLastError()</code> and should not be used often. <code>$uError</code> must be a numeric error code. Also returns the dual-valued version of <code>$uError</code>.</p> </dd> <dt id="GetDriveType">GetDriveType</dt>  <dt id="$uDriveType=-GetDriveType(-$sRootPath-)">
<code>$uDriveType= GetDriveType( $sRootPath )</code>
</dt> <dd> <p>Takes a string giving the path to the root directory of a file system [called a "drive" because every file system is assigned a "drive letter"] and returns an unsigned value indicating the type of drive the file system is on. The return value should be one of:</p> <dl> <dt id="DRIVE_UNKNOWN"><code>DRIVE_UNKNOWN</code></dt> <dd> <p>None of the following.</p> </dd> <dt id="DRIVE_NO_ROOT_DIR"><code>DRIVE_NO_ROOT_DIR</code></dt> <dd> <p>A "drive" that does not have a file system. This can be a drive letter that hasn't been defined or a drive letter assigned to a partition that hasn't been formatted yet.</p> </dd> <dt id="DRIVE_REMOVABLE"><code>DRIVE_REMOVABLE</code></dt> <dd> <p>A floppy diskette drive or other removable media drive, but not a CD-ROM drive.</p> </dd> <dt id="DRIVE_FIXED"><code>DRIVE_FIXED</code></dt> <dd> <p>An ordinary hard disk partition.</p> </dd> <dt id="DRIVE_REMOTE"><code>DRIVE_REMOTE</code></dt> <dd> <p>A network share.</p> </dd> <dt id="DRIVE_CDROM"><code>DRIVE_CDROM</code></dt> <dd> <p>A CD-ROM drive.</p> </dd> <dt id="DRIVE_RAMDISK"><code>DRIVE_RAMDISK</code></dt> <dd> <p>A "ram disk" or memory-resident virtual file system used for high-speed access to small amounts of temporary file space.</p> </dd> </dl> </dd> <dt id="GetFileAttributes">GetFileAttributes</dt>  <dt id="$uAttrs-=-GetFileAttributes(-$sPath-)">
<code>$uAttrs = GetFileAttributes( $sPath )</code>
</dt> <dd> <p>Takes a path string and returns an unsigned value with attribute flags. If it fails, it returns INVALID_FILE_ATTRIBUTES, otherwise it can be one or more of the following values:</p> <dl> <dt id="FILE_ATTRIBUTE_ARCHIVE"><code>FILE_ATTRIBUTE_ARCHIVE</code></dt> <dd> <p>The file or directory is an archive file or directory. Applications use this attribute to mark files for backup or removal.</p> </dd> <dt id="FILE_ATTRIBUTE_COMPRESSED"><code>FILE_ATTRIBUTE_COMPRESSED</code></dt> <dd> <p>The file or directory is compressed. For a file, this means that all of the data in the file is compressed. For a directory, this means that compression is the default for newly created files and subdirectories.</p> </dd> <dt id="FILE_ATTRIBUTE_DEVICE"><code>FILE_ATTRIBUTE_DEVICE</code></dt> <dd> <p>Reserved; do not use.</p> </dd> <dt id="FILE_ATTRIBUTE_DIRECTORY"><code>FILE_ATTRIBUTE_DIRECTORY</code></dt> <dd> <p>The handle identifies a directory.</p> </dd> <dt id="FILE_ATTRIBUTE_ENCRYPTED"><code>FILE_ATTRIBUTE_ENCRYPTED</code></dt> <dd> <p>The file or directory is encrypted. For a file, this means that all data streams in the file are encrypted. For a directory, this means that encryption is the default for newly created files and subdirectories.</p> </dd> <dt id="FILE_ATTRIBUTE_HIDDEN"><code>FILE_ATTRIBUTE_HIDDEN</code></dt> <dd> <p>The file or directory is hidden. It is not included in an ordinary directory listing.</p> </dd> <dt id="FILE_ATTRIBUTE_NORMAL"><code>FILE_ATTRIBUTE_NORMAL</code></dt> <dd> <p>The file or directory has no other attributes set. This attribute is valid only if used alone.</p> </dd> <dt id="FILE_ATTRIBUTE_NOT_CONTENT_INDEXED"><code>FILE_ATTRIBUTE_NOT_CONTENT_INDEXED</code></dt> <dd> <p>The file will not be indexed by the content indexing service.</p> </dd> <dt id="FILE_ATTRIBUTE_OFFLINE"><code>FILE_ATTRIBUTE_OFFLINE</code></dt> <dd> <p>The data of the file is not immediately available. This attribute indicates that the file data has been physically moved to offline storage. This attribute is used by Remote Storage, the hierarchical storage management software. Applications should not arbitrarily change this attribute.</p> </dd> <dt id="FILE_ATTRIBUTE_READONLY"><code>FILE_ATTRIBUTE_READONLY</code></dt> <dd> <p>The file or directory is read-only. Applications can read the file but cannot write to it or delete it. In the case of a directory, applications cannot delete it.</p> </dd> <dt id="FILE_ATTRIBUTE_REPARSE_POINT"><code>FILE_ATTRIBUTE_REPARSE_POINT</code></dt> <dd> <p>The file or directory has an associated reparse point.</p> </dd> <dt id="FILE_ATTRIBUTE_SPARSE_FILE"><code>FILE_ATTRIBUTE_SPARSE_FILE</code></dt> <dd> <p>The file is a sparse file.</p> </dd> <dt id="FILE_ATTRIBUTE_SYSTEM"><code>FILE_ATTRIBUTE_SYSTEM</code></dt> <dd> <p>The file or directory is part of, or is used exclusively by, the operating system.</p> </dd> <dt id="FILE_ATTRIBUTE_TEMPORARY"><code>FILE_ATTRIBUTE_TEMPORARY</code></dt> <dd> <p>The file is being used for temporary storage. File systems avoid writing data back to mass storage if sufficient cache memory is available, because often the application deletes the temporary file shortly after the handle is closed. In that case, the system can entirely avoid writing the data. Otherwise, the data will be written after the handle is closed.</p> </dd> </dl> </dd> <dt id="GetFileType">GetFileType</dt>  <dt id="$uFileType=-GetFileType(-$hFile-)">
<code>$uFileType= GetFileType( $hFile )</code>
</dt> <dd> <p>Takes a Win32 native file handle and returns a <code>FILE_TYPE_*</code> constant indicating the type of the file opened on that handle:</p> <dl> <dt id="FILE_TYPE_UNKNOWN"><code>FILE_TYPE_UNKNOWN</code></dt> <dd> <p>None of the below. Often a special device.</p> </dd> <dt id="FILE_TYPE_DISK"><code>FILE_TYPE_DISK</code></dt> <dd> <p>An ordinary disk file.</p> </dd> <dt id="FILE_TYPE_CHAR"><code>FILE_TYPE_CHAR</code></dt> <dd> <p>What Unix would call a "character special file", that is, a device that works on character streams such as a printer port or a console.</p> </dd> <dt id="FILE_TYPE_PIPE"><code>FILE_TYPE_PIPE</code></dt> <dd> <p>Either a named or anonymous pipe.</p> </dd> </dl> </dd> <dt id="getFileSize">getFileSize</dt>  <dt id="$size=-getFileSize(-$hFile-)">
<code>$size= getFileSize( $hFile )</code>
</dt> <dd> <p>This is a Perl-friendly wrapper for the <code>GetFileSize</code> (below) API call.</p> <p>It takes a Win32 native file handle and returns the size in bytes. Since the size can be a 64 bit value, on non 64 bit integer Perls the value returned will be an object of type <code>Math::BigInt</code>.</p> </dd> <dt id="GetFileSize">GetFileSize</dt>  <dt id="$iSizeLow=-GetFileSize($win32Handle,-$iSizeHigh)">
<code>$iSizeLow= GetFileSize($win32Handle, $iSizeHigh)</code>
</dt> <dd> <p>Returns the size of a file pointed to by <code>$win32Handle</code>, optionally storing the high order 32 bits into <code>$iSizeHigh</code> if it is not <code>[]</code>. If $iSizeHigh is <code>[]</code>, a non-zero value indicates success. Otherwise, on failure the return value will be <code>0xffffffff</code> and <code>fileLastError()</code> will not be <code>NO_ERROR</code>.</p> </dd> <dt id="GetOverlappedResult">GetOverlappedResult</dt>  <dt id="$bRetval=-GetOverlappedResult(-$win32Handle,-$pOverlapped,-$numBytesTransferred,-$bWait-)">
<code>$bRetval= GetOverlappedResult( $win32Handle, $pOverlapped, $numBytesTransferred, $bWait )</code>
</dt> <dd> <p>Used for asynchronous IO in Win32 to get the result of a pending IO operation, such as when a file operation returns <code>ERROR_IO_PENDING</code>. Returns a false value on failure. The <code>$overlapped</code> structure and <code>$numBytesTransferred</code> will be modified with the results of the operation.</p> <p>As far as creating the <code>$pOverlapped</code> structure, you are currently on your own.</p> <p>See <a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getoverlappedresult.asp">http://msdn.microsoft.com/library/default.asp?url=/library/en-us/dllproc/base/getoverlappedresult.asp</a> for more information.</p> </dd> <dt id="GetLogicalDrives">GetLogicalDrives</dt>  <dt id="$uDriveBits=-GetLogicalDrives()">
<code>$uDriveBits= GetLogicalDrives()</code>
</dt> <dd> <p>Returns an unsigned value with one bit set for each drive letter currently defined. If "A:" is currently a valid drive letter, then the <code>1</code> bit will be set in <code>$uDriveBits</code>. If "B:" is valid, then the <code>2</code> bit will be set. If "Z:" is valid, then the <code>2**26</code> [<code>0x4000000</code>] bit will be set.</p> </dd> <dt id="GetLogicalDriveStrings">GetLogicalDriveStrings</dt>  <dt id="$olOutLength=-GetLogicalDriveStrings(-$lBufSize,-$osBuffer-)">
<code>$olOutLength= GetLogicalDriveStrings( $lBufSize, $osBuffer )</code>
</dt> <dd> <p>For each currently defined drive letter, a <code>'\0'</code>-terminated string of the path to the root of its file system is constructed. All of these strings are concatenated into a single larger string and an extra terminating <code>'\0'</code> is added. This larger string is returned in <code>$osBuffer</code>. Note that this includes drive letters that have been defined but that have no file system, such as drive letters assigned to unformatted partitions.</p> <p><code>$lBufSize</code> is the size of the buffer to allocate to store this list of strings. <code>26*4+1</code> is always sufficient and should usually be used.</p> <p><code>$osBuffer</code> is a scalar to be set to contain the constructed string.</p> <p><code>$olOutLength</code> is the number of bytes actually written to <code>$osBuffer</code> but <code>length($osBuffer)</code> can also be used to determine this.</p> <p>For example, on a poorly equipped computer,</p> <pre data-language="perl"><code>GetLogicalDriveStrings( 4*26+1, $osBuffer );</code></pre> <p>might set <code>$osBuffer</code> to the 9-character string, <code>"A:\\\0C:\\\0\0"</code>.</p> </dd> <dt id="GetHandleInformation">GetHandleInformation</dt>  <dt id="GetHandleInformation(-$hObject,-$ouFlags-)">
<code>GetHandleInformation( $hObject, $ouFlags )</code>
</dt> <dd> <p>Retrieves the flags associated with a Win32 native file handle or object handle.</p> <p><code>$hObject</code> is an open Win32 native file handle or an open Win32 native handle to some other type of object.</p> <p><code>$ouFlags</code> will be set to an unsigned value having zero or more of the bits <code>HANDLE_FLAG_INHERIT</code> and <code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code> set. See the <code>":HANDLE_FLAG_"</code> export class for the meanings of these bits.</p> </dd> <dt id="GetOsFHandle">GetOsFHandle</dt>  <dt id="$hNativeHandle=-GetOsFHandle(-FILE-)">
<code>$hNativeHandle= GetOsFHandle( FILE )</code>
</dt> <dd> <p>Takes a Perl file handle [like <code>STDIN</code>] and returns the Win32 native file handle associated with it. See <code>FdGetOsFHandle</code> for more information about Win32 native file handles.</p> <p><code>$hNativeHandle</code> is set to a false value [and <code>lastFileError()</code> and <code>$^E</code> are set] if <code>GetOsFHandle</code> fails. <code>GetOsFHandle</code> returns <code>"0 but true"</code> in the impossible(?) case of the handle having a value of <code>0</code>.</p> </dd> <dt id="GetVolumeInformation">GetVolumeInformation</dt>  <dt id="GetVolumeInformation(-$sRootPath,-$osVolName,-$lVolName,-$ouSerialNum,-$ouMaxNameLen,-$ouFsFlags,-$osFsType,-$lFsType-)">
<code>GetVolumeInformation( $sRootPath, $osVolName, $lVolName, $ouSerialNum, $ouMaxNameLen, $ouFsFlags, $osFsType, $lFsType )</code>
</dt> <dd> <p>Gets information about a file system volume, returning a true value if successful. On failure, returns a false value and sets <code>fileLastError()</code> and <code>$^E</code>.</p> <p><code>$sRootPath</code> is a string specifying the path to the root of the file system, for example, <code>"C:/"</code>.</p> <p><code>$osVolName</code> is a scalar to be set to the string representing the volume name, also called the file system label. <code>$lVolName</code> is the number of bytes to allocate for the <code>$osVolName</code> buffer [see <a href="#Buffer-Sizes">"Buffer Sizes"</a> for more information].</p> <p><code>$ouSerialNum</code> is <code>[]</code> [for <code>NULL</code>] or will be set to the numeric value of the volume's serial number.</p> <p><code>$ouMaxNameLen</code> is <code>[]</code> [for <code>NULL</code>] or will be set to the maximum length allowed for a file name or directory name within the file system.</p> <p><code>$osFsType</code> is a scalar to be set to the string representing the file system type, such as <code>"FAT"</code> or <code>"NTFS"</code>. <code>$lFsType</code> is the number of bytes to allocate for the <code>$osFsType</code> buffer [see <a href="#Buffer-Sizes">"Buffer Sizes"</a> for more information].</p> <p><code>$ouFsFlags</code> is <code>[]</code> [for <code>NULL</code>] or will be set to an unsigned integer with bits set indicating properties of the file system:</p> <dl> <dt id="FS_CASE_IS_PRESERVED"><code>FS_CASE_IS_PRESERVED</code></dt> <dd> <p>The file system preserves the case of file names [usually true]. That is, it doesn't change the case of file names such as forcing them to upper- or lower-case.</p> </dd> <dt id="FS_CASE_SENSITIVE"><code>FS_CASE_SENSITIVE</code></dt> <dd> <p>The file system supports the ability to not ignore the case of file names [but might ignore case the way you are using it]. That is, the file system has the ability to force you to get the letter case of a file's name exactly right to be able to open it. This is true for "NTFS" file systems, even though case in file names is usually still ignored.</p> </dd> <dt id="FS_UNICODE_STORED_ON_DISK"><code>FS_UNICODE_STORED_ON_DISK</code></dt> <dd> <p>The file system preserves Unicode in file names [true for "NTFS"].</p> </dd> <dt id="FS_PERSISTENT_ACLS"><code>FS_PERSISTENT_ACLS</code></dt> <dd> <p>The file system supports setting Access Control Lists on files [true for "NTFS"].</p> </dd> <dt id="FS_FILE_COMPRESSION"><code>FS_FILE_COMPRESSION</code></dt> <dd> <p>The file system supports compression on a per-file basis [true for "NTFS"].</p> </dd> <dt id="FS_VOL_IS_COMPRESSED"><code>FS_VOL_IS_COMPRESSED</code></dt> <dd> <p>The entire file system is compressed such as via "DoubleSpace".</p> </dd> </dl> </dd> <dt id="IsRecognizedPartition">IsRecognizedPartition</dt>  <dt id="IsRecognizedPartition(-$ivPartitionType-)">
<code>IsRecognizedPartition( $ivPartitionType )</code>
</dt> <dd> <p>Takes a partition type and returns whether that partition type is supported under Win32. <code>$ivPartitonType</code> is an integer value as from the operating system byte of a hard disk's DOS-compatible partition table [that is, a partition table for x86-based Win32, not, for example, one used with Windows NT for Alpha processors]. For example, the <code>PartitionType</code> member of the <code>PARTITION_INFORMATION</code> structure.</p> <p>Common values for <code>$ivPartitionType</code> include <code>PARTITION_FAT_12==1</code>, <code>PARTITION_FAT_16==4</code>, <code>PARTITION_EXTENDED==5</code>, <code>PARTITION_FAT32==0xB</code>.</p> </dd> <dt id="IsContainerPartition">IsContainerPartition</dt>  <dt id="IsContainerPartition(-$ivPartitionType-)">
<code>IsContainerPartition( $ivPartitionType )</code>
</dt> <dd> <p>Takes a partition type and returns whether that partition is a "container" partition that is supported under Win32, that is, whether it is an "extended" partition that can contain "logical" partitions. <code>$ivPartitonType</code> is as for <code>IsRecognizedPartition</code>.</p> </dd> <dt id="MoveFile">MoveFile</dt>  <dt id="MoveFile(-$sOldName,-$sNewName-)">
<code>MoveFile( $sOldName, $sNewName )</code>
</dt> <dd> <p>Renames a file or directory. <code>$sOldName</code> is the name of the existing file or directory that is to be renamed. <code>$sNewName</code> is the new name to give the file or directory. Returns a true value if the move succeeds. For failure, returns a false value and sets <code>fileLastErorr()</code> and <code>$^E</code> to the reason for the failure.</p> <p>Files can be "renamed" between file systems and the file contents and some attributes will be moved. Directories can only be renamed within one file system. If there is already a file or directory named <code>$sNewName</code>, then <code>MoveFile</code> will fail.</p> </dd> <dt id="MoveFileEx">MoveFileEx</dt>  <dt id="MoveFileEx(-$sOldName,-$sNewName,-$uFlags-)">
<code>MoveFileEx( $sOldName, $sNewName, $uFlags )</code>
</dt> <dd> <p>Renames a file or directory. <code>$sOldName</code> is the name of the existing file or directory that is to be renamed. <code>$sNewName</code> is the new name to give the file or directory. Returns a true value if the move succeeds. For failure, returns a false value and sets <code>fileLastErorr()</code> and <code>$^E</code> to the reason for the failure.</p> <p><code>$uFlags</code> is an unsigned value with zero or more of the following bits set:</p> <dl> <dt id="MOVEFILE_REPLACE_EXISTING"><code>MOVEFILE_REPLACE_EXISTING</code></dt> <dd> <p>If this bit is set and a file [but not a directory] named <code>$sNewName</code> already exists, then it will be replaced by <code>$sOldName</code>. If this bit is not set then <code>MoveFileEx</code> will fail rather than replace an existing <code>$sNewName</code>.</p> </dd> <dt id="MOVEFILE_COPY_ALLOWED"><code>MOVEFILE_COPY_ALLOWED</code></dt> <dd> <p>Allows files [but not directories] to be moved between file systems by copying the <code>$sOldName</code> file data and some attributes to <code>$sNewName</code> and then deleting <code>$sOldName</code>. If this bit is not set [or if <code>$sOldName</code> denotes a directory] and <code>$sNewName</code> refers to a different file system than <code>$sOldName</code>, then <code>MoveFileEx</code> will fail.</p> </dd> <dt id="MOVEFILE_DELAY_UNTIL_REBOOT"><code>MOVEFILE_DELAY_UNTIL_REBOOT</code></dt> <dd> <p>Preliminary verifications are made and then an entry is added to the Registry to cause the rename [or delete] operation to be done the next time this copy of the operating system is booted [right after any automatic file system checks have completed]. This is not supported under Windows 95.</p> <p>When this bit is set, <code>$sNewName</code> can be <code>[]</code> [for <code>NULL</code>] to indicate that <code>$sOldName</code> should be deleted during the next boot rather than renamed.</p> <p>Setting both the <code>MOVEFILE_COPY_ALLOWED</code> and <code>MOVEFILE_DELAY_UNTIL_REBOOT</code> bits will cause <code>MoveFileEx</code> to fail.</p> </dd> <dt id="MOVEFILE_WRITE_THROUGH"><code>MOVEFILE_WRITE_THROUGH</code></dt> <dd> <p>Ensures that <code>MoveFileEx</code> won't return until the operation has finished and been flushed to disk. This is not supported under Windows 95. Only affects file renames to another file system, forcing a buffer flush at the end of the copy operation.</p> </dd> </dl> </dd> <dt id="OsFHandleOpen">OsFHandleOpen</dt>  <dt id="OsFHandleOpen(-FILE,-$hNativeHandle,-$sMode-)">
<code>OsFHandleOpen( FILE, $hNativeHandle, $sMode )</code>
</dt> <dd> <p>Opens a Perl file handle based on an already open Win32 native file handle [much like C's <code>fdopen()</code> does with a file descriptor]. Returns a true value if the open operation succeeded. For failure, returns a false value and sets <code>$!</code> [and possibly <code>fileLastError()</code> and <code>$^E</code>] to the reason for the failure.</p> <p><code>FILE</code> is a Perl file handle [in any of the supported forms, a bareword, a string, a typeglob, or a reference to a typeglob] that will be opened. If <code>FILE</code> is already open, it will automatically be closed before it is reopened.</p> <p><code>$hNativeHandle</code> is an open Win32 native file handle, probably the return value from <code>CreateFile</code> or <code>createFile</code>.</p> <p><code>$sMode</code> is string of zero or more letters from <code>"rwatb"</code>. These are translated into a combination <code>O_RDONLY</code> [<code>"r"</code>], <code>O_WRONLY</code> [<code>"w"</code>], <code>O_RDWR</code> [<code>"rw"</code>], <code>O_APPEND</code> [<code>"a"</code>], <code>O_TEXT</code> [<code>"t"</code>], and <code>O_BINARY</code> [<code>"b"</code>] flags [see the <a href="fcntl.html">Fcntl</a> module] that is passed to <code>OsFHandleOpenFd</code>. Currently only <code>O_APPEND</code> and <code>O_TEXT</code> have any significance.</p> <p>Also, a <code>"r"</code> and/or <code>"w"</code> in <code>$sMode</code> is used to decide how the file descriptor is converted into a Perl file handle, even though this doesn't appear to make a difference. One of the following is used:</p> <pre data-language="perl"><code>open( FILE, "&lt;&amp;=".$ivFd )	# "r" w/o "w"
open( FILE, "&gt;&amp;=".$ivFd )	# "w" w/o "r"
open( FILE, "+&lt;&amp;=".$ivFd )	# both "r" and "w"</code></pre> <p><code>OsFHandleOpen</code> eventually calls the Win32-specific C routine <code>_open_osfhandle()</code> or Perl's "improved" version called <code>win32_open_osfhandle()</code>. Prior to Perl5.005, C's <code>_open_osfhandle()</code> is called which will fail if <code>GetFileType($hNativeHandle)</code> would return <code>FILE_TYPE_UNKNOWN</code>. For Perl5.005 and later, <code>OsFHandleOpen</code> calls <code>win32_open_osfhandle()</code> from the Perl DLL which doesn't have this restriction.</p> </dd> <dt id="OsFHandleOpenFd">OsFHandleOpenFd</dt>  <dt id="$ivFD=-OsFHandleOpenFd(-$hNativeHandle,-$uMode-)">
<code>$ivFD= OsFHandleOpenFd( $hNativeHandle, $uMode )</code>
</dt> <dd> <p>Opens a file descriptor [<code>$ivFD</code>] based on an already open Win32 native file handle, <code>$hNativeHandle</code>. This just calls the Win32-specific C routine <code>_open_osfhandle()</code> or Perl's "improved" version called <code>win32_open_osfhandle()</code>. Prior to Perl5.005 and in Cygwin Perl, C's <code>_open_osfhandle()</code> is called which will fail if <code>GetFileType($hNativeHandle)</code> would return <code>FILE_TYPE_UNKNOWN</code>. For Perl5.005 and later, <code>OsFHandleOpenFd</code> calls <code>win32_open_osfhandle()</code> from the Perl DLL which doesn't have this restriction.</p> <p><code>$uMode</code> the logical combination of zero or more <code>O_*</code> constants exported by the <code>Fcntl</code> module. Currently only <code>O_APPEND</code> and <code>O_TEXT</code> have any significance.</p> <p><code>$ivFD</code> will be non-negative if the open operation was successful. For failure, <code>-1</code> is returned and <code>$!</code> [and possibly <code>fileLastError()</code> and <code>$^E</code>] is set to the reason for the failure.</p> </dd> <dt id="QueryDosDevice">QueryDosDevice</dt>  <dt id="$olTargetLen=-QueryDosDevice(-$sDosDeviceName,-$osTargetPath,-$lTargetBuf-)">
<code>$olTargetLen= QueryDosDevice( $sDosDeviceName, $osTargetPath, $lTargetBuf )</code>
</dt> <dd> <p>Looks up the definition of a given "DOS" device name, yielding the active Windows NT native device name along with any currently dormant definitions.</p> <p><code>$sDosDeviceName</code> is the name of the "DOS" device whose definitions we want. For example, <code>"C:"</code>, <code>"COM1"</code>, or <code>"PhysicalDrive0"</code>. If <code>$sDosDeviceName</code> is <code>[]</code> [for <code>NULL</code>], the list of all DOS device names is returned instead.</p> <p><code>$osTargetPath</code> will be assigned a string containing the list of definitions. The definitions are each <code>'\0'</code>-terminate and are concatenated into the string, most recent first, with an extra <code>'\0'</code> at the end of the whole string [see <code>GetLogicalDriveStrings</code> for a sample of this format].</p> <p><code>$lTargetBuf</code> is the size [in bytes] of the buffer to allocate for <code>$osTargetPath</code>. See <a href="#Buffer-Sizes">"Buffer Sizes"</a> for more information.</p> <p><code>$olTargetLen</code> is set to the number of bytes written to <code>$osTargetPath</code> but you can also use <code>length($osTargetPath)</code> to determine this.</p> <p>For failure, <code>0</code> is returned and <code>fileLastError()</code> and <code>$^E</code> are set to the reason for the failure.</p> </dd> <dt id="ReadFile">ReadFile</dt>  <dt id="ReadFile(-$hFile,-$opBuffer,-$lBytes,-$olBytesRead,-$pOverlapped-)">
<code>ReadFile( $hFile, $opBuffer, $lBytes, $olBytesRead, $pOverlapped )</code>
</dt> <dd> <p>Reads bytes from a file or file-like device. Returns a true value if the read operation was successful. For failure, returns a false value and sets <code>fileLastError()</code> and <code>$^E</code> for the reason for the failure.</p> <p><code>$hFile</code> is a Win32 native file handle that is already open to the file or device to read from.</p> <p><code>$opBuffer</code> will be set to a string containing the bytes read.</p> <p><code>$lBytes</code> is the number of bytes you would like to read. <code>$opBuffer</code> is automatically initialized to have a buffer large enough to hold that many bytes. Unlike other buffer sizes, <code>$lBytes</code> does not need to have a <code>"="</code> prepended to it to prevent a larger value to be passed to the underlying Win32 <code>ReadFile</code> API. However, a leading <code>"="</code> will be silently ignored, even if Perl warnings are enabled.</p> <p>If <code>$olBytesRead</code> is not <code>[]</code>, it will be set to the actual number of bytes read, though <code>length($opBuffer)</code> can also be used to determine this.</p> <p><code>$pOverlapped</code> is <code>[]</code> or is a <code>OVERLAPPED</code> structure packed into a string. This is only useful if <code>$hFile</code> was opened with the <code>FILE_FLAG_OVERLAPPED</code> flag set.</p> </dd> <dt id="SetErrorMode">SetErrorMode</dt>  <dt id="$uOldMode=-SetErrorMode(-$uNewMode-)">
<code>$uOldMode= SetErrorMode( $uNewMode )</code>
</dt> <dd> <p>Sets the mode controlling system error handling <b>and</b> returns the previous mode value. Both <code>$uOldMode</code> and <code>$uNewMode</code> will have zero or more of the following bits set:</p> <dl> <dt id="SEM_FAILCRITICALERRORS"><code>SEM_FAILCRITICALERRORS</code></dt> <dd> <p>If set, indicates that when a critical error is encountered, the call that triggered the error fails immediately. Normally this bit is not set, which means that a critical error causes a dialogue box to appear notifying the desktop user that some application has triggered a critical error. The dialogue box allows the desktop user to decide whether the critical error is returned to the process, is ignored, or the offending operation is retried.</p> <p>This affects the <code>CreateFile</code> and <code>GetVolumeInformation</code> calls.</p> <p>Setting this bit is useful for allowing you to check whether a floppy diskette is in the floppy drive.</p> </dd> <dt id="SEM_NOALIGNMENTFAULTEXCEPT"><code>SEM_NOALIGNMENTFAULTEXCEPT</code></dt> <dd> <p>If set, this causes memory access misalignment faults to be automatically fixed in a manner invisible to the process. This flag is ignored on x86-based versions of Windows NT. This flag is not supported on Windows 95.</p> </dd> <dt id="SEM_NOGPFAULTERRORBOX"><code>SEM_NOGPFAULTERRORBOX</code></dt> <dd> <p>If set, general protection faults do not generate a dialogue box but can instead be handled by the process via an exception handler. This bit should not be set by programs that don't know how to handle such faults.</p> </dd> <dt id="SEM_NOOPENFILEERRORBOX"><code>SEM_NOOPENFILEERRORBOX</code></dt> <dd> <p>If set, then when an attempt to continue reading from or writing to an already open file [usually on a removable medium like a floppy diskette] finds the file no longer available, the call will immediately fail. Normally this bit is not set, which means that instead a dialogue box will appear notifying the desktop user that some application has run into this problem. The dialogue box allows the desktop user to decide whether the failure is returned to the process, is ignored, or the offending operation is retried.</p> <p>This affects the <code>ReadFile</code> and <code>WriteFile</code> calls.</p> </dd> </dl> </dd> <dt id="setFilePointer">setFilePointer</dt>  <dt id="$uNewPos-=-setFilePointer(-$hFile,-$ivOffset,-$uFromWhere-)">
<code>$uNewPos = setFilePointer( $hFile, $ivOffset, $uFromWhere )</code>
</dt> <dd> <p>This is a perl-friendly wrapper for the SetFilePointer API (below). <code>$ivOffset</code> can be a 64 bit integer or <code>Math::BigInt</code> object if your Perl doesn't have 64 bit integers. The return value is the new offset and will likewise be a 64 bit integer or a <code>Math::BigInt</code> object.</p> </dd> <dt id="SetFilePointer">SetFilePointer</dt>  <dt id="$uNewPos-=-SetFilePointer(-$hFile,-$ivOffset,-$ioivOffsetHigh,-$uFromWhere-)">
<code>$uNewPos = SetFilePointer( $hFile, $ivOffset, $ioivOffsetHigh, $uFromWhere )</code>
</dt> <dd> <p>The native Win32 version of <code>seek()</code>. <code>SetFilePointer</code> sets the position within a file where the next read or write operation will start from.</p> <p><code>$hFile</code> is a Win32 native file handle.</p> <p><code>$uFromWhere</code> is either <code>FILE_BEGIN</code>, <code>FILE_CURRENT</code>, or <code>FILE_END</code>, indicating that the new file position is being specified relative to the beginning of the file, the current file pointer, or the end of the file, respectively.</p> <p><code>$ivOffset</code> is [if <code>$ioivOffsetHigh</code> is <code>[]</code>] the offset [in bytes] to the new file position from the position specified via <code>$uFromWhere</code>. If <code>$ioivOffsetHigh</code> is not <code>[]</code>, then <code>$ivOffset</code> is converted to an unsigned value to be used as the low-order 4 bytes of the offset.</p> <p><code>$ioivOffsetHigh</code> can be <code>[]</code> [for <code>NULL</code>] to indicate that you are only specifying a 4-byte offset and the resulting file position will be 0xFFFFFFFE or less [just under 4GB]. Otherwise <code>$ioivOfffsetHigh</code> starts out with the high-order 4 bytes [signed] of the offset and gets set to the [unsigned] high-order 4 bytes of the resulting file position.</p> <p>The underlying <code>SetFilePointer</code> returns <code>0xFFFFFFFF</code> to indicate failure, but if <code>$ioivOffsetHigh</code> is not <code>[]</code>, you would also have to check <code>$^E</code> to determine whether <code>0xFFFFFFFF</code> indicates an error or not. <code>Win32API::File::SetFilePointer</code> does this checking for you and returns a false value if and only if the underlying <code>SetFilePointer</code> failed. For this reason, <code>$uNewPos</code> is set to <code>"0 but true"</code> if you set the file pointer to the beginning of the file [or any position with 0 for the low-order 4 bytes].</p> <p>So the return value will be true if the seek operation was successful. For failure, a false value is returned and <code>fileLastError()</code> and <code>$^E</code> are set to the reason for the failure.</p> </dd> <dt id="SetHandleInformation">SetHandleInformation</dt>  <dt id="SetHandleInformation(-$hObject,-$uMask,-$uFlags-)">
<code>SetHandleInformation( $hObject, $uMask, $uFlags )</code>
</dt> <dd> <p>Sets the flags associated with a Win32 native file handle or object handle. Returns a true value if the operation was successful. For failure, returns a false value and sets <code>fileLastError()</code> and <code>$^E</code> for the reason for the failure.</p> <p><code>$hObject</code> is an open Win32 native file handle or an open Win32 native handle to some other type of object.</p> <p><code>$uMask</code> is an unsigned value having one or more of the bits <code>HANDLE_FLAG_INHERIT</code> and <code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code> set. Only bits set in <code>$uMask</code> will be modified by <code>SetHandleInformation</code>.</p> <p><code>$uFlags</code> is an unsigned value having zero or more of the bits <code>HANDLE_FLAG_INHERIT</code> and <code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code> set. For each bit set in <code>$uMask</code>, the corresponding bit in the handle's flags is set to the value of the corresponding bit in <code>$uFlags</code>.</p> <p>If <code>$uOldFlags</code> were the value of the handle's flags before the call to <code>SetHandleInformation</code>, then the value of the handle's flags afterward would be:</p> <pre data-language="perl"><code>( $uOldFlags &amp; ~$uMask ) | ( $uFlags &amp; $uMask )</code></pre> <p>[at least as far as the <code>HANDLE_FLAG_INHERIT</code> and <code>HANDLE_FLAG_PROTECT_FROM_CLOSE</code> bits are concerned.]</p> <p>See the <code>":HANDLE_FLAG_"</code> export class for the meanings of these bits.</p> </dd> <dt id="WriteFile">WriteFile</dt>  <dt id="WriteFile(-$hFile,-$pBuffer,-$lBytes,-$ouBytesWritten,-$pOverlapped-)">
<code>WriteFile( $hFile, $pBuffer, $lBytes, $ouBytesWritten, $pOverlapped )</code>
</dt> <dd> <p>Write bytes to a file or file-like device. Returns a true value if the operation was successful. For failure, returns a false value and sets <code>fileLastError()</code> and <code>$^E</code> for the reason for the failure.</p> <p><code>$hFile</code> is a Win32 native file handle that is already open to the file or device to be written to.</p> <p><code>$pBuffer</code> is a string containing the bytes to be written.</p> <p><code>$lBytes</code> is the number of bytes you would like to write. If <code>$pBuffer</code> is not at least <code>$lBytes</code> long, <code>WriteFile</code> croaks. You can specify <code>0</code> for <code>$lBytes</code> to write <code>length($pBuffer)</code> bytes. A leading <code>"="</code> on <code>$lBytes</code> will be silently ignored, even if Perl warnings are enabled.</p> <p><code>$ouBytesWritten</code> will be set to the actual number of bytes written unless you specify it as <code>[]</code>.</p> <p><code>$pOverlapped</code> is <code>[]</code> or is an <code>OVERLAPPED</code> structure packed into a string. This is only useful if <code>$hFile</code> was opened with the <code>FILE_FLAG_OVERLAPPED</code> flag set.</p> </dd> </dl> </dd> <dt id='":FuncA"'>
<code>":FuncA"</code>
</dt> <dd> <p>The ASCII-specific functions. Each of these is just the same as the version without the trailing "A".</p> <pre data-language="perl"><code class="plaintext">CopyFileA
CreateFileA
DefineDosDeviceA
DeleteFileA
GetDriveTypeA
GetFileAttributesA
GetLogicalDriveStringsA
GetVolumeInformationA
MoveFileA
MoveFileExA
QueryDosDeviceA</code></pre> </dd> <dt id='":FuncW"'>
<code>":FuncW"</code>
</dt> <dd> <p>The wide-character-specific (Unicode) functions. Each of these is just the same as the version without the trailing "W" except that strings are expected in Unicode and some lengths are measured as number of <code>WCHAR</code>s instead of number of bytes, as indicated below.</p> <dl> <dt id="CopyFileW">CopyFileW</dt>  <dt id="CopyFileW(-$swOldFileName,-$swNewFileName,-$bFailIfExists-)">
<code>CopyFileW( $swOldFileName, $swNewFileName, $bFailIfExists )</code>
</dt> <dd> <p><code>$swOldFileName</code> and <code>$swNewFileName</code> are Unicode strings.</p> </dd> <dt id="CreateFileW">CreateFileW</dt>  <dt id="$hObject=-CreateFileW(-$swPath,-$uAccess,-$uShare,-$pSecAttr,-$uCreate,-$uFlags,-$hModel-)">
<code>$hObject= CreateFileW( $swPath, $uAccess, $uShare, $pSecAttr, $uCreate, $uFlags, $hModel )</code>
</dt> <dd> <p><code>$swPath</code> is Unicode.</p> </dd> <dt id="DefineDosDeviceW">DefineDosDeviceW</dt>  <dt id="DefineDosDeviceW(-$uFlags,-$swDosDeviceName,-$swTargetPath-)">
<code>DefineDosDeviceW( $uFlags, $swDosDeviceName, $swTargetPath )</code>
</dt> <dd> <p><code>$swDosDeviceName</code> and <code>$swTargetPath</code> are Unicode.</p> </dd> <dt id="DeleteFileW">DeleteFileW</dt>  <dt id="DeleteFileW(-$swFileName-)">
<code>DeleteFileW( $swFileName )</code>
</dt> <dd> <p><code>$swFileName</code> is Unicode.</p> </dd> <dt id="GetDriveTypeW">GetDriveTypeW</dt>  <dt id="$uDriveType=-GetDriveTypeW(-$swRootPath-)">
<code>$uDriveType= GetDriveTypeW( $swRootPath )</code>
</dt> <dd> <p><code>$swRootPath</code> is Unicode.</p> </dd> <dt id="GetFileAttributesW">GetFileAttributesW</dt>  <dt id="$uAttrs=-GetFileAttributesW(-$swPath-)">
<code>$uAttrs= GetFileAttributesW( $swPath )</code>
</dt> <dd> <p><code>$swPath</code> is Unicode.</p> </dd> <dt id="GetLogicalDriveStringsW">GetLogicalDriveStringsW</dt>  <dt id="$olwOutLength=-GetLogicalDriveStringsW(-$lwBufSize,-$oswBuffer-)">
<code>$olwOutLength= GetLogicalDriveStringsW( $lwBufSize, $oswBuffer )</code>
</dt> <dd> <p>Unicode is stored in <code>$oswBuffer</code>. <code>$lwBufSize</code> and <code>$olwOutLength</code> are measured as number of <code>WCHAR</code>s.</p> </dd> <dt id="GetVolumeInformationW">GetVolumeInformationW</dt>  <dt id="GetVolumeInformationW(-$swRootPath,-$oswVolName,-$lwVolName,-$ouSerialNum,-$ouMaxNameLen,-$ouFsFlags,-$oswFsType,-$lwFsType-)">
<code>GetVolumeInformationW( $swRootPath, $oswVolName, $lwVolName, $ouSerialNum, $ouMaxNameLen, $ouFsFlags, $oswFsType, $lwFsType )</code>
</dt> <dd> <p><code>$swRootPath</code> is Unicode and Unicode is written to <code>$oswVolName</code> and <code>$oswFsType</code>. <code>$lwVolName</code> and <code>$lwFsType</code> are measures as number of <code>WCHAR</code>s.</p> </dd> <dt id="MoveFileW">MoveFileW</dt>  <dt id="MoveFileW(-$swOldName,-$swNewName-)">
<code>MoveFileW( $swOldName, $swNewName )</code>
</dt> <dd> <p><code>$swOldName</code> and <code>$swNewName</code> are Unicode.</p> </dd> <dt id="MoveFileExW">MoveFileExW</dt>  <dt id="MoveFileExW(-$swOldName,-$swNewName,-$uFlags-)">
<code>MoveFileExW( $swOldName, $swNewName, $uFlags )</code>
</dt> <dd> <p><code>$swOldName</code> and <code>$swNewName</code> are Unicode.</p> </dd> <dt id="QueryDosDeviceW">QueryDosDeviceW</dt>  <dt id="$olwTargetLen=-QueryDosDeviceW(-$swDeviceName,-$oswTargetPath,-$lwTargetBuf-)">
<code>$olwTargetLen= QueryDosDeviceW( $swDeviceName, $oswTargetPath, $lwTargetBuf )</code>
</dt> <dd> <p><code>$swDeviceName</code> is Unicode and Unicode is written to <code>$oswTargetPath</code>. <code>$lwTargetBuf</code> and <code>$olwTargetLen</code> are measured as number of <code>WCHAR</code>s.</p> </dd> </dl> </dd> <dt id='":Misc"'>
<code>":Misc"</code>
</dt> <dd> <p>Miscellaneous constants. Used for the <code>$uCreate</code> argument of <code>CreateFile</code> or the <code>$uFromWhere</code> argument of <code>SetFilePointer</code>. Plus <code>INVALID_HANDLE_VALUE</code>, which you usually won't need to check for since most routines translate it into a false value.</p> <pre data-language="perl"><code class="plaintext">CREATE_ALWAYS		CREATE_NEW		OPEN_ALWAYS
OPEN_EXISTING		TRUNCATE_EXISTING	INVALID_HANDLE_VALUE
FILE_BEGIN		FILE_CURRENT		FILE_END</code></pre> </dd> <dt id='":DDD_"'>
<code>":DDD_"</code>
</dt> <dd> <p>Constants for the <code>$uFlags</code> argument of <code>DefineDosDevice</code>.</p> <pre data-language="perl"><code class="plaintext">DDD_EXACT_MATCH_ON_REMOVE
DDD_RAW_TARGET_PATH
DDD_REMOVE_DEFINITION</code></pre> </dd> <dt id='":DRIVE_"'>
<code>":DRIVE_"</code>
</dt> <dd> <p>Constants returned by <code>GetDriveType</code>.</p> <pre data-language="perl"><code class="plaintext">DRIVE_UNKNOWN		DRIVE_NO_ROOT_DIR	DRIVE_REMOVABLE
DRIVE_FIXED		DRIVE_REMOTE		DRIVE_CDROM
DRIVE_RAMDISK</code></pre> </dd> <dt id='":FILE_"'>
<code>":FILE_"</code>
</dt> <dd> <p>Specific types of access to files that can be requested via the <code>$uAccess</code> argument to <code>CreateFile</code>.</p> <pre data-language="perl"><code class="plaintext">FILE_READ_DATA			FILE_LIST_DIRECTORY
FILE_WRITE_DATA			FILE_ADD_FILE
FILE_APPEND_DATA		FILE_ADD_SUBDIRECTORY
FILE_CREATE_PIPE_INSTANCE	FILE_READ_EA
FILE_WRITE_EA			FILE_EXECUTE
FILE_TRAVERSE			FILE_DELETE_CHILD
FILE_READ_ATTRIBUTES		FILE_WRITE_ATTRIBUTES
FILE_ALL_ACCESS			FILE_GENERIC_READ
FILE_GENERIC_WRITE		FILE_GENERIC_EXECUTE )],</code></pre> </dd> <dt id='":FILE_ATTRIBUTE_"'>
<code>":FILE_ATTRIBUTE_"</code>
</dt> <dd> <p>File attribute constants. Returned by <code>attrLetsToBits</code> and used in the <code>$uFlags</code> argument to <code>CreateFile</code>.</p> <pre data-language="perl"><code class="plaintext">FILE_ATTRIBUTE_ARCHIVE			FILE_ATTRIBUTE_COMPRESSED
FILE_ATTRIBUTE_HIDDEN			FILE_ATTRIBUTE_NORMAL
FILE_ATTRIBUTE_OFFLINE			FILE_ATTRIBUTE_READONLY
FILE_ATTRIBUTE_SYSTEM			FILE_ATTRIBUTE_TEMPORARY</code></pre> <p>In addition, <code>GetFileAttributes</code> can return these constants (or INVALID_FILE_ATTRIBUTES in case of an error).</p> <pre data-language="perl"><code class="plaintext">FILE_ATTRIBUTE_DEVICE			FILE_ATTRIBUTE_DIRECTORY
FILE_ATTRIBUTE_ENCRYPTED		FILE_ATTRIBUTE_NOT_CONTENT_INDEXED
FILE_ATTRIBUTE_REPARSE_POINT	FILE_ATTRIBUTE_SPARSE_FILE</code></pre> </dd> <dt id='":FILE_FLAG_"'>
<code>":FILE_FLAG_"</code>
</dt> <dd> <p>File option flag constants. Used in the <code>$uFlags</code> argument to <code>CreateFile</code>.</p> <pre data-language="perl"><code class="plaintext">FILE_FLAG_BACKUP_SEMANTICS	FILE_FLAG_DELETE_ON_CLOSE
FILE_FLAG_NO_BUFFERING		FILE_FLAG_OVERLAPPED
FILE_FLAG_POSIX_SEMANTICS	FILE_FLAG_RANDOM_ACCESS
FILE_FLAG_SEQUENTIAL_SCAN	FILE_FLAG_WRITE_THROUGH
FILE_FLAG_OPEN_REPARSE_POINT</code></pre> </dd> <dt id='":FILE_SHARE_"'>
<code>":FILE_SHARE_"</code>
</dt> <dd> <p>File sharing constants. Used in the <code>$uShare</code> argument to <code>CreateFile</code>.</p> <pre data-language="perl"><code class="plaintext">FILE_SHARE_DELETE	FILE_SHARE_READ		FILE_SHARE_WRITE</code></pre> </dd> <dt id='":FILE_TYPE_"'>
<code>":FILE_TYPE_"</code>
</dt> <dd> <p>File type constants. Returned by <code>GetFileType</code>.</p> <pre data-language="perl"><code class="plaintext">FILE_TYPE_CHAR		FILE_TYPE_DISK
FILE_TYPE_PIPE		FILE_TYPE_UNKNOWN</code></pre> </dd> <dt id='":FS_"'>
<code>":FS_"</code>
</dt> <dd> <p>File system characteristics constants. Placed in the <code>$ouFsFlags</code> argument to <code>GetVolumeInformation</code>.</p> <pre data-language="perl"><code class="plaintext">FS_CASE_IS_PRESERVED		FS_CASE_SENSITIVE
FS_UNICODE_STORED_ON_DISK	FS_PERSISTENT_ACLS 
FS_FILE_COMPRESSION		FS_VOL_IS_COMPRESSED</code></pre> </dd> <dt id='":HANDLE_FLAG_"'>
<code>":HANDLE_FLAG_"</code>
</dt> <dd> <p>Flag bits modifying the behavior of an object handle and accessed via <code>GetHandleInformation</code> and <code>SetHandleInformation</code>.</p> <dl> <dt id="HANDLE_FLAG_INHERIT">HANDLE_FLAG_INHERIT</dt> <dd> <p>If this bit is set, then children of this process who inherit handles [that is, processes created by calls to the Win32 <code>CreateProcess</code> API with the <code>bInheritHandles</code> parameter specified as <code>TRUE</code>], will inherit this particular object handle.</p> </dd> <dt id="HANDLE_FLAG_PROTECT_FROM_CLOSE">HANDLE_FLAG_PROTECT_FROM_CLOSE</dt> <dd> <p>If this bit is set, then calls to <code>CloseHandle</code> against this handle will be ignored, leaving the handle open and usable.</p> </dd> </dl> </dd> <dt id='":IOCTL_STORAGE_"'>
<code>":IOCTL_STORAGE_"</code>
</dt> <dd> <p>I/O control operations for generic storage devices. Used in the <code>$uIoControlCode</code> argument to <code>DeviceIoControl</code>. Includes <code>IOCTL_STORAGE_CHECK_VERIFY</code>, <code>IOCTL_STORAGE_MEDIA_REMOVAL</code>, <code>IOCTL_STORAGE_EJECT_MEDIA</code>, <code>IOCTL_STORAGE_LOAD_MEDIA</code>, <code>IOCTL_STORAGE_RESERVE</code>, <code>IOCTL_STORAGE_RELEASE</code>, <code>IOCTL_STORAGE_FIND_NEW_DEVICES</code>, and <code>IOCTL_STORAGE_GET_MEDIA_TYPES</code>.</p> <dl> <dt id="IOCTL_STORAGE_CHECK_VERIFY"><code>IOCTL_STORAGE_CHECK_VERIFY</code></dt> <dd> <p>Verify that a device's media is accessible. <code>$pInBuf</code> and <code>$opOutBuf</code> should both be <code>[]</code>. If <code>DeviceIoControl</code> returns a true value, then the media is currently accessible.</p> </dd> <dt id="IOCTL_STORAGE_MEDIA_REMOVAL"><code>IOCTL_STORAGE_MEDIA_REMOVAL</code></dt> <dd> <p>Allows the device's media to be locked or unlocked. <code>$opOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should be a <code>PREVENT_MEDIA_REMOVAL</code> data structure, which is simply an integer containing a boolean value:</p> <pre data-language="perl"><code>$pInBuf= pack( "i", $bPreventMediaRemoval );</code></pre> </dd> <dt id="IOCTL_STORAGE_EJECT_MEDIA"><code>IOCTL_STORAGE_EJECT_MEDIA</code></dt> <dd> <p>Requests that the device eject the media. <code>$pInBuf</code> and <code>$opOutBuf</code> should both be <code>[]</code>.</p> </dd> <dt id="IOCTL_STORAGE_LOAD_MEDIA"><code>IOCTL_STORAGE_LOAD_MEDIA</code></dt> <dd> <p>Requests that the device load the media. <code>$pInBuf</code> and <code>$opOutBuf</code> should both be <code>[]</code>.</p> </dd> <dt id="IOCTL_STORAGE_RESERVE"><code>IOCTL_STORAGE_RESERVE</code></dt> <dd> <p>Requests that the device be reserved. <code>$pInBuf</code> and <code>$opOutBuf</code> should both be <code>[]</code>.</p> </dd> <dt id="IOCTL_STORAGE_RELEASE"><code>IOCTL_STORAGE_RELEASE</code></dt> <dd> <p>Releases a previous device reservation. <code>$pInBuf</code> and <code>$opOutBuf</code> should both be <code>[]</code>.</p> </dd> <dt id="IOCTL_STORAGE_FIND_NEW_DEVICES"><code>IOCTL_STORAGE_FIND_NEW_DEVICES</code></dt> <dd> <p>No documentation on this IOCTL operation was found.</p> </dd> <dt id="IOCTL_STORAGE_GET_MEDIA_TYPES"><code>IOCTL_STORAGE_GET_MEDIA_TYPES</code></dt> <dd> <p>Requests information about the type of media supported by the device. <code>$pInBuf</code> should be <code>[]</code>. <code>$opOutBuf</code> will be set to contain a vector of <code>DISK_GEOMETRY</code> data structures, which can be decoded via:</p> <pre data-language="perl"><code>    # Calculate the number of DISK_GEOMETRY structures returned:
    my $cStructs= length($opOutBuf)/(4+4+4+4+4+4);
    my @fields= unpack( "L l I L L L" x $cStructs, $opOutBuf )
    my( @ucCylsLow, @ivcCylsHigh, @uMediaType, @uTracksPerCyl,
      @uSectsPerTrack, @uBytesPerSect )= ();
    while(  @fields  ) {
	push( @ucCylsLow, unshift @fields );
	push( @ivcCylsHigh, unshift @fields );
	push( @uMediaType, unshift @fields );
	push( @uTracksPerCyl, unshift @fields );
	push( @uSectsPerTrack, unshift @fields );
	push( @uBytesPerSect, unshift @fields );
    }</code></pre> <p>For the <code>$i</code>th type of supported media, the following variables will contain the following data.</p> <dl> <dt id="$ucCylsLow[$i]">
<code>$ucCylsLow[$i]</code>
</dt> <dd> <p>The low-order 4 bytes of the total number of cylinders.</p> </dd> <dt id="$ivcCylsHigh[$i]">
<code>$ivcCylsHigh[$i]</code>
</dt> <dd> <p>The high-order 4 bytes of the total number of cylinders.</p> </dd> <dt id="$uMediaType[$i]">
<code>$uMediaType[$i]</code>
</dt> <dd> <p>A code for the type of media. See the <code>":MEDIA_TYPE"</code> export class.</p> </dd> <dt id="$uTracksPerCyl[$i]">
<code>$uTracksPerCyl[$i]</code>
</dt> <dd> <p>The number of tracks in each cylinder.</p> </dd> <dt id="$uSectsPerTrack[$i]">
<code>$uSectsPerTrack[$i]</code>
</dt> <dd> <p>The number of sectors in each track.</p> </dd> <dt id="$uBytesPerSect[$i]">
<code>$uBytesPerSect[$i]</code>
</dt> <dd> <p>The number of bytes in each sector.</p> </dd> </dl> </dd> </dl> </dd> <dt id='":IOCTL_DISK_"'>
<code>":IOCTL_DISK_"</code>
</dt> <dd> <p>I/O control operations for disk devices. Used in the <code>$uIoControlCode</code> argument to <code>DeviceIoControl</code>. Most of these are to be used on physical drive devices like <code>"//./PhysicalDrive0"</code>. However, <code>IOCTL_DISK_GET_PARTITION_INFO</code> and <code>IOCTL_DISK_SET_PARTITION_INFO</code> should only be used on a single-partition device like <code>"//./C:"</code>. Also, <code>IOCTL_DISK_GET_MEDIA_TYPES</code> is documented as having been superseded but is still useful when used on a floppy device like <code>"//./A:"</code>.</p> <p>Includes <code>IOCTL_DISK_FORMAT_TRACKS</code>, <code>IOCTL_DISK_FORMAT_TRACKS_EX</code>, <code>IOCTL_DISK_GET_DRIVE_GEOMETRY</code>, <code>IOCTL_DISK_GET_DRIVE_LAYOUT</code>, <code>IOCTL_DISK_GET_MEDIA_TYPES</code>, <code>IOCTL_DISK_GET_PARTITION_INFO</code>, <code>IOCTL_DISK_HISTOGRAM_DATA</code>, <code>IOCTL_DISK_HISTOGRAM_RESET</code>, <code>IOCTL_DISK_HISTOGRAM_STRUCTURE</code>, <code>IOCTL_DISK_IS_WRITABLE</code>, <code>IOCTL_DISK_LOGGING</code>, <code>IOCTL_DISK_PERFORMANCE</code>, <code>IOCTL_DISK_REASSIGN_BLOCKS</code>, <code>IOCTL_DISK_REQUEST_DATA</code>, <code>IOCTL_DISK_REQUEST_STRUCTURE</code>, <code>IOCTL_DISK_SET_DRIVE_LAYOUT</code>, <code>IOCTL_DISK_SET_PARTITION_INFO</code>, and <code>IOCTL_DISK_VERIFY</code>.</p> <dl> <dt id="IOCTL_DISK_GET_DRIVE_GEOMETRY"><code>IOCTL_DISK_GET_DRIVE_GEOMETRY</code></dt> <dd> <p>Request information about the size and geometry of the disk. <code>$pInBuf</code> should be <code>[]</code>. <code>$opOutBuf</code> will be set to a <code>DISK_GEOMETRY</code> data structure which can be decode via:</p> <pre data-language="perl"><code>( $ucCylsLow, $ivcCylsHigh, $uMediaType, $uTracksPerCyl,
  $uSectsPerTrack, $uBytesPerSect )= unpack( "L l I L L L", $opOutBuf );</code></pre> <dl> <dt id="$ucCylsLow">
<code>$ucCylsLow</code>
</dt> <dd> <p>The low-order 4 bytes of the total number of cylinders.</p> </dd> <dt id="$ivcCylsHigh">
<code>$ivcCylsHigh</code>
</dt> <dd> <p>The high-order 4 bytes of the total number of cylinders.</p> </dd> <dt id="$uMediaType">
<code>$uMediaType</code>
</dt> <dd> <p>A code for the type of media. See the <code>":MEDIA_TYPE"</code> export class.</p> </dd> <dt id="$uTracksPerCyl">
<code>$uTracksPerCyl</code>
</dt> <dd> <p>The number of tracks in each cylinder.</p> </dd> <dt id="$uSectsPerTrack">
<code>$uSectsPerTrack</code>
</dt> <dd> <p>The number of sectors in each track.</p> </dd> <dt id="$uBytesPerSect">
<code>$uBytesPerSect</code>
</dt> <dd> <p>The number of bytes in each sector.</p> </dd> </dl> </dd> <dt id="IOCTL_DISK_GET_PARTITION_INFO"><code>IOCTL_DISK_GET_PARTITION_INFO</code></dt> <dd> <p>Request information about the size and geometry of the partition. <code>$pInBuf</code> should be <code>[]</code>. <code>$opOutBuf</code> will be set to a <code>PARTITION_INFORMATION</code> data structure which can be decode via:</p> <pre data-language="perl"><code>( $uStartLow, $ivStartHigh, $ucHiddenSects, $uPartitionSeqNumber,
  $uPartitionType, $bActive, $bRecognized, $bToRewrite )=
  unpack( "L l L L C c c c", $opOutBuf );</code></pre> <dl> <dt id="$uStartLow-and-$ivStartHigh">
<code>$uStartLow</code> and <code>$ivStartHigh</code>
</dt> <dd> <p>The low-order and high-order [respectively] 4 bytes of the starting offset of the partition, measured in bytes.</p> </dd> <dt id="$ucHiddenSects">
<code>$ucHiddenSects</code>
</dt> <dd> <p>The number of "hidden" sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in <code>$uStartLow</code> and <code>$ivStartHigh</code>] divided by the number of bytes per sector.</p> </dd> <dt id="$uPartitionSeqNumber">
<code>$uPartitionSeqNumber</code>
</dt> <dd> <p>The sequence number of this partition. Partitions are numbered starting as <code>1</code> [with "partition 0" meaning the entire disk]. Sometimes this field may be <code>0</code> and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</p> </dd> <dt id="$uPartitionType">
<code>$uPartitionType</code>
</dt> <dd> <p>The type of partition. See the <code>":PARTITION_"</code> export class for a list of known types. See also <code>IsRecognizedPartition</code> and <code>IsContainerPartition</code>.</p> </dd> <dt id="$bActive">
<code>$bActive</code>
</dt> <dd> <p><code>1</code> for the active [boot] partition, <code>0</code> otherwise.</p> </dd> <dt id="$bRecognized">
<code>$bRecognized</code>
</dt> <dd> <p>Whether this type of partition is support under Win32.</p> </dd> <dt id="$bToRewrite">
<code>$bToRewrite</code>
</dt> <dd> <p>Whether to update this partition information. This field is not used by <code>IOCTL_DISK_GET_PARTITION_INFO</code>. For <code>IOCTL_DISK_SET_DRIVE_LAYOUT</code>, you must set this field to a true value for any partitions you wish to have changed, added, or deleted.</p> </dd> </dl> </dd> <dt id="IOCTL_DISK_SET_PARTITION_INFO"><code>IOCTL_DISK_SET_PARTITION_INFO</code></dt> <dd> <p>Change the type of the partition. <code>$opOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should be a <code>SET_PARTITION_INFORMATION</code> data structure which is just a single byte containing the new partition type [see the <code>":PARTITION_"</code> export class for a list of known types]:</p> <pre data-language="perl"><code>$pInBuf= pack( "C", $uPartitionType );</code></pre> </dd> <dt id="IOCTL_DISK_GET_DRIVE_LAYOUT"><code>IOCTL_DISK_GET_DRIVE_LAYOUT</code></dt> <dd> <p>Request information about the disk layout. <code>$pInBuf</code> should be <code>[]</code>. <code>$opOutBuf</code> will be set to contain <code>DRIVE_LAYOUT_INFORMATION</code> structure including several <code>PARTITION_INFORMATION</code> structures:</p> <pre data-language="perl"><code>    my( $cPartitions, $uDiskSignature )= unpack( "L L", $opOutBuf );
    my @fields= unpack( "x8" . ( "L l L L C c c c" x $cPartitions ),
		        $opOutBuf );
    my( @uStartLow, @ivStartHigh, @ucHiddenSects,
      @uPartitionSeqNumber, @uPartitionType, @bActive,
      @bRecognized, @bToRewrite )= ();
    for(  1..$cPartition  ) {
	push( @uStartLow, unshift @fields );
	push( @ivStartHigh, unshift @fields );
	push( @ucHiddenSects, unshift @fields );
	push( @uPartitionSeqNumber, unshift @fields );
	push( @uPartitionType, unshift @fields );
	push( @bActive, unshift @fields );
	push( @bRecognized, unshift @fields );
	push( @bToRewrite, unshift @fields );
    }</code></pre> <dl> <dt id="$cPartitions">
<code>$cPartitions</code>
</dt> <dd> <p>If the number of partitions on the disk.</p> </dd> <dt id="$uDiskSignature">
<code>$uDiskSignature</code>
</dt> <dd> <p>Is the disk signature, a unique number assigned by Disk Administrator [<i>WinDisk.exe</i>] and used to identify the disk. This allows drive letters for partitions on that disk to remain constant even if the SCSI Target ID of the disk gets changed.</p> </dd> </dl> <p>See <code>IOCTL_DISK_GET_PARTITION_INFORMATION</code> for information on the remaining these fields.</p> </dd> <dt id="IOCTL_DISK_GET_MEDIA_TYPES"><code>IOCTL_DISK_GET_MEDIA_TYPES</code></dt> <dd> <p>Is supposed to be superseded by <code>IOCTL_STORAGE_GET_MEDIA_TYPES</code> but is still useful for determining the types of floppy diskette formats that can be produced by a given floppy drive. See <i>ex/FormatFloppy.plx</i> for an example.</p> </dd> <dt id="IOCTL_DISK_SET_DRIVE_LAYOUT"><code>IOCTL_DISK_SET_DRIVE_LAYOUT</code></dt> <dd> <p>Change the partition layout of the disk. <code>$pOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should be a <code>DISK_LAYOUT_INFORMATION</code> data structure including several <code>PARTITION_INFORMATION</code> data structures.</p> <pre data-language="perl"><code>    # Already set:  $cPartitions, $uDiskSignature, @uStartLow, @ivStartHigh,
    #   @ucHiddenSects, @uPartitionSeqNumber, @uPartitionType, @bActive,
    #   @bRecognized, and @bToRewrite.
    my( @fields, $prtn )= ();
    for $prtn (  1..$cPartition  ) {
	push( @fields, $uStartLow[$prtn-1], $ivStartHigh[$prtn-1],
	    $ucHiddenSects[$prtn-1], $uPartitionSeqNumber[$prtn-1],
	    $uPartitionType[$prtn-1], $bActive[$prtn-1],
	    $bRecognized[$prtn-1], $bToRewrite[$prtn-1] );
    }
    $pInBuf= pack( "L L" . ( "L l L L C c c c" x $cPartitions ),
		   $cPartitions, $uDiskSignature, @fields );</code></pre> <p>To delete a partition, zero out all fields except for <code>$bToRewrite</code> which should be set to <code>1</code>. To add a partition, increment <code>$cPartitions</code> and add the information for the new partition into the arrays, making sure that you insert <code>1</code> into @bToRewrite.</p> <p>See <code>IOCTL_DISK_GET_DRIVE_LAYOUT</code> and <code>IOCTL_DISK_GET_PARITITON_INFORMATION</code> for descriptions of the fields.</p> </dd> <dt id="IOCTL_DISK_VERIFY"><code>IOCTL_DISK_VERIFY</code></dt> <dd> <p>Performs a logical format of [part of] the disk. <code>$opOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should contain a <code>VERIFY_INFORMATION</code> data structure:</p> <pre data-language="perl"><code>    $pInBuf= pack( "L l L",
		   $uStartOffsetLow, $ivStartOffsetHigh, $uLength );</code></pre> <dl> <dt id="$uStartOffsetLow-and-$ivStartOffsetHigh">
<code>$uStartOffsetLow</code> and <code>$ivStartOffsetHigh</code>
</dt> <dd> <p>The low-order and high-order [respectively] 4 bytes of the offset [in bytes] where the formatting should begin.</p> </dd> <dt id="$uLength">
<code>$uLength</code>
</dt> <dd> <p>The length [in bytes] of the section to be formatted.</p> </dd> </dl> </dd> <dt id="IOCTL_DISK_FORMAT_TRACKS"><code>IOCTL_DISK_FORMAT_TRACKS</code></dt> <dd> <p>Format a range of tracks on the disk. <code>$opOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should contain a <code>FORMAT_PARAMETERS</code> data structure:</p> <pre data-language="perl"><code>    $pInBuf= pack( "L L L L L", $uMediaType,
		   $uStartCyl, $uEndCyl, $uStartHead, $uEndHead );</code></pre> <p><code>$uMediaType</code> if the type of media to be formatted. Mostly used to specify the density to use when formatting a floppy diskette. See the <code>":MEDIA_TYPE"</code> export class for more information.</p> <p>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</p> </dd> <dt id="IOCTL_DISK_REASSIGN_BLOCKS"><code>IOCTL_DISK_REASSIGN_BLOCKS</code></dt> <dd> <p>Reassign a list of disk blocks to the disk's spare-block pool. <code>$opOutBuf</code> should be <code>[]</code>. <code>$pInBuf</code> should be a <code>REASSIGN_BLOCKS</code> data structure:</p> <pre data-language="perl"><code>$pInBuf= pack( "S S L*", 0, $cBlocks, @uBlockNumbers );</code></pre> </dd> <dt id="IOCTL_DISK_PERFORMANCE"><code>IOCTL_DISK_PERFORMANCE</code></dt> <dd> <p>Request information about disk performance. <code>$pInBuf</code> should be <code>[]</code>. <code>$opOutBuf</code> will be set to contain a <code>DISK_PERFORMANCE</code> data structure:</p> <pre data-language="perl"><code>    my( $ucBytesReadLow, $ivcBytesReadHigh,
	$ucBytesWrittenLow, $ivcBytesWrittenHigh,
	$uReadTimeLow, $ivReadTimeHigh,
	$uWriteTimeLow, $ivWriteTimeHigh,
	$ucReads, $ucWrites, $uQueueDepth )=
	unpack( "L l L l L l L l L L L", $opOutBuf );</code></pre> </dd> <dt id="IOCTL_DISK_IS_WRITABLE"><code>IOCTL_DISK_IS_WRITABLE</code></dt> <dd> <p>No documentation on this IOCTL operation was found.</p> </dd> <dt id="IOCTL_DISK_LOGGING"><code>IOCTL_DISK_LOGGING</code></dt> <dd> <p>Control disk logging. Little documentation for this IOCTL operation was found. It makes use of a <code>DISK_LOGGING</code> data structure:</p> <dl> <dt id="DISK_LOGGING_START">DISK_LOGGING_START</dt> <dd> <p>Start logging each disk request in a buffer internal to the disk device driver of size <code>$uLogBufferSize</code>:</p> <pre data-language="perl"><code>$pInBuf= pack( "C L L", 0, 0, $uLogBufferSize );</code></pre> </dd> <dt id="DISK_LOGGING_STOP">DISK_LOGGING_STOP</dt> <dd> <p>Stop logging each disk request:</p> <pre data-language="perl"><code>$pInBuf= pack( "C L L", 1, 0, 0 );</code></pre> </dd> <dt id="DISK_LOGGING_DUMP">DISK_LOGGING_DUMP</dt> <dd> <p>Copy the internal log into the supplied buffer:</p> <pre data-language="perl"><code>$pLogBuffer= ' ' x $uLogBufferSize
$pInBuf= pack( "C P L", 2, $pLogBuffer, $uLogBufferSize );

( $uByteOffsetLow[$i], $ivByteOffsetHigh[$i],
  $uStartTimeLow[$i], $ivStartTimeHigh[$i],
  $uEndTimeLog[$i], $ivEndTimeHigh[$i],
  $hVirtualAddress[$i], $ucBytes[$i],
  $uDeviceNumber[$i], $bWasReading[$i] )=
  unpack( "x".(8+8+8+4+4+1+1+2)." L l L l L l L L C c x2", $pLogBuffer );</code></pre> </dd> <dt id="DISK_LOGGING_BINNING">DISK_LOGGING_BINNING</dt> <dd> <p>Keep statics grouped into bins based on request sizes.</p> <pre data-language="perl"><code>$pInBuf= pack( "C P L", 3, $pUnknown, $uUnknownSize );</code></pre> </dd> </dl> </dd> <dt id="IOCTL_DISK_FORMAT_TRACKS_EX"><code>IOCTL_DISK_FORMAT_TRACKS_EX</code></dt> <dd> <p>No documentation on this IOCTL is included.</p> </dd> <dt id="IOCTL_DISK_HISTOGRAM_STRUCTURE"><code>IOCTL_DISK_HISTOGRAM_STRUCTURE</code></dt> <dd> <p>No documentation on this IOCTL is included.</p> </dd> <dt id="IOCTL_DISK_HISTOGRAM_DATA"><code>IOCTL_DISK_HISTOGRAM_DATA</code></dt> <dd> <p>No documentation on this IOCTL is included.</p> </dd> <dt id="IOCTL_DISK_HISTOGRAM_RESET"><code>IOCTL_DISK_HISTOGRAM_RESET</code></dt> <dd> <p>No documentation on this IOCTL is included.</p> </dd> <dt id="IOCTL_DISK_REQUEST_STRUCTURE"><code>IOCTL_DISK_REQUEST_STRUCTURE</code></dt> <dd> <p>No documentation on this IOCTL operation was found.</p> </dd> <dt id="IOCTL_DISK_REQUEST_DATA"><code>IOCTL_DISK_REQUEST_DATA</code></dt> <dd> <p>No documentation on this IOCTL operation was found.</p> </dd> </dl> </dd> <dt id='":FSCTL_"'>
<code>":FSCTL_"</code>
</dt> <dd> <p>File system control operations. Used in the <code>$uIoControlCode</code> argument to <code>DeviceIoControl</code>.</p> <p>Includes <code>FSCTL_SET_REPARSE_POINT</code>, <code>FSCTL_GET_REPARSE_POINT</code>, <code>FSCTL_DELETE_REPARSE_POINT</code>.</p> <dl> <dt id="FSCTL_SET_REPARSE_POINT"><code>FSCTL_SET_REPARSE_POINT</code></dt> <dd> <p>Sets reparse point data to be associated with $hDevice.</p> </dd> <dt id="FSCTL_GET_REPARSE_POINT"><code>FSCTL_GET_REPARSE_POINT</code></dt> <dd> <p>Retrieves the reparse point data associated with $hDevice.</p> </dd> <dt id="FSCTL_DELETE_REPARSE_POINT"><code>FSCTL_DELETE_REPARSE_POINT</code></dt> <dd> <p>Deletes the reparse point data associated with $hDevice.</p> </dd> </dl> </dd> <dt id='":GENERIC_"'>
<code>":GENERIC_"</code>
</dt> <dd> <p>Constants specifying generic access permissions that are not specific to one type of object.</p> <pre data-language="perl"><code class="plaintext">GENERIC_ALL			GENERIC_EXECUTE
GENERIC_READ		GENERIC_WRITE</code></pre> </dd> <dt id='":MEDIA_TYPE"'>
<code>":MEDIA_TYPE"</code>
</dt> <dd> <p>Different classes of media that a device can support. Used in the <code>$uMediaType</code> field of a <code>DISK_GEOMETRY</code> structure.</p> <dl> <dt id="Unknown"><code>Unknown</code></dt> <dd> <p>Format is unknown.</p> </dd> <dt id="F5_1Pt2_512"><code>F5_1Pt2_512</code></dt> <dd> <p>5.25" floppy, 1.2MB [really 1,200KB] total space, 512 bytes/sector.</p> </dd> <dt id="F3_1Pt44_512"><code>F3_1Pt44_512</code></dt> <dd> <p>3.5" floppy, 1.44MB [really 1,440KB] total space, 512 bytes/sector.</p> </dd> <dt id="F3_2Pt88_512"><code>F3_2Pt88_512</code></dt> <dd> <p>3.5" floppy, 2.88MB [really 2,880KB] total space, 512 bytes/sector.</p> </dd> <dt id="F3_20Pt8_512"><code>F3_20Pt8_512</code></dt> <dd> <p>3.5" floppy, 20.8MB total space, 512 bytes/sector.</p> </dd> <dt id="F3_720_512"><code>F3_720_512</code></dt> <dd> <p>3.5" floppy, 720KB total space, 512 bytes/sector.</p> </dd> <dt id="F5_360_512"><code>F5_360_512</code></dt> <dd> <p>5.25" floppy, 360KB total space, 512 bytes/sector.</p> </dd> <dt id="F5_320_512"><code>F5_320_512</code></dt> <dd> <p>5.25" floppy, 320KB total space, 512 bytes/sector.</p> </dd> <dt id="F5_320_1024"><code>F5_320_1024</code></dt> <dd> <p>5.25" floppy, 320KB total space, 1024 bytes/sector.</p> </dd> <dt id="F5_180_512"><code>F5_180_512</code></dt> <dd> <p>5.25" floppy, 180KB total space, 512 bytes/sector.</p> </dd> <dt id="F5_160_512"><code>F5_160_512</code></dt> <dd> <p>5.25" floppy, 160KB total space, 512 bytes/sector.</p> </dd> <dt id="RemovableMedia"><code>RemovableMedia</code></dt> <dd> <p>Some type of removable media other than a floppy diskette.</p> </dd> <dt id="FixedMedia"><code>FixedMedia</code></dt> <dd> <p>A fixed hard disk.</p> </dd> <dt id="F3_120M_512"><code>F3_120M_512</code></dt> <dd> <p>3.5" floppy, 120MB total space.</p> </dd> </dl> </dd> <dt id='":MOVEFILE_"'>
<code>":MOVEFILE_"</code>
</dt> <dd> <p>Constants for use in <code>$uFlags</code> arguments to <code>MoveFileEx</code>.</p> <pre data-language="perl"><code class="plaintext">MOVEFILE_COPY_ALLOWED		MOVEFILE_DELAY_UNTIL_REBOOT
MOVEFILE_REPLACE_EXISTING	MOVEFILE_WRITE_THROUGH</code></pre> </dd> <dt id='":SECURITY_"'>
<code>":SECURITY_"</code>
</dt> <dd> <p>Security quality of service values that can be used in the <code>$uFlags</code> argument to <code>CreateFile</code> if opening the client side of a named pipe.</p> <pre data-language="perl"><code class="plaintext">SECURITY_ANONYMOUS		SECURITY_CONTEXT_TRACKING
SECURITY_DELEGATION		SECURITY_EFFECTIVE_ONLY
SECURITY_IDENTIFICATION		SECURITY_IMPERSONATION
SECURITY_SQOS_PRESENT</code></pre> </dd> <dt id='":SEM_"'>
<code>":SEM_"</code>
</dt> <dd> <p>Constants to be used with <code>SetErrorMode</code>.</p> <pre data-language="perl"><code class="plaintext">SEM_FAILCRITICALERRORS		SEM_NOGPFAULTERRORBOX
SEM_NOALIGNMENTFAULTEXCEPT	SEM_NOOPENFILEERRORBOX</code></pre> </dd> <dt id='":PARTITION_"'>
<code>":PARTITION_"</code>
</dt> <dd> <p>Constants describing partition types.</p> <pre data-language="perl"><code class="plaintext">PARTITION_ENTRY_UNUSED		PARTITION_FAT_12
PARTITION_XENIX_1		PARTITION_XENIX_2
PARTITION_FAT_16		PARTITION_EXTENDED
PARTITION_HUGE			PARTITION_IFS
PARTITION_FAT32			PARTITION_FAT32_XINT13
PARTITION_XINT13		PARTITION_XINT13_EXTENDED
PARTITION_PREP			PARTITION_UNIX
VALID_NTFT			PARTITION_NTFT</code></pre> </dd> <dt id='":STD_HANDLE_"'>
<code>":STD_HANDLE_"</code>
</dt> <dd> <p>Constants for GetStdHandle and SetStdHandle</p> <pre data-language="perl"><code class="plaintext">STD_ERROR_HANDLE
STD_INPUT_HANDLE
STD_OUTPUT_HANDLE</code></pre> </dd> <dt id='":ALL"'>
<code>":ALL"</code>
</dt> <dd> <p>All of the above.</p> </dd> </dl> <h2 id="BUGS">BUGS</h2> <p>None known at this time.</p> <h2 id="AUTHOR">AUTHOR</h2> <p>Tye McQueen, tye@metronet.com, http://perlmonks.org/?node=tye.</p> <h2 id="SEE-ALSO">
SEE ALSO</h2> <p>The pyramids.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/Win32API::File" class="_attribution-link">https://perldoc.perl.org/5.38.0/Win32API::File</a>
  </p>
</div>
