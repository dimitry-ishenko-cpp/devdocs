<h1>Math::BigFloat</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> <ul> <li> <a class="text-decoration-none" href="#Input">Input</a> </li> <li> <a class="text-decoration-none" href="#Output">Output</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#METHODS">METHODS</a> <ul> <li> <a class="text-decoration-none" href="#Configuration-methods">Configuration methods</a> </li> <li> <a class="text-decoration-none" href="#Constructor-methods">Constructor methods</a> </li> <li> <a class="text-decoration-none" href="#Arithmetic-methods">Arithmetic methods</a> </li> <li> <a class="text-decoration-none" href="#ACCURACY-AND-PRECISION">ACCURACY AND PRECISION</a> </li> <li> <a class="text-decoration-none" href="#Rounding">Rounding</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#NUMERIC-LITERALS">NUMERIC LITERALS</a> <ul> <li> <a class="text-decoration-none" href="#Hexadecimal,-octal,-and-binary-floating-point-literals">Hexadecimal, octal, and binary floating point literals</a> </li> <li> <a class="text-decoration-none" href="#Math-library">Math library</a> </li> <li> <a class="text-decoration-none" href="#Using-Math::BigInt::Lite">Using Math::BigInt::Lite</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#EXPORTS">EXPORTS</a> </li> <li> <a class="text-decoration-none" href="#CAVEATS">CAVEATS</a> </li> <li> <a class="text-decoration-none" href="#BUGS">BUGS</a> </li> <li> <a class="text-decoration-none" href="#SUPPORT">SUPPORT</a> </li> <li> <a class="text-decoration-none" href="#LICENSE">LICENSE</a> </li> <li> <a class="text-decoration-none" href="#SEE-ALSO">SEE ALSO</a> </li> <li> <a class="text-decoration-none" href="#AUTHORS">AUTHORS</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>Math::BigFloat - arbitrary size floating point math package</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code class="nohighlight">use Math::BigFloat;

# Configuration methods (may be used as class methods and instance methods)

Math::BigFloat-&gt;accuracy();     # get class accuracy
Math::BigFloat-&gt;accuracy($n);   # set class accuracy
Math::BigFloat-&gt;precision();    # get class precision
Math::BigFloat-&gt;precision($n);  # set class precision
Math::BigFloat-&gt;round_mode();   # get class rounding mode
Math::BigFloat-&gt;round_mode($m); # set global round mode, must be one of
                                # 'even', 'odd', '+inf', '-inf', 'zero',
                                # 'trunc', or 'common'
Math::BigFloat-&gt;config("lib");  # name of backend math library

# Constructor methods (when the class methods below are used as instance
# methods, the value is assigned the invocand)

$x = Math::BigFloat-&gt;new($str);               # defaults to 0
$x = Math::BigFloat-&gt;new('0x123');            # from hexadecimal
$x = Math::BigFloat-&gt;new('0o377');            # from octal
$x = Math::BigFloat-&gt;new('0b101');            # from binary
$x = Math::BigFloat-&gt;from_hex('0xc.afep+3');  # from hex
$x = Math::BigFloat-&gt;from_hex('cafe');        # ditto
$x = Math::BigFloat-&gt;from_oct('1.3267p-4');   # from octal
$x = Math::BigFloat-&gt;from_oct('01.3267p-4');  # ditto
$x = Math::BigFloat-&gt;from_oct('0o1.3267p-4'); # ditto
$x = Math::BigFloat-&gt;from_oct('0377');        # ditto
$x = Math::BigFloat-&gt;from_bin('0b1.1001p-4'); # from binary
$x = Math::BigFloat-&gt;from_bin('0101');        # ditto
$x = Math::BigFloat-&gt;from_ieee754($b, "binary64");  # from IEEE-754 bytes
$x = Math::BigFloat-&gt;bzero();                 # create a +0
$x = Math::BigFloat-&gt;bone();                  # create a +1
$x = Math::BigFloat-&gt;bone('-');               # create a -1
$x = Math::BigFloat-&gt;binf();                  # create a +inf
$x = Math::BigFloat-&gt;binf('-');               # create a -inf
$x = Math::BigFloat-&gt;bnan();                  # create a Not-A-Number
$x = Math::BigFloat-&gt;bpi();                   # returns pi

$y = $x-&gt;copy();        # make a copy (unlike $y = $x)
$y = $x-&gt;as_int();      # return as BigInt
$y = $x-&gt;as_float();    # return as a Math::BigFloat
$y = $x-&gt;as_rat();      # return as a Math::BigRat

# Boolean methods (these don't modify the invocand)

$x-&gt;is_zero();          # if $x is 0
$x-&gt;is_one();           # if $x is +1
$x-&gt;is_one("+");        # ditto
$x-&gt;is_one("-");        # if $x is -1
$x-&gt;is_inf();           # if $x is +inf or -inf
$x-&gt;is_inf("+");        # if $x is +inf
$x-&gt;is_inf("-");        # if $x is -inf
$x-&gt;is_nan();           # if $x is NaN

$x-&gt;is_positive();      # if $x &gt; 0
$x-&gt;is_pos();           # ditto
$x-&gt;is_negative();      # if $x &lt; 0
$x-&gt;is_neg();           # ditto

$x-&gt;is_odd();           # if $x is odd
$x-&gt;is_even();          # if $x is even
$x-&gt;is_int();           # if $x is an integer

# Comparison methods

$x-&gt;bcmp($y);           # compare numbers (undef, &lt; 0, == 0, &gt; 0)
$x-&gt;bacmp($y);          # compare absolutely (undef, &lt; 0, == 0, &gt; 0)
$x-&gt;beq($y);            # true if and only if $x == $y
$x-&gt;bne($y);            # true if and only if $x != $y
$x-&gt;blt($y);            # true if and only if $x &lt; $y
$x-&gt;ble($y);            # true if and only if $x &lt;= $y
$x-&gt;bgt($y);            # true if and only if $x &gt; $y
$x-&gt;bge($y);            # true if and only if $x &gt;= $y

# Arithmetic methods

$x-&gt;bneg();             # negation
$x-&gt;babs();             # absolute value
$x-&gt;bsgn();             # sign function (-1, 0, 1, or NaN)
$x-&gt;bnorm();            # normalize (no-op)
$x-&gt;binc();             # increment $x by 1
$x-&gt;bdec();             # decrement $x by 1
$x-&gt;badd($y);           # addition (add $y to $x)
$x-&gt;bsub($y);           # subtraction (subtract $y from $x)
$x-&gt;bmul($y);           # multiplication (multiply $x by $y)
$x-&gt;bmuladd($y,$z);     # $x = $x * $y + $z
$x-&gt;bdiv($y);           # division (floored), set $x to quotient
                        # return (quo,rem) or quo if scalar
$x-&gt;btdiv($y);          # division (truncated), set $x to quotient
                        # return (quo,rem) or quo if scalar
$x-&gt;bmod($y);           # modulus (x % y)
$x-&gt;btmod($y);          # modulus (truncated)
$x-&gt;bmodinv($mod);      # modular multiplicative inverse
$x-&gt;bmodpow($y,$mod);   # modular exponentiation (($x ** $y) % $mod)
$x-&gt;bpow($y);           # power of arguments (x ** y)
$x-&gt;blog();             # logarithm of $x to base e (Euler's number)
$x-&gt;blog($base);        # logarithm of $x to base $base (e.g., base 2)
$x-&gt;bexp();             # calculate e ** $x where e is Euler's number
$x-&gt;bnok($y);           # x over y (binomial coefficient n over k)
$x-&gt;bsin();             # sine
$x-&gt;bcos();             # cosine
$x-&gt;batan();            # inverse tangent
$x-&gt;batan2($y);         # two-argument inverse tangent
$x-&gt;bsqrt();            # calculate square root
$x-&gt;broot($y);          # $y'th root of $x (e.g. $y == 3 =&gt; cubic root)
$x-&gt;bfac();             # factorial of $x (1*2*3*4*..$x)

$x-&gt;blsft($n);          # left shift $n places in base 2
$x-&gt;blsft($n,$b);       # left shift $n places in base $b
                        # returns (quo,rem) or quo (scalar context)
$x-&gt;brsft($n);          # right shift $n places in base 2
$x-&gt;brsft($n,$b);       # right shift $n places in base $b
                        # returns (quo,rem) or quo (scalar context)

# Bitwise methods

$x-&gt;band($y);           # bitwise and
$x-&gt;bior($y);           # bitwise inclusive or
$x-&gt;bxor($y);           # bitwise exclusive or
$x-&gt;bnot();             # bitwise not (two's complement)

# Rounding methods
$x-&gt;round($A,$P,$mode); # round to accuracy or precision using
                        # rounding mode $mode
$x-&gt;bround($n);         # accuracy: preserve $n digits
$x-&gt;bfround($n);        # $n &gt; 0: round to $nth digit left of dec. point
                        # $n &lt; 0: round to $nth digit right of dec. point
$x-&gt;bfloor();           # round towards minus infinity
$x-&gt;bceil();            # round towards plus infinity
$x-&gt;bint();             # round towards zero

# Other mathematical methods

$x-&gt;bgcd($y);            # greatest common divisor
$x-&gt;blcm($y);            # least common multiple

# Object property methods (do not modify the invocand)

$x-&gt;sign();              # the sign, either +, - or NaN
$x-&gt;digit($n);           # the nth digit, counting from the right
$x-&gt;digit(-$n);          # the nth digit, counting from the left
$x-&gt;length();            # return number of digits in number
($xl,$f) = $x-&gt;length(); # length of number and length of fraction
                         # part, latter is always 0 digits long
                         # for Math::BigInt objects
$x-&gt;mantissa();          # return (signed) mantissa as BigInt
$x-&gt;exponent();          # return exponent as BigInt
$x-&gt;parts();             # return (mantissa,exponent) as BigInt
$x-&gt;sparts();            # mantissa and exponent (as integers)
$x-&gt;nparts();            # mantissa and exponent (normalised)
$x-&gt;eparts();            # mantissa and exponent (engineering notation)
$x-&gt;dparts();            # integer and fraction part
$x-&gt;fparts();            # numerator and denominator
$x-&gt;numerator();         # numerator
$x-&gt;denominator();       # denominator

# Conversion methods (do not modify the invocand)

$x-&gt;bstr();         # decimal notation, possibly zero padded
$x-&gt;bsstr();        # string in scientific notation with integers
$x-&gt;bnstr();        # string in normalized notation
$x-&gt;bestr();        # string in engineering notation
$x-&gt;bdstr();        # string in decimal notation
$x-&gt;bfstr();        # string in fractional notation

$x-&gt;as_hex();       # as signed hexadecimal string with prefixed 0x
$x-&gt;as_bin();       # as signed binary string with prefixed 0b
$x-&gt;as_oct();       # as signed octal string with prefixed 0
$x-&gt;to_ieee754($format); # to bytes encoded according to IEEE 754-2008

# Other conversion methods

$x-&gt;numify();           # return as scalar (might overflow or underflow)</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>Math::BigFloat provides support for arbitrary precision floating point. Overloading is also provided for Perl operators.</p> <p>All operators (including basic math operations) are overloaded if you declare your big floating point numbers as</p> <pre data-language="perl"><code>$x = Math::BigFloat -&gt; new('12_3.456_789_123_456_789E-2');</code></pre> <p>Operations with overloaded operators preserve the arguments, which is exactly what you expect.</p> <h3 id="Input">Input</h3> <p>Input values to these routines may be any scalar number or string that looks like a number. Anything that is accepted by Perl as a literal numeric constant should be accepted by this module.</p> <ul> <li>
<p>Leading and trailing whitespace is ignored.</p> </li> <li>
<p>Leading zeros are ignored, except for floating point numbers with a binary exponent, in which case the number is interpreted as an octal floating point number. For example, "01.4p+0" gives 1.5, "00.4p+0" gives 0.5, but "0.4p+0" gives a NaN. And while "0377" gives 255, "0377p0" gives 255.</p> </li> <li>
<p>If the string has a "0x" or "0X" prefix, it is interpreted as a hexadecimal number.</p> </li> <li>
<p>If the string has a "0o" or "0O" prefix, it is interpreted as an octal number. A floating point literal with a "0" prefix is also interpreted as an octal number.</p> </li> <li>
<p>If the string has a "0b" or "0B" prefix, it is interpreted as a binary number.</p> </li> <li>
<p>Underline characters are allowed in the same way as they are allowed in literal numerical constants.</p> </li> <li>
<p>If the string can not be interpreted, NaN is returned.</p> </li> <li>
<p>For hexadecimal, octal, and binary floating point numbers, the exponent must be separated from the significand (mantissa) by the letter "p" or "P", not "e" or "E" as with decimal numbers.</p> </li> </ul> <p>Some examples of valid string input</p> <pre data-language="perl"><code class="plaintext">Input string                Resulting value

123                         123
1.23e2                      123
12300e-2                    123

67_538_754                  67538754
-4_5_6.7_8_9e+0_1_0         -4567890000000

0x13a                       314
0x13ap0                     314
0x1.3ap+8                   314
0x0.00013ap+24              314
0x13a000p-12                314

0o472                       314
0o1.164p+8                  314
0o0.0001164p+20             314
0o1164000p-10               314

0472                        472     Note!
01.164p+8                   314
00.0001164p+20              314
01164000p-10                314

0b100111010                 314
0b1.0011101p+8              314
0b0.00010011101p+12         314
0b100111010000p-3           314

0x1.921fb5p+1               3.14159262180328369140625e+0
0o1.2677025p1               2.71828174591064453125
01.2677025p1                2.71828174591064453125
0b1.1001p-4                 9.765625e-2</code></pre> <h3 id="Output">Output</h3> <p>Output values are usually Math::BigFloat objects.</p> <p>Boolean operators <code>is_zero()</code>, <code>is_one()</code>, <code>is_inf()</code>, etc. return true or false.</p> <p>Comparison operators <code>bcmp()</code> and <code>bacmp()</code>) return -1, 0, 1, or undef.</p> <h2 id="METHODS">METHODS</h2> <p>Math::BigFloat supports all methods that Math::BigInt supports, except it calculates non-integer results when possible. Please see <a href="Math::BigInt.html">Math::BigInt</a> for a full description of each method. Below are just the most important differences:</p> <h3 id="Configuration-methods">
Configuration methods</h3> <dl> <dt id="accuracy()">
accuracy()</dt> <dd> <pre data-language="perl"><code>$x-&gt;accuracy(5);           # local for $x
CLASS-&gt;accuracy(5);        # global for all members of CLASS
                           # Note: This also applies to new()!

$A = $x-&gt;accuracy();       # read out accuracy that affects $x
$A = CLASS-&gt;accuracy();    # read out global accuracy</code></pre> <p>Set or get the global or local accuracy, aka how many significant digits the results have. If you set a global accuracy, then this also applies to new()!</p> <p>Warning! The accuracy <i>sticks</i>, e.g. once you created a number under the influence of <code>CLASS-&gt;accuracy($A)</code>, all results from math operations with that number will also be rounded.</p> <p>In most cases, you should probably round the results explicitly using one of <a href="Math::BigInt.html#round%28%29">"round()" in Math::BigInt</a>, <a href="Math::BigInt.html#bround%28%29">"bround()" in Math::BigInt</a> or <a href="Math::BigInt.html#bfround%28%29">"bfround()" in Math::BigInt</a> or by passing the desired accuracy to the math operation as additional parameter:</p> <pre data-language="perl"><code>my $x = Math::BigInt-&gt;new(30000);
my $y = Math::BigInt-&gt;new(7);
print scalar $x-&gt;copy()-&gt;bdiv($y, 2);           # print 4300
print scalar $x-&gt;copy()-&gt;bdiv($y)-&gt;bround(2);   # print 4300</code></pre> </dd> <dt id="precision()">
precision()</dt> <dd> <pre data-language="perl"><code>$x-&gt;precision(-2);        # local for $x, round at the second
                          # digit right of the dot
$x-&gt;precision(2);         # ditto, round at the second digit
                          # left of the dot

CLASS-&gt;precision(5);      # Global for all members of CLASS
                          # This also applies to new()!
CLASS-&gt;precision(-5);     # ditto

$P = CLASS-&gt;precision();  # read out global precision
$P = $x-&gt;precision();     # read out precision that affects $x</code></pre> <p>Note: You probably want to use <a href="#accuracy%28%29">"accuracy()"</a> instead. With <a href="#accuracy%28%29">"accuracy()"</a> you set the number of digits each result should have, with <a href="#precision%28%29">"precision()"</a> you set the place where to round!</p> </dd> </dl> <h3 id="Constructor-methods">
Constructor methods</h3> <dl> <dt id="from_hex()">
from_hex()</dt> <dd> <pre data-language="perl"><code>$x -&gt; from_hex("0x1.921fb54442d18p+1");
$x = Math::BigFloat -&gt; from_hex("0x1.921fb54442d18p+1");</code></pre> <p>Interpret input as a hexadecimal string.A prefix ("0x", "x", ignoring case) is optional. A single underscore character ("_") may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</p> <p>If called as an instance method, the value is assigned to the invocand.</p> </dd> <dt id="from_oct()">
from_oct()</dt> <dd> <pre data-language="perl"><code>$x -&gt; from_oct("1.3267p-4");
$x = Math::BigFloat -&gt; from_oct("1.3267p-4");</code></pre> <p>Interpret input as an octal string. A single underscore character ("_") may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</p> <p>If called as an instance method, the value is assigned to the invocand.</p> </dd> <dt id="from_bin()">
from_bin()</dt> <dd> <pre data-language="perl"><code>$x -&gt; from_bin("0b1.1001p-4");
$x = Math::BigFloat -&gt; from_bin("0b1.1001p-4");</code></pre> <p>Interpret input as a hexadecimal string. A prefix ("0b" or "b", ignoring case) is optional. A single underscore character ("_") may be placed between any two digits. If the input is invalid, a NaN is returned. The exponent is in base 2 using decimal digits.</p> <p>If called as an instance method, the value is assigned to the invocand.</p> </dd> <dt id="from_ieee754()">
from_ieee754()</dt> <dd> <p>Interpret the input as a value encoded as described in IEEE754-2008. The input can be given as a byte string, hex string or binary string. The input is assumed to be in big-endian byte-order.</p> <pre data-language="perl"><code># both $dbl and $mbf are 3.141592...
$bytes = "\x40\x09\x21\xfb\x54\x44\x2d\x18";
$dbl = unpack "d&gt;", $bytes;
$mbf = Math::BigFloat -&gt; from_ieee754($bytes, "binary64");</code></pre> </dd> <dt id="bpi()">
bpi()</dt> <dd> <pre data-language="perl"><code>print Math::BigFloat-&gt;bpi(100), "\n";</code></pre> <p>Calculate PI to N digits (including the 3 before the dot). The result is rounded according to the current rounding mode, which defaults to "even".</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> </dl> <h3 id="Arithmetic-methods">
Arithmetic methods</h3> <dl> <dt id="bmuladd()">
bmuladd()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmuladd($y,$z);</code></pre> <p>Multiply $x by $y, and then add $z to the result.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="bdiv()">
bdiv()</dt> <dd> <pre data-language="perl"><code>$q = $x-&gt;bdiv($y);
($q, $r) = $x-&gt;bdiv($y);</code></pre> <p>In scalar context, divides $x by $y and returns the result to the given or default accuracy/precision. In list context, does floored division (F-division), returning an integer $q and a remainder $r so that $x = $q * $y + $r. The remainer (modulo) is equal to what is returned by <code>$x-&gt;bmod($y)</code>.</p> </dd> <dt id="bmod()">
bmod()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bmod($y);</code></pre> <p>Returns $x modulo $y. When $x is finite, and $y is finite and non-zero, the result is identical to the remainder after floored division (F-division). If, in addition, both $x and $y are integers, the result is identical to the result from Perl's % operator.</p> </dd> <dt id="bexp()">
bexp()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bexp($accuracy);            # calculate e ** X</code></pre> <p>Calculates the expression <code>e ** $x</code> where <code>e</code> is Euler's number.</p> <p>This method was added in v1.82 of Math::BigInt (April 2007).</p> </dd> <dt id="bnok()">
bnok()</dt> <dd> <pre data-language="perl"><code>$x-&gt;bnok($y);   # x over y (binomial coefficient n over k)</code></pre> <p>Calculates the binomial coefficient n over k, also called the "choose" function. The result is equivalent to:</p> <pre data-language="perl"><code class="plaintext">( n )      n!
| - |  = -------
( k )    k!(n-k)!</code></pre> <p>This method was added in v1.84 of Math::BigInt (April 2007).</p> </dd> <dt id="bsin()">
bsin()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigFloat-&gt;new(1);
print $x-&gt;bsin(100), "\n";</code></pre> <p>Calculate the sinus of $x, modifying $x in place.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="bcos()">
bcos()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigFloat-&gt;new(1);
print $x-&gt;bcos(100), "\n";</code></pre> <p>Calculate the cosinus of $x, modifying $x in place.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="batan()">
batan()</dt> <dd> <pre data-language="perl"><code>my $x = Math::BigFloat-&gt;new(1);
print $x-&gt;batan(100), "\n";</code></pre> <p>Calculate the arcus tanges of $x, modifying $x in place. See also <a href="#batan2%28%29">"batan2()"</a>.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="batan2()">
batan2()</dt> <dd> <pre data-language="perl"><code>my $y = Math::BigFloat-&gt;new(2);
my $x = Math::BigFloat-&gt;new(3);
print $y-&gt;batan2($x), "\n";</code></pre> <p>Calculate the arcus tanges of <code>$y</code> divided by <code>$x</code>, modifying $y in place. See also <a href="#batan%28%29">"batan()"</a>.</p> <p>This method was added in v1.87 of Math::BigInt (June 2007).</p> </dd> <dt id="as_float()">
as_float()</dt> <dd> <p>This method is called when Math::BigFloat encounters an object it doesn't know how to handle. For instance, assume $x is a Math::BigFloat, or subclass thereof, and $y is defined, but not a Math::BigFloat, or subclass thereof. If you do</p> <pre data-language="perl"><code>$x -&gt; badd($y);</code></pre> <p>$y needs to be converted into an object that $x can deal with. This is done by first checking if $y is something that $x might be upgraded to. If that is the case, no further attempts are made. The next is to see if $y supports the method <code>as_float()</code>. The method <code>as_float()</code> is expected to return either an object that has the same class as $x, a subclass thereof, or a string that <code>ref($x)-&gt;new()</code> can parse to create an object.</p> <p>In Math::BigFloat, <code>as_float()</code> has the same effect as <code>copy()</code>.</p> </dd> <dt id="to_ieee754()">
to_ieee754()</dt> <dd> <p>Encodes the invocand as a byte string in the given format as specified in IEEE 754-2008. Note that the encoded value is the nearest possible representation of the value. This value might not be exactly the same as the value in the invocand.</p> <pre data-language="perl"><code># $x = 3.1415926535897932385
$x = Math::BigFloat -&gt; bpi(30);

$b = $x -&gt; to_ieee754("binary64");  # encode as 8 bytes
$h = unpack "H*", $b;               # "400921fb54442d18"

# 3.141592653589793115997963...
$y = Math::BigFloat -&gt; from_ieee754($h, "binary64");</code></pre> <p>All binary formats in IEEE 754-2008 are accepted. For convenience, som aliases are recognized: "half" for "binary16", "single" for "binary32", "double" for "binary64", "quadruple" for "binary128", "octuple" for "binary256", and "sexdecuple" for "binary512".</p> <p>See also <a href="https://en.wikipedia.org/wiki/IEEE_754">https://en.wikipedia.org/wiki/IEEE_754</a>.</p> </dd> </dl> <h3 id="ACCURACY-AND-PRECISION">
ACCURACY AND PRECISION</h3> <p>See also: <a href="#Rounding">Rounding</a>.</p> <p>Math::BigFloat supports both precision (rounding to a certain place before or after the dot) and accuracy (rounding to a certain number of digits). For a full documentation, examples and tips on these topics please see the large section about rounding in <a href="Math::BigInt.html">Math::BigInt</a>.</p> <p>Since things like <code>sqrt(2)</code> or <code>1 / 3</code> must presented with a limited accuracy lest a operation consumes all resources, each operation produces no more than the requested number of digits.</p> <p>If there is no global precision or accuracy set, <b>and</b> the operation in question was not called with a requested precision or accuracy, <b>and</b> the input $x has no accuracy or precision set, then a fallback parameter will be used. For historical reasons, it is called <code>div_scale</code> and can be accessed via:</p> <pre data-language="perl"><code>$d = Math::BigFloat-&gt;div_scale();       # query
Math::BigFloat-&gt;div_scale($n);          # set to $n digits</code></pre> <p>The default value for <code>div_scale</code> is 40.</p> <p>In case the result of one operation has more digits than specified, it is rounded. The rounding mode taken is either the default mode, or the one supplied to the operation after the <i>scale</i>:</p> <pre data-language="perl"><code>$x = Math::BigFloat-&gt;new(2);
Math::BigFloat-&gt;accuracy(5);              # 5 digits max
$y = $x-&gt;copy()-&gt;bdiv(3);                 # gives 0.66667
$y = $x-&gt;copy()-&gt;bdiv(3,6);               # gives 0.666667
$y = $x-&gt;copy()-&gt;bdiv(3,6,undef,'odd');   # gives 0.666667
Math::BigFloat-&gt;round_mode('zero');
$y = $x-&gt;copy()-&gt;bdiv(3,6);               # will also give 0.666667</code></pre> <p>Note that <code>Math::BigFloat-&gt;accuracy()</code> and <code>Math::BigFloat-&gt;precision()</code> set the global variables, and thus <b>any</b> newly created number will be subject to the global rounding <b>immediately</b>. This means that in the examples above, the <code>3</code> as argument to <code>bdiv()</code> will also get an accuracy of <b>5</b>.</p> <p>It is less confusing to either calculate the result fully, and afterwards round it explicitly, or use the additional parameters to the math functions like so:</p> <pre data-language="perl"><code>use Math::BigFloat;
$x = Math::BigFloat-&gt;new(2);
$y = $x-&gt;copy()-&gt;bdiv(3);
print $y-&gt;bround(5),"\n";               # gives 0.66667

or

use Math::BigFloat;
$x = Math::BigFloat-&gt;new(2);
$y = $x-&gt;copy()-&gt;bdiv(3,5);             # gives 0.66667
print "$y\n";</code></pre> <h3 id="Rounding">Rounding</h3> <dl> <dt id="bfround-(-+$scale-)">
bfround ( +$scale )</dt> <dd> <p>Rounds to the $scale'th place left from the '.', counting from the dot. The first digit is numbered 1.</p> </dd> <dt id="bfround-(-$scale-)">
bfround ( -$scale )</dt> <dd> <p>Rounds to the $scale'th place right from the '.', counting from the dot.</p> </dd> <dt id="bfround-(-0-)">
bfround ( 0 )</dt> <dd> <p>Rounds to an integer.</p> </dd> <dt id="bround-(-+$scale-)">
bround ( +$scale )</dt> <dd> <p>Preserves accuracy to $scale digits from the left (aka significant digits) and pads the rest with zeros. If the number is between 1 and -1, the significant digits count from the first non-zero after the '.'</p> </dd> <dt id="bround-(-$scale-)-and-bround-(-0-)">
bround ( -$scale ) and bround ( 0 )</dt> <dd> <p>These are effectively no-ops.</p> </dd> </dl> <p>All rounding functions take as a second parameter a rounding mode from one of the following: 'even', 'odd', '+inf', '-inf', 'zero', 'trunc' or 'common'.</p> <p>The default rounding mode is 'even'. By using <code>Math::BigFloat-&gt;round_mode($round_mode);</code> you can get and set the default mode for subsequent rounding. The usage of <code>$Math::BigFloat::$round_mode</code> is no longer supported. The second parameter to the round functions then overrides the default temporarily.</p> <p>The <code>as_number()</code> function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</p> <pre data-language="perl"><code>$x = 2.5;
$y = int($x) + 2;</code></pre> <p>You can override this by passing the desired rounding mode as parameter to <code>as_number()</code>:</p> <pre data-language="perl"><code>$x = Math::BigFloat-&gt;new(2.5);
$y = $x-&gt;as_number('odd');      # $y = 3</code></pre> <h2 id="NUMERIC-LITERALS">
NUMERIC LITERALS</h2> <p>After <code>use Math::BigFloat ':constant'</code> all numeric literals in the given scope are converted to <code>Math::BigFloat</code> objects. This conversion happens at compile time.</p> <p>For example,</p> <pre data-language="perl"><code class="plaintext">perl -MMath::BigFloat=:constant -le 'print 2e-150'</code></pre> <p>prints the exact value of <code>2e-150</code>. Note that without conversion of constants the expression <code>2e-150</code> is calculated using Perl scalars, which leads to an inaccuracte result.</p> <p>Note that strings are not affected, so that</p> <pre data-language="perl"><code>use Math::BigFloat qw/:constant/;

$y = "1234567890123456789012345678901234567890"
        + "123456789123456789";</code></pre> <p>does not give you what you expect. You need an explicit Math::BigFloat-&gt;new() around at least one of the operands. You should also quote large constants to prevent loss of precision:</p> <pre data-language="perl"><code>use Math::BigFloat;

$x = Math::BigFloat-&gt;new("1234567889123456789123456789123456789");</code></pre> <p>Without the quotes Perl converts the large number to a floating point constant at compile time, and then converts the result to a Math::BigFloat object at runtime, which results in an inaccurate result.</p> <h3 id="Hexadecimal,-octal,-and-binary-floating-point-literals">
Hexadecimal, octal, and binary floating point literals</h3> <p>Perl (and this module) accepts hexadecimal, octal, and binary floating point literals, but use them with care with Perl versions before v5.32.0, because some versions of Perl silently give the wrong result. Below are some examples of different ways to write the number decimal 314.</p> <p>Hexadecimal floating point literals:</p> <pre data-language="perl"><code class="plaintext">0x1.3ap+8         0X1.3AP+8
0x1.3ap8          0X1.3AP8
0x13a0p-4         0X13A0P-4</code></pre> <p>Octal floating point literals (with "0" prefix):</p> <pre data-language="perl"><code class="plaintext">01.164p+8         01.164P+8
01.164p8          01.164P8
011640p-4         011640P-4</code></pre> <p>Octal floating point literals (with "0o" prefix) (requires v5.34.0):</p> <pre data-language="perl"><code class="plaintext">0o1.164p+8        0O1.164P+8
0o1.164p8         0O1.164P8
0o11640p-4        0O11640P-4</code></pre> <p>Binary floating point literals:</p> <pre data-language="perl"><code class="plaintext">0b1.0011101p+8    0B1.0011101P+8
0b1.0011101p8     0B1.0011101P8
0b10011101000p-2  0B10011101000P-2</code></pre> <h3 id="Math-library">
Math library</h3> <p>Math with the numbers is done (by default) by a module called Math::BigInt::Calc. This is equivalent to saying:</p> <pre data-language="perl"><code>use Math::BigFloat lib =&gt; "Calc";</code></pre> <p>You can change this by using:</p> <pre data-language="perl"><code>use Math::BigFloat lib =&gt; "GMP";</code></pre> <p><b>Note</b>: General purpose packages should not be explicit about the library to use; let the script author decide which is best.</p> <p>Note: The keyword 'lib' will warn when the requested library could not be loaded. To suppress the warning use 'try' instead:</p> <pre data-language="perl"><code>use Math::BigFloat try =&gt; "GMP";</code></pre> <p>If your script works with huge numbers and Calc is too slow for them, you can also for the loading of one of these libraries and if none of them can be used, the code will die:</p> <pre data-language="perl"><code>use Math::BigFloat only =&gt; "GMP,Pari";</code></pre> <p>The following would first try to find Math::BigInt::Foo, then Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:</p> <pre data-language="perl"><code>use Math::BigFloat lib =&gt; "Foo,Math::BigInt::Bar";</code></pre> <p>See the respective low-level library documentation for further details.</p> <p>See <a href="Math::BigInt.html">Math::BigInt</a> for more details about using a different low-level library.</p> <h3 id="Using-Math::BigInt::Lite">
Using Math::BigInt::Lite</h3> <p>For backwards compatibility reasons it is still possible to request a different storage class for use with Math::BigFloat:</p> <pre data-language="perl"><code>use Math::BigFloat with =&gt; 'Math::BigInt::Lite';</code></pre> <p>However, this request is ignored, as the current code now uses the low-level math library for directly storing the number parts.</p> <h2 id="EXPORTS">EXPORTS</h2> <p><code>Math::BigFloat</code> exports nothing by default, but can export the <code>bpi()</code> method:</p> <pre data-language="perl"><code>use Math::BigFloat qw/bpi/;

print bpi(10), "\n";</code></pre> <h2 id="CAVEATS">CAVEATS</h2> <p>Do not try to be clever to insert some operations in between switching libraries:</p> <pre data-language="perl"><code>require Math::BigFloat;
my $matter = Math::BigFloat-&gt;bone() + 4;    # load BigInt and Calc
Math::BigFloat-&gt;import( lib =&gt; 'Pari' );    # load Pari, too
my $anti_matter = Math::BigFloat-&gt;bone()+4; # now use Pari</code></pre> <p>This will create objects with numbers stored in two different backend libraries, and <b>VERY BAD THINGS</b> will happen when you use these together:</p> <pre data-language="perl"><code>my $flash_and_bang = $matter + $anti_matter;    # Don't do this!</code></pre> <dl> <dt id="stringify,-bstr()">
stringify, bstr()</dt> <dd> <p>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in <a href="Math::BigInt.html">Math::BigInt</a> for reasoning and details.</p> </dd> <dt id="brsft()">
brsft()</dt> <dd> <p>The following will probably not print what you expect:</p> <pre data-language="perl"><code>my $c = Math::BigFloat-&gt;new('3.14159');
print $c-&gt;brsft(3,10),"\n";     # prints 0.00314153.1415</code></pre> <p>It prints both quotient and remainder, since print calls <code>brsft()</code> in list context. Also, <code>$c-&gt;brsft()</code> will modify $c, so be careful. You probably want to use</p> <pre data-language="perl"><code>print scalar $c-&gt;copy()-&gt;brsft(3,10),"\n";
# or if you really want to modify $c
print scalar $c-&gt;brsft(3,10),"\n";</code></pre> <p>instead.</p> </dd> <dt id="Modifying-and-=">
Modifying and =</dt> <dd> <p>Beware of:</p> <pre data-language="perl"><code>$x = Math::BigFloat-&gt;new(5);
$y = $x;</code></pre> <p>It will not do what you think, e.g. making a copy of $x. Instead it just makes a second reference to the <b>same</b> object and stores it in $y. Thus anything that modifies $x will modify $y (except overloaded math operators), and vice versa. See <a href="Math::BigInt.html">Math::BigInt</a> for details and how to avoid that.</p> </dd> <dt id="precision()-vs.-accuracy()">
precision() vs. accuracy()</dt> <dd> <p>A common pitfall is to use <a href="#precision%28%29">"precision()"</a> when you want to round a result to a certain number of digits:</p> <pre data-language="perl"><code>use Math::BigFloat;

Math::BigFloat-&gt;precision(4);           # does not do what you
                                        # think it does
my $x = Math::BigFloat-&gt;new(12345);     # rounds $x to "12000"!
print "$x\n";                           # print "12000"
my $y = Math::BigFloat-&gt;new(3);         # rounds $y to "0"!
print "$y\n";                           # print "0"
$z = $x / $y;                           # 12000 / 0 =&gt; NaN!
print "$z\n";
print $z-&gt;precision(),"\n";             # 4</code></pre> <p>Replacing <a href="#precision%28%29">"precision()"</a> with <a href="#accuracy%28%29">"accuracy()"</a> is probably not what you want, either:</p> <pre data-language="perl"><code>use Math::BigFloat;

Math::BigFloat-&gt;accuracy(4);          # enables global rounding:
my $x = Math::BigFloat-&gt;new(123456);  # rounded immediately
                                      #   to "12350"
print "$x\n";                         # print "123500"
my $y = Math::BigFloat-&gt;new(3);       # rounded to "3
print "$y\n";                         # print "3"
print $z = $x-&gt;copy()-&gt;bdiv($y),"\n"; # 41170
print $z-&gt;accuracy(),"\n";            # 4</code></pre> <p>What you want to use instead is:</p> <pre data-language="perl"><code>use Math::BigFloat;

my $x = Math::BigFloat-&gt;new(123456);    # no rounding
print "$x\n";                           # print "123456"
my $y = Math::BigFloat-&gt;new(3);         # no rounding
print "$y\n";                           # print "3"
print $z = $x-&gt;copy()-&gt;bdiv($y,4),"\n"; # 41150
print $z-&gt;accuracy(),"\n";              # undef</code></pre> <p>In addition to computing what you expected, the last example also does <b>not</b> "taint" the result with an accuracy or precision setting, which would influence any further operation.</p> </dd> </dl> <h2 id="BUGS">BUGS</h2> <p>Please report any bugs or feature requests to <code>bug-math-bigint at rt.cpan.org</code>, or through the web interface at <a href="https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt">https://rt.cpan.org/Ticket/Create.html?Queue=Math-BigInt</a> (requires login). We will be notified, and then you'll automatically be notified of progress on your bug as I make changes.</p> <h2 id="SUPPORT">SUPPORT</h2> <p>You can find documentation for this module with the perldoc command.</p> <pre data-language="perl"><code class="plaintext">perldoc Math::BigFloat</code></pre> <p>You can also look for information at:</p> <ul> <li>
<p>GitHub</p> <p><a href="https://github.com/pjacklam/p5-Math-BigInt">https://github.com/pjacklam/p5-Math-BigInt</a></p> </li> <li>
<p>RT: CPAN's request tracker</p> <p><a href="https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt">https://rt.cpan.org/Dist/Display.html?Name=Math-BigInt</a></p> </li> <li>
<p>MetaCPAN</p> <p><a href="https://metacpan.org/release/Math-BigInt">https://metacpan.org/release/Math-BigInt</a></p> </li> <li>
<p>CPAN Testers Matrix</p> <p><a href="http://matrix.cpantesters.org/?dist=Math-BigInt">http://matrix.cpantesters.org/?dist=Math-BigInt</a></p> </li> <li>
<p>CPAN Ratings</p> <p><a href="https://cpanratings.perl.org/dist/Math-BigInt">https://cpanratings.perl.org/dist/Math-BigInt</a></p> </li> <li>
<p>The Bignum mailing list</p> <ul> <li>
<p>Post to mailing list</p> <p><code>bignum at lists.scsys.co.uk</code></p> </li> <li>
<p>View mailing list</p> <p><a href="http://lists.scsys.co.uk/pipermail/bignum/">http://lists.scsys.co.uk/pipermail/bignum/</a></p> </li> <li>
<p>Subscribe/Unsubscribe</p> <p><a href="http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum">http://lists.scsys.co.uk/cgi-bin/mailman/listinfo/bignum</a></p> </li> </ul> </li> </ul> <h2 id="LICENSE">LICENSE</h2> <p>This program is free software; you may redistribute it and/or modify it under the same terms as Perl itself.</p> <h2 id="SEE-ALSO">
SEE ALSO</h2> <p><a href="Math::BigInt.html">Math::BigInt</a> and <a href="Math::BigInt.html">Math::BigInt</a> as well as the backends <a href="Math::BigInt::FastCalc.html">Math::BigInt::FastCalc</a>, <a href="Math::BigInt::GMP.html">Math::BigInt::GMP</a>, and <a href="Math::BigInt::Pari.html">Math::BigInt::Pari</a>.</p> <p>The pragmas <a href="bignum.html">bignum</a>, <a href="bigint.html">bigint</a> and <a href="bigrat.html">bigrat</a>.</p> <h2 id="AUTHORS">AUTHORS</h2> <ul> <li>
<p>Mark Biggar, overloaded interface by Ilya Zakharevich, 1996-2001.</p> </li> <li>
<p>Completely rewritten by Tels <a href="http://bloodgate.com">http://bloodgate.com</a> in 2001-2008.</p> </li> <li>
<p>Florian Ragwitz &lt;flora@cpan.org&gt;, 2010.</p> </li> <li>
<p>Peter John Acklam &lt;pjacklam@gmail.com&gt;, 2011-.</p> </li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/Math::BigFloat" class="_attribution-link">https://perldoc.perl.org/5.38.0/Math::BigFloat</a>
  </p>
</div>
