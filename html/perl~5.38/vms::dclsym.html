<h1>VMS::DCLsym</h1>   <h2><a id="toc">CONTENTS</a></h2> <ul> <li> <a class="text-decoration-none" href="#NAME">NAME</a> </li> <li> <a class="text-decoration-none" href="#SYNOPSIS">SYNOPSIS</a> </li> <li> <a class="text-decoration-none" href="#DESCRIPTION">DESCRIPTION</a> <ul> <li> <a class="text-decoration-none" href="#Tied-hash-interface">Tied hash interface</a> </li> <li> <a class="text-decoration-none" href="#Object-interface">Object interface</a> </li> </ul> </li> <li> <a class="text-decoration-none" href="#AUTHOR">AUTHOR</a> </li> <li> <a class="text-decoration-none" href="#VERSION">VERSION</a> </li> <li> <a class="text-decoration-none" href="#BUGS">BUGS</a> </li> </ul> <h2 id="NAME">NAME</h2> <p>VMS::DCLsym - Perl extension to manipulate DCL symbols</p> <h2 id="SYNOPSIS">SYNOPSIS</h2> <pre data-language="perl"><code>tie %allsyms, VMS::DCLsym;
tie %cgisyms, VMS::DCLsym, 'GLOBAL';


$handle = new VMS::DCLsym;
$value = $handle-&gt;getsym($name);
$handle-&gt;setsym($name, $value, 'GLOBAL')
    or die "Can't create symbol: $!\n";
$handle-&gt;delsym($name, 'LOCAL') or die "Can't delete symbol: $!\n";
$handle-&gt;clearcache();</code></pre> <h2 id="DESCRIPTION">DESCRIPTION</h2> <p>The VMS::DCLsym extension provides access to DCL symbols using a tied hash interface. This allows Perl scripts to manipulate symbols in a manner similar to the way in which logical names are manipulated via the built-in <code>%ENV</code> hash. Alternatively, one can call methods in this package directly to read, create, and delete symbols.</p> <h3 id="Tied-hash-interface">
Tied hash interface</h3> <p>This interface lets you treat the DCL symbol table as a Perl associative array, in which the key of each element is the symbol name, and the value of the element is that symbol's value. Case is not significant in the key string, as DCL converts symbol names to uppercase, but it is significant in the value string. All of the usual operations on associative arrays are supported. Reading an element retrieves the current value of the symbol, assigning to it defines a new symbol (or overwrites the old value of an existing symbol), and deleting an element deletes the corresponding symbol. Setting an element to <code>undef</code>, or <code>undef</code>ing it directly, sets the corresponding symbol to the null string. You may also read the special keys ':GLOBAL' and ':LOCAL' to find out whether a default symbol table has been specified for this hash (see the next paragraph), or set either or these keys to specify a default symbol table.</p> <p>When you call the <code>tie</code> function to bind an associative array to this package, you may specify as an optional argument the symbol table in which you wish to create and delete symbols. If the argument is the string 'GLOBAL', then the global symbol table is used; any other string causes the local symbol table to be used. Note that this argument does not affect attempts to read symbols; if a symbol with the specified name exists in the local symbol table, it is always returned in preference to a symbol by the same name in the global symbol table.</p> <h3 id="Object-interface">
Object interface</h3> <p>Although it's less convenient in some ways than the tied hash interface, you can also call methods directly to manipulate individual symbols. In some cases, this allows you finer control than using a tied hash aggregate. The following methods are supported:</p> <dl> <dt id="new">new</dt> <dd> <p>This creates a <code>VMS::DCLsym</code> object which can be used as a handle for later method calls. The single optional argument specifies the symbol table used by default in future method calls, in the same way as the optional argument to <code>tie</code> described above.</p> </dd> <dt id="getsym">getsym</dt> <dd> <p>If called in a scalar context, <code>getsym</code> returns the value of the symbol whose name is given as the argument to the call, or <code>undef</code> if no such symbol exists. Symbols in the local symbol table are always used in preference to symbols in the global symbol table. If called in a list context, <code>getsym</code> returns a two-element list, whose first element is the value of the symbol, and whose second element is the string 'GLOBAL' or 'LOCAL', indicating the table from which the symbol's value was read.</p> </dd> <dt id="setsym">setsym</dt> <dd> <p>The first two arguments taken by this method are the name of the symbol and the value which should be assigned to it. The optional third argument is a string specifying the symbol table to be used; 'GLOBAL' specifies the global symbol table, and any other string specifies the local symbol table. If this argument is omitted, the default symbol table for the object is used. <code>setsym</code> returns TRUE if successful, and FALSE otherwise.</p> </dd> <dt id="delsym">delsym</dt> <dd> <p>This method deletes the symbol whose name is given as the first argument. The optional second argument specifies the symbol table, as described above under <code>setsym</code>. It returns TRUE if the symbol was successfully deleted, and FALSE if it was not.</p> </dd> <dt id="clearcache">clearcache</dt> <dd> <p>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling <code>clearcache</code> again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</p> <p>This method is a stopgap until we can incorporate code into this extension to traverse the process' symbol table directly, so it may disappear in a future version of this package.</p> </dd> </dl> <h2 id="AUTHOR">AUTHOR</h2> <p>Charles Bailey bailey@newman.upenn.edu</p> <h2 id="VERSION">VERSION</h2> <p>1.09</p> <h2 id="BUGS">BUGS</h2> <p>The list of symbols for the iterator is assembled by spawning off a subprocess, which can be slow. Ideally, we should just traverse the process' symbol table directly from C.</p><div class="_attribution">
  <p class="_attribution-p">
    &copy; 1993&ndash;2023 Larry Wall and others<br>Licensed under the GNU General Public License version 1 or later, or the Artistic License.<br>The Perl logo is a trademark of the Perl Foundation.<br>
    <a href="https://perldoc.perl.org/5.38.0/VMS::DCLsym" class="_attribution-link">https://perldoc.perl.org/5.38.0/VMS::DCLsym</a>
  </p>
</div>
