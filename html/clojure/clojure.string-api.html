<h1 id="overview">clojure.string</h1> <span id="author-line">by <span id="author-name">Stuart Sierra, Stuart Halloway, David Liebke</span><br></span> <br>Full namespace name: <span id="long-name">clojure.string</span>  <h2>Overview</h2> <pre id="namespace-docstr">Clojure String utilities

It is poor form to (:use clojure.string). Instead, use require
with :as to specify a prefix, e.g.

(ns your.namespace.here
  (:require [clojure.string :as str]))

Design notes for clojure.string:

1. Strings are objects (as opposed to sequences). As such, the
   string being manipulated is the first argument to a function;
   passing nil will result in a NullPointerException unless
   documented otherwise. If you want sequence-y behavior instead,
   use a sequence.

2. Functions are generally not lazy, and call straight to host
   methods where those are available and efficient.

3. Functions take advantage of String implementation details to
   write high-performing loop/recurs instead of using higher-order
   functions. (This is not idiomatic in general-purpose application
   code.)

4. When a function is documented to accept a string argument, it
   will take any implementation of the correct *interface* on the
   host platform. In Java, this is CharSequence, which is more
   general than String. In ordinary usage you will almost always
   pass concrete strings. If you are doing something unusual,
   e.g. passing a mutable implementation of CharSequence, then
   thread-safety is your responsibility.</pre>    <h2>Public Variables and Functions</h2>    <h2 id="clojure.string/blank?">blank?<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (blank? s)
</pre> <pre id="var-docstr">True if s is nil, empty, or contains only whitespace.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L288">Source</a>  <br>  <h2 id="clojure.string/capitalize">capitalize<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (capitalize s)
</pre> <pre id="var-docstr">Converts first character of the string to upper-case, all other
characters to lower-case.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L196">Source</a>  <br>  <h2 id="clojure.string/ends-with?">ends-with?<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (ends-with? s substr)
</pre> <pre id="var-docstr">True if s ends with substr.</pre>  <p class="var-added">Added in Clojure version 1.8</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L367">Source</a>  <br>  <h2 id="clojure.string/escape">escape<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (escape s cmap)
</pre> <pre id="var-docstr">Return a new string, using cmap to escape each character ch
from s as follows:

If (cmap ch) is nil, append ch to the new string.
If (cmap ch) is non-nil, append (str (cmap ch)) instead.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L301">Source</a>  <br>  <h2 id="clojure.string/includes?">includes?<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (includes? s substr)
</pre> <pre id="var-docstr">True if s includes substr.</pre>  <p class="var-added">Added in Clojure version 1.8</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L373">Source</a>  <br>  <h2 id="clojure.string/index-of">index-of<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (index-of s value)
       (index-of s value from-index)
</pre> <pre id="var-docstr">Return index of value (string or char) in s, optionally searching
forward from from-index. Return nil if value not found.</pre>  <p class="var-added">Added in Clojure version 1.8</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L319">Source</a>  <br>  <h2 id="clojure.string/join">join<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (join coll)
       (join separator coll)
</pre> <pre id="var-docstr">Returns a string of all elements in coll, as returned by (seq coll),
separated by an optional separator.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L180">Source</a>  <br>  <h2 id="clojure.string/last-index-of">last-index-of<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (last-index-of s value)
       (last-index-of s value from-index)
</pre> <pre id="var-docstr">Return last index of value (string or char) in s, optionally
searching backward from from-index. Return nil if value not found.</pre>  <p class="var-added">Added in Clojure version 1.8</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L340">Source</a>  <br>  <h2 id="clojure.string/lower-case">lower-case<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (lower-case s)
</pre> <pre id="var-docstr">Converts string to all lower-case.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L213">Source</a>  <br>  <h2 id="clojure.string/re-quote-replacement">re-quote-replacement<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (re-quote-replacement replacement)
</pre> <pre id="var-docstr">Given a replacement string that you wish to be a literal
replacement for a pattern match in replace or replace-first, do the
necessary escaping of special characters in the replacement.</pre>  <p class="var-added">Added in Clojure version 1.5</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L54">Source</a>  <br>  <h2 id="clojure.string/replace">replace<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (replace s match replacement)
</pre> <pre id="var-docstr">Replaces all instance of match with replacement in s.

match/replacement can be:

string / string
char / char
pattern / (string or function of match).

See also replace-first.

The replacement is literal (i.e. none of its characters are treated
specially) for all cases above except pattern / string.

For pattern / string, $1, $2, etc. in the replacement string are
substituted with the string that matched the corresponding
parenthesized group in the pattern.  If you wish your replacement
string r to be used literally, use (re-quote-replacement r) as the
replacement argument.  See also documentation for
java.util.regex.Matcher's appendReplacement method.

Example:
(clojure.string/replace "Almost Pig Latin" #"\b(\w)(\w+)\b" "$2$1ay")
-&gt; "lmostAay igPay atinLay"</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L75">Source</a>  <br>  <h2 id="clojure.string/replace-first">replace-first<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (replace-first s match replacement)
</pre> <pre id="var-docstr">Replaces the first instance of match with replacement in s.

match/replacement can be:

char / char
string / string
pattern / (string or function of match).

See also replace.

The replacement is literal (i.e. none of its characters are treated
specially) for all cases above except pattern / string.

For pattern / string, $1, $2, etc. in the replacement string are
substituted with the string that matched the corresponding
parenthesized group in the pattern.  If you wish your replacement
string r to be used literally, use (re-quote-replacement r) as the
replacement argument.  See also documentation for
java.util.regex.Matcher's appendReplacement method.

Example:
(clojure.string/replace-first "swap first two words"
                              #"(\w+)(\s+)(\w+)" "$3$2$1")
-&gt; "first swap two words"</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L138">Source</a>  <br>  <h2 id="clojure.string/reverse">reverse<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (reverse s)
</pre> <pre id="var-docstr">Returns s with its characters reversed.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L48">Source</a>  <br>  <h2 id="clojure.string/split">split<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (split s re)
       (split s re limit)
</pre> <pre id="var-docstr">Splits string on a regular expression.  Optional argument limit is
the maximum number of parts. Not lazy. Returns vector of the parts.
Trailing empty strings are not returned - pass limit of -1 to return all.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L219">Source</a>  <br>  <h2 id="clojure.string/split-lines">split-lines<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (split-lines s)
</pre> <pre id="var-docstr">Splits s on \n or \r\n. Trailing empty lines are not returned.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L229">Source</a>  <br>  <h2 id="clojure.string/starts-with?">starts-with?<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (starts-with? s substr)
</pre> <pre id="var-docstr">True if s starts with substr.</pre>  <p class="var-added">Added in Clojure version 1.8</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L361">Source</a>  <br>  <h2 id="clojure.string/trim">trim<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (trim s)
</pre> <pre id="var-docstr">Removes whitespace from both ends of string.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L235">Source</a>  <br>  <h2 id="clojure.string/trim-newline">trim-newline<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (trim-newline s)
</pre> <pre id="var-docstr">Removes all trailing newline \n or return \r characters from
string.  Similar to Perl's chomp.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L275">Source</a>  <br>  <h2 id="clojure.string/triml">triml<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (triml s)
</pre> <pre id="var-docstr">Removes whitespace from the left side of string.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L252">Source</a>  <br>  <h2 id="clojure.string/trimr">trimr<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (trimr s)
</pre> <pre id="var-docstr">Removes whitespace from the right side of string.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L264">Source</a>  <br>  <h2 id="clojure.string/upper-case">upper-case<span id="var-type" class="type">function</span>
</h2>  <pre id="var-usage">Usage: (upper-case s)
</pre> <pre id="var-docstr">Converts string to all upper-case.</pre>  <p class="var-added">Added in Clojure version 1.2</p> <a id="var-source" href="https://github.com/clojure/clojure/blob/ade22645ba5dbf4c0d8115b19938af96d6fb4cd5/src/clj/clojure/string.clj#L207">Source</a><div class="_attribution">
  <p class="_attribution-p">
    &copy; Rich Hickey<br>Licensed under the Eclipse Public License 1.0.<br>
    <a href="https://clojure.github.io/clojure/clojure.string-api.html" class="_attribution-link">https://clojure.github.io/clojure/clojure.string-api.html</a>
  </p>
</div>
