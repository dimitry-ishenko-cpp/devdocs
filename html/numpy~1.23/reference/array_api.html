<h1 id="array-api">Array API Standard Compatibility</h1> <div class="admonition note"> <p class="admonition-title">Note</p> <p>The <code>numpy.array_api</code> module is still experimental. See <a class="reference external" href="https://numpy.org/neps/nep-0047-array-api-standard.html">NEP 47</a>.</p> </div> <p>NumPy includes a reference implementation of the <a class="reference external" href="https://data-apis.org/array-api/latest/">array API standard</a> in <code>numpy.array_api</code>. <a class="reference external" href="https://numpy.org/neps/nep-0047-array-api-standard.html">NEP 47</a> describes the motivation and scope for implementing the array API standard in NumPy.</p> <p>The <code>numpy.array_api</code> module serves as a minimal, reference implementation of the array API standard. In being minimal, the module only implements those things that are explicitly required by the specification. Certain things are allowed by the specification but are explicitly disallowed in <code>numpy.array_api</code>. This is so that the module can serve as a reference implementation for users of the array API standard. Any consumer of the array API can test their code against <code>numpy.array_api</code> and be sure that they aren’t using any features that aren’t guaranteed by the spec, and which may not be present in other conforming libraries.</p> <p>The <code>numpy.array_api</code> module is not documented here. For a listing of the functions present in the array API specification, refer to the <a class="reference external" href="https://data-apis.org/array-api/latest/">array API standard</a>. The <code>numpy.array_api</code> implementation is functionally complete, so all functionality described in the standard is implemented.</p> <section id="table-of-differences-between-numpy-array-api-and-numpy"> <h2 id="array-api-differences">Table of Differences between <code>numpy.array_api</code> and <code>numpy</code>
</h2> <p>This table outlines the primary differences between <code>numpy.array_api</code> from the main <code>numpy</code> namespace. There are three types of differences:</p> <ol class="arabic simple"> <li>
<strong>Strictness</strong>. Things that are only done so that <code>numpy.array_api</code> is a strict, minimal implementation. They aren’t actually required by the spec, and other conforming libraries may not follow them. In most cases, spec does not specify or require any behavior outside of the given domain. The main <code>numpy</code> namespace would not need to change in any way to be spec-compatible for these.</li> <li>
<strong>Compatible</strong>. Things that could be added to the main <code>numpy</code> namespace without breaking backwards compatibility.</li> <li>
<strong>Breaking</strong>. Things that would break backwards compatibility if implemented in the main <code>numpy</code> namespace.</li> </ol> <section id="name-differences"> <h3>Name Differences</h3> <p>Many functions have been renamed in the spec from NumPy. These are otherwise identical in behavior, and are thus all <strong>compatible</strong> changes, unless otherwise noted.</p> <section id="function-name-changes"> <h4 id="array-api-name-changes">Function Name Changes</h4> <p>The following functions are named differently in the array API</p> <table class="table">  <thead> <tr>
<th class="head"><p>Array API name</p></th> <th class="head"><p>NumPy namespace name</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>acos</code></p></td> <td><p><code>arccos</code></p></td> <td></td> </tr> <tr>
<td><p><code>acosh</code></p></td> <td><p><code>arccosh</code></p></td> <td></td> </tr> <tr>
<td><p><code>asin</code></p></td> <td><p><code>arcsin</code></p></td> <td></td> </tr> <tr>
<td><p><code>asinh</code></p></td> <td><p><code>arcsinh</code></p></td> <td></td> </tr> <tr>
<td><p><code>atan</code></p></td> <td><p><code>arctan</code></p></td> <td></td> </tr> <tr>
<td><p><code>atan2</code></p></td> <td><p><code>arctan2</code></p></td> <td></td> </tr> <tr>
<td><p><code>atanh</code></p></td> <td><p><code>arctanh</code></p></td> <td></td> </tr> <tr>
<td><p><code>bitwise_left_shift</code></p></td> <td><p><code>left_shift</code></p></td> <td></td> </tr> <tr>
<td><p><code>bitwise_invert</code></p></td> <td><p><code>invert</code></p></td> <td></td> </tr> <tr>
<td><p><code>bitwise_right_shift</code></p></td> <td><p><code>right_shift</code></p></td> <td></td> </tr> <tr>
<td><p><code>bool</code></p></td> <td><p><code>bool_</code></p></td> <td><p>This is <strong>breaking</strong> because <code>np.bool</code> is currently a deprecated alias for the built-in <code>bool</code>.</p></td> </tr> <tr>
<td><p><code>concat</code></p></td> <td><p><code>concatenate</code></p></td> <td></td> </tr> <tr>
<td><p><code>matrix_norm</code> and <code>vector_norm</code></p></td> <td><p><code>norm</code></p></td> <td><p><code>matrix_norm</code> and <code>vector_norm</code> each do a limited subset of what <code>np.norm</code> does.</p></td> </tr> <tr>
<td><p><code>permute_dims</code></p></td> <td><p><code>transpose</code></p></td> <td><p>Unlike <code>np.transpose</code>, the <code>axis</code> keyword-argument to <code>permute_dims</code> is required.</p></td> </tr> <tr>
<td><p><code>pow</code></p></td> <td><p><code>power</code></p></td> <td></td> </tr> <tr>
<td><p><code>unique_all</code>, <code>unique_counts</code>, <code>unique_inverse</code>, and <code>unique_values</code></p></td> <td><p><code>unique</code></p></td> <td><p>Each is equivalent to <code>np.unique</code> with certain flags set.</p></td> </tr>  </table> </section> <section id="function-instead-of-method"> <h4>Function instead of method</h4> <ul class="simple"> <li>
<code>astype</code> is a function in the array API, whereas it is a method on <code>ndarray</code> in <code>numpy</code>.</li> </ul> </section> <section id="linalg-namespace-differences"> <h4>
<code>linalg</code> Namespace Differences</h4> <p>These functions are in the <code>linalg</code> sub-namespace in the array API, but are only in the top-level namespace in NumPy:</p> <ul class="simple"> <li><code>cross</code></li> <li><code>diagonal</code></li> <li>
<code>matmul</code> (*)</li> <li><code>outer</code></li> <li>
<code>tensordot</code> (*)</li> <li><code>trace</code></li> </ul> <p>(*): These functions are also in the top-level namespace in the array API.</p> </section> <section id="keyword-argument-renames"> <h4>Keyword Argument Renames</h4> <p>The following functions have keyword arguments that have been renamed. The functionality of the keyword argument is identical unless otherwise stated. Each new keyword argument is not already present on the given function in <code>numpy</code>, so the changes are <strong>compatible</strong>.</p> <p>Note, this page does not list function keyword arguments that are in the main <code>numpy</code> namespace but not in the array API. Such keyword arguments are omitted from <code>numpy.array_api</code> for <strong>strictness</strong>, as the spec allows functions to include additional keyword arguments from those required.</p> <table class="table">  <thead> <tr>
<th class="head"><p>Function</p></th> <th class="head"><p>Array API keyword name</p></th> <th class="head"><p>NumPy keyword name</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>argsort</code> and <code>sort</code></p></td> <td><p><code>stable</code></p></td> <td><p><code>kind</code></p></td> <td><p>The definitions of <code>stable</code> and <code>kind</code> differ, as do the default values. The change of the default value makes this <strong>breaking</strong>. See <a class="reference internal" href="#array-api-set-functions-differences"><span class="std std-ref">Set Functions Differences</span></a>.</p></td> </tr> <tr>
<td><p><code>matrix_rank</code></p></td> <td><p><code>rtol</code></p></td> <td><p><code>tol</code></p></td> <td><p>The definitions of <code>rtol</code> and <code>tol</code> differ, as do the default values. The change of the default value makes this <strong>breaking</strong>. See <a class="reference internal" href="#array-api-linear-algebra-differences"><span class="std std-ref">Linear Algebra Differences</span></a>.</p></td> </tr> <tr>
<td><p><code>pinv</code></p></td> <td><p><code>rtol</code></p></td> <td><p><code>rcond</code></p></td> <td><p>The definitions of <code>rtol</code> and <code>rcond</code> are the same, but their default values differ, making this <strong>breaking</strong>. See <a class="reference internal" href="#array-api-linear-algebra-differences"><span class="std std-ref">Linear Algebra Differences</span></a>.</p></td> </tr> <tr>
<td><p><code>std</code> and <code>var</code></p></td> <td><p><code>correction</code></p></td> <td><p><code>ddof</code></p></td> <td></td> </tr>  </table> </section> </section> <section id="type-promotion-differences"> <h3 id="array-api-type-promotion-differences">Type Promotion Differences</h3> <p>Type promotion is the biggest area where NumPy deviates from the spec. The most notable difference is that NumPy does value-based casting in many cases. The spec explicitly disallows value-based casting. In the array API, the result type of any operation is always determined entirely by the input types, independently of values or shapes.</p> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>Limited set of dtypes.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p><code>numpy.array_api</code> only implements those <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/data_types.html">dtypes that are required by the spec</a>.</p></td> </tr> <tr>
<td><p>Operators (like <code>+</code>) with Python scalars only accept matching scalar types.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>For example, <code>&lt;int32 array&gt; + 1.0</code> is not allowed. See <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars">the spec rules for mixing arrays and Python scalars</a>.</p></td> </tr> <tr>
<td><p>Operators (like <code>+</code>) with Python scalars always return the same dtype as the array.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>For example, <code>numpy.array_api.asarray(0., dtype=float32) + 1e64</code> is a <code>float32</code> array.</p></td> </tr> <tr>
<td><p>In-place operators are disallowed when the left-hand side would be promoted.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>Example: <code>a = np.array(1, dtype=np.int8); a += np.array(1, dtype=np.int16)</code>. The spec explicitly disallows this.</p></td> </tr> <tr>
<td><p><code>int</code> promotion for operators is only specified for integers within the bounds of the dtype.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p><code>numpy.array_api</code> fallsback to <code>np.ndarray</code> behavior (either cast or raise <code>OverflowError</code>).</p></td> </tr> <tr>
<td><p><code>__pow__</code> and <code>__rpow__</code> do not do value-based casting for 0-D arrays.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>For example, <code>np.array(0., dtype=float32)**np.array(0.,
dtype=float64)</code> is <code>float32</code>. Note that this is value-based casting on 0-D arrays, not scalars.</p></td> </tr> <tr>
<td><p>No cross-kind casting.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>Namely, boolean, integer, and floating-point data types do not cast to each other, except explicitly with <code>astype</code> (this is separate from the behavior with Python scalars).</p></td> </tr> <tr>
<td><p>No casting unsigned integer dtypes to floating dtypes (e.g., <code>int64 +
uint64 -&gt; float64</code>.</p></td> <td><p><strong>Strictness</strong></p></td> <td></td> </tr> <tr>
<td><p><code>can_cast</code> and <code>result_type</code> are restricted.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>The <code>numpy.array_api</code> implementations disallow cross-kind casting.</p></td> </tr> <tr>
<td><p><code>sum</code> and <code>prod</code> always upcast <code>float32</code> to <code>float64</code> when <code>dtype=None</code>.</p></td> <td><p><strong>Breaking</strong></p></td> <td></td> </tr>  </table> </section> <section id="indexing-differences"> <h3>Indexing Differences</h3> <p>The spec requires only a subset of indexing, but all indexing rules in the spec are compatible with NumPy’s more broad indexing rules.</p> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>No implicit ellipses (<code>...</code>).</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>If an index does not include an ellipsis, all axes must be indexed.</p></td> </tr> <tr>
<td><p>The start and stop of a slice may not be out of bounds.</p></td> <td><p><strong>Strictness</strong></p></td> <td>
<p>For a slice <code>i:j:k</code>, only the following are allowed:</p> <ul class="simple"> <li>
<code>i</code> or <code>j</code> omitted (<code>None</code>).</li> <li>
<code>-n &lt;= i &lt;= max(0, n - 1)</code>.</li> <li>For <code>k &gt; 0</code> or <code>k</code> omitted (<code>None</code>), <code>-n &lt;= j &lt;= n</code>.</li> <li>For <code>k &lt; 0</code>, <code>-n - 1 &lt;= j &lt;= max(0, n - 1)</code>.</li> </ul> </td> </tr> <tr>
<td><p>Boolean array indices are only allowed as the sole index.</p></td> <td><p><strong>Strictness</strong></p></td> <td></td> </tr> <tr>
<td><p>Integer array indices are not allowed at all.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>With the exception of 0-D arrays, which are treated like integers.</p></td> </tr>  </table> </section> <section id="type-strictness"> <h3 id="array-api-type-strictness">Type Strictness</h3> <p>Functions in <code>numpy.array_api</code> restrict their inputs to only those dtypes that are explicitly required by the spec, even when the wrapped corresponding NumPy function would allow a broader set. Here, we list each function and the dtypes that are allowed in <code>numpy.array_api</code>. These are <strong>strictness</strong> differences because the spec does not require that other dtypes result in an error. The categories here are defined as follows:</p> <ul class="simple"> <li>
<strong>Floating-point</strong>: <code>float32</code> or <code>float64</code>.</li> <li>
<strong>Integer</strong>: Any signed or unsigned integer dtype (<code>int8</code>, <code>int16</code>, <code>int32</code>, <code>int64</code>, <code>uint8</code>, <code>uint16</code>, <code>uint32</code>, or <code>uint64</code>).</li> <li>
<strong>Boolean</strong>: <code>bool</code>.</li> <li>
<strong>Integer or boolean</strong>: Any signed or unsigned integer dtype, or <code>bool</code>. For two-argument functions, both arguments must be integer or both must be <code>bool</code>.</li> <li>
<strong>Numeric</strong>: Any integer or floating-point dtype. For two-argument functions, both arguments must be integer or both must be floating-point.</li> <li>
<strong>All</strong>: Any of the above dtype categories. For two-argument functions, both arguments must be the same kind (integer, floating-point, or boolean).</li> </ul> <p>In all cases, the return dtype is chosen according to <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/type_promotion.html">the rules outlined in the spec</a>, and does not differ from NumPy’s return dtype for any of the allowed input dtypes, except in the cases mentioned specifically in the subsections below.</p> <section id="elementwise-functions"> <h4>Elementwise Functions</h4> <table class="table">  <thead> <tr>
<th class="head"><p>Function Name</p></th> <th class="head"><p>Dtypes</p></th> </tr> </thead>  <tr>
<td><p><code>abs</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>acos</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>acosh</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>add</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>asin</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>asinh</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>atan</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>atan2</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>atanh</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>bitwise_and</code></p></td> <td><p>Integer or boolean</p></td> </tr> <tr>
<td><p><code>bitwise_invert</code></p></td> <td><p>Integer or boolean</p></td> </tr> <tr>
<td><p><code>bitwise_left_shift</code> (*)</p></td> <td><p>Integer</p></td> </tr> <tr>
<td><p><code>bitwise_or</code></p></td> <td><p>Integer or boolean</p></td> </tr> <tr>
<td><p><code>bitwise_right_shift</code> (*)</p></td> <td><p>Integer</p></td> </tr> <tr>
<td><p><code>bitwise_xor</code></p></td> <td><p>Integer or boolean</p></td> </tr> <tr>
<td><p><code>ceil</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>cos</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>cosh</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>divide</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>equal</code></p></td> <td><p>All</p></td> </tr> <tr>
<td><p><code>exp</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>expm1</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>floor</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>floor_divide</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>greater</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>greater_equal</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>isfinite</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>isinf</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>isnan</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>less</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>less_equal</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>log</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>logaddexp</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>log10</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>log1p</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>log2</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>logical_and</code></p></td> <td><p>Boolean</p></td> </tr> <tr>
<td><p><code>logical_not</code></p></td> <td><p>Boolean</p></td> </tr> <tr>
<td><p><code>logical_or</code></p></td> <td><p>Boolean</p></td> </tr> <tr>
<td><p><code>logical_xor</code></p></td> <td><p>Boolean</p></td> </tr> <tr>
<td><p><code>multiply</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>negative</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>not_equal</code></p></td> <td><p>All</p></td> </tr> <tr>
<td><p><code>positive</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>pow</code> (*)</p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>remainder</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>round</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>sign</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>sin</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>sinh</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>sqrt</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>square</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>subtract</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>tan</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>tanh</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>trunc</code></p></td> <td><p>Numeric</p></td> </tr>  </table> <p>(*) These functions have different names from the main <code>numpy</code> namespace. See <a class="reference internal" href="#array-api-name-changes"><span class="std std-ref">Function Name Changes</span></a>.</p> </section> <section id="creation-functions"> <h4>Creation Functions</h4> <table class="table">  <thead> <tr>
<th class="head"><p>Function Name</p></th> <th class="head"><p>Dtypes</p></th> </tr> </thead>  <tr>
<td><p><code>meshgrid</code></p></td> <td><p>Any (all input dtypes must be the same)</p></td> </tr>  </table> </section> <section id="linear-algebra-functions"> <h4>Linear Algebra Functions</h4> <table class="table">  <thead> <tr>
<th class="head"><p>Function Name</p></th> <th class="head"><p>Dtypes</p></th> </tr> </thead>  <tr>
<td><p><code>cholesky</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>cross</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>det</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>diagonal</code></p></td> <td><p>Any</p></td> </tr> <tr>
<td><p><code>eigh</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>eighvals</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>inv</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>matmul</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>matrix_norm</code> (*)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>matrix_power</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>matrix_rank</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>matrix_transpose</code> (**)</p></td> <td><p>Any</p></td> </tr> <tr>
<td><p><code>outer</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>pinv</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>qr</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>slogdet</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>solve</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>svd</code></p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>svdvals</code> (**)</p></td> <td><p>Floating-point</p></td> </tr> <tr>
<td><p><code>tensordot</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>trace</code></p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>vecdot</code> (**)</p></td> <td><p>Numeric</p></td> </tr> <tr>
<td><p><code>vector_norm</code> (*)</p></td> <td><p>Floating-point</p></td> </tr>  </table> <p>(*) Thes functions are split from <code>norm</code> from the main <code>numpy</code> namespace. See <a class="reference internal" href="#array-api-name-changes"><span class="std std-ref">Function Name Changes</span></a>.</p> <p>(**) These functions are new in the array API and are not in the main <code>numpy</code> namespace.</p> </section> <section id="array-object"> <h4>Array Object</h4> <p>All the special <code>__operator__</code> methods on the array object behave identically to their corresponding functions (see <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/array_object.html#methods">the spec</a> for a list of which methods correspond to which functions). The exception is that operators explicitly allow Python scalars according to the <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/type_promotion.html#mixing-arrays-with-python-scalars">rules outlined in the spec</a> (see <a class="reference internal" href="#array-api-type-promotion-differences"><span class="std std-ref">Type Promotion Differences</span></a>).</p> </section> </section> <section id="array-object-differences"> <h3>Array Object Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>No array scalars</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>The spec does not have array scalars, only 0-D arrays. However, other than the promotion differences outlined in <a class="reference internal" href="#array-api-type-promotion-differences"><span class="std std-ref">Type Promotion Differences</span></a>, scalars duck type as 0-D arrays for the purposes of the spec. The are immutable, but the spec <a class="reference external" href="https://data-apis.org/array-api/latest/design_topics/copies_views_and_mutation.html">does not require mutability</a>.</p></td> </tr> <tr>
<td><p><code>bool()</code>, <code>int()</code>, and <code>float()</code> only work on 0-D arrays.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>See <a class="reference external" href="https://github.com/numpy/numpy/issues/10404">https://github.com/numpy/numpy/issues/10404</a>.</p></td> </tr> <tr>
<td><p><code>__imatmul__</code></p></td> <td><p><strong>Compatible</strong></p></td> <td><p><code>np.ndarray</code> does not currently implement <code>__imatmul</code>. Note that <code>a @= b</code> should only defined when it does not change the shape of <code>a</code>.</p></td> </tr> <tr>
<td><p>The <code>mT</code> attribute for matrix transpose.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.mT.html">the spec definition</a> for <code>mT</code>.</p></td> </tr> <tr>
<td><p>The <code>T</code> attribute should error if the input is not 2-dimensional.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>See <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/generated/signatures.array_object.array.T.html">the note in the spec</a>.</p></td> </tr> <tr>
<td><p>New method <code>to_device</code> and attribute <code>device</code></p></td> <td><p><strong>Compatible</strong></p></td> <td><p>The methods would effectively not do anything since NumPy is CPU only</p></td> </tr>  </table> </section> <section id="creation-functions-differences"> <h3>Creation Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>copy</code> keyword argument to <code>asarray</code></p></td> <td><p><strong>Compatible</strong></p></td> <td></td> </tr> <tr>
<td><p>New <code>device</code> keyword argument to all array creation functions (<code>asarray</code>, <code>arange</code>, <code>empty</code>, <code>empty_like</code>, <code>eye</code>, <code>full</code>, <code>full_like</code>, <code>linspace</code>, <code>ones</code>, <code>ones_like</code>, <code>zeros</code>, and <code>zeros_like</code>).</p></td> <td><p><strong>Compatible</strong></p></td> <td><p><code>device</code> would effectively do nothing, since NumPy is CPU only.</p></td> </tr>  </table> </section> <section id="elementwise-functions-differences"> <h3>Elementwise Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>Various functions have been renamed.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference internal" href="#array-api-name-changes"><span class="std std-ref">Function Name Changes</span></a>.</p></td> </tr> <tr>
<td><p>Elementwise functions are only defined for given input type combinations.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>See <a class="reference internal" href="#array-api-type-strictness"><span class="std std-ref">Type Strictness</span></a>.</p></td> </tr> <tr>
<td><p><code>bitwise_left_shift</code> and <code>bitwise_right_shift</code> are only defined for <code>x2</code> nonnegative.</p></td> <td><p><strong>Strictness</strong></p></td> <td></td> </tr> <tr>
<td><p><code>ceil</code>, <code>floor</code>, and <code>trunc</code> return an integer with integer input.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p><code>np.ceil</code>, <code>np.floor</code>, and <code>np.trunc</code> return a floating-point dtype on integer dtype input.</p></td> </tr>  </table> </section> <section id="linear-algebra-differences"> <h3 id="array-api-linear-algebra-differences">Linear Algebra Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>cholesky</code> includes an <code>upper</code> keyword argument.</p></td> <td><p><strong>Compatible</strong></p></td> <td></td> </tr> <tr>
<td><p><code>cross</code> does not allow size 2 vectors (only size 3).</p></td> <td><p><strong>Breaking</strong></p></td> <td></td> </tr> <tr>
<td><p><code>diagonal</code> operates on the last two axes.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>Strictly speaking this can be <strong>compatible</strong> because <code>diagonal</code> is moved to the <code>linalg</code> namespace.</p></td> </tr> <tr>
<td><p><code>eigh</code>, <code>qr</code>, <code>slogdet</code> and <code>svd</code> return a named tuple.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>The corresponding <code>numpy</code> functions return a <code>tuple</code>, with the resulting arrays in the same order.</p></td> </tr> <tr>
<td><p>New functions <code>matrix_norm</code> and <code>vector_norm</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>The <code>norm</code> function has been omitted from the array API and split into <code>matrix_norm</code> for matrix norms and <code>vector_norm</code> for vector norms. Note that <code>vector_norm</code> supports any number of axes, whereas <code>np.linalg.norm</code> only supports a single axis for vector norms.</p></td> </tr> <tr>
<td><p><code>matrix_rank</code> has an <code>rtol</code> keyword argument instead of <code>tol</code>.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>In the array API, <code>rtol</code> filters singular values smaller than <code>rtol * largest_singular_value</code>. In <code>np.linalg.matrix_rank</code>, <code>tol</code> filters singular values smaller than <code>tol</code>. Furthermore, the default value for <code>rtol</code> is <code>max(M, N) * eps</code>, whereas the default value of <code>tol</code> in <code>np.linalg.matrix_rank</code> is <code>S.max() *
max(M, N) * eps</code>, where <code>S</code> is the singular values of the input. The new flag name is compatible but the default change is breaking</p></td> </tr> <tr>
<td><p><code>matrix_rank</code> does not support 1-dimensional arrays.</p></td> <td><p><strong>Breaking</strong></p></td> <td></td> </tr> <tr>
<td><p>New function <code>matrix_transpose</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>Unlike <code>np.transpose</code>, <code>matrix_transpose</code> only transposes the last two axes. See <a class="reference external" href="https://data-apis.org/array-api/latest/API_specification/generated/signatures.linear_algebra_functions.matrix_transpose.html#signatures.linear_algebra_functions.matrix_transpose">the spec definition</a></p></td> </tr> <tr>
<td><p><code>outer</code> only supports 1-dimensional arrays.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>The spec currently only specifies behavior on 1-D arrays but future behavior will likely be to broadcast, rather than flatten, which is what <code>np.outer</code> does.</p></td> </tr> <tr>
<td><p><code>pinv</code> has an <code>rtol</code> keyword argument instead of <code>rcond</code></p></td> <td><p><strong>Breaking</strong></p></td> <td><p>The meaning of <code>rtol</code> and <code>rcond</code> is the same, but the default value for <code>rtol</code> is <code>max(M, N) * eps</code>, whereas the default value for <code>rcond</code> is <code>1e-15</code>. The new flag name is compatible but the default change is breaking.</p></td> </tr> <tr>
<td><p><code>solve</code> only accepts <code>x2</code> as a vector when it is exactly 1-dimensional.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p>The <code>np.linalg.solve</code> behavior is ambiguous. See <a class="reference external" href="https://github.com/numpy/numpy/issues/15349">this numpy issue</a> and <a class="reference external" href="https://github.com/data-apis/array-api/issues/285">this array API specification issue</a> for more details.</p></td> </tr> <tr>
<td><p>New function <code>svdvals</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>Equivalent to <code>np.linalg.svd(compute_uv=False)</code>.</p></td> </tr> <tr>
<td><p>The <code>axis</code> keyword to <code>tensordot</code> must be a tuple.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>In <code>np.tensordot</code>, it can also be an array or array-like.</p></td> </tr> <tr>
<td><p><code>trace</code> operates on the last two axes.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p><code>np.trace</code> operates on the first two axes by default. Note that the array API <code>trace</code> does not allow specifying which axes to operate on.</p></td> </tr>  </table> </section> <section id="manipulation-functions-differences"> <h3>Manipulation Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>Various functions have been renamed</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference internal" href="#array-api-name-changes"><span class="std std-ref">Function Name Changes</span></a>.</p></td> </tr> <tr>
<td><p><code>concat</code> has different default casting rules from <code>np.concatenate</code></p></td> <td><p><strong>Strictness</strong></p></td> <td><p>No cross-kind casting. No value-based casting on scalars (when axis=None).</p></td> </tr> <tr>
<td><p><code>stack</code> has different default casting rules from <code>np.stack</code></p></td> <td><p><strong>Strictness</strong></p></td> <td><p>No cross-kind casting.</p></td> </tr> <tr>
<td><p>New function <code>permute_dims</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>Unlike <code>np.transpose</code>, the <code>axis</code> keyword argument to <code>permute_dims</code> is required.</p></td> </tr> <tr>
<td><p><code>reshape</code> function has a <code>copy</code> keyword argument</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference external" href="https://github.com/numpy/numpy/issues/9818">https://github.com/numpy/numpy/issues/9818</a>.</p></td> </tr>  </table> </section> <section id="set-functions-differences"> <h3>Set Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>New functions <code>unique_all</code>, <code>unique_counts</code>, <code>unique_inverse</code>, and <code>unique_values</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference internal" href="#array-api-name-changes"><span class="std std-ref">Function Name Changes</span></a>.</p></td> </tr> <tr>
<td><p>The four <code>unique_*</code> functions return a named tuple.</p></td> <td><p><strong>Compatible</strong></p></td> <td></td> </tr> <tr>
<td><p><code>unique_all</code> and <code>unique_indices</code> return indices with the same shape as <code>x</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td><p>See <a class="reference external" href="https://github.com/numpy/numpy/issues/20638">https://github.com/numpy/numpy/issues/20638</a>.</p></td> </tr>  </table> </section> <section id="array-api-set-functions-differences"> <h3 id="id1">Set Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>argsort</code> and <code>sort</code> have a <code>stable</code> keyword argument instead of <code>kind</code>.</p></td> <td><p><strong>Breaking</strong></p></td> <td><p><code>stable</code> is a boolean keyword argument, defaulting to <code>True</code>. <code>kind</code> takes a string, defaulting to <code>"quicksort"</code>. <code>stable=True</code> is equivalent to <code>kind="stable"</code> and <code>kind=False</code> is equivalent to <code>kind="quicksort"</code>, although any sorting algorithm is allowed by the spec when <code>stable=False</code>. The new flag name is compatible but the default change is breaking.</p></td> </tr> <tr>
<td><p><code>argsort</code> and <code>sort</code> have a <code>descending</code> keyword argument.</p></td> <td><p><strong>Compatible</strong></p></td> <td></td> </tr>  </table> </section> <section id="statistical-functions-differences"> <h3>Statistical Functions Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p><code>sum</code> and <code>prod</code> always upcast <code>float32</code> to <code>float64</code> when <code>dtype=None</code>.</p></td> <td><p><strong>Breaking</strong></p></td> <td></td> </tr> <tr>
<td><p>The <code>std</code> and <code>var</code> functions have a <code>correction</code> keyword argument instead of <code>ddof</code>.</p></td> <td><p><strong>Compatible</strong></p></td> <td></td> </tr>  </table> </section> <section id="other-differences"> <h3>Other Differences</h3> <table class="table">  <thead> <tr>
<th class="head"><p>Feature</p></th> <th class="head"><p>Type</p></th> <th class="head"><p>Notes</p></th> </tr> </thead>  <tr>
<td><p>Dtypes can only be spelled as dtype objects.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>For example, <code>numpy.array_api.asarray([0], dtype='int32')</code> is not allowed.</p></td> </tr> <tr>
<td><p><code>asarray</code> is not implicitly called in any function.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>The exception is Python operators, which accept Python scalars in certain cases (see <a class="reference internal" href="#array-api-type-promotion-differences"><span class="std std-ref">Type Promotion Differences</span></a>).</p></td> </tr> <tr>
<td><p><code>tril</code> and <code>triu</code> require the input to be at least 2-D.</p></td> <td><p><strong>Strictness</strong></p></td> <td></td> </tr> <tr>
<td><p>finfo() return type uses <code>float</code> for the various attributes.</p></td> <td><p><strong>Strictness</strong></p></td> <td><p>The spec allows duck typing, so <code>finfo</code> returning dtype scalars is considered type compatible with <code>float</code>.</p></td> </tr>  </table> </section> </section><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/array_api.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/array_api.html</a>
  </p>
</div>
