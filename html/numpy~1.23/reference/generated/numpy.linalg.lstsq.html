<h1>numpy.linalg.lstsq</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.linalg.lstsq"> <span class="sig-prename descclassname">linalg.</span><span class="sig-name descname">lstsq</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">b</span></em>, <em class="sig-param"><span class="n">rcond</span><span class="o">=</span><span class="default_value">'warn'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/linalg/linalg.py#L2165-L2322"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return the least-squares solution to a linear matrix equation.</p> <p>Computes the vector <code>x</code> that approximately solves the equation <code>a @ x = b</code>. The equation may be under-, well-, or over-determined (i.e., the number of linearly independent rows of <code>a</code> can be less than, equal to, or greater than its number of linearly independent columns). If <code>a</code> is square and of full rank, then <code>x</code> (but for round-off error) is the “exact” solution of the equation. Else, <code>x</code> minimizes the Euclidean 2-norm <span class="math notranslate nohighlight">\(||b - ax||\)</span>. If there are multiple minimizing solutions, the one with the smallest 2-norm <span class="math notranslate nohighlight">\(||x||\)</span> is returned.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">(M, N) array_like</span>
</dt>
<dd>
<p>“Coefficient” matrix.</p> </dd> <dt>
<strong>b</strong><span class="classifier">{(M,), (M, K)} array_like</span>
</dt>
<dd>
<p>Ordinate or “dependent variable” values. If <code>b</code> is two-dimensional, the least-squares solution is calculated for each of the <code>K</code> columns of <code>b</code>.</p> </dd> <dt>
<strong>rcond</strong><span class="classifier">float, optional</span>
</dt>
<dd>
<p>Cut-off ratio for small singular values of <code>a</code>. For the purposes of rank determination, singular values are treated as zero if they are smaller than <code>rcond</code> times the largest singular value of <code>a</code>.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.14.0: </span>If not set, a FutureWarning is given. The previous default of <code>-1</code> will use the machine precision as <code>rcond</code> parameter, the new default will use the machine precision times <code>max(M, N)</code>. To silence the warning and use the new default, use <code>rcond=None</code>, to keep using the old behavior, use <code>rcond=-1</code>.</p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>x</strong><span class="classifier">{(N,), (N, K)} ndarray</span>
</dt>
<dd>
<p>Least-squares solution. If <code>b</code> is two-dimensional, the solutions are in the <code>K</code> columns of <code>x</code>.</p> </dd> <dt>
<strong>residuals</strong><span class="classifier">{(1,), (K,), (0,)} ndarray</span>
</dt>
<dd>
<p>Sums of squared residuals: Squared Euclidean 2-norm for each column in <code>b - a @ x</code>. If the rank of <code>a</code> is &lt; N or M &lt;= N, this is an empty array. If <code>b</code> is 1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).</p> </dd> <dt>
<strong>rank</strong><span class="classifier">int</span>
</dt>
<dd>
<p>Rank of matrix <code>a</code>.</p> </dd> <dt>
<strong>s</strong><span class="classifier">(min(M, N),) ndarray</span>
</dt>
<dd>
<p>Singular values of <code>a</code>.</p> </dd> </dl> </dd> <dt class="field-odd">Raises</dt> <dd class="field-odd">
<dl class="simple"> <dt>LinAlgError</dt>
<dd>
<p>If computation does not converge.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq" title="(in SciPy v1.8.1)"><code>scipy.linalg.lstsq</code></a></dt>
<dd>
<p>Similar function in SciPy.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>If <code>b</code> is a matrix, then all array results are returned as matrices.</p> <h4 class="rubric">Examples</h4> <p>Fit a line, <code>y = mx + c</code>, through some noisy data-points:</p> <pre data-language="python">&gt;&gt;&gt; x = np.array([0, 1, 2, 3])
&gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])
</pre> <p>By examining the coefficients, we see that the line should have a gradient of roughly 1 and cut the y-axis at, more or less, -1.</p> <p>We can rewrite the line equation as <code>y = Ap</code>, where <code>A = [[x 1]]</code> and <code>p = [[m], [c]]</code>. Now use <a class="reference internal" href="#numpy.linalg.lstsq" title="numpy.linalg.lstsq"><code>lstsq</code></a> to solve for <code>p</code>:</p> <pre data-language="python">&gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T
&gt;&gt;&gt; A
array([[ 0.,  1.],
       [ 1.,  1.],
       [ 2.,  1.],
       [ 3.,  1.]])
</pre> <pre data-language="python">&gt;&gt;&gt; m, c = np.linalg.lstsq(A, y, rcond=None)[0]
&gt;&gt;&gt; m, c
(1.0 -0.95) # may vary
</pre> <p>Plot the data along with the fitted line:</p> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
&gt;&gt;&gt; _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
&gt;&gt;&gt; _ = plt.legend()
&gt;&gt;&gt; plt.show()
</pre> <figure class="align-default"> <img alt="../../_images/numpy-linalg-lstsq-1.png" class="plot-directive" src="data:image/png;base64,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"> </figure> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.linalg.lstsq.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.linalg.lstsq.html</a>
  </p>
</div>
