<h1>numpy.meshgrid</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.meshgrid"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">meshgrid</span><span class="sig-paren">(</span><em class="sig-param"><span class="o">*</span><span class="n">xi</span></em>, <em class="sig-param"><span class="n">copy</span><span class="o">=</span><span class="default_value">True</span></em>, <em class="sig-param"><span class="n">sparse</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">indexing</span><span class="o">=</span><span class="default_value">'xy'</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/lib/function_base.py#L4846-L4992"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Return coordinate matrices from coordinate vectors.</p> <p>Make N-D coordinate arrays for vectorized evaluations of N-D scalar/vector fields over N-D grids, given one-dimensional coordinate arrays x1, x2,…, xn.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.9: </span>1-D and 0-D cases are allowed.</p> </div> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>x1, x2,…, xn</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>1-D arrays representing the coordinates of a grid.</p> </dd> <dt>
<strong>indexing</strong><span class="classifier">{‘xy’, ‘ij’}, optional</span>
</dt>
<dd>
<p>Cartesian (‘xy’, default) or matrix (‘ij’) indexing of output. See Notes for more details.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.0.</span></p> </div> </dd> <dt>
<strong>sparse</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If True the shape of the returned coordinate array for dimension <em>i</em> is reduced from <code>(N1, ..., Ni, ... Nn)</code> to <code>(1, ..., 1, Ni, 1, ..., 1)</code>. These sparse coordinate grids are intended to be use with <a class="reference internal" href="../../user/basics.broadcasting.html#basics-broadcasting"><span class="std std-ref">Broadcasting</span></a>. When all coordinates are used in an expression, broadcasting still leads to a fully-dimensonal result array.</p> <p>Default is False.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.0.</span></p> </div> </dd> <dt>
<strong>copy</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If False, a view into the original arrays are returned in order to conserve memory. Default is True. Please note that <code>sparse=False, copy=False</code> will likely return non-contiguous arrays. Furthermore, more than one element of a broadcast array may refer to a single memory location. If you need to write to the arrays, make copies first.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.7.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>X1, X2,…, XN</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>For vectors <code>x1</code>, <code>x2</code>,…, <code>xn</code> with lengths <code>Ni=len(xi)</code>, returns <code>(N1, N2, N3,..., Nn)</code> shaped arrays if indexing=’ij’ or <code>(N2, N1, N3,..., Nn)</code> shaped arrays if indexing=’xy’ with the elements of <code>xi</code> repeated to fill the matrix along the first dimension for <code>x1</code>, the second for <code>x2</code> and so on.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.mgrid.html#numpy.mgrid" title="numpy.mgrid"><code>mgrid</code></a></dt>
<dd>
<p>Construct a multi-dimensional “meshgrid” using indexing notation.</p> </dd> <dt><a class="reference internal" href="numpy.ogrid.html#numpy.ogrid" title="numpy.ogrid"><code>ogrid</code></a></dt>
<dd>
<p>Construct an open multi-dimensional “meshgrid” using indexing notation.</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This function supports both indexing conventions through the indexing keyword argument. Giving the string ‘ij’ returns a meshgrid with matrix indexing, while ‘xy’ returns a meshgrid with Cartesian indexing. In the 2-D case with inputs of length M and N, the outputs are of shape (N, M) for ‘xy’ indexing and (M, N) for ‘ij’ indexing. In the 3-D case with inputs of length M, N and P, outputs are of shape (N, M, P) for ‘xy’ indexing and (M, N, P) for ‘ij’ indexing. The difference is illustrated by the following code snippet:</p> <pre data-language="python">xv, yv = np.meshgrid(x, y, indexing='ij')
for i in range(nx):
    for j in range(ny):
        # treat xv[i,j], yv[i,j]

xv, yv = np.meshgrid(x, y, indexing='xy')
for i in range(nx):
    for j in range(ny):
        # treat xv[j,i], yv[j,i]
</pre> <p>In the 1-D and 0-D case, the indexing and sparse keywords have no effect.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; nx, ny = (3, 2)
&gt;&gt;&gt; x = np.linspace(0, 1, nx)
&gt;&gt;&gt; y = np.linspace(0, 1, ny)
&gt;&gt;&gt; xv, yv = np.meshgrid(x, y)
&gt;&gt;&gt; xv
array([[0. , 0.5, 1. ],
       [0. , 0.5, 1. ]])
&gt;&gt;&gt; yv
array([[0.,  0.,  0.],
       [1.,  1.,  1.]])
&gt;&gt;&gt; xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
&gt;&gt;&gt; xv
array([[0. ,  0.5,  1. ]])
&gt;&gt;&gt; yv
array([[0.],
       [1.]])
</pre> <p><a class="reference internal" href="#numpy.meshgrid" title="numpy.meshgrid"><code>meshgrid</code></a> is very useful to evaluate functions on a grid. If the function depends on all coordinates, you can use the parameter <code>sparse=True</code> to save memory and computation time.</p> <pre data-language="python">&gt;&gt;&gt; x = np.linspace(-5, 5, 101)
&gt;&gt;&gt; y = np.linspace(-5, 5, 101)
&gt;&gt;&gt; # full coordinate arrays
&gt;&gt;&gt; xx, yy = np.meshgrid(x, y)
&gt;&gt;&gt; zz = np.sqrt(xx**2 + yy**2)
&gt;&gt;&gt; xx.shape, yy.shape, zz.shape
((101, 101), (101, 101), (101, 101))
&gt;&gt;&gt; # sparse coordinate arrays
&gt;&gt;&gt; xs, ys = np.meshgrid(x, y, sparse=True)
&gt;&gt;&gt; zs = np.sqrt(xs**2 + ys**2)
&gt;&gt;&gt; xs.shape, ys.shape, zs.shape
((1, 101), (101, 1), (101, 101))
&gt;&gt;&gt; np.array_equal(zz, zs)
True
</pre> <pre data-language="python">&gt;&gt;&gt; import matplotlib.pyplot as plt
&gt;&gt;&gt; h = plt.contourf(x, y, zs)
&gt;&gt;&gt; plt.axis('scaled')
&gt;&gt;&gt; plt.colorbar()
&gt;&gt;&gt; plt.show()
</pre> <figure class="align-default"> <img alt="../../_images/numpy-meshgrid-1.png" class="plot-directive" src="data:image/png;base64,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"> </figure> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.meshgrid.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.meshgrid.html</a>
  </p>
</div>
