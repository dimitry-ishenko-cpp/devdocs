<h1>numpy.loadtxt</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.loadtxt"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">loadtxt</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">fname</span></em>, <em class="sig-param"><span class="n">dtype=&lt;class 'float'&gt;</span></em>, <em class="sig-param"><span class="n">comments='#'</span></em>, <em class="sig-param"><span class="n">delimiter=None</span></em>, <em class="sig-param"><span class="n">converters=None</span></em>, <em class="sig-param"><span class="n">skiprows=0</span></em>, <em class="sig-param"><span class="n">usecols=None</span></em>, <em class="sig-param"><span class="n">unpack=False</span></em>, <em class="sig-param"><span class="n">ndmin=0</span></em>, <em class="sig-param"><span class="n">encoding='bytes'</span></em>, <em class="sig-param"><span class="n">max_rows=None</span></em>, <em class="sig-param"><span class="n">*</span></em>, <em class="sig-param"><span class="n">quotechar=None</span></em>, <em class="sig-param"><span class="n">like=None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/lib/npyio.py#L1061-L1306"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Load data from a text file.</p> <p>Each row in the text file must have the same number of values.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>fname</strong><span class="classifier">file, str, pathlib.Path, list of str, generator</span>
</dt>
<dd>
<p>File, filename, list, or generator to read. If the filename extension is <code>.gz</code> or <code>.bz2</code>, the file is first decompressed. Note that generators must return bytes or strings. The strings in a list or produced by a generator are treated as lines.</p> </dd> <dt>
<strong>dtype</strong><span class="classifier">data-type, optional</span>
</dt>
<dd>
<p>Data-type of the resulting array; default: float. If this is a structured data-type, the resulting array will be 1-dimensional, and each row will be interpreted as an element of the array. In this case, the number of columns used must match the number of fields in the data-type.</p> </dd> <dt>
<strong>comments</strong><span class="classifier">str or sequence of str or None, optional</span>
</dt>
<dd>
<p>The characters or list of characters used to indicate the start of a comment. None implies no comments. For backwards compatibility, byte strings will be decoded as ‘latin1’. The default is ‘#’.</p> </dd> <dt>
<strong>delimiter</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>The string used to separate values. For backwards compatibility, byte strings will be decoded as ‘latin1’. The default is whitespace.</p> </dd> <dt>
<strong>converters</strong><span class="classifier">dict or callable, optional</span>
</dt>
<dd>
<p>A function to parse all columns strings into the desired value, or a dictionary mapping column number to a parser function. E.g. if column 0 is a date string: <code>converters = {0: datestr2num}</code>. Converters can also be used to provide a default value for missing data, e.g. <code>converters = lambda s: float(s.strip() or 0)</code> will convert empty fields to 0. Default: None.</p> </dd> <dt>
<strong>skiprows</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Skip the first <code>skiprows</code> lines, including comments; default: 0.</p> </dd> <dt>
<strong>usecols</strong><span class="classifier">int or sequence, optional</span>
</dt>
<dd>
<p>Which columns to read, with 0 being the first. For example, <code>usecols = (1,4,5)</code> will extract the 2nd, 5th and 6th columns. The default, None, results in all columns being read.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.11.0: </span>When a single column has to be read it is possible to use an integer instead of a tuple. E.g <code>usecols = 3</code> reads the fourth column the same way as <code>usecols = (3,)</code> would.</p> </div> </dd> <dt>
<strong>unpack</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If True, the returned array is transposed, so that arguments may be unpacked using <code>x, y, z = loadtxt(...)</code>. When used with a structured data-type, arrays are returned for each field. Default is False.</p> </dd> <dt>
<strong>ndmin</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>The returned array will have at least <code>ndmin</code> dimensions. Otherwise mono-dimensional axes will be squeezed. Legal values: 0 (default), 1 or 2.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.6.0.</span></p> </div> </dd> <dt>
<strong>encoding</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Encoding used to decode the inputfile. Does not apply to input streams. The special value ‘bytes’ enables backward compatibility workarounds that ensures you receive byte arrays as results if possible and passes ‘latin1’ encoded strings to converters. Override this value to receive unicode arrays and pass strings as input to converters. If set to None the system default is used. The default value is ‘bytes’.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.14.0.</span></p> </div> </dd> <dt>
<strong>max_rows</strong><span class="classifier">int, optional</span>
</dt>
<dd>
<p>Read <code>max_rows</code> lines of content after <code>skiprows</code> lines. The default is to read all the lines.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.16.0.</span></p> </div> </dd> <dt>
<strong>quotechar</strong><span class="classifier">unicode character or None, optional</span>
</dt>
<dd>
<p>The character used to denote the start and end of a quoted item. Occurrences of the delimiter or comment characters are ignored within a quoted item. The default value is <code>quotechar=None</code>, which means quoting support is disabled.</p> <p>If two consecutive instances of <code>quotechar</code> are found within a quoted field, the first is treated as an escape character. See examples.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.23.0.</span></p> </div> </dd> <dt>
<strong>like</strong><span class="classifier">array_like, optional</span>
</dt>
<dd>
<p>Reference object to allow the creation of arrays which are not NumPy arrays. If an array-like passed in as <code>like</code> supports the <code>__array_function__</code> protocol, the result will be defined by it. In this case, it ensures the creation of an array object compatible with that passed in via this argument.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.20.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>out</strong><span class="classifier">ndarray</span>
</dt>
<dd>
<p>Data read from the text file.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt>
<a class="reference internal" href="numpy.load.html#numpy.load" title="numpy.load"><code>load</code></a>, <a class="reference internal" href="numpy.fromstring.html#numpy.fromstring" title="numpy.fromstring"><code>fromstring</code></a>, <a class="reference internal" href="numpy.fromregex.html#numpy.fromregex" title="numpy.fromregex"><code>fromregex</code></a>
</dt>
 <dt><a class="reference internal" href="numpy.genfromtxt.html#numpy.genfromtxt" title="numpy.genfromtxt"><code>genfromtxt</code></a></dt>
<dd>
<p>Load data with missing values handled as specified.</p> </dd> <dt><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.io.loadmat.html#scipy.io.loadmat" title="(in SciPy v1.8.1)"><code>scipy.io.loadmat</code></a></dt>
<dd>
<p>reads MATLAB data files</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>This function aims to be a fast reader for simply formatted files. The <a class="reference internal" href="numpy.genfromtxt.html#numpy.genfromtxt" title="numpy.genfromtxt"><code>genfromtxt</code></a> function provides more sophisticated handling of, e.g., lines with missing values.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.10.0.</span></p> </div> <p>The strings produced by the Python float.hex method can be used as input for floats.</p> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object
&gt;&gt;&gt; c = StringIO("0 1\n2 3")
&gt;&gt;&gt; np.loadtxt(c)
array([[0., 1.],
       [2., 3.]])
</pre> <pre data-language="python">&gt;&gt;&gt; d = StringIO("M 21 72\nF 35 58")
&gt;&gt;&gt; np.loadtxt(d, dtype={'names': ('gender', 'age', 'weight'),
...                      'formats': ('S1', 'i4', 'f4')})
array([(b'M', 21, 72.), (b'F', 35, 58.)],
      dtype=[('gender', 'S1'), ('age', '&lt;i4'), ('weight', '&lt;f4')])
</pre> <pre data-language="python">&gt;&gt;&gt; c = StringIO("1,0,2\n3,0,4")
&gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=',', usecols=(0, 2), unpack=True)
&gt;&gt;&gt; x
array([1., 3.])
&gt;&gt;&gt; y
array([2., 4.])
</pre> <p>The <code>converters</code> argument is used to specify functions to preprocess the text prior to parsing. <code>converters</code> can be a dictionary that maps preprocessing functions to each column:</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO("1.618, 2.296\n3.141, 4.669\n")
&gt;&gt;&gt; conv = {
...     0: lambda x: np.floor(float(x)),  # conversion fn for column 0
...     1: lambda x: np.ceil(float(x)),  # conversion fn for column 1
... }
&gt;&gt;&gt; np.loadtxt(s, delimiter=",", converters=conv)
array([[1., 3.],
       [3., 5.]])
</pre> <p><code>converters</code> can be a callable instead of a dictionary, in which case it is applied to all columns:</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO("0xDE 0xAD\n0xC0 0xDE")
&gt;&gt;&gt; import functools
&gt;&gt;&gt; conv = functools.partial(int, base=16)
&gt;&gt;&gt; np.loadtxt(s, converters=conv)
array([[222., 173.],
       [192., 222.]])
</pre> <p>This example shows how <code>converters</code> can be used to convert a field with a trailing minus sign into a negative number.</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO('10.01 31.25-\n19.22 64.31\n17.57- 63.94')
&gt;&gt;&gt; def conv(fld):
...     return -float(fld[:-1]) if fld.endswith(b'-') else float(fld)
...
&gt;&gt;&gt; np.loadtxt(s, converters=conv)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
</pre> <p>Using a callable as the converter can be particularly useful for handling values with different formatting, e.g. floats with underscores:</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO("1 2.7 100_000")
&gt;&gt;&gt; np.loadtxt(s, converters=float)
array([1.e+00, 2.7e+00, 1.e+05])
</pre> <p>This idea can be extended to automatically handle values specified in many different formats:</p> <pre data-language="python">&gt;&gt;&gt; def conv(val):
...     try:
...         return float(val)
...     except ValueError:
...         return float.fromhex(val)
&gt;&gt;&gt; s = StringIO("1, 2.5, 3_000, 0b4, 0x1.4000000000000p+2")
&gt;&gt;&gt; np.loadtxt(s, delimiter=",", converters=conv, encoding=None)
array([1.0e+00, 2.5e+00, 3.0e+03, 1.8e+02, 5.0e+00])
</pre> <p>Note that with the default <code>encoding="bytes"</code>, the inputs to the converter function are latin-1 encoded byte strings. To deactivate the implicit encoding prior to conversion, use <code>encoding=None</code></p> <pre data-language="python">&gt;&gt;&gt; s = StringIO('10.01 31.25-\n19.22 64.31\n17.57- 63.94')
&gt;&gt;&gt; conv = lambda x: -float(x[:-1]) if x.endswith('-') else float(x)
&gt;&gt;&gt; np.loadtxt(s, converters=conv, encoding=None)
array([[ 10.01, -31.25],
       [ 19.22,  64.31],
       [-17.57,  63.94]])
</pre> <p>Support for quoted fields is enabled with the <code>quotechar</code> parameter. Comment and delimiter characters are ignored when they appear within a quoted item delineated by <code>quotechar</code>:</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO('"alpha, #42", 10.0\n"beta, #64", 2.0\n')
&gt;&gt;&gt; dtype = np.dtype([("label", "U12"), ("value", float)])
&gt;&gt;&gt; np.loadtxt(s, dtype=dtype, delimiter=",", quotechar='"')
array([('alpha, #42', 10.), ('beta, #64',  2.)],
      dtype=[('label', '&lt;U12'), ('value', '&lt;f8')])
</pre> <p>Two consecutive quote characters within a quoted field are treated as a single escaped character:</p> <pre data-language="python">&gt;&gt;&gt; s = StringIO('"Hello, my name is ""Monty""!"')
&gt;&gt;&gt; np.loadtxt(s, dtype="U", delimiter=",", quotechar='"')
array('Hello, my name is "Monty"!', dtype='&lt;U26')
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.loadtxt.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.loadtxt.html</a>
  </p>
</div>
