<h1>numpy.percentile</h1> <dl class="py function"> <dt class="sig sig-object py" id="numpy.percentile"> <span class="sig-prename descclassname">numpy.</span><span class="sig-name descname">percentile</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">a</span></em>, <em class="sig-param"><span class="n">q</span></em>, <em class="sig-param"><span class="n">axis</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">overwrite_input</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'linear'</span></em>, <em class="sig-param"><span class="n">keepdims</span><span class="o">=</span><span class="default_value">False</span></em>, <em class="sig-param"><span class="o">*</span></em>, <em class="sig-param"><span class="n">interpolation</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span><a class="reference external" href="https://github.com/numpy/numpy/blob/v1.23.0/numpy/lib/function_base.py#L3884-L4167"><span class="viewcode-link">[source]</span></a>
</dt> <dd>
<p>Compute the q-th percentile of the data along the specified axis.</p> <p>Returns the q-th percentile(s) of the array elements.</p> <dl class="field-list"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl> <dt>
<strong>a</strong><span class="classifier">array_like</span>
</dt>
<dd>
<p>Input array or object that can be converted to an array.</p> </dd> <dt>
<strong>q</strong><span class="classifier">array_like of float</span>
</dt>
<dd>
<p>Percentile or sequence of percentiles to compute, which must be between 0 and 100 inclusive.</p> </dd> <dt>
<strong>axis</strong><span class="classifier">{int, tuple of int, None}, optional</span>
</dt>
<dd>
<p>Axis or axes along which the percentiles are computed. The default is to compute the percentile(s) along a flattened version of the array.</p> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.9.0: </span>A tuple of axes is supported</p> </div> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, optional</span>
</dt>
<dd>
<p>Alternative output array in which to place the result. It must have the same shape and buffer length as the expected output, but the type (of the output) will be cast if necessary.</p> </dd> <dt>
<strong>overwrite_input</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If True, then allow the input array <code>a</code> to be modified by intermediate calculations, to save memory. In this case, the contents of the input <code>a</code> after this function completes is undefined.</p> </dd> <dt>
<strong>method</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>This parameter specifies the method to use for estimating the percentile. There are many different methods, some unique to NumPy. See the notes for explanation. The options sorted by their R type as summarized in the H&amp;F paper <a class="reference internal" href="#r08bde0ebf37b-1" id="id1">[1]</a> are:</p> <ol class="arabic simple"> <li>‘inverted_cdf’</li> <li>‘averaged_inverted_cdf’</li> <li>‘closest_observation’</li> <li>‘interpolated_inverted_cdf’</li> <li>‘hazen’</li> <li>‘weibull’</li> <li>‘linear’ (default)</li> <li>‘median_unbiased’</li> <li>‘normal_unbiased’</li> </ol> <p>The first three methods are discontiuous. NumPy further defines the following discontinuous variations of the default ‘linear’ (7.) option:</p> <ul class="simple"> <li>‘lower’</li> <li>‘higher’,</li> <li>‘midpoint’</li> <li>‘nearest’</li> </ul> <div class="versionchanged"> <p><span class="versionmodified changed">Changed in version 1.22.0: </span>This argument was previously called “interpolation” and only offered the “linear” default and last four options.</p> </div> </dd> <dt>
<strong>keepdims</strong><span class="classifier">bool, optional</span>
</dt>
<dd>
<p>If this is set to True, the axes which are reduced are left in the result as dimensions with size one. With this option, the result will broadcast correctly against the original array <code>a</code>.</p> <div class="versionadded"> <p><span class="versionmodified added">New in version 1.9.0.</span></p> </div> </dd> <dt>
<strong>interpolation</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Deprecated name for the method keyword argument.</p> <div class="deprecated"> <p><span class="versionmodified deprecated">Deprecated since version 1.22.0.</span></p> </div> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>percentile</strong><span class="classifier">scalar or ndarray</span>
</dt>
<dd>
<p>If <code>q</code> is a single percentile and <code>axis=None</code>, then the result is a scalar. If multiple percentiles are given, first axis of the result corresponds to the percentiles. The other axes are the axes that remain after the reduction of <code>a</code>. If the input contains integers or floats smaller than <code>float64</code>, the output data-type is <code>float64</code>. Otherwise, the output data-type is the same as that of the input. If <code>out</code> is specified, that array is returned instead.</p> </dd> </dl> </dd> </dl> <div class="admonition seealso"> <p class="admonition-title">See also</p> <dl class="simple"> <dt><a class="reference internal" href="numpy.mean.html#numpy.mean" title="numpy.mean"><code>mean</code></a></dt>
 <dt><a class="reference internal" href="numpy.median.html#numpy.median" title="numpy.median"><code>median</code></a></dt>
<dd>
<p>equivalent to <code>percentile(..., 50)</code></p> </dd> <dt><a class="reference internal" href="numpy.nanpercentile.html#numpy.nanpercentile" title="numpy.nanpercentile"><code>nanpercentile</code></a></dt>
 <dt><a class="reference internal" href="numpy.quantile.html#numpy.quantile" title="numpy.quantile"><code>quantile</code></a></dt>
<dd>
<p>equivalent to percentile, except q in the range [0, 1].</p> </dd> </dl> </div> <h4 class="rubric">Notes</h4> <p>Given a vector <code>V</code> of length <code>N</code>, the q-th percentile of <code>V</code> is the value <code>q/100</code> of the way from the minimum to the maximum in a sorted copy of <code>V</code>. The values and distances of the two nearest neighbors as well as the <code>method</code> parameter will determine the percentile if the normalized ranking does not match the location of <code>q</code> exactly. This function is the same as the median if <code>q=50</code>, the same as the minimum if <code>q=0</code> and the same as the maximum if <code>q=100</code>.</p> <p>This optional <code>method</code> parameter specifies the method to use when the desired quantile lies between two data points <code>i &lt; j</code>. If <code>g</code> is the fractional part of the index surrounded by <code>i</code> and alpha and beta are correction constants modifying i and j.</p> <p>Below, ‘q’ is the quantile value, ‘n’ is the sample size and alpha and beta are constants. The following formula gives an interpolation “i + g” of where the quantile would be in the sorted sample. With ‘i’ being the floor and ‘g’ the fractional part of the result.</p> <div class="math notranslate nohighlight"> \[i + g = (q - alpha) / ( n - alpha - beta + 1 )\]</div> <p>The different methods then work as follows</p> <dl class="simple"> <dt>inverted_cdf:</dt>
<dd>
<p>method 1 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id2">[1]</a>. This method gives discontinuous results:</p> <ul class="simple"> <li>if g &gt; 0 ; then take j</li> <li>if g = 0 ; then take i</li> </ul> </dd> <dt>averaged_inverted_cdf:</dt>
<dd>
<p>method 2 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id3">[1]</a>. This method give discontinuous results:</p> <ul class="simple"> <li>if g &gt; 0 ; then take j</li> <li>if g = 0 ; then average between bounds</li> </ul> </dd> <dt>closest_observation:</dt>
<dd>
<p>method 3 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id4">[1]</a>. This method give discontinuous results:</p> <ul class="simple"> <li>if g &gt; 0 ; then take j</li> <li>if g = 0 and index is odd ; then take j</li> <li>if g = 0 and index is even ; then take i</li> </ul> </dd> <dt>interpolated_inverted_cdf:</dt>
<dd>
<p>method 4 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id5">[1]</a>. This method give continuous results using:</p> <ul class="simple"> <li>alpha = 0</li> <li>beta = 1</li> </ul> </dd> <dt>hazen:</dt>
<dd>
<p>method 5 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id6">[1]</a>. This method give continuous results using:</p> <ul class="simple"> <li>alpha = 1/2</li> <li>beta = 1/2</li> </ul> </dd> <dt>weibull:</dt>
<dd>
<p>method 6 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id7">[1]</a>. This method give continuous results using:</p> <ul class="simple"> <li>alpha = 0</li> <li>beta = 0</li> </ul> </dd> <dt>linear:</dt>
<dd>
<p>method 7 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id8">[1]</a>. This method give continuous results using:</p> <ul class="simple"> <li>alpha = 1</li> <li>beta = 1</li> </ul> </dd> <dt>median_unbiased:</dt>
<dd>
<p>method 8 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id9">[1]</a>. This method is probably the best method if the sample distribution function is unknown (see reference). This method give continuous results using:</p> <ul class="simple"> <li>alpha = 1/3</li> <li>beta = 1/3</li> </ul> </dd> <dt>normal_unbiased:</dt>
<dd>
<p>method 9 of H&amp;F <a class="reference internal" href="#r08bde0ebf37b-1" id="id10">[1]</a>. This method is probably the best method if the sample distribution function is known to be normal. This method give continuous results using:</p> <ul class="simple"> <li>alpha = 3/8</li> <li>beta = 3/8</li> </ul> </dd> <dt>lower:</dt>
<dd>
<p>NumPy method kept for backwards compatibility. Takes <code>i</code> as the interpolation point.</p> </dd> <dt>higher:</dt>
<dd>
<p>NumPy method kept for backwards compatibility. Takes <code>j</code> as the interpolation point.</p> </dd> <dt>nearest:</dt>
<dd>
<p>NumPy method kept for backwards compatibility. Takes <code>i</code> or <code>j</code>, whichever is nearest.</p> </dd> <dt>midpoint:</dt>
<dd>
<p>NumPy method kept for backwards compatibility. Uses <code>(i + j) / 2</code>.</p> </dd> </dl> <h4 class="rubric">References</h4> <dl class="citation"> <dt class="label" id="r08bde0ebf37b-1">
<span class="brackets">1</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id2">2</a>,<a href="#id3">3</a>,<a href="#id4">4</a>,<a href="#id5">5</a>,<a href="#id6">6</a>,<a href="#id7">7</a>,<a href="#id8">8</a>,<a href="#id9">9</a>,<a href="#id10">10</a>)</span>
</dt> <dd>
<p>R. J. Hyndman and Y. Fan, “Sample quantiles in statistical packages,” The American Statistician, 50(4), pp. 361-365, 1996</p> </dd> </dl> <h4 class="rubric">Examples</h4> <pre data-language="python">&gt;&gt;&gt; a = np.array([[10, 7, 4], [3, 2, 1]])
&gt;&gt;&gt; a
array([[10,  7,  4],
       [ 3,  2,  1]])
&gt;&gt;&gt; np.percentile(a, 50)
3.5
&gt;&gt;&gt; np.percentile(a, 50, axis=0)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; np.percentile(a, 50, axis=1)
array([7.,  2.])
&gt;&gt;&gt; np.percentile(a, 50, axis=1, keepdims=True)
array([[7.],
       [2.]])
</pre> <pre data-language="python">&gt;&gt;&gt; m = np.percentile(a, 50, axis=0)
&gt;&gt;&gt; out = np.zeros_like(m)
&gt;&gt;&gt; np.percentile(a, 50, axis=0, out=out)
array([6.5, 4.5, 2.5])
&gt;&gt;&gt; m
array([6.5, 4.5, 2.5])
</pre> <pre data-language="python">&gt;&gt;&gt; b = a.copy()
&gt;&gt;&gt; np.percentile(b, 50, axis=1, overwrite_input=True)
array([7.,  2.])
&gt;&gt;&gt; assert not np.all(a == b)
</pre> <p>The different methods can be visualized graphically:</p> <pre data-language="python">import matplotlib.pyplot as plt

a = np.arange(4)
p = np.linspace(0, 100, 6001)
ax = plt.gca()
lines = [
    ('linear', '-', 'C0'),
    ('inverted_cdf', ':', 'C1'),
    # Almost the same as `inverted_cdf`:
    ('averaged_inverted_cdf', '-.', 'C1'),
    ('closest_observation', ':', 'C2'),
    ('interpolated_inverted_cdf', '--', 'C1'),
    ('hazen', '--', 'C3'),
    ('weibull', '-.', 'C4'),
    ('median_unbiased', '--', 'C5'),
    ('normal_unbiased', '-.', 'C6'),
    ]
for method, style, color in lines:
    ax.plot(
        p, np.percentile(a, p, method=method),
        label=method, linestyle=style, color=color)
ax.set(
    title='Percentiles for different methods and data: ' + str(a),
    xlabel='Percentile',
    ylabel='Estimated percentile value',
    yticks=a)
ax.legend()
plt.show()
</pre> <figure class="align-default"> <img alt="../../_images/numpy-percentile-1.png" class="plot-directive" src="data:image/png;base64,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"> </figure> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/generated/numpy.percentile.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/generated/numpy.percentile.html</a>
  </p>
</div>
