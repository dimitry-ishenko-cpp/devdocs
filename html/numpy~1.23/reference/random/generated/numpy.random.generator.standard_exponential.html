<h1>numpy.random.Generator.standard_exponential</h1> <p>method</p> <dl class="py method"> <dt class="sig sig-object py" id="numpy.random.Generator.standard_exponential"> <span class="sig-prename descclassname">random.Generator.</span><span class="sig-name descname">standard_exponential</span><span class="sig-paren">(</span><em class="sig-param"><span class="n">size</span><span class="o">=</span><span class="default_value">None</span></em>, <em class="sig-param"><span class="n">dtype</span><span class="o">=</span><span class="default_value">np.float64</span></em>, <em class="sig-param"><span class="n">method</span><span class="o">=</span><span class="default_value">'zig'</span></em>, <em class="sig-param"><span class="n">out</span><span class="o">=</span><span class="default_value">None</span></em><span class="sig-paren">)</span>
</dt> <dd>
<p>Draw samples from the standard exponential distribution.</p> <p><a class="reference internal" href="#numpy.random.Generator.standard_exponential" title="numpy.random.Generator.standard_exponential"><code>standard_exponential</code></a> is identical to the exponential distribution with a scale parameter of 1.</p> <dl class="field-list simple"> <dt class="field-odd">Parameters</dt> <dd class="field-odd">
<dl class="simple"> <dt>
<strong>size</strong><span class="classifier">int or tuple of ints, optional</span>
</dt>
<dd>
<p>Output shape. If the given shape is, e.g., <code>(m, n, k)</code>, then <code>m * n * k</code> samples are drawn. Default is None, in which case a single value is returned.</p> </dd> <dt>
<strong>dtype</strong><span class="classifier">dtype, optional</span>
</dt>
<dd>
<p>Desired dtype of the result, only <a class="reference internal" href="../../arrays.scalars.html#numpy.float64" title="numpy.float64"><code>float64</code></a> and <a class="reference internal" href="../../arrays.scalars.html#numpy.float32" title="numpy.float32"><code>float32</code></a> are supported. Byteorder must be native. The default value is np.float64.</p> </dd> <dt>
<strong>method</strong><span class="classifier">str, optional</span>
</dt>
<dd>
<p>Either ‘inv’ or ‘zig’. ‘inv’ uses the default inverse CDF method. ‘zig’ uses the much faster Ziggurat method of Marsaglia and Tsang.</p> </dd> <dt>
<strong>out</strong><span class="classifier">ndarray, optional</span>
</dt>
<dd>
<p>Alternative output array in which to place the result. If size is not None, it must have the same shape as the provided size and must match the type of the output values.</p> </dd> </dl> </dd> <dt class="field-even">Returns</dt> <dd class="field-even">
<dl class="simple"> <dt>
<strong>out</strong><span class="classifier">float or ndarray</span>
</dt>
<dd>
<p>Drawn samples.</p> </dd> </dl> </dd> </dl> <h4 class="rubric">Examples</h4> <p>Output a 3x8000 array:</p> <pre data-language="python">&gt;&gt;&gt; n = np.random.default_rng().standard_exponential((3, 8000))
</pre> </dd>
</dl><div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2022 NumPy Developers<br>Licensed under the 3-clause BSD License.<br>
    <a href="https://numpy.org/doc/1.23/reference/random/generated/numpy.random.Generator.standard_exponential.html" class="_attribution-link">https://numpy.org/doc/1.23/reference/random/generated/numpy.random.Generator.standard_exponential.html</a>
  </p>
</div>
