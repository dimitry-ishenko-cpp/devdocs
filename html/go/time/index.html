<h1> Package time  </h1>     <ul id="short-nav">
<li><code>import "time"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package time provides functionality for measuring and displaying time. </p>
<p>The calendrical calculations always assume a Gregorian calendar, with no leap seconds. </p>
<h3 id="hdr-Monotonic_Clocks">Monotonic Clocks</h3> <p>Operating systems provide both a “wall clock,” which is subject to changes for clock synchronization, and a “monotonic clock,” which is not. The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time. Rather than split the API, in this package the Time returned by time.Now contains both a wall clock reading and a monotonic clock reading; later time-telling operations use the wall clock reading, but later time-measuring operations, specifically comparisons and subtractions, use the monotonic clock reading. </p>
<p>For example, this code always computes a positive elapsed time of approximately 20 milliseconds, even if the wall clock is changed during the operation being timed: </p>
<pre data-language="go">start := time.Now()
... operation that takes 20 milliseconds ...
t := time.Now()
elapsed := t.Sub(start)
</pre> <p>Other idioms, such as time.Since(start), time.Until(deadline), and time.Now().Before(deadline), are similarly robust against wall clock resets. </p>
<p>The rest of this section gives the precise details of how operations use monotonic clocks, but understanding those details is not required to use this package. </p>
<p>The Time returned by time.Now contains a monotonic clock reading. If Time t has a monotonic clock reading, t.Add adds the same duration to both the wall clock and monotonic clock readings to compute the result. Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time computations, they always strip any monotonic clock reading from their results. Because t.In, t.Local, and t.UTC are used for their effect on the interpretation of the wall time, they also strip any monotonic clock reading from their results. The canonical way to strip a monotonic clock reading is to use t = t.Round(0). </p>
<p>If Times t and u both contain monotonic clock readings, the operations t.After(u), t.Before(u), t.Equal(u), t.Compare(u), and t.Sub(u) are carried out using the monotonic clock readings alone, ignoring the wall clock readings. If either t or u contains no monotonic clock reading, these operations fall back to using the wall clock readings. </p>
<p>On some systems the monotonic clock will stop if the computer goes to sleep. On such a system, t.Sub(u) may not accurately reflect the actual time that passed between t and u. </p>
<p>Because the monotonic clock reading has no meaning outside the current process, the serialized forms generated by t.GobEncode, t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic clock reading, and t.Format provides no format for it. Similarly, the constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix, as well as the unmarshalers t.GobDecode, t.UnmarshalBinary. t.UnmarshalJSON, and t.UnmarshalText always create times with no monotonic clock reading. </p>
<p>The monotonic clock reading exists only in Time values. It is not a part of Duration values or the Unix times returned by t.Unix and friends. </p>
<p>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. See the documentation for the Time type for a discussion of equality testing for Time values. </p>
<p>For debugging, the result of t.String does include the monotonic clock reading if present. If t != u because of different monotonic clock readings, that difference will be visible when printing t.String() and u.String(). </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#After">func After(d Duration) &lt;-chan Time</a></li>
<li><a href="#Sleep">func Sleep(d Duration)</a></li>
<li><a href="#Tick">func Tick(d Duration) &lt;-chan Time</a></li>
<li><a href="#Duration">type Duration</a></li>
<li> <a href="#ParseDuration">func ParseDuration(s string) (Duration, error)</a>
</li>
<li> <a href="#Since">func Since(t Time) Duration</a>
</li>
<li> <a href="#Until">func Until(t Time) Duration</a>
</li>
<li> <a href="#Duration.Abs">func (d Duration) Abs() Duration</a>
</li>
<li> <a href="#Duration.Hours">func (d Duration) Hours() float64</a>
</li>
<li> <a href="#Duration.Microseconds">func (d Duration) Microseconds() int64</a>
</li>
<li> <a href="#Duration.Milliseconds">func (d Duration) Milliseconds() int64</a>
</li>
<li> <a href="#Duration.Minutes">func (d Duration) Minutes() float64</a>
</li>
<li> <a href="#Duration.Nanoseconds">func (d Duration) Nanoseconds() int64</a>
</li>
<li> <a href="#Duration.Round">func (d Duration) Round(m Duration) Duration</a>
</li>
<li> <a href="#Duration.Seconds">func (d Duration) Seconds() float64</a>
</li>
<li> <a href="#Duration.String">func (d Duration) String() string</a>
</li>
<li> <a href="#Duration.Truncate">func (d Duration) Truncate(m Duration) Duration</a>
</li>
<li><a href="#Location">type Location</a></li>
<li> <a href="#FixedZone">func FixedZone(name string, offset int) *Location</a>
</li>
<li> <a href="#LoadLocation">func LoadLocation(name string) (*Location, error)</a>
</li>
<li> <a href="#LoadLocationFromTZData">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</a>
</li>
<li> <a href="#Location.String">func (l *Location) String() string</a>
</li>
<li><a href="#Month">type Month</a></li>
<li> <a href="#Month.String">func (m Month) String() string</a>
</li>
<li><a href="#ParseError">type ParseError</a></li>
<li> <a href="#ParseError.Error">func (e *ParseError) Error() string</a>
</li>
<li><a href="#Ticker">type Ticker</a></li>
<li> <a href="#NewTicker">func NewTicker(d Duration) *Ticker</a>
</li>
<li> <a href="#Ticker.Reset">func (t *Ticker) Reset(d Duration)</a>
</li>
<li> <a href="#Ticker.Stop">func (t *Ticker) Stop()</a>
</li>
<li><a href="#Time">type Time</a></li>
<li> <a href="#Date">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</a>
</li>
<li> <a href="#Now">func Now() Time</a>
</li>
<li> <a href="#Parse">func Parse(layout, value string) (Time, error)</a>
</li>
<li> <a href="#ParseInLocation">func ParseInLocation(layout, value string, loc *Location) (Time, error)</a>
</li>
<li> <a href="#Unix">func Unix(sec int64, nsec int64) Time</a>
</li>
<li> <a href="#UnixMicro">func UnixMicro(usec int64) Time</a>
</li>
<li> <a href="#UnixMilli">func UnixMilli(msec int64) Time</a>
</li>
<li> <a href="#Time.Add">func (t Time) Add(d Duration) Time</a>
</li>
<li> <a href="#Time.AddDate">func (t Time) AddDate(years int, months int, days int) Time</a>
</li>
<li> <a href="#Time.After">func (t Time) After(u Time) bool</a>
</li>
<li> <a href="#Time.AppendFormat">func (t Time) AppendFormat(b []byte, layout string) []byte</a>
</li>
<li> <a href="#Time.Before">func (t Time) Before(u Time) bool</a>
</li>
<li> <a href="#Time.Clock">func (t Time) Clock() (hour, min, sec int)</a>
</li>
<li> <a href="#Time.Compare">func (t Time) Compare(u Time) int</a>
</li>
<li> <a href="#Time.Date">func (t Time) Date() (year int, month Month, day int)</a>
</li>
<li> <a href="#Time.Day">func (t Time) Day() int</a>
</li>
<li> <a href="#Time.Equal">func (t Time) Equal(u Time) bool</a>
</li>
<li> <a href="#Time.Format">func (t Time) Format(layout string) string</a>
</li>
<li> <a href="#Time.GoString">func (t Time) GoString() string</a>
</li>
<li> <a href="#Time.GobDecode">func (t *Time) GobDecode(data []byte) error</a>
</li>
<li> <a href="#Time.GobEncode">func (t Time) GobEncode() ([]byte, error)</a>
</li>
<li> <a href="#Time.Hour">func (t Time) Hour() int</a>
</li>
<li> <a href="#Time.ISOWeek">func (t Time) ISOWeek() (year, week int)</a>
</li>
<li> <a href="#Time.In">func (t Time) In(loc *Location) Time</a>
</li>
<li> <a href="#Time.IsDST">func (t Time) IsDST() bool</a>
</li>
<li> <a href="#Time.IsZero">func (t Time) IsZero() bool</a>
</li>
<li> <a href="#Time.Local">func (t Time) Local() Time</a>
</li>
<li> <a href="#Time.Location">func (t Time) Location() *Location</a>
</li>
<li> <a href="#Time.MarshalBinary">func (t Time) MarshalBinary() ([]byte, error)</a>
</li>
<li> <a href="#Time.MarshalJSON">func (t Time) MarshalJSON() ([]byte, error)</a>
</li>
<li> <a href="#Time.MarshalText">func (t Time) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#Time.Minute">func (t Time) Minute() int</a>
</li>
<li> <a href="#Time.Month">func (t Time) Month() Month</a>
</li>
<li> <a href="#Time.Nanosecond">func (t Time) Nanosecond() int</a>
</li>
<li> <a href="#Time.Round">func (t Time) Round(d Duration) Time</a>
</li>
<li> <a href="#Time.Second">func (t Time) Second() int</a>
</li>
<li> <a href="#Time.String">func (t Time) String() string</a>
</li>
<li> <a href="#Time.Sub">func (t Time) Sub(u Time) Duration</a>
</li>
<li> <a href="#Time.Truncate">func (t Time) Truncate(d Duration) Time</a>
</li>
<li> <a href="#Time.UTC">func (t Time) UTC() Time</a>
</li>
<li> <a href="#Time.Unix">func (t Time) Unix() int64</a>
</li>
<li> <a href="#Time.UnixMicro">func (t Time) UnixMicro() int64</a>
</li>
<li> <a href="#Time.UnixMilli">func (t Time) UnixMilli() int64</a>
</li>
<li> <a href="#Time.UnixNano">func (t Time) UnixNano() int64</a>
</li>
<li> <a href="#Time.UnmarshalBinary">func (t *Time) UnmarshalBinary(data []byte) error</a>
</li>
<li> <a href="#Time.UnmarshalJSON">func (t *Time) UnmarshalJSON(data []byte) error</a>
</li>
<li> <a href="#Time.UnmarshalText">func (t *Time) UnmarshalText(data []byte) error</a>
</li>
<li> <a href="#Time.Weekday">func (t Time) Weekday() Weekday</a>
</li>
<li> <a href="#Time.Year">func (t Time) Year() int</a>
</li>
<li> <a href="#Time.YearDay">func (t Time) YearDay() int</a>
</li>
<li> <a href="#Time.Zone">func (t Time) Zone() (name string, offset int)</a>
</li>
<li> <a href="#Time.ZoneBounds">func (t Time) ZoneBounds() (start, end Time)</a>
</li>
<li><a href="#Timer">type Timer</a></li>
<li> <a href="#AfterFunc">func AfterFunc(d Duration, f func()) *Timer</a>
</li>
<li> <a href="#NewTimer">func NewTimer(d Duration) *Timer</a>
</li>
<li> <a href="#Timer.Reset">func (t *Timer) Reset(d Duration) bool</a>
</li>
<li> <a href="#Timer.Stop">func (t *Timer) Stop() bool</a>
</li>
<li><a href="#Weekday">type Weekday</a></li>
<li> <a href="#Weekday.String">func (d Weekday) String() string</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_After">After</a></dd> <dd><a class="exampleLink" href="#example_Date">Date</a></dd> <dd><a class="exampleLink" href="#example_Duration">Duration</a></dd> <dd><a class="exampleLink" href="#example_Duration_Hours">Duration.Hours</a></dd> <dd><a class="exampleLink" href="#example_Duration_Microseconds">Duration.Microseconds</a></dd> <dd><a class="exampleLink" href="#example_Duration_Milliseconds">Duration.Milliseconds</a></dd> <dd><a class="exampleLink" href="#example_Duration_Minutes">Duration.Minutes</a></dd> <dd><a class="exampleLink" href="#example_Duration_Nanoseconds">Duration.Nanoseconds</a></dd> <dd><a class="exampleLink" href="#example_Duration_Round">Duration.Round</a></dd> <dd><a class="exampleLink" href="#example_Duration_Seconds">Duration.Seconds</a></dd> <dd><a class="exampleLink" href="#example_Duration_String">Duration.String</a></dd> <dd><a class="exampleLink" href="#example_Duration_Truncate">Duration.Truncate</a></dd> <dd><a class="exampleLink" href="#example_FixedZone">FixedZone</a></dd> <dd><a class="exampleLink" href="#example_LoadLocation">LoadLocation</a></dd> <dd><a class="exampleLink" href="#example_Location">Location</a></dd> <dd><a class="exampleLink" href="#example_Month">Month</a></dd> <dd><a class="exampleLink" href="#example_NewTicker">NewTicker</a></dd> <dd><a class="exampleLink" href="#example_Parse">Parse</a></dd> <dd><a class="exampleLink" href="#example_ParseDuration">ParseDuration</a></dd> <dd><a class="exampleLink" href="#example_ParseInLocation">ParseInLocation</a></dd> <dd><a class="exampleLink" href="#example_Sleep">Sleep</a></dd> <dd><a class="exampleLink" href="#example_Tick">Tick</a></dd> <dd><a class="exampleLink" href="#example_Time_Add">Time.Add</a></dd> <dd><a class="exampleLink" href="#example_Time_AddDate">Time.AddDate</a></dd> <dd><a class="exampleLink" href="#example_Time_After">Time.After</a></dd> <dd><a class="exampleLink" href="#example_Time_AppendFormat">Time.AppendFormat</a></dd> <dd><a class="exampleLink" href="#example_Time_Before">Time.Before</a></dd> <dd><a class="exampleLink" href="#example_Time_Date">Time.Date</a></dd> <dd><a class="exampleLink" href="#example_Time_Day">Time.Day</a></dd> <dd><a class="exampleLink" href="#example_Time_Equal">Time.Equal</a></dd> <dd><a class="exampleLink" href="#example_Time_Format">Time.Format</a></dd> <dd><a class="exampleLink" href="#example_Time_Format_pad">Time.Format (Pad)</a></dd> <dd><a class="exampleLink" href="#example_Time_GoString">Time.GoString</a></dd> <dd><a class="exampleLink" href="#example_Time_Round">Time.Round</a></dd> <dd><a class="exampleLink" href="#example_Time_String">Time.String</a></dd> <dd><a class="exampleLink" href="#example_Time_Sub">Time.Sub</a></dd> <dd><a class="exampleLink" href="#example_Time_Truncate">Time.Truncate</a></dd> <dd><a class="exampleLink" href="#example_Time_Unix">Time.Unix</a></dd> <dd><a class="exampleLink" href="#example_Unix">Unix</a></dd> <dd><a class="exampleLink" href="#example_UnixMicro">UnixMicro</a></dd> <dd><a class="exampleLink" href="#example_UnixMilli">UnixMilli</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>format.go</span> <span>format_rfc3339.go</span> <span>sleep.go</span> <span>sys_unix.go</span> <span>tick.go</span> <span>time.go</span> <span>zoneinfo.go</span> <span>zoneinfo_goroot.go</span> <span>zoneinfo_read.go</span> <span>zoneinfo_unix.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <p>These are predefined layouts for use in Time.Format and time.Parse. The reference time used in these layouts is the specific time stamp: </p>
<pre data-language="go">01/02 03:04:05PM '06 -0700
</pre> <p>(January 2, 15:04:05, 2006, in time zone seven hours west of GMT). That value is recorded as the constant named Layout, listed below. As a Unix time, this is 1136239445. Since MST is GMT-0700, the reference would be printed by the Unix date command as: </p>
<pre data-language="go">Mon Jan 2 15:04:05 MST 2006
</pre> <p>It is a regrettable historic error that the date uses the American convention of putting the numerical month before the day. </p>
<p>The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. </p>
<p>Note that the RFC822, RFC850, and RFC1123 formats should be applied only to local times. Applying them to UTC times will use "UTC" as the time zone abbreviation, while strictly speaking those RFCs require the use of "GMT" in that case. In general RFC1123Z should be used instead of RFC1123 for servers that insist on that format, and RFC3339 should be preferred for new protocols. RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting; when used with time.Parse they do not accept all the time formats permitted by the RFCs and they do accept time formats not formally defined. The RFC3339Nano format removes trailing zeros from the seconds field and thus may not sort correctly once formatted. </p>
<p>Most programs can use one of the defined constants as the layout passed to Format or Parse. The rest of this comment can be ignored unless you are creating a custom layout string. </p>
<p>To define your own format, write down what the reference time would look like formatted your way; see the values of constants like ANSIC, StampMicro or Kitchen for examples. The model is to demonstrate what the reference time looks like so that the Format and Parse methods can apply the same transformation to a general time value. </p>
<p>Here is a summary of the components of a layout string. Each element shows by example the formatting of an element of the reference time. Only these values are recognized. Text in the layout string that is not recognized as part of the reference time is echoed verbatim during Format and expected to appear verbatim in the input to Parse. </p>
<pre data-language="go">Year: "2006" "06"
Month: "Jan" "January" "01" "1"
Day of the week: "Mon" "Monday"
Day of the month: "2" "_2" "02"
Day of the year: "__2" "002"
Hour: "15" "3" "03" (PM or AM)
Minute: "4" "04"
Second: "5" "05"
AM/PM mark: "PM"
</pre> <p>Numeric time zone offsets format as follows: </p>
<pre data-language="go">"-0700"     ±hhmm
"-07:00"    ±hh:mm
"-07"       ±hh
"-070000"   ±hhmmss
"-07:00:00" ±hh:mm:ss
</pre> <p>Replacing the sign in the format with a Z triggers the ISO 8601 behavior of printing Z instead of an offset for the UTC zone. Thus: </p>
<pre data-language="go">"Z0700"      Z or ±hhmm
"Z07:00"     Z or ±hh:mm
"Z07"        Z or ±hh
"Z070000"    Z or ±hhmmss
"Z07:00:00"  Z or ±hh:mm:ss
</pre> <p>Within the format string, the underscores in "_2" and "__2" represent spaces that may be replaced by digits if the following number has multiple digits, for compatibility with fixed-width Unix time formats. A leading zero represents a zero-padded value. </p>
<p>The formats __2 and 002 are space-padded and zero-padded three-character day of year; there is no unpadded day of year format. </p>
<p>A comma or decimal point followed by one or more zeros represents a fractional second, printed to the given number of decimal places. A comma or decimal point followed by one or more nines represents a fractional second, printed to the given number of decimal places, with trailing zeros removed. For example "15:04:05,000" or "15:04:05.000" formats or parses with millisecond precision. </p>
<p>Some valid layouts are invalid time values for time.Parse, due to formats such as _ for space padding and Z for zone information. </p>
<pre data-language="go">const (
    Layout      = "01/02 03:04:05PM '06 -0700" // The reference time, in numerical order.
    ANSIC       = "Mon Jan _2 15:04:05 2006"
    UnixDate    = "Mon Jan _2 15:04:05 MST 2006"
    RubyDate    = "Mon Jan 02 15:04:05 -0700 2006"
    RFC822      = "02 Jan 06 15:04 MST"
    RFC822Z     = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
    RFC850      = "Monday, 02-Jan-06 15:04:05 MST"
    RFC1123     = "Mon, 02 Jan 2006 15:04:05 MST"
    RFC1123Z    = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
    RFC3339     = "2006-01-02T15:04:05Z07:00"
    RFC3339Nano = "2006-01-02T15:04:05.999999999Z07:00"
    Kitchen     = "3:04PM"
    // Handy time stamps.
    Stamp      = "Jan _2 15:04:05"
    StampMilli = "Jan _2 15:04:05.000"
    StampMicro = "Jan _2 15:04:05.000000"
    StampNano  = "Jan _2 15:04:05.000000000"
    DateTime   = "2006-01-02 15:04:05"
    DateOnly   = "2006-01-02"
    TimeOnly   = "15:04:05"
)</pre> <p>Common durations. There is no definition for units of Day or larger to avoid confusion across daylight savings time zone transitions. </p>
<p>To count the number of units in a Duration, divide: </p>
<pre data-language="go">second := time.Second
fmt.Print(int64(second/time.Millisecond)) // prints 1000
</pre> <p>To convert an integer number of units to a Duration, multiply: </p>
<pre data-language="go">seconds := 10
fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
</pre> <pre data-language="go">const (
    Nanosecond  Duration = 1
    Microsecond          = 1000 * Nanosecond
    Millisecond          = 1000 * Microsecond
    Second               = 1000 * Millisecond
    Minute               = 60 * Second
    Hour                 = 60 * Minute
)</pre> <h2 id="After">func <span>After</span>  </h2> <pre data-language="go">func After(d Duration) &lt;-chan Time</pre> <p>After waits for the duration to elapse and then sends the current time on the returned channel. It is equivalent to NewTimer(d).C. The underlying Timer is not recovered by the garbage collector until the timer fires. If efficiency is a concern, use NewTimer instead and call Timer.Stop if the timer is no longer needed. </p>   <h4 id="example_After"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
select {
case m := &lt;-c:
    handle(m)
case &lt;-time.After(10 * time.Second):
    fmt.Println("timed out")
}
</pre>   <h2 id="Sleep">func <span>Sleep</span>  </h2> <pre data-language="go">func Sleep(d Duration)</pre> <p>Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately. </p>   <h4 id="example_Sleep"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
time.Sleep(100 * time.Millisecond)
</pre>   <h2 id="Tick">func <span>Tick</span>  </h2> <pre data-language="go">func Tick(d Duration) &lt;-chan Time</pre> <p>Tick is a convenience wrapper for NewTicker providing access to the ticking channel only. While Tick is useful for clients that have no need to shut down the Ticker, be aware that without a way to shut it down the underlying Ticker cannot be recovered by the garbage collector; it "leaks". Unlike NewTicker, Tick will return nil if d &lt;= 0. </p>   <h4 id="example_Tick"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
c := time.Tick(5 * time.Second)
for next := range c {
    fmt.Printf("%v %s\n", next, statusUpdate())
}
</pre>   <h2 id="Duration">type <span>Duration</span>  </h2> <p>A Duration represents the elapsed time between two instants as an int64 nanosecond count. The representation limits the largest representable duration to approximately 290 years. </p>
<pre data-language="go">type Duration int64</pre>    <h4 id="example_Duration"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
t0 := time.Now()
expensiveCall()
t1 := time.Now()
fmt.Printf("The call took %v to run.\n", t1.Sub(t0))
</pre>   <h3 id="ParseDuration">func <span>ParseDuration</span>  </h3> <pre data-language="go">func ParseDuration(s string) (Duration, error)</pre> <p>ParseDuration parses a duration string. A duration string is a possibly signed sequence of decimal numbers, each with optional fraction and a unit suffix, such as "300ms", "-1.5h" or "2h45m". Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h". </p>   <h4 id="example_ParseDuration"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">hours, _ := time.ParseDuration("10h")
complex, _ := time.ParseDuration("1h10m10s")
micro, _ := time.ParseDuration("1µs")
// The package also accepts the incorrect but common prefix u for micro.
micro2, _ := time.ParseDuration("1us")

fmt.Println(hours)
fmt.Println(complex)
fmt.Printf("There are %.0f seconds in %v.\n", complex.Seconds(), complex)
fmt.Printf("There are %d nanoseconds in %v.\n", micro.Nanoseconds(), micro)
fmt.Printf("There are %6.2e seconds in %v.\n", micro2.Seconds(), micro)
</pre> <p>Output:</p> <pre class="output" data-language="go">10h0m0s
1h10m10s
There are 4210 seconds in 1h10m10s.
There are 1000 nanoseconds in 1µs.
There are 1.00e-06 seconds in 1µs.
</pre>   <h3 id="Since">func <span>Since</span>  </h3> <pre data-language="go">func Since(t Time) Duration</pre> <p>Since returns the time elapsed since t. It is shorthand for time.Now().Sub(t). </p>
<h3 id="Until">func <span>Until</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func Until(t Time) Duration</pre> <p>Until returns the duration until t. It is shorthand for t.Sub(time.Now()). </p>
<h3 id="Duration.Abs">func (Duration) <span>Abs</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (d Duration) Abs() Duration</pre> <p>Abs returns the absolute value of d. As a special case, math.MinInt64 is converted to math.MaxInt64. </p>
<h3 id="Duration.Hours">func (Duration) <span>Hours</span>  </h3> <pre data-language="go">func (d Duration) Hours() float64</pre> <p>Hours returns the duration as a floating point number of hours. </p>   <h4 id="example_Duration_Hours"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">h, _ := time.ParseDuration("4h30m")
fmt.Printf("I've got %.1f hours of work left.", h.Hours())
</pre> <p>Output:</p> <pre class="output" data-language="go">I've got 4.5 hours of work left.
</pre>   <h3 id="Duration.Microseconds">func (Duration) <span>Microseconds</span>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (d Duration) Microseconds() int64</pre> <p>Microseconds returns the duration as an integer microsecond count. </p>   <h4 id="example_Duration_Microseconds"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">u, _ := time.ParseDuration("1s")
fmt.Printf("One second is %d microseconds.\n", u.Microseconds())
</pre> <p>Output:</p> <pre class="output" data-language="go">One second is 1000000 microseconds.
</pre>   <h3 id="Duration.Milliseconds">func (Duration) <span>Milliseconds</span>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (d Duration) Milliseconds() int64</pre> <p>Milliseconds returns the duration as an integer millisecond count. </p>   <h4 id="example_Duration_Milliseconds"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">u, _ := time.ParseDuration("1s")
fmt.Printf("One second is %d milliseconds.\n", u.Milliseconds())
</pre> <p>Output:</p> <pre class="output" data-language="go">One second is 1000 milliseconds.
</pre>   <h3 id="Duration.Minutes">func (Duration) <span>Minutes</span>  </h3> <pre data-language="go">func (d Duration) Minutes() float64</pre> <p>Minutes returns the duration as a floating point number of minutes. </p>   <h4 id="example_Duration_Minutes"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">m, _ := time.ParseDuration("1h30m")
fmt.Printf("The movie is %.0f minutes long.", m.Minutes())
</pre> <p>Output:</p> <pre class="output" data-language="go">The movie is 90 minutes long.
</pre>   <h3 id="Duration.Nanoseconds">func (Duration) <span>Nanoseconds</span>  </h3> <pre data-language="go">func (d Duration) Nanoseconds() int64</pre> <p>Nanoseconds returns the duration as an integer nanosecond count. </p>   <h4 id="example_Duration_Nanoseconds"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">u, _ := time.ParseDuration("1µs")
fmt.Printf("One microsecond is %d nanoseconds.\n", u.Nanoseconds())
</pre> <p>Output:</p> <pre class="output" data-language="go">One microsecond is 1000 nanoseconds.
</pre>   <h3 id="Duration.Round">func (Duration) <span>Round</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (d Duration) Round(m Duration) Duration</pre> <p>Round returns the result of rounding d to the nearest multiple of m. The rounding behavior for halfway values is to round away from zero. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, Round returns the maximum (or minimum) duration. If m &lt;= 0, Round returns d unchanged. </p>   <h4 id="example_Duration_Round"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">d, err := time.ParseDuration("1h15m30.918273645s")
if err != nil {
    panic(err)
}

round := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
    time.Hour,
}

for _, r := range round {
    fmt.Printf("d.Round(%6s) = %s\n", r, d.Round(r).String())
}
</pre> <p>Output:</p> <pre class="output" data-language="go">d.Round(   1ns) = 1h15m30.918273645s
d.Round(   1µs) = 1h15m30.918274s
d.Round(   1ms) = 1h15m30.918s
d.Round(    1s) = 1h15m31s
d.Round(    2s) = 1h15m30s
d.Round(  1m0s) = 1h16m0s
d.Round( 10m0s) = 1h20m0s
d.Round(1h0m0s) = 1h0m0s
</pre>   <h3 id="Duration.Seconds">func (Duration) <span>Seconds</span>  </h3> <pre data-language="go">func (d Duration) Seconds() float64</pre> <p>Seconds returns the duration as a floating point number of seconds. </p>   <h4 id="example_Duration_Seconds"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">m, _ := time.ParseDuration("1m30s")
fmt.Printf("Take off in t-%.0f seconds.", m.Seconds())
</pre> <p>Output:</p> <pre class="output" data-language="go">Take off in t-90 seconds.
</pre>   <h3 id="Duration.String">func (Duration) <span>String</span>  </h3> <pre data-language="go">func (d Duration) String() string</pre> <p>String returns a string representing the duration in the form "72h3m0.5s". Leading zero units are omitted. As a special case, durations less than one second format use a smaller unit (milli-, micro-, or nanoseconds) to ensure that the leading digit is non-zero. The zero duration formats as 0s. </p>   <h4 id="example_Duration_String"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(1*time.Hour + 2*time.Minute + 300*time.Millisecond)
fmt.Println(300 * time.Millisecond)
</pre> <p>Output:</p> <pre class="output" data-language="go">1h2m0.3s
300ms
</pre>   <h3 id="Duration.Truncate">func (Duration) <span>Truncate</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (d Duration) Truncate(m Duration) Duration</pre> <p>Truncate returns the result of rounding d toward zero to a multiple of m. If m &lt;= 0, Truncate returns d unchanged. </p>   <h4 id="example_Duration_Truncate"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">d, err := time.ParseDuration("1h15m30.918273645s")
if err != nil {
    panic(err)
}

trunc := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
    time.Hour,
}

for _, t := range trunc {
    fmt.Printf("d.Truncate(%6s) = %s\n", t, d.Truncate(t).String())
}
</pre> <p>Output:</p> <pre class="output" data-language="go">d.Truncate(   1ns) = 1h15m30.918273645s
d.Truncate(   1µs) = 1h15m30.918273s
d.Truncate(   1ms) = 1h15m30.918s
d.Truncate(    1s) = 1h15m30s
d.Truncate(    2s) = 1h15m30s
d.Truncate(  1m0s) = 1h15m0s
d.Truncate( 10m0s) = 1h10m0s
d.Truncate(1h0m0s) = 1h0m0s
</pre>   <h2 id="Location">type <span>Location</span>  </h2> <p>A Location maps time instants to the zone in use at that time. Typically, the Location represents the collection of time offsets in use in a geographical area. For many Locations the time offset varies depending on whether daylight savings time is in use at the time instant. </p>
<pre data-language="go">type Location struct {
    // contains filtered or unexported fields
}
</pre> <p>Local represents the system's local time zone. On Unix systems, Local consults the TZ environment variable to find the time zone to use. No TZ means use the system default /etc/localtime. TZ="" means use UTC. TZ="foo" means use file foo in the system timezone directory. </p>
<pre data-language="go">var Local *Location = &amp;localLoc</pre> <p>UTC represents Universal Coordinated Time (UTC). </p>
<pre data-language="go">var UTC *Location = &amp;utcLoc</pre>    <h4 id="example_Location"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// China doesn't have daylight saving. It uses a fixed 8 hour offset from UTC.
secondsEastOfUTC := int((8 * time.Hour).Seconds())
beijing := time.FixedZone("Beijing Time", secondsEastOfUTC)

// If the system has a timezone database present, it's possible to load a location
// from that, e.g.:
//    newYork, err := time.LoadLocation("America/New_York")

// Creating a time requires a location. Common locations are time.Local and time.UTC.
timeInUTC := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
sameTimeInBeijing := time.Date(2009, 1, 1, 20, 0, 0, 0, beijing)

// Although the UTC clock time is 1200 and the Beijing clock time is 2000, Beijing is
// 8 hours ahead so the two dates actually represent the same instant.
timesAreEqual := timeInUTC.Equal(sameTimeInBeijing)
fmt.Println(timesAreEqual)

</pre> <p>Output:</p> <pre class="output" data-language="go">true
</pre>   <h3 id="FixedZone">func <span>FixedZone</span>  </h3> <pre data-language="go">func FixedZone(name string, offset int) *Location</pre> <p>FixedZone returns a Location that always uses the given zone name and offset (seconds east of UTC). </p>   <h4 id="example_FixedZone"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">loc := time.FixedZone("UTC-8", -8*60*60)
t := time.Date(2009, time.November, 10, 23, 0, 0, 0, loc)
fmt.Println("The time is:", t.Format(time.RFC822))
</pre> <p>Output:</p> <pre class="output" data-language="go">The time is: 10 Nov 09 23:00 UTC-8
</pre>   <h3 id="LoadLocation">func <span>LoadLocation</span>  </h3> <pre data-language="go">func LoadLocation(name string) (*Location, error)</pre> <p>LoadLocation returns the Location with the given name. </p>
<p>If the name is "" or "UTC", LoadLocation returns UTC. If the name is "Local", LoadLocation returns Local. </p>
<p>Otherwise, the name is taken to be a location name corresponding to a file in the IANA Time Zone database, such as "America/New_York". </p>
<p>LoadLocation looks for the IANA Time Zone database in the following locations in order: </p>
<ul> <li>the directory or uncompressed zip file named by the ZONEINFO environment variable </li>
<li>on a Unix system, the system standard installation location </li>
<li>$GOROOT/lib/time/zoneinfo.zip </li>
<li>the time/tzdata package, if it was imported </li>
</ul>    <h4 id="example_LoadLocation"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">location, err := time.LoadLocation("America/Los_Angeles")
if err != nil {
    panic(err)
}

timeInUTC := time.Date(2018, 8, 30, 12, 0, 0, 0, time.UTC)
fmt.Println(timeInUTC.In(location))
</pre> <p>Output:</p> <pre class="output" data-language="go">2018-08-30 05:00:00 -0700 PDT
</pre>   <h3 id="LoadLocationFromTZData">func <span>LoadLocationFromTZData</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func LoadLocationFromTZData(name string, data []byte) (*Location, error)</pre> <p>LoadLocationFromTZData returns a Location with the given name initialized from the IANA Time Zone database-formatted data. The data should be in the format of a standard IANA time zone file (for example, the content of /etc/localtime on Unix systems). </p>
<h3 id="Location.String">func (*Location) <span>String</span>  </h3> <pre data-language="go">func (l *Location) String() string</pre> <p>String returns a descriptive name for the time zone information, corresponding to the name argument to LoadLocation or FixedZone. </p>
<h2 id="Month">type <span>Month</span>  </h2> <p>A Month specifies a month of the year (January = 1, ...). </p>
<pre data-language="go">type Month int</pre> <pre data-language="go">const (
    January Month = 1 + iota
    February
    March
    April
    May
    June
    July
    August
    September
    October
    November
    December
)</pre>    <h4 id="example_Month"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
_, month, day := time.Now().Date()
if month == time.November &amp;&amp; day == 10 {
    fmt.Println("Happy Go day!")
}
</pre>   <h3 id="Month.String">func (Month) <span>String</span>  </h3> <pre data-language="go">func (m Month) String() string</pre> <p>String returns the English name of the month ("January", "February", ...). </p>
<h2 id="ParseError">type <span>ParseError</span>  </h2> <p>ParseError describes a problem parsing a time string. </p>
<pre data-language="go">type ParseError struct {
    Layout     string
    Value      string
    LayoutElem string
    ValueElem  string
    Message    string
}
</pre> <h3 id="ParseError.Error">func (*ParseError) <span>Error</span>  </h3> <pre data-language="go">func (e *ParseError) Error() string</pre> <p>Error returns the string representation of a ParseError. </p>
<h2 id="Ticker">type <span>Ticker</span>  </h2> <p>A Ticker holds a channel that delivers “ticks” of a clock at intervals. </p>
<pre data-language="go">type Ticker struct {
    C &lt;-chan Time // The channel on which the ticks are delivered.
    // contains filtered or unexported fields
}
</pre> <h3 id="NewTicker">func <span>NewTicker</span>  </h3> <pre data-language="go">func NewTicker(d Duration) *Ticker</pre> <p>NewTicker returns a new Ticker containing a channel that will send the current time on the channel after each tick. The period of the ticks is specified by the duration argument. The ticker will adjust the time interval or drop ticks to make up for slow receivers. The duration d must be greater than zero; if not, NewTicker will panic. Stop the ticker to release associated resources. </p>   <h4 id="example_NewTicker"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
ticker := time.NewTicker(time.Second)
defer ticker.Stop()
done := make(chan bool)
go func() {
    time.Sleep(10 * time.Second)
    done &lt;- true
}()
for {
    select {
    case &lt;-done:
        fmt.Println("Done!")
        return
    case t := &lt;-ticker.C:
        fmt.Println("Current time: ", t)
    }
}
</pre>   <h3 id="Ticker.Reset">func (*Ticker) <span>Reset</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (t *Ticker) Reset(d Duration)</pre> <p>Reset stops a ticker and resets its period to the specified duration. The next tick will arrive after the new period elapses. The duration d must be greater than zero; if not, Reset will panic. </p>
<h3 id="Ticker.Stop">func (*Ticker) <span>Stop</span>  </h3> <pre data-language="go">func (t *Ticker) Stop()</pre> <p>Stop turns off a ticker. After Stop, no more ticks will be sent. Stop does not close the channel, to prevent a concurrent goroutine reading from the channel from seeing an erroneous "tick". </p>
<h2 id="Time">type <span>Time</span>  </h2> <p>A Time represents an instant in time with nanosecond precision. </p>
<p>Programs using times should typically store and pass them as values, not pointers. That is, time variables and struct fields should be of type time.Time, not *time.Time. </p>
<p>A Time value can be used by multiple goroutines simultaneously except that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and UnmarshalText are not concurrency-safe. </p>
<p>Time instants can be compared using the Before, After, and Equal methods. The Sub method subtracts two instants, producing a Duration. The Add method adds a Time and a Duration, producing a Time. </p>
<p>The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC. As this time is unlikely to come up in practice, the IsZero method gives a simple way of detecting a time that has not been initialized explicitly. </p>
<p>Each Time has associated with it a Location, consulted when computing the presentation form of the time, such as in the Format, Hour, and Year methods. The methods Local, UTC, and In return a Time with a specific location. Changing the location in this way changes only the presentation; it does not change the instant in time being denoted and therefore does not affect the computations described in earlier paragraphs. </p>
<p>Representations of a Time value saved by the GobEncode, MarshalBinary, MarshalJSON, and MarshalText methods store the Time.Location's offset, but not the location name. They therefore lose information about Daylight Saving Time. </p>
<p>In addition to the required “wall clock” reading, a Time may contain an optional reading of the current process's monotonic clock, to provide additional precision for comparison or subtraction. See the “Monotonic Clocks” section in the package documentation for details. </p>
<p>Note that the Go == operator compares not just the time instant but also the Location and the monotonic clock reading. Therefore, Time values should not be used as map or database keys without first guaranteeing that the identical Location has been set for all values, which can be achieved through use of the UTC or Local method, and that the monotonic clock reading has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u) to t == u, since t.Equal uses the most accurate comparison available and correctly handles the case when only one of its arguments has a monotonic clock reading. </p>
<pre data-language="go">type Time struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Date">func <span>Date</span>  </h3> <pre data-language="go">func Date(year int, month Month, day, hour, min, sec, nsec int, loc *Location) Time</pre> <p>Date returns the Time corresponding to </p>
<pre data-language="go">yyyy-mm-dd hh:mm:ss + nsec nanoseconds
</pre> <p>in the appropriate zone for that time in the given location. </p>
<p>The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1. </p>
<p>A daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which. </p>
<p>Date panics if loc is nil. </p>   <h4 id="example_Date"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Printf("Go launched at %s\n", t.Local())
</pre> <p>Output:</p> <pre class="output" data-language="go">Go launched at 2009-11-10 15:00:00 -0800 PST
</pre>   <h3 id="Now">func <span>Now</span>  </h3> <pre data-language="go">func Now() Time</pre> <p>Now returns the current local time. </p>
<h3 id="Parse">func <span>Parse</span>  </h3> <pre data-language="go">func Parse(layout, value string) (Time, error)</pre> <p>Parse parses a formatted string and returns the time value it represents. See the documentation for the constant called Layout to see how to represent the format. The second argument must be parseable using the format string (layout) provided as the first argument. </p>
<p>The example for Time.Format demonstrates the working of the layout string in detail and is a good reference. </p>
<p>When parsing (only), the input may contain a fractional second field immediately after the seconds field, even if the layout does not signify its presence. In that case either a comma or a decimal point followed by a maximal series of digits is parsed as a fractional second. Fractional seconds are truncated to nanosecond precision. </p>
<p>Elements omitted from the layout are assumed to be zero or, when zero is impossible, one, so parsing "3:04pm" returns the time corresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is 0, this time is before the zero Time). Years must be in the range 0000..9999. The day of the week is checked for syntax but it is otherwise ignored. </p>
<p>For layouts specifying the two-digit year 06, a value NN &gt;= 69 will be treated as 19NN and a value NN &lt; 69 will be treated as 20NN. </p>
<p>The remainder of this comment describes the handling of time zones. </p>
<p>In the absence of a time zone indicator, Parse returns a time in UTC. </p>
<p>When parsing a time with a zone offset like -0700, if the offset corresponds to a time zone used by the current location (Local), then Parse uses that location and zone in the returned time. Otherwise it records the time as being in a fabricated location with time fixed at the given zone offset. </p>
<p>When parsing a time with a zone abbreviation like MST, if the zone abbreviation has a defined offset in the current location, then that offset is used. The zone abbreviation "UTC" is recognized as UTC regardless of location. If the zone abbreviation is unknown, Parse records the time as being in a fabricated location with the given zone abbreviation and a zero offset. This choice means that such a time can be parsed and reformatted with the same layout losslessly, but the exact instant used in the representation will differ by the actual zone offset. To avoid such problems, prefer time layouts that use a numeric zone offset, or use ParseInLocation. </p>   <h4 id="example_Parse"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// See the example for Time.Format for a thorough description of how
// to define the layout string to parse a time.Time value; Parse and
// Format use the same model to describe their input and output.

// longForm shows by example how the reference time would be represented in
// the desired layout.
const longForm = "Jan 2, 2006 at 3:04pm (MST)"
t, _ := time.Parse(longForm, "Feb 3, 2013 at 7:54pm (PST)")
fmt.Println(t)

// shortForm is another way the reference time would be represented
// in the desired layout; it has no time zone present.
// Note: without explicit zone, returns time in UTC.
const shortForm = "2006-Jan-02"
t, _ = time.Parse(shortForm, "2013-Feb-03")
fmt.Println(t)

// Some valid layouts are invalid time values, due to format specifiers
// such as _ for space padding and Z for zone information.
// For example the RFC3339 layout 2006-01-02T15:04:05Z07:00
// contains both Z and a time zone offset in order to handle both valid options:
// 2006-01-02T15:04:05Z
// 2006-01-02T15:04:05+07:00
t, _ = time.Parse(time.RFC3339, "2006-01-02T15:04:05Z")
fmt.Println(t)
t, _ = time.Parse(time.RFC3339, "2006-01-02T15:04:05+07:00")
fmt.Println(t)
_, err := time.Parse(time.RFC3339, time.RFC3339)
fmt.Println("error", err) // Returns an error as the layout is not a valid time value

</pre> <p>Output:</p> <pre class="output" data-language="go">2013-02-03 19:54:00 -0800 PST
2013-02-03 00:00:00 +0000 UTC
2006-01-02 15:04:05 +0000 UTC
2006-01-02 15:04:05 +0700 +0700
error parsing time "2006-01-02T15:04:05Z07:00": extra text: "07:00"
</pre>   <h3 id="ParseInLocation">func <span>ParseInLocation</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func ParseInLocation(layout, value string, loc *Location) (Time, error)</pre> <p>ParseInLocation is like Parse but differs in two important ways. First, in the absence of time zone information, Parse interprets a time as UTC; ParseInLocation interprets the time as in the given location. Second, when given a zone offset or abbreviation, Parse tries to match it against the Local location; ParseInLocation uses the given location. </p>   <h4 id="example_ParseInLocation"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">loc, _ := time.LoadLocation("Europe/Berlin")

// This will look for the name CEST in the Europe/Berlin time zone.
const longForm = "Jan 2, 2006 at 3:04pm (MST)"
t, _ := time.ParseInLocation(longForm, "Jul 9, 2012 at 5:02am (CEST)", loc)
fmt.Println(t)

// Note: without explicit zone, returns time in given location.
const shortForm = "2006-Jan-02"
t, _ = time.ParseInLocation(shortForm, "2012-Jul-09", loc)
fmt.Println(t)

</pre> <p>Output:</p> <pre class="output" data-language="go">2012-07-09 05:02:00 +0200 CEST
2012-07-09 00:00:00 +0200 CEST
</pre>   <h3 id="Unix">func <span>Unix</span>  </h3> <pre data-language="go">func Unix(sec int64, nsec int64) Time</pre> <p>Unix returns the local Time corresponding to the given Unix time, sec seconds and nsec nanoseconds since January 1, 1970 UTC. It is valid to pass nsec outside the range [0, 999999999]. Not all sec values have a corresponding time value. One such value is 1&lt;&lt;63-1 (the largest int64 value). </p>   <h4 id="example_Unix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">unixTime := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Println(unixTime.Unix())
t := time.Unix(unixTime.Unix(), 0).UTC()
fmt.Println(t)

</pre> <p>Output:</p> <pre class="output" data-language="go">1257894000
2009-11-10 23:00:00 +0000 UTC
</pre>   <h3 id="UnixMicro">func <span>UnixMicro</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func UnixMicro(usec int64) Time</pre> <p>UnixMicro returns the local Time corresponding to the given Unix time, usec microseconds since January 1, 1970 UTC. </p>   <h4 id="example_UnixMicro"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">umt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Println(umt.UnixMicro())
t := time.UnixMicro(umt.UnixMicro()).UTC()
fmt.Println(t)

</pre> <p>Output:</p> <pre class="output" data-language="go">1257894000000000
2009-11-10 23:00:00 +0000 UTC
</pre>   <h3 id="UnixMilli">func <span>UnixMilli</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func UnixMilli(msec int64) Time</pre> <p>UnixMilli returns the local Time corresponding to the given Unix time, msec milliseconds since January 1, 1970 UTC. </p>   <h4 id="example_UnixMilli"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">umt := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Println(umt.UnixMilli())
t := time.UnixMilli(umt.UnixMilli()).UTC()
fmt.Println(t)

</pre> <p>Output:</p> <pre class="output" data-language="go">1257894000000
2009-11-10 23:00:00 +0000 UTC
</pre>   <h3 id="Time.Add">func (Time) <span>Add</span>  </h3> <pre data-language="go">func (t Time) Add(d Duration) Time</pre> <p>Add returns the time t+d. </p>   <h4 id="example_Time_Add"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">start := time.Date(2009, 1, 1, 12, 0, 0, 0, time.UTC)
afterTenSeconds := start.Add(time.Second * 10)
afterTenMinutes := start.Add(time.Minute * 10)
afterTenHours := start.Add(time.Hour * 10)
afterTenDays := start.Add(time.Hour * 24 * 10)

fmt.Printf("start = %v\n", start)
fmt.Printf("start.Add(time.Second * 10) = %v\n", afterTenSeconds)
fmt.Printf("start.Add(time.Minute * 10) = %v\n", afterTenMinutes)
fmt.Printf("start.Add(time.Hour * 10) = %v\n", afterTenHours)
fmt.Printf("start.Add(time.Hour * 24 * 10) = %v\n", afterTenDays)

</pre> <p>Output:</p> <pre class="output" data-language="go">start = 2009-01-01 12:00:00 +0000 UTC
start.Add(time.Second * 10) = 2009-01-01 12:00:10 +0000 UTC
start.Add(time.Minute * 10) = 2009-01-01 12:10:00 +0000 UTC
start.Add(time.Hour * 10) = 2009-01-01 22:00:00 +0000 UTC
start.Add(time.Hour * 24 * 10) = 2009-01-11 12:00:00 +0000 UTC
</pre>   <h3 id="Time.AddDate">func (Time) <span>AddDate</span>  </h3> <pre data-language="go">func (t Time) AddDate(years int, months int, days int) Time</pre> <p>AddDate returns the time corresponding to adding the given number of years, months, and days to t. For example, AddDate(-1, 2, 3) applied to January 1, 2011 returns March 4, 2010. </p>
<p>AddDate normalizes its result in the same way that Date does, so, for example, adding one month to October 31 yields December 1, the normalized form for November 31. </p>   <h4 id="example_Time_AddDate"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">start := time.Date(2009, 1, 1, 0, 0, 0, 0, time.UTC)
oneDayLater := start.AddDate(0, 0, 1)
oneMonthLater := start.AddDate(0, 1, 0)
oneYearLater := start.AddDate(1, 0, 0)

fmt.Printf("oneDayLater: start.AddDate(0, 0, 1) = %v\n", oneDayLater)
fmt.Printf("oneMonthLater: start.AddDate(0, 1, 0) = %v\n", oneMonthLater)
fmt.Printf("oneYearLater: start.AddDate(1, 0, 0) = %v\n", oneYearLater)

</pre> <p>Output:</p> <pre class="output" data-language="go">oneDayLater: start.AddDate(0, 0, 1) = 2009-01-02 00:00:00 +0000 UTC
oneMonthLater: start.AddDate(0, 1, 0) = 2009-02-01 00:00:00 +0000 UTC
oneYearLater: start.AddDate(1, 0, 0) = 2010-01-01 00:00:00 +0000 UTC
</pre>   <h3 id="Time.After">func (Time) <span>After</span>  </h3> <pre data-language="go">func (t Time) After(u Time) bool</pre> <p>After reports whether the time instant t is after u. </p>   <h4 id="example_Time_After"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">year2000 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
year3000 := time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC)

isYear3000AfterYear2000 := year3000.After(year2000) // True
isYear2000AfterYear3000 := year2000.After(year3000) // False

fmt.Printf("year3000.After(year2000) = %v\n", isYear3000AfterYear2000)
fmt.Printf("year2000.After(year3000) = %v\n", isYear2000AfterYear3000)

</pre> <p>Output:</p> <pre class="output" data-language="go">year3000.After(year2000) = true
year2000.After(year3000) = false
</pre>   <h3 id="Time.AppendFormat">func (Time) <span>AppendFormat</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t Time) AppendFormat(b []byte, layout string) []byte</pre> <p>AppendFormat is like Format but appends the textual representation to b and returns the extended buffer. </p>   <h4 id="example_Time_AppendFormat"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">t := time.Date(2017, time.November, 4, 11, 0, 0, 0, time.UTC)
text := []byte("Time: ")

text = t.AppendFormat(text, time.Kitchen)
fmt.Println(string(text))

</pre> <p>Output:</p> <pre class="output" data-language="go">Time: 11:00AM
</pre>   <h3 id="Time.Before">func (Time) <span>Before</span>  </h3> <pre data-language="go">func (t Time) Before(u Time) bool</pre> <p>Before reports whether the time instant t is before u. </p>   <h4 id="example_Time_Before"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">year2000 := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
year3000 := time.Date(3000, 1, 1, 0, 0, 0, 0, time.UTC)

isYear2000BeforeYear3000 := year2000.Before(year3000) // True
isYear3000BeforeYear2000 := year3000.Before(year2000) // False

fmt.Printf("year2000.Before(year3000) = %v\n", isYear2000BeforeYear3000)
fmt.Printf("year3000.Before(year2000) = %v\n", isYear3000BeforeYear2000)

</pre> <p>Output:</p> <pre class="output" data-language="go">year2000.Before(year3000) = true
year3000.Before(year2000) = false
</pre>   <h3 id="Time.Clock">func (Time) <span>Clock</span>  </h3> <pre data-language="go">func (t Time) Clock() (hour, min, sec int)</pre> <p>Clock returns the hour, minute, and second within the day specified by t. </p>
<h3 id="Time.Compare">func (Time) <span>Compare</span>  <span title="Added in Go 1.20">1.20</span> </h3> <pre data-language="go">func (t Time) Compare(u Time) int</pre> <p>Compare compares the time instant t with u. If t is before u, it returns -1; if t is after u, it returns +1; if they're the same, it returns 0. </p>
<h3 id="Time.Date">func (Time) <span>Date</span>  </h3> <pre data-language="go">func (t Time) Date() (year int, month Month, day int)</pre> <p>Date returns the year, month, and day in which t occurs. </p>   <h4 id="example_Time_Date"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">d := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
year, month, day := d.Date()

fmt.Printf("year = %v\n", year)
fmt.Printf("month = %v\n", month)
fmt.Printf("day = %v\n", day)

</pre> <p>Output:</p> <pre class="output" data-language="go">year = 2000
month = February
day = 1
</pre>   <h3 id="Time.Day">func (Time) <span>Day</span>  </h3> <pre data-language="go">func (t Time) Day() int</pre> <p>Day returns the day of the month specified by t. </p>   <h4 id="example_Time_Day"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">d := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
day := d.Day()

fmt.Printf("day = %v\n", day)

</pre> <p>Output:</p> <pre class="output" data-language="go">day = 1
</pre>   <h3 id="Time.Equal">func (Time) <span>Equal</span>  </h3> <pre data-language="go">func (t Time) Equal(u Time) bool</pre> <p>Equal reports whether t and u represent the same time instant. Two times can be equal even if they are in different locations. For example, 6:00 +0200 and 4:00 UTC are Equal. See the documentation on the Time type for the pitfalls of using == with Time values; most code should use Equal instead. </p>   <h4 id="example_Time_Equal"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">secondsEastOfUTC := int((8 * time.Hour).Seconds())
beijing := time.FixedZone("Beijing Time", secondsEastOfUTC)

// Unlike the equal operator, Equal is aware that d1 and d2 are the
// same instant but in different time zones.
d1 := time.Date(2000, 2, 1, 12, 30, 0, 0, time.UTC)
d2 := time.Date(2000, 2, 1, 20, 30, 0, 0, beijing)

datesEqualUsingEqualOperator := d1 == d2
datesEqualUsingFunction := d1.Equal(d2)

fmt.Printf("datesEqualUsingEqualOperator = %v\n", datesEqualUsingEqualOperator)
fmt.Printf("datesEqualUsingFunction = %v\n", datesEqualUsingFunction)

</pre> <p>Output:</p> <pre class="output" data-language="go">datesEqualUsingEqualOperator = false
datesEqualUsingFunction = true
</pre>   <h3 id="Time.Format">func (Time) <span>Format</span>  </h3> <pre data-language="go">func (t Time) Format(layout string) string</pre> <p>Format returns a textual representation of the time value formatted according to the layout defined by the argument. See the documentation for the constant called Layout to see how to represent the layout format. </p>
<p>The executable example for Time.Format demonstrates the working of the layout string in detail and is a good reference. </p>   <h4 id="example_Time_Format"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// Parse a time value from a string in the standard Unix format.
t, err := time.Parse(time.UnixDate, "Wed Feb 25 11:06:39 PST 2015")
if err != nil { // Always check errors even if they should not happen.
    panic(err)
}

tz, err := time.LoadLocation("Asia/Shanghai")
if err != nil { // Always check errors even if they should not happen.
    panic(err)
}

// time.Time's Stringer method is useful without any format.
fmt.Println("default format:", t)

// Predefined constants in the package implement common layouts.
fmt.Println("Unix format:", t.Format(time.UnixDate))

// The time zone attached to the time value affects its output.
fmt.Println("Same, in UTC:", t.UTC().Format(time.UnixDate))

fmt.Println("in Shanghai with seconds:", t.In(tz).Format("2006-01-02T15:04:05 -070000"))

fmt.Println("in Shanghai with colon seconds:", t.In(tz).Format("2006-01-02T15:04:05 -07:00:00"))

// The rest of this function demonstrates the properties of the
// layout string used in the format.

// The layout string used by the Parse function and Format method
// shows by example how the reference time should be represented.
// We stress that one must show how the reference time is formatted,
// not a time of the user's choosing. Thus each layout string is a
// representation of the time stamp,
//	Jan 2 15:04:05 2006 MST
// An easy way to remember this value is that it holds, when presented
// in this order, the values (lined up with the elements above):
//	  1 2  3  4  5    6  -7
// There are some wrinkles illustrated below.

// Most uses of Format and Parse use constant layout strings such as
// the ones defined in this package, but the interface is flexible,
// as these examples show.

// Define a helper function to make the examples' output look nice.
do := func(name, layout, want string) {
    got := t.Format(layout)
    if want != got {
        fmt.Printf("error: for %q got %q; expected %q\n", layout, got, want)
        return
    }
    fmt.Printf("%-16s %q gives %q\n", name, layout, got)
}

// Print a header in our output.
fmt.Printf("\nFormats:\n\n")

// Simple starter examples.
do("Basic full date", "Mon Jan 2 15:04:05 MST 2006", "Wed Feb 25 11:06:39 PST 2015")
do("Basic short date", "2006/01/02", "2015/02/25")

// The hour of the reference time is 15, or 3PM. The layout can express
// it either way, and since our value is the morning we should see it as
// an AM time. We show both in one format string. Lower case too.
do("AM/PM", "3PM==3pm==15h", "11AM==11am==11h")

// When parsing, if the seconds value is followed by a decimal point
// and some digits, that is taken as a fraction of a second even if
// the layout string does not represent the fractional second.
// Here we add a fractional second to our time value used above.
t, err = time.Parse(time.UnixDate, "Wed Feb 25 11:06:39.1234 PST 2015")
if err != nil {
    panic(err)
}
// It does not appear in the output if the layout string does not contain
// a representation of the fractional second.
do("No fraction", time.UnixDate, "Wed Feb 25 11:06:39 PST 2015")

// Fractional seconds can be printed by adding a run of 0s or 9s after
// a decimal point in the seconds value in the layout string.
// If the layout digits are 0s, the fractional second is of the specified
// width. Note that the output has a trailing zero.
do("0s for fraction", "15:04:05.00000", "11:06:39.12340")

// If the fraction in the layout is 9s, trailing zeros are dropped.
do("9s for fraction", "15:04:05.99999999", "11:06:39.1234")

</pre> <p>Output:</p> <pre class="output" data-language="go">default format: 2015-02-25 11:06:39 -0800 PST
Unix format: Wed Feb 25 11:06:39 PST 2015
Same, in UTC: Wed Feb 25 19:06:39 UTC 2015
in Shanghai with seconds: 2015-02-26T03:06:39 +080000
in Shanghai with colon seconds: 2015-02-26T03:06:39 +08:00:00

Formats:

Basic full date  "Mon Jan 2 15:04:05 MST 2006" gives "Wed Feb 25 11:06:39 PST 2015"
Basic short date "2006/01/02" gives "2015/02/25"
AM/PM            "3PM==3pm==15h" gives "11AM==11am==11h"
No fraction      "Mon Jan _2 15:04:05 MST 2006" gives "Wed Feb 25 11:06:39 PST 2015"
0s for fraction  "15:04:05.00000" gives "11:06:39.12340"
9s for fraction  "15:04:05.99999999" gives "11:06:39.1234"
</pre>      <h4 id="example_Time_Format_pad"> <span class="text">Example (Pad)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// Parse a time value from a string in the standard Unix format.
t, err := time.Parse(time.UnixDate, "Sat Mar 7 11:06:39 PST 2015")
if err != nil { // Always check errors even if they should not happen.
    panic(err)
}

// Define a helper function to make the examples' output look nice.
do := func(name, layout, want string) {
    got := t.Format(layout)
    if want != got {
        fmt.Printf("error: for %q got %q; expected %q\n", layout, got, want)
        return
    }
    fmt.Printf("%-16s %q gives %q\n", name, layout, got)
}

// The predefined constant Unix uses an underscore to pad the day.
do("Unix", time.UnixDate, "Sat Mar  7 11:06:39 PST 2015")

// For fixed-width printing of values, such as the date, that may be one or
// two characters (7 vs. 07), use an _ instead of a space in the layout string.
// Here we print just the day, which is 2 in our layout string and 7 in our
// value.
do("No pad", "&lt;2&gt;", "&lt;7&gt;")

// An underscore represents a space pad, if the date only has one digit.
do("Spaces", "&lt;_2&gt;", "&lt; 7&gt;")

// A "0" indicates zero padding for single-digit values.
do("Zeros", "&lt;02&gt;", "&lt;07&gt;")

// If the value is already the right width, padding is not used.
// For instance, the second (05 in the reference time) in our value is 39,
// so it doesn't need padding, but the minutes (04, 06) does.
do("Suppressed pad", "04:05", "06:39")

</pre> <p>Output:</p> <pre class="output" data-language="go">Unix             "Mon Jan _2 15:04:05 MST 2006" gives "Sat Mar  7 11:06:39 PST 2015"
No pad           "&lt;2&gt;" gives "&lt;7&gt;"
Spaces           "&lt;_2&gt;" gives "&lt; 7&gt;"
Zeros            "&lt;02&gt;" gives "&lt;07&gt;"
Suppressed pad   "04:05" gives "06:39"
</pre>   <h3 id="Time.GoString">func (Time) <span>GoString</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (t Time) GoString() string</pre> <p>GoString implements fmt.GoStringer and formats t to be printed in Go source code. </p>   <h4 id="example_Time_GoString"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">t := time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
fmt.Println(t.GoString())
t = t.Add(1 * time.Minute)
fmt.Println(t.GoString())
t = t.AddDate(0, 1, 0)
fmt.Println(t.GoString())
t, _ = time.Parse("Jan 2, 2006 at 3:04pm (MST)", "Feb 3, 2013 at 7:54pm (UTC)")
fmt.Println(t.GoString())

</pre> <p>Output:</p> <pre class="output" data-language="go">time.Date(2009, time.November, 10, 23, 0, 0, 0, time.UTC)
time.Date(2009, time.November, 10, 23, 1, 0, 0, time.UTC)
time.Date(2009, time.December, 10, 23, 1, 0, 0, time.UTC)
time.Date(2013, time.February, 3, 19, 54, 0, 0, time.UTC)
</pre>   <h3 id="Time.GobDecode">func (*Time) <span>GobDecode</span>  </h3> <pre data-language="go">func (t *Time) GobDecode(data []byte) error</pre> <p>GobDecode implements the gob.GobDecoder interface. </p>
<h3 id="Time.GobEncode">func (Time) <span>GobEncode</span>  </h3> <pre data-language="go">func (t Time) GobEncode() ([]byte, error)</pre> <p>GobEncode implements the gob.GobEncoder interface. </p>
<h3 id="Time.Hour">func (Time) <span>Hour</span>  </h3> <pre data-language="go">func (t Time) Hour() int</pre> <p>Hour returns the hour within the day specified by t, in the range [0, 23]. </p>
<h3 id="Time.ISOWeek">func (Time) <span>ISOWeek</span>  </h3> <pre data-language="go">func (t Time) ISOWeek() (year, week int)</pre> <p>ISOWeek returns the ISO 8601 year and week number in which t occurs. Week ranges from 1 to 53. Jan 01 to Jan 03 of year n might belong to week 52 or 53 of year n-1, and Dec 29 to Dec 31 might belong to week 1 of year n+1. </p>
<h3 id="Time.In">func (Time) <span>In</span>  </h3> <pre data-language="go">func (t Time) In(loc *Location) Time</pre> <p>In returns a copy of t representing the same time instant, but with the copy's location information set to loc for display purposes. </p>
<p>In panics if loc is nil. </p>
<h3 id="Time.IsDST">func (Time) <span>IsDST</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (t Time) IsDST() bool</pre> <p>IsDST reports whether the time in the configured location is in Daylight Savings Time. </p>
<h3 id="Time.IsZero">func (Time) <span>IsZero</span>  </h3> <pre data-language="go">func (t Time) IsZero() bool</pre> <p>IsZero reports whether t represents the zero time instant, January 1, year 1, 00:00:00 UTC. </p>
<h3 id="Time.Local">func (Time) <span>Local</span>  </h3> <pre data-language="go">func (t Time) Local() Time</pre> <p>Local returns t with the location set to local time. </p>
<h3 id="Time.Location">func (Time) <span>Location</span>  </h3> <pre data-language="go">func (t Time) Location() *Location</pre> <p>Location returns the time zone information associated with t. </p>
<h3 id="Time.MarshalBinary">func (Time) <span>MarshalBinary</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (t Time) MarshalBinary() ([]byte, error)</pre> <p>MarshalBinary implements the encoding.BinaryMarshaler interface. </p>
<h3 id="Time.MarshalJSON">func (Time) <span>MarshalJSON</span>  </h3> <pre data-language="go">func (t Time) MarshalJSON() ([]byte, error)</pre> <p>MarshalJSON implements the json.Marshaler interface. The time is a quoted string in the RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported. </p>
<h3 id="Time.MarshalText">func (Time) <span>MarshalText</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (t Time) MarshalText() ([]byte, error)</pre> <p>MarshalText implements the encoding.TextMarshaler interface. The time is formatted in RFC 3339 format with sub-second precision. If the timestamp cannot be represented as valid RFC 3339 (e.g., the year is out of range), then an error is reported. </p>
<h3 id="Time.Minute">func (Time) <span>Minute</span>  </h3> <pre data-language="go">func (t Time) Minute() int</pre> <p>Minute returns the minute offset within the hour specified by t, in the range [0, 59]. </p>
<h3 id="Time.Month">func (Time) <span>Month</span>  </h3> <pre data-language="go">func (t Time) Month() Month</pre> <p>Month returns the month of the year specified by t. </p>
<h3 id="Time.Nanosecond">func (Time) <span>Nanosecond</span>  </h3> <pre data-language="go">func (t Time) Nanosecond() int</pre> <p>Nanosecond returns the nanosecond offset within the second specified by t, in the range [0, 999999999]. </p>
<h3 id="Time.Round">func (Time) <span>Round</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (t Time) Round(d Duration) Time</pre> <p>Round returns the result of rounding t to the nearest multiple of d (since the zero time). The rounding behavior for halfway values is to round up. If d &lt;= 0, Round returns t stripped of any monotonic clock reading but otherwise unchanged. </p>
<p>Round operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Round(Hour) may return a time with a non-zero minute, depending on the time's Location. </p>   <h4 id="example_Time_Round"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">t := time.Date(0, 0, 0, 12, 15, 30, 918273645, time.UTC)
round := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
    time.Hour,
}

for _, d := range round {
    fmt.Printf("t.Round(%6s) = %s\n", d, t.Round(d).Format("15:04:05.999999999"))
}
</pre> <p>Output:</p> <pre class="output" data-language="go">t.Round(   1ns) = 12:15:30.918273645
t.Round(   1µs) = 12:15:30.918274
t.Round(   1ms) = 12:15:30.918
t.Round(    1s) = 12:15:31
t.Round(    2s) = 12:15:30
t.Round(  1m0s) = 12:16:00
t.Round( 10m0s) = 12:20:00
t.Round(1h0m0s) = 12:00:00
</pre>   <h3 id="Time.Second">func (Time) <span>Second</span>  </h3> <pre data-language="go">func (t Time) Second() int</pre> <p>Second returns the second offset within the minute specified by t, in the range [0, 59]. </p>
<h3 id="Time.String">func (Time) <span>String</span>  </h3> <pre data-language="go">func (t Time) String() string</pre> <p>String returns the time formatted using the format string </p>
<pre data-language="go">"2006-01-02 15:04:05.999999999 -0700 MST"
</pre> <p>If the time has a monotonic clock reading, the returned string includes a final field "m=±&lt;value&gt;", where value is the monotonic clock reading formatted as a decimal number of seconds. </p>
<p>The returned string is meant for debugging; for a stable serialized representation, use t.MarshalText, t.MarshalBinary, or t.Format with an explicit format string. </p>   <h4 id="example_Time_String"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">timeWithNanoseconds := time.Date(2000, 2, 1, 12, 13, 14, 15, time.UTC)
withNanoseconds := timeWithNanoseconds.String()

timeWithoutNanoseconds := time.Date(2000, 2, 1, 12, 13, 14, 0, time.UTC)
withoutNanoseconds := timeWithoutNanoseconds.String()

fmt.Printf("withNanoseconds = %v\n", string(withNanoseconds))
fmt.Printf("withoutNanoseconds = %v\n", string(withoutNanoseconds))

</pre> <p>Output:</p> <pre class="output" data-language="go">withNanoseconds = 2000-02-01 12:13:14.000000015 +0000 UTC
withoutNanoseconds = 2000-02-01 12:13:14 +0000 UTC
</pre>   <h3 id="Time.Sub">func (Time) <span>Sub</span>  </h3> <pre data-language="go">func (t Time) Sub(u Time) Duration</pre> <p>Sub returns the duration t-u. If the result exceeds the maximum (or minimum) value that can be stored in a Duration, the maximum (or minimum) duration will be returned. To compute t-d for a duration d, use t.Add(-d). </p>   <h4 id="example_Time_Sub"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">start := time.Date(2000, 1, 1, 0, 0, 0, 0, time.UTC)
end := time.Date(2000, 1, 1, 12, 0, 0, 0, time.UTC)

difference := end.Sub(start)
fmt.Printf("difference = %v\n", difference)

</pre> <p>Output:</p> <pre class="output" data-language="go">difference = 12h0m0s
</pre>   <h3 id="Time.Truncate">func (Time) <span>Truncate</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (t Time) Truncate(d Duration) Time</pre> <p>Truncate returns the result of rounding t down to a multiple of d (since the zero time). If d &lt;= 0, Truncate returns t stripped of any monotonic clock reading but otherwise unchanged. </p>
<p>Truncate operates on the time as an absolute duration since the zero time; it does not operate on the presentation form of the time. Thus, Truncate(Hour) may return a time with a non-zero minute, depending on the time's Location. </p>   <h4 id="example_Time_Truncate"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">t, _ := time.Parse("2006 Jan 02 15:04:05", "2012 Dec 07 12:15:30.918273645")
trunc := []time.Duration{
    time.Nanosecond,
    time.Microsecond,
    time.Millisecond,
    time.Second,
    2 * time.Second,
    time.Minute,
    10 * time.Minute,
}

for _, d := range trunc {
    fmt.Printf("t.Truncate(%5s) = %s\n", d, t.Truncate(d).Format("15:04:05.999999999"))
}
// To round to the last midnight in the local timezone, create a new Date.
midnight := time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.Local)
_ = midnight

</pre> <p>Output:</p> <pre class="output" data-language="go">t.Truncate(  1ns) = 12:15:30.918273645
t.Truncate(  1µs) = 12:15:30.918273
t.Truncate(  1ms) = 12:15:30.918
t.Truncate(   1s) = 12:15:30
t.Truncate(   2s) = 12:15:30
t.Truncate( 1m0s) = 12:15:00
t.Truncate(10m0s) = 12:10:00
</pre>   <h3 id="Time.UTC">func (Time) <span>UTC</span>  </h3> <pre data-language="go">func (t Time) UTC() Time</pre> <p>UTC returns t with the location set to UTC. </p>
<h3 id="Time.Unix">func (Time) <span>Unix</span>  </h3> <pre data-language="go">func (t Time) Unix() int64</pre> <p>Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t. Unix-like operating systems often record time as a 32-bit count of seconds, but since the method here returns a 64-bit value it is valid for billions of years into the past or future. </p>   <h4 id="example_Time_Unix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// 1 billion seconds of Unix, three ways.
fmt.Println(time.Unix(1e9, 0).UTC())     // 1e9 seconds
fmt.Println(time.Unix(0, 1e18).UTC())    // 1e18 nanoseconds
fmt.Println(time.Unix(2e9, -1e18).UTC()) // 2e9 seconds - 1e18 nanoseconds

t := time.Date(2001, time.September, 9, 1, 46, 40, 0, time.UTC)
fmt.Println(t.Unix())     // seconds since 1970
fmt.Println(t.UnixNano()) // nanoseconds since 1970

</pre> <p>Output:</p> <pre class="output" data-language="go">2001-09-09 01:46:40 +0000 UTC
2001-09-09 01:46:40 +0000 UTC
2001-09-09 01:46:40 +0000 UTC
1000000000
1000000000000000000
</pre>   <h3 id="Time.UnixMicro">func (Time) <span>UnixMicro</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (t Time) UnixMicro() int64</pre> <p>UnixMicro returns t as a Unix time, the number of microseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in microseconds cannot be represented by an int64 (a date before year -290307 or after year 294246). The result does not depend on the location associated with t. </p>
<h3 id="Time.UnixMilli">func (Time) <span>UnixMilli</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (t Time) UnixMilli() int64</pre> <p>UnixMilli returns t as a Unix time, the number of milliseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in milliseconds cannot be represented by an int64 (a date more than 292 million years before or after 1970). The result does not depend on the location associated with t. </p>
<h3 id="Time.UnixNano">func (Time) <span>UnixNano</span>  </h3> <pre data-language="go">func (t Time) UnixNano() int64</pre> <p>UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t. </p>
<h3 id="Time.UnmarshalBinary">func (*Time) <span>UnmarshalBinary</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (t *Time) UnmarshalBinary(data []byte) error</pre> <p>UnmarshalBinary implements the encoding.BinaryUnmarshaler interface. </p>
<h3 id="Time.UnmarshalJSON">func (*Time) <span>UnmarshalJSON</span>  </h3> <pre data-language="go">func (t *Time) UnmarshalJSON(data []byte) error</pre> <p>UnmarshalJSON implements the json.Unmarshaler interface. The time must be a quoted string in the RFC 3339 format. </p>
<h3 id="Time.UnmarshalText">func (*Time) <span>UnmarshalText</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (t *Time) UnmarshalText(data []byte) error</pre> <p>UnmarshalText implements the encoding.TextUnmarshaler interface. The time must be in the RFC 3339 format. </p>
<h3 id="Time.Weekday">func (Time) <span>Weekday</span>  </h3> <pre data-language="go">func (t Time) Weekday() Weekday</pre> <p>Weekday returns the day of the week specified by t. </p>
<h3 id="Time.Year">func (Time) <span>Year</span>  </h3> <pre data-language="go">func (t Time) Year() int</pre> <p>Year returns the year in which t occurs. </p>
<h3 id="Time.YearDay">func (Time) <span>YearDay</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (t Time) YearDay() int</pre> <p>YearDay returns the day of the year specified by t, in the range [1,365] for non-leap years, and [1,366] in leap years. </p>
<h3 id="Time.Zone">func (Time) <span>Zone</span>  </h3> <pre data-language="go">func (t Time) Zone() (name string, offset int)</pre> <p>Zone computes the time zone in effect at time t, returning the abbreviated name of the zone (such as "CET") and its offset in seconds east of UTC. </p>
<h3 id="Time.ZoneBounds">func (Time) <span>ZoneBounds</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (t Time) ZoneBounds() (start, end Time)</pre> <p>ZoneBounds returns the bounds of the time zone in effect at time t. The zone begins at start and the next zone begins at end. If the zone begins at the beginning of time, start will be returned as a zero Time. If the zone goes on forever, end will be returned as a zero Time. The Location of the returned times will be the same as t. </p>
<h2 id="Timer">type <span>Timer</span>  </h2> <p>The Timer type represents a single event. When the Timer expires, the current time will be sent on C, unless the Timer was created by AfterFunc. A Timer must be created with NewTimer or AfterFunc. </p>
<pre data-language="go">type Timer struct {
    C &lt;-chan Time
    // contains filtered or unexported fields
}
</pre> <h3 id="AfterFunc">func <span>AfterFunc</span>  </h3> <pre data-language="go">func AfterFunc(d Duration, f func()) *Timer</pre> <p>AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method. </p>
<h3 id="NewTimer">func <span>NewTimer</span>  </h3> <pre data-language="go">func NewTimer(d Duration) *Timer</pre> <p>NewTimer creates a new Timer that will send the current time on its channel after at least duration d. </p>
<h3 id="Timer.Reset">func (*Timer) <span>Reset</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (t *Timer) Reset(d Duration) bool</pre> <p>Reset changes the timer to expire after duration d. It returns true if the timer had been active, false if the timer had expired or been stopped. </p>
<p>For a Timer created with NewTimer, Reset should be invoked only on stopped or expired timers with drained channels. </p>
<p>If a program has already received a value from t.C, the timer is known to have expired and the channel drained, so t.Reset can be used directly. If a program has not yet received a value from t.C, however, the timer must be stopped and—if Stop reports that the timer expired before being stopped—the channel explicitly drained: </p>
<pre data-language="go">if !t.Stop() {
	&lt;-t.C
}
t.Reset(d)
</pre> <p>This should not be done concurrent to other receives from the Timer's channel. </p>
<p>Note that it is not possible to use Reset's return value correctly, as there is a race condition between draining the channel and the new timer expiring. Reset should always be invoked on stopped or expired channels, as described above. The return value exists to preserve compatibility with existing programs. </p>
<p>For a Timer created with AfterFunc(d, f), Reset either reschedules when f will run, in which case Reset returns true, or schedules f to run again, in which case it returns false. When Reset returns false, Reset neither waits for the prior f to complete before returning nor does it guarantee that the subsequent goroutine running f does not run concurrently with the prior one. If the caller needs to know whether the prior execution of f is completed, it must coordinate with f explicitly. </p>
<h3 id="Timer.Stop">func (*Timer) <span>Stop</span>  </h3> <pre data-language="go">func (t *Timer) Stop() bool</pre> <p>Stop prevents the Timer from firing. It returns true if the call stops the timer, false if the timer has already expired or been stopped. Stop does not close the channel, to prevent a read from the channel succeeding incorrectly. </p>
<p>To ensure the channel is empty after a call to Stop, check the return value and drain the channel. For example, assuming the program has not received from t.C already: </p>
<pre data-language="go">if !t.Stop() {
	&lt;-t.C
}
</pre> <p>This cannot be done concurrent to other receives from the Timer's channel or other calls to the Timer's Stop method. </p>
<p>For a timer created with AfterFunc(d, f), if t.Stop returns false, then the timer has already expired and the function f has been started in its own goroutine; Stop does not wait for f to complete before returning. If the caller needs to know whether f is completed, it must coordinate with f explicitly. </p>
<h2 id="Weekday">type <span>Weekday</span>  </h2> <p>A Weekday specifies a day of the week (Sunday = 0, ...). </p>
<pre data-language="go">type Weekday int</pre> <pre data-language="go">const (
    Sunday Weekday = iota
    Monday
    Tuesday
    Wednesday
    Thursday
    Friday
    Saturday
)</pre> <h3 id="Weekday.String">func (Weekday) <span>String</span>  </h3> <pre data-language="go">func (d Weekday) String() string</pre> <p>String returns the English name of the day ("Sunday", "Monday", ...). </p>
<h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../index.html">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="tzdata/index.html">tzdata</a> </td> <td class="pkg-synopsis"> Package tzdata provides an embedded copy of the timezone database. </td> </tr> </table> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/time/" class="_attribution-link">http://golang.org/pkg/time/</a>
  </p>
</div>
