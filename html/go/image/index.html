<h1> Package image  </h1>     <ul id="short-nav">
<li><code>import "image"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package image implements a basic 2-D image library. </p>
<p>The fundamental interface is called Image. An Image contains colors, which are described in the image/color package. </p>
<p>Values of the Image interface are created either by calling functions such as NewRGBA and NewPaletted, or by calling Decode on an io.Reader containing image data in a format such as GIF, JPEG or PNG. Decoding any particular image format requires the prior registration of a decoder function. Registration is typically automatic as a side effect of initializing that format's package so that, to decode a PNG image, it suffices to have </p>
<pre data-language="go">import _ "image/png"
</pre> <p>in a program's main package. The _ means to import a package purely for its initialization side effects. </p>
<p>See "The Go image package" for more details: <a href="https://golang.org/doc/articles/image_package.html">https://golang.org/doc/articles/image_package.html</a> </p>   <h4 id="example_"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// Decode the JPEG data. If reading from file, create a reader with
//
// reader, err := os.Open("testdata/video-001.q50.420.jpeg")
// if err != nil {
//     log.Fatal(err)
// }
// defer reader.Close()
reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
m, _, err := image.Decode(reader)
if err != nil {
    log.Fatal(err)
}
bounds := m.Bounds()

// Calculate a 16-bin histogram for m's red, green, blue and alpha components.
//
// An image's bounds do not necessarily start at (0, 0), so the two loops start
// at bounds.Min.Y and bounds.Min.X. Looping over Y first and X second is more
// likely to result in better memory access patterns than X first and Y second.
var histogram [16][4]int
for y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ {
    for x := bounds.Min.X; x &lt; bounds.Max.X; x++ {
        r, g, b, a := m.At(x, y).RGBA()
        // A color's RGBA method returns values in the range [0, 65535].
        // Shifting by 12 reduces this to the range [0, 15].
        histogram[r&gt;&gt;12][0]++
        histogram[g&gt;&gt;12][1]++
        histogram[b&gt;&gt;12][2]++
        histogram[a&gt;&gt;12][3]++
    }
}

// Print the results.
fmt.Printf("%-14s %6s %6s %6s %6s\n", "bin", "red", "green", "blue", "alpha")
for i, x := range histogram {
    fmt.Printf("0x%04x-0x%04x: %6d %6d %6d %6d\n", i&lt;&lt;12, (i+1)&lt;&lt;12-1, x[0], x[1], x[2], x[3])
}
</pre> <p>Output:</p> <pre class="output" data-language="go">bin               red  green   blue  alpha
0x0000-0x0fff:    364    790   7242      0
0x1000-0x1fff:    645   2967   1039      0
0x2000-0x2fff:   1072   2299    979      0
0x3000-0x3fff:    820   2266    980      0
0x4000-0x4fff:    537   1305    541      0
0x5000-0x5fff:    319    962    261      0
0x6000-0x6fff:    322    375    177      0
0x7000-0x7fff:    601    279    214      0
0x8000-0x8fff:   3478    227    273      0
0x9000-0x9fff:   2260    234    329      0
0xa000-0xafff:    921    282    373      0
0xb000-0xbfff:    321    335    397      0
0xc000-0xcfff:    229    388    298      0
0xd000-0xdfff:    260    414    277      0
0xe000-0xefff:    516    428    298      0
0xf000-0xffff:   2785   1899   1772  15450
</pre>      <h4 id="example__decodeConfig"> <span class="text">Example (DecodeConfig)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
config, format, err := image.DecodeConfig(reader)
if err != nil {
    log.Fatal(err)
}
fmt.Println("Width:", config.Width, "Height:", config.Height, "Format:", format)
</pre>        <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#RegisterFormat">func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))</a></li>
<li><a href="#Alpha">type Alpha</a></li>
<li> <a href="#NewAlpha">func NewAlpha(r Rectangle) *Alpha</a>
</li>
<li> <a href="#Alpha.AlphaAt">func (p *Alpha) AlphaAt(x, y int) color.Alpha</a>
</li>
<li> <a href="#Alpha.At">func (p *Alpha) At(x, y int) color.Color</a>
</li>
<li> <a href="#Alpha.Bounds">func (p *Alpha) Bounds() Rectangle</a>
</li>
<li> <a href="#Alpha.ColorModel">func (p *Alpha) ColorModel() color.Model</a>
</li>
<li> <a href="#Alpha.Opaque">func (p *Alpha) Opaque() bool</a>
</li>
<li> <a href="#Alpha.PixOffset">func (p *Alpha) PixOffset(x, y int) int</a>
</li>
<li> <a href="#Alpha.RGBA64At">func (p *Alpha) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Alpha.Set">func (p *Alpha) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#Alpha.SetAlpha">func (p *Alpha) SetAlpha(x, y int, c color.Alpha)</a>
</li>
<li> <a href="#Alpha.SetRGBA64">func (p *Alpha) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#Alpha.SubImage">func (p *Alpha) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#Alpha16">type Alpha16</a></li>
<li> <a href="#NewAlpha16">func NewAlpha16(r Rectangle) *Alpha16</a>
</li>
<li> <a href="#Alpha16.Alpha16At">func (p *Alpha16) Alpha16At(x, y int) color.Alpha16</a>
</li>
<li> <a href="#Alpha16.At">func (p *Alpha16) At(x, y int) color.Color</a>
</li>
<li> <a href="#Alpha16.Bounds">func (p *Alpha16) Bounds() Rectangle</a>
</li>
<li> <a href="#Alpha16.ColorModel">func (p *Alpha16) ColorModel() color.Model</a>
</li>
<li> <a href="#Alpha16.Opaque">func (p *Alpha16) Opaque() bool</a>
</li>
<li> <a href="#Alpha16.PixOffset">func (p *Alpha16) PixOffset(x, y int) int</a>
</li>
<li> <a href="#Alpha16.RGBA64At">func (p *Alpha16) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Alpha16.Set">func (p *Alpha16) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#Alpha16.SetAlpha16">func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)</a>
</li>
<li> <a href="#Alpha16.SetRGBA64">func (p *Alpha16) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#Alpha16.SubImage">func (p *Alpha16) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#CMYK">type CMYK</a></li>
<li> <a href="#NewCMYK">func NewCMYK(r Rectangle) *CMYK</a>
</li>
<li> <a href="#CMYK.At">func (p *CMYK) At(x, y int) color.Color</a>
</li>
<li> <a href="#CMYK.Bounds">func (p *CMYK) Bounds() Rectangle</a>
</li>
<li> <a href="#CMYK.CMYKAt">func (p *CMYK) CMYKAt(x, y int) color.CMYK</a>
</li>
<li> <a href="#CMYK.ColorModel">func (p *CMYK) ColorModel() color.Model</a>
</li>
<li> <a href="#CMYK.Opaque">func (p *CMYK) Opaque() bool</a>
</li>
<li> <a href="#CMYK.PixOffset">func (p *CMYK) PixOffset(x, y int) int</a>
</li>
<li> <a href="#CMYK.RGBA64At">func (p *CMYK) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#CMYK.Set">func (p *CMYK) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#CMYK.SetCMYK">func (p *CMYK) SetCMYK(x, y int, c color.CMYK)</a>
</li>
<li> <a href="#CMYK.SetRGBA64">func (p *CMYK) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#CMYK.SubImage">func (p *CMYK) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#Config">type Config</a></li>
<li> <a href="#DecodeConfig">func DecodeConfig(r io.Reader) (Config, string, error)</a>
</li>
<li><a href="#Gray">type Gray</a></li>
<li> <a href="#NewGray">func NewGray(r Rectangle) *Gray</a>
</li>
<li> <a href="#Gray.At">func (p *Gray) At(x, y int) color.Color</a>
</li>
<li> <a href="#Gray.Bounds">func (p *Gray) Bounds() Rectangle</a>
</li>
<li> <a href="#Gray.ColorModel">func (p *Gray) ColorModel() color.Model</a>
</li>
<li> <a href="#Gray.GrayAt">func (p *Gray) GrayAt(x, y int) color.Gray</a>
</li>
<li> <a href="#Gray.Opaque">func (p *Gray) Opaque() bool</a>
</li>
<li> <a href="#Gray.PixOffset">func (p *Gray) PixOffset(x, y int) int</a>
</li>
<li> <a href="#Gray.RGBA64At">func (p *Gray) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Gray.Set">func (p *Gray) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#Gray.SetGray">func (p *Gray) SetGray(x, y int, c color.Gray)</a>
</li>
<li> <a href="#Gray.SetRGBA64">func (p *Gray) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#Gray.SubImage">func (p *Gray) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#Gray16">type Gray16</a></li>
<li> <a href="#NewGray16">func NewGray16(r Rectangle) *Gray16</a>
</li>
<li> <a href="#Gray16.At">func (p *Gray16) At(x, y int) color.Color</a>
</li>
<li> <a href="#Gray16.Bounds">func (p *Gray16) Bounds() Rectangle</a>
</li>
<li> <a href="#Gray16.ColorModel">func (p *Gray16) ColorModel() color.Model</a>
</li>
<li> <a href="#Gray16.Gray16At">func (p *Gray16) Gray16At(x, y int) color.Gray16</a>
</li>
<li> <a href="#Gray16.Opaque">func (p *Gray16) Opaque() bool</a>
</li>
<li> <a href="#Gray16.PixOffset">func (p *Gray16) PixOffset(x, y int) int</a>
</li>
<li> <a href="#Gray16.RGBA64At">func (p *Gray16) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Gray16.Set">func (p *Gray16) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#Gray16.SetGray16">func (p *Gray16) SetGray16(x, y int, c color.Gray16)</a>
</li>
<li> <a href="#Gray16.SetRGBA64">func (p *Gray16) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#Gray16.SubImage">func (p *Gray16) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#Image">type Image</a></li>
<li> <a href="#Decode">func Decode(r io.Reader) (Image, string, error)</a>
</li>
<li><a href="#NRGBA">type NRGBA</a></li>
<li> <a href="#NewNRGBA">func NewNRGBA(r Rectangle) *NRGBA</a>
</li>
<li> <a href="#NRGBA.At">func (p *NRGBA) At(x, y int) color.Color</a>
</li>
<li> <a href="#NRGBA.Bounds">func (p *NRGBA) Bounds() Rectangle</a>
</li>
<li> <a href="#NRGBA.ColorModel">func (p *NRGBA) ColorModel() color.Model</a>
</li>
<li> <a href="#NRGBA.NRGBAAt">func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA</a>
</li>
<li> <a href="#NRGBA.Opaque">func (p *NRGBA) Opaque() bool</a>
</li>
<li> <a href="#NRGBA.PixOffset">func (p *NRGBA) PixOffset(x, y int) int</a>
</li>
<li> <a href="#NRGBA.RGBA64At">func (p *NRGBA) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#NRGBA.Set">func (p *NRGBA) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#NRGBA.SetNRGBA">func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)</a>
</li>
<li> <a href="#NRGBA.SetRGBA64">func (p *NRGBA) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#NRGBA.SubImage">func (p *NRGBA) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#NRGBA64">type NRGBA64</a></li>
<li> <a href="#NewNRGBA64">func NewNRGBA64(r Rectangle) *NRGBA64</a>
</li>
<li> <a href="#NRGBA64.At">func (p *NRGBA64) At(x, y int) color.Color</a>
</li>
<li> <a href="#NRGBA64.Bounds">func (p *NRGBA64) Bounds() Rectangle</a>
</li>
<li> <a href="#NRGBA64.ColorModel">func (p *NRGBA64) ColorModel() color.Model</a>
</li>
<li> <a href="#NRGBA64.NRGBA64At">func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64</a>
</li>
<li> <a href="#NRGBA64.Opaque">func (p *NRGBA64) Opaque() bool</a>
</li>
<li> <a href="#NRGBA64.PixOffset">func (p *NRGBA64) PixOffset(x, y int) int</a>
</li>
<li> <a href="#NRGBA64.RGBA64At">func (p *NRGBA64) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#NRGBA64.Set">func (p *NRGBA64) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#NRGBA64.SetNRGBA64">func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)</a>
</li>
<li> <a href="#NRGBA64.SetRGBA64">func (p *NRGBA64) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#NRGBA64.SubImage">func (p *NRGBA64) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#NYCbCrA">type NYCbCrA</a></li>
<li> <a href="#NewNYCbCrA">func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA</a>
</li>
<li> <a href="#NYCbCrA.AOffset">func (p *NYCbCrA) AOffset(x, y int) int</a>
</li>
<li> <a href="#NYCbCrA.At">func (p *NYCbCrA) At(x, y int) color.Color</a>
</li>
<li> <a href="#NYCbCrA.ColorModel">func (p *NYCbCrA) ColorModel() color.Model</a>
</li>
<li> <a href="#NYCbCrA.NYCbCrAAt">func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA</a>
</li>
<li> <a href="#NYCbCrA.Opaque">func (p *NYCbCrA) Opaque() bool</a>
</li>
<li> <a href="#NYCbCrA.RGBA64At">func (p *NYCbCrA) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#NYCbCrA.SubImage">func (p *NYCbCrA) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#Paletted">type Paletted</a></li>
<li> <a href="#NewPaletted">func NewPaletted(r Rectangle, p color.Palette) *Paletted</a>
</li>
<li> <a href="#Paletted.At">func (p *Paletted) At(x, y int) color.Color</a>
</li>
<li> <a href="#Paletted.Bounds">func (p *Paletted) Bounds() Rectangle</a>
</li>
<li> <a href="#Paletted.ColorIndexAt">func (p *Paletted) ColorIndexAt(x, y int) uint8</a>
</li>
<li> <a href="#Paletted.ColorModel">func (p *Paletted) ColorModel() color.Model</a>
</li>
<li> <a href="#Paletted.Opaque">func (p *Paletted) Opaque() bool</a>
</li>
<li> <a href="#Paletted.PixOffset">func (p *Paletted) PixOffset(x, y int) int</a>
</li>
<li> <a href="#Paletted.RGBA64At">func (p *Paletted) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Paletted.Set">func (p *Paletted) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#Paletted.SetColorIndex">func (p *Paletted) SetColorIndex(x, y int, index uint8)</a>
</li>
<li> <a href="#Paletted.SetRGBA64">func (p *Paletted) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#Paletted.SubImage">func (p *Paletted) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#PalettedImage">type PalettedImage</a></li>
<li><a href="#Point">type Point</a></li>
<li> <a href="#Pt">func Pt(X, Y int) Point</a>
</li>
<li> <a href="#Point.Add">func (p Point) Add(q Point) Point</a>
</li>
<li> <a href="#Point.Div">func (p Point) Div(k int) Point</a>
</li>
<li> <a href="#Point.Eq">func (p Point) Eq(q Point) bool</a>
</li>
<li> <a href="#Point.In">func (p Point) In(r Rectangle) bool</a>
</li>
<li> <a href="#Point.Mod">func (p Point) Mod(r Rectangle) Point</a>
</li>
<li> <a href="#Point.Mul">func (p Point) Mul(k int) Point</a>
</li>
<li> <a href="#Point.String">func (p Point) String() string</a>
</li>
<li> <a href="#Point.Sub">func (p Point) Sub(q Point) Point</a>
</li>
<li><a href="#RGBA">type RGBA</a></li>
<li> <a href="#NewRGBA">func NewRGBA(r Rectangle) *RGBA</a>
</li>
<li> <a href="#RGBA.At">func (p *RGBA) At(x, y int) color.Color</a>
</li>
<li> <a href="#RGBA.Bounds">func (p *RGBA) Bounds() Rectangle</a>
</li>
<li> <a href="#RGBA.ColorModel">func (p *RGBA) ColorModel() color.Model</a>
</li>
<li> <a href="#RGBA.Opaque">func (p *RGBA) Opaque() bool</a>
</li>
<li> <a href="#RGBA.PixOffset">func (p *RGBA) PixOffset(x, y int) int</a>
</li>
<li> <a href="#RGBA.RGBA64At">func (p *RGBA) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#RGBA.RGBAAt">func (p *RGBA) RGBAAt(x, y int) color.RGBA</a>
</li>
<li> <a href="#RGBA.Set">func (p *RGBA) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#RGBA.SetRGBA">func (p *RGBA) SetRGBA(x, y int, c color.RGBA)</a>
</li>
<li> <a href="#RGBA.SetRGBA64">func (p *RGBA) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#RGBA.SubImage">func (p *RGBA) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#RGBA64">type RGBA64</a></li>
<li> <a href="#NewRGBA64">func NewRGBA64(r Rectangle) *RGBA64</a>
</li>
<li> <a href="#RGBA64.At">func (p *RGBA64) At(x, y int) color.Color</a>
</li>
<li> <a href="#RGBA64.Bounds">func (p *RGBA64) Bounds() Rectangle</a>
</li>
<li> <a href="#RGBA64.ColorModel">func (p *RGBA64) ColorModel() color.Model</a>
</li>
<li> <a href="#RGBA64.Opaque">func (p *RGBA64) Opaque() bool</a>
</li>
<li> <a href="#RGBA64.PixOffset">func (p *RGBA64) PixOffset(x, y int) int</a>
</li>
<li> <a href="#RGBA64.RGBA64At">func (p *RGBA64) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#RGBA64.Set">func (p *RGBA64) Set(x, y int, c color.Color)</a>
</li>
<li> <a href="#RGBA64.SetRGBA64">func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)</a>
</li>
<li> <a href="#RGBA64.SubImage">func (p *RGBA64) SubImage(r Rectangle) Image</a>
</li>
<li><a href="#RGBA64Image">type RGBA64Image</a></li>
<li><a href="#Rectangle">type Rectangle</a></li>
<li> <a href="#Rect">func Rect(x0, y0, x1, y1 int) Rectangle</a>
</li>
<li> <a href="#Rectangle.Add">func (r Rectangle) Add(p Point) Rectangle</a>
</li>
<li> <a href="#Rectangle.At">func (r Rectangle) At(x, y int) color.Color</a>
</li>
<li> <a href="#Rectangle.Bounds">func (r Rectangle) Bounds() Rectangle</a>
</li>
<li> <a href="#Rectangle.Canon">func (r Rectangle) Canon() Rectangle</a>
</li>
<li> <a href="#Rectangle.ColorModel">func (r Rectangle) ColorModel() color.Model</a>
</li>
<li> <a href="#Rectangle.Dx">func (r Rectangle) Dx() int</a>
</li>
<li> <a href="#Rectangle.Dy">func (r Rectangle) Dy() int</a>
</li>
<li> <a href="#Rectangle.Empty">func (r Rectangle) Empty() bool</a>
</li>
<li> <a href="#Rectangle.Eq">func (r Rectangle) Eq(s Rectangle) bool</a>
</li>
<li> <a href="#Rectangle.In">func (r Rectangle) In(s Rectangle) bool</a>
</li>
<li> <a href="#Rectangle.Inset">func (r Rectangle) Inset(n int) Rectangle</a>
</li>
<li> <a href="#Rectangle.Intersect">func (r Rectangle) Intersect(s Rectangle) Rectangle</a>
</li>
<li> <a href="#Rectangle.Overlaps">func (r Rectangle) Overlaps(s Rectangle) bool</a>
</li>
<li> <a href="#Rectangle.RGBA64At">func (r Rectangle) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#Rectangle.Size">func (r Rectangle) Size() Point</a>
</li>
<li> <a href="#Rectangle.String">func (r Rectangle) String() string</a>
</li>
<li> <a href="#Rectangle.Sub">func (r Rectangle) Sub(p Point) Rectangle</a>
</li>
<li> <a href="#Rectangle.Union">func (r Rectangle) Union(s Rectangle) Rectangle</a>
</li>
<li><a href="#Uniform">type Uniform</a></li>
<li> <a href="#NewUniform">func NewUniform(c color.Color) *Uniform</a>
</li>
<li> <a href="#Uniform.At">func (c *Uniform) At(x, y int) color.Color</a>
</li>
<li> <a href="#Uniform.Bounds">func (c *Uniform) Bounds() Rectangle</a>
</li>
<li> <a href="#Uniform.ColorModel">func (c *Uniform) ColorModel() color.Model</a>
</li>
<li> <a href="#Uniform.Convert">func (c *Uniform) Convert(color.Color) color.Color</a>
</li>
<li> <a href="#Uniform.Opaque">func (c *Uniform) Opaque() bool</a>
</li>
<li> <a href="#Uniform.RGBA">func (c *Uniform) RGBA() (r, g, b, a uint32)</a>
</li>
<li> <a href="#Uniform.RGBA64At">func (c *Uniform) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li><a href="#YCbCr">type YCbCr</a></li>
<li> <a href="#NewYCbCr">func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr</a>
</li>
<li> <a href="#YCbCr.At">func (p *YCbCr) At(x, y int) color.Color</a>
</li>
<li> <a href="#YCbCr.Bounds">func (p *YCbCr) Bounds() Rectangle</a>
</li>
<li> <a href="#YCbCr.COffset">func (p *YCbCr) COffset(x, y int) int</a>
</li>
<li> <a href="#YCbCr.ColorModel">func (p *YCbCr) ColorModel() color.Model</a>
</li>
<li> <a href="#YCbCr.Opaque">func (p *YCbCr) Opaque() bool</a>
</li>
<li> <a href="#YCbCr.RGBA64At">func (p *YCbCr) RGBA64At(x, y int) color.RGBA64</a>
</li>
<li> <a href="#YCbCr.SubImage">func (p *YCbCr) SubImage(r Rectangle) Image</a>
</li>
<li> <a href="#YCbCr.YCbCrAt">func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr</a>
</li>
<li> <a href="#YCbCr.YOffset">func (p *YCbCr) YOffset(x, y int) int</a>
</li>
<li><a href="#YCbCrSubsampleRatio">type YCbCrSubsampleRatio</a></li>
<li> <a href="#YCbCrSubsampleRatio.String">func (s YCbCrSubsampleRatio) String() string</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_">Package</a></dd> <dd><a class="exampleLink" href="#example__decodeConfig">Package (DecodeConfig)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>format.go</span> <span>geom.go</span> <span>image.go</span> <span>names.go</span> <span>ycbcr.go</span>  </p>   <h2 id="pkg-variables">Variables</h2> <pre data-language="go">var (
    // Black is an opaque black uniform image.
    Black = NewUniform(color.Black)
    // White is an opaque white uniform image.
    White = NewUniform(color.White)
    // Transparent is a fully transparent uniform image.
    Transparent = NewUniform(color.Transparent)
    // Opaque is a fully opaque uniform image.
    Opaque = NewUniform(color.Opaque)
)</pre> <p>ErrFormat indicates that decoding encountered an unknown format. </p>
<pre data-language="go">var ErrFormat = errors.New("image: unknown format")</pre> <h2 id="RegisterFormat">func <span>RegisterFormat</span>  </h2> <pre data-language="go">func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))</pre> <p>RegisterFormat registers an image format for use by Decode. Name is the name of the format, like "jpeg" or "png". Magic is the magic prefix that identifies the format's encoding. The magic string can contain "?" wildcards that each match any one byte. Decode is the function that decodes the encoded image. DecodeConfig is the function that decodes just its configuration. </p>
<h2 id="Alpha">type <span>Alpha</span>  </h2> <p>Alpha is an in-memory image whose At method returns color.Alpha values. </p>
<pre data-language="go">type Alpha struct {
    // Pix holds the image's pixels, as alpha values. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewAlpha">func <span>NewAlpha</span>  </h3> <pre data-language="go">func NewAlpha(r Rectangle) *Alpha</pre> <p>NewAlpha returns a new Alpha image with the given bounds. </p>
<h3 id="Alpha.AlphaAt">func (*Alpha) <span>AlphaAt</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *Alpha) AlphaAt(x, y int) color.Alpha</pre> <h3 id="Alpha.At">func (*Alpha) <span>At</span>  </h3> <pre data-language="go">func (p *Alpha) At(x, y int) color.Color</pre> <h3 id="Alpha.Bounds">func (*Alpha) <span>Bounds</span>  </h3> <pre data-language="go">func (p *Alpha) Bounds() Rectangle</pre> <h3 id="Alpha.ColorModel">func (*Alpha) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *Alpha) ColorModel() color.Model</pre> <h3 id="Alpha.Opaque">func (*Alpha) <span>Opaque</span>  </h3> <pre data-language="go">func (p *Alpha) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Alpha.PixOffset">func (*Alpha) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *Alpha) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="Alpha.RGBA64At">func (*Alpha) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Alpha) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="Alpha.Set">func (*Alpha) <span>Set</span>  </h3> <pre data-language="go">func (p *Alpha) Set(x, y int, c color.Color)</pre> <h3 id="Alpha.SetAlpha">func (*Alpha) <span>SetAlpha</span>  </h3> <pre data-language="go">func (p *Alpha) SetAlpha(x, y int, c color.Alpha)</pre> <h3 id="Alpha.SetRGBA64">func (*Alpha) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Alpha) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="Alpha.SubImage">func (*Alpha) <span>SubImage</span>  </h3> <pre data-language="go">func (p *Alpha) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="Alpha16">type <span>Alpha16</span>  </h2> <p>Alpha16 is an in-memory image whose At method returns color.Alpha16 values. </p>
<pre data-language="go">type Alpha16 struct {
    // Pix holds the image's pixels, as alpha values in big-endian format. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewAlpha16">func <span>NewAlpha16</span>  </h3> <pre data-language="go">func NewAlpha16(r Rectangle) *Alpha16</pre> <p>NewAlpha16 returns a new Alpha16 image with the given bounds. </p>
<h3 id="Alpha16.Alpha16At">func (*Alpha16) <span>Alpha16At</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *Alpha16) Alpha16At(x, y int) color.Alpha16</pre> <h3 id="Alpha16.At">func (*Alpha16) <span>At</span>  </h3> <pre data-language="go">func (p *Alpha16) At(x, y int) color.Color</pre> <h3 id="Alpha16.Bounds">func (*Alpha16) <span>Bounds</span>  </h3> <pre data-language="go">func (p *Alpha16) Bounds() Rectangle</pre> <h3 id="Alpha16.ColorModel">func (*Alpha16) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *Alpha16) ColorModel() color.Model</pre> <h3 id="Alpha16.Opaque">func (*Alpha16) <span>Opaque</span>  </h3> <pre data-language="go">func (p *Alpha16) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Alpha16.PixOffset">func (*Alpha16) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *Alpha16) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="Alpha16.RGBA64At">func (*Alpha16) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Alpha16) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="Alpha16.Set">func (*Alpha16) <span>Set</span>  </h3> <pre data-language="go">func (p *Alpha16) Set(x, y int, c color.Color)</pre> <h3 id="Alpha16.SetAlpha16">func (*Alpha16) <span>SetAlpha16</span>  </h3> <pre data-language="go">func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)</pre> <h3 id="Alpha16.SetRGBA64">func (*Alpha16) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Alpha16) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="Alpha16.SubImage">func (*Alpha16) <span>SubImage</span>  </h3> <pre data-language="go">func (p *Alpha16) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="CMYK">type <span>CMYK</span>  <span title="Added in Go 1.5">1.5</span> </h2> <p>CMYK is an in-memory image whose At method returns color.CMYK values. </p>
<pre data-language="go">type CMYK struct {
    // Pix holds the image's pixels, in C, M, Y, K order. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewCMYK">func <span>NewCMYK</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func NewCMYK(r Rectangle) *CMYK</pre> <p>NewCMYK returns a new CMYK image with the given bounds. </p>
<h3 id="CMYK.At">func (*CMYK) <span>At</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) At(x, y int) color.Color</pre> <h3 id="CMYK.Bounds">func (*CMYK) <span>Bounds</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) Bounds() Rectangle</pre> <h3 id="CMYK.CMYKAt">func (*CMYK) <span>CMYKAt</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) CMYKAt(x, y int) color.CMYK</pre> <h3 id="CMYK.ColorModel">func (*CMYK) <span>ColorModel</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) ColorModel() color.Model</pre> <h3 id="CMYK.Opaque">func (*CMYK) <span>Opaque</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="CMYK.PixOffset">func (*CMYK) <span>PixOffset</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="CMYK.RGBA64At">func (*CMYK) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *CMYK) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="CMYK.Set">func (*CMYK) <span>Set</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) Set(x, y int, c color.Color)</pre> <h3 id="CMYK.SetCMYK">func (*CMYK) <span>SetCMYK</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) SetCMYK(x, y int, c color.CMYK)</pre> <h3 id="CMYK.SetRGBA64">func (*CMYK) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *CMYK) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="CMYK.SubImage">func (*CMYK) <span>SubImage</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (p *CMYK) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="Config">type <span>Config</span>  </h2> <p>Config holds an image's color model and dimensions. </p>
<pre data-language="go">type Config struct {
    ColorModel    color.Model
    Width, Height int
}
</pre> <h3 id="DecodeConfig">func <span>DecodeConfig</span>  </h3> <pre data-language="go">func DecodeConfig(r io.Reader) (Config, string, error)</pre> <p>DecodeConfig decodes the color model and dimensions of an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec-specific package. </p>
<h2 id="Gray">type <span>Gray</span>  </h2> <p>Gray is an in-memory image whose At method returns color.Gray values. </p>
<pre data-language="go">type Gray struct {
    // Pix holds the image's pixels, as gray values. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewGray">func <span>NewGray</span>  </h3> <pre data-language="go">func NewGray(r Rectangle) *Gray</pre> <p>NewGray returns a new Gray image with the given bounds. </p>
<h3 id="Gray.At">func (*Gray) <span>At</span>  </h3> <pre data-language="go">func (p *Gray) At(x, y int) color.Color</pre> <h3 id="Gray.Bounds">func (*Gray) <span>Bounds</span>  </h3> <pre data-language="go">func (p *Gray) Bounds() Rectangle</pre> <h3 id="Gray.ColorModel">func (*Gray) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *Gray) ColorModel() color.Model</pre> <h3 id="Gray.GrayAt">func (*Gray) <span>GrayAt</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *Gray) GrayAt(x, y int) color.Gray</pre> <h3 id="Gray.Opaque">func (*Gray) <span>Opaque</span>  </h3> <pre data-language="go">func (p *Gray) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Gray.PixOffset">func (*Gray) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *Gray) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="Gray.RGBA64At">func (*Gray) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Gray) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="Gray.Set">func (*Gray) <span>Set</span>  </h3> <pre data-language="go">func (p *Gray) Set(x, y int, c color.Color)</pre> <h3 id="Gray.SetGray">func (*Gray) <span>SetGray</span>  </h3> <pre data-language="go">func (p *Gray) SetGray(x, y int, c color.Gray)</pre> <h3 id="Gray.SetRGBA64">func (*Gray) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Gray) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="Gray.SubImage">func (*Gray) <span>SubImage</span>  </h3> <pre data-language="go">func (p *Gray) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="Gray16">type <span>Gray16</span>  </h2> <p>Gray16 is an in-memory image whose At method returns color.Gray16 values. </p>
<pre data-language="go">type Gray16 struct {
    // Pix holds the image's pixels, as gray values in big-endian format. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewGray16">func <span>NewGray16</span>  </h3> <pre data-language="go">func NewGray16(r Rectangle) *Gray16</pre> <p>NewGray16 returns a new Gray16 image with the given bounds. </p>
<h3 id="Gray16.At">func (*Gray16) <span>At</span>  </h3> <pre data-language="go">func (p *Gray16) At(x, y int) color.Color</pre> <h3 id="Gray16.Bounds">func (*Gray16) <span>Bounds</span>  </h3> <pre data-language="go">func (p *Gray16) Bounds() Rectangle</pre> <h3 id="Gray16.ColorModel">func (*Gray16) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *Gray16) ColorModel() color.Model</pre> <h3 id="Gray16.Gray16At">func (*Gray16) <span>Gray16At</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *Gray16) Gray16At(x, y int) color.Gray16</pre> <h3 id="Gray16.Opaque">func (*Gray16) <span>Opaque</span>  </h3> <pre data-language="go">func (p *Gray16) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Gray16.PixOffset">func (*Gray16) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *Gray16) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="Gray16.RGBA64At">func (*Gray16) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Gray16) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="Gray16.Set">func (*Gray16) <span>Set</span>  </h3> <pre data-language="go">func (p *Gray16) Set(x, y int, c color.Color)</pre> <h3 id="Gray16.SetGray16">func (*Gray16) <span>SetGray16</span>  </h3> <pre data-language="go">func (p *Gray16) SetGray16(x, y int, c color.Gray16)</pre> <h3 id="Gray16.SetRGBA64">func (*Gray16) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Gray16) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="Gray16.SubImage">func (*Gray16) <span>SubImage</span>  </h3> <pre data-language="go">func (p *Gray16) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="Image">type <span>Image</span>  </h2> <p>Image is a finite rectangular grid of color.Color values taken from a color model. </p>
<pre data-language="go">type Image interface {
    // ColorModel returns the Image's color model.
    ColorModel() color.Model
    // Bounds returns the domain for which At can return non-zero color.
    // The bounds do not necessarily contain the point (0, 0).
    Bounds() Rectangle
    // At returns the color of the pixel at (x, y).
    // At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.
    // At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.
    At(x, y int) color.Color
}</pre> <h3 id="Decode">func <span>Decode</span>  </h3> <pre data-language="go">func Decode(r io.Reader) (Image, string, error)</pre> <p>Decode decodes an image that has been encoded in a registered format. The string returned is the format name used during format registration. Format registration is typically done by an init function in the codec- specific package. </p>
<h2 id="NRGBA">type <span>NRGBA</span>  </h2> <p>NRGBA is an in-memory image whose At method returns color.NRGBA values. </p>
<pre data-language="go">type NRGBA struct {
    // Pix holds the image's pixels, in R, G, B, A order. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewNRGBA">func <span>NewNRGBA</span>  </h3> <pre data-language="go">func NewNRGBA(r Rectangle) *NRGBA</pre> <p>NewNRGBA returns a new NRGBA image with the given bounds. </p>
<h3 id="NRGBA.At">func (*NRGBA) <span>At</span>  </h3> <pre data-language="go">func (p *NRGBA) At(x, y int) color.Color</pre> <h3 id="NRGBA.Bounds">func (*NRGBA) <span>Bounds</span>  </h3> <pre data-language="go">func (p *NRGBA) Bounds() Rectangle</pre> <h3 id="NRGBA.ColorModel">func (*NRGBA) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *NRGBA) ColorModel() color.Model</pre> <h3 id="NRGBA.NRGBAAt">func (*NRGBA) <span>NRGBAAt</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA</pre> <h3 id="NRGBA.Opaque">func (*NRGBA) <span>Opaque</span>  </h3> <pre data-language="go">func (p *NRGBA) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="NRGBA.PixOffset">func (*NRGBA) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *NRGBA) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="NRGBA.RGBA64At">func (*NRGBA) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *NRGBA) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="NRGBA.Set">func (*NRGBA) <span>Set</span>  </h3> <pre data-language="go">func (p *NRGBA) Set(x, y int, c color.Color)</pre> <h3 id="NRGBA.SetNRGBA">func (*NRGBA) <span>SetNRGBA</span>  </h3> <pre data-language="go">func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)</pre> <h3 id="NRGBA.SetRGBA64">func (*NRGBA) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *NRGBA) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="NRGBA.SubImage">func (*NRGBA) <span>SubImage</span>  </h3> <pre data-language="go">func (p *NRGBA) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="NRGBA64">type <span>NRGBA64</span>  </h2> <p>NRGBA64 is an in-memory image whose At method returns color.NRGBA64 values. </p>
<pre data-language="go">type NRGBA64 struct {
    // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewNRGBA64">func <span>NewNRGBA64</span>  </h3> <pre data-language="go">func NewNRGBA64(r Rectangle) *NRGBA64</pre> <p>NewNRGBA64 returns a new NRGBA64 image with the given bounds. </p>
<h3 id="NRGBA64.At">func (*NRGBA64) <span>At</span>  </h3> <pre data-language="go">func (p *NRGBA64) At(x, y int) color.Color</pre> <h3 id="NRGBA64.Bounds">func (*NRGBA64) <span>Bounds</span>  </h3> <pre data-language="go">func (p *NRGBA64) Bounds() Rectangle</pre> <h3 id="NRGBA64.ColorModel">func (*NRGBA64) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *NRGBA64) ColorModel() color.Model</pre> <h3 id="NRGBA64.NRGBA64At">func (*NRGBA64) <span>NRGBA64At</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64</pre> <h3 id="NRGBA64.Opaque">func (*NRGBA64) <span>Opaque</span>  </h3> <pre data-language="go">func (p *NRGBA64) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="NRGBA64.PixOffset">func (*NRGBA64) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *NRGBA64) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="NRGBA64.RGBA64At">func (*NRGBA64) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *NRGBA64) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="NRGBA64.Set">func (*NRGBA64) <span>Set</span>  </h3> <pre data-language="go">func (p *NRGBA64) Set(x, y int, c color.Color)</pre> <h3 id="NRGBA64.SetNRGBA64">func (*NRGBA64) <span>SetNRGBA64</span>  </h3> <pre data-language="go">func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)</pre> <h3 id="NRGBA64.SetRGBA64">func (*NRGBA64) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *NRGBA64) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="NRGBA64.SubImage">func (*NRGBA64) <span>SubImage</span>  </h3> <pre data-language="go">func (p *NRGBA64) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="NYCbCrA">type <span>NYCbCrA</span>  <span title="Added in Go 1.6">1.6</span> </h2> <p>NYCbCrA is an in-memory image of non-alpha-premultiplied Y'CbCr-with-alpha colors. A and AStride are analogous to the Y and YStride fields of the embedded YCbCr. </p>
<pre data-language="go">type NYCbCrA struct {
    YCbCr
    A       []uint8
    AStride int
}
</pre> <h3 id="NewNYCbCrA">func <span>NewNYCbCrA</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA</pre> <p>NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample ratio. </p>
<h3 id="NYCbCrA.AOffset">func (*NYCbCrA) <span>AOffset</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) AOffset(x, y int) int</pre> <p>AOffset returns the index of the first element of A that corresponds to the pixel at (x, y). </p>
<h3 id="NYCbCrA.At">func (*NYCbCrA) <span>At</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) At(x, y int) color.Color</pre> <h3 id="NYCbCrA.ColorModel">func (*NYCbCrA) <span>ColorModel</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) ColorModel() color.Model</pre> <h3 id="NYCbCrA.NYCbCrAAt">func (*NYCbCrA) <span>NYCbCrAAt</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA</pre> <h3 id="NYCbCrA.Opaque">func (*NYCbCrA) <span>Opaque</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="NYCbCrA.RGBA64At">func (*NYCbCrA) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *NYCbCrA) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="NYCbCrA.SubImage">func (*NYCbCrA) <span>SubImage</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (p *NYCbCrA) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="Paletted">type <span>Paletted</span>  </h2> <p>Paletted is an in-memory image of uint8 indices into a given palette. </p>
<pre data-language="go">type Paletted struct {
    // Pix holds the image's pixels, as palette indices. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
    // Palette is the image's palette.
    Palette color.Palette
}
</pre> <h3 id="NewPaletted">func <span>NewPaletted</span>  </h3> <pre data-language="go">func NewPaletted(r Rectangle, p color.Palette) *Paletted</pre> <p>NewPaletted returns a new Paletted image with the given width, height and palette. </p>
<h3 id="Paletted.At">func (*Paletted) <span>At</span>  </h3> <pre data-language="go">func (p *Paletted) At(x, y int) color.Color</pre> <h3 id="Paletted.Bounds">func (*Paletted) <span>Bounds</span>  </h3> <pre data-language="go">func (p *Paletted) Bounds() Rectangle</pre> <h3 id="Paletted.ColorIndexAt">func (*Paletted) <span>ColorIndexAt</span>  </h3> <pre data-language="go">func (p *Paletted) ColorIndexAt(x, y int) uint8</pre> <h3 id="Paletted.ColorModel">func (*Paletted) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *Paletted) ColorModel() color.Model</pre> <h3 id="Paletted.Opaque">func (*Paletted) <span>Opaque</span>  </h3> <pre data-language="go">func (p *Paletted) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Paletted.PixOffset">func (*Paletted) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *Paletted) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="Paletted.RGBA64At">func (*Paletted) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Paletted) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="Paletted.Set">func (*Paletted) <span>Set</span>  </h3> <pre data-language="go">func (p *Paletted) Set(x, y int, c color.Color)</pre> <h3 id="Paletted.SetColorIndex">func (*Paletted) <span>SetColorIndex</span>  </h3> <pre data-language="go">func (p *Paletted) SetColorIndex(x, y int, index uint8)</pre> <h3 id="Paletted.SetRGBA64">func (*Paletted) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *Paletted) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="Paletted.SubImage">func (*Paletted) <span>SubImage</span>  </h3> <pre data-language="go">func (p *Paletted) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="PalettedImage">type <span>PalettedImage</span>  </h2> <p>PalettedImage is an image whose colors may come from a limited palette. If m is a PalettedImage and m.ColorModel() returns a color.Palette p, then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m's color model is not a color.Palette, then ColorIndexAt's behavior is undefined. </p>
<pre data-language="go">type PalettedImage interface {
    // ColorIndexAt returns the palette index of the pixel at (x, y).
    ColorIndexAt(x, y int) uint8
    Image
}</pre> <h2 id="Point">type <span>Point</span>  </h2> <p>A Point is an X, Y coordinate pair. The axes increase right and down. </p>
<pre data-language="go">type Point struct {
    X, Y int
}
</pre> <p>ZP is the zero Point. </p>
<p>Deprecated: Use a literal image.Point{} instead. </p>
<pre data-language="go">var ZP Point</pre> <h3 id="Pt">func <span>Pt</span>  </h3> <pre data-language="go">func Pt(X, Y int) Point</pre> <p>Pt is shorthand for Point{X, Y}. </p>
<h3 id="Point.Add">func (Point) <span>Add</span>  </h3> <pre data-language="go">func (p Point) Add(q Point) Point</pre> <p>Add returns the vector p+q. </p>
<h3 id="Point.Div">func (Point) <span>Div</span>  </h3> <pre data-language="go">func (p Point) Div(k int) Point</pre> <p>Div returns the vector p/k. </p>
<h3 id="Point.Eq">func (Point) <span>Eq</span>  </h3> <pre data-language="go">func (p Point) Eq(q Point) bool</pre> <p>Eq reports whether p and q are equal. </p>
<h3 id="Point.In">func (Point) <span>In</span>  </h3> <pre data-language="go">func (p Point) In(r Rectangle) bool</pre> <p>In reports whether p is in r. </p>
<h3 id="Point.Mod">func (Point) <span>Mod</span>  </h3> <pre data-language="go">func (p Point) Mod(r Rectangle) Point</pre> <p>Mod returns the point q in r such that p.X-q.X is a multiple of r's width and p.Y-q.Y is a multiple of r's height. </p>
<h3 id="Point.Mul">func (Point) <span>Mul</span>  </h3> <pre data-language="go">func (p Point) Mul(k int) Point</pre> <p>Mul returns the vector p*k. </p>
<h3 id="Point.String">func (Point) <span>String</span>  </h3> <pre data-language="go">func (p Point) String() string</pre> <p>String returns a string representation of p like "(3,4)". </p>
<h3 id="Point.Sub">func (Point) <span>Sub</span>  </h3> <pre data-language="go">func (p Point) Sub(q Point) Point</pre> <p>Sub returns the vector p-q. </p>
<h2 id="RGBA">type <span>RGBA</span>  </h2> <p>RGBA is an in-memory image whose At method returns color.RGBA values. </p>
<pre data-language="go">type RGBA struct {
    // Pix holds the image's pixels, in R, G, B, A order. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewRGBA">func <span>NewRGBA</span>  </h3> <pre data-language="go">func NewRGBA(r Rectangle) *RGBA</pre> <p>NewRGBA returns a new RGBA image with the given bounds. </p>
<h3 id="RGBA.At">func (*RGBA) <span>At</span>  </h3> <pre data-language="go">func (p *RGBA) At(x, y int) color.Color</pre> <h3 id="RGBA.Bounds">func (*RGBA) <span>Bounds</span>  </h3> <pre data-language="go">func (p *RGBA) Bounds() Rectangle</pre> <h3 id="RGBA.ColorModel">func (*RGBA) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *RGBA) ColorModel() color.Model</pre> <h3 id="RGBA.Opaque">func (*RGBA) <span>Opaque</span>  </h3> <pre data-language="go">func (p *RGBA) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="RGBA.PixOffset">func (*RGBA) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *RGBA) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="RGBA.RGBA64At">func (*RGBA) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *RGBA) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="RGBA.RGBAAt">func (*RGBA) <span>RGBAAt</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *RGBA) RGBAAt(x, y int) color.RGBA</pre> <h3 id="RGBA.Set">func (*RGBA) <span>Set</span>  </h3> <pre data-language="go">func (p *RGBA) Set(x, y int, c color.Color)</pre> <h3 id="RGBA.SetRGBA">func (*RGBA) <span>SetRGBA</span>  </h3> <pre data-language="go">func (p *RGBA) SetRGBA(x, y int, c color.RGBA)</pre> <h3 id="RGBA.SetRGBA64">func (*RGBA) <span>SetRGBA64</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *RGBA) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="RGBA.SubImage">func (*RGBA) <span>SubImage</span>  </h3> <pre data-language="go">func (p *RGBA) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="RGBA64">type <span>RGBA64</span>  </h2> <p>RGBA64 is an in-memory image whose At method returns color.RGBA64 values. </p>
<pre data-language="go">type RGBA64 struct {
    // Pix holds the image's pixels, in R, G, B, A order and big-endian format. The pixel at
    // (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].
    Pix []uint8
    // Stride is the Pix stride (in bytes) between vertically adjacent pixels.
    Stride int
    // Rect is the image's bounds.
    Rect Rectangle
}
</pre> <h3 id="NewRGBA64">func <span>NewRGBA64</span>  </h3> <pre data-language="go">func NewRGBA64(r Rectangle) *RGBA64</pre> <p>NewRGBA64 returns a new RGBA64 image with the given bounds. </p>
<h3 id="RGBA64.At">func (*RGBA64) <span>At</span>  </h3> <pre data-language="go">func (p *RGBA64) At(x, y int) color.Color</pre> <h3 id="RGBA64.Bounds">func (*RGBA64) <span>Bounds</span>  </h3> <pre data-language="go">func (p *RGBA64) Bounds() Rectangle</pre> <h3 id="RGBA64.ColorModel">func (*RGBA64) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *RGBA64) ColorModel() color.Model</pre> <h3 id="RGBA64.Opaque">func (*RGBA64) <span>Opaque</span>  </h3> <pre data-language="go">func (p *RGBA64) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="RGBA64.PixOffset">func (*RGBA64) <span>PixOffset</span>  </h3> <pre data-language="go">func (p *RGBA64) PixOffset(x, y int) int</pre> <p>PixOffset returns the index of the first element of Pix that corresponds to the pixel at (x, y). </p>
<h3 id="RGBA64.RGBA64At">func (*RGBA64) <span>RGBA64At</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *RGBA64) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="RGBA64.Set">func (*RGBA64) <span>Set</span>  </h3> <pre data-language="go">func (p *RGBA64) Set(x, y int, c color.Color)</pre> <h3 id="RGBA64.SetRGBA64">func (*RGBA64) <span>SetRGBA64</span>  </h3> <pre data-language="go">func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)</pre> <h3 id="RGBA64.SubImage">func (*RGBA64) <span>SubImage</span>  </h3> <pre data-language="go">func (p *RGBA64) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h2 id="RGBA64Image">type <span>RGBA64Image</span>  <span title="Added in Go 1.17">1.17</span> </h2> <p>RGBA64Image is an Image whose pixels can be converted directly to a color.RGBA64. </p>
<pre data-language="go">type RGBA64Image interface {
    // RGBA64At returns the RGBA64 color of the pixel at (x, y). It is
    // equivalent to calling At(x, y).RGBA() and converting the resulting
    // 32-bit return values to a color.RGBA64, but it can avoid allocations
    // from converting concrete color types to the color.Color interface type.
    RGBA64At(x, y int) color.RGBA64
    Image
}</pre> <h2 id="Rectangle">type <span>Rectangle</span>  </h2> <p>A Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y. It is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always well-formed. A rectangle's methods always return well-formed outputs for well-formed inputs. </p>
<p>A Rectangle is also an Image whose bounds are the rectangle itself. At returns color.Opaque for points in the rectangle and color.Transparent otherwise. </p>
<pre data-language="go">type Rectangle struct {
    Min, Max Point
}
</pre> <p>ZR is the zero Rectangle. </p>
<p>Deprecated: Use a literal image.Rectangle{} instead. </p>
<pre data-language="go">var ZR Rectangle</pre> <h3 id="Rect">func <span>Rect</span>  </h3> <pre data-language="go">func Rect(x0, y0, x1, y1 int) Rectangle</pre> <p>Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. </p>
<h3 id="Rectangle.Add">func (Rectangle) <span>Add</span>  </h3> <pre data-language="go">func (r Rectangle) Add(p Point) Rectangle</pre> <p>Add returns the rectangle r translated by p. </p>
<h3 id="Rectangle.At">func (Rectangle) <span>At</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r Rectangle) At(x, y int) color.Color</pre> <p>At implements the Image interface. </p>
<h3 id="Rectangle.Bounds">func (Rectangle) <span>Bounds</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r Rectangle) Bounds() Rectangle</pre> <p>Bounds implements the Image interface. </p>
<h3 id="Rectangle.Canon">func (Rectangle) <span>Canon</span>  </h3> <pre data-language="go">func (r Rectangle) Canon() Rectangle</pre> <p>Canon returns the canonical version of r. The returned rectangle has minimum and maximum coordinates swapped if necessary so that it is well-formed. </p>
<h3 id="Rectangle.ColorModel">func (Rectangle) <span>ColorModel</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r Rectangle) ColorModel() color.Model</pre> <p>ColorModel implements the Image interface. </p>
<h3 id="Rectangle.Dx">func (Rectangle) <span>Dx</span>  </h3> <pre data-language="go">func (r Rectangle) Dx() int</pre> <p>Dx returns r's width. </p>
<h3 id="Rectangle.Dy">func (Rectangle) <span>Dy</span>  </h3> <pre data-language="go">func (r Rectangle) Dy() int</pre> <p>Dy returns r's height. </p>
<h3 id="Rectangle.Empty">func (Rectangle) <span>Empty</span>  </h3> <pre data-language="go">func (r Rectangle) Empty() bool</pre> <p>Empty reports whether the rectangle contains no points. </p>
<h3 id="Rectangle.Eq">func (Rectangle) <span>Eq</span>  </h3> <pre data-language="go">func (r Rectangle) Eq(s Rectangle) bool</pre> <p>Eq reports whether r and s contain the same set of points. All empty rectangles are considered equal. </p>
<h3 id="Rectangle.In">func (Rectangle) <span>In</span>  </h3> <pre data-language="go">func (r Rectangle) In(s Rectangle) bool</pre> <p>In reports whether every point in r is in s. </p>
<h3 id="Rectangle.Inset">func (Rectangle) <span>Inset</span>  </h3> <pre data-language="go">func (r Rectangle) Inset(n int) Rectangle</pre> <p>Inset returns the rectangle r inset by n, which may be negative. If either of r's dimensions is less than 2*n then an empty rectangle near the center of r will be returned. </p>
<h3 id="Rectangle.Intersect">func (Rectangle) <span>Intersect</span>  </h3> <pre data-language="go">func (r Rectangle) Intersect(s Rectangle) Rectangle</pre> <p>Intersect returns the largest rectangle contained by both r and s. If the two rectangles do not overlap then the zero rectangle will be returned. </p>
<h3 id="Rectangle.Overlaps">func (Rectangle) <span>Overlaps</span>  </h3> <pre data-language="go">func (r Rectangle) Overlaps(s Rectangle) bool</pre> <p>Overlaps reports whether r and s have a non-empty intersection. </p>
<h3 id="Rectangle.RGBA64At">func (Rectangle) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (r Rectangle) RGBA64At(x, y int) color.RGBA64</pre> <p>RGBA64At implements the RGBA64Image interface. </p>
<h3 id="Rectangle.Size">func (Rectangle) <span>Size</span>  </h3> <pre data-language="go">func (r Rectangle) Size() Point</pre> <p>Size returns r's width and height. </p>
<h3 id="Rectangle.String">func (Rectangle) <span>String</span>  </h3> <pre data-language="go">func (r Rectangle) String() string</pre> <p>String returns a string representation of r like "(3,4)-(6,5)". </p>
<h3 id="Rectangle.Sub">func (Rectangle) <span>Sub</span>  </h3> <pre data-language="go">func (r Rectangle) Sub(p Point) Rectangle</pre> <p>Sub returns the rectangle r translated by -p. </p>
<h3 id="Rectangle.Union">func (Rectangle) <span>Union</span>  </h3> <pre data-language="go">func (r Rectangle) Union(s Rectangle) Rectangle</pre> <p>Union returns the smallest rectangle that contains both r and s. </p>
<h2 id="Uniform">type <span>Uniform</span>  </h2> <p>Uniform is an infinite-sized Image of uniform color. It implements the color.Color, color.Model, and Image interfaces. </p>
<pre data-language="go">type Uniform struct {
    C color.Color
}
</pre> <h3 id="NewUniform">func <span>NewUniform</span>  </h3> <pre data-language="go">func NewUniform(c color.Color) *Uniform</pre> <p>NewUniform returns a new Uniform image of the given color. </p>
<h3 id="Uniform.At">func (*Uniform) <span>At</span>  </h3> <pre data-language="go">func (c *Uniform) At(x, y int) color.Color</pre> <h3 id="Uniform.Bounds">func (*Uniform) <span>Bounds</span>  </h3> <pre data-language="go">func (c *Uniform) Bounds() Rectangle</pre> <h3 id="Uniform.ColorModel">func (*Uniform) <span>ColorModel</span>  </h3> <pre data-language="go">func (c *Uniform) ColorModel() color.Model</pre> <h3 id="Uniform.Convert">func (*Uniform) <span>Convert</span>  </h3> <pre data-language="go">func (c *Uniform) Convert(color.Color) color.Color</pre> <h3 id="Uniform.Opaque">func (*Uniform) <span>Opaque</span>  </h3> <pre data-language="go">func (c *Uniform) Opaque() bool</pre> <p>Opaque scans the entire image and reports whether it is fully opaque. </p>
<h3 id="Uniform.RGBA">func (*Uniform) <span>RGBA</span>  </h3> <pre data-language="go">func (c *Uniform) RGBA() (r, g, b, a uint32)</pre> <h3 id="Uniform.RGBA64At">func (*Uniform) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (c *Uniform) RGBA64At(x, y int) color.RGBA64</pre> <h2 id="YCbCr">type <span>YCbCr</span>  </h2> <p>YCbCr is an in-memory image of Y'CbCr colors. There is one Y sample per pixel, but each Cb and Cr sample can span one or more pixels. YStride is the Y slice index delta between vertically adjacent pixels. CStride is the Cb and Cr slice index delta between vertically adjacent pixels that map to separate chroma samples. It is not an absolute requirement, but YStride and len(Y) are typically multiples of 8, and: </p>
<pre data-language="go">For 4:4:4, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/1.
For 4:2:2, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
For 4:2:0, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.
For 4:4:0, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
For 4:1:1, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.
For 4:1:0, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/8.
</pre> <pre data-language="go">type YCbCr struct {
    Y, Cb, Cr      []uint8
    YStride        int
    CStride        int
    SubsampleRatio YCbCrSubsampleRatio
    Rect           Rectangle
}
</pre> <h3 id="NewYCbCr">func <span>NewYCbCr</span>  </h3> <pre data-language="go">func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr</pre> <p>NewYCbCr returns a new YCbCr image with the given bounds and subsample ratio. </p>
<h3 id="YCbCr.At">func (*YCbCr) <span>At</span>  </h3> <pre data-language="go">func (p *YCbCr) At(x, y int) color.Color</pre> <h3 id="YCbCr.Bounds">func (*YCbCr) <span>Bounds</span>  </h3> <pre data-language="go">func (p *YCbCr) Bounds() Rectangle</pre> <h3 id="YCbCr.COffset">func (*YCbCr) <span>COffset</span>  </h3> <pre data-language="go">func (p *YCbCr) COffset(x, y int) int</pre> <p>COffset returns the index of the first element of Cb or Cr that corresponds to the pixel at (x, y). </p>
<h3 id="YCbCr.ColorModel">func (*YCbCr) <span>ColorModel</span>  </h3> <pre data-language="go">func (p *YCbCr) ColorModel() color.Model</pre> <h3 id="YCbCr.Opaque">func (*YCbCr) <span>Opaque</span>  </h3> <pre data-language="go">func (p *YCbCr) Opaque() bool</pre> <h3 id="YCbCr.RGBA64At">func (*YCbCr) <span>RGBA64At</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (p *YCbCr) RGBA64At(x, y int) color.RGBA64</pre> <h3 id="YCbCr.SubImage">func (*YCbCr) <span>SubImage</span>  </h3> <pre data-language="go">func (p *YCbCr) SubImage(r Rectangle) Image</pre> <p>SubImage returns an image representing the portion of the image p visible through r. The returned value shares pixels with the original image. </p>
<h3 id="YCbCr.YCbCrAt">func (*YCbCr) <span>YCbCrAt</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr</pre> <h3 id="YCbCr.YOffset">func (*YCbCr) <span>YOffset</span>  </h3> <pre data-language="go">func (p *YCbCr) YOffset(x, y int) int</pre> <p>YOffset returns the index of the first element of Y that corresponds to the pixel at (x, y). </p>
<h2 id="YCbCrSubsampleRatio">type <span>YCbCrSubsampleRatio</span>  </h2> <p>YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image. </p>
<pre data-language="go">type YCbCrSubsampleRatio int</pre> <pre data-language="go">const (
    YCbCrSubsampleRatio444 YCbCrSubsampleRatio = iota
    YCbCrSubsampleRatio422
    YCbCrSubsampleRatio420
    YCbCrSubsampleRatio440
    YCbCrSubsampleRatio411
    YCbCrSubsampleRatio410
)</pre> <h3 id="YCbCrSubsampleRatio.String">func (YCbCrSubsampleRatio) <span>String</span>  </h3> <pre data-language="go">func (s YCbCrSubsampleRatio) String() string</pre> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../index.html">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="color/index.html">color</a> </td> <td class="pkg-synopsis"> Package color implements a basic color library. </td> </tr> <tr> <td class="pkg-name"> <a href="color/palette/index.html">palette</a> </td> <td class="pkg-synopsis"> Package palette provides standard color palettes. </td> </tr> <tr> <td class="pkg-name"> <a href="draw/index.html">draw</a> </td> <td class="pkg-synopsis"> Package draw provides image composition functions. </td> </tr> <tr> <td class="pkg-name"> <a href="gif/index.html">gif</a> </td> <td class="pkg-synopsis"> Package gif implements a GIF image decoder and encoder. </td> </tr> <tr> <td class="pkg-name"> <a href="jpeg/index.html">jpeg</a> </td> <td class="pkg-synopsis"> Package jpeg implements a JPEG image decoder and encoder. </td> </tr> <tr> <td class="pkg-name"> <a href="png/index.html">png</a> </td> <td class="pkg-synopsis"> Package png implements a PNG image decoder and encoder. </td> </tr> </table> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/image/" class="_attribution-link">http://golang.org/pkg/image/</a>
  </p>
</div>
