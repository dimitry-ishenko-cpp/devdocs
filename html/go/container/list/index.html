<h1> Package list  </h1>     <ul id="short-nav">
<li><code>import "container/list"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package list implements a doubly linked list. </p>
<p>To iterate over a list (where l is a *List): </p>
<pre data-language="go">for e := l.Front(); e != nil; e = e.Next() {
	// do something with e.Value
}
</pre>    <h4 id="example_"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// Create a new list and put some numbers in it.
l := list.New()
e4 := l.PushBack(4)
e1 := l.PushFront(1)
l.InsertBefore(3, e4)
l.InsertAfter(2, e1)

// Iterate through list and print its contents.
for e := l.Front(); e != nil; e = e.Next() {
    fmt.Println(e.Value)
}

</pre> <p>Output:</p> <pre class="output" data-language="go">1
2
3
4
</pre>        <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#Element">type Element</a></li>
<li> <a href="#Element.Next">func (e *Element) Next() *Element</a>
</li>
<li> <a href="#Element.Prev">func (e *Element) Prev() *Element</a>
</li>
<li><a href="#List">type List</a></li>
<li> <a href="#New">func New() *List</a>
</li>
<li> <a href="#List.Back">func (l *List) Back() *Element</a>
</li>
<li> <a href="#List.Front">func (l *List) Front() *Element</a>
</li>
<li> <a href="#List.Init">func (l *List) Init() *List</a>
</li>
<li> <a href="#List.InsertAfter">func (l *List) InsertAfter(v any, mark *Element) *Element</a>
</li>
<li> <a href="#List.InsertBefore">func (l *List) InsertBefore(v any, mark *Element) *Element</a>
</li>
<li> <a href="#List.Len">func (l *List) Len() int</a>
</li>
<li> <a href="#List.MoveAfter">func (l *List) MoveAfter(e, mark *Element)</a>
</li>
<li> <a href="#List.MoveBefore">func (l *List) MoveBefore(e, mark *Element)</a>
</li>
<li> <a href="#List.MoveToBack">func (l *List) MoveToBack(e *Element)</a>
</li>
<li> <a href="#List.MoveToFront">func (l *List) MoveToFront(e *Element)</a>
</li>
<li> <a href="#List.PushBack">func (l *List) PushBack(v any) *Element</a>
</li>
<li> <a href="#List.PushBackList">func (l *List) PushBackList(other *List)</a>
</li>
<li> <a href="#List.PushFront">func (l *List) PushFront(v any) *Element</a>
</li>
<li> <a href="#List.PushFrontList">func (l *List) PushFrontList(other *List)</a>
</li>
<li> <a href="#List.Remove">func (l *List) Remove(e *Element) any</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_">Package</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>list.go</span>  </p>   <h2 id="Element">type <span>Element</span>  </h2> <p>Element is an element of a linked list. </p>
<pre data-language="go">type Element struct {

    // The value stored with this element.
    Value any
    // contains filtered or unexported fields
}
</pre> <h3 id="Element.Next">func (*Element) <span>Next</span>  </h3> <pre data-language="go">func (e *Element) Next() *Element</pre> <p>Next returns the next list element or nil. </p>
<h3 id="Element.Prev">func (*Element) <span>Prev</span>  </h3> <pre data-language="go">func (e *Element) Prev() *Element</pre> <p>Prev returns the previous list element or nil. </p>
<h2 id="List">type <span>List</span>  </h2> <p>List represents a doubly linked list. The zero value for List is an empty list ready to use. </p>
<pre data-language="go">type List struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="New">func <span>New</span>  </h3> <pre data-language="go">func New() *List</pre> <p>New returns an initialized list. </p>
<h3 id="List.Back">func (*List) <span>Back</span>  </h3> <pre data-language="go">func (l *List) Back() *Element</pre> <p>Back returns the last element of list l or nil if the list is empty. </p>
<h3 id="List.Front">func (*List) <span>Front</span>  </h3> <pre data-language="go">func (l *List) Front() *Element</pre> <p>Front returns the first element of list l or nil if the list is empty. </p>
<h3 id="List.Init">func (*List) <span>Init</span>  </h3> <pre data-language="go">func (l *List) Init() *List</pre> <p>Init initializes or clears list l. </p>
<h3 id="List.InsertAfter">func (*List) <span>InsertAfter</span>  </h3> <pre data-language="go">func (l *List) InsertAfter(v any, mark *Element) *Element</pre> <p>InsertAfter inserts a new element e with value v immediately after mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil. </p>
<h3 id="List.InsertBefore">func (*List) <span>InsertBefore</span>  </h3> <pre data-language="go">func (l *List) InsertBefore(v any, mark *Element) *Element</pre> <p>InsertBefore inserts a new element e with value v immediately before mark and returns e. If mark is not an element of l, the list is not modified. The mark must not be nil. </p>
<h3 id="List.Len">func (*List) <span>Len</span>  </h3> <pre data-language="go">func (l *List) Len() int</pre> <p>Len returns the number of elements of list l. The complexity is O(1). </p>
<h3 id="List.MoveAfter">func (*List) <span>MoveAfter</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (l *List) MoveAfter(e, mark *Element)</pre> <p>MoveAfter moves element e to its new position after mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil. </p>
<h3 id="List.MoveBefore">func (*List) <span>MoveBefore</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (l *List) MoveBefore(e, mark *Element)</pre> <p>MoveBefore moves element e to its new position before mark. If e or mark is not an element of l, or e == mark, the list is not modified. The element and mark must not be nil. </p>
<h3 id="List.MoveToBack">func (*List) <span>MoveToBack</span>  </h3> <pre data-language="go">func (l *List) MoveToBack(e *Element)</pre> <p>MoveToBack moves element e to the back of list l. If e is not an element of l, the list is not modified. The element must not be nil. </p>
<h3 id="List.MoveToFront">func (*List) <span>MoveToFront</span>  </h3> <pre data-language="go">func (l *List) MoveToFront(e *Element)</pre> <p>MoveToFront moves element e to the front of list l. If e is not an element of l, the list is not modified. The element must not be nil. </p>
<h3 id="List.PushBack">func (*List) <span>PushBack</span>  </h3> <pre data-language="go">func (l *List) PushBack(v any) *Element</pre> <p>PushBack inserts a new element e with value v at the back of list l and returns e. </p>
<h3 id="List.PushBackList">func (*List) <span>PushBackList</span>  </h3> <pre data-language="go">func (l *List) PushBackList(other *List)</pre> <p>PushBackList inserts a copy of another list at the back of list l. The lists l and other may be the same. They must not be nil. </p>
<h3 id="List.PushFront">func (*List) <span>PushFront</span>  </h3> <pre data-language="go">func (l *List) PushFront(v any) *Element</pre> <p>PushFront inserts a new element e with value v at the front of list l and returns e. </p>
<h3 id="List.PushFrontList">func (*List) <span>PushFrontList</span>  </h3> <pre data-language="go">func (l *List) PushFrontList(other *List)</pre> <p>PushFrontList inserts a copy of another list at the front of list l. The lists l and other may be the same. They must not be nil. </p>
<h3 id="List.Remove">func (*List) <span>Remove</span>  </h3> <pre data-language="go">func (l *List) Remove(e *Element) any</pre> <p>Remove removes e from l if e is an element of list l. It returns the element value e.Value. The element must not be nil. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/container/list/" class="_attribution-link">http://golang.org/pkg/container/list/</a>
  </p>
</div>
