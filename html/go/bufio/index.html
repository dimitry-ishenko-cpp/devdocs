<h1> Package bufio  </h1>     <ul id="short-nav">
<li><code>import "bufio"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#ScanBytes">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>
<li><a href="#ScanLines">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>
<li><a href="#ScanRunes">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>
<li><a href="#ScanWords">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</a></li>
<li><a href="#ReadWriter">type ReadWriter</a></li>
<li> <a href="#NewReadWriter">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(rd io.Reader) *Reader</a>
</li>
<li> <a href="#NewReaderSize">func NewReaderSize(rd io.Reader, size int) *Reader</a>
</li>
<li> <a href="#Reader.Buffered">func (b *Reader) Buffered() int</a>
</li>
<li> <a href="#Reader.Discard">func (b *Reader) Discard(n int) (discarded int, err error)</a>
</li>
<li> <a href="#Reader.Peek">func (b *Reader) Peek(n int) ([]byte, error)</a>
</li>
<li> <a href="#Reader.Read">func (b *Reader) Read(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadByte">func (b *Reader) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Reader.ReadBytes">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</a>
</li>
<li> <a href="#Reader.ReadLine">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</a>
</li>
<li> <a href="#Reader.ReadRune">func (b *Reader) ReadRune() (r rune, size int, err error)</a>
</li>
<li> <a href="#Reader.ReadSlice">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</a>
</li>
<li> <a href="#Reader.ReadString">func (b *Reader) ReadString(delim byte) (string, error)</a>
</li>
<li> <a href="#Reader.Reset">func (b *Reader) Reset(r io.Reader)</a>
</li>
<li> <a href="#Reader.Size">func (b *Reader) Size() int</a>
</li>
<li> <a href="#Reader.UnreadByte">func (b *Reader) UnreadByte() error</a>
</li>
<li> <a href="#Reader.UnreadRune">func (b *Reader) UnreadRune() error</a>
</li>
<li> <a href="#Reader.WriteTo">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Scanner">type Scanner</a></li>
<li> <a href="#NewScanner">func NewScanner(r io.Reader) *Scanner</a>
</li>
<li> <a href="#Scanner.Buffer">func (s *Scanner) Buffer(buf []byte, max int)</a>
</li>
<li> <a href="#Scanner.Bytes">func (s *Scanner) Bytes() []byte</a>
</li>
<li> <a href="#Scanner.Err">func (s *Scanner) Err() error</a>
</li>
<li> <a href="#Scanner.Scan">func (s *Scanner) Scan() bool</a>
</li>
<li> <a href="#Scanner.Split">func (s *Scanner) Split(split SplitFunc)</a>
</li>
<li> <a href="#Scanner.Text">func (s *Scanner) Text() string</a>
</li>
<li><a href="#SplitFunc">type SplitFunc</a></li>
<li><a href="#Writer">type Writer</a></li>
<li> <a href="#NewWriter">func NewWriter(w io.Writer) *Writer</a>
</li>
<li> <a href="#NewWriterSize">func NewWriterSize(w io.Writer, size int) *Writer</a>
</li>
<li> <a href="#Writer.Available">func (b *Writer) Available() int</a>
</li>
<li> <a href="#Writer.AvailableBuffer">func (b *Writer) AvailableBuffer() []byte</a>
</li>
<li> <a href="#Writer.Buffered">func (b *Writer) Buffered() int</a>
</li>
<li> <a href="#Writer.Flush">func (b *Writer) Flush() error</a>
</li>
<li> <a href="#Writer.ReadFrom">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</a>
</li>
<li> <a href="#Writer.Reset">func (b *Writer) Reset(w io.Writer)</a>
</li>
<li> <a href="#Writer.Size">func (b *Writer) Size() int</a>
</li>
<li> <a href="#Writer.Write">func (b *Writer) Write(p []byte) (nn int, err error)</a>
</li>
<li> <a href="#Writer.WriteByte">func (b *Writer) WriteByte(c byte) error</a>
</li>
<li> <a href="#Writer.WriteRune">func (b *Writer) WriteRune(r rune) (size int, err error)</a>
</li>
<li> <a href="#Writer.WriteString">func (b *Writer) WriteString(s string) (int, error)</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Scanner_Bytes">Scanner.Bytes</a></dd> <dd><a class="exampleLink" href="#example_Scanner_custom">Scanner (Custom)</a></dd> <dd><a class="exampleLink" href="#example_Scanner_earlyStop">Scanner (EarlyStop)</a></dd> <dd><a class="exampleLink" href="#example_Scanner_emptyFinalToken">Scanner (EmptyFinalToken)</a></dd> <dd><a class="exampleLink" href="#example_Scanner_lines">Scanner (Lines)</a></dd> <dd><a class="exampleLink" href="#example_Scanner_words">Scanner (Words)</a></dd> <dd><a class="exampleLink" href="#example_Writer">Writer</a></dd> <dd><a class="exampleLink" href="#example_Writer_AvailableBuffer">Writer.AvailableBuffer</a></dd> <dd><a class="exampleLink" href="#example_Writer_ReadFrom">Writer.ReadFrom</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>bufio.go</span> <span>scan.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <pre data-language="go">const (
    // MaxScanTokenSize is the maximum size used to buffer a token
    // unless the user provides an explicit buffer with [Scanner.Buffer].
    // The actual maximum token size may be smaller as the buffer
    // may need to include, for instance, a newline.
    MaxScanTokenSize = 64 * 1024
)</pre> <h2 id="pkg-variables">Variables</h2> <pre data-language="go">var (
    ErrInvalidUnreadByte = errors.New("bufio: invalid use of UnreadByte")
    ErrInvalidUnreadRune = errors.New("bufio: invalid use of UnreadRune")
    ErrBufferFull        = errors.New("bufio: buffer full")
    ErrNegativeCount     = errors.New("bufio: negative count")
)</pre> <p>Errors returned by Scanner. </p>
<pre data-language="go">var (
    ErrTooLong         = errors.New("bufio.Scanner: token too long")
    ErrNegativeAdvance = errors.New("bufio.Scanner: SplitFunc returns negative advance count")
    ErrAdvanceTooFar   = errors.New("bufio.Scanner: SplitFunc returns advance count beyond input")
    ErrBadReadCount    = errors.New("bufio.Scanner: Read returned impossible count")
)</pre> <p>ErrFinalToken is a special sentinel error value. It is intended to be returned by a Split function to indicate that the scanning should stop with no error. If the token being delivered with this error is not nil, the token is the last token. </p>
<p>The value is useful to stop processing early or when it is necessary to deliver a final empty token (which is different from a nil token). One could achieve the same behavior with a custom error value but providing one here is tidier. See the emptyFinalToken example for a use of this value. </p>
<pre data-language="go">var ErrFinalToken = errors.New("final token")</pre> <h2 id="ScanBytes">func <span>ScanBytes</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func ScanBytes(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p>ScanBytes is a split function for a <a href="#Scanner">Scanner</a> that returns each byte as a token. </p>
<h2 id="ScanLines">func <span>ScanLines</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func ScanLines(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p>ScanLines is a split function for a <a href="#Scanner">Scanner</a> that returns each line of text, stripped of any trailing end-of-line marker. The returned line may be empty. The end-of-line marker is one optional carriage return followed by one mandatory newline. In regular expression notation, it is `\r?\n`. The last non-empty line of input will be returned even if it has no newline. </p>
<h2 id="ScanRunes">func <span>ScanRunes</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func ScanRunes(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p>ScanRunes is a split function for a <a href="#Scanner">Scanner</a> that returns each UTF-8-encoded rune as a token. The sequence of runes returned is equivalent to that from a range loop over the input as a string, which means that erroneous UTF-8 encodings translate to U+FFFD = "\xef\xbf\xbd". Because of the Scan interface, this makes it impossible for the client to distinguish correctly encoded replacement runes from encoding errors. </p>
<h2 id="ScanWords">func <span>ScanWords</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func ScanWords(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <p>ScanWords is a split function for a <a href="#Scanner">Scanner</a> that returns each space-separated word of text, with surrounding spaces deleted. It will never return an empty string. The definition of space is set by unicode.IsSpace. </p>
<h2 id="ReadWriter">type <span>ReadWriter</span>  </h2> <p>ReadWriter stores pointers to a <a href="#Reader">Reader</a> and a <a href="#Writer">Writer</a>. It implements <span>io.ReadWriter</span>. </p>
<pre data-language="go">type ReadWriter struct {
    *Reader
    *Writer
}
</pre> <h3 id="NewReadWriter">func <span>NewReadWriter</span>  </h3> <pre data-language="go">func NewReadWriter(r *Reader, w *Writer) *ReadWriter</pre> <p>NewReadWriter allocates a new <a href="#ReadWriter">ReadWriter</a> that dispatches to r and w. </p>
<h2 id="Reader">type <span>Reader</span>  </h2> <p>Reader implements buffering for an io.Reader object. A new Reader is created by calling <a href="#NewReader">NewReader</a> or <a href="#NewReaderSize">NewReaderSize</a>; alternatively the zero value of a Reader may be used after calling [Reset] on it. </p>
<pre data-language="go">type Reader struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewReader">func <span>NewReader</span>  </h3> <pre data-language="go">func NewReader(rd io.Reader) *Reader</pre> <p>NewReader returns a new <a href="#Reader">Reader</a> whose buffer has the default size. </p>
<h3 id="NewReaderSize">func <span>NewReaderSize</span>  </h3> <pre data-language="go">func NewReaderSize(rd io.Reader, size int) *Reader</pre> <p>NewReaderSize returns a new <a href="#Reader">Reader</a> whose buffer has at least the specified size. If the argument io.Reader is already a <a href="#Reader">Reader</a> with large enough size, it returns the underlying <a href="#Reader">Reader</a>. </p>
<h3 id="Reader.Buffered">func (*Reader) <span>Buffered</span>  </h3> <pre data-language="go">func (b *Reader) Buffered() int</pre> <p>Buffered returns the number of bytes that can be read from the current buffer. </p>
<h3 id="Reader.Discard">func (*Reader) <span>Discard</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Reader) Discard(n int) (discarded int, err error)</pre> <p>Discard skips the next n bytes, returning the number of bytes discarded. </p>
<p>If Discard skips fewer than n bytes, it also returns an error. If 0 &lt;= n &lt;= b.Buffered(), Discard is guaranteed to succeed without reading from the underlying io.Reader. </p>
<h3 id="Reader.Peek">func (*Reader) <span>Peek</span>  </h3> <pre data-language="go">func (b *Reader) Peek(n int) ([]byte, error)</pre> <p>Peek returns the next n bytes without advancing the reader. The bytes stop being valid at the next read call. If necessary, Peek will read more bytes into the buffer in order to make n bytes available. If Peek returns fewer than n bytes, it also returns an error explaining why the read is short. The error is <a href="#ErrBufferFull">ErrBufferFull</a> if n is larger than b's buffer size. </p>
<p>Calling Peek prevents a <a href="#Reader.UnreadByte">Reader.UnreadByte</a> or <a href="#Reader.UnreadRune">Reader.UnreadRune</a> call from succeeding until the next read operation. </p>
<h3 id="Reader.Read">func (*Reader) <span>Read</span>  </h3> <pre data-language="go">func (b *Reader) Read(p []byte) (n int, err error)</pre> <p>Read reads data into p. It returns the number of bytes read into p. The bytes are taken from at most one Read on the underlying <a href="#Reader">Reader</a>, hence n may be less than len(p). To read exactly len(p) bytes, use io.ReadFull(b, p). If the underlying <a href="#Reader">Reader</a> can return a non-zero count with io.EOF, then this Read method can do so as well; see the <span>io.Reader</span> docs. </p>
<h3 id="Reader.ReadByte">func (*Reader) <span>ReadByte</span>  </h3> <pre data-language="go">func (b *Reader) ReadByte() (byte, error)</pre> <p>ReadByte reads and returns a single byte. If no byte is available, returns an error. </p>
<h3 id="Reader.ReadBytes">func (*Reader) <span>ReadBytes</span>  </h3> <pre data-language="go">func (b *Reader) ReadBytes(delim byte) ([]byte, error)</pre> <p>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadBytes returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. </p>
<h3 id="Reader.ReadLine">func (*Reader) <span>ReadLine</span>  </h3> <pre data-language="go">func (b *Reader) ReadLine() (line []byte, isPrefix bool, err error)</pre> <p>ReadLine is a low-level line-reading primitive. Most callers should use <a href="#Reader.ReadBytes">Reader.ReadBytes</a>('\n') or <a href="#Reader.ReadString">Reader.ReadString</a>('\n') instead or use a <a href="#Scanner">Scanner</a>. </p>
<p>ReadLine tries to return a single line, not including the end-of-line bytes. If the line was too long for the buffer then isPrefix is set and the beginning of the line is returned. The rest of the line will be returned from future calls. isPrefix will be false when returning the last fragment of the line. The returned buffer is only valid until the next call to ReadLine. ReadLine either returns a non-nil line or it returns an error, never both. </p>
<p>The text returned from ReadLine does not include the line end ("\r\n" or "\n"). No indication or error is given if the input ends without a final line end. Calling <a href="#Reader.UnreadByte">Reader.UnreadByte</a> after ReadLine will always unread the last byte read (possibly a character belonging to the line end) even if that byte is not part of the line returned by ReadLine. </p>
<h3 id="Reader.ReadRune">func (*Reader) <span>ReadRune</span>  </h3> <pre data-language="go">func (b *Reader) ReadRune() (r rune, size int, err error)</pre> <p>ReadRune reads a single UTF-8 encoded Unicode character and returns the rune and its size in bytes. If the encoded rune is invalid, it consumes one byte and returns unicode.ReplacementChar (U+FFFD) with a size of 1. </p>
<h3 id="Reader.ReadSlice">func (*Reader) <span>ReadSlice</span>  </h3> <pre data-language="go">func (b *Reader) ReadSlice(delim byte) (line []byte, err error)</pre> <p>ReadSlice reads until the first occurrence of delim in the input, returning a slice pointing at the bytes in the buffer. The bytes stop being valid at the next read. If ReadSlice encounters an error before finding a delimiter, it returns all the data in the buffer and the error itself (often io.EOF). ReadSlice fails with error <a href="#ErrBufferFull">ErrBufferFull</a> if the buffer fills without a delim. Because the data returned from ReadSlice will be overwritten by the next I/O operation, most clients should use <a href="#Reader.ReadBytes">Reader.ReadBytes</a> or ReadString instead. ReadSlice returns err != nil if and only if line does not end in delim. </p>
<h3 id="Reader.ReadString">func (*Reader) <span>ReadString</span>  </h3> <pre data-language="go">func (b *Reader) ReadString(delim byte) (string, error)</pre> <p>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often io.EOF). ReadString returns err != nil if and only if the returned data does not end in delim. For simple uses, a Scanner may be more convenient. </p>
<h3 id="Reader.Reset">func (*Reader) <span>Reset</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (b *Reader) Reset(r io.Reader)</pre> <p>Reset discards any buffered data, resets all state, and switches the buffered reader to read from r. Calling Reset on the zero value of <a href="#Reader">Reader</a> initializes the internal buffer to the default size. Calling b.Reset(b) (that is, resetting a <a href="#Reader">Reader</a> to itself) does nothing. </p>
<h3 id="Reader.Size">func (*Reader) <span>Size</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Reader) Size() int</pre> <p>Size returns the size of the underlying buffer in bytes. </p>
<h3 id="Reader.UnreadByte">func (*Reader) <span>UnreadByte</span>  </h3> <pre data-language="go">func (b *Reader) UnreadByte() error</pre> <p>UnreadByte unreads the last byte. Only the most recently read byte can be unread. </p>
<p>UnreadByte returns an error if the most recent method called on the <a href="#Reader">Reader</a> was not a read operation. Notably, <a href="#Reader.Peek">Reader.Peek</a>, <a href="#Reader.Discard">Reader.Discard</a>, and <a href="#Reader.WriteTo">Reader.WriteTo</a> are not considered read operations. </p>
<h3 id="Reader.UnreadRune">func (*Reader) <span>UnreadRune</span>  </h3> <pre data-language="go">func (b *Reader) UnreadRune() error</pre> <p>UnreadRune unreads the last rune. If the most recent method called on the <a href="#Reader">Reader</a> was not a <a href="#Reader.ReadRune">Reader.ReadRune</a>, <a href="#Reader.UnreadRune">Reader.UnreadRune</a> returns an error. (In this regard it is stricter than <a href="#Reader.UnreadByte">Reader.UnreadByte</a>, which will unread the last byte from any read operation.) </p>
<h3 id="Reader.WriteTo">func (*Reader) <span>WriteTo</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (b *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p>WriteTo implements io.WriterTo. This may make multiple calls to the <a href="#Reader.Read">Reader.Read</a> method of the underlying <a href="#Reader">Reader</a>. If the underlying reader supports the <a href="#Reader.WriteTo">Reader.WriteTo</a> method, this calls the underlying <a href="#Reader.WriteTo">Reader.WriteTo</a> without buffering. </p>
<h2 id="Scanner">type <span>Scanner</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>Scanner provides a convenient interface for reading data such as a file of newline-delimited lines of text. Successive calls to the <a href="#Scanner.Scan">Scanner.Scan</a> method will step through the 'tokens' of a file, skipping the bytes between the tokens. The specification of a token is defined by a split function of type <a href="#SplitFunc">SplitFunc</a>; the default split function breaks the input into lines with line termination stripped. <a href="#Scanner.Split">Scanner.Split</a> functions are defined in this package for scanning a file into lines, bytes, UTF-8-encoded runes, and space-delimited words. The client may instead provide a custom split function. </p>
<p>Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to fit in the <a href="#Scanner.Buffer">Scanner.Buffer</a>. When a scan stops, the reader may have advanced arbitrarily far past the last token. Programs that need more control over error handling or large tokens, or must run sequential scans on a reader, should use <a href="#Reader">bufio.Reader</a> instead. </p>
<pre data-language="go">type Scanner struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Scanner_custom"> <span class="text">Example (Custom)</span>
</h4> <p>Use a Scanner with a custom split function (built by wrapping ScanWords) to validate 32-bit decimal input. </p> <p>Code:</p> <pre class="code" data-language="go">// An artificial input source.
const input = "1234 5678 1234567901234567890"
scanner := bufio.NewScanner(strings.NewReader(input))
// Create a custom split function by wrapping the existing ScanWords function.
split := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
    advance, token, err = bufio.ScanWords(data, atEOF)
    if err == nil &amp;&amp; token != nil {
        _, err = strconv.ParseInt(string(token), 10, 32)
    }
    return
}
// Set the split function for the scanning operation.
scanner.Split(split)
// Validate the input
for scanner.Scan() {
    fmt.Printf("%s\n", scanner.Text())
}

if err := scanner.Err(); err != nil {
    fmt.Printf("Invalid input: %s", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">1234
5678
Invalid input: strconv.ParseInt: parsing "1234567901234567890": value out of range
</pre>      <h4 id="example_Scanner_earlyStop"> <span class="text">Example (EarlyStop)</span>
</h4> <p>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value but stops at the token "STOP". </p> <p>Code:</p> <pre class="code" data-language="go">onComma := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
    i := bytes.IndexByte(data, ',')
    if i == -1 {
        if !atEOF {
            return 0, nil, nil
        }
        // If we have reached the end, return the last token.
        return 0, data, bufio.ErrFinalToken
    }
    // If the token is "STOP", stop the scanning and ignore the rest.
    if string(data[:i]) == "STOP" {
        return i + 1, nil, bufio.ErrFinalToken
    }
    // Otherwise, return the token before the comma.
    return i + 1, data[:i], nil
}
const input = "1,2,STOP,4,"
scanner := bufio.NewScanner(strings.NewReader(input))
scanner.Split(onComma)
for scanner.Scan() {
    fmt.Printf("Got a token %q\n", scanner.Text())
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "reading input:", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">Got a token "1"
Got a token "2"
</pre>      <h4 id="example_Scanner_emptyFinalToken"> <span class="text">Example (EmptyFinalToken)</span>
</h4> <p>Use a Scanner with a custom split function to parse a comma-separated list with an empty final value. </p> <p>Code:</p> <pre class="code" data-language="go">// Comma-separated list; last entry is empty.
const input = "1,2,3,4,"
scanner := bufio.NewScanner(strings.NewReader(input))
// Define a split function that separates on commas.
onComma := func(data []byte, atEOF bool) (advance int, token []byte, err error) {
    for i := 0; i &lt; len(data); i++ {
        if data[i] == ',' {
            return i + 1, data[:i], nil
        }
    }
    if !atEOF {
        return 0, nil, nil
    }
    // There is one final token to be delivered, which may be the empty string.
    // Returning bufio.ErrFinalToken here tells Scan there are no more tokens after this
    // but does not trigger an error to be returned from Scan itself.
    return 0, data, bufio.ErrFinalToken
}
scanner.Split(onComma)
// Scan.
for scanner.Scan() {
    fmt.Printf("%q ", scanner.Text())
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "reading input:", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">"1" "2" "3" "4" ""
</pre>      <h4 id="example_Scanner_lines"> <span class="text">Example (Lines)</span>
</h4> <p>The simplest use of a Scanner, to read standard input as a set of lines. </p> <p>Code:</p> <pre class="code" data-language="go">
scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
    fmt.Println(scanner.Text()) // Println will add back the final '\n'
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "reading standard input:", err)
}
</pre>      <h4 id="example_Scanner_words"> <span class="text">Example (Words)</span>
</h4> <p>Use a Scanner to implement a simple word-count utility by scanning the input as a sequence of space-delimited tokens. </p> <p>Code:</p> <pre class="code" data-language="go">// An artificial input source.
const input = "Now is the winter of our discontent,\nMade glorious summer by this sun of York.\n"
scanner := bufio.NewScanner(strings.NewReader(input))
// Set the split function for the scanning operation.
scanner.Split(bufio.ScanWords)
// Count the words.
count := 0
for scanner.Scan() {
    count++
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "reading input:", err)
}
fmt.Printf("%d\n", count)
</pre> <p>Output:</p> <pre class="output" data-language="go">15
</pre>   <h3 id="NewScanner">func <span>NewScanner</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func NewScanner(r io.Reader) *Scanner</pre> <p>NewScanner returns a new <a href="#Scanner">Scanner</a> to read from r. The split function defaults to <a href="#ScanLines">ScanLines</a>. </p>
<h3 id="Scanner.Buffer">func (*Scanner) <span>Buffer</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (s *Scanner) Buffer(buf []byte, max int)</pre> <p>Buffer sets the initial buffer to use when scanning and the maximum size of buffer that may be allocated during scanning. The maximum token size must be less than the larger of max and cap(buf). If max &lt;= cap(buf), <a href="#Scanner.Scan">Scanner.Scan</a> will use this buffer only and do no allocation. </p>
<p>By default, <a href="#Scanner.Scan">Scanner.Scan</a> uses an internal buffer and sets the maximum token size to <a href="#MaxScanTokenSize">MaxScanTokenSize</a>. </p>
<p>Buffer panics if it is called after scanning has started. </p>
<h3 id="Scanner.Bytes">func (*Scanner) <span>Bytes</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (s *Scanner) Bytes() []byte</pre> <p>Bytes returns the most recent token generated by a call to <a href="#Scanner.Scan">Scanner.Scan</a>. The underlying array may point to data that will be overwritten by a subsequent call to Scan. It does no allocation. </p>   <h4 id="example_Scanner_Bytes"> <span class="text">Example</span>
</h4> <p>Return the most recent call to Scan as a []byte. </p> <p>Code:</p> <pre class="code" data-language="go">scanner := bufio.NewScanner(strings.NewReader("gopher"))
for scanner.Scan() {
    fmt.Println(len(scanner.Bytes()) == 6)
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "shouldn't see an error scanning a string")
}
</pre> <p>Output:</p> <pre class="output" data-language="go">true
</pre>   <h3 id="Scanner.Err">func (*Scanner) <span>Err</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (s *Scanner) Err() error</pre> <p>Err returns the first non-EOF error that was encountered by the <a href="#Scanner">Scanner</a>. </p>
<h3 id="Scanner.Scan">func (*Scanner) <span>Scan</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (s *Scanner) Scan() bool</pre> <p>Scan advances the <a href="#Scanner">Scanner</a> to the next token, which will then be available through the <a href="#Scanner.Bytes">Scanner.Bytes</a> or <a href="#Scanner.Text">Scanner.Text</a> method. It returns false when there are no more tokens, either by reaching the end of the input or an error. After Scan returns false, the <a href="#Scanner.Err">Scanner.Err</a> method will return any error that occurred during scanning, except that if it was <span>io.EOF</span>, <a href="#Scanner.Err">Scanner.Err</a> will return nil. Scan panics if the split function returns too many empty tokens without advancing the input. This is a common error mode for scanners. </p>
<h3 id="Scanner.Split">func (*Scanner) <span>Split</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (s *Scanner) Split(split SplitFunc)</pre> <p>Split sets the split function for the <a href="#Scanner">Scanner</a>. The default split function is <a href="#ScanLines">ScanLines</a>. </p>
<p>Split panics if it is called after scanning has started. </p>
<h3 id="Scanner.Text">func (*Scanner) <span>Text</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (s *Scanner) Text() string</pre> <p>Text returns the most recent token generated by a call to <a href="#Scanner.Scan">Scanner.Scan</a> as a newly allocated string holding its bytes. </p>
<h2 id="SplitFunc">type <span>SplitFunc</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>SplitFunc is the signature of the split function used to tokenize the input. The arguments are an initial substring of the remaining unprocessed data and a flag, atEOF, that reports whether the <a href="#Reader">Reader</a> has no more data to give. The return values are the number of bytes to advance the input and the next token to return to the user, if any, plus an error, if any. </p>
<p>Scanning stops if the function returns an error, in which case some of the input may be discarded. If that error is <a href="#ErrFinalToken">ErrFinalToken</a>, scanning stops with no error. A non-nil token delivered with <a href="#ErrFinalToken">ErrFinalToken</a> will be the last token, and a nil token with <a href="#ErrFinalToken">ErrFinalToken</a> immediately stops the scanning. </p>
<p>Otherwise, the <a href="#Scanner">Scanner</a> advances the input. If the token is not nil, the <a href="#Scanner">Scanner</a> returns it to the user. If the token is nil, the Scanner reads more data and continues scanning; if there is no more data--if atEOF was true--the <a href="#Scanner">Scanner</a> returns. If the data does not yet hold a complete token, for instance if it has no newline while scanning lines, a <a href="#SplitFunc">SplitFunc</a> can return (0, nil, nil) to signal the <a href="#Scanner">Scanner</a> to read more data into the slice and try again with a longer slice starting at the same point in the input. </p>
<p>The function is never called with an empty data slice unless atEOF is true. If atEOF is true, however, data may be non-empty and, as always, holds unprocessed text. </p>
<pre data-language="go">type SplitFunc func(data []byte, atEOF bool) (advance int, token []byte, err error)</pre> <h2 id="Writer">type <span>Writer</span>  </h2> <p>Writer implements buffering for an <span>io.Writer</span> object. If an error occurs writing to a <a href="#Writer">Writer</a>, no more data will be accepted and all subsequent writes, and <a href="#Writer.Flush">Writer.Flush</a>, will return the error. After all data has been written, the client should call the <a href="#Writer.Flush">Writer.Flush</a> method to guarantee all data has been forwarded to the underlying <span>io.Writer</span>. </p>
<pre data-language="go">type Writer struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Writer"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">w := bufio.NewWriter(os.Stdout)
fmt.Fprint(w, "Hello, ")
fmt.Fprint(w, "world!")
w.Flush() // Don't forget to flush!
</pre> <p>Output:</p> <pre class="output" data-language="go">Hello, world!
</pre>   <h3 id="NewWriter">func <span>NewWriter</span>  </h3> <pre data-language="go">func NewWriter(w io.Writer) *Writer</pre> <p>NewWriter returns a new <a href="#Writer">Writer</a> whose buffer has the default size. If the argument io.Writer is already a <a href="#Writer">Writer</a> with large enough buffer size, it returns the underlying <a href="#Writer">Writer</a>. </p>
<h3 id="NewWriterSize">func <span>NewWriterSize</span>  </h3> <pre data-language="go">func NewWriterSize(w io.Writer, size int) *Writer</pre> <p>NewWriterSize returns a new <a href="#Writer">Writer</a> whose buffer has at least the specified size. If the argument io.Writer is already a <a href="#Writer">Writer</a> with large enough size, it returns the underlying <a href="#Writer">Writer</a>. </p>
<h3 id="Writer.Available">func (*Writer) <span>Available</span>  </h3> <pre data-language="go">func (b *Writer) Available() int</pre> <p>Available returns how many bytes are unused in the buffer. </p>
<h3 id="Writer.AvailableBuffer">func (*Writer) <span>AvailableBuffer</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (b *Writer) AvailableBuffer() []byte</pre> <p>AvailableBuffer returns an empty buffer with b.Available() capacity. This buffer is intended to be appended to and passed to an immediately succeeding <a href="#Writer.Write">Writer.Write</a> call. The buffer is only valid until the next write operation on b. </p>   <h4 id="example_Writer_AvailableBuffer"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">w := bufio.NewWriter(os.Stdout)
for _, i := range []int64{1, 2, 3, 4} {
    b := w.AvailableBuffer()
    b = strconv.AppendInt(b, i, 10)
    b = append(b, ' ')
    w.Write(b)
}
w.Flush()
</pre> <p>Output:</p> <pre class="output" data-language="go">1 2 3 4
</pre>   <h3 id="Writer.Buffered">func (*Writer) <span>Buffered</span>  </h3> <pre data-language="go">func (b *Writer) Buffered() int</pre> <p>Buffered returns the number of bytes that have been written into the current buffer. </p>
<h3 id="Writer.Flush">func (*Writer) <span>Flush</span>  </h3> <pre data-language="go">func (b *Writer) Flush() error</pre> <p>Flush writes any buffered data to the underlying <span>io.Writer</span>. </p>
<h3 id="Writer.ReadFrom">func (*Writer) <span>ReadFrom</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (b *Writer) ReadFrom(r io.Reader) (n int64, err error)</pre> <p>ReadFrom implements <span>io.ReaderFrom</span>. If the underlying writer supports the ReadFrom method, this calls the underlying ReadFrom. If there is buffered data and an underlying ReadFrom, this fills the buffer and writes it before calling ReadFrom. </p>   <h4 id="example_Writer_ReadFrom"> <span class="text">Example</span>
</h4> <p>ExampleWriter_ReadFrom demonstrates how to use the ReadFrom method of Writer. </p> <p>Code:</p> <pre class="code" data-language="go">var buf bytes.Buffer
writer := bufio.NewWriter(&amp;buf)

data := "Hello, world!\nThis is a ReadFrom example."
reader := strings.NewReader(data)

n, err := writer.ReadFrom(reader)
if err != nil {
    fmt.Println("ReadFrom Error:", err)
    return
}

if err = writer.Flush(); err != nil {
    fmt.Println("Flush Error:", err)
    return
}

fmt.Println("Bytes written:", n)
fmt.Println("Buffer contents:", buf.String())
</pre> <p>Output:</p> <pre class="output" data-language="go">Bytes written: 41
Buffer contents: Hello, world!
This is a ReadFrom example.
</pre>   <h3 id="Writer.Reset">func (*Writer) <span>Reset</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (b *Writer) Reset(w io.Writer)</pre> <p>Reset discards any unflushed buffered data, clears any error, and resets b to write its output to w. Calling Reset on the zero value of <a href="#Writer">Writer</a> initializes the internal buffer to the default size. Calling w.Reset(w) (that is, resetting a <a href="#Writer">Writer</a> to itself) does nothing. </p>
<h3 id="Writer.Size">func (*Writer) <span>Size</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (b *Writer) Size() int</pre> <p>Size returns the size of the underlying buffer in bytes. </p>
<h3 id="Writer.Write">func (*Writer) <span>Write</span>  </h3> <pre data-language="go">func (b *Writer) Write(p []byte) (nn int, err error)</pre> <p>Write writes the contents of p into the buffer. It returns the number of bytes written. If nn &lt; len(p), it also returns an error explaining why the write is short. </p>
<h3 id="Writer.WriteByte">func (*Writer) <span>WriteByte</span>  </h3> <pre data-language="go">func (b *Writer) WriteByte(c byte) error</pre> <p>WriteByte writes a single byte. </p>
<h3 id="Writer.WriteRune">func (*Writer) <span>WriteRune</span>  </h3> <pre data-language="go">func (b *Writer) WriteRune(r rune) (size int, err error)</pre> <p>WriteRune writes a single Unicode code point, returning the number of bytes written and any error. </p>
<h3 id="Writer.WriteString">func (*Writer) <span>WriteString</span>  </h3> <pre data-language="go">func (b *Writer) WriteString(s string) (int, error)</pre> <p>WriteString writes a string. It returns the number of bytes written. If the count is less than len(s), it also returns an error explaining why the write is short. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/bufio/" class="_attribution-link">http://golang.org/pkg/bufio/</a>
  </p>
</div>
