<h1> Package tls  </h1>     <ul id="short-nav">
<li><code>import "crypto/tls"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package tls partially implements TLS 1.2, as specified in RFC 5246, and TLS 1.3, as specified in RFC 8446. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#CipherSuiteName">func CipherSuiteName(id uint16) string</a></li>
<li><a href="#Listen">func Listen(network, laddr string, config *Config) (net.Listener, error)</a></li>
<li><a href="#NewListener">func NewListener(inner net.Listener, config *Config) net.Listener</a></li>
<li><a href="#VersionName">func VersionName(version uint16) string</a></li>
<li><a href="#AlertError">type AlertError</a></li>
<li> <a href="#AlertError.Error">func (e AlertError) Error() string</a>
</li>
<li><a href="#Certificate">type Certificate</a></li>
<li> <a href="#LoadX509KeyPair">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</a>
</li>
<li> <a href="#X509KeyPair">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</a>
</li>
<li><a href="#CertificateRequestInfo">type CertificateRequestInfo</a></li>
<li> <a href="#CertificateRequestInfo.Context">func (c *CertificateRequestInfo) Context() context.Context</a>
</li>
<li> <a href="#CertificateRequestInfo.SupportsCertificate">func (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error</a>
</li>
<li><a href="#CertificateVerificationError">type CertificateVerificationError</a></li>
<li> <a href="#CertificateVerificationError.Error">func (e *CertificateVerificationError) Error() string</a>
</li>
<li> <a href="#CertificateVerificationError.Unwrap">func (e *CertificateVerificationError) Unwrap() error</a>
</li>
<li><a href="#CipherSuite">type CipherSuite</a></li>
<li> <a href="#CipherSuites">func CipherSuites() []*CipherSuite</a>
</li>
<li> <a href="#InsecureCipherSuites">func InsecureCipherSuites() []*CipherSuite</a>
</li>
<li><a href="#ClientAuthType">type ClientAuthType</a></li>
<li> <a href="#ClientAuthType.String">func (i ClientAuthType) String() string</a>
</li>
<li><a href="#ClientHelloInfo">type ClientHelloInfo</a></li>
<li> <a href="#ClientHelloInfo.Context">func (c *ClientHelloInfo) Context() context.Context</a>
</li>
<li> <a href="#ClientHelloInfo.SupportsCertificate">func (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error</a>
</li>
<li><a href="#ClientSessionCache">type ClientSessionCache</a></li>
<li> <a href="#NewLRUClientSessionCache">func NewLRUClientSessionCache(capacity int) ClientSessionCache</a>
</li>
<li><a href="#ClientSessionState">type ClientSessionState</a></li>
<li> <a href="#NewResumptionState">func NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error)</a>
</li>
<li> <a href="#ClientSessionState.ResumptionState">func (cs *ClientSessionState) ResumptionState() (ticket []byte, state *SessionState, err error)</a>
</li>
<li><a href="#Config">type Config</a></li>
<li> <a href="#Config.BuildNameToCertificate">func (c *Config) BuildNameToCertificate()</a>
</li>
<li> <a href="#Config.Clone">func (c *Config) Clone() *Config</a>
</li>
<li> <a href="#Config.DecryptTicket">func (c *Config) DecryptTicket(identity []byte, cs ConnectionState) (*SessionState, error)</a>
</li>
<li> <a href="#Config.EncryptTicket">func (c *Config) EncryptTicket(cs ConnectionState, ss *SessionState) ([]byte, error)</a>
</li>
<li> <a href="#Config.SetSessionTicketKeys">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</a>
</li>
<li><a href="#Conn">type Conn</a></li>
<li> <a href="#Client">func Client(conn net.Conn, config *Config) *Conn</a>
</li>
<li> <a href="#Dial">func Dial(network, addr string, config *Config) (*Conn, error)</a>
</li>
<li> <a href="#DialWithDialer">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</a>
</li>
<li> <a href="#Server">func Server(conn net.Conn, config *Config) *Conn</a>
</li>
<li> <a href="#Conn.Close">func (c *Conn) Close() error</a>
</li>
<li> <a href="#Conn.CloseWrite">func (c *Conn) CloseWrite() error</a>
</li>
<li> <a href="#Conn.ConnectionState">func (c *Conn) ConnectionState() ConnectionState</a>
</li>
<li> <a href="#Conn.Handshake">func (c *Conn) Handshake() error</a>
</li>
<li> <a href="#Conn.HandshakeContext">func (c *Conn) HandshakeContext(ctx context.Context) error</a>
</li>
<li> <a href="#Conn.LocalAddr">func (c *Conn) LocalAddr() net.Addr</a>
</li>
<li> <a href="#Conn.NetConn">func (c *Conn) NetConn() net.Conn</a>
</li>
<li> <a href="#Conn.OCSPResponse">func (c *Conn) OCSPResponse() []byte</a>
</li>
<li> <a href="#Conn.Read">func (c *Conn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#Conn.RemoteAddr">func (c *Conn) RemoteAddr() net.Addr</a>
</li>
<li> <a href="#Conn.SetDeadline">func (c *Conn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.SetReadDeadline">func (c *Conn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.SetWriteDeadline">func (c *Conn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#Conn.VerifyHostname">func (c *Conn) VerifyHostname(host string) error</a>
</li>
<li> <a href="#Conn.Write">func (c *Conn) Write(b []byte) (int, error)</a>
</li>
<li><a href="#ConnectionState">type ConnectionState</a></li>
<li> <a href="#ConnectionState.ExportKeyingMaterial">func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)</a>
</li>
<li><a href="#CurveID">type CurveID</a></li>
<li> <a href="#CurveID.String">func (i CurveID) String() string</a>
</li>
<li><a href="#Dialer">type Dialer</a></li>
<li> <a href="#Dialer.Dial">func (d *Dialer) Dial(network, addr string) (net.Conn, error)</a>
</li>
<li> <a href="#Dialer.DialContext">func (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)</a>
</li>
<li><a href="#QUICConfig">type QUICConfig</a></li>
<li><a href="#QUICConn">type QUICConn</a></li>
<li> <a href="#QUICClient">func QUICClient(config *QUICConfig) *QUICConn</a>
</li>
<li> <a href="#QUICServer">func QUICServer(config *QUICConfig) *QUICConn</a>
</li>
<li> <a href="#QUICConn.Close">func (q *QUICConn) Close() error</a>
</li>
<li> <a href="#QUICConn.ConnectionState">func (q *QUICConn) ConnectionState() ConnectionState</a>
</li>
<li> <a href="#QUICConn.HandleData">func (q *QUICConn) HandleData(level QUICEncryptionLevel, data []byte) error</a>
</li>
<li> <a href="#QUICConn.NextEvent">func (q *QUICConn) NextEvent() QUICEvent</a>
</li>
<li> <a href="#QUICConn.SendSessionTicket">func (q *QUICConn) SendSessionTicket(opts QUICSessionTicketOptions) error</a>
</li>
<li> <a href="#QUICConn.SetTransportParameters">func (q *QUICConn) SetTransportParameters(params []byte)</a>
</li>
<li> <a href="#QUICConn.Start">func (q *QUICConn) Start(ctx context.Context) error</a>
</li>
<li><a href="#QUICEncryptionLevel">type QUICEncryptionLevel</a></li>
<li> <a href="#QUICEncryptionLevel.String">func (l QUICEncryptionLevel) String() string</a>
</li>
<li><a href="#QUICEvent">type QUICEvent</a></li>
<li><a href="#QUICEventKind">type QUICEventKind</a></li>
<li><a href="#QUICSessionTicketOptions">type QUICSessionTicketOptions</a></li>
<li><a href="#RecordHeaderError">type RecordHeaderError</a></li>
<li> <a href="#RecordHeaderError.Error">func (e RecordHeaderError) Error() string</a>
</li>
<li><a href="#RenegotiationSupport">type RenegotiationSupport</a></li>
<li><a href="#SessionState">type SessionState</a></li>
<li> <a href="#ParseSessionState">func ParseSessionState(data []byte) (*SessionState, error)</a>
</li>
<li> <a href="#SessionState.Bytes">func (s *SessionState) Bytes() ([]byte, error)</a>
</li>
<li><a href="#SignatureScheme">type SignatureScheme</a></li>
<li> <a href="#SignatureScheme.String">func (i SignatureScheme) String() string</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Config_keyLogWriter">Config (KeyLogWriter)</a></dd> <dd><a class="exampleLink" href="#example_Config_verifyConnection">Config (VerifyConnection)</a></dd> <dd><a class="exampleLink" href="#example_Dial">Dial</a></dd> <dd><a class="exampleLink" href="#example_LoadX509KeyPair">LoadX509KeyPair</a></dd> <dd><a class="exampleLink" href="#example_X509KeyPair">X509KeyPair</a></dd> <dd><a class="exampleLink" href="#example_X509KeyPair_httpServer">X509KeyPair (HttpServer)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>alert.go</span> <span>auth.go</span> <span>cache.go</span> <span>cipher_suites.go</span> <span>common.go</span> <span>common_string.go</span> <span>conn.go</span> <span>handshake_client.go</span> <span>handshake_client_tls13.go</span> <span>handshake_messages.go</span> <span>handshake_server.go</span> <span>handshake_server_tls13.go</span> <span>key_agreement.go</span> <span>key_schedule.go</span> <span>notboring.go</span> <span>prf.go</span> <span>quic.go</span> <span>ticket.go</span> <span>tls.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <p>A list of cipher suite IDs that are, or have been, implemented by this package. </p>
<p>See <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml</a> </p>
<pre data-language="go">const (
    // TLS 1.0 - 1.2 cipher suites.
    TLS_RSA_WITH_RC4_128_SHA                      uint16 = 0x0005
    TLS_RSA_WITH_3DES_EDE_CBC_SHA                 uint16 = 0x000a
    TLS_RSA_WITH_AES_128_CBC_SHA                  uint16 = 0x002f
    TLS_RSA_WITH_AES_256_CBC_SHA                  uint16 = 0x0035
    TLS_RSA_WITH_AES_128_CBC_SHA256               uint16 = 0x003c
    TLS_RSA_WITH_AES_128_GCM_SHA256               uint16 = 0x009c
    TLS_RSA_WITH_AES_256_GCM_SHA384               uint16 = 0x009d
    TLS_ECDHE_ECDSA_WITH_RC4_128_SHA              uint16 = 0xc007
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA          uint16 = 0xc009
    TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA          uint16 = 0xc00a
    TLS_ECDHE_RSA_WITH_RC4_128_SHA                uint16 = 0xc011
    TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA           uint16 = 0xc012
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA            uint16 = 0xc013
    TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA            uint16 = 0xc014
    TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256       uint16 = 0xc023
    TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256         uint16 = 0xc027
    TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256         uint16 = 0xc02f
    TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256       uint16 = 0xc02b
    TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384         uint16 = 0xc030
    TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384       uint16 = 0xc02c
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256   uint16 = 0xcca8
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256 uint16 = 0xcca9

    // TLS 1.3 cipher suites.
    TLS_AES_128_GCM_SHA256       uint16 = 0x1301
    TLS_AES_256_GCM_SHA384       uint16 = 0x1302
    TLS_CHACHA20_POLY1305_SHA256 uint16 = 0x1303

    // TLS_FALLBACK_SCSV isn't a standard cipher suite but an indicator
    // that the client is doing version fallback. See RFC 7507.
    TLS_FALLBACK_SCSV uint16 = 0x5600

    // Legacy names for the corresponding cipher suites with the correct _SHA256
    // suffix, retained for backward compatibility.
    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305   = TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256
    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305 = TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256
)</pre> <pre data-language="go">const (
    VersionTLS10 = 0x0301
    VersionTLS11 = 0x0302
    VersionTLS12 = 0x0303
    VersionTLS13 = 0x0304

    // Deprecated: SSLv3 is cryptographically broken, and is no longer
    // supported by this package. See golang.org/issue/32716.
    VersionSSL30 = 0x0300
)</pre> <pre data-language="go">const (
    QUICEncryptionLevelInitial = QUICEncryptionLevel(iota)
    QUICEncryptionLevelEarly
    QUICEncryptionLevelHandshake
    QUICEncryptionLevelApplication
)</pre> <h2 id="CipherSuiteName">func <span>CipherSuiteName</span>  <span title="Added in Go 1.14">1.14</span> </h2> <pre data-language="go">func CipherSuiteName(id uint16) string</pre> <p>CipherSuiteName returns the standard name for the passed cipher suite ID (e.g. "TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256"), or a fallback representation of the ID value if the cipher suite is not implemented by this package. </p>
<h2 id="Listen">func <span>Listen</span>  </h2> <pre data-language="go">func Listen(network, laddr string, config *Config) (net.Listener, error)</pre> <p>Listen creates a TLS listener accepting connections on the given network address using net.Listen. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p>
<h2 id="NewListener">func <span>NewListener</span>  </h2> <pre data-language="go">func NewListener(inner net.Listener, config *Config) net.Listener</pre> <p>NewListener creates a Listener which accepts connections from an inner Listener and wraps each connection with Server. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p>
<h2 id="VersionName">func <span>VersionName</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func VersionName(version uint16) string</pre> <p>VersionName returns the name for the provided TLS version number (e.g. "TLS 1.3"), or a fallback representation of the value if the version is not implemented by this package. </p>
<h2 id="AlertError">type <span>AlertError</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>An AlertError is a TLS alert. </p>
<p>When using a QUIC transport, QUICConn methods will return an error which wraps AlertError rather than sending a TLS alert. </p>
<pre data-language="go">type AlertError uint8</pre> <h3 id="AlertError.Error">func (AlertError) <span>Error</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (e AlertError) Error() string</pre> <h2 id="Certificate">type <span>Certificate</span>  </h2> <p>A Certificate is a chain of one or more certificates, leaf first. </p>
<pre data-language="go">type Certificate struct {
    Certificate [][]byte
    // PrivateKey contains the private key corresponding to the public key in
    // Leaf. This must implement crypto.Signer with an RSA, ECDSA or Ed25519 PublicKey.
    // For a server up to TLS 1.2, it can also implement crypto.Decrypter with
    // an RSA PublicKey.
    PrivateKey crypto.PrivateKey
    // SupportedSignatureAlgorithms is an optional list restricting what
    // signature algorithms the PrivateKey can be used for.
    SupportedSignatureAlgorithms []SignatureScheme // Go 1.14
    // OCSPStaple contains an optional OCSP response which will be served
    // to clients that request it.
    OCSPStaple []byte
    // SignedCertificateTimestamps contains an optional list of Signed
    // Certificate Timestamps which will be served to clients that request it.
    SignedCertificateTimestamps [][]byte // Go 1.5
    // Leaf is the parsed form of the leaf certificate, which may be initialized
    // using x509.ParseCertificate to reduce per-handshake processing. If nil,
    // the leaf certificate will be parsed as needed.
    Leaf *x509.Certificate
}
</pre> <h3 id="LoadX509KeyPair">func <span>LoadX509KeyPair</span>  </h3> <pre data-language="go">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</pre> <p>LoadX509KeyPair reads and parses a public/private key pair from a pair of files. The files must contain PEM encoded data. The certificate file may contain intermediate certificates following the leaf certificate to form a certificate chain. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p>   <h4 id="example_LoadX509KeyPair"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
cert, err := tls.LoadX509KeyPair("testdata/example-cert.pem", "testdata/example-key.pem")
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
listener, err := tls.Listen("tcp", ":2000", cfg)
if err != nil {
    log.Fatal(err)
}
_ = listener
</pre>   <h3 id="X509KeyPair">func <span>X509KeyPair</span>  </h3> <pre data-language="go">func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (Certificate, error)</pre> <p>X509KeyPair parses a public/private key pair from a pair of PEM encoded data. On successful return, Certificate.Leaf will be nil because the parsed form of the certificate is not retained. </p>   <h4 id="example_X509KeyPair"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
cert, err := tls.X509KeyPair(certPem, keyPem)
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
listener, err := tls.Listen("tcp", ":2000", cfg)
if err != nil {
    log.Fatal(err)
}
_ = listener
</pre>      <h4 id="example_X509KeyPair_httpServer"> <span class="text">Example (HttpServer)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
certPem := []byte(`-----BEGIN CERTIFICATE-----
MIIBhTCCASugAwIBAgIQIRi6zePL6mKjOipn+dNuaTAKBggqhkjOPQQDAjASMRAw
DgYDVQQKEwdBY21lIENvMB4XDTE3MTAyMDE5NDMwNloXDTE4MTAyMDE5NDMwNlow
EjEQMA4GA1UEChMHQWNtZSBDbzBZMBMGByqGSM49AgEGCCqGSM49AwEHA0IABD0d
7VNhbWvZLWPuj/RtHFjvtJBEwOkhbN/BnnE8rnZR8+sbwnc/KhCk3FhnpHZnQz7B
5aETbbIgmuvewdjvSBSjYzBhMA4GA1UdDwEB/wQEAwICpDATBgNVHSUEDDAKBggr
BgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MCkGA1UdEQQiMCCCDmxvY2FsaG9zdDo1
NDUzgg4xMjcuMC4wLjE6NTQ1MzAKBggqhkjOPQQDAgNIADBFAiEA2zpJEPQyz6/l
Wf86aX6PepsntZv2GYlA5UpabfT2EZICICpJ5h/iI+i341gBmLiAFQOyTDT+/wQc
6MF9+Yw1Yy0t
-----END CERTIFICATE-----`)
keyPem := []byte(`-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIIrYSSNQFaA2Hwf1duRSxKtLYX5CB04fSeQ6tF1aY/PuoAoGCCqGSM49
AwEHoUQDQgAEPR3tU2Fta9ktY+6P9G0cWO+0kETA6SFs38GecTyudlHz6xvCdz8q
EKTcWGekdmdDPsHloRNtsiCa697B2O9IFA==
-----END EC PRIVATE KEY-----`)
cert, err := tls.X509KeyPair(certPem, keyPem)
if err != nil {
    log.Fatal(err)
}
cfg := &amp;tls.Config{Certificates: []tls.Certificate{cert}}
srv := &amp;http.Server{
    TLSConfig:    cfg,
    ReadTimeout:  time.Minute,
    WriteTimeout: time.Minute,
}
log.Fatal(srv.ListenAndServeTLS("", ""))
</pre>   <h2 id="CertificateRequestInfo">type <span>CertificateRequestInfo</span>  <span title="Added in Go 1.8">1.8</span> </h2> <p>CertificateRequestInfo contains information from a server's CertificateRequest message, which is used to demand a certificate and proof of control from a client. </p>
<pre data-language="go">type CertificateRequestInfo struct {
    // AcceptableCAs contains zero or more, DER-encoded, X.501
    // Distinguished Names. These are the names of root or intermediate CAs
    // that the server wishes the returned certificate to be signed by. An
    // empty slice indicates that the server has no preference.
    AcceptableCAs [][]byte

    // SignatureSchemes lists the signature schemes that the server is
    // willing to verify.
    SignatureSchemes []SignatureScheme

    // Version is the TLS version that was negotiated for this connection.
    Version uint16 // Go 1.14
    // contains filtered or unexported fields
}
</pre> <h3 id="CertificateRequestInfo.Context">func (*CertificateRequestInfo) <span>Context</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (c *CertificateRequestInfo) Context() context.Context</pre> <p>Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. </p>
<h3 id="CertificateRequestInfo.SupportsCertificate">func (*CertificateRequestInfo) <span>SupportsCertificate</span>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func (cri *CertificateRequestInfo) SupportsCertificate(c *Certificate) error</pre> <p>SupportsCertificate returns nil if the provided certificate is supported by the server that sent the CertificateRequest. Otherwise, it returns an error describing the reason for the incompatibility. </p>
<h2 id="CertificateVerificationError">type <span>CertificateVerificationError</span>  <span title="Added in Go 1.20">1.20</span> </h2> <p>CertificateVerificationError is returned when certificate verification fails during the handshake. </p>
<pre data-language="go">type CertificateVerificationError struct {
    // UnverifiedCertificates and its contents should not be modified.
    UnverifiedCertificates []*x509.Certificate
    Err                    error
}
</pre> <h3 id="CertificateVerificationError.Error">func (*CertificateVerificationError) <span>Error</span>  <span title="Added in Go 1.20">1.20</span> </h3> <pre data-language="go">func (e *CertificateVerificationError) Error() string</pre> <h3 id="CertificateVerificationError.Unwrap">func (*CertificateVerificationError) <span>Unwrap</span>  <span title="Added in Go 1.20">1.20</span> </h3> <pre data-language="go">func (e *CertificateVerificationError) Unwrap() error</pre> <h2 id="CipherSuite">type <span>CipherSuite</span>  <span title="Added in Go 1.14">1.14</span> </h2> <p>CipherSuite is a TLS cipher suite. Note that most functions in this package accept and expose cipher suite IDs instead of this type. </p>
<pre data-language="go">type CipherSuite struct {
    ID   uint16
    Name string

    // Supported versions is the list of TLS protocol versions that can
    // negotiate this cipher suite.
    SupportedVersions []uint16

    // Insecure is true if the cipher suite has known security issues
    // due to its primitives, design, or implementation.
    Insecure bool
}
</pre> <h3 id="CipherSuites">func <span>CipherSuites</span>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func CipherSuites() []*CipherSuite</pre> <p>CipherSuites returns a list of cipher suites currently implemented by this package, excluding those with security issues, which are returned by InsecureCipherSuites. </p>
<p>The list is sorted by ID. Note that the default cipher suites selected by this package might depend on logic that can't be captured by a static list, and might not match those returned by this function. </p>
<h3 id="InsecureCipherSuites">func <span>InsecureCipherSuites</span>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func InsecureCipherSuites() []*CipherSuite</pre> <p>InsecureCipherSuites returns a list of cipher suites currently implemented by this package and which have security issues. </p>
<p>Most applications should not use the cipher suites in this list, and should only use those returned by CipherSuites. </p>
<h2 id="ClientAuthType">type <span>ClientAuthType</span>  </h2> <p>ClientAuthType declares the policy the server will follow for TLS Client Authentication. </p>
<pre data-language="go">type ClientAuthType int</pre> <pre data-language="go">const (
    // NoClientCert indicates that no client certificate should be requested
    // during the handshake, and if any certificates are sent they will not
    // be verified.
    NoClientCert ClientAuthType = iota
    // RequestClientCert indicates that a client certificate should be requested
    // during the handshake, but does not require that the client send any
    // certificates.
    RequestClientCert
    // RequireAnyClientCert indicates that a client certificate should be requested
    // during the handshake, and that at least one certificate is required to be
    // sent by the client, but that certificate is not required to be valid.
    RequireAnyClientCert
    // VerifyClientCertIfGiven indicates that a client certificate should be requested
    // during the handshake, but does not require that the client sends a
    // certificate. If the client does send a certificate it is required to be
    // valid.
    VerifyClientCertIfGiven
    // RequireAndVerifyClientCert indicates that a client certificate should be requested
    // during the handshake, and that at least one valid certificate is required
    // to be sent by the client.
    RequireAndVerifyClientCert
)</pre> <h3 id="ClientAuthType.String">func (ClientAuthType) <span>String</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (i ClientAuthType) String() string</pre> <h2 id="ClientHelloInfo">type <span>ClientHelloInfo</span>  <span title="Added in Go 1.4">1.4</span> </h2> <p>ClientHelloInfo contains information from a ClientHello message in order to guide application logic in the GetCertificate and GetConfigForClient callbacks. </p>
<pre data-language="go">type ClientHelloInfo struct {
    // CipherSuites lists the CipherSuites supported by the client (e.g.
    // TLS_AES_128_GCM_SHA256, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256).
    CipherSuites []uint16

    // ServerName indicates the name of the server requested by the client
    // in order to support virtual hosting. ServerName is only set if the
    // client is using SNI (see RFC 4366, Section 3.1).
    ServerName string

    // SupportedCurves lists the elliptic curves supported by the client.
    // SupportedCurves is set only if the Supported Elliptic Curves
    // Extension is being used (see RFC 4492, Section 5.1.1).
    SupportedCurves []CurveID

    // SupportedPoints lists the point formats supported by the client.
    // SupportedPoints is set only if the Supported Point Formats Extension
    // is being used (see RFC 4492, Section 5.1.2).
    SupportedPoints []uint8

    // SignatureSchemes lists the signature and hash schemes that the client
    // is willing to verify. SignatureSchemes is set only if the Signature
    // Algorithms Extension is being used (see RFC 5246, Section 7.4.1.4.1).
    SignatureSchemes []SignatureScheme // Go 1.8

    // SupportedProtos lists the application protocols supported by the client.
    // SupportedProtos is set only if the Application-Layer Protocol
    // Negotiation Extension is being used (see RFC 7301, Section 3.1).
    //
    // Servers can select a protocol by setting Config.NextProtos in a
    // GetConfigForClient return value.
    SupportedProtos []string // Go 1.8

    // SupportedVersions lists the TLS versions supported by the client.
    // For TLS versions less than 1.3, this is extrapolated from the max
    // version advertised by the client, so values other than the greatest
    // might be rejected if used.
    SupportedVersions []uint16 // Go 1.8

    // Conn is the underlying net.Conn for the connection. Do not read
    // from, or write to, this connection; that will cause the TLS
    // connection to fail.
    Conn net.Conn // Go 1.8
    // contains filtered or unexported fields
}
</pre> <h3 id="ClientHelloInfo.Context">func (*ClientHelloInfo) <span>Context</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (c *ClientHelloInfo) Context() context.Context</pre> <p>Context returns the context of the handshake that is in progress. This context is a child of the context passed to HandshakeContext, if any, and is canceled when the handshake concludes. </p>
<h3 id="ClientHelloInfo.SupportsCertificate">func (*ClientHelloInfo) <span>SupportsCertificate</span>  <span title="Added in Go 1.14">1.14</span> </h3> <pre data-language="go">func (chi *ClientHelloInfo) SupportsCertificate(c *Certificate) error</pre> <p>SupportsCertificate returns nil if the provided certificate is supported by the client that sent the ClientHello. Otherwise, it returns an error describing the reason for the incompatibility. </p>
<p>If this ClientHelloInfo was passed to a GetConfigForClient or GetCertificate callback, this method will take into account the associated Config. Note that if GetConfigForClient returns a different Config, the change can't be accounted for by this method. </p>
<p>This function will call x509.ParseCertificate unless c.Leaf is set, which can incur a significant performance cost. </p>
<h2 id="ClientSessionCache">type <span>ClientSessionCache</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>ClientSessionCache is a cache of ClientSessionState objects that can be used by a client to resume a TLS session with a given server. ClientSessionCache implementations should expect to be called concurrently from different goroutines. Up to TLS 1.2, only ticket-based resumption is supported, not SessionID-based resumption. In TLS 1.3 they were merged into PSK modes, which are supported via this interface. </p>
<pre data-language="go">type ClientSessionCache interface {
    // Get searches for a ClientSessionState associated with the given key.
    // On return, ok is true if one was found.
    Get(sessionKey string) (session *ClientSessionState, ok bool)

    // Put adds the ClientSessionState to the cache with the given key. It might
    // get called multiple times in a connection if a TLS 1.3 server provides
    // more than one session ticket. If called with a nil *ClientSessionState,
    // it should remove the cache entry.
    Put(sessionKey string, cs *ClientSessionState)
}</pre> <h3 id="NewLRUClientSessionCache">func <span>NewLRUClientSessionCache</span>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func NewLRUClientSessionCache(capacity int) ClientSessionCache</pre> <p>NewLRUClientSessionCache returns a ClientSessionCache with the given capacity that uses an LRU strategy. If capacity is &lt; 1, a default capacity is used instead. </p>
<h2 id="ClientSessionState">type <span>ClientSessionState</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>ClientSessionState contains the state needed by a client to resume a previous TLS session. </p>
<pre data-language="go">type ClientSessionState struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewResumptionState">func <span>NewResumptionState</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func NewResumptionState(ticket []byte, state *SessionState) (*ClientSessionState, error)</pre> <p>NewResumptionState returns a state value that can be returned by [ClientSessionCache.Get] to resume a previous session. </p>
<p>state needs to be returned by <a href="#ParseSessionState">ParseSessionState</a>, and the ticket and session state must have been returned by <a href="#ClientSessionState.ResumptionState">ClientSessionState.ResumptionState</a>. </p>
<h3 id="ClientSessionState.ResumptionState">func (*ClientSessionState) <span>ResumptionState</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (cs *ClientSessionState) ResumptionState() (ticket []byte, state *SessionState, err error)</pre> <p>ResumptionState returns the session ticket sent by the server (also known as the session's identity) and the state necessary to resume this session. </p>
<p>It can be called by [ClientSessionCache.Put] to serialize (with <a href="#SessionState.Bytes">SessionState.Bytes</a>) and store the session. </p>
<h2 id="Config">type <span>Config</span>  </h2> <p>A Config structure is used to configure a TLS client or server. After one has been passed to a TLS function it must not be modified. A Config may be reused; the tls package will also not modify it. </p>
<pre data-language="go">type Config struct {
    // Rand provides the source of entropy for nonces and RSA blinding.
    // If Rand is nil, TLS uses the cryptographic random reader in package
    // crypto/rand.
    // The Reader must be safe for use by multiple goroutines.
    Rand io.Reader

    // Time returns the current time as the number of seconds since the epoch.
    // If Time is nil, TLS uses time.Now.
    Time func() time.Time

    // Certificates contains one or more certificate chains to present to the
    // other side of the connection. The first certificate compatible with the
    // peer's requirements is selected automatically.
    //
    // Server configurations must set one of Certificates, GetCertificate or
    // GetConfigForClient. Clients doing client-authentication may set either
    // Certificates or GetClientCertificate.
    //
    // Note: if there are multiple Certificates, and they don't have the
    // optional field Leaf set, certificate selection will incur a significant
    // per-handshake performance cost.
    Certificates []Certificate

    // NameToCertificate maps from a certificate name to an element of
    // Certificates. Note that a certificate name can be of the form
    // '*.example.com' and so doesn't have to be a domain name as such.
    //
    // Deprecated: NameToCertificate only allows associating a single
    // certificate with a given name. Leave this field nil to let the library
    // select the first compatible chain from Certificates.
    NameToCertificate map[string]*Certificate

    // GetCertificate returns a Certificate based on the given
    // ClientHelloInfo. It will only be called if the client supplies SNI
    // information or if Certificates is empty.
    //
    // If GetCertificate is nil or returns nil, then the certificate is
    // retrieved from NameToCertificate. If NameToCertificate is nil, the
    // best element of Certificates will be used.
    //
    // Once a Certificate is returned it should not be modified.
    GetCertificate func(*ClientHelloInfo) (*Certificate, error) // Go 1.4

    // GetClientCertificate, if not nil, is called when a server requests a
    // certificate from a client. If set, the contents of Certificates will
    // be ignored.
    //
    // If GetClientCertificate returns an error, the handshake will be
    // aborted and that error will be returned. Otherwise
    // GetClientCertificate must return a non-nil Certificate. If
    // Certificate.Certificate is empty then no certificate will be sent to
    // the server. If this is unacceptable to the server then it may abort
    // the handshake.
    //
    // GetClientCertificate may be called multiple times for the same
    // connection if renegotiation occurs or if TLS 1.3 is in use.
    //
    // Once a Certificate is returned it should not be modified.
    GetClientCertificate func(*CertificateRequestInfo) (*Certificate, error) // Go 1.8

    // GetConfigForClient, if not nil, is called after a ClientHello is
    // received from a client. It may return a non-nil Config in order to
    // change the Config that will be used to handle this connection. If
    // the returned Config is nil, the original Config will be used. The
    // Config returned by this callback may not be subsequently modified.
    //
    // If GetConfigForClient is nil, the Config passed to Server() will be
    // used for all connections.
    //
    // If SessionTicketKey was explicitly set on the returned Config, or if
    // SetSessionTicketKeys was called on the returned Config, those keys will
    // be used. Otherwise, the original Config keys will be used (and possibly
    // rotated if they are automatically managed).
    GetConfigForClient func(*ClientHelloInfo) (*Config, error) // Go 1.8

    // VerifyPeerCertificate, if not nil, is called after normal
    // certificate verification by either a TLS client or server. It
    // receives the raw ASN.1 certificates provided by the peer and also
    // any verified chains that normal processing found. If it returns a
    // non-nil error, the handshake is aborted and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. If normal verification is disabled (on the
    // client when InsecureSkipVerify is set, or on a server when ClientAuth is
    // RequestClientCert or RequireAnyClientCert), then this callback will be
    // considered but the verifiedChains argument will always be nil. When
    // ClientAuth is NoClientCert, this callback is not called on the server.
    // rawCerts may be empty on the server if ClientAuth is RequestClientCert or
    // VerifyClientCertIfGiven.
    //
    // This callback is not invoked on resumed connections, as certificates are
    // not re-verified on resumption.
    //
    // verifiedChains and its contents should not be modified.
    VerifyPeerCertificate func(rawCerts [][]byte, verifiedChains [][]*x509.Certificate) error // Go 1.8

    // VerifyConnection, if not nil, is called after normal certificate
    // verification and after VerifyPeerCertificate by either a TLS client
    // or server. If it returns a non-nil error, the handshake is aborted
    // and that error results.
    //
    // If normal verification fails then the handshake will abort before
    // considering this callback. This callback will run for all connections,
    // including resumptions, regardless of InsecureSkipVerify or ClientAuth
    // settings.
    VerifyConnection func(ConnectionState) error // Go 1.15

    // RootCAs defines the set of root certificate authorities
    // that clients use when verifying server certificates.
    // If RootCAs is nil, TLS uses the host's root CA set.
    RootCAs *x509.CertPool

    // NextProtos is a list of supported application level protocols, in
    // order of preference. If both peers support ALPN, the selected
    // protocol will be one from this list, and the connection will fail
    // if there is no mutually supported protocol. If NextProtos is empty
    // or the peer doesn't support ALPN, the connection will succeed and
    // ConnectionState.NegotiatedProtocol will be empty.
    NextProtos []string

    // ServerName is used to verify the hostname on the returned
    // certificates unless InsecureSkipVerify is given. It is also included
    // in the client's handshake to support virtual hosting unless it is
    // an IP address.
    ServerName string

    // ClientAuth determines the server's policy for
    // TLS Client Authentication. The default is NoClientCert.
    ClientAuth ClientAuthType

    // ClientCAs defines the set of root certificate authorities
    // that servers use if required to verify a client certificate
    // by the policy in ClientAuth.
    ClientCAs *x509.CertPool

    // InsecureSkipVerify controls whether a client verifies the server's
    // certificate chain and host name. If InsecureSkipVerify is true, crypto/tls
    // accepts any certificate presented by the server and any host name in that
    // certificate. In this mode, TLS is susceptible to machine-in-the-middle
    // attacks unless custom verification is used. This should be used only for
    // testing or in combination with VerifyConnection or VerifyPeerCertificate.
    InsecureSkipVerify bool

    // CipherSuites is a list of enabled TLS 1.0–1.2 cipher suites. The order of
    // the list is ignored. Note that TLS 1.3 ciphersuites are not configurable.
    //
    // If CipherSuites is nil, a safe default list is used. The default cipher
    // suites might change over time.
    CipherSuites []uint16

    // PreferServerCipherSuites is a legacy field and has no effect.
    //
    // It used to control whether the server would follow the client's or the
    // server's preference. Servers now select the best mutually supported
    // cipher suite based on logic that takes into account inferred client
    // hardware, server hardware, and security.
    //
    // Deprecated: PreferServerCipherSuites is ignored.
    PreferServerCipherSuites bool // Go 1.1

    // SessionTicketsDisabled may be set to true to disable session ticket and
    // PSK (resumption) support. Note that on clients, session ticket support is
    // also disabled if ClientSessionCache is nil.
    SessionTicketsDisabled bool // Go 1.1

    // SessionTicketKey is used by TLS servers to provide session resumption.
    // See RFC 5077 and the PSK mode of RFC 8446. If zero, it will be filled
    // with random data before the first server handshake.
    //
    // Deprecated: if this field is left at zero, session ticket keys will be
    // automatically rotated every day and dropped after seven days. For
    // customizing the rotation schedule or synchronizing servers that are
    // terminating connections for the same host, use SetSessionTicketKeys.
    SessionTicketKey [32]byte // Go 1.1

    // ClientSessionCache is a cache of ClientSessionState entries for TLS
    // session resumption. It is only used by clients.
    ClientSessionCache ClientSessionCache // Go 1.3

    // UnwrapSession is called on the server to turn a ticket/identity
    // previously produced by [WrapSession] into a usable session.
    //
    // UnwrapSession will usually either decrypt a session state in the ticket
    // (for example with [Config.EncryptTicket]), or use the ticket as a handle
    // to recover a previously stored state. It must use [ParseSessionState] to
    // deserialize the session state.
    //
    // If UnwrapSession returns an error, the connection is terminated. If it
    // returns (nil, nil), the session is ignored. crypto/tls may still choose
    // not to resume the returned session.
    UnwrapSession func(identity []byte, cs ConnectionState) (*SessionState, error) // Go 1.21

    // WrapSession is called on the server to produce a session ticket/identity.
    //
    // WrapSession must serialize the session state with [SessionState.Bytes].
    // It may then encrypt the serialized state (for example with
    // [Config.DecryptTicket]) and use it as the ticket, or store the state and
    // return a handle for it.
    //
    // If WrapSession returns an error, the connection is terminated.
    //
    // Warning: the return value will be exposed on the wire and to clients in
    // plaintext. The application is in charge of encrypting and authenticating
    // it (and rotating keys) or returning high-entropy identifiers. Failing to
    // do so correctly can compromise current, previous, and future connections
    // depending on the protocol version.
    WrapSession func(ConnectionState, *SessionState) ([]byte, error) // Go 1.21

    // MinVersion contains the minimum TLS version that is acceptable.
    //
    // By default, TLS 1.2 is currently used as the minimum when acting as a
    // client, and TLS 1.0 when acting as a server. TLS 1.0 is the minimum
    // supported by this package, both as a client and as a server.
    //
    // The client-side default can temporarily be reverted to TLS 1.0 by
    // including the value "x509sha1=1" in the GODEBUG environment variable.
    // Note that this option will be removed in Go 1.19 (but it will still be
    // possible to set this field to VersionTLS10 explicitly).
    MinVersion uint16 // Go 1.2

    // MaxVersion contains the maximum TLS version that is acceptable.
    //
    // By default, the maximum version supported by this package is used,
    // which is currently TLS 1.3.
    MaxVersion uint16 // Go 1.2

    // CurvePreferences contains the elliptic curves that will be used in
    // an ECDHE handshake, in preference order. If empty, the default will
    // be used. The client will use the first preference as the type for
    // its key share in TLS 1.3. This may change in the future.
    CurvePreferences []CurveID // Go 1.3

    // DynamicRecordSizingDisabled disables adaptive sizing of TLS records.
    // When true, the largest possible TLS record size is always used. When
    // false, the size of TLS records may be adjusted in an attempt to
    // improve latency.
    DynamicRecordSizingDisabled bool // Go 1.7

    // Renegotiation controls what types of renegotiation are supported.
    // The default, none, is correct for the vast majority of applications.
    Renegotiation RenegotiationSupport // Go 1.7

    // KeyLogWriter optionally specifies a destination for TLS master secrets
    // in NSS key log format that can be used to allow external programs
    // such as Wireshark to decrypt TLS connections.
    // See https://developer.mozilla.org/en-US/docs/Mozilla/Projects/NSS/Key_Log_Format.
    // Use of KeyLogWriter compromises security and should only be
    // used for debugging.
    KeyLogWriter io.Writer // Go 1.8
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Config_keyLogWriter"> <span class="text">Example (KeyLogWriter)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Debugging TLS applications by decrypting a network traffic capture.

// WARNING: Use of KeyLogWriter compromises security and should only be
// used for debugging.

// Dummy test HTTP server for the example with insecure random so output is
// reproducible.
server := httptest.NewUnstartedServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {}))
server.TLS = &amp;tls.Config{
    Rand: zeroSource{}, // for example only; don't do this.
}
server.StartTLS()
defer server.Close()

// Typically the log would go to an open file:
// w, err := os.OpenFile("tls-secrets.txt", os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0600)
w := os.Stdout

client := &amp;http.Client{
    Transport: &amp;http.Transport{
        TLSClientConfig: &amp;tls.Config{
            KeyLogWriter: w,

            Rand:               zeroSource{}, // for reproducible output; don't do this.
            InsecureSkipVerify: true,         // test server certificate is not trusted.
        },
    },
}
resp, err := client.Get(server.URL)
if err != nil {
    log.Fatalf("Failed to get URL: %v", err)
}
resp.Body.Close()

// The resulting file can be used with Wireshark to decrypt the TLS
// connection by setting (Pre)-Master-Secret log filename in SSL Protocol
// preferences.
</pre>      <h4 id="example_Config_verifyConnection"> <span class="text">Example (VerifyConnection)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// VerifyConnection can be used to replace and customize connection
// verification. This example shows a VerifyConnection implementation that
// will be approximately equivalent to what crypto/tls does normally to
// verify the peer's certificate.

// Client side configuration.
_ = &amp;tls.Config{
    // Set InsecureSkipVerify to skip the default validation we are
    // replacing. This will not disable VerifyConnection.
    InsecureSkipVerify: true,
    VerifyConnection: func(cs tls.ConnectionState) error {
        opts := x509.VerifyOptions{
            DNSName:       cs.ServerName,
            Intermediates: x509.NewCertPool(),
        }
        for _, cert := range cs.PeerCertificates[1:] {
            opts.Intermediates.AddCert(cert)
        }
        _, err := cs.PeerCertificates[0].Verify(opts)
        return err
    },
}

// Server side configuration.
_ = &amp;tls.Config{
    // Require client certificates (or VerifyConnection will run anyway and
    // panic accessing cs.PeerCertificates[0]) but don't verify them with the
    // default verifier. This will not disable VerifyConnection.
    ClientAuth: tls.RequireAnyClientCert,
    VerifyConnection: func(cs tls.ConnectionState) error {
        opts := x509.VerifyOptions{
            DNSName:       cs.ServerName,
            Intermediates: x509.NewCertPool(),
            KeyUsages:     []x509.ExtKeyUsage{x509.ExtKeyUsageClientAuth},
        }
        for _, cert := range cs.PeerCertificates[1:] {
            opts.Intermediates.AddCert(cert)
        }
        _, err := cs.PeerCertificates[0].Verify(opts)
        return err
    },
}

// Note that when certificates are not handled by the default verifier
// ConnectionState.VerifiedChains will be nil.
</pre>   <h3 id="Config.BuildNameToCertificate">func (*Config) <span>BuildNameToCertificate</span>  </h3> <pre data-language="go">func (c *Config) BuildNameToCertificate()</pre> <p>BuildNameToCertificate parses c.Certificates and builds c.NameToCertificate from the CommonName and SubjectAlternateName fields of each of the leaf certificates. </p>
<p>Deprecated: NameToCertificate only allows associating a single certificate with a given name. Leave that field nil to let the library select the first compatible chain from Certificates. </p>
<h3 id="Config.Clone">func (*Config) <span>Clone</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *Config) Clone() *Config</pre> <p>Clone returns a shallow clone of c or nil if c is nil. It is safe to clone a Config that is being used concurrently by a TLS client or server. </p>
<h3 id="Config.DecryptTicket">func (*Config) <span>DecryptTicket</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (c *Config) DecryptTicket(identity []byte, cs ConnectionState) (*SessionState, error)</pre> <p>DecryptTicket decrypts a ticket encrypted by <a href="#Config.EncryptTicket">Config.EncryptTicket</a>. It can be used as a [Config.UnwrapSession] implementation. </p>
<p>If the ticket can't be decrypted or parsed, DecryptTicket returns (nil, nil). </p>
<h3 id="Config.EncryptTicket">func (*Config) <span>EncryptTicket</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (c *Config) EncryptTicket(cs ConnectionState, ss *SessionState) ([]byte, error)</pre> <p>EncryptTicket encrypts a ticket with the Config's configured (or default) session ticket keys. It can be used as a [Config.WrapSession] implementation. </p>
<h3 id="Config.SetSessionTicketKeys">func (*Config) <span>SetSessionTicketKeys</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (c *Config) SetSessionTicketKeys(keys [][32]byte)</pre> <p>SetSessionTicketKeys updates the session ticket keys for a server. </p>
<p>The first key will be used when creating new tickets, while all keys can be used for decrypting tickets. It is safe to call this function while the server is running in order to rotate the session ticket keys. The function will panic if keys is empty. </p>
<p>Calling this function will turn off automatic session ticket key rotation. </p>
<p>If multiple servers are terminating connections for the same host they should all have the same session ticket keys. If the session ticket keys leaks, previously recorded and future TLS connections using those keys might be compromised. </p>
<h2 id="Conn">type <span>Conn</span>  </h2> <p>A Conn represents a secured connection. It implements the net.Conn interface. </p>
<pre data-language="go">type Conn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Client">func <span>Client</span>  </h3> <pre data-language="go">func Client(conn net.Conn, config *Config) *Conn</pre> <p>Client returns a new TLS client side connection using conn as the underlying transport. The config cannot be nil: users must set either ServerName or InsecureSkipVerify in the config. </p>
<h3 id="Dial">func <span>Dial</span>  </h3> <pre data-language="go">func Dial(network, addr string, config *Config) (*Conn, error)</pre> <p>Dial connects to the given network address using net.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Dial interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p>   <h4 id="example_Dial"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Connecting with a custom root-certificate set.

const rootPEM = `
-- GlobalSign Root R2, valid until Dec 15, 2021
-----BEGIN CERTIFICATE-----
MIIDujCCAqKgAwIBAgILBAAAAAABD4Ym5g0wDQYJKoZIhvcNAQEFBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjIxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDYxMjE1MDgwMDAwWhcNMjExMjE1
MDgwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMjETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAKbPJA6+Lm8omUVCxKs+IVSbC9N/hHD6ErPL
v4dfxn+G07IwXNb9rfF73OX4YJYJkhD10FPe+3t+c4isUoh7SqbKSaZeqKeMWhG8
eoLrvozps6yWJQeXSpkqBy+0Hne/ig+1AnwblrjFuTosvNYSuetZfeLQBoZfXklq
tTleiDTsvHgMCJiEbKjNS7SgfQx5TfC4LcshytVsW33hoCmEofnTlEnLJGKRILzd
C9XZzPnqJworc5HGnRusyMvo4KD0L5CLTfuwNhv2GXqF4G3yYROIXJ/gkwpRl4pa
zq+r1feqCapgvdzZX99yqWATXgAByUr6P6TqBwMhAo6CygPCm48CAwEAAaOBnDCB
mTAOBgNVHQ8BAf8EBAMCAQYwDwYDVR0TAQH/BAUwAwEB/zAdBgNVHQ4EFgQUm+IH
V2ccHsBqBt5ZtJot39wZhi4wNgYDVR0fBC8wLTAroCmgJ4YlaHR0cDovL2NybC5n
bG9iYWxzaWduLm5ldC9yb290LXIyLmNybDAfBgNVHSMEGDAWgBSb4gdXZxwewGoG
3lm0mi3f3BmGLjANBgkqhkiG9w0BAQUFAAOCAQEAmYFThxxol4aR7OBKuEQLq4Gs
J0/WwbgcQ3izDJr86iw8bmEbTUsp9Z8FHSbBuOmDAGJFtqkIk7mpM0sYmsL4h4hO
291xNBrBVNpGP+DTKqttVCL1OmLNIG+6KYnX3ZHu01yiPqFbQfXf5WRDLenVOavS
ot+3i9DAgBkcRcAtjOj4LaR0VknFBbVPFd5uRHg5h6h+u/N5GJG79G+dwfCMNYxd
AfvDbbnvRG15RjF+Cv6pgsH/76tuIMRQyV+dTZsXjAzlAcmgQWpzU/qlULRuJQ/7
TBj0/VLZjmmx6BEP3ojY+x1J96relc8geMJgEtslQIxq/H5COEBkEveegeGTLg==
-----END CERTIFICATE-----`

// First, create the set of root certificates. For this example we only
// have one. It's also possible to omit this in order to use the
// default root set of the current operating system.
roots := x509.NewCertPool()
ok := roots.AppendCertsFromPEM([]byte(rootPEM))
if !ok {
    panic("failed to parse root certificate")
}

conn, err := tls.Dial("tcp", "mail.google.com:443", &amp;tls.Config{
    RootCAs: roots,
})
if err != nil {
    panic("failed to connect: " + err.Error())
}
conn.Close()
</pre>   <h3 id="DialWithDialer">func <span>DialWithDialer</span>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func DialWithDialer(dialer *net.Dialer, network, addr string, config *Config) (*Conn, error)</pre> <p>DialWithDialer connects to the given network address using dialer.Dial and then initiates a TLS handshake, returning the resulting TLS connection. Any timeout or deadline given in the dialer apply to connection and TLS handshake as a whole. </p>
<p>DialWithDialer interprets a nil configuration as equivalent to the zero configuration; see the documentation of Config for the defaults. </p>
<p>DialWithDialer uses context.Background internally; to specify the context, use Dialer.DialContext with NetDialer set to the desired dialer. </p>
<h3 id="Server">func <span>Server</span>  </h3> <pre data-language="go">func Server(conn net.Conn, config *Config) *Conn</pre> <p>Server returns a new TLS server side connection using conn as the underlying transport. The configuration config must be non-nil and must include at least one certificate or else set GetCertificate. </p>
<h3 id="Conn.Close">func (*Conn) <span>Close</span>  </h3> <pre data-language="go">func (c *Conn) Close() error</pre> <p>Close closes the connection. </p>
<h3 id="Conn.CloseWrite">func (*Conn) <span>CloseWrite</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (c *Conn) CloseWrite() error</pre> <p>CloseWrite shuts down the writing side of the connection. It should only be called once the handshake has completed and does not call CloseWrite on the underlying connection. Most callers should just use Close. </p>
<h3 id="Conn.ConnectionState">func (*Conn) <span>ConnectionState</span>  </h3> <pre data-language="go">func (c *Conn) ConnectionState() ConnectionState</pre> <p>ConnectionState returns basic TLS details about the connection. </p>
<h3 id="Conn.Handshake">func (*Conn) <span>Handshake</span>  </h3> <pre data-language="go">func (c *Conn) Handshake() error</pre> <p>Handshake runs the client or server handshake protocol if it has not yet been run. </p>
<p>Most uses of this package need not call Handshake explicitly: the first Read or Write will call it automatically. </p>
<p>For control over canceling or setting a timeout on a handshake, use HandshakeContext or the Dialer's DialContext method instead. </p>
<p>In order to avoid denial of service attacks, the maximum RSA key size allowed in certificates sent by either the TLS server or client is limited to 8192 bits. This limit can be overridden by setting tlsmaxrsasize in the GODEBUG environment variable (e.g. GODEBUG=tlsmaxrsasize=4096). </p>
<h3 id="Conn.HandshakeContext">func (*Conn) <span>HandshakeContext</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (c *Conn) HandshakeContext(ctx context.Context) error</pre> <p>HandshakeContext runs the client or server handshake protocol if it has not yet been run. </p>
<p>The provided Context must be non-nil. If the context is canceled before the handshake is complete, the handshake is interrupted and an error is returned. Once the handshake has completed, cancellation of the context will not affect the connection. </p>
<p>Most uses of this package need not call HandshakeContext explicitly: the first Read or Write will call it automatically. </p>
<h3 id="Conn.LocalAddr">func (*Conn) <span>LocalAddr</span>  </h3> <pre data-language="go">func (c *Conn) LocalAddr() net.Addr</pre> <p>LocalAddr returns the local network address. </p>
<h3 id="Conn.NetConn">func (*Conn) <span>NetConn</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *Conn) NetConn() net.Conn</pre> <p>NetConn returns the underlying connection that is wrapped by c. Note that writing to or reading from this connection directly will corrupt the TLS session. </p>
<h3 id="Conn.OCSPResponse">func (*Conn) <span>OCSPResponse</span>  </h3> <pre data-language="go">func (c *Conn) OCSPResponse() []byte</pre> <p>OCSPResponse returns the stapled OCSP response from the TLS server, if any. (Only valid for client connections.) </p>
<h3 id="Conn.Read">func (*Conn) <span>Read</span>  </h3> <pre data-language="go">func (c *Conn) Read(b []byte) (int, error)</pre> <p>Read reads data from the connection. </p>
<p>As Read calls Handshake, in order to prevent indefinite blocking a deadline must be set for both Read and Write before Read is called when the handshake has not yet completed. See SetDeadline, SetReadDeadline, and SetWriteDeadline. </p>
<h3 id="Conn.RemoteAddr">func (*Conn) <span>RemoteAddr</span>  </h3> <pre data-language="go">func (c *Conn) RemoteAddr() net.Addr</pre> <p>RemoteAddr returns the remote network address. </p>
<h3 id="Conn.SetDeadline">func (*Conn) <span>SetDeadline</span>  </h3> <pre data-language="go">func (c *Conn) SetDeadline(t time.Time) error</pre> <p>SetDeadline sets the read and write deadlines associated with the connection. A zero value for t means Read and Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p>
<h3 id="Conn.SetReadDeadline">func (*Conn) <span>SetReadDeadline</span>  </h3> <pre data-language="go">func (c *Conn) SetReadDeadline(t time.Time) error</pre> <p>SetReadDeadline sets the read deadline on the underlying connection. A zero value for t means Read will not time out. </p>
<h3 id="Conn.SetWriteDeadline">func (*Conn) <span>SetWriteDeadline</span>  </h3> <pre data-language="go">func (c *Conn) SetWriteDeadline(t time.Time) error</pre> <p>SetWriteDeadline sets the write deadline on the underlying connection. A zero value for t means Write will not time out. After a Write has timed out, the TLS state is corrupt and all future writes will return the same error. </p>
<h3 id="Conn.VerifyHostname">func (*Conn) <span>VerifyHostname</span>  </h3> <pre data-language="go">func (c *Conn) VerifyHostname(host string) error</pre> <p>VerifyHostname checks that the peer certificate chain is valid for connecting to host. If so, it returns nil; if not, it returns an error describing the problem. </p>
<h3 id="Conn.Write">func (*Conn) <span>Write</span>  </h3> <pre data-language="go">func (c *Conn) Write(b []byte) (int, error)</pre> <p>Write writes data to the connection. </p>
<p>As Write calls Handshake, in order to prevent indefinite blocking a deadline must be set for both Read and Write before Write is called when the handshake has not yet completed. See SetDeadline, SetReadDeadline, and SetWriteDeadline. </p>
<h2 id="ConnectionState">type <span>ConnectionState</span>  </h2> <p>ConnectionState records basic TLS details about the connection. </p>
<pre data-language="go">type ConnectionState struct {
    // Version is the TLS version used by the connection (e.g. VersionTLS12).
    Version uint16 // Go 1.3

    // HandshakeComplete is true if the handshake has concluded.
    HandshakeComplete bool

    // DidResume is true if this connection was successfully resumed from a
    // previous session with a session ticket or similar mechanism.
    DidResume bool // Go 1.1

    // CipherSuite is the cipher suite negotiated for the connection (e.g.
    // TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_AES_128_GCM_SHA256).
    CipherSuite uint16

    // NegotiatedProtocol is the application protocol negotiated with ALPN.
    NegotiatedProtocol string

    // NegotiatedProtocolIsMutual used to indicate a mutual NPN negotiation.
    //
    // Deprecated: this value is always true.
    NegotiatedProtocolIsMutual bool

    // ServerName is the value of the Server Name Indication extension sent by
    // the client. It's available both on the server and on the client side.
    ServerName string

    // PeerCertificates are the parsed certificates sent by the peer, in the
    // order in which they were sent. The first element is the leaf certificate
    // that the connection is verified against.
    //
    // On the client side, it can't be empty. On the server side, it can be
    // empty if Config.ClientAuth is not RequireAnyClientCert or
    // RequireAndVerifyClientCert.
    //
    // PeerCertificates and its contents should not be modified.
    PeerCertificates []*x509.Certificate

    // VerifiedChains is a list of one or more chains where the first element is
    // PeerCertificates[0] and the last element is from Config.RootCAs (on the
    // client side) or Config.ClientCAs (on the server side).
    //
    // On the client side, it's set if Config.InsecureSkipVerify is false. On
    // the server side, it's set if Config.ClientAuth is VerifyClientCertIfGiven
    // (and the peer provided a certificate) or RequireAndVerifyClientCert.
    //
    // VerifiedChains and its contents should not be modified.
    VerifiedChains [][]*x509.Certificate

    // SignedCertificateTimestamps is a list of SCTs provided by the peer
    // through the TLS handshake for the leaf certificate, if any.
    SignedCertificateTimestamps [][]byte // Go 1.5

    // OCSPResponse is a stapled Online Certificate Status Protocol (OCSP)
    // response provided by the peer for the leaf certificate, if any.
    OCSPResponse []byte // Go 1.5

    // TLSUnique contains the "tls-unique" channel binding value (see RFC 5929,
    // Section 3). This value will be nil for TLS 1.3 connections and for
    // resumed connections that don't support Extended Master Secret (RFC 7627).
    TLSUnique []byte // Go 1.4
    // contains filtered or unexported fields
}
</pre> <h3 id="ConnectionState.ExportKeyingMaterial">func (*ConnectionState) <span>ExportKeyingMaterial</span>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (cs *ConnectionState) ExportKeyingMaterial(label string, context []byte, length int) ([]byte, error)</pre> <p>ExportKeyingMaterial returns length bytes of exported key material in a new slice as defined in RFC 5705. If context is nil, it is not used as part of the seed. If the connection was set to allow renegotiation via Config.Renegotiation, this function will return an error. </p>
<p>There are conditions in which the returned values might not be unique to a connection. See the Security Considerations sections of RFC 5705 and RFC 7627, and <a href="https://mitls.org/pages/attacks/3SHAKE#channelbindings">https://mitls.org/pages/attacks/3SHAKE#channelbindings</a>. </p>
<h2 id="CurveID">type <span>CurveID</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>CurveID is the type of a TLS identifier for an elliptic curve. See <a href="https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8">https://www.iana.org/assignments/tls-parameters/tls-parameters.xml#tls-parameters-8</a>. </p>
<p>In TLS 1.3, this type is called NamedGroup, but at this time this library only supports Elliptic Curve based groups. See RFC 8446, Section 4.2.7. </p>
<pre data-language="go">type CurveID uint16</pre> <pre data-language="go">const (
    CurveP256 CurveID = 23
    CurveP384 CurveID = 24
    CurveP521 CurveID = 25
    X25519    CurveID = 29
)</pre> <h3 id="CurveID.String">func (CurveID) <span>String</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (i CurveID) String() string</pre> <h2 id="Dialer">type <span>Dialer</span>  <span title="Added in Go 1.15">1.15</span> </h2> <p>Dialer dials TLS connections given a configuration and a Dialer for the underlying connection. </p>
<pre data-language="go">type Dialer struct {
    // NetDialer is the optional dialer to use for the TLS connections'
    // underlying TCP connections.
    // A nil NetDialer is equivalent to the net.Dialer zero value.
    NetDialer *net.Dialer

    // Config is the TLS configuration to use for new connections.
    // A nil configuration is equivalent to the zero
    // configuration; see the documentation of Config for the
    // defaults.
    Config *Config
}
</pre> <h3 id="Dialer.Dial">func (*Dialer) <span>Dial</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (d *Dialer) Dial(network, addr string) (net.Conn, error)</pre> <p>Dial connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection. </p>
<p>The returned Conn, if any, will always be of type *Conn. </p>
<p>Dial uses context.Background internally; to specify the context, use DialContext. </p>
<h3 id="Dialer.DialContext">func (*Dialer) <span>DialContext</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (d *Dialer) DialContext(ctx context.Context, network, addr string) (net.Conn, error)</pre> <p>DialContext connects to the given network address and initiates a TLS handshake, returning the resulting TLS connection. </p>
<p>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. </p>
<p>The returned Conn, if any, will always be of type *Conn. </p>
<h2 id="QUICConfig">type <span>QUICConfig</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>A QUICConfig configures a QUICConn. </p>
<pre data-language="go">type QUICConfig struct {
    TLSConfig *Config
}
</pre> <h2 id="QUICConn">type <span>QUICConn</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>A QUICConn represents a connection which uses a QUIC implementation as the underlying transport as described in RFC 9001. </p>
<p>Methods of QUICConn are not safe for concurrent use. </p>
<pre data-language="go">type QUICConn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="QUICClient">func <span>QUICClient</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func QUICClient(config *QUICConfig) *QUICConn</pre> <p>QUICClient returns a new TLS client side connection using QUICTransport as the underlying transport. The config cannot be nil. </p>
<p>The config's MinVersion must be at least TLS 1.3. </p>
<h3 id="QUICServer">func <span>QUICServer</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func QUICServer(config *QUICConfig) *QUICConn</pre> <p>QUICServer returns a new TLS server side connection using QUICTransport as the underlying transport. The config cannot be nil. </p>
<p>The config's MinVersion must be at least TLS 1.3. </p>
<h3 id="QUICConn.Close">func (*QUICConn) <span>Close</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) Close() error</pre> <p>Close closes the connection and stops any in-progress handshake. </p>
<h3 id="QUICConn.ConnectionState">func (*QUICConn) <span>ConnectionState</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) ConnectionState() ConnectionState</pre> <p>ConnectionState returns basic TLS details about the connection. </p>
<h3 id="QUICConn.HandleData">func (*QUICConn) <span>HandleData</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) HandleData(level QUICEncryptionLevel, data []byte) error</pre> <p>HandleData handles handshake bytes received from the peer. It may produce connection events, which may be read with NextEvent. </p>
<h3 id="QUICConn.NextEvent">func (*QUICConn) <span>NextEvent</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) NextEvent() QUICEvent</pre> <p>NextEvent returns the next event occurring on the connection. It returns an event with a Kind of QUICNoEvent when no events are available. </p>
<h3 id="QUICConn.SendSessionTicket">func (*QUICConn) <span>SendSessionTicket</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) SendSessionTicket(opts QUICSessionTicketOptions) error</pre> <p>SendSessionTicket sends a session ticket to the client. It produces connection events, which may be read with NextEvent. Currently, it can only be called once. </p>
<h3 id="QUICConn.SetTransportParameters">func (*QUICConn) <span>SetTransportParameters</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) SetTransportParameters(params []byte)</pre> <p>SetTransportParameters sets the transport parameters to send to the peer. </p>
<p>Server connections may delay setting the transport parameters until after receiving the client's transport parameters. See QUICTransportParametersRequired. </p>
<h3 id="QUICConn.Start">func (*QUICConn) <span>Start</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (q *QUICConn) Start(ctx context.Context) error</pre> <p>Start starts the client or server handshake protocol. It may produce connection events, which may be read with NextEvent. </p>
<p>Start must be called at most once. </p>
<h2 id="QUICEncryptionLevel">type <span>QUICEncryptionLevel</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>QUICEncryptionLevel represents a QUIC encryption level used to transmit handshake messages. </p>
<pre data-language="go">type QUICEncryptionLevel int</pre> <h3 id="QUICEncryptionLevel.String">func (QUICEncryptionLevel) <span>String</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (l QUICEncryptionLevel) String() string</pre> <h2 id="QUICEvent">type <span>QUICEvent</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>A QUICEvent is an event occurring on a QUIC connection. </p>
<p>The type of event is specified by the Kind field. The contents of the other fields are kind-specific. </p>
<pre data-language="go">type QUICEvent struct {
    Kind QUICEventKind

    // Set for QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.
    Level QUICEncryptionLevel

    // Set for QUICTransportParameters, QUICSetReadSecret, QUICSetWriteSecret, and QUICWriteData.
    // The contents are owned by crypto/tls, and are valid until the next NextEvent call.
    Data []byte

    // Set for QUICSetReadSecret and QUICSetWriteSecret.
    Suite uint16
}
</pre> <h2 id="QUICEventKind">type <span>QUICEventKind</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>A QUICEventKind is a type of operation on a QUIC connection. </p>
<pre data-language="go">type QUICEventKind int</pre> <pre data-language="go">const (
    // QUICNoEvent indicates that there are no events available.
    QUICNoEvent QUICEventKind = iota

    // QUICSetReadSecret and QUICSetWriteSecret provide the read and write
    // secrets for a given encryption level.
    // QUICEvent.Level, QUICEvent.Data, and QUICEvent.Suite are set.
    //
    // Secrets for the Initial encryption level are derived from the initial
    // destination connection ID, and are not provided by the QUICConn.
    QUICSetReadSecret
    QUICSetWriteSecret

    // QUICWriteData provides data to send to the peer in CRYPTO frames.
    // QUICEvent.Data is set.
    QUICWriteData

    // QUICTransportParameters provides the peer's QUIC transport parameters.
    // QUICEvent.Data is set.
    QUICTransportParameters

    // QUICTransportParametersRequired indicates that the caller must provide
    // QUIC transport parameters to send to the peer. The caller should set
    // the transport parameters with QUICConn.SetTransportParameters and call
    // QUICConn.NextEvent again.
    //
    // If transport parameters are set before calling QUICConn.Start, the
    // connection will never generate a QUICTransportParametersRequired event.
    QUICTransportParametersRequired

    // QUICRejectedEarlyData indicates that the server rejected 0-RTT data even
    // if we offered it. It's returned before QUICEncryptionLevelApplication
    // keys are returned.
    QUICRejectedEarlyData

    // QUICHandshakeDone indicates that the TLS handshake has completed.
    QUICHandshakeDone
)</pre> <h2 id="QUICSessionTicketOptions">type <span>QUICSessionTicketOptions</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">type QUICSessionTicketOptions struct {
    // EarlyData specifies whether the ticket may be used for 0-RTT.
    EarlyData bool
}
</pre> <h2 id="RecordHeaderError">type <span>RecordHeaderError</span>  <span title="Added in Go 1.6">1.6</span> </h2> <p>RecordHeaderError is returned when a TLS record header is invalid. </p>
<pre data-language="go">type RecordHeaderError struct {
    // Msg contains a human readable string that describes the error.
    Msg string
    // RecordHeader contains the five bytes of TLS record header that
    // triggered the error.
    RecordHeader [5]byte
    // Conn provides the underlying net.Conn in the case that a client
    // sent an initial handshake that didn't look like TLS.
    // It is nil if there's already been a handshake or a TLS alert has
    // been written to the connection.
    Conn net.Conn // Go 1.12
}
</pre> <h3 id="RecordHeaderError.Error">func (RecordHeaderError) <span>Error</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (e RecordHeaderError) Error() string</pre> <h2 id="RenegotiationSupport">type <span>RenegotiationSupport</span>  <span title="Added in Go 1.7">1.7</span> </h2> <p>RenegotiationSupport enumerates the different levels of support for TLS renegotiation. TLS renegotiation is the act of performing subsequent handshakes on a connection after the first. This significantly complicates the state machine and has been the source of numerous, subtle security issues. Initiating a renegotiation is not supported, but support for accepting renegotiation requests may be enabled. </p>
<p>Even when enabled, the server may not change its identity between handshakes (i.e. the leaf certificate must be the same). Additionally, concurrent handshake and application data flow is not permitted so renegotiation can only be used with protocols that synchronise with the renegotiation, such as HTTPS. </p>
<p>Renegotiation is not defined in TLS 1.3. </p>
<pre data-language="go">type RenegotiationSupport int</pre> <pre data-language="go">const (
    // RenegotiateNever disables renegotiation.
    RenegotiateNever RenegotiationSupport = iota

    // RenegotiateOnceAsClient allows a remote server to request
    // renegotiation once per connection.
    RenegotiateOnceAsClient

    // RenegotiateFreelyAsClient allows a remote server to repeatedly
    // request renegotiation.
    RenegotiateFreelyAsClient
)</pre> <h2 id="SessionState">type <span>SessionState</span>  <span title="Added in Go 1.21">1.21</span> </h2> <p>A SessionState is a resumable session. </p>
<pre data-language="go">type SessionState struct {

    // Extra is ignored by crypto/tls, but is encoded by [SessionState.Bytes]
    // and parsed by [ParseSessionState].
    //
    // This allows [Config.UnwrapSession]/[Config.WrapSession] and
    // [ClientSessionCache] implementations to store and retrieve additional
    // data alongside this session.
    //
    // To allow different layers in a protocol stack to share this field,
    // applications must only append to it, not replace it, and must use entries
    // that can be recognized even if out of order (for example, by starting
    // with a id and version prefix).
    Extra [][]byte

    // EarlyData indicates whether the ticket can be used for 0-RTT in a QUIC
    // connection. The application may set this to false if it is true to
    // decline to offer 0-RTT even if supported.
    EarlyData bool
    // contains filtered or unexported fields
}
</pre> <h3 id="ParseSessionState">func <span>ParseSessionState</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func ParseSessionState(data []byte) (*SessionState, error)</pre> <p>ParseSessionState parses a <a href="#SessionState">SessionState</a> encoded by <a href="#SessionState.Bytes">SessionState.Bytes</a>. </p>
<h3 id="SessionState.Bytes">func (*SessionState) <span>Bytes</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (s *SessionState) Bytes() ([]byte, error)</pre> <p>Bytes encodes the session, including any private fields, so that it can be parsed by <a href="#ParseSessionState">ParseSessionState</a>. The encoding contains secret values critical to the security of future and possibly past sessions. </p>
<p>The specific encoding should be considered opaque and may change incompatibly between Go versions. </p>
<h2 id="SignatureScheme">type <span>SignatureScheme</span>  <span title="Added in Go 1.8">1.8</span> </h2> <p>SignatureScheme identifies a signature algorithm supported by TLS. See RFC 8446, Section 4.2.3. </p>
<pre data-language="go">type SignatureScheme uint16</pre> <pre data-language="go">const (
    // RSASSA-PKCS1-v1_5 algorithms.
    PKCS1WithSHA256 SignatureScheme = 0x0401
    PKCS1WithSHA384 SignatureScheme = 0x0501
    PKCS1WithSHA512 SignatureScheme = 0x0601

    // RSASSA-PSS algorithms with public key OID rsaEncryption.
    PSSWithSHA256 SignatureScheme = 0x0804
    PSSWithSHA384 SignatureScheme = 0x0805
    PSSWithSHA512 SignatureScheme = 0x0806

    // ECDSA algorithms. Only constrained to a specific curve in TLS 1.3.
    ECDSAWithP256AndSHA256 SignatureScheme = 0x0403
    ECDSAWithP384AndSHA384 SignatureScheme = 0x0503
    ECDSAWithP521AndSHA512 SignatureScheme = 0x0603

    // EdDSA algorithms.
    Ed25519 SignatureScheme = 0x0807

    // Legacy signature and hash algorithms for TLS 1.2.
    PKCS1WithSHA1 SignatureScheme = 0x0201
    ECDSAWithSHA1 SignatureScheme = 0x0203
)</pre> <h3 id="SignatureScheme.String">func (SignatureScheme) <span>String</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (i SignatureScheme) String() string</pre> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>☞ <p>The crypto/tls package only implements some countermeasures against Lucky13 attacks on CBC-mode encryption, and only on SHA1 variants. See <a href="http://www.isg.rhul.ac.uk/tls/TLStiming.pdf">http://www.isg.rhul.ac.uk/tls/TLStiming.pdf</a> and <a href="https://www.imperialviolet.org/2013/02/04/luckythirteen.html">https://www.imperialviolet.org/2013/02/04/luckythirteen.html</a>. </p>
</li> </ul> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../index.html">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="fipsonly/index.html">fipsonly</a> </td> <td class="pkg-synopsis"> Package fipsonly restricts all TLS configuration to FIPS-approved settings. </td> </tr> </table> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/crypto/tls/" class="_attribution-link">http://golang.org/pkg/crypto/tls/</a>
  </p>
</div>
