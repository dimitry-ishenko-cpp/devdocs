<h1> Package subtle  </h1>     <ul id="short-nav">
<li><code>import "crypto/subtle"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package subtle implements functions that are often useful in cryptographic code but require careful thought to use correctly. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#ConstantTimeByteEq">func ConstantTimeByteEq(x, y uint8) int</a></li>
<li><a href="#ConstantTimeCompare">func ConstantTimeCompare(x, y []byte) int</a></li>
<li><a href="#ConstantTimeCopy">func ConstantTimeCopy(v int, x, y []byte)</a></li>
<li><a href="#ConstantTimeEq">func ConstantTimeEq(x, y int32) int</a></li>
<li><a href="#ConstantTimeLessOrEq">func ConstantTimeLessOrEq(x, y int) int</a></li>
<li><a href="#ConstantTimeSelect">func ConstantTimeSelect(v, x, y int) int</a></li>
<li><a href="#WithDataIndependentTiming">func WithDataIndependentTiming(f func())</a></li>
<li><a href="#XORBytes">func XORBytes(dst, x, y []byte) int</a></li>
</ul> <h3>Package files</h3> <p>  <span>constant_time.go</span> <span>dit.go</span> <span>xor.go</span>  </p>   <h2 id="ConstantTimeByteEq">func <span>ConstantTimeByteEq</span>  </h2> <pre data-language="go">func ConstantTimeByteEq(x, y uint8) int</pre> <p>ConstantTimeByteEq returns 1 if x == y and 0 otherwise. </p>
<h2 id="ConstantTimeCompare">func <span>ConstantTimeCompare</span>  </h2> <pre data-language="go">func ConstantTimeCompare(x, y []byte) int</pre> <p>ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents and 0 otherwise. The time taken is a function of the length of the slices and is independent of the contents. If the lengths of x and y do not match it returns 0 immediately. </p>
<h2 id="ConstantTimeCopy">func <span>ConstantTimeCopy</span>  </h2> <pre data-language="go">func ConstantTimeCopy(v int, x, y []byte)</pre> <p>ConstantTimeCopy copies the contents of y into x (a slice of equal length) if v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v takes any other value. </p>
<h2 id="ConstantTimeEq">func <span>ConstantTimeEq</span>  </h2> <pre data-language="go">func ConstantTimeEq(x, y int32) int</pre> <p>ConstantTimeEq returns 1 if x == y and 0 otherwise. </p>
<h2 id="ConstantTimeLessOrEq">func <span>ConstantTimeLessOrEq</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func ConstantTimeLessOrEq(x, y int) int</pre> <p>ConstantTimeLessOrEq returns 1 if x &lt;= y and 0 otherwise. Its behavior is undefined if x or y are negative or &gt; 2**31 - 1. </p>
<h2 id="ConstantTimeSelect">func <span>ConstantTimeSelect</span>  </h2> <pre data-language="go">func ConstantTimeSelect(v, x, y int) int</pre> <p>ConstantTimeSelect returns x if v == 1 and y if v == 0. Its behavior is undefined if v takes any other value. </p>
<h2 id="WithDataIndependentTiming">func <span>WithDataIndependentTiming</span>  <span title="Added in Go 1.24">1.24</span> </h2> <pre data-language="go">func WithDataIndependentTiming(f func())</pre> <p>WithDataIndependentTiming enables architecture specific features which ensure that the timing of specific instructions is independent of their inputs before executing f. On f returning it disables these features. </p>
<p>WithDataIndependentTiming should only be used when f is written to make use of constant-time operations. WithDataIndependentTiming does not make variable-time code constant-time. </p>
<p>WithDataIndependentTiming may lock the current goroutine to the OS thread for the duration of f. Calls to WithDataIndependentTiming may be nested. </p>
<p>On Arm64 processors with FEAT_DIT, WithDataIndependentTiming enables PSTATE.DIT. See <a href="https://developer.arm.com/documentation/ka005181/1-0/?lang=en">https://developer.arm.com/documentation/ka005181/1-0/?lang=en</a>. </p>
<p>Currently, on all other architectures WithDataIndependentTiming executes f immediately with no other side-effects. </p>
<h2 id="XORBytes">func <span>XORBytes</span>  <span title="Added in Go 1.20">1.20</span> </h2> <pre data-language="go">func XORBytes(dst, x, y []byte) int</pre> <p>XORBytes sets dst[i] = x[i] ^ y[i] for all i &lt; n = min(len(x), len(y)), returning n, the number of bytes written to dst. </p>
<p>If dst does not have length at least n, XORBytes panics without writing anything to dst. </p>
<p>dst and x or y may overlap exactly or not at all, otherwise XORBytes may panic. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/crypto/subtle/" class="_attribution-link">http://golang.org/pkg/crypto/subtle/</a>
  </p>
</div>
