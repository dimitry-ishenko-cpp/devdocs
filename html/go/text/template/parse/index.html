<h1> Package parse  </h1>     <ul id="short-nav">
<li><code>import "text/template/parse"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package parse builds parse trees for templates as defined by text/template and html/template. Clients should use those packages to construct templates rather than this one, which provides shared internal data structures not intended for general use. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#IsEmptyTree">func IsEmptyTree(n Node) bool</a></li>
<li><a href="#Parse">func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)</a></li>
<li><a href="#ActionNode">type ActionNode</a></li>
<li> <a href="#ActionNode.Copy">func (a *ActionNode) Copy() Node</a>
</li>
<li> <a href="#ActionNode.String">func (a *ActionNode) String() string</a>
</li>
<li><a href="#BoolNode">type BoolNode</a></li>
<li> <a href="#BoolNode.Copy">func (b *BoolNode) Copy() Node</a>
</li>
<li> <a href="#BoolNode.String">func (b *BoolNode) String() string</a>
</li>
<li><a href="#BranchNode">type BranchNode</a></li>
<li> <a href="#BranchNode.Copy">func (b *BranchNode) Copy() Node</a>
</li>
<li> <a href="#BranchNode.String">func (b *BranchNode) String() string</a>
</li>
<li><a href="#BreakNode">type BreakNode</a></li>
<li> <a href="#BreakNode.Copy">func (b *BreakNode) Copy() Node</a>
</li>
<li> <a href="#BreakNode.String">func (b *BreakNode) String() string</a>
</li>
<li><a href="#ChainNode">type ChainNode</a></li>
<li> <a href="#ChainNode.Add">func (c *ChainNode) Add(field string)</a>
</li>
<li> <a href="#ChainNode.Copy">func (c *ChainNode) Copy() Node</a>
</li>
<li> <a href="#ChainNode.String">func (c *ChainNode) String() string</a>
</li>
<li><a href="#CommandNode">type CommandNode</a></li>
<li> <a href="#CommandNode.Copy">func (c *CommandNode) Copy() Node</a>
</li>
<li> <a href="#CommandNode.String">func (c *CommandNode) String() string</a>
</li>
<li><a href="#CommentNode">type CommentNode</a></li>
<li> <a href="#CommentNode.Copy">func (c *CommentNode) Copy() Node</a>
</li>
<li> <a href="#CommentNode.String">func (c *CommentNode) String() string</a>
</li>
<li><a href="#ContinueNode">type ContinueNode</a></li>
<li> <a href="#ContinueNode.Copy">func (c *ContinueNode) Copy() Node</a>
</li>
<li> <a href="#ContinueNode.String">func (c *ContinueNode) String() string</a>
</li>
<li><a href="#DotNode">type DotNode</a></li>
<li> <a href="#DotNode.Copy">func (d *DotNode) Copy() Node</a>
</li>
<li> <a href="#DotNode.String">func (d *DotNode) String() string</a>
</li>
<li> <a href="#DotNode.Type">func (d *DotNode) Type() NodeType</a>
</li>
<li><a href="#FieldNode">type FieldNode</a></li>
<li> <a href="#FieldNode.Copy">func (f *FieldNode) Copy() Node</a>
</li>
<li> <a href="#FieldNode.String">func (f *FieldNode) String() string</a>
</li>
<li><a href="#IdentifierNode">type IdentifierNode</a></li>
<li> <a href="#NewIdentifier">func NewIdentifier(ident string) *IdentifierNode</a>
</li>
<li> <a href="#IdentifierNode.Copy">func (i *IdentifierNode) Copy() Node</a>
</li>
<li> <a href="#IdentifierNode.SetPos">func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode</a>
</li>
<li> <a href="#IdentifierNode.SetTree">func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode</a>
</li>
<li> <a href="#IdentifierNode.String">func (i *IdentifierNode) String() string</a>
</li>
<li><a href="#IfNode">type IfNode</a></li>
<li> <a href="#IfNode.Copy">func (i *IfNode) Copy() Node</a>
</li>
<li><a href="#ListNode">type ListNode</a></li>
<li> <a href="#ListNode.Copy">func (l *ListNode) Copy() Node</a>
</li>
<li> <a href="#ListNode.CopyList">func (l *ListNode) CopyList() *ListNode</a>
</li>
<li> <a href="#ListNode.String">func (l *ListNode) String() string</a>
</li>
<li><a href="#Mode">type Mode</a></li>
<li><a href="#NilNode">type NilNode</a></li>
<li> <a href="#NilNode.Copy">func (n *NilNode) Copy() Node</a>
</li>
<li> <a href="#NilNode.String">func (n *NilNode) String() string</a>
</li>
<li> <a href="#NilNode.Type">func (n *NilNode) Type() NodeType</a>
</li>
<li><a href="#Node">type Node</a></li>
<li><a href="#NodeType">type NodeType</a></li>
<li> <a href="#NodeType.Type">func (t NodeType) Type() NodeType</a>
</li>
<li><a href="#NumberNode">type NumberNode</a></li>
<li> <a href="#NumberNode.Copy">func (n *NumberNode) Copy() Node</a>
</li>
<li> <a href="#NumberNode.String">func (n *NumberNode) String() string</a>
</li>
<li><a href="#PipeNode">type PipeNode</a></li>
<li> <a href="#PipeNode.Copy">func (p *PipeNode) Copy() Node</a>
</li>
<li> <a href="#PipeNode.CopyPipe">func (p *PipeNode) CopyPipe() *PipeNode</a>
</li>
<li> <a href="#PipeNode.String">func (p *PipeNode) String() string</a>
</li>
<li><a href="#Pos">type Pos</a></li>
<li> <a href="#Pos.Position">func (p Pos) Position() Pos</a>
</li>
<li><a href="#RangeNode">type RangeNode</a></li>
<li> <a href="#RangeNode.Copy">func (r *RangeNode) Copy() Node</a>
</li>
<li><a href="#StringNode">type StringNode</a></li>
<li> <a href="#StringNode.Copy">func (s *StringNode) Copy() Node</a>
</li>
<li> <a href="#StringNode.String">func (s *StringNode) String() string</a>
</li>
<li><a href="#TemplateNode">type TemplateNode</a></li>
<li> <a href="#TemplateNode.Copy">func (t *TemplateNode) Copy() Node</a>
</li>
<li> <a href="#TemplateNode.String">func (t *TemplateNode) String() string</a>
</li>
<li><a href="#TextNode">type TextNode</a></li>
<li> <a href="#TextNode.Copy">func (t *TextNode) Copy() Node</a>
</li>
<li> <a href="#TextNode.String">func (t *TextNode) String() string</a>
</li>
<li><a href="#Tree">type Tree</a></li>
<li> <a href="#New">func New(name string, funcs ...map[string]any) *Tree</a>
</li>
<li> <a href="#Tree.Copy">func (t *Tree) Copy() *Tree</a>
</li>
<li> <a href="#Tree.ErrorContext">func (t *Tree) ErrorContext(n Node) (location, context string)</a>
</li>
<li> <a href="#Tree.Parse">func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error)</a>
</li>
<li><a href="#VariableNode">type VariableNode</a></li>
<li> <a href="#VariableNode.Copy">func (v *VariableNode) Copy() Node</a>
</li>
<li> <a href="#VariableNode.String">func (v *VariableNode) String() string</a>
</li>
<li><a href="#WithNode">type WithNode</a></li>
<li> <a href="#WithNode.Copy">func (w *WithNode) Copy() Node</a>
</li>
</ul> <h3>Package files</h3> <p>  <span>lex.go</span> <span>node.go</span> <span>parse.go</span>  </p>   <h2 id="IsEmptyTree">func <span>IsEmptyTree</span>  </h2> <pre data-language="go">func IsEmptyTree(n Node) bool</pre> <p>IsEmptyTree reports whether this tree (node) is empty of everything but space or comments. </p>
<h2 id="Parse">func <span>Parse</span>  </h2> <pre data-language="go">func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]any) (map[string]*Tree, error)</pre> <p>Parse returns a map from template name to <a href="#Tree">Tree</a>, created by parsing the templates described in the argument string. The top-level template will be given the specified name. If an error is encountered, parsing stops and an empty map is returned with the error. </p>
<h2 id="ActionNode">type <span>ActionNode</span>  </h2> <p>ActionNode holds an action (something bounded by delimiters). Control actions have their own nodes; ActionNode represents simple ones such as field evaluations and parenthesized pipelines. </p>
<pre data-language="go">type ActionNode struct {
    NodeType
    Pos

    Line int       // The line number in the input. Deprecated: Kept for compatibility.
    Pipe *PipeNode // The pipeline in the action.
    // contains filtered or unexported fields
}
</pre> <h3 id="ActionNode.Copy">func (*ActionNode) <span>Copy</span>  </h3> <pre data-language="go">func (a *ActionNode) Copy() Node</pre> <h3 id="ActionNode.String">func (*ActionNode) <span>String</span>  </h3> <pre data-language="go">func (a *ActionNode) String() string</pre> <h2 id="BoolNode">type <span>BoolNode</span>  </h2> <p>BoolNode holds a boolean constant. </p>
<pre data-language="go">type BoolNode struct {
    NodeType
    Pos

    True bool // The value of the boolean constant.
    // contains filtered or unexported fields
}
</pre> <h3 id="BoolNode.Copy">func (*BoolNode) <span>Copy</span>  </h3> <pre data-language="go">func (b *BoolNode) Copy() Node</pre> <h3 id="BoolNode.String">func (*BoolNode) <span>String</span>  </h3> <pre data-language="go">func (b *BoolNode) String() string</pre> <h2 id="BranchNode">type <span>BranchNode</span>  </h2> <p>BranchNode is the common representation of if, range, and with. </p>
<pre data-language="go">type BranchNode struct {
    NodeType
    Pos

    Line     int       // The line number in the input. Deprecated: Kept for compatibility.
    Pipe     *PipeNode // The pipeline to be evaluated.
    List     *ListNode // What to execute if the value is non-empty.
    ElseList *ListNode // What to execute if the value is empty (nil if absent).
    // contains filtered or unexported fields
}
</pre> <h3 id="BranchNode.Copy">func (*BranchNode) <span>Copy</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (b *BranchNode) Copy() Node</pre> <h3 id="BranchNode.String">func (*BranchNode) <span>String</span>  </h3> <pre data-language="go">func (b *BranchNode) String() string</pre> <h2 id="BreakNode">type <span>BreakNode</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>BreakNode represents a {{break}} action. </p>
<pre data-language="go">type BreakNode struct {
    NodeType
    Pos
    Line int
    // contains filtered or unexported fields
}
</pre> <h3 id="BreakNode.Copy">func (*BreakNode) <span>Copy</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (b *BreakNode) Copy() Node</pre> <h3 id="BreakNode.String">func (*BreakNode) <span>String</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (b *BreakNode) String() string</pre> <h2 id="ChainNode">type <span>ChainNode</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>ChainNode holds a term followed by a chain of field accesses (identifier starting with '.'). The names may be chained ('.x.y'). The periods are dropped from each ident. </p>
<pre data-language="go">type ChainNode struct {
    NodeType
    Pos

    Node  Node
    Field []string // The identifiers in lexical order.
    // contains filtered or unexported fields
}
</pre> <h3 id="ChainNode.Add">func (*ChainNode) <span>Add</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *ChainNode) Add(field string)</pre> <p>Add adds the named field (which should start with a period) to the end of the chain. </p>
<h3 id="ChainNode.Copy">func (*ChainNode) <span>Copy</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *ChainNode) Copy() Node</pre> <h3 id="ChainNode.String">func (*ChainNode) <span>String</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *ChainNode) String() string</pre> <h2 id="CommandNode">type <span>CommandNode</span>  </h2> <p>CommandNode holds a command (a pipeline inside an evaluating action). </p>
<pre data-language="go">type CommandNode struct {
    NodeType
    Pos

    Args []Node // Arguments in lexical order: Identifier, field, or constant.
    // contains filtered or unexported fields
}
</pre> <h3 id="CommandNode.Copy">func (*CommandNode) <span>Copy</span>  </h3> <pre data-language="go">func (c *CommandNode) Copy() Node</pre> <h3 id="CommandNode.String">func (*CommandNode) <span>String</span>  </h3> <pre data-language="go">func (c *CommandNode) String() string</pre> <h2 id="CommentNode">type <span>CommentNode</span>  <span title="Added in Go 1.16">1.16</span> </h2> <p>CommentNode holds a comment. </p>
<pre data-language="go">type CommentNode struct {
    NodeType
    Pos

    Text string // Comment text.
    // contains filtered or unexported fields
}
</pre> <h3 id="CommentNode.Copy">func (*CommentNode) <span>Copy</span>  <span title="Added in Go 1.16">1.16</span> </h3> <pre data-language="go">func (c *CommentNode) Copy() Node</pre> <h3 id="CommentNode.String">func (*CommentNode) <span>String</span>  <span title="Added in Go 1.16">1.16</span> </h3> <pre data-language="go">func (c *CommentNode) String() string</pre> <h2 id="ContinueNode">type <span>ContinueNode</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>ContinueNode represents a {{continue}} action. </p>
<pre data-language="go">type ContinueNode struct {
    NodeType
    Pos
    Line int
    // contains filtered or unexported fields
}
</pre> <h3 id="ContinueNode.Copy">func (*ContinueNode) <span>Copy</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *ContinueNode) Copy() Node</pre> <h3 id="ContinueNode.String">func (*ContinueNode) <span>String</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *ContinueNode) String() string</pre> <h2 id="DotNode">type <span>DotNode</span>  </h2> <p>DotNode holds the special identifier '.'. </p>
<pre data-language="go">type DotNode struct {
    NodeType
    Pos
    // contains filtered or unexported fields
}
</pre> <h3 id="DotNode.Copy">func (*DotNode) <span>Copy</span>  </h3> <pre data-language="go">func (d *DotNode) Copy() Node</pre> <h3 id="DotNode.String">func (*DotNode) <span>String</span>  </h3> <pre data-language="go">func (d *DotNode) String() string</pre> <h3 id="DotNode.Type">func (*DotNode) <span>Type</span>  </h3> <pre data-language="go">func (d *DotNode) Type() NodeType</pre> <h2 id="FieldNode">type <span>FieldNode</span>  </h2> <p>FieldNode holds a field (identifier starting with '.'). The names may be chained ('.x.y'). The period is dropped from each ident. </p>
<pre data-language="go">type FieldNode struct {
    NodeType
    Pos

    Ident []string // The identifiers in lexical order.
    // contains filtered or unexported fields
}
</pre> <h3 id="FieldNode.Copy">func (*FieldNode) <span>Copy</span>  </h3> <pre data-language="go">func (f *FieldNode) Copy() Node</pre> <h3 id="FieldNode.String">func (*FieldNode) <span>String</span>  </h3> <pre data-language="go">func (f *FieldNode) String() string</pre> <h2 id="IdentifierNode">type <span>IdentifierNode</span>  </h2> <p>IdentifierNode holds an identifier. </p>
<pre data-language="go">type IdentifierNode struct {
    NodeType
    Pos

    Ident string // The identifier's name.
    // contains filtered or unexported fields
}
</pre> <h3 id="NewIdentifier">func <span>NewIdentifier</span>  </h3> <pre data-language="go">func NewIdentifier(ident string) *IdentifierNode</pre> <p>NewIdentifier returns a new <a href="#IdentifierNode">IdentifierNode</a> with the given identifier name. </p>
<h3 id="IdentifierNode.Copy">func (*IdentifierNode) <span>Copy</span>  </h3> <pre data-language="go">func (i *IdentifierNode) Copy() Node</pre> <h3 id="IdentifierNode.SetPos">func (*IdentifierNode) <span>SetPos</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode</pre> <p>SetPos sets the position. <a href="#NewIdentifier">NewIdentifier</a> is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? </p>
<h3 id="IdentifierNode.SetTree">func (*IdentifierNode) <span>SetTree</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode</pre> <p>SetTree sets the parent tree for the node. <a href="#NewIdentifier">NewIdentifier</a> is a public method so we can't modify its signature. Chained for convenience. TODO: fix one day? </p>
<h3 id="IdentifierNode.String">func (*IdentifierNode) <span>String</span>  </h3> <pre data-language="go">func (i *IdentifierNode) String() string</pre> <h2 id="IfNode">type <span>IfNode</span>  </h2> <p>IfNode represents an {{if}} action and its commands. </p>
<pre data-language="go">type IfNode struct {
    BranchNode
}
</pre> <h3 id="IfNode.Copy">func (*IfNode) <span>Copy</span>  </h3> <pre data-language="go">func (i *IfNode) Copy() Node</pre> <h2 id="ListNode">type <span>ListNode</span>  </h2> <p>ListNode holds a sequence of nodes. </p>
<pre data-language="go">type ListNode struct {
    NodeType
    Pos

    Nodes []Node // The element nodes in lexical order.
    // contains filtered or unexported fields
}
</pre> <h3 id="ListNode.Copy">func (*ListNode) <span>Copy</span>  </h3> <pre data-language="go">func (l *ListNode) Copy() Node</pre> <h3 id="ListNode.CopyList">func (*ListNode) <span>CopyList</span>  </h3> <pre data-language="go">func (l *ListNode) CopyList() *ListNode</pre> <h3 id="ListNode.String">func (*ListNode) <span>String</span>  </h3> <pre data-language="go">func (l *ListNode) String() string</pre> <h2 id="Mode">type <span>Mode</span>  <span title="Added in Go 1.16">1.16</span> </h2> <p>A mode value is a set of flags (or 0). Modes control parser behavior. </p>
<pre data-language="go">type Mode uint</pre> <pre data-language="go">const (
    ParseComments Mode = 1 &lt;&lt; iota // parse comments and add them to AST
    SkipFuncCheck                  // do not check that functions are defined
)</pre> <h2 id="NilNode">type <span>NilNode</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>NilNode holds the special identifier 'nil' representing an untyped nil constant. </p>
<pre data-language="go">type NilNode struct {
    NodeType
    Pos
    // contains filtered or unexported fields
}
</pre> <h3 id="NilNode.Copy">func (*NilNode) <span>Copy</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (n *NilNode) Copy() Node</pre> <h3 id="NilNode.String">func (*NilNode) <span>String</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (n *NilNode) String() string</pre> <h3 id="NilNode.Type">func (*NilNode) <span>Type</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (n *NilNode) Type() NodeType</pre> <h2 id="Node">type <span>Node</span>  </h2> <p>A Node is an element in the parse tree. The interface is trivial. The interface contains an unexported method so that only types local to this package can satisfy it. </p>
<pre data-language="go">type Node interface {
    Type() NodeType
    String() string
    // Copy does a deep copy of the Node and all its components.
    // To avoid type assertions, some XxxNodes also have specialized
    // CopyXxx methods that return *XxxNode.
    Copy() Node
    Position() Pos // byte position of start of node in full original input string
    // contains filtered or unexported methods
}</pre> <h2 id="NodeType">type <span>NodeType</span>  </h2> <p>NodeType identifies the type of a parse tree node. </p>
<pre data-language="go">type NodeType int</pre> <pre data-language="go">const (
    NodeText    NodeType = iota // Plain text.
    NodeAction                  // A non-control action such as a field evaluation.
    NodeBool                    // A boolean constant.
    NodeChain                   // A sequence of field accesses.
    NodeCommand                 // An element of a pipeline.
    NodeDot                     // The cursor, dot.

    NodeField      // A field or method name.
    NodeIdentifier // An identifier; always a function name.
    NodeIf         // An if action.
    NodeList       // A list of Nodes.
    NodeNil        // An untyped nil constant.
    NodeNumber     // A numerical constant.
    NodePipe       // A pipeline of commands.
    NodeRange      // A range action.
    NodeString     // A string constant.
    NodeTemplate   // A template invocation action.
    NodeVariable   // A $ variable.
    NodeWith       // A with action.
    NodeComment    // A comment.
    NodeBreak      // A break action.
    NodeContinue   // A continue action.
)</pre> <h3 id="NodeType.Type">func (NodeType) <span>Type</span>  </h3> <pre data-language="go">func (t NodeType) Type() NodeType</pre> <p>Type returns itself and provides an easy default implementation for embedding in a Node. Embedded in all non-trivial Nodes. </p>
<h2 id="NumberNode">type <span>NumberNode</span>  </h2> <p>NumberNode holds a number: signed or unsigned integer, float, or complex. The value is parsed and stored under all the types that can represent the value. This simulates in a small amount of code the behavior of Go's ideal constants. </p>
<pre data-language="go">type NumberNode struct {
    NodeType
    Pos

    IsInt      bool       // Number has an integral value.
    IsUint     bool       // Number has an unsigned integral value.
    IsFloat    bool       // Number has a floating-point value.
    IsComplex  bool       // Number is complex.
    Int64      int64      // The signed integer value.
    Uint64     uint64     // The unsigned integer value.
    Float64    float64    // The floating-point value.
    Complex128 complex128 // The complex value.
    Text       string     // The original textual representation from the input.
    // contains filtered or unexported fields
}
</pre> <h3 id="NumberNode.Copy">func (*NumberNode) <span>Copy</span>  </h3> <pre data-language="go">func (n *NumberNode) Copy() Node</pre> <h3 id="NumberNode.String">func (*NumberNode) <span>String</span>  </h3> <pre data-language="go">func (n *NumberNode) String() string</pre> <h2 id="PipeNode">type <span>PipeNode</span>  </h2> <p>PipeNode holds a pipeline with optional declaration </p>
<pre data-language="go">type PipeNode struct {
    NodeType
    Pos

    Line     int             // The line number in the input. Deprecated: Kept for compatibility.
    IsAssign bool            // The variables are being assigned, not declared; added in Go 1.11
    Decl     []*VariableNode // Variables in lexical order.
    Cmds     []*CommandNode  // The commands in lexical order.
    // contains filtered or unexported fields
}
</pre> <h3 id="PipeNode.Copy">func (*PipeNode) <span>Copy</span>  </h3> <pre data-language="go">func (p *PipeNode) Copy() Node</pre> <h3 id="PipeNode.CopyPipe">func (*PipeNode) <span>CopyPipe</span>  </h3> <pre data-language="go">func (p *PipeNode) CopyPipe() *PipeNode</pre> <h3 id="PipeNode.String">func (*PipeNode) <span>String</span>  </h3> <pre data-language="go">func (p *PipeNode) String() string</pre> <h2 id="Pos">type <span>Pos</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>Pos represents a byte position in the original input text from which this template was parsed. </p>
<pre data-language="go">type Pos int</pre> <h3 id="Pos.Position">func (Pos) <span>Position</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (p Pos) Position() Pos</pre> <h2 id="RangeNode">type <span>RangeNode</span>  </h2> <p>RangeNode represents a {{range}} action and its commands. </p>
<pre data-language="go">type RangeNode struct {
    BranchNode
}
</pre> <h3 id="RangeNode.Copy">func (*RangeNode) <span>Copy</span>  </h3> <pre data-language="go">func (r *RangeNode) Copy() Node</pre> <h2 id="StringNode">type <span>StringNode</span>  </h2> <p>StringNode holds a string constant. The value has been "unquoted". </p>
<pre data-language="go">type StringNode struct {
    NodeType
    Pos

    Quoted string // The original text of the string, with quotes.
    Text   string // The string, after quote processing.
    // contains filtered or unexported fields
}
</pre> <h3 id="StringNode.Copy">func (*StringNode) <span>Copy</span>  </h3> <pre data-language="go">func (s *StringNode) Copy() Node</pre> <h3 id="StringNode.String">func (*StringNode) <span>String</span>  </h3> <pre data-language="go">func (s *StringNode) String() string</pre> <h2 id="TemplateNode">type <span>TemplateNode</span>  </h2> <p>TemplateNode represents a {{template}} action. </p>
<pre data-language="go">type TemplateNode struct {
    NodeType
    Pos

    Line int       // The line number in the input. Deprecated: Kept for compatibility.
    Name string    // The name of the template (unquoted).
    Pipe *PipeNode // The command to evaluate as dot for the template.
    // contains filtered or unexported fields
}
</pre> <h3 id="TemplateNode.Copy">func (*TemplateNode) <span>Copy</span>  </h3> <pre data-language="go">func (t *TemplateNode) Copy() Node</pre> <h3 id="TemplateNode.String">func (*TemplateNode) <span>String</span>  </h3> <pre data-language="go">func (t *TemplateNode) String() string</pre> <h2 id="TextNode">type <span>TextNode</span>  </h2> <p>TextNode holds plain text. </p>
<pre data-language="go">type TextNode struct {
    NodeType
    Pos

    Text []byte // The text; may span newlines.
    // contains filtered or unexported fields
}
</pre> <h3 id="TextNode.Copy">func (*TextNode) <span>Copy</span>  </h3> <pre data-language="go">func (t *TextNode) Copy() Node</pre> <h3 id="TextNode.String">func (*TextNode) <span>String</span>  </h3> <pre data-language="go">func (t *TextNode) String() string</pre> <h2 id="Tree">type <span>Tree</span>  </h2> <p>Tree is the representation of a single parsed template. </p>
<pre data-language="go">type Tree struct {
    Name      string    // name of the template represented by the tree.
    ParseName string    // name of the top-level template during parsing, for error messages; added in Go 1.1
    Root      *ListNode // top-level root of the tree.
    Mode      Mode      // parsing mode; added in Go 1.16
    // contains filtered or unexported fields
}
</pre> <h3 id="New">func <span>New</span>  </h3> <pre data-language="go">func New(name string, funcs ...map[string]any) *Tree</pre> <p>New allocates a new parse tree with the given name. </p>
<h3 id="Tree.Copy">func (*Tree) <span>Copy</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (t *Tree) Copy() *Tree</pre> <p>Copy returns a copy of the <a href="#Tree">Tree</a>. Any parsing state is discarded. </p>
<h3 id="Tree.ErrorContext">func (*Tree) <span>ErrorContext</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (t *Tree) ErrorContext(n Node) (location, context string)</pre> <p>ErrorContext returns a textual representation of the location of the node in the input text. The receiver is only used when the node does not have a pointer to the tree inside, which can occur in old code. </p>
<h3 id="Tree.Parse">func (*Tree) <span>Parse</span>  </h3> <pre data-language="go">func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]any) (tree *Tree, err error)</pre> <p>Parse parses the template definition string to construct a representation of the template for execution. If either action delimiter string is empty, the default ("{{" or "}}") is used. Embedded template definitions are added to the treeSet map. </p>
<h2 id="VariableNode">type <span>VariableNode</span>  </h2> <p>VariableNode holds a list of variable names, possibly with chained field accesses. The dollar sign is part of the (first) name. </p>
<pre data-language="go">type VariableNode struct {
    NodeType
    Pos

    Ident []string // Variable name and fields in lexical order.
    // contains filtered or unexported fields
}
</pre> <h3 id="VariableNode.Copy">func (*VariableNode) <span>Copy</span>  </h3> <pre data-language="go">func (v *VariableNode) Copy() Node</pre> <h3 id="VariableNode.String">func (*VariableNode) <span>String</span>  </h3> <pre data-language="go">func (v *VariableNode) String() string</pre> <h2 id="WithNode">type <span>WithNode</span>  </h2> <p>WithNode represents a {{with}} action and its commands. </p>
<pre data-language="go">type WithNode struct {
    BranchNode
}
</pre> <h3 id="WithNode.Copy">func (*WithNode) <span>Copy</span>  </h3> <pre data-language="go">func (w *WithNode) Copy() Node</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/text/template/parse/" class="_attribution-link">http://golang.org/pkg/text/template/parse/</a>
  </p>
</div>
