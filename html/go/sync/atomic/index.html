<h1> Package atomic  </h1>     <ul id="short-nav">
<li><code>import "sync/atomic"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package atomic provides low-level atomic memory primitives useful for implementing synchronization algorithms. </p>
<p>These functions require great care to be used correctly. Except for special, low-level applications, synchronization is better done with channels or the facilities of the <span>sync</span> package. Share memory by communicating; don't communicate by sharing memory. </p>
<p>The swap operation, implemented by the SwapT functions, is the atomic equivalent of: </p>
<pre data-language="go">old = *addr
*addr = new
return old
</pre> <p>The compare-and-swap operation, implemented by the CompareAndSwapT functions, is the atomic equivalent of: </p>
<pre data-language="go">if *addr == old {
	*addr = new
	return true
}
return false
</pre> <p>The add operation, implemented by the AddT functions, is the atomic equivalent of: </p>
<pre data-language="go">*addr += delta
return *addr
</pre> <p>The load and store operations, implemented by the LoadT and StoreT functions, are the atomic equivalents of "return *addr" and "*addr = val". </p>
<p>In the terminology of <a href="https://go.dev/ref/mem">the Go memory model</a>, if the effect of an atomic operation A is observed by atomic operation B, then A “synchronizes before” B. Additionally, all the atomic operations executed in a program behave as though executed in some sequentially consistent order. This definition provides the same semantics as C++'s sequentially consistent atomics and Java's volatile variables. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></li>
<li><a href="#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></li>
<li><a href="#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></li>
<li><a href="#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></li>
<li><a href="#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></li>
<li><a href="#AndInt32">func AndInt32(addr *int32, mask int32) (old int32)</a></li>
<li><a href="#AndInt64">func AndInt64(addr *int64, mask int64) (old int64)</a></li>
<li><a href="#AndUint32">func AndUint32(addr *uint32, mask uint32) (old uint32)</a></li>
<li><a href="#AndUint64">func AndUint64(addr *uint64, mask uint64) (old uint64)</a></li>
<li><a href="#AndUintptr">func AndUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></li>
<li><a href="#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></li>
<li><a href="#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></li>
<li><a href="#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></li>
<li><a href="#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></li>
<li><a href="#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></li>
<li><a href="#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></li>
<li><a href="#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></li>
<li><a href="#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></li>
<li><a href="#OrInt32">func OrInt32(addr *int32, mask int32) (old int32)</a></li>
<li><a href="#OrInt64">func OrInt64(addr *int64, mask int64) (old int64)</a></li>
<li><a href="#OrUint32">func OrUint32(addr *uint32, mask uint32) (old uint32)</a></li>
<li><a href="#OrUint64">func OrUint64(addr *uint64, mask uint64) (old uint64)</a></li>
<li><a href="#OrUintptr">func OrUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></li>
<li><a href="#StoreInt32">func StoreInt32(addr *int32, val int32)</a></li>
<li><a href="#StoreInt64">func StoreInt64(addr *int64, val int64)</a></li>
<li><a href="#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></li>
<li><a href="#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></li>
<li><a href="#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></li>
<li><a href="#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></li>
<li><a href="#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></li>
<li><a href="#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></li>
<li><a href="#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></li>
<li><a href="#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></li>
<li><a href="#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></li>
<li><a href="#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></li>
<li><a href="#Bool">type Bool</a></li>
<li> <a href="#Bool.CompareAndSwap">func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)</a>
</li>
<li> <a href="#Bool.Load">func (x *Bool) Load() bool</a>
</li>
<li> <a href="#Bool.Store">func (x *Bool) Store(val bool)</a>
</li>
<li> <a href="#Bool.Swap">func (x *Bool) Swap(new bool) (old bool)</a>
</li>
<li><a href="#Int32">type Int32</a></li>
<li> <a href="#Int32.Add">func (x *Int32) Add(delta int32) (new int32)</a>
</li>
<li> <a href="#Int32.And">func (x *Int32) And(mask int32) (old int32)</a>
</li>
<li> <a href="#Int32.CompareAndSwap">func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)</a>
</li>
<li> <a href="#Int32.Load">func (x *Int32) Load() int32</a>
</li>
<li> <a href="#Int32.Or">func (x *Int32) Or(mask int32) (old int32)</a>
</li>
<li> <a href="#Int32.Store">func (x *Int32) Store(val int32)</a>
</li>
<li> <a href="#Int32.Swap">func (x *Int32) Swap(new int32) (old int32)</a>
</li>
<li><a href="#Int64">type Int64</a></li>
<li> <a href="#Int64.Add">func (x *Int64) Add(delta int64) (new int64)</a>
</li>
<li> <a href="#Int64.And">func (x *Int64) And(mask int64) (old int64)</a>
</li>
<li> <a href="#Int64.CompareAndSwap">func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)</a>
</li>
<li> <a href="#Int64.Load">func (x *Int64) Load() int64</a>
</li>
<li> <a href="#Int64.Or">func (x *Int64) Or(mask int64) (old int64)</a>
</li>
<li> <a href="#Int64.Store">func (x *Int64) Store(val int64)</a>
</li>
<li> <a href="#Int64.Swap">func (x *Int64) Swap(new int64) (old int64)</a>
</li>
<li><a href="#Pointer">type Pointer</a></li>
<li> <a href="#Pointer.CompareAndSwap">func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)</a>
</li>
<li> <a href="#Pointer.Load">func (x *Pointer[T]) Load() *T</a>
</li>
<li> <a href="#Pointer.Store">func (x *Pointer[T]) Store(val *T)</a>
</li>
<li> <a href="#Pointer.Swap">func (x *Pointer[T]) Swap(new *T) (old *T)</a>
</li>
<li><a href="#Uint32">type Uint32</a></li>
<li> <a href="#Uint32.Add">func (x *Uint32) Add(delta uint32) (new uint32)</a>
</li>
<li> <a href="#Uint32.And">func (x *Uint32) And(mask uint32) (old uint32)</a>
</li>
<li> <a href="#Uint32.CompareAndSwap">func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)</a>
</li>
<li> <a href="#Uint32.Load">func (x *Uint32) Load() uint32</a>
</li>
<li> <a href="#Uint32.Or">func (x *Uint32) Or(mask uint32) (old uint32)</a>
</li>
<li> <a href="#Uint32.Store">func (x *Uint32) Store(val uint32)</a>
</li>
<li> <a href="#Uint32.Swap">func (x *Uint32) Swap(new uint32) (old uint32)</a>
</li>
<li><a href="#Uint64">type Uint64</a></li>
<li> <a href="#Uint64.Add">func (x *Uint64) Add(delta uint64) (new uint64)</a>
</li>
<li> <a href="#Uint64.And">func (x *Uint64) And(mask uint64) (old uint64)</a>
</li>
<li> <a href="#Uint64.CompareAndSwap">func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)</a>
</li>
<li> <a href="#Uint64.Load">func (x *Uint64) Load() uint64</a>
</li>
<li> <a href="#Uint64.Or">func (x *Uint64) Or(mask uint64) (old uint64)</a>
</li>
<li> <a href="#Uint64.Store">func (x *Uint64) Store(val uint64)</a>
</li>
<li> <a href="#Uint64.Swap">func (x *Uint64) Swap(new uint64) (old uint64)</a>
</li>
<li><a href="#Uintptr">type Uintptr</a></li>
<li> <a href="#Uintptr.Add">func (x *Uintptr) Add(delta uintptr) (new uintptr)</a>
</li>
<li> <a href="#Uintptr.And">func (x *Uintptr) And(mask uintptr) (old uintptr)</a>
</li>
<li> <a href="#Uintptr.CompareAndSwap">func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)</a>
</li>
<li> <a href="#Uintptr.Load">func (x *Uintptr) Load() uintptr</a>
</li>
<li> <a href="#Uintptr.Or">func (x *Uintptr) Or(mask uintptr) (old uintptr)</a>
</li>
<li> <a href="#Uintptr.Store">func (x *Uintptr) Store(val uintptr)</a>
</li>
<li> <a href="#Uintptr.Swap">func (x *Uintptr) Swap(new uintptr) (old uintptr)</a>
</li>
<li><a href="#Value">type Value</a></li>
<li> <a href="#Value.CompareAndSwap">func (v *Value) CompareAndSwap(old, new any) (swapped bool)</a>
</li>
<li> <a href="#Value.Load">func (v *Value) Load() (val any)</a>
</li>
<li> <a href="#Value.Store">func (v *Value) Store(val any)</a>
</li>
<li> <a href="#Value.Swap">func (v *Value) Swap(new any) (old any)</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Value_config">Value (Config)</a></dd> <dd><a class="exampleLink" href="#example_Value_readMostly">Value (ReadMostly)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>doc.go</span> <span>type.go</span> <span>value.go</span>  </p>   <h2 id="AddInt32">func <span>AddInt32</span>  </h2> <pre data-language="go">func AddInt32(addr *int32, delta int32) (new int32)</pre> <p>AddInt32 atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone <a href="#Int32.Add">Int32.Add</a> instead. </p>
<h2 id="AddInt64">func <span>AddInt64</span>  </h2> <pre data-language="go">func AddInt64(addr *int64, delta int64) (new int64)</pre> <p>AddInt64 atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone <a href="#Int64.Add">Int64.Add</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="AddUint32">func <span>AddUint32</span>  </h2> <pre data-language="go">func AddUint32(addr *uint32, delta uint32) (new uint32)</pre> <p>AddUint32 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)). In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)). Consider using the more ergonomic and less error-prone <a href="#Uint32.Add">Uint32.Add</a> instead. </p>
<h2 id="AddUint64">func <span>AddUint64</span>  </h2> <pre data-language="go">func AddUint64(addr *uint64, delta uint64) (new uint64)</pre> <p>AddUint64 atomically adds delta to *addr and returns the new value. To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)). In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)). Consider using the more ergonomic and less error-prone <a href="#Uint64.Add">Uint64.Add</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="AddUintptr">func <span>AddUintptr</span>  </h2> <pre data-language="go">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</pre> <p>AddUintptr atomically adds delta to *addr and returns the new value. Consider using the more ergonomic and less error-prone <a href="#Uintptr.Add">Uintptr.Add</a> instead. </p>
<h2 id="AndInt32">func <span>AndInt32</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AndInt32(addr *int32, mask int32) (old int32)</pre> <p>AndInt32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Int32.And">Int32.And</a> instead. </p>
<h2 id="AndInt64">func <span>AndInt64</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AndInt64(addr *int64, mask int64) (old int64)</pre> <p>AndInt64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Int64.And">Int64.And</a> instead. </p>
<h2 id="AndUint32">func <span>AndUint32</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AndUint32(addr *uint32, mask uint32) (old uint32)</pre> <p>AndUint32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Uint32.And">Uint32.And</a> instead. </p>
<h2 id="AndUint64">func <span>AndUint64</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AndUint64(addr *uint64, mask uint64) (old uint64)</pre> <p>AndUint64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old. Consider using the more ergonomic and less error-prone <a href="#Uint64.And">Uint64.And</a> instead. </p>
<h2 id="AndUintptr">func <span>AndUintptr</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AndUintptr(addr *uintptr, mask uintptr) (old uintptr)</pre> <p>AndUintptr atomically performs a bitwise AND operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Uintptr.And">Uintptr.And</a> instead. </p>
<h2 id="CompareAndSwapInt32">func <span>CompareAndSwapInt32</span>  </h2> <pre data-language="go">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</pre> <p>CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value. Consider using the more ergonomic and less error-prone <a href="#Int32.CompareAndSwap">Int32.CompareAndSwap</a> instead. </p>
<h2 id="CompareAndSwapInt64">func <span>CompareAndSwapInt64</span>  </h2> <pre data-language="go">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</pre> <p>CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value. Consider using the more ergonomic and less error-prone <a href="#Int64.CompareAndSwap">Int64.CompareAndSwap</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="CompareAndSwapPointer">func <span>CompareAndSwapPointer</span>  </h2> <pre data-language="go">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</pre> <p>CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value. Consider using the more ergonomic and less error-prone <a href="#Pointer.CompareAndSwap">Pointer.CompareAndSwap</a> instead. </p>
<h2 id="CompareAndSwapUint32">func <span>CompareAndSwapUint32</span>  </h2> <pre data-language="go">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</pre> <p>CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value. Consider using the more ergonomic and less error-prone <a href="#Uint32.CompareAndSwap">Uint32.CompareAndSwap</a> instead. </p>
<h2 id="CompareAndSwapUint64">func <span>CompareAndSwapUint64</span>  </h2> <pre data-language="go">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</pre> <p>CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value. Consider using the more ergonomic and less error-prone <a href="#Uint64.CompareAndSwap">Uint64.CompareAndSwap</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="CompareAndSwapUintptr">func <span>CompareAndSwapUintptr</span>  </h2> <pre data-language="go">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</pre> <p>CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value. Consider using the more ergonomic and less error-prone <a href="#Uintptr.CompareAndSwap">Uintptr.CompareAndSwap</a> instead. </p>
<h2 id="LoadInt32">func <span>LoadInt32</span>  </h2> <pre data-language="go">func LoadInt32(addr *int32) (val int32)</pre> <p>LoadInt32 atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Int32.Load">Int32.Load</a> instead. </p>
<h2 id="LoadInt64">func <span>LoadInt64</span>  </h2> <pre data-language="go">func LoadInt64(addr *int64) (val int64)</pre> <p>LoadInt64 atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Int64.Load">Int64.Load</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="LoadPointer">func <span>LoadPointer</span>  </h2> <pre data-language="go">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</pre> <p>LoadPointer atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Pointer.Load">Pointer.Load</a> instead. </p>
<h2 id="LoadUint32">func <span>LoadUint32</span>  </h2> <pre data-language="go">func LoadUint32(addr *uint32) (val uint32)</pre> <p>LoadUint32 atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Uint32.Load">Uint32.Load</a> instead. </p>
<h2 id="LoadUint64">func <span>LoadUint64</span>  </h2> <pre data-language="go">func LoadUint64(addr *uint64) (val uint64)</pre> <p>LoadUint64 atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Uint64.Load">Uint64.Load</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="LoadUintptr">func <span>LoadUintptr</span>  </h2> <pre data-language="go">func LoadUintptr(addr *uintptr) (val uintptr)</pre> <p>LoadUintptr atomically loads *addr. Consider using the more ergonomic and less error-prone <a href="#Uintptr.Load">Uintptr.Load</a> instead. </p>
<h2 id="OrInt32">func <span>OrInt32</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func OrInt32(addr *int32, mask int32) (old int32)</pre> <p>OrInt32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Int32.Or">Int32.Or</a> instead. </p>
<h2 id="OrInt64">func <span>OrInt64</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func OrInt64(addr *int64, mask int64) (old int64)</pre> <p>OrInt64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Int64.Or">Int64.Or</a> instead. </p>
<h2 id="OrUint32">func <span>OrUint32</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func OrUint32(addr *uint32, mask uint32) (old uint32)</pre> <p>OrUint32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Uint32.Or">Uint32.Or</a> instead. </p>
<h2 id="OrUint64">func <span>OrUint64</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func OrUint64(addr *uint64, mask uint64) (old uint64)</pre> <p>OrUint64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Uint64.Or">Uint64.Or</a> instead. </p>
<h2 id="OrUintptr">func <span>OrUintptr</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func OrUintptr(addr *uintptr, mask uintptr) (old uintptr)</pre> <p>OrUintptr atomically performs a bitwise OR operation on *addr using the bitmask provided as mask and returns the old value. Consider using the more ergonomic and less error-prone <a href="#Uintptr.Or">Uintptr.Or</a> instead. </p>
<h2 id="StoreInt32">func <span>StoreInt32</span>  </h2> <pre data-language="go">func StoreInt32(addr *int32, val int32)</pre> <p>StoreInt32 atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Int32.Store">Int32.Store</a> instead. </p>
<h2 id="StoreInt64">func <span>StoreInt64</span>  </h2> <pre data-language="go">func StoreInt64(addr *int64, val int64)</pre> <p>StoreInt64 atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Int64.Store">Int64.Store</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="StorePointer">func <span>StorePointer</span>  </h2> <pre data-language="go">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</pre> <p>StorePointer atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Pointer.Store">Pointer.Store</a> instead. </p>
<h2 id="StoreUint32">func <span>StoreUint32</span>  </h2> <pre data-language="go">func StoreUint32(addr *uint32, val uint32)</pre> <p>StoreUint32 atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Uint32.Store">Uint32.Store</a> instead. </p>
<h2 id="StoreUint64">func <span>StoreUint64</span>  </h2> <pre data-language="go">func StoreUint64(addr *uint64, val uint64)</pre> <p>StoreUint64 atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Uint64.Store">Uint64.Store</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="StoreUintptr">func <span>StoreUintptr</span>  </h2> <pre data-language="go">func StoreUintptr(addr *uintptr, val uintptr)</pre> <p>StoreUintptr atomically stores val into *addr. Consider using the more ergonomic and less error-prone <a href="#Uintptr.Store">Uintptr.Store</a> instead. </p>
<h2 id="SwapInt32">func <span>SwapInt32</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapInt32(addr *int32, new int32) (old int32)</pre> <p>SwapInt32 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Int32.Swap">Int32.Swap</a> instead. </p>
<h2 id="SwapInt64">func <span>SwapInt64</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapInt64(addr *int64, new int64) (old int64)</pre> <p>SwapInt64 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Int64.Swap">Int64.Swap</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="SwapPointer">func <span>SwapPointer</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</pre> <p>SwapPointer atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Pointer.Swap">Pointer.Swap</a> instead. </p>
<h2 id="SwapUint32">func <span>SwapUint32</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUint32(addr *uint32, new uint32) (old uint32)</pre> <p>SwapUint32 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Uint32.Swap">Uint32.Swap</a> instead. </p>
<h2 id="SwapUint64">func <span>SwapUint64</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUint64(addr *uint64, new uint64) (old uint64)</pre> <p>SwapUint64 atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Uint64.Swap">Uint64.Swap</a> instead (particularly if you target 32-bit platforms; see the bugs section). </p>
<h2 id="SwapUintptr">func <span>SwapUintptr</span>  <span title="Added in Go 1.2">1.2</span> </h2> <pre data-language="go">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</pre> <p>SwapUintptr atomically stores new into *addr and returns the previous *addr value. Consider using the more ergonomic and less error-prone <a href="#Uintptr.Swap">Uintptr.Swap</a> instead. </p>
<h2 id="Bool">type <span>Bool</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>A Bool is an atomic boolean value. The zero value is false. </p>
<pre data-language="go">type Bool struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Bool.CompareAndSwap">func (*Bool) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for the boolean value x. </p>
<h3 id="Bool.Load">func (*Bool) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Bool) Load() bool</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Bool.Store">func (*Bool) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Bool) Store(val bool)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Bool.Swap">func (*Bool) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Bool) Swap(new bool) (old bool)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Int32">type <span>Int32</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>An Int32 is an atomic int32. The zero value is zero. </p>
<pre data-language="go">type Int32 struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Int32.Add">func (*Int32) <span>Add</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int32) Add(delta int32) (new int32)</pre> <p>Add atomically adds delta to x and returns the new value. </p>
<h3 id="Int32.And">func (*Int32) <span>And</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Int32) And(mask int32) (old int32)</pre> <p>And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Int32.CompareAndSwap">func (*Int32) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Int32.Load">func (*Int32) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int32) Load() int32</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Int32.Or">func (*Int32) <span>Or</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Int32) Or(mask int32) (old int32)</pre> <p>Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Int32.Store">func (*Int32) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int32) Store(val int32)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Int32.Swap">func (*Int32) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int32) Swap(new int32) (old int32)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Int64">type <span>Int64</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>An Int64 is an atomic int64. The zero value is zero. </p>
<pre data-language="go">type Int64 struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Int64.Add">func (*Int64) <span>Add</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int64) Add(delta int64) (new int64)</pre> <p>Add atomically adds delta to x and returns the new value. </p>
<h3 id="Int64.And">func (*Int64) <span>And</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Int64) And(mask int64) (old int64)</pre> <p>And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Int64.CompareAndSwap">func (*Int64) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Int64.Load">func (*Int64) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int64) Load() int64</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Int64.Or">func (*Int64) <span>Or</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Int64) Or(mask int64) (old int64)</pre> <p>Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Int64.Store">func (*Int64) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int64) Store(val int64)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Int64.Swap">func (*Int64) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Int64) Swap(new int64) (old int64)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Pointer">type <span>Pointer</span>  </h2> <p>A Pointer is an atomic pointer of type *T. The zero value is a nil *T. </p>
<pre data-language="go">type Pointer[T any] struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Pointer.CompareAndSwap">func (*Pointer[T]) <span>CompareAndSwap</span>  </h3> <pre data-language="go">func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Pointer.Load">func (*Pointer[T]) <span>Load</span>  </h3> <pre data-language="go">func (x *Pointer[T]) Load() *T</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Pointer.Store">func (*Pointer[T]) <span>Store</span>  </h3> <pre data-language="go">func (x *Pointer[T]) Store(val *T)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Pointer.Swap">func (*Pointer[T]) <span>Swap</span>  </h3> <pre data-language="go">func (x *Pointer[T]) Swap(new *T) (old *T)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Uint32">type <span>Uint32</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>A Uint32 is an atomic uint32. The zero value is zero. </p>
<pre data-language="go">type Uint32 struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Uint32.Add">func (*Uint32) <span>Add</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint32) Add(delta uint32) (new uint32)</pre> <p>Add atomically adds delta to x and returns the new value. </p>
<h3 id="Uint32.And">func (*Uint32) <span>And</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uint32) And(mask uint32) (old uint32)</pre> <p>And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Uint32.CompareAndSwap">func (*Uint32) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Uint32.Load">func (*Uint32) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint32) Load() uint32</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Uint32.Or">func (*Uint32) <span>Or</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uint32) Or(mask uint32) (old uint32)</pre> <p>Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Uint32.Store">func (*Uint32) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint32) Store(val uint32)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Uint32.Swap">func (*Uint32) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint32) Swap(new uint32) (old uint32)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Uint64">type <span>Uint64</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>A Uint64 is an atomic uint64. The zero value is zero. </p>
<pre data-language="go">type Uint64 struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Uint64.Add">func (*Uint64) <span>Add</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint64) Add(delta uint64) (new uint64)</pre> <p>Add atomically adds delta to x and returns the new value. </p>
<h3 id="Uint64.And">func (*Uint64) <span>And</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uint64) And(mask uint64) (old uint64)</pre> <p>And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Uint64.CompareAndSwap">func (*Uint64) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Uint64.Load">func (*Uint64) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint64) Load() uint64</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Uint64.Or">func (*Uint64) <span>Or</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uint64) Or(mask uint64) (old uint64)</pre> <p>Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Uint64.Store">func (*Uint64) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint64) Store(val uint64)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Uint64.Swap">func (*Uint64) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uint64) Swap(new uint64) (old uint64)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Uintptr">type <span>Uintptr</span>  <span title="Added in Go 1.19">1.19</span> </h2> <p>A Uintptr is an atomic uintptr. The zero value is zero. </p>
<pre data-language="go">type Uintptr struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="Uintptr.Add">func (*Uintptr) <span>Add</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uintptr) Add(delta uintptr) (new uintptr)</pre> <p>Add atomically adds delta to x and returns the new value. </p>
<h3 id="Uintptr.And">func (*Uintptr) <span>And</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uintptr) And(mask uintptr) (old uintptr)</pre> <p>And atomically performs a bitwise AND operation on x using the bitmask provided as mask and returns the old value. </p>
<h3 id="Uintptr.CompareAndSwap">func (*Uintptr) <span>CompareAndSwap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for x. </p>
<h3 id="Uintptr.Load">func (*Uintptr) <span>Load</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uintptr) Load() uintptr</pre> <p>Load atomically loads and returns the value stored in x. </p>
<h3 id="Uintptr.Or">func (*Uintptr) <span>Or</span>  <span title="Added in Go 1.23">1.23</span> </h3> <pre data-language="go">func (x *Uintptr) Or(mask uintptr) (old uintptr)</pre> <p>Or atomically performs a bitwise OR operation on x using the bitmask provided as mask and returns the updated value after the OR operation. </p>
<h3 id="Uintptr.Store">func (*Uintptr) <span>Store</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uintptr) Store(val uintptr)</pre> <p>Store atomically stores val into x. </p>
<h3 id="Uintptr.Swap">func (*Uintptr) <span>Swap</span>  <span title="Added in Go 1.19">1.19</span> </h3> <pre data-language="go">func (x *Uintptr) Swap(new uintptr) (old uintptr)</pre> <p>Swap atomically stores new into x and returns the previous value. </p>
<h2 id="Value">type <span>Value</span>  <span title="Added in Go 1.4">1.4</span> </h2> <p>A Value provides an atomic load and store of a consistently typed value. The zero value for a Value returns nil from <a href="#Value.Load">Value.Load</a>. Once <a href="#Value.Store">Value.Store</a> has been called, a Value must not be copied. </p>
<p>A Value must not be copied after first use. </p>
<pre data-language="go">type Value struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Value_config"> <span class="text">Example (Config)</span>
</h4> <p>The following example shows how to use Value for periodic program config updates and propagation of the changes to worker goroutines. </p> <p>Code:</p> <pre class="code" data-language="go">
var config atomic.Value // holds current server configuration
// Create initial config value and store into config.
config.Store(loadConfig())
go func() {
    // Reload config every 10 seconds
    // and update config value with the new version.
    for {
        time.Sleep(10 * time.Second)
        config.Store(loadConfig())
    }
}()
// Create worker goroutines that handle incoming requests
// using the latest config value.
for i := 0; i &lt; 10; i++ {
    go func() {
        for r := range requests() {
            c := config.Load()
            // Handle request r using config c.
            _, _ = r, c
        }
    }()
}
</pre>      <h4 id="example_Value_readMostly"> <span class="text">Example (ReadMostly)</span>
</h4> <p>The following example shows how to maintain a scalable frequently read, but infrequently updated data structure using copy-on-write idiom. </p> <p>Code:</p> <pre class="code" data-language="go">
type Map map[string]string
var m atomic.Value
m.Store(make(Map))
var mu sync.Mutex // used only by writers
// read function can be used to read the data without further synchronization
read := func(key string) (val string) {
    m1 := m.Load().(Map)
    return m1[key]
}
// insert function can be used to update the data without further synchronization
insert := func(key, val string) {
    mu.Lock() // synchronize with other potential writers
    defer mu.Unlock()
    m1 := m.Load().(Map) // load current value of the data structure
    m2 := make(Map)      // create a new value
    for k, v := range m1 {
        m2[k] = v // copy all data from the current object to the new one
    }
    m2[key] = val // do the update that we need
    m.Store(m2)   // atomically replace the current object with the new one
    // At this point all new readers start working with the new version.
    // The old version will be garbage collected once the existing readers
    // (if any) are done with it.
}
_, _ = read, insert
</pre>   <h3 id="Value.CompareAndSwap">func (*Value) <span>CompareAndSwap</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (v *Value) CompareAndSwap(old, new any) (swapped bool)</pre> <p>CompareAndSwap executes the compare-and-swap operation for the <a href="#Value">Value</a>. </p>
<p>All calls to CompareAndSwap for a given Value must use values of the same concrete type. CompareAndSwap of an inconsistent type panics, as does CompareAndSwap(old, nil). </p>
<h3 id="Value.Load">func (*Value) <span>Load</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (v *Value) Load() (val any)</pre> <p>Load returns the value set by the most recent Store. It returns nil if there has been no call to Store for this Value. </p>
<h3 id="Value.Store">func (*Value) <span>Store</span>  <span title="Added in Go 1.4">1.4</span> </h3> <pre data-language="go">func (v *Value) Store(val any)</pre> <p>Store sets the value of the <a href="#Value">Value</a> v to val. All calls to Store for a given Value must use values of the same concrete type. Store of an inconsistent type panics, as does Store(nil). </p>
<h3 id="Value.Swap">func (*Value) <span>Swap</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (v *Value) Swap(new any) (old any)</pre> <p>Swap stores new into Value and returns the previous value. It returns nil if the Value is empty. </p>
<p>All calls to Swap for a given Value must use values of the same concrete type. Swap of an inconsistent type panics, as does Swap(nil). </p>
<h2 id="pkg-note-BUG">Bugs</h2> <ul> <li>☞ <p>On 386, the 64-bit functions use instructions unavailable before the Pentium MMX. </p>
<p>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core. </p>
<p>On ARM, 386, and 32-bit MIPS, it is the caller's responsibility to arrange for 64-bit alignment of 64-bit words accessed atomically via the primitive atomic functions (types <a href="#Int64">Int64</a> and <a href="#Uint64">Uint64</a> are automatically aligned). The first word in an allocated struct, array, or slice; in a global variable; or in a local variable (because the subject of all atomic operations will escape to the heap) can be relied upon to be 64-bit aligned. </p>
</li> </ul><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/sync/atomic/" class="_attribution-link">http://golang.org/pkg/sync/atomic/</a>
  </p>
</div>
