<h1> Package bytes  </h1>     <ul id="short-nav">
<li><code>import "bytes"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package bytes implements functions for the manipulation of byte slices. It is analogous to the facilities of the <span>strings</span> package. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Clone">func Clone(b []byte) []byte</a></li>
<li><a href="#Compare">func Compare(a, b []byte) int</a></li>
<li><a href="#Contains">func Contains(b, subslice []byte) bool</a></li>
<li><a href="#ContainsAny">func ContainsAny(b []byte, chars string) bool</a></li>
<li><a href="#ContainsFunc">func ContainsFunc(b []byte, f func(rune) bool) bool</a></li>
<li><a href="#ContainsRune">func ContainsRune(b []byte, r rune) bool</a></li>
<li><a href="#Count">func Count(s, sep []byte) int</a></li>
<li><a href="#Cut">func Cut(s, sep []byte) (before, after []byte, found bool)</a></li>
<li><a href="#CutPrefix">func CutPrefix(s, prefix []byte) (after []byte, found bool)</a></li>
<li><a href="#CutSuffix">func CutSuffix(s, suffix []byte) (before []byte, found bool)</a></li>
<li><a href="#Equal">func Equal(a, b []byte) bool</a></li>
<li><a href="#EqualFold">func EqualFold(s, t []byte) bool</a></li>
<li><a href="#Fields">func Fields(s []byte) [][]byte</a></li>
<li><a href="#FieldsFunc">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></li>
<li><a href="#HasPrefix">func HasPrefix(s, prefix []byte) bool</a></li>
<li><a href="#HasSuffix">func HasSuffix(s, suffix []byte) bool</a></li>
<li><a href="#Index">func Index(s, sep []byte) int</a></li>
<li><a href="#IndexAny">func IndexAny(s []byte, chars string) int</a></li>
<li><a href="#IndexByte">func IndexByte(b []byte, c byte) int</a></li>
<li><a href="#IndexFunc">func IndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="#IndexRune">func IndexRune(s []byte, r rune) int</a></li>
<li><a href="#Join">func Join(s [][]byte, sep []byte) []byte</a></li>
<li><a href="#LastIndex">func LastIndex(s, sep []byte) int</a></li>
<li><a href="#LastIndexAny">func LastIndexAny(s []byte, chars string) int</a></li>
<li><a href="#LastIndexByte">func LastIndexByte(s []byte, c byte) int</a></li>
<li><a href="#LastIndexFunc">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></li>
<li><a href="#Map">func Map(mapping func(r rune) rune, s []byte) []byte</a></li>
<li><a href="#Repeat">func Repeat(b []byte, count int) []byte</a></li>
<li><a href="#Replace">func Replace(s, old, new []byte, n int) []byte</a></li>
<li><a href="#ReplaceAll">func ReplaceAll(s, old, new []byte) []byte</a></li>
<li><a href="#Runes">func Runes(s []byte) []rune</a></li>
<li><a href="#Split">func Split(s, sep []byte) [][]byte</a></li>
<li><a href="#SplitAfter">func SplitAfter(s, sep []byte) [][]byte</a></li>
<li><a href="#SplitAfterN">func SplitAfterN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="#SplitN">func SplitN(s, sep []byte, n int) [][]byte</a></li>
<li><a href="#Title">func Title(s []byte) []byte</a></li>
<li><a href="#ToLower">func ToLower(s []byte) []byte</a></li>
<li><a href="#ToLowerSpecial">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#ToTitle">func ToTitle(s []byte) []byte</a></li>
<li><a href="#ToTitleSpecial">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#ToUpper">func ToUpper(s []byte) []byte</a></li>
<li><a href="#ToUpperSpecial">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</a></li>
<li><a href="#ToValidUTF8">func ToValidUTF8(s, replacement []byte) []byte</a></li>
<li><a href="#Trim">func Trim(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimFunc">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimLeft">func TrimLeft(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimLeftFunc">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimPrefix">func TrimPrefix(s, prefix []byte) []byte</a></li>
<li><a href="#TrimRight">func TrimRight(s []byte, cutset string) []byte</a></li>
<li><a href="#TrimRightFunc">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></li>
<li><a href="#TrimSpace">func TrimSpace(s []byte) []byte</a></li>
<li><a href="#TrimSuffix">func TrimSuffix(s, suffix []byte) []byte</a></li>
<li><a href="#Buffer">type Buffer</a></li>
<li> <a href="#NewBuffer">func NewBuffer(buf []byte) *Buffer</a>
</li>
<li> <a href="#NewBufferString">func NewBufferString(s string) *Buffer</a>
</li>
<li> <a href="#Buffer.Available">func (b *Buffer) Available() int</a>
</li>
<li> <a href="#Buffer.AvailableBuffer">func (b *Buffer) AvailableBuffer() []byte</a>
</li>
<li> <a href="#Buffer.Bytes">func (b *Buffer) Bytes() []byte</a>
</li>
<li> <a href="#Buffer.Cap">func (b *Buffer) Cap() int</a>
</li>
<li> <a href="#Buffer.Grow">func (b *Buffer) Grow(n int)</a>
</li>
<li> <a href="#Buffer.Len">func (b *Buffer) Len() int</a>
</li>
<li> <a href="#Buffer.Next">func (b *Buffer) Next(n int) []byte</a>
</li>
<li> <a href="#Buffer.Read">func (b *Buffer) Read(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffer.ReadByte">func (b *Buffer) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Buffer.ReadBytes">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a>
</li>
<li> <a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a>
</li>
<li> <a href="#Buffer.ReadRune">func (b *Buffer) ReadRune() (r rune, size int, err error)</a>
</li>
<li> <a href="#Buffer.ReadString">func (b *Buffer) ReadString(delim byte) (line string, err error)</a>
</li>
<li> <a href="#Buffer.Reset">func (b *Buffer) Reset()</a>
</li>
<li> <a href="#Buffer.String">func (b *Buffer) String() string</a>
</li>
<li> <a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a>
</li>
<li> <a href="#Buffer.UnreadByte">func (b *Buffer) UnreadByte() error</a>
</li>
<li> <a href="#Buffer.UnreadRune">func (b *Buffer) UnreadRune() error</a>
</li>
<li> <a href="#Buffer.Write">func (b *Buffer) Write(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteByte">func (b *Buffer) WriteByte(c byte) error</a>
</li>
<li> <a href="#Buffer.WriteRune">func (b *Buffer) WriteRune(r rune) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteString">func (b *Buffer) WriteString(s string) (n int, err error)</a>
</li>
<li> <a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Reader">type Reader</a></li>
<li> <a href="#NewReader">func NewReader(b []byte) *Reader</a>
</li>
<li> <a href="#Reader.Len">func (r *Reader) Len() int</a>
</li>
<li> <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a>
</li>
<li> <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (byte, error)</a>
</li>
<li> <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a>
</li>
<li> <a href="#Reader.Reset">func (r *Reader) Reset(b []byte)</a>
</li>
<li> <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a>
</li>
<li> <a href="#Reader.Size">func (r *Reader) Size() int64</a>
</li>
<li> <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a>
</li>
<li> <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a>
</li>
<li> <a href="#Reader.WriteTo">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_Buffer">Buffer</a></dd> <dd><a class="exampleLink" href="#example_Buffer_AvailableBuffer">Buffer.AvailableBuffer</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Bytes">Buffer.Bytes</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Cap">Buffer.Cap</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Grow">Buffer.Grow</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Len">Buffer.Len</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Next">Buffer.Next</a></dd> <dd><a class="exampleLink" href="#example_Buffer_Read">Buffer.Read</a></dd> <dd><a class="exampleLink" href="#example_Buffer_ReadByte">Buffer.ReadByte</a></dd> <dd><a class="exampleLink" href="#example_Buffer_reader">Buffer (Reader)</a></dd> <dd><a class="exampleLink" href="#example_Clone">Clone</a></dd> <dd><a class="exampleLink" href="#example_Compare">Compare</a></dd> <dd><a class="exampleLink" href="#example_Compare_search">Compare (Search)</a></dd> <dd><a class="exampleLink" href="#example_Contains">Contains</a></dd> <dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd> <dd><a class="exampleLink" href="#example_ContainsFunc">ContainsFunc</a></dd> <dd><a class="exampleLink" href="#example_ContainsRune">ContainsRune</a></dd> <dd><a class="exampleLink" href="#example_Count">Count</a></dd> <dd><a class="exampleLink" href="#example_Cut">Cut</a></dd> <dd><a class="exampleLink" href="#example_CutPrefix">CutPrefix</a></dd> <dd><a class="exampleLink" href="#example_CutSuffix">CutSuffix</a></dd> <dd><a class="exampleLink" href="#example_Equal">Equal</a></dd> <dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd> <dd><a class="exampleLink" href="#example_Fields">Fields</a></dd> <dd><a class="exampleLink" href="#example_FieldsFunc">FieldsFunc</a></dd> <dd><a class="exampleLink" href="#example_HasPrefix">HasPrefix</a></dd> <dd><a class="exampleLink" href="#example_HasSuffix">HasSuffix</a></dd> <dd><a class="exampleLink" href="#example_Index">Index</a></dd> <dd><a class="exampleLink" href="#example_IndexAny">IndexAny</a></dd> <dd><a class="exampleLink" href="#example_IndexByte">IndexByte</a></dd> <dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd> <dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd> <dd><a class="exampleLink" href="#example_Join">Join</a></dd> <dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd> <dd><a class="exampleLink" href="#example_LastIndexAny">LastIndexAny</a></dd> <dd><a class="exampleLink" href="#example_LastIndexByte">LastIndexByte</a></dd> <dd><a class="exampleLink" href="#example_LastIndexFunc">LastIndexFunc</a></dd> <dd><a class="exampleLink" href="#example_Map">Map</a></dd> <dd><a class="exampleLink" href="#example_Reader_Len">Reader.Len</a></dd> <dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd> <dd><a class="exampleLink" href="#example_Replace">Replace</a></dd> <dd><a class="exampleLink" href="#example_ReplaceAll">ReplaceAll</a></dd> <dd><a class="exampleLink" href="#example_Runes">Runes</a></dd> <dd><a class="exampleLink" href="#example_Split">Split</a></dd> <dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd> <dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd> <dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd> <dd><a class="exampleLink" href="#example_Title">Title</a></dd> <dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd> <dd><a class="exampleLink" href="#example_ToLowerSpecial">ToLowerSpecial</a></dd> <dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd> <dd><a class="exampleLink" href="#example_ToTitleSpecial">ToTitleSpecial</a></dd> <dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd> <dd><a class="exampleLink" href="#example_ToUpperSpecial">ToUpperSpecial</a></dd> <dd><a class="exampleLink" href="#example_ToValidUTF8">ToValidUTF8</a></dd> <dd><a class="exampleLink" href="#example_Trim">Trim</a></dd> <dd><a class="exampleLink" href="#example_TrimFunc">TrimFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimLeft">TrimLeft</a></dd> <dd><a class="exampleLink" href="#example_TrimLeftFunc">TrimLeftFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimPrefix">TrimPrefix</a></dd> <dd><a class="exampleLink" href="#example_TrimRight">TrimRight</a></dd> <dd><a class="exampleLink" href="#example_TrimRightFunc">TrimRightFunc</a></dd> <dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd> <dd><a class="exampleLink" href="#example_TrimSuffix">TrimSuffix</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>buffer.go</span> <span>bytes.go</span> <span>reader.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <p>MinRead is the minimum slice size passed to a <a href="#Buffer.Read">Buffer.Read</a> call by <a href="#Buffer.ReadFrom">Buffer.ReadFrom</a>. As long as the <a href="#Buffer">Buffer</a> has at least MinRead bytes beyond what is required to hold the contents of r, <a href="#Buffer.ReadFrom">Buffer.ReadFrom</a> will not grow the underlying buffer. </p>
<pre data-language="go">const MinRead = 512</pre> <h2 id="pkg-variables">Variables</h2> <p>ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer. </p>
<pre data-language="go">var ErrTooLarge = errors.New("bytes.Buffer: too large")</pre> <h2 id="Clone">func <span>Clone</span>  <span title="Added in Go 1.20">1.20</span> </h2> <pre data-language="go">func Clone(b []byte) []byte</pre> <p>Clone returns a copy of b[:len(b)]. The result may have additional unused capacity. Clone(nil) returns nil. </p>   <h4 id="example_Clone"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">b := []byte("abc")
clone := bytes.Clone(b)
fmt.Printf("%s\n", clone)
clone[0] = 'd'
fmt.Printf("%s\n", b)
fmt.Printf("%s\n", clone)
</pre> <p>Output:</p> <pre class="output" data-language="go">abc
abc
dbc
</pre>   <h2 id="Compare">func <span>Compare</span>  </h2> <pre data-language="go">func Compare(a, b []byte) int</pre> <p>Compare returns an integer comparing two byte slices lexicographically. The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b. A nil argument is equivalent to an empty slice. </p>   <h4 id="example_Compare"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Interpret Compare's result by comparing it to zero.
var a, b []byte
if bytes.Compare(a, b) &lt; 0 {
    // a less b
}
if bytes.Compare(a, b) &lt;= 0 {
    // a less or equal b
}
if bytes.Compare(a, b) &gt; 0 {
    // a greater b
}
if bytes.Compare(a, b) &gt;= 0 {
    // a greater or equal b
}

// Prefer Equal to Compare for equality comparisons.
if bytes.Equal(a, b) {
    // a equal b
}
if !bytes.Equal(a, b) {
    // a not equal b
}
</pre>      <h4 id="example_Compare_search"> <span class="text">Example (Search)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Binary search to find a matching byte slice.
var needle []byte
var haystack [][]byte // Assume sorted
_, found := slices.BinarySearchFunc(haystack, needle, bytes.Compare)
if found {
    // Found it!
}
</pre>   <h2 id="Contains">func <span>Contains</span>  </h2> <pre data-language="go">func Contains(b, subslice []byte) bool</pre> <p>Contains reports whether subslice is within b. </p>   <h4 id="example_Contains"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.Contains([]byte("seafood"), []byte("foo")))
fmt.Println(bytes.Contains([]byte("seafood"), []byte("bar")))
fmt.Println(bytes.Contains([]byte("seafood"), []byte("")))
fmt.Println(bytes.Contains([]byte(""), []byte("")))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
true
</pre>   <h2 id="ContainsAny">func <span>ContainsAny</span>  <span title="Added in Go 1.7">1.7</span> </h2> <pre data-language="go">func ContainsAny(b []byte, chars string) bool</pre> <p>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b. </p>   <h4 id="example_ContainsAny"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.ContainsAny([]byte("I like seafood."), "fÄo!"))
fmt.Println(bytes.ContainsAny([]byte("I like seafood."), "去是伟大的."))
fmt.Println(bytes.ContainsAny([]byte("I like seafood."), ""))
fmt.Println(bytes.ContainsAny([]byte(""), ""))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
true
false
false
</pre>   <h2 id="ContainsFunc">func <span>ContainsFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func ContainsFunc(b []byte, f func(rune) bool) bool</pre> <p>ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r). </p>   <h4 id="example_ContainsFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">f := func(r rune) bool {
    return r &gt;= 'a' &amp;&amp; r &lt;= 'z'
}
fmt.Println(bytes.ContainsFunc([]byte("HELLO"), f))
fmt.Println(bytes.ContainsFunc([]byte("World"), f))
</pre> <p>Output:</p> <pre class="output" data-language="go">false
true
</pre>   <h2 id="ContainsRune">func <span>ContainsRune</span>  <span title="Added in Go 1.7">1.7</span> </h2> <pre data-language="go">func ContainsRune(b []byte, r rune) bool</pre> <p>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b. </p>   <h4 id="example_ContainsRune"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.ContainsRune([]byte("I like seafood."), 'f'))
fmt.Println(bytes.ContainsRune([]byte("I like seafood."), 'ö'))
fmt.Println(bytes.ContainsRune([]byte("去是伟大的!"), '大'))
fmt.Println(bytes.ContainsRune([]byte("去是伟大的!"), '!'))
fmt.Println(bytes.ContainsRune([]byte(""), '@'))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
true
false
</pre>   <h2 id="Count">func <span>Count</span>  </h2> <pre data-language="go">func Count(s, sep []byte) int</pre> <p>Count counts the number of non-overlapping instances of sep in s. If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s. </p>   <h4 id="example_Count"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.Count([]byte("cheese"), []byte("e")))
fmt.Println(bytes.Count([]byte("five"), []byte(""))) // before &amp; after each rune
</pre> <p>Output:</p> <pre class="output" data-language="go">3
5
</pre>   <h2 id="Cut">func <span>Cut</span>  <span title="Added in Go 1.18">1.18</span> </h2> <pre data-language="go">func Cut(s, sep []byte) (before, after []byte, found bool)</pre> <p>Cut slices s around the first instance of sep, returning the text before and after sep. The found result reports whether sep appears in s. If sep does not appear in s, cut returns s, nil, false. </p>
<p>Cut returns slices of the original slice s, not copies. </p>   <h4 id="example_Cut"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">show := func(s, sep string) {
    before, after, found := bytes.Cut([]byte(s), []byte(sep))
    fmt.Printf("Cut(%q, %q) = %q, %q, %v\n", s, sep, before, after, found)
}
show("Gopher", "Go")
show("Gopher", "ph")
show("Gopher", "er")
show("Gopher", "Badger")
</pre> <p>Output:</p> <pre class="output" data-language="go">Cut("Gopher", "Go") = "", "pher", true
Cut("Gopher", "ph") = "Go", "er", true
Cut("Gopher", "er") = "Goph", "", true
Cut("Gopher", "Badger") = "Gopher", "", false
</pre>   <h2 id="CutPrefix">func <span>CutPrefix</span>  <span title="Added in Go 1.20">1.20</span> </h2> <pre data-language="go">func CutPrefix(s, prefix []byte) (after []byte, found bool)</pre> <p>CutPrefix returns s without the provided leading prefix byte slice and reports whether it found the prefix. If s doesn't start with prefix, CutPrefix returns s, false. If prefix is the empty byte slice, CutPrefix returns s, true. </p>
<p>CutPrefix returns slices of the original slice s, not copies. </p>   <h4 id="example_CutPrefix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">show := func(s, sep string) {
    after, found := bytes.CutPrefix([]byte(s), []byte(sep))
    fmt.Printf("CutPrefix(%q, %q) = %q, %v\n", s, sep, after, found)
}
show("Gopher", "Go")
show("Gopher", "ph")
</pre> <p>Output:</p> <pre class="output" data-language="go">CutPrefix("Gopher", "Go") = "pher", true
CutPrefix("Gopher", "ph") = "Gopher", false
</pre>   <h2 id="CutSuffix">func <span>CutSuffix</span>  <span title="Added in Go 1.20">1.20</span> </h2> <pre data-language="go">func CutSuffix(s, suffix []byte) (before []byte, found bool)</pre> <p>CutSuffix returns s without the provided ending suffix byte slice and reports whether it found the suffix. If s doesn't end with suffix, CutSuffix returns s, false. If suffix is the empty byte slice, CutSuffix returns s, true. </p>
<p>CutSuffix returns slices of the original slice s, not copies. </p>   <h4 id="example_CutSuffix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">show := func(s, sep string) {
    before, found := bytes.CutSuffix([]byte(s), []byte(sep))
    fmt.Printf("CutSuffix(%q, %q) = %q, %v\n", s, sep, before, found)
}
show("Gopher", "Go")
show("Gopher", "er")
</pre> <p>Output:</p> <pre class="output" data-language="go">CutSuffix("Gopher", "Go") = "Gopher", false
CutSuffix("Gopher", "er") = "Goph", true
</pre>   <h2 id="Equal">func <span>Equal</span>  </h2> <pre data-language="go">func Equal(a, b []byte) bool</pre> <p>Equal reports whether a and b are the same length and contain the same bytes. A nil argument is equivalent to an empty slice. </p>   <h4 id="example_Equal"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.Equal([]byte("Go"), []byte("Go")))
fmt.Println(bytes.Equal([]byte("Go"), []byte("C++")))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
</pre>   <h2 id="EqualFold">func <span>EqualFold</span>  </h2> <pre data-language="go">func EqualFold(s, t []byte) bool</pre> <p>EqualFold reports whether s and t, interpreted as UTF-8 strings, are equal under simple Unicode case-folding, which is a more general form of case-insensitivity. </p>   <h4 id="example_EqualFold"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.EqualFold([]byte("Go"), []byte("go")))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
</pre>   <h2 id="Fields">func <span>Fields</span>  </h2> <pre data-language="go">func Fields(s []byte) [][]byte</pre> <p>Fields interprets s as a sequence of UTF-8-encoded code points. It splits the slice s around each instance of one or more consecutive white space characters, as defined by <span>unicode.IsSpace</span>, returning a slice of subslices of s or an empty slice if s contains only white space. </p>   <h4 id="example_Fields"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("Fields are: %q", bytes.Fields([]byte("  foo bar  baz   ")))
</pre> <p>Output:</p> <pre class="output" data-language="go">Fields are: ["foo" "bar" "baz"]
</pre>   <h2 id="FieldsFunc">func <span>FieldsFunc</span>  </h2> <pre data-language="go">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</pre> <p>FieldsFunc interprets s as a sequence of UTF-8-encoded code points. It splits the slice s at each run of code points c satisfying f(c) and returns a slice of subslices of s. If all code points in s satisfy f(c), or len(s) == 0, an empty slice is returned. </p>
<p>FieldsFunc makes no guarantees about the order in which it calls f(c) and assumes that f always returns the same value for a given c. </p>   <h4 id="example_FieldsFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">f := func(c rune) bool {
    return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
}
fmt.Printf("Fields are: %q", bytes.FieldsFunc([]byte("  foo1;bar2,baz3..."), f))
</pre> <p>Output:</p> <pre class="output" data-language="go">Fields are: ["foo1" "bar2" "baz3"]
</pre>   <h2 id="HasPrefix">func <span>HasPrefix</span>  </h2> <pre data-language="go">func HasPrefix(s, prefix []byte) bool</pre> <p>HasPrefix reports whether the byte slice s begins with prefix. </p>   <h4 id="example_HasPrefix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("Go")))
fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("C")))
fmt.Println(bytes.HasPrefix([]byte("Gopher"), []byte("")))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
</pre>   <h2 id="HasSuffix">func <span>HasSuffix</span>  </h2> <pre data-language="go">func HasSuffix(s, suffix []byte) bool</pre> <p>HasSuffix reports whether the byte slice s ends with suffix. </p>   <h4 id="example_HasSuffix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("go")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("O")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("Ami")))
fmt.Println(bytes.HasSuffix([]byte("Amigo"), []byte("")))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
false
true
</pre>   <h2 id="Index">func <span>Index</span>  </h2> <pre data-language="go">func Index(s, sep []byte) int</pre> <p>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s. </p>   <h4 id="example_Index"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.Index([]byte("chicken"), []byte("ken")))
fmt.Println(bytes.Index([]byte("chicken"), []byte("dmr")))
</pre> <p>Output:</p> <pre class="output" data-language="go">4
-1
</pre>   <h2 id="IndexAny">func <span>IndexAny</span>  </h2> <pre data-language="go">func IndexAny(s []byte, chars string) int</pre> <p>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the first occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p>   <h4 id="example_IndexAny"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.IndexAny([]byte("chicken"), "aeiouy"))
fmt.Println(bytes.IndexAny([]byte("crwth"), "aeiouy"))
</pre> <p>Output:</p> <pre class="output" data-language="go">2
-1
</pre>   <h2 id="IndexByte">func <span>IndexByte</span>  </h2> <pre data-language="go">func IndexByte(b []byte, c byte) int</pre> <p>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b. </p>   <h4 id="example_IndexByte"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.IndexByte([]byte("chicken"), byte('k')))
fmt.Println(bytes.IndexByte([]byte("chicken"), byte('g')))
</pre> <p>Output:</p> <pre class="output" data-language="go">4
-1
</pre>   <h2 id="IndexFunc">func <span>IndexFunc</span>  </h2> <pre data-language="go">func IndexFunc(s []byte, f func(r rune) bool) int</pre> <p>IndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the first Unicode code point satisfying f(c), or -1 if none do. </p>   <h4 id="example_IndexFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">f := func(c rune) bool {
    return unicode.Is(unicode.Han, c)
}
fmt.Println(bytes.IndexFunc([]byte("Hello, 世界"), f))
fmt.Println(bytes.IndexFunc([]byte("Hello, world"), f))
</pre> <p>Output:</p> <pre class="output" data-language="go">7
-1
</pre>   <h2 id="IndexRune">func <span>IndexRune</span>  </h2> <pre data-language="go">func IndexRune(s []byte, r rune) int</pre> <p>IndexRune interprets s as a sequence of UTF-8-encoded code points. It returns the byte index of the first occurrence in s of the given rune. It returns -1 if rune is not present in s. If r is <span>utf8.RuneError</span>, it returns the first instance of any invalid UTF-8 byte sequence. </p>   <h4 id="example_IndexRune"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.IndexRune([]byte("chicken"), 'k'))
fmt.Println(bytes.IndexRune([]byte("chicken"), 'd'))
</pre> <p>Output:</p> <pre class="output" data-language="go">4
-1
</pre>   <h2 id="Join">func <span>Join</span>  </h2> <pre data-language="go">func Join(s [][]byte, sep []byte) []byte</pre> <p>Join concatenates the elements of s to create a new byte slice. The separator sep is placed between elements in the resulting slice. </p>   <h4 id="example_Join"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">s := [][]byte{[]byte("foo"), []byte("bar"), []byte("baz")}
fmt.Printf("%s", bytes.Join(s, []byte(", ")))
</pre> <p>Output:</p> <pre class="output" data-language="go">foo, bar, baz
</pre>   <h2 id="LastIndex">func <span>LastIndex</span>  </h2> <pre data-language="go">func LastIndex(s, sep []byte) int</pre> <p>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s. </p>   <h4 id="example_LastIndex"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.Index([]byte("go gopher"), []byte("go")))
fmt.Println(bytes.LastIndex([]byte("go gopher"), []byte("go")))
fmt.Println(bytes.LastIndex([]byte("go gopher"), []byte("rodent")))
</pre> <p>Output:</p> <pre class="output" data-language="go">0
3
-1
</pre>   <h2 id="LastIndexAny">func <span>LastIndexAny</span>  </h2> <pre data-language="go">func LastIndexAny(s []byte, chars string) int</pre> <p>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code points. It returns the byte index of the last occurrence in s of any of the Unicode code points in chars. It returns -1 if chars is empty or if there is no code point in common. </p>   <h4 id="example_LastIndexAny"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.LastIndexAny([]byte("go gopher"), "MüQp"))
fmt.Println(bytes.LastIndexAny([]byte("go 地鼠"), "地大"))
fmt.Println(bytes.LastIndexAny([]byte("go gopher"), "z,!."))
</pre> <p>Output:</p> <pre class="output" data-language="go">5
3
-1
</pre>   <h2 id="LastIndexByte">func <span>LastIndexByte</span>  <span title="Added in Go 1.5">1.5</span> </h2> <pre data-language="go">func LastIndexByte(s []byte, c byte) int</pre> <p>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s. </p>   <h4 id="example_LastIndexByte"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('g')))
fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('r')))
fmt.Println(bytes.LastIndexByte([]byte("go gopher"), byte('z')))
</pre> <p>Output:</p> <pre class="output" data-language="go">3
8
-1
</pre>   <h2 id="LastIndexFunc">func <span>LastIndexFunc</span>  </h2> <pre data-language="go">func LastIndexFunc(s []byte, f func(r rune) bool) int</pre> <p>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points. It returns the byte index in s of the last Unicode code point satisfying f(c), or -1 if none do. </p>   <h4 id="example_LastIndexFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsLetter))
fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsPunct))
fmt.Println(bytes.LastIndexFunc([]byte("go gopher!"), unicode.IsNumber))
</pre> <p>Output:</p> <pre class="output" data-language="go">8
9
-1
</pre>   <h2 id="Map">func <span>Map</span>  </h2> <pre data-language="go">func Map(mapping func(r rune) rune, s []byte) []byte</pre> <p>Map returns a copy of the byte slice s with all its characters modified according to the mapping function. If mapping returns a negative value, the character is dropped from the byte slice with no replacement. The characters in s and the output are interpreted as UTF-8-encoded code points. </p>   <h4 id="example_Map"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">rot13 := func(r rune) rune {
    switch {
    case r &gt;= 'A' &amp;&amp; r &lt;= 'Z':
        return 'A' + (r-'A'+13)%26
    case r &gt;= 'a' &amp;&amp; r &lt;= 'z':
        return 'a' + (r-'a'+13)%26
    }
    return r
}
fmt.Printf("%s\n", bytes.Map(rot13, []byte("'Twas brillig and the slithy gopher...")))
</pre> <p>Output:</p> <pre class="output" data-language="go">'Gjnf oevyyvt naq gur fyvgul tbcure...
</pre>   <h2 id="Repeat">func <span>Repeat</span>  </h2> <pre data-language="go">func Repeat(b []byte, count int) []byte</pre> <p>Repeat returns a new byte slice consisting of count copies of b. </p>
<p>It panics if count is negative or if the result of (len(b) * count) overflows. </p>   <h4 id="example_Repeat"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("ba%s", bytes.Repeat([]byte("na"), 2))
</pre> <p>Output:</p> <pre class="output" data-language="go">banana
</pre>   <h2 id="Replace">func <span>Replace</span>  </h2> <pre data-language="go">func Replace(s, old, new []byte, n int) []byte</pre> <p>Replace returns a copy of the slice s with the first n non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. If n &lt; 0, there is no limit on the number of replacements. </p>   <h4 id="example_Replace"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("k"), []byte("ky"), 2))
fmt.Printf("%s\n", bytes.Replace([]byte("oink oink oink"), []byte("oink"), []byte("moo"), -1))
</pre> <p>Output:</p> <pre class="output" data-language="go">oinky oinky oink
moo moo moo
</pre>   <h2 id="ReplaceAll">func <span>ReplaceAll</span>  <span title="Added in Go 1.12">1.12</span> </h2> <pre data-language="go">func ReplaceAll(s, old, new []byte) []byte</pre> <p>ReplaceAll returns a copy of the slice s with all non-overlapping instances of old replaced by new. If old is empty, it matches at the beginning of the slice and after each UTF-8 sequence, yielding up to k+1 replacements for a k-rune slice. </p>   <h4 id="example_ReplaceAll"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s\n", bytes.ReplaceAll([]byte("oink oink oink"), []byte("oink"), []byte("moo")))
</pre> <p>Output:</p> <pre class="output" data-language="go">moo moo moo
</pre>   <h2 id="Runes">func <span>Runes</span>  </h2> <pre data-language="go">func Runes(s []byte) []rune</pre> <p>Runes interprets s as a sequence of UTF-8-encoded code points. It returns a slice of runes (Unicode code points) equivalent to s. </p>   <h4 id="example_Runes"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">rs := bytes.Runes([]byte("go gopher"))
for _, r := range rs {
    fmt.Printf("%#U\n", r)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">U+0067 'g'
U+006F 'o'
U+0020 ' '
U+0067 'g'
U+006F 'o'
U+0070 'p'
U+0068 'h'
U+0065 'e'
U+0072 'r'
</pre>   <h2 id="Split">func <span>Split</span>  </h2> <pre data-language="go">func Split(s, sep []byte) [][]byte</pre> <p>Split slices s into all subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, Split splits after each UTF-8 sequence. It is equivalent to SplitN with a count of -1. </p>
<p>To split around the first instance of a separator, see <a href="#Cut">Cut</a>. </p>   <h4 id="example_Split"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%q\n", bytes.Split([]byte("a,b,c"), []byte(",")))
fmt.Printf("%q\n", bytes.Split([]byte("a man a plan a canal panama"), []byte("a ")))
fmt.Printf("%q\n", bytes.Split([]byte(" xyz "), []byte("")))
fmt.Printf("%q\n", bytes.Split([]byte(""), []byte("Bernardo O'Higgins")))
</pre> <p>Output:</p> <pre class="output" data-language="go">["a" "b" "c"]
["" "man " "plan " "canal panama"]
[" " "x" "y" "z" " "]
[""]
</pre>   <h2 id="SplitAfter">func <span>SplitAfter</span>  </h2> <pre data-language="go">func SplitAfter(s, sep []byte) [][]byte</pre> <p>SplitAfter slices s into all subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfter splits after each UTF-8 sequence. It is equivalent to SplitAfterN with a count of -1. </p>   <h4 id="example_SplitAfter"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%q\n", bytes.SplitAfter([]byte("a,b,c"), []byte(",")))
</pre> <p>Output:</p> <pre class="output" data-language="go">["a," "b," "c"]
</pre>   <h2 id="SplitAfterN">func <span>SplitAfterN</span>  </h2> <pre data-language="go">func SplitAfterN(s, sep []byte, n int) [][]byte</pre> <p>SplitAfterN slices s into subslices after each instance of sep and returns a slice of those subslices. If sep is empty, SplitAfterN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p>
<ul> <li>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder; </li>
<li>n == 0: the result is nil (zero subslices); </li>
<li>n &lt; 0: all subslices. </li>
</ul>    <h4 id="example_SplitAfterN"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%q\n", bytes.SplitAfterN([]byte("a,b,c"), []byte(","), 2))
</pre> <p>Output:</p> <pre class="output" data-language="go">["a," "b,c"]
</pre>   <h2 id="SplitN">func <span>SplitN</span>  </h2> <pre data-language="go">func SplitN(s, sep []byte, n int) [][]byte</pre> <p>SplitN slices s into subslices separated by sep and returns a slice of the subslices between those separators. If sep is empty, SplitN splits after each UTF-8 sequence. The count determines the number of subslices to return: </p>
<ul> <li>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder; </li>
<li>n == 0: the result is nil (zero subslices); </li>
<li>n &lt; 0: all subslices. </li>
</ul> <p>To split around the first instance of a separator, see <a href="#Cut">Cut</a>. </p>   <h4 id="example_SplitN"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%q\n", bytes.SplitN([]byte("a,b,c"), []byte(","), 2))
z := bytes.SplitN([]byte("a,b,c"), []byte(","), 0)
fmt.Printf("%q (nil = %v)\n", z, z == nil)
</pre> <p>Output:</p> <pre class="output" data-language="go">["a" "b,c"]
[] (nil = true)
</pre>   <h2 id="Title">func <span>Title</span>  </h2> <pre data-language="go">func Title(s []byte) []byte</pre> <p>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin words mapped to their title case. </p>
<p>Deprecated: The rule Title uses for word boundaries does not handle Unicode punctuation properly. Use golang.org/x/text/cases instead. </p>   <h4 id="example_Title"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s", bytes.Title([]byte("her royal highness")))
</pre> <p>Output:</p> <pre class="output" data-language="go">Her Royal Highness
</pre>   <h2 id="ToLower">func <span>ToLower</span>  </h2> <pre data-language="go">func ToLower(s []byte) []byte</pre> <p>ToLower returns a copy of the byte slice s with all Unicode letters mapped to their lower case. </p>   <h4 id="example_ToLower"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s", bytes.ToLower([]byte("Gopher")))
</pre> <p>Output:</p> <pre class="output" data-language="go">gopher
</pre>   <h2 id="ToLowerSpecial">func <span>ToLowerSpecial</span>  </h2> <pre data-language="go">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case, giving priority to the special casing rules. </p>   <h4 id="example_ToLowerSpecial"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">str := []byte("AHOJ VÝVOJÁRİ GOLANG")
totitle := bytes.ToLowerSpecial(unicode.AzeriCase, str)
fmt.Println("Original : " + string(str))
fmt.Println("ToLower : " + string(totitle))
</pre> <p>Output:</p> <pre class="output" data-language="go">Original : AHOJ VÝVOJÁRİ GOLANG
ToLower : ahoj vývojári golang
</pre>   <h2 id="ToTitle">func <span>ToTitle</span>  </h2> <pre data-language="go">func ToTitle(s []byte) []byte</pre> <p>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case. </p>   <h4 id="example_ToTitle"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s\n", bytes.ToTitle([]byte("loud noises")))
fmt.Printf("%s\n", bytes.ToTitle([]byte("хлеб")))
</pre> <p>Output:</p> <pre class="output" data-language="go">LOUD NOISES
ХЛЕБ
</pre>   <h2 id="ToTitleSpecial">func <span>ToTitleSpecial</span>  </h2> <pre data-language="go">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case, giving priority to the special casing rules. </p>   <h4 id="example_ToTitleSpecial"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">str := []byte("ahoj vývojári golang")
totitle := bytes.ToTitleSpecial(unicode.AzeriCase, str)
fmt.Println("Original : " + string(str))
fmt.Println("ToTitle : " + string(totitle))
</pre> <p>Output:</p> <pre class="output" data-language="go">Original : ahoj vývojári golang
ToTitle : AHOJ VÝVOJÁRİ GOLANG
</pre>   <h2 id="ToUpper">func <span>ToUpper</span>  </h2> <pre data-language="go">func ToUpper(s []byte) []byte</pre> <p>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to their upper case. </p>   <h4 id="example_ToUpper"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s", bytes.ToUpper([]byte("Gopher")))
</pre> <p>Output:</p> <pre class="output" data-language="go">GOPHER
</pre>   <h2 id="ToUpperSpecial">func <span>ToUpperSpecial</span>  </h2> <pre data-language="go">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</pre> <p>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their upper case, giving priority to the special casing rules. </p>   <h4 id="example_ToUpperSpecial"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">str := []byte("ahoj vývojári golang")
totitle := bytes.ToUpperSpecial(unicode.AzeriCase, str)
fmt.Println("Original : " + string(str))
fmt.Println("ToUpper : " + string(totitle))
</pre> <p>Output:</p> <pre class="output" data-language="go">Original : ahoj vývojári golang
ToUpper : AHOJ VÝVOJÁRİ GOLANG
</pre>   <h2 id="ToValidUTF8">func <span>ToValidUTF8</span>  <span title="Added in Go 1.13">1.13</span> </h2> <pre data-language="go">func ToValidUTF8(s, replacement []byte) []byte</pre> <p>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes representing invalid UTF-8 replaced with the bytes in replacement, which may be empty. </p>   <h4 id="example_ToValidUTF8"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s\n", bytes.ToValidUTF8([]byte("abc"), []byte("\uFFFD")))
fmt.Printf("%s\n", bytes.ToValidUTF8([]byte("a\xffb\xC0\xAFc\xff"), []byte("")))
fmt.Printf("%s\n", bytes.ToValidUTF8([]byte("\xed\xa0\x80"), []byte("abc")))
</pre> <p>Output:</p> <pre class="output" data-language="go">abc
abc
abc
</pre>   <h2 id="Trim">func <span>Trim</span>  </h2> <pre data-language="go">func Trim(s []byte, cutset string) []byte</pre> <p>Trim returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points contained in cutset. </p>   <h4 id="example_Trim"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("[%q]", bytes.Trim([]byte(" !!! Achtung! Achtung! !!! "), "! "))
</pre> <p>Output:</p> <pre class="output" data-language="go">["Achtung! Achtung"]
</pre>   <h2 id="TrimFunc">func <span>TrimFunc</span>  </h2> <pre data-language="go">func TrimFunc(s []byte, f func(r rune) bool) []byte</pre> <p>TrimFunc returns a subslice of s by slicing off all leading and trailing UTF-8-encoded code points c that satisfy f(c). </p>   <h4 id="example_TrimFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(string(bytes.TrimFunc([]byte("go-gopher!"), unicode.IsLetter)))
fmt.Println(string(bytes.TrimFunc([]byte("\"go-gopher!\""), unicode.IsLetter)))
fmt.Println(string(bytes.TrimFunc([]byte("go-gopher!"), unicode.IsPunct)))
fmt.Println(string(bytes.TrimFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
</pre> <p>Output:</p> <pre class="output" data-language="go">-gopher!
"go-gopher!"
go-gopher
go-gopher!
</pre>   <h2 id="TrimLeft">func <span>TrimLeft</span>  </h2> <pre data-language="go">func TrimLeft(s []byte, cutset string) []byte</pre> <p>TrimLeft returns a subslice of s by slicing off all leading UTF-8-encoded code points contained in cutset. </p>   <h4 id="example_TrimLeft"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Print(string(bytes.TrimLeft([]byte("453gopher8257"), "0123456789")))
</pre> <p>Output:</p> <pre class="output" data-language="go">gopher8257
</pre>   <h2 id="TrimLeftFunc">func <span>TrimLeftFunc</span>  </h2> <pre data-language="go">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</pre> <p>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off all leading UTF-8-encoded code points c that satisfy f(c). </p>   <h4 id="example_TrimLeftFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(string(bytes.TrimLeftFunc([]byte("go-gopher"), unicode.IsLetter)))
fmt.Println(string(bytes.TrimLeftFunc([]byte("go-gopher!"), unicode.IsPunct)))
fmt.Println(string(bytes.TrimLeftFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
</pre> <p>Output:</p> <pre class="output" data-language="go">-gopher
go-gopher!
go-gopher!567
</pre>   <h2 id="TrimPrefix">func <span>TrimPrefix</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimPrefix(s, prefix []byte) []byte</pre> <p>TrimPrefix returns s without the provided leading prefix string. If s doesn't start with prefix, s is returned unchanged. </p>   <h4 id="example_TrimPrefix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b = []byte("Goodbye,, world!")
b = bytes.TrimPrefix(b, []byte("Goodbye,"))
b = bytes.TrimPrefix(b, []byte("See ya,"))
fmt.Printf("Hello%s", b)
</pre> <p>Output:</p> <pre class="output" data-language="go">Hello, world!
</pre>   <h2 id="TrimRight">func <span>TrimRight</span>  </h2> <pre data-language="go">func TrimRight(s []byte, cutset string) []byte</pre> <p>TrimRight returns a subslice of s by slicing off all trailing UTF-8-encoded code points that are contained in cutset. </p>   <h4 id="example_TrimRight"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Print(string(bytes.TrimRight([]byte("453gopher8257"), "0123456789")))
</pre> <p>Output:</p> <pre class="output" data-language="go">453gopher
</pre>   <h2 id="TrimRightFunc">func <span>TrimRightFunc</span>  </h2> <pre data-language="go">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</pre> <p>TrimRightFunc returns a subslice of s by slicing off all trailing UTF-8-encoded code points c that satisfy f(c). </p>   <h4 id="example_TrimRightFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(string(bytes.TrimRightFunc([]byte("go-gopher"), unicode.IsLetter)))
fmt.Println(string(bytes.TrimRightFunc([]byte("go-gopher!"), unicode.IsPunct)))
fmt.Println(string(bytes.TrimRightFunc([]byte("1234go-gopher!567"), unicode.IsNumber)))
</pre> <p>Output:</p> <pre class="output" data-language="go">go-
go-gopher
1234go-gopher!
</pre>   <h2 id="TrimSpace">func <span>TrimSpace</span>  </h2> <pre data-language="go">func TrimSpace(s []byte) []byte</pre> <p>TrimSpace returns a subslice of s by slicing off all leading and trailing white space, as defined by Unicode. </p>   <h4 id="example_TrimSpace"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Printf("%s", bytes.TrimSpace([]byte(" \t\n a lone gopher \n\t\r\n")))
</pre> <p>Output:</p> <pre class="output" data-language="go">a lone gopher
</pre>   <h2 id="TrimSuffix">func <span>TrimSuffix</span>  <span title="Added in Go 1.1">1.1</span> </h2> <pre data-language="go">func TrimSuffix(s, suffix []byte) []byte</pre> <p>TrimSuffix returns s without the provided trailing suffix string. If s doesn't end with suffix, s is returned unchanged. </p>   <h4 id="example_TrimSuffix"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b = []byte("Hello, goodbye, etc!")
b = bytes.TrimSuffix(b, []byte("goodbye, etc!"))
b = bytes.TrimSuffix(b, []byte("gopher"))
b = append(b, bytes.TrimSuffix([]byte("world!"), []byte("x!"))...)
os.Stdout.Write(b)
</pre> <p>Output:</p> <pre class="output" data-language="go">Hello, world!
</pre>   <h2 id="Buffer">type <span>Buffer</span>  </h2> <p>A Buffer is a variable-sized buffer of bytes with <a href="#Buffer.Read">Buffer.Read</a> and <a href="#Buffer.Write">Buffer.Write</a> methods. The zero value for Buffer is an empty buffer ready to use. </p>
<pre data-language="go">type Buffer struct {
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Buffer"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer // A Buffer needs no initialization.
b.Write([]byte("Hello "))
fmt.Fprintf(&amp;b, "world!")
b.WriteTo(os.Stdout)
</pre> <p>Output:</p> <pre class="output" data-language="go">Hello world!
</pre>      <h4 id="example_Buffer_reader"> <span class="text">Example (Reader)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// A Buffer can turn a string or a []byte into an io.Reader.
buf := bytes.NewBufferString("R29waGVycyBydWxlIQ==")
dec := base64.NewDecoder(base64.StdEncoding, buf)
io.Copy(os.Stdout, dec)
</pre> <p>Output:</p> <pre class="output" data-language="go">Gophers rule!
</pre>   <h3 id="NewBuffer">func <span>NewBuffer</span>  </h3> <pre data-language="go">func NewBuffer(buf []byte) *Buffer</pre> <p>NewBuffer creates and initializes a new <a href="#Buffer">Buffer</a> using buf as its initial contents. The new <a href="#Buffer">Buffer</a> takes ownership of buf, and the caller should not use buf after this call. NewBuffer is intended to prepare a <a href="#Buffer">Buffer</a> to read existing data. It can also be used to set the initial size of the internal buffer for writing. To do that, buf should have the desired capacity but a length of zero. </p>
<p>In most cases, new(<a href="#Buffer">Buffer</a>) (or just declaring a <a href="#Buffer">Buffer</a> variable) is sufficient to initialize a <a href="#Buffer">Buffer</a>. </p>
<h3 id="NewBufferString">func <span>NewBufferString</span>  </h3> <pre data-language="go">func NewBufferString(s string) *Buffer</pre> <p>NewBufferString creates and initializes a new <a href="#Buffer">Buffer</a> using string s as its initial contents. It is intended to prepare a buffer to read an existing string. </p>
<p>In most cases, new(<a href="#Buffer">Buffer</a>) (or just declaring a <a href="#Buffer">Buffer</a> variable) is sufficient to initialize a <a href="#Buffer">Buffer</a>. </p>
<h3 id="Buffer.Available">func (*Buffer) <span>Available</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (b *Buffer) Available() int</pre> <p>Available returns how many bytes are unused in the buffer. </p>
<h3 id="Buffer.AvailableBuffer">func (*Buffer) <span>AvailableBuffer</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (b *Buffer) AvailableBuffer() []byte</pre> <p>AvailableBuffer returns an empty buffer with b.Available() capacity. This buffer is intended to be appended to and passed to an immediately succeeding <a href="#Buffer.Write">Buffer.Write</a> call. The buffer is only valid until the next write operation on b. </p>   <h4 id="example_Buffer_AvailableBuffer"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var buf bytes.Buffer
for i := 0; i &lt; 4; i++ {
    b := buf.AvailableBuffer()
    b = strconv.AppendInt(b, int64(i), 10)
    b = append(b, ' ')
    buf.Write(b)
}
os.Stdout.Write(buf.Bytes())
</pre> <p>Output:</p> <pre class="output" data-language="go">0 1 2 3
</pre>   <h3 id="Buffer.Bytes">func (*Buffer) <span>Bytes</span>  </h3> <pre data-language="go">func (b *Buffer) Bytes() []byte</pre> <p>Bytes returns a slice of length b.Len() holding the unread portion of the buffer. The slice is valid for use only until the next buffer modification (that is, only until the next call to a method like <a href="#Buffer.Read">Buffer.Read</a>, <a href="#Buffer.Write">Buffer.Write</a>, <a href="#Buffer.Reset">Buffer.Reset</a>, or <a href="#Buffer.Truncate">Buffer.Truncate</a>). The slice aliases the buffer content at least until the next buffer modification, so immediate changes to the slice will affect the result of future reads. </p>   <h4 id="example_Buffer_Bytes"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">buf := bytes.Buffer{}
buf.Write([]byte{'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'})
os.Stdout.Write(buf.Bytes())
</pre> <p>Output:</p> <pre class="output" data-language="go">hello world
</pre>   <h3 id="Buffer.Cap">func (*Buffer) <span>Cap</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (b *Buffer) Cap() int</pre> <p>Cap returns the capacity of the buffer's underlying byte slice, that is, the total space allocated for the buffer's data. </p>   <h4 id="example_Buffer_Cap"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">buf1 := bytes.NewBuffer(make([]byte, 10))
buf2 := bytes.NewBuffer(make([]byte, 0, 10))
fmt.Println(buf1.Cap())
fmt.Println(buf2.Cap())
</pre> <p>Output:</p> <pre class="output" data-language="go">10
10
</pre>   <h3 id="Buffer.Grow">func (*Buffer) <span>Grow</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (b *Buffer) Grow(n int)</pre> <p>Grow grows the buffer's capacity, if necessary, to guarantee space for another n bytes. After Grow(n), at least n bytes can be written to the buffer without another allocation. If n is negative, Grow will panic. If the buffer can't grow it will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>   <h4 id="example_Buffer_Grow"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer
b.Grow(64)
bb := b.Bytes()
b.Write([]byte("64 bytes or fewer"))
fmt.Printf("%q", bb[:b.Len()])
</pre> <p>Output:</p> <pre class="output" data-language="go">"64 bytes or fewer"
</pre>   <h3 id="Buffer.Len">func (*Buffer) <span>Len</span>  </h3> <pre data-language="go">func (b *Buffer) Len() int</pre> <p>Len returns the number of bytes of the unread portion of the buffer; b.Len() == len(b.Bytes()). </p>   <h4 id="example_Buffer_Len"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer
b.Grow(64)
b.Write([]byte("abcde"))
fmt.Printf("%d", b.Len())
</pre> <p>Output:</p> <pre class="output" data-language="go">5
</pre>   <h3 id="Buffer.Next">func (*Buffer) <span>Next</span>  </h3> <pre data-language="go">func (b *Buffer) Next(n int) []byte</pre> <p>Next returns a slice containing the next n bytes from the buffer, advancing the buffer as if the bytes had been returned by <a href="#Buffer.Read">Buffer.Read</a>. If there are fewer than n bytes in the buffer, Next returns the entire buffer. The slice is only valid until the next call to a read or write method. </p>   <h4 id="example_Buffer_Next"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer
b.Grow(64)
b.Write([]byte("abcde"))
fmt.Printf("%s\n", b.Next(2))
fmt.Printf("%s\n", b.Next(2))
fmt.Printf("%s", b.Next(2))
</pre> <p>Output:</p> <pre class="output" data-language="go">ab
cd
e
</pre>   <h3 id="Buffer.Read">func (*Buffer) <span>Read</span>  </h3> <pre data-language="go">func (b *Buffer) Read(p []byte) (n int, err error)</pre> <p>Read reads the next len(p) bytes from the buffer or until the buffer is drained. The return value n is the number of bytes read. If the buffer has no data to return, err is <span>io.EOF</span> (unless len(p) is zero); otherwise it is nil. </p>   <h4 id="example_Buffer_Read"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer
b.Grow(64)
b.Write([]byte("abcde"))
rdbuf := make([]byte, 1)
n, err := b.Read(rdbuf)
if err != nil {
    panic(err)
}
fmt.Println(n)
fmt.Println(b.String())
fmt.Println(string(rdbuf))
</pre> <p>Output:</p> <pre class="output" data-language="go">1
bcde
a
</pre>   <h3 id="Buffer.ReadByte">func (*Buffer) <span>ReadByte</span>  </h3> <pre data-language="go">func (b *Buffer) ReadByte() (byte, error)</pre> <p>ReadByte reads and returns the next byte from the buffer. If no byte is available, it returns error <span>io.EOF</span>. </p>   <h4 id="example_Buffer_ReadByte"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">var b bytes.Buffer
b.Grow(64)
b.Write([]byte("abcde"))
c, err := b.ReadByte()
if err != nil {
    panic(err)
}
fmt.Println(c)
fmt.Println(b.String())
</pre> <p>Output:</p> <pre class="output" data-language="go">97
bcde
</pre>   <h3 id="Buffer.ReadBytes">func (*Buffer) <span>ReadBytes</span>  </h3> <pre data-language="go">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</pre> <p>ReadBytes reads until the first occurrence of delim in the input, returning a slice containing the data up to and including the delimiter. If ReadBytes encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often <span>io.EOF</span>). ReadBytes returns err != nil if and only if the returned data does not end in delim. </p>
<h3 id="Buffer.ReadFrom">func (*Buffer) <span>ReadFrom</span>  </h3> <pre data-language="go">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</pre> <p>ReadFrom reads data from r until EOF and appends it to the buffer, growing the buffer as needed. The return value n is the number of bytes read. Any error except io.EOF encountered during the read is also returned. If the buffer becomes too large, ReadFrom will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>
<h3 id="Buffer.ReadRune">func (*Buffer) <span>ReadRune</span>  </h3> <pre data-language="go">func (b *Buffer) ReadRune() (r rune, size int, err error)</pre> <p>ReadRune reads and returns the next UTF-8-encoded Unicode code point from the buffer. If no bytes are available, the error returned is io.EOF. If the bytes are an erroneous UTF-8 encoding, it consumes one byte and returns U+FFFD, 1. </p>
<h3 id="Buffer.ReadString">func (*Buffer) <span>ReadString</span>  </h3> <pre data-language="go">func (b *Buffer) ReadString(delim byte) (line string, err error)</pre> <p>ReadString reads until the first occurrence of delim in the input, returning a string containing the data up to and including the delimiter. If ReadString encounters an error before finding a delimiter, it returns the data read before the error and the error itself (often <span>io.EOF</span>). ReadString returns err != nil if and only if the returned data does not end in delim. </p>
<h3 id="Buffer.Reset">func (*Buffer) <span>Reset</span>  </h3> <pre data-language="go">func (b *Buffer) Reset()</pre> <p>Reset resets the buffer to be empty, but it retains the underlying storage for use by future writes. Reset is the same as <a href="#Buffer.Truncate">Buffer.Truncate</a>(0). </p>
<h3 id="Buffer.String">func (*Buffer) <span>String</span>  </h3> <pre data-language="go">func (b *Buffer) String() string</pre> <p>String returns the contents of the unread portion of the buffer as a string. If the <a href="#Buffer">Buffer</a> is a nil pointer, it returns "&lt;nil&gt;". </p>
<p>To build strings more efficiently, see the <span>strings.Builder</span> type. </p>
<h3 id="Buffer.Truncate">func (*Buffer) <span>Truncate</span>  </h3> <pre data-language="go">func (b *Buffer) Truncate(n int)</pre> <p>Truncate discards all but the first n unread bytes from the buffer but continues to use the same allocated storage. It panics if n is negative or greater than the length of the buffer. </p>
<h3 id="Buffer.UnreadByte">func (*Buffer) <span>UnreadByte</span>  </h3> <pre data-language="go">func (b *Buffer) UnreadByte() error</pre> <p>UnreadByte unreads the last byte returned by the most recent successful read operation that read at least one byte. If a write has happened since the last read, if the last read returned an error, or if the read read zero bytes, UnreadByte returns an error. </p>
<h3 id="Buffer.UnreadRune">func (*Buffer) <span>UnreadRune</span>  </h3> <pre data-language="go">func (b *Buffer) UnreadRune() error</pre> <p>UnreadRune unreads the last rune returned by <a href="#Buffer.ReadRune">Buffer.ReadRune</a>. If the most recent read or write operation on the buffer was not a successful <a href="#Buffer.ReadRune">Buffer.ReadRune</a>, UnreadRune returns an error. (In this regard it is stricter than <a href="#Buffer.UnreadByte">Buffer.UnreadByte</a>, which will unread the last byte from any read operation.) </p>
<h3 id="Buffer.Write">func (*Buffer) <span>Write</span>  </h3> <pre data-language="go">func (b *Buffer) Write(p []byte) (n int, err error)</pre> <p>Write appends the contents of p to the buffer, growing the buffer as needed. The return value n is the length of p; err is always nil. If the buffer becomes too large, Write will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>
<h3 id="Buffer.WriteByte">func (*Buffer) <span>WriteByte</span>  </h3> <pre data-language="go">func (b *Buffer) WriteByte(c byte) error</pre> <p>WriteByte appends the byte c to the buffer, growing the buffer as needed. The returned error is always nil, but is included to match <span>bufio.Writer</span>'s WriteByte. If the buffer becomes too large, WriteByte will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>
<h3 id="Buffer.WriteRune">func (*Buffer) <span>WriteRune</span>  </h3> <pre data-language="go">func (b *Buffer) WriteRune(r rune) (n int, err error)</pre> <p>WriteRune appends the UTF-8 encoding of Unicode code point r to the buffer, returning its length and an error, which is always nil but is included to match <span>bufio.Writer</span>'s WriteRune. The buffer is grown as needed; if it becomes too large, WriteRune will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>
<h3 id="Buffer.WriteString">func (*Buffer) <span>WriteString</span>  </h3> <pre data-language="go">func (b *Buffer) WriteString(s string) (n int, err error)</pre> <p>WriteString appends the contents of s to the buffer, growing the buffer as needed. The return value n is the length of s; err is always nil. If the buffer becomes too large, WriteString will panic with <a href="#ErrTooLarge">ErrTooLarge</a>. </p>
<h3 id="Buffer.WriteTo">func (*Buffer) <span>WriteTo</span>  </h3> <pre data-language="go">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</pre> <p>WriteTo writes data to w until the buffer is drained or an error occurs. The return value n is the number of bytes written; it always fits into an int, but it is int64 to match the <span>io.WriterTo</span> interface. Any error encountered during the write is also returned. </p>
<h2 id="Reader">type <span>Reader</span>  </h2> <p>A Reader implements the <span>io.Reader</span>, <span>io.ReaderAt</span>, <span>io.WriterTo</span>, <span>io.Seeker</span>, <span>io.ByteScanner</span>, and <span>io.RuneScanner</span> interfaces by reading from a byte slice. Unlike a <a href="#Buffer">Buffer</a>, a Reader is read-only and supports seeking. The zero value for Reader operates like a Reader of an empty slice. </p>
<pre data-language="go">type Reader struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="NewReader">func <span>NewReader</span>  </h3> <pre data-language="go">func NewReader(b []byte) *Reader</pre> <p>NewReader returns a new <a href="#Reader">Reader</a> reading from b. </p>
<h3 id="Reader.Len">func (*Reader) <span>Len</span>  </h3> <pre data-language="go">func (r *Reader) Len() int</pre> <p>Len returns the number of bytes of the unread portion of the slice. </p>   <h4 id="example_Reader_Len"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(bytes.NewReader([]byte("Hi!")).Len())
fmt.Println(bytes.NewReader([]byte("こんにちは!")).Len())
</pre> <p>Output:</p> <pre class="output" data-language="go">3
16
</pre>   <h3 id="Reader.Read">func (*Reader) <span>Read</span>  </h3> <pre data-language="go">func (r *Reader) Read(b []byte) (n int, err error)</pre> <p>Read implements the <span>io.Reader</span> interface. </p>
<h3 id="Reader.ReadAt">func (*Reader) <span>ReadAt</span>  </h3> <pre data-language="go">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</pre> <p>ReadAt implements the <span>io.ReaderAt</span> interface. </p>
<h3 id="Reader.ReadByte">func (*Reader) <span>ReadByte</span>  </h3> <pre data-language="go">func (r *Reader) ReadByte() (byte, error)</pre> <p>ReadByte implements the <span>io.ByteReader</span> interface. </p>
<h3 id="Reader.ReadRune">func (*Reader) <span>ReadRune</span>  </h3> <pre data-language="go">func (r *Reader) ReadRune() (ch rune, size int, err error)</pre> <p>ReadRune implements the <span>io.RuneReader</span> interface. </p>
<h3 id="Reader.Reset">func (*Reader) <span>Reset</span>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (r *Reader) Reset(b []byte)</pre> <p>Reset resets the <a href="#Reader">Reader</a> to be reading from b. </p>
<h3 id="Reader.Seek">func (*Reader) <span>Seek</span>  </h3> <pre data-language="go">func (r *Reader) Seek(offset int64, whence int) (int64, error)</pre> <p>Seek implements the <span>io.Seeker</span> interface. </p>
<h3 id="Reader.Size">func (*Reader) <span>Size</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (r *Reader) Size() int64</pre> <p>Size returns the original length of the underlying byte slice. Size is the number of bytes available for reading via <a href="#Reader.ReadAt">Reader.ReadAt</a>. The result is unaffected by any method calls except <a href="#Reader.Reset">Reader.Reset</a>. </p>
<h3 id="Reader.UnreadByte">func (*Reader) <span>UnreadByte</span>  </h3> <pre data-language="go">func (r *Reader) UnreadByte() error</pre> <p>UnreadByte complements <a href="#Reader.ReadByte">Reader.ReadByte</a> in implementing the <span>io.ByteScanner</span> interface. </p>
<h3 id="Reader.UnreadRune">func (*Reader) <span>UnreadRune</span>  </h3> <pre data-language="go">func (r *Reader) UnreadRune() error</pre> <p>UnreadRune complements <a href="#Reader.ReadRune">Reader.ReadRune</a> in implementing the <span>io.RuneScanner</span> interface. </p>
<h3 id="Reader.WriteTo">func (*Reader) <span>WriteTo</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</pre> <p>WriteTo implements the <span>io.WriterTo</span> interface. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/bytes/" class="_attribution-link">http://golang.org/pkg/bytes/</a>
  </p>
</div>
