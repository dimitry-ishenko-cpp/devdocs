<h1> Package net  </h1>     <ul id="short-nav">
<li><code>import "net"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
<li><a href="#pkg-subdirectories">Subdirectories</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package net provides a portable interface for network I/O, including TCP/IP, UDP, domain name resolution, and Unix domain sockets. </p>
<p>Although the package provides access to low-level networking primitives, most clients will need only the basic interface provided by the Dial, Listen, and Accept functions and the associated Conn and Listener interfaces. The crypto/tls package uses the same interfaces and similar Dial and Listen functions. </p>
<p>The Dial function connects to a server: </p>
<pre data-language="go">conn, err := net.Dial("tcp", "golang.org:80")
if err != nil {
	// handle error
}
fmt.Fprintf(conn, "GET / HTTP/1.0\r\n\r\n")
status, err := bufio.NewReader(conn).ReadString('\n')
// ...
</pre> <p>The Listen function creates servers: </p>
<pre data-language="go">ln, err := net.Listen("tcp", ":8080")
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
</pre> <h3 id="hdr-Name_Resolution">Name Resolution</h3> <p>The method for resolving domain names, whether indirectly with functions like Dial or directly with functions like LookupHost and LookupAddr, varies by operating system. </p>
<p>On Unix systems, the resolver has two options for resolving names. It can use a pure Go resolver that sends DNS requests directly to the servers listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C library routines such as getaddrinfo and getnameinfo. </p>
<p>By default the pure Go resolver is used, because a blocked DNS request consumes only a goroutine, while a blocked C call consumes an operating system thread. When cgo is available, the cgo-based resolver is used instead under a variety of conditions: on systems that do not let programs make direct DNS requests (OS X), when the LOCALDOMAIN environment variable is present (even if empty), when the RES_OPTIONS or HOSTALIASES environment variable is non-empty, when the ASR_CONFIG environment variable is non-empty (OpenBSD only), when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the Go resolver does not implement, and when the name being looked up ends in .local or is an mDNS name. </p>
<p>The resolver decision can be overridden by setting the netdns value of the GODEBUG environment variable (see package runtime) to go or cgo, as in: </p>
<pre data-language="go">export GODEBUG=netdns=go    # force pure Go resolver
export GODEBUG=netdns=cgo   # force native resolver (cgo, win32)
</pre> <p>The decision can also be forced while building the Go source tree by setting the netgo or netcgo build tag. </p>
<p>A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver to print debugging information about its decisions. To force a particular resolver while also printing debugging information, join the two settings by a plus sign, as in GODEBUG=netdns=go+1. </p>
<p>On macOS, if Go code that uses the net package is built with -buildmode=c-archive, linking the resulting archive into a C program requires passing -lresolv when linking the C code. </p>
<p>On Plan 9, the resolver always accesses /net/cs and /net/dns. </p>
<p>On Windows, in Go 1.18.x and earlier, the resolver always used C library functions, such as GetAddrInfo and DnsQuery. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></li>
<li><a href="#LookupAddr">func LookupAddr(addr string) (names []string, err error)</a></li>
<li><a href="#LookupCNAME">func LookupCNAME(host string) (cname string, err error)</a></li>
<li><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></li>
<li><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></li>
<li><a href="#LookupTXT">func LookupTXT(name string) ([]string, error)</a></li>
<li><a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a></li>
<li><a href="#Pipe">func Pipe() (Conn, Conn)</a></li>
<li><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></li>
<li><a href="#Addr">type Addr</a></li>
<li> <a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a>
</li>
<li><a href="#AddrError">type AddrError</a></li>
<li> <a href="#AddrError.Error">func (e *AddrError) Error() string</a>
</li>
<li> <a href="#AddrError.Temporary">func (e *AddrError) Temporary() bool</a>
</li>
<li> <a href="#AddrError.Timeout">func (e *AddrError) Timeout() bool</a>
</li>
<li><a href="#Buffers">type Buffers</a></li>
<li> <a href="#Buffers.Read">func (v *Buffers) Read(p []byte) (n int, err error)</a>
</li>
<li> <a href="#Buffers.WriteTo">func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</a>
</li>
<li><a href="#Conn">type Conn</a></li>
<li> <a href="#Dial">func Dial(network, address string) (Conn, error)</a>
</li>
<li> <a href="#DialTimeout">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</a>
</li>
<li> <a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a>
</li>
<li><a href="#DNSConfigError">type DNSConfigError</a></li>
<li> <a href="#DNSConfigError.Error">func (e *DNSConfigError) Error() string</a>
</li>
<li> <a href="#DNSConfigError.Temporary">func (e *DNSConfigError) Temporary() bool</a>
</li>
<li> <a href="#DNSConfigError.Timeout">func (e *DNSConfigError) Timeout() bool</a>
</li>
<li> <a href="#DNSConfigError.Unwrap">func (e *DNSConfigError) Unwrap() error</a>
</li>
<li><a href="#DNSError">type DNSError</a></li>
<li> <a href="#DNSError.Error">func (e *DNSError) Error() string</a>
</li>
<li> <a href="#DNSError.Temporary">func (e *DNSError) Temporary() bool</a>
</li>
<li> <a href="#DNSError.Timeout">func (e *DNSError) Timeout() bool</a>
</li>
<li><a href="#Dialer">type Dialer</a></li>
<li> <a href="#Dialer.Dial">func (d *Dialer) Dial(network, address string) (Conn, error)</a>
</li>
<li> <a href="#Dialer.DialContext">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</a>
</li>
<li> <a href="#Dialer.MultipathTCP">func (d *Dialer) MultipathTCP() bool</a>
</li>
<li> <a href="#Dialer.SetMultipathTCP">func (d *Dialer) SetMultipathTCP(use bool)</a>
</li>
<li><a href="#Error">type Error</a></li>
<li><a href="#Flags">type Flags</a></li>
<li> <a href="#Flags.String">func (f Flags) String() string</a>
</li>
<li><a href="#HardwareAddr">type HardwareAddr</a></li>
<li> <a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a>
</li>
<li> <a href="#HardwareAddr.String">func (a HardwareAddr) String() string</a>
</li>
<li><a href="#IP">type IP</a></li>
<li> <a href="#IPv4">func IPv4(a, b, c, d byte) IP</a>
</li>
<li> <a href="#LookupIP">func LookupIP(host string) ([]IP, error)</a>
</li>
<li> <a href="#ParseIP">func ParseIP(s string) IP</a>
</li>
<li> <a href="#IP.DefaultMask">func (ip IP) DefaultMask() IPMask</a>
</li>
<li> <a href="#IP.Equal">func (ip IP) Equal(x IP) bool</a>
</li>
<li> <a href="#IP.IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a>
</li>
<li> <a href="#IP.IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a>
</li>
<li> <a href="#IP.IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a>
</li>
<li> <a href="#IP.IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a>
</li>
<li> <a href="#IP.IsLoopback">func (ip IP) IsLoopback() bool</a>
</li>
<li> <a href="#IP.IsMulticast">func (ip IP) IsMulticast() bool</a>
</li>
<li> <a href="#IP.IsPrivate">func (ip IP) IsPrivate() bool</a>
</li>
<li> <a href="#IP.IsUnspecified">func (ip IP) IsUnspecified() bool</a>
</li>
<li> <a href="#IP.MarshalText">func (ip IP) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#IP.Mask">func (ip IP) Mask(mask IPMask) IP</a>
</li>
<li> <a href="#IP.String">func (ip IP) String() string</a>
</li>
<li> <a href="#IP.To16">func (ip IP) To16() IP</a>
</li>
<li> <a href="#IP.To4">func (ip IP) To4() IP</a>
</li>
<li> <a href="#IP.UnmarshalText">func (ip *IP) UnmarshalText(text []byte) error</a>
</li>
<li><a href="#IPAddr">type IPAddr</a></li>
<li> <a href="#ResolveIPAddr">func ResolveIPAddr(network, address string) (*IPAddr, error)</a>
</li>
<li> <a href="#IPAddr.Network">func (a *IPAddr) Network() string</a>
</li>
<li> <a href="#IPAddr.String">func (a *IPAddr) String() string</a>
</li>
<li><a href="#IPConn">type IPConn</a></li>
<li> <a href="#DialIP">func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)</a>
</li>
<li> <a href="#ListenIP">func ListenIP(network string, laddr *IPAddr) (*IPConn, error)</a>
</li>
<li> <a href="#IPConn.Close">func (c *IPConn) Close() error</a>
</li>
<li> <a href="#IPConn.File">func (c *IPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#IPConn.LocalAddr">func (c *IPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#IPConn.Read">func (c *IPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#IPConn.ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#IPConn.ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a>
</li>
<li> <a href="#IPConn.ReadMsgIP">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</a>
</li>
<li> <a href="#IPConn.RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#IPConn.SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#IPConn.SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#IPConn.SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#IPConn.SyscallConn">func (c *IPConn) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li> <a href="#IPConn.Write">func (c *IPConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#IPConn.WriteMsgIP">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#IPConn.WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#IPConn.WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a>
</li>
<li><a href="#IPMask">type IPMask</a></li>
<li> <a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a>
</li>
<li> <a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a>
</li>
<li> <a href="#IPMask.Size">func (m IPMask) Size() (ones, bits int)</a>
</li>
<li> <a href="#IPMask.String">func (m IPMask) String() string</a>
</li>
<li><a href="#IPNet">type IPNet</a></li>
<li> <a href="#IPNet.Contains">func (n *IPNet) Contains(ip IP) bool</a>
</li>
<li> <a href="#IPNet.Network">func (n *IPNet) Network() string</a>
</li>
<li> <a href="#IPNet.String">func (n *IPNet) String() string</a>
</li>
<li><a href="#Interface">type Interface</a></li>
<li> <a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a>
</li>
<li> <a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a>
</li>
<li> <a href="#Interfaces">func Interfaces() ([]Interface, error)</a>
</li>
<li> <a href="#Interface.Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a>
</li>
<li> <a href="#Interface.MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a>
</li>
<li><a href="#InvalidAddrError">type InvalidAddrError</a></li>
<li> <a href="#InvalidAddrError.Error">func (e InvalidAddrError) Error() string</a>
</li>
<li> <a href="#InvalidAddrError.Temporary">func (e InvalidAddrError) Temporary() bool</a>
</li>
<li> <a href="#InvalidAddrError.Timeout">func (e InvalidAddrError) Timeout() bool</a>
</li>
<li><a href="#ListenConfig">type ListenConfig</a></li>
<li> <a href="#ListenConfig.Listen">func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)</a>
</li>
<li> <a href="#ListenConfig.ListenPacket">func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)</a>
</li>
<li> <a href="#ListenConfig.MultipathTCP">func (lc *ListenConfig) MultipathTCP() bool</a>
</li>
<li> <a href="#ListenConfig.SetMultipathTCP">func (lc *ListenConfig) SetMultipathTCP(use bool)</a>
</li>
<li><a href="#Listener">type Listener</a></li>
<li> <a href="#FileListener">func FileListener(f *os.File) (ln Listener, err error)</a>
</li>
<li> <a href="#Listen">func Listen(network, address string) (Listener, error)</a>
</li>
<li><a href="#MX">type MX</a></li>
<li> <a href="#LookupMX">func LookupMX(name string) ([]*MX, error)</a>
</li>
<li><a href="#NS">type NS</a></li>
<li> <a href="#LookupNS">func LookupNS(name string) ([]*NS, error)</a>
</li>
<li><a href="#OpError">type OpError</a></li>
<li> <a href="#OpError.Error">func (e *OpError) Error() string</a>
</li>
<li> <a href="#OpError.Temporary">func (e *OpError) Temporary() bool</a>
</li>
<li> <a href="#OpError.Timeout">func (e *OpError) Timeout() bool</a>
</li>
<li> <a href="#OpError.Unwrap">func (e *OpError) Unwrap() error</a>
</li>
<li><a href="#PacketConn">type PacketConn</a></li>
<li> <a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a>
</li>
<li> <a href="#ListenPacket">func ListenPacket(network, address string) (PacketConn, error)</a>
</li>
<li><a href="#ParseError">type ParseError</a></li>
<li> <a href="#ParseError.Error">func (e *ParseError) Error() string</a>
</li>
<li> <a href="#ParseError.Temporary">func (e *ParseError) Temporary() bool</a>
</li>
<li> <a href="#ParseError.Timeout">func (e *ParseError) Timeout() bool</a>
</li>
<li><a href="#Resolver">type Resolver</a></li>
<li> <a href="#Resolver.LookupAddr">func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)</a>
</li>
<li> <a href="#Resolver.LookupCNAME">func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)</a>
</li>
<li> <a href="#Resolver.LookupHost">func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</a>
</li>
<li> <a href="#Resolver.LookupIP">func (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)</a>
</li>
<li> <a href="#Resolver.LookupIPAddr">func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</a>
</li>
<li> <a href="#Resolver.LookupMX">func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</a>
</li>
<li> <a href="#Resolver.LookupNS">func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</a>
</li>
<li> <a href="#Resolver.LookupNetIP">func (r *Resolver) LookupNetIP(ctx context.Context, network, host string) ([]netip.Addr, error)</a>
</li>
<li> <a href="#Resolver.LookupPort">func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)</a>
</li>
<li> <a href="#Resolver.LookupSRV">func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)</a>
</li>
<li> <a href="#Resolver.LookupTXT">func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</a>
</li>
<li><a href="#SRV">type SRV</a></li>
<li> <a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a>
</li>
<li><a href="#TCPAddr">type TCPAddr</a></li>
<li> <a href="#ResolveTCPAddr">func ResolveTCPAddr(network, address string) (*TCPAddr, error)</a>
</li>
<li> <a href="#TCPAddrFromAddrPort">func TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr</a>
</li>
<li> <a href="#TCPAddr.AddrPort">func (a *TCPAddr) AddrPort() netip.AddrPort</a>
</li>
<li> <a href="#TCPAddr.Network">func (a *TCPAddr) Network() string</a>
</li>
<li> <a href="#TCPAddr.String">func (a *TCPAddr) String() string</a>
</li>
<li><a href="#TCPConn">type TCPConn</a></li>
<li> <a href="#DialTCP">func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)</a>
</li>
<li> <a href="#TCPConn.Close">func (c *TCPConn) Close() error</a>
</li>
<li> <a href="#TCPConn.CloseRead">func (c *TCPConn) CloseRead() error</a>
</li>
<li> <a href="#TCPConn.CloseWrite">func (c *TCPConn) CloseWrite() error</a>
</li>
<li> <a href="#TCPConn.File">func (c *TCPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#TCPConn.LocalAddr">func (c *TCPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#TCPConn.MultipathTCP">func (c *TCPConn) MultipathTCP() (bool, error)</a>
</li>
<li> <a href="#TCPConn.Read">func (c *TCPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#TCPConn.ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a>
</li>
<li> <a href="#TCPConn.RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#TCPConn.SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a>
</li>
<li> <a href="#TCPConn.SetKeepAlivePeriod">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</a>
</li>
<li> <a href="#TCPConn.SetLinger">func (c *TCPConn) SetLinger(sec int) error</a>
</li>
<li> <a href="#TCPConn.SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a>
</li>
<li> <a href="#TCPConn.SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#TCPConn.SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#TCPConn.SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPConn.SyscallConn">func (c *TCPConn) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li> <a href="#TCPConn.Write">func (c *TCPConn) Write(b []byte) (int, error)</a>
</li>
<li><a href="#TCPListener">type TCPListener</a></li>
<li> <a href="#ListenTCP">func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)</a>
</li>
<li> <a href="#TCPListener.Accept">func (l *TCPListener) Accept() (Conn, error)</a>
</li>
<li> <a href="#TCPListener.AcceptTCP">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</a>
</li>
<li> <a href="#TCPListener.Addr">func (l *TCPListener) Addr() Addr</a>
</li>
<li> <a href="#TCPListener.Close">func (l *TCPListener) Close() error</a>
</li>
<li> <a href="#TCPListener.File">func (l *TCPListener) File() (f *os.File, err error)</a>
</li>
<li> <a href="#TCPListener.SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#TCPListener.SyscallConn">func (l *TCPListener) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li><a href="#UDPAddr">type UDPAddr</a></li>
<li> <a href="#ResolveUDPAddr">func ResolveUDPAddr(network, address string) (*UDPAddr, error)</a>
</li>
<li> <a href="#UDPAddrFromAddrPort">func UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr</a>
</li>
<li> <a href="#UDPAddr.AddrPort">func (a *UDPAddr) AddrPort() netip.AddrPort</a>
</li>
<li> <a href="#UDPAddr.Network">func (a *UDPAddr) Network() string</a>
</li>
<li> <a href="#UDPAddr.String">func (a *UDPAddr) String() string</a>
</li>
<li><a href="#UDPConn">type UDPConn</a></li>
<li> <a href="#DialUDP">func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#ListenMulticastUDP">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#ListenUDP">func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)</a>
</li>
<li> <a href="#UDPConn.Close">func (c *UDPConn) Close() error</a>
</li>
<li> <a href="#UDPConn.File">func (c *UDPConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UDPConn.LocalAddr">func (c *UDPConn) LocalAddr() Addr</a>
</li>
<li> <a href="#UDPConn.Read">func (c *UDPConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#UDPConn.ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#UDPConn.ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</a>
</li>
<li> <a href="#UDPConn.ReadFromUDPAddrPort">func (c *UDPConn) ReadFromUDPAddrPort(b []byte) (n int, addr netip.AddrPort, err error)</a>
</li>
<li> <a href="#UDPConn.ReadMsgUDP">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</a>
</li>
<li> <a href="#UDPConn.ReadMsgUDPAddrPort">func (c *UDPConn) ReadMsgUDPAddrPort(b, oob []byte) (n, oobn, flags int, addr netip.AddrPort, err error)</a>
</li>
<li> <a href="#UDPConn.RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#UDPConn.SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#UDPConn.SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#UDPConn.SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#UDPConn.SyscallConn">func (c *UDPConn) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li> <a href="#UDPConn.Write">func (c *UDPConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#UDPConn.WriteMsgUDP">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#UDPConn.WriteMsgUDPAddrPort">func (c *UDPConn) WriteMsgUDPAddrPort(b, oob []byte, addr netip.AddrPort) (n, oobn int, err error)</a>
</li>
<li> <a href="#UDPConn.WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#UDPConn.WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a>
</li>
<li> <a href="#UDPConn.WriteToUDPAddrPort">func (c *UDPConn) WriteToUDPAddrPort(b []byte, addr netip.AddrPort) (int, error)</a>
</li>
<li><a href="#UnixAddr">type UnixAddr</a></li>
<li> <a href="#ResolveUnixAddr">func ResolveUnixAddr(network, address string) (*UnixAddr, error)</a>
</li>
<li> <a href="#UnixAddr.Network">func (a *UnixAddr) Network() string</a>
</li>
<li> <a href="#UnixAddr.String">func (a *UnixAddr) String() string</a>
</li>
<li><a href="#UnixConn">type UnixConn</a></li>
<li> <a href="#DialUnix">func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)</a>
</li>
<li> <a href="#ListenUnixgram">func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)</a>
</li>
<li> <a href="#UnixConn.Close">func (c *UnixConn) Close() error</a>
</li>
<li> <a href="#UnixConn.CloseRead">func (c *UnixConn) CloseRead() error</a>
</li>
<li> <a href="#UnixConn.CloseWrite">func (c *UnixConn) CloseWrite() error</a>
</li>
<li> <a href="#UnixConn.File">func (c *UnixConn) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UnixConn.LocalAddr">func (c *UnixConn) LocalAddr() Addr</a>
</li>
<li> <a href="#UnixConn.Read">func (c *UnixConn) Read(b []byte) (int, error)</a>
</li>
<li> <a href="#UnixConn.ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</a>
</li>
<li> <a href="#UnixConn.ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</a>
</li>
<li> <a href="#UnixConn.ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a>
</li>
<li> <a href="#UnixConn.RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a>
</li>
<li> <a href="#UnixConn.SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a>
</li>
<li> <a href="#UnixConn.SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a>
</li>
<li> <a href="#UnixConn.SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixConn.SyscallConn">func (c *UnixConn) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li> <a href="#UnixConn.Write">func (c *UnixConn) Write(b []byte) (int, error)</a>
</li>
<li> <a href="#UnixConn.WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a>
</li>
<li> <a href="#UnixConn.WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</a>
</li>
<li> <a href="#UnixConn.WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</a>
</li>
<li><a href="#UnixListener">type UnixListener</a></li>
<li> <a href="#ListenUnix">func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)</a>
</li>
<li> <a href="#UnixListener.Accept">func (l *UnixListener) Accept() (Conn, error)</a>
</li>
<li> <a href="#UnixListener.AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a>
</li>
<li> <a href="#UnixListener.Addr">func (l *UnixListener) Addr() Addr</a>
</li>
<li> <a href="#UnixListener.Close">func (l *UnixListener) Close() error</a>
</li>
<li> <a href="#UnixListener.File">func (l *UnixListener) File() (f *os.File, err error)</a>
</li>
<li> <a href="#UnixListener.SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) error</a>
</li>
<li> <a href="#UnixListener.SetUnlinkOnClose">func (l *UnixListener) SetUnlinkOnClose(unlink bool)</a>
</li>
<li> <a href="#UnixListener.SyscallConn">func (l *UnixListener) SyscallConn() (syscall.RawConn, error)</a>
</li>
<li><a href="#UnknownNetworkError">type UnknownNetworkError</a></li>
<li> <a href="#UnknownNetworkError.Error">func (e UnknownNetworkError) Error() string</a>
</li>
<li> <a href="#UnknownNetworkError.Temporary">func (e UnknownNetworkError) Temporary() bool</a>
</li>
<li> <a href="#UnknownNetworkError.Timeout">func (e UnknownNetworkError) Timeout() bool</a>
</li>
<li><a href="#pkg-note-BUG">Bugs</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_CIDRMask">CIDRMask</a></dd> <dd><a class="exampleLink" href="#example_Dialer">Dialer</a></dd> <dd><a class="exampleLink" href="#example_Dialer_unix">Dialer (Unix)</a></dd> <dd><a class="exampleLink" href="#example_IP_DefaultMask">IP.DefaultMask</a></dd> <dd><a class="exampleLink" href="#example_IP_Equal">IP.Equal</a></dd> <dd><a class="exampleLink" href="#example_IP_IsGlobalUnicast">IP.IsGlobalUnicast</a></dd> <dd><a class="exampleLink" href="#example_IP_IsInterfaceLocalMulticast">IP.IsInterfaceLocalMulticast</a></dd> <dd><a class="exampleLink" href="#example_IP_IsLinkLocalMulticast">IP.IsLinkLocalMulticast</a></dd> <dd><a class="exampleLink" href="#example_IP_IsLinkLocalUnicast">IP.IsLinkLocalUnicast</a></dd> <dd><a class="exampleLink" href="#example_IP_IsLoopback">IP.IsLoopback</a></dd> <dd><a class="exampleLink" href="#example_IP_IsMulticast">IP.IsMulticast</a></dd> <dd><a class="exampleLink" href="#example_IP_IsPrivate">IP.IsPrivate</a></dd> <dd><a class="exampleLink" href="#example_IP_IsUnspecified">IP.IsUnspecified</a></dd> <dd><a class="exampleLink" href="#example_IP_Mask">IP.Mask</a></dd> <dd><a class="exampleLink" href="#example_IP_String">IP.String</a></dd> <dd><a class="exampleLink" href="#example_IP_To16">IP.To16</a></dd> <dd><a class="exampleLink" href="#example_IP_to4">IP (To4)</a></dd> <dd><a class="exampleLink" href="#example_IPv4">IPv4</a></dd> <dd><a class="exampleLink" href="#example_IPv4Mask">IPv4Mask</a></dd> <dd><a class="exampleLink" href="#example_Listener">Listener</a></dd> <dd><a class="exampleLink" href="#example_ParseCIDR">ParseCIDR</a></dd> <dd><a class="exampleLink" href="#example_ParseIP">ParseIP</a></dd> <dd><a class="exampleLink" href="#example_UDPConn_WriteTo">UDPConn.WriteTo</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>addrselect.go</span> <span>cgo_linux.go</span> <span>cgo_resnew.go</span> <span>cgo_socknew.go</span> <span>cgo_unix.go</span> <span>cgo_unix_cgo.go</span> <span>cgo_unix_cgo_res.go</span> <span>conf.go</span> <span>dial.go</span> <span>dnsclient.go</span> <span>dnsclient_unix.go</span> <span>dnsconfig.go</span> <span>dnsconfig_unix.go</span> <span>error_posix.go</span> <span>error_unix.go</span> <span>fd_posix.go</span> <span>fd_unix.go</span> <span>file.go</span> <span>file_unix.go</span> <span>hook.go</span> <span>hook_unix.go</span> <span>hosts.go</span> <span>interface.go</span> <span>interface_linux.go</span> <span>ip.go</span> <span>iprawsock.go</span> <span>iprawsock_posix.go</span> <span>ipsock.go</span> <span>ipsock_posix.go</span> <span>lookup.go</span> <span>lookup_unix.go</span> <span>mac.go</span> <span>mptcpsock_linux.go</span> <span>net.go</span> <span>netcgo_off.go</span> <span>netgo_off.go</span> <span>nss.go</span> <span>parse.go</span> <span>pipe.go</span> <span>port.go</span> <span>port_unix.go</span> <span>rawconn.go</span> <span>sendfile_linux.go</span> <span>sock_cloexec.go</span> <span>sock_linux.go</span> <span>sock_posix.go</span> <span>sockaddr_posix.go</span> <span>sockopt_linux.go</span> <span>sockopt_posix.go</span> <span>sockoptip_linux.go</span> <span>sockoptip_posix.go</span> <span>splice_linux.go</span> <span>tcpsock.go</span> <span>tcpsock_posix.go</span> <span>tcpsockopt_posix.go</span> <span>tcpsockopt_unix.go</span> <span>udpsock.go</span> <span>udpsock_posix.go</span> <span>unixsock.go</span> <span>unixsock_posix.go</span> <span>unixsock_readmsg_cmsg_cloexec.go</span> <span>writev_unix.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <p>IP address lengths (bytes). </p>
<pre data-language="go">const (
    IPv4len = 4
    IPv6len = 16
)</pre> <h2 id="pkg-variables">Variables</h2> <p>Well-known IPv4 addresses </p>
<pre data-language="go">var (
    IPv4bcast     = IPv4(255, 255, 255, 255) // limited broadcast
    IPv4allsys    = IPv4(224, 0, 0, 1)       // all systems
    IPv4allrouter = IPv4(224, 0, 0, 2)       // all routers
    IPv4zero      = IPv4(0, 0, 0, 0)         // all zeros
)</pre> <p>Well-known IPv6 addresses </p>
<pre data-language="go">var (
    IPv6zero                   = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6unspecified            = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    IPv6loopback               = IP{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    IPv6interfacelocalallnodes = IP{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallnodes      = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    IPv6linklocalallrouters    = IP{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre> <p>DefaultResolver is the resolver used by the package-level Lookup functions and by Dialers without a specified Resolver. </p>
<pre data-language="go">var DefaultResolver = &amp;Resolver{}</pre> <p>ErrClosed is the error returned by an I/O call on a network connection that has already been closed, or that is closed by another goroutine before the I/O is completed. This may be wrapped in another error, and should normally be tested using errors.Is(err, net.ErrClosed). </p>
<pre data-language="go">var ErrClosed error = errClosed</pre> <p>Various errors contained in OpError. </p>
<pre data-language="go">var (
    ErrWriteToConnected = errors.New("use of WriteTo with pre-connected connection")
)</pre> <h2 id="JoinHostPort">func <span>JoinHostPort</span>  </h2> <pre data-language="go">func JoinHostPort(host, port string) string</pre> <p>JoinHostPort combines host and port into a network address of the form "host:port". If host contains a colon, as found in literal IPv6 addresses, then JoinHostPort returns "[host]:port". </p>
<p>See func Dial for a description of the host and port parameters. </p>
<h2 id="LookupAddr">func <span>LookupAddr</span>  </h2> <pre data-language="go">func LookupAddr(addr string) (names []string, err error)</pre> <p>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. </p>
<p>The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<p>When using the host C library resolver, at most one result will be returned. To bypass the host resolver, use a custom Resolver. </p>
<p>LookupAddr uses context.Background internally; to specify the context, use Resolver.LookupAddr. </p>
<h2 id="LookupCNAME">func <span>LookupCNAME</span>  </h2> <pre data-language="go">func LookupCNAME(host string) (cname string, err error)</pre> <p>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. </p>
<p>A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS "CNAME" records, as long as host resolves to address records. </p>
<p>The returned canonical name is validated to be a properly formatted presentation-format domain name. </p>
<p>LookupCNAME uses context.Background internally; to specify the context, use Resolver.LookupCNAME. </p>
<h2 id="LookupHost">func <span>LookupHost</span>  </h2> <pre data-language="go">func LookupHost(host string) (addrs []string, err error)</pre> <p>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. </p>
<p>LookupHost uses context.Background internally; to specify the context, use Resolver.LookupHost. </p>
<h2 id="LookupPort">func <span>LookupPort</span>  </h2> <pre data-language="go">func LookupPort(network, service string) (port int, err error)</pre> <p>LookupPort looks up the port for the given network and service. </p>
<p>LookupPort uses context.Background internally; to specify the context, use Resolver.LookupPort. </p>
<h2 id="LookupTXT">func <span>LookupTXT</span>  </h2> <pre data-language="go">func LookupTXT(name string) ([]string, error)</pre> <p>LookupTXT returns the DNS TXT records for the given domain name. </p>
<p>LookupTXT uses context.Background internally; to specify the context, use Resolver.LookupTXT. </p>
<h2 id="ParseCIDR">func <span>ParseCIDR</span>  </h2> <pre data-language="go">func ParseCIDR(s string) (IP, *IPNet, error)</pre> <p>ParseCIDR parses s as a CIDR notation IP address and prefix length, like "192.0.2.0/24" or "2001:db8::/32", as defined in RFC 4632 and RFC 4291. </p>
<p>It returns the IP address and the network implied by the IP and prefix length. For example, ParseCIDR("192.0.2.1/24") returns the IP address 192.0.2.1 and the network 192.0.2.0/24. </p>   <h4 id="example_ParseCIDR"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv4Addr, ipv4Net, err := net.ParseCIDR("192.0.2.1/24")
if err != nil {
    log.Fatal(err)
}
fmt.Println(ipv4Addr)
fmt.Println(ipv4Net)

ipv6Addr, ipv6Net, err := net.ParseCIDR("2001:db8:a0b:12f0::1/32")
if err != nil {
    log.Fatal(err)
}
fmt.Println(ipv6Addr)
fmt.Println(ipv6Net)

</pre> <p>Output:</p> <pre class="output" data-language="go">192.0.2.1
192.0.2.0/24
2001:db8:a0b:12f0::1
2001:db8::/32
</pre>   <h2 id="Pipe">func <span>Pipe</span>  </h2> <pre data-language="go">func Pipe() (Conn, Conn)</pre> <p>Pipe creates a synchronous, in-memory, full duplex network connection; both ends implement the Conn interface. Reads on one end are matched with writes on the other, copying data directly between the two; there is no internal buffering. </p>
<h2 id="SplitHostPort">func <span>SplitHostPort</span>  </h2> <pre data-language="go">func SplitHostPort(hostport string) (host, port string, err error)</pre> <p>SplitHostPort splits a network address of the form "host:port", "host%zone:port", "[host]:port" or "[host%zone]:port" into host or host%zone and port. </p>
<p>A literal IPv6 address in hostport must be enclosed in square brackets, as in "[::1]:80", "[::1%lo0]:80". </p>
<p>See func Dial for a description of the hostport parameter, and host and port results. </p>
<h2 id="Addr">type <span>Addr</span>  </h2> <p>Addr represents a network end point address. </p>
<p>The two methods Network and String conventionally return strings that can be passed as the arguments to Dial, but the exact form and meaning of the strings is up to the implementation. </p>
<pre data-language="go">type Addr interface {
    Network() string // name of the network (for example, "tcp", "udp")
    String() string  // string form of address (for example, "192.0.2.1:25", "[2001:db8::1]:80")
}</pre> <h3 id="InterfaceAddrs">func <span>InterfaceAddrs</span>  </h3> <pre data-language="go">func InterfaceAddrs() ([]Addr, error)</pre> <p>InterfaceAddrs returns a list of the system's unicast interface addresses. </p>
<p>The returned list does not identify the associated interface; use Interfaces and Interface.Addrs for more detail. </p>
<h2 id="AddrError">type <span>AddrError</span>  </h2> <pre data-language="go">type AddrError struct {
    Err  string
    Addr string
}
</pre> <h3 id="AddrError.Error">func (*AddrError) <span>Error</span>  </h3> <pre data-language="go">func (e *AddrError) Error() string</pre> <h3 id="AddrError.Temporary">func (*AddrError) <span>Temporary</span>  </h3> <pre data-language="go">func (e *AddrError) Temporary() bool</pre> <h3 id="AddrError.Timeout">func (*AddrError) <span>Timeout</span>  </h3> <pre data-language="go">func (e *AddrError) Timeout() bool</pre> <h2 id="Buffers">type <span>Buffers</span>  <span title="Added in Go 1.8">1.8</span> </h2> <p>Buffers contains zero or more runs of bytes to write. </p>
<p>On certain machines, for certain types of connections, this is optimized into an OS-specific batch write operation (such as "writev"). </p>
<pre data-language="go">type Buffers [][]byte</pre> <h3 id="Buffers.Read">func (*Buffers) <span>Read</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (v *Buffers) Read(p []byte) (n int, err error)</pre> <p>Read from the buffers. </p>
<p>Read implements io.Reader for Buffers. </p>
<p>Read modifies the slice v as well as v[i] for 0 &lt;= i &lt; len(v), but does not modify v[i][j] for any i, j. </p>
<h3 id="Buffers.WriteTo">func (*Buffers) <span>WriteTo</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</pre> <p>WriteTo writes contents of the buffers to w. </p>
<p>WriteTo implements io.WriterTo for Buffers. </p>
<p>WriteTo modifies the slice v as well as v[i] for 0 &lt;= i &lt; len(v), but does not modify v[i][j] for any i, j. </p>
<h2 id="Conn">type <span>Conn</span>  </h2> <p>Conn is a generic stream-oriented network connection. </p>
<p>Multiple goroutines may invoke methods on a Conn simultaneously. </p>
<pre data-language="go">type Conn interface {
    // Read reads data from the connection.
    // Read can be made to time out and return an error after a fixed
    // time limit; see SetDeadline and SetReadDeadline.
    Read(b []byte) (n int, err error)

    // Write writes data to the connection.
    // Write can be made to time out and return an error after a fixed
    // time limit; see SetDeadline and SetWriteDeadline.
    Write(b []byte) (n int, err error)

    // Close closes the connection.
    // Any blocked Read or Write operations will be unblocked and return errors.
    Close() error

    // LocalAddr returns the local network address, if known.
    LocalAddr() Addr

    // RemoteAddr returns the remote network address, if known.
    RemoteAddr() Addr

    // SetDeadline sets the read and write deadlines associated
    // with the connection. It is equivalent to calling both
    // SetReadDeadline and SetWriteDeadline.
    //
    // A deadline is an absolute time after which I/O operations
    // fail instead of blocking. The deadline applies to all future
    // and pending I/O, not just the immediately following call to
    // Read or Write. After a deadline has been exceeded, the
    // connection can be refreshed by setting a deadline in the future.
    //
    // If the deadline is exceeded a call to Read or Write or to other
    // I/O methods will return an error that wraps os.ErrDeadlineExceeded.
    // This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
    // The error's Timeout method will return true, but note that there
    // are other possible errors for which the Timeout method will
    // return true even if the deadline has not been exceeded.
    //
    // An idle timeout can be implemented by repeatedly extending
    // the deadline after successful Read or Write calls.
    //
    // A zero value for t means I/O operations will not time out.
    SetDeadline(t time.Time) error

    // SetReadDeadline sets the deadline for future Read calls
    // and any currently-blocked Read call.
    // A zero value for t means Read will not time out.
    SetReadDeadline(t time.Time) error

    // SetWriteDeadline sets the deadline for future Write calls
    // and any currently-blocked Write call.
    // Even if write times out, it may return n &gt; 0, indicating that
    // some of the data was successfully written.
    // A zero value for t means Write will not time out.
    SetWriteDeadline(t time.Time) error
}</pre> <h3 id="Dial">func <span>Dial</span>  </h3> <pre data-language="go">func Dial(network, address string) (Conn, error)</pre> <p>Dial connects to the address on the named network. </p>
<p>Known networks are "tcp", "tcp4" (IPv4-only), "tcp6" (IPv6-only), "udp", "udp4" (IPv4-only), "udp6" (IPv6-only), "ip", "ip4" (IPv4-only), "ip6" (IPv6-only), "unix", "unixgram" and "unixpacket". </p>
<p>For TCP and UDP networks, the address has the form "host:port". The host must be a literal IP address, or a host name that can be resolved to IP addresses. The port must be a literal port number or a service name. If the host is a literal IPv6 address it must be enclosed in square brackets, as in "[2001:db8::1]:80" or "[fe80::1%zone]:80". The zone specifies the scope of the literal IPv6 address as defined in RFC 4007. The functions JoinHostPort and SplitHostPort manipulate a pair of host and port in this form. When using TCP, and the host resolves to multiple IP addresses, Dial will try each IP address in order until one succeeds. </p>
<p>Examples: </p>
<pre data-language="go">Dial("tcp", "golang.org:http")
Dial("tcp", "192.0.2.1:http")
Dial("tcp", "198.51.100.1:80")
Dial("udp", "[2001:db8::1]:domain")
Dial("udp", "[fe80::1%lo0]:53")
Dial("tcp", ":80")
</pre> <p>For IP networks, the network must be "ip", "ip4" or "ip6" followed by a colon and a literal protocol number or a protocol name, and the address has the form "host". The host must be a literal IP address or a literal IPv6 address with zone. It depends on each operating system how the operating system behaves with a non-well known protocol number such as "0" or "255". </p>
<p>Examples: </p>
<pre data-language="go">Dial("ip4:1", "192.0.2.1")
Dial("ip6:ipv6-icmp", "2001:db8::1")
Dial("ip6:58", "fe80::1%lo0")
</pre> <p>For TCP, UDP and IP networks, if the host is empty or a literal unspecified IP address, as in ":80", "0.0.0.0:80" or "[::]:80" for TCP and UDP, "", "0.0.0.0" or "::" for IP, the local system is assumed. </p>
<p>For Unix networks, the address must be a file system path. </p>
<h3 id="DialTimeout">func <span>DialTimeout</span>  </h3> <pre data-language="go">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</pre> <p>DialTimeout acts like Dial but takes a timeout. </p>
<p>The timeout includes name resolution, if required. When using TCP, and the host in the address parameter resolves to multiple IP addresses, the timeout is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="FileConn">func <span>FileConn</span>  </h3> <pre data-language="go">func FileConn(f *os.File) (c Conn, err error)</pre> <p>FileConn returns a copy of the network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<h2 id="DNSConfigError">type <span>DNSConfigError</span>  </h2> <p>DNSConfigError represents an error reading the machine's DNS configuration. (No longer used; kept for compatibility.) </p>
<pre data-language="go">type DNSConfigError struct {
    Err error
}
</pre> <h3 id="DNSConfigError.Error">func (*DNSConfigError) <span>Error</span>  </h3> <pre data-language="go">func (e *DNSConfigError) Error() string</pre> <h3 id="DNSConfigError.Temporary">func (*DNSConfigError) <span>Temporary</span>  </h3> <pre data-language="go">func (e *DNSConfigError) Temporary() bool</pre> <h3 id="DNSConfigError.Timeout">func (*DNSConfigError) <span>Timeout</span>  </h3> <pre data-language="go">func (e *DNSConfigError) Timeout() bool</pre> <h3 id="DNSConfigError.Unwrap">func (*DNSConfigError) <span>Unwrap</span>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (e *DNSConfigError) Unwrap() error</pre> <h2 id="DNSError">type <span>DNSError</span>  </h2> <p>DNSError represents a DNS lookup error. </p>
<pre data-language="go">type DNSError struct {
    Err         string // description of the error
    Name        string // name looked for
    Server      string // server used
    IsTimeout   bool   // if true, timed out; not all timeouts set this
    IsTemporary bool   // if true, error is temporary; not all errors set this; added in Go 1.6
    IsNotFound  bool   // if true, host could not be found; added in Go 1.13
}
</pre> <h3 id="DNSError.Error">func (*DNSError) <span>Error</span>  </h3> <pre data-language="go">func (e *DNSError) Error() string</pre> <h3 id="DNSError.Temporary">func (*DNSError) <span>Temporary</span>  </h3> <pre data-language="go">func (e *DNSError) Temporary() bool</pre> <p>Temporary reports whether the DNS error is known to be temporary. This is not always known; a DNS lookup may fail due to a temporary error and return a DNSError for which Temporary returns false. </p>
<h3 id="DNSError.Timeout">func (*DNSError) <span>Timeout</span>  </h3> <pre data-language="go">func (e *DNSError) Timeout() bool</pre> <p>Timeout reports whether the DNS lookup is known to have timed out. This is not always known; a DNS lookup may fail due to a timeout and return a DNSError for which Timeout returns false. </p>
<h2 id="Dialer">type <span>Dialer</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>A Dialer contains options for connecting to an address. </p>
<p>The zero value for each field is equivalent to dialing without that option. Dialing with the zero value of Dialer is therefore equivalent to just calling the Dial function. </p>
<p>It is safe to call Dialer's methods concurrently. </p>
<pre data-language="go">type Dialer struct {
    // Timeout is the maximum amount of time a dial will wait for
    // a connect to complete. If Deadline is also set, it may fail
    // earlier.
    //
    // The default is no timeout.
    //
    // When using TCP and dialing a host name with multiple IP
    // addresses, the timeout may be divided between them.
    //
    // With or without a timeout, the operating system may impose
    // its own earlier timeout. For instance, TCP timeouts are
    // often around 3 minutes.
    Timeout time.Duration

    // Deadline is the absolute point in time after which dials
    // will fail. If Timeout is set, it may fail earlier.
    // Zero means no deadline, or dependent on the operating system
    // as with the Timeout option.
    Deadline time.Time

    // LocalAddr is the local address to use when dialing an
    // address. The address must be of a compatible type for the
    // network being dialed.
    // If nil, a local address is automatically chosen.
    LocalAddr Addr

    // DualStack previously enabled RFC 6555 Fast Fallback
    // support, also known as "Happy Eyeballs", in which IPv4 is
    // tried soon if IPv6 appears to be misconfigured and
    // hanging.
    //
    // Deprecated: Fast Fallback is enabled by default. To
    // disable, set FallbackDelay to a negative value.
    DualStack bool // Go 1.2

    // FallbackDelay specifies the length of time to wait before
    // spawning a RFC 6555 Fast Fallback connection. That is, this
    // is the amount of time to wait for IPv6 to succeed before
    // assuming that IPv6 is misconfigured and falling back to
    // IPv4.
    //
    // If zero, a default delay of 300ms is used.
    // A negative value disables Fast Fallback support.
    FallbackDelay time.Duration // Go 1.5

    // KeepAlive specifies the interval between keep-alive
    // probes for an active network connection.
    // If zero, keep-alive probes are sent with a default value
    // (currently 15 seconds), if supported by the protocol and operating
    // system. Network protocols or operating systems that do
    // not support keep-alives ignore this field.
    // If negative, keep-alive probes are disabled.
    KeepAlive time.Duration // Go 1.3

    // Resolver optionally specifies an alternate resolver to use.
    Resolver *Resolver // Go 1.8

    // Cancel is an optional channel whose closure indicates that
    // the dial should be canceled. Not all types of dials support
    // cancellation.
    //
    // Deprecated: Use DialContext instead.
    Cancel &lt;-chan struct{} // Go 1.6

    // If Control is not nil, it is called after creating the network
    // connection but before actually dialing.
    //
    // Network and address parameters passed to Control function are not
    // necessarily the ones passed to Dial. For example, passing "tcp" to Dial
    // will cause the Control function to be called with "tcp4" or "tcp6".
    //
    // Control is ignored if ControlContext is not nil.
    Control func(network, address string, c syscall.RawConn) error // Go 1.11

    // If ControlContext is not nil, it is called after creating the network
    // connection but before actually dialing.
    //
    // Network and address parameters passed to ControlContext function are not
    // necessarily the ones passed to Dial. For example, passing "tcp" to Dial
    // will cause the ControlContext function to be called with "tcp4" or "tcp6".
    //
    // If ControlContext is not nil, Control is ignored.
    ControlContext func(ctx context.Context, network, address string, c syscall.RawConn) error // Go 1.20
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Dialer"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
var d net.Dialer
ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
defer cancel()

conn, err := d.DialContext(ctx, "tcp", "localhost:12345")
if err != nil {
    log.Fatalf("Failed to dial: %v", err)
}
defer conn.Close()

if _, err := conn.Write([]byte("Hello, World!")); err != nil {
    log.Fatal(err)
}
</pre>      <h4 id="example_Dialer_unix"> <span class="text">Example (Unix)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// DialUnix does not take a context.Context parameter. This example shows
// how to dial a Unix socket with a Context. Note that the Context only
// applies to the dial operation; it does not apply to the connection once
// it has been established.
var d net.Dialer
ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
defer cancel()

d.LocalAddr = nil // if you have a local addr, add it here
raddr := net.UnixAddr{Name: "/path/to/unix.sock", Net: "unix"}
conn, err := d.DialContext(ctx, "unix", raddr.String())
if err != nil {
    log.Fatalf("Failed to dial: %v", err)
}
defer conn.Close()
if _, err := conn.Write([]byte("Hello, socket!")); err != nil {
    log.Fatal(err)
}
</pre>   <h3 id="Dialer.Dial">func (*Dialer) <span>Dial</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (d *Dialer) Dial(network, address string) (Conn, error)</pre> <p>Dial connects to the address on the named network. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<p>Dial uses context.Background internally; to specify the context, use DialContext. </p>
<h3 id="Dialer.DialContext">func (*Dialer) <span>DialContext</span>  <span title="Added in Go 1.7">1.7</span> </h3> <pre data-language="go">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</pre> <p>DialContext connects to the address on the named network using the provided context. </p>
<p>The provided Context must be non-nil. If the context expires before the connection is complete, an error is returned. Once successfully connected, any expiration of the context will not affect the connection. </p>
<p>When using TCP, and the host in the address parameter resolves to multiple network addresses, any dial timeout (from d.Timeout or ctx) is spread over each consecutive dial, such that each is given an appropriate fraction of the time to connect. For example, if a host has 4 IP addresses and the timeout is 1 minute, the connect to each single address will be given 15 seconds to complete before trying the next one. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="Dialer.MultipathTCP">func (*Dialer) <span>MultipathTCP</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (d *Dialer) MultipathTCP() bool</pre> <p>MultipathTCP reports whether MPTCP will be used. </p>
<p>This method doesn't check if MPTCP is supported by the operating system or not. </p>
<h3 id="Dialer.SetMultipathTCP">func (*Dialer) <span>SetMultipathTCP</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (d *Dialer) SetMultipathTCP(use bool)</pre> <p>SetMultipathTCP directs the Dial methods to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any. </p>
<p>If MPTCP is not available on the host or not supported by the server, the Dial methods will fall back to TCP. </p>
<h2 id="Error">type <span>Error</span>  </h2> <p>An Error represents a network error. </p>
<pre data-language="go">type Error interface {
    error
    Timeout() bool // Is the error a timeout?

    // Deprecated: Temporary errors are not well-defined.
    // Most "temporary" errors are timeouts, and the few exceptions are surprising.
    // Do not use this method.
    Temporary() bool
}</pre> <h2 id="Flags">type <span>Flags</span>  </h2> <pre data-language="go">type Flags uint</pre> <pre data-language="go">const (
    FlagUp           Flags = 1 &lt;&lt; iota // interface is administratively up
    FlagBroadcast                      // interface supports broadcast access capability
    FlagLoopback                       // interface is a loopback interface
    FlagPointToPoint                   // interface belongs to a point-to-point link
    FlagMulticast                      // interface supports multicast access capability
    FlagRunning                        // interface is in running state
)</pre> <h3 id="Flags.String">func (Flags) <span>String</span>  </h3> <pre data-language="go">func (f Flags) String() string</pre> <h2 id="HardwareAddr">type <span>HardwareAddr</span>  </h2> <p>A HardwareAddr represents a physical hardware address. </p>
<pre data-language="go">type HardwareAddr []byte</pre> <h3 id="ParseMAC">func <span>ParseMAC</span>  </h3> <pre data-language="go">func ParseMAC(s string) (hw HardwareAddr, err error)</pre> <p>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet IP over InfiniBand link-layer address using one of the following formats: </p>
<pre data-language="go">00:00:5e:00:53:01
02:00:5e:10:00:00:00:01
00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01
00-00-5e-00-53-01
02-00-5e-10-00-00-00-01
00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01
0000.5e00.5301
0200.5e10.0000.0001
0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001
</pre> <h3 id="HardwareAddr.String">func (HardwareAddr) <span>String</span>  </h3> <pre data-language="go">func (a HardwareAddr) String() string</pre> <h2 id="IP">type <span>IP</span>  </h2> <p>An IP is a single IP address, a slice of bytes. Functions in this package accept either 4-byte (IPv4) or 16-byte (IPv6) slices as input. </p>
<p>Note that in this documentation, referring to an IP address as an IPv4 address or an IPv6 address is a semantic property of the address, not just the length of the byte slice: a 16-byte slice can still be an IPv4 address. </p>
<pre data-language="go">type IP []byte</pre>    <h4 id="example_IP_to4"> <span class="text">Example (To4)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.To4())
fmt.Println(ipv4.To4())

</pre> <p>Output:</p> <pre class="output" data-language="go">&lt;nil&gt;
10.255.0.0
</pre>   <h3 id="IPv4">func <span>IPv4</span>  </h3> <pre data-language="go">func IPv4(a, b, c, d byte) IP</pre> <p>IPv4 returns the IP address (in 16-byte form) of the IPv4 address a.b.c.d. </p>   <h4 id="example_IPv4"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(net.IPv4(8, 8, 8, 8))

</pre> <p>Output:</p> <pre class="output" data-language="go">8.8.8.8
</pre>   <h3 id="LookupIP">func <span>LookupIP</span>  </h3> <pre data-language="go">func LookupIP(host string) ([]IP, error)</pre> <p>LookupIP looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. </p>
<h3 id="ParseIP">func <span>ParseIP</span>  </h3> <pre data-language="go">func ParseIP(s string) IP</pre> <p>ParseIP parses s as an IP address, returning the result. The string s can be in IPv4 dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"), or IPv4-mapped IPv6 ("::ffff:192.0.2.1") form. If s is not a valid textual representation of an IP address, ParseIP returns nil. </p>   <h4 id="example_ParseIP"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(net.ParseIP("192.0.2.1"))
fmt.Println(net.ParseIP("2001:db8::68"))
fmt.Println(net.ParseIP("192.0.2"))

</pre> <p>Output:</p> <pre class="output" data-language="go">192.0.2.1
2001:db8::68
&lt;nil&gt;
</pre>   <h3 id="IP.DefaultMask">func (IP) <span>DefaultMask</span>  </h3> <pre data-language="go">func (ip IP) DefaultMask() IPMask</pre> <p>DefaultMask returns the default IP mask for the IP address ip. Only IPv4 addresses have default masks; DefaultMask returns nil if ip is not a valid IPv4 address. </p>   <h4 id="example_IP_DefaultMask"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ip := net.ParseIP("192.0.2.1")
fmt.Println(ip.DefaultMask())

</pre> <p>Output:</p> <pre class="output" data-language="go">ffffff00
</pre>   <h3 id="IP.Equal">func (IP) <span>Equal</span>  </h3> <pre data-language="go">func (ip IP) Equal(x IP) bool</pre> <p>Equal reports whether ip and x are the same IP address. An IPv4 address and that same address in IPv6 form are considered to be equal. </p>   <h4 id="example_IP_Equal"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv4DNS := net.ParseIP("8.8.8.8")
ipv4Lo := net.ParseIP("127.0.0.1")
ipv6DNS := net.ParseIP("0:0:0:0:0:FFFF:0808:0808")

fmt.Println(ipv4DNS.Equal(ipv4DNS))
fmt.Println(ipv4DNS.Equal(ipv4Lo))
fmt.Println(ipv4DNS.Equal(ipv6DNS))

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
</pre>   <h3 id="IP.IsGlobalUnicast">func (IP) <span>IsGlobalUnicast</span>  </h3> <pre data-language="go">func (ip IP) IsGlobalUnicast() bool</pre> <p>IsGlobalUnicast reports whether ip is a global unicast address. </p>
<p>The identification of global unicast addresses uses address type identification as defined in RFC 1122, RFC 4632 and RFC 4291 with the exception of IPv4 directed broadcast addresses. It returns true even if ip is in IPv4 private address space or local IPv6 unicast address space. </p>   <h4 id="example_IP_IsGlobalUnicast"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6Global := net.ParseIP("2000::")
ipv6UniqLocal := net.ParseIP("2000::")
ipv6Multi := net.ParseIP("FF00::")

ipv4Private := net.ParseIP("10.255.0.0")
ipv4Public := net.ParseIP("8.8.8.8")
ipv4Broadcast := net.ParseIP("255.255.255.255")

fmt.Println(ipv6Global.IsGlobalUnicast())
fmt.Println(ipv6UniqLocal.IsGlobalUnicast())
fmt.Println(ipv6Multi.IsGlobalUnicast())

fmt.Println(ipv4Private.IsGlobalUnicast())
fmt.Println(ipv4Public.IsGlobalUnicast())
fmt.Println(ipv4Broadcast.IsGlobalUnicast())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
true
false
true
true
false
</pre>   <h3 id="IP.IsInterfaceLocalMulticast">func (IP) <span>IsInterfaceLocalMulticast</span>  </h3> <pre data-language="go">func (ip IP) IsInterfaceLocalMulticast() bool</pre> <p>IsInterfaceLocalMulticast reports whether ip is an interface-local multicast address. </p>   <h4 id="example_IP_IsInterfaceLocalMulticast"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6InterfaceLocalMulti := net.ParseIP("ff01::1")
ipv6Global := net.ParseIP("2000::")
ipv4 := net.ParseIP("255.0.0.0")

fmt.Println(ipv6InterfaceLocalMulti.IsInterfaceLocalMulticast())
fmt.Println(ipv6Global.IsInterfaceLocalMulticast())
fmt.Println(ipv4.IsInterfaceLocalMulticast())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
false
</pre>   <h3 id="IP.IsLinkLocalMulticast">func (IP) <span>IsLinkLocalMulticast</span>  </h3> <pre data-language="go">func (ip IP) IsLinkLocalMulticast() bool</pre> <p>IsLinkLocalMulticast reports whether ip is a link-local multicast address. </p>   <h4 id="example_IP_IsLinkLocalMulticast"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6LinkLocalMulti := net.ParseIP("ff02::2")
ipv6LinkLocalUni := net.ParseIP("fe80::")
ipv4LinkLocalMulti := net.ParseIP("224.0.0.0")
ipv4LinkLocalUni := net.ParseIP("169.254.0.0")

fmt.Println(ipv6LinkLocalMulti.IsLinkLocalMulticast())
fmt.Println(ipv6LinkLocalUni.IsLinkLocalMulticast())
fmt.Println(ipv4LinkLocalMulti.IsLinkLocalMulticast())
fmt.Println(ipv4LinkLocalUni.IsLinkLocalMulticast())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
false
</pre>   <h3 id="IP.IsLinkLocalUnicast">func (IP) <span>IsLinkLocalUnicast</span>  </h3> <pre data-language="go">func (ip IP) IsLinkLocalUnicast() bool</pre> <p>IsLinkLocalUnicast reports whether ip is a link-local unicast address. </p>   <h4 id="example_IP_IsLinkLocalUnicast"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6LinkLocalUni := net.ParseIP("fe80::")
ipv6Global := net.ParseIP("2000::")
ipv4LinkLocalUni := net.ParseIP("169.254.0.0")
ipv4LinkLocalMulti := net.ParseIP("224.0.0.0")

fmt.Println(ipv6LinkLocalUni.IsLinkLocalUnicast())
fmt.Println(ipv6Global.IsLinkLocalUnicast())
fmt.Println(ipv4LinkLocalUni.IsLinkLocalUnicast())
fmt.Println(ipv4LinkLocalMulti.IsLinkLocalUnicast())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
false
</pre>   <h3 id="IP.IsLoopback">func (IP) <span>IsLoopback</span>  </h3> <pre data-language="go">func (ip IP) IsLoopback() bool</pre> <p>IsLoopback reports whether ip is a loopback address. </p>   <h4 id="example_IP_IsLoopback"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6Lo := net.ParseIP("::1")
ipv6 := net.ParseIP("ff02::1")
ipv4Lo := net.ParseIP("127.0.0.0")
ipv4 := net.ParseIP("128.0.0.0")

fmt.Println(ipv6Lo.IsLoopback())
fmt.Println(ipv6.IsLoopback())
fmt.Println(ipv4Lo.IsLoopback())
fmt.Println(ipv4.IsLoopback())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
false
</pre>   <h3 id="IP.IsMulticast">func (IP) <span>IsMulticast</span>  </h3> <pre data-language="go">func (ip IP) IsMulticast() bool</pre> <p>IsMulticast reports whether ip is a multicast address. </p>   <h4 id="example_IP_IsMulticast"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6Multi := net.ParseIP("FF00::")
ipv6LinkLocalMulti := net.ParseIP("ff02::1")
ipv6Lo := net.ParseIP("::1")
ipv4Multi := net.ParseIP("239.0.0.0")
ipv4LinkLocalMulti := net.ParseIP("224.0.0.0")
ipv4Lo := net.ParseIP("127.0.0.0")

fmt.Println(ipv6Multi.IsMulticast())
fmt.Println(ipv6LinkLocalMulti.IsMulticast())
fmt.Println(ipv6Lo.IsMulticast())
fmt.Println(ipv4Multi.IsMulticast())
fmt.Println(ipv4LinkLocalMulti.IsMulticast())
fmt.Println(ipv4Lo.IsMulticast())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
true
false
true
true
false
</pre>   <h3 id="IP.IsPrivate">func (IP) <span>IsPrivate</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (ip IP) IsPrivate() bool</pre> <p>IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). </p>   <h4 id="example_IP_IsPrivate"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6Private := net.ParseIP("fc00::")
ipv6Public := net.ParseIP("fe00::")
ipv4Private := net.ParseIP("10.255.0.0")
ipv4Public := net.ParseIP("11.0.0.0")

fmt.Println(ipv6Private.IsPrivate())
fmt.Println(ipv6Public.IsPrivate())
fmt.Println(ipv4Private.IsPrivate())
fmt.Println(ipv4Public.IsPrivate())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
false
</pre>   <h3 id="IP.IsUnspecified">func (IP) <span>IsUnspecified</span>  </h3> <pre data-language="go">func (ip IP) IsUnspecified() bool</pre> <p>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address "0.0.0.0" or the IPv6 address "::". </p>   <h4 id="example_IP_IsUnspecified"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6Unspecified := net.ParseIP("::")
ipv6Specified := net.ParseIP("fe00::")
ipv4Unspecified := net.ParseIP("0.0.0.0")
ipv4Specified := net.ParseIP("8.8.8.8")

fmt.Println(ipv6Unspecified.IsUnspecified())
fmt.Println(ipv6Specified.IsUnspecified())
fmt.Println(ipv4Unspecified.IsUnspecified())
fmt.Println(ipv4Specified.IsUnspecified())

</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
true
false
</pre>   <h3 id="IP.MarshalText">func (IP) <span>MarshalText</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (ip IP) MarshalText() ([]byte, error)</pre> <p>MarshalText implements the encoding.TextMarshaler interface. The encoding is the same as returned by String, with one exception: When len(ip) is zero, it returns an empty slice. </p>
<h3 id="IP.Mask">func (IP) <span>Mask</span>  </h3> <pre data-language="go">func (ip IP) Mask(mask IPMask) IP</pre> <p>Mask returns the result of masking the IP address ip with mask. </p>   <h4 id="example_IP_Mask"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv4Addr := net.ParseIP("192.0.2.1")
// This mask corresponds to a /24 subnet for IPv4.
ipv4Mask := net.CIDRMask(24, 32)
fmt.Println(ipv4Addr.Mask(ipv4Mask))

ipv6Addr := net.ParseIP("2001:db8:a0b:12f0::1")
// This mask corresponds to a /32 subnet for IPv6.
ipv6Mask := net.CIDRMask(32, 128)
fmt.Println(ipv6Addr.Mask(ipv6Mask))

</pre> <p>Output:</p> <pre class="output" data-language="go">192.0.2.0
2001:db8::
</pre>   <h3 id="IP.String">func (IP) <span>String</span>  </h3> <pre data-language="go">func (ip IP) String() string</pre> <p>String returns the string form of the IP address ip. It returns one of 4 forms: </p>
<ul> <li>"&lt;nil&gt;", if ip has length 0 </li>
<li>dotted decimal ("192.0.2.1"), if ip is an IPv4 or IP4-mapped IPv6 address </li>
<li>IPv6 conforming to RFC 5952 ("2001:db8::1"), if ip is a valid IPv6 address </li>
<li>the hexadecimal form of ip, without punctuation, if no other cases apply </li>
</ul>    <h4 id="example_IP_String"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.String())
fmt.Println(ipv4.String())

</pre> <p>Output:</p> <pre class="output" data-language="go">fc00::
10.255.0.0
</pre>   <h3 id="IP.To16">func (IP) <span>To16</span>  </h3> <pre data-language="go">func (ip IP) To16() IP</pre> <p>To16 converts the IP address ip to a 16-byte representation. If ip is not an IP address (it is the wrong length), To16 returns nil. </p>   <h4 id="example_IP_To16"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.To16())
fmt.Println(ipv4.To16())

</pre> <p>Output:</p> <pre class="output" data-language="go">fc00::
10.255.0.0
</pre>   <h3 id="IP.To4">func (IP) <span>To4</span>  </h3> <pre data-language="go">func (ip IP) To4() IP</pre> <p>To4 converts the IPv4 address ip to a 4-byte representation. If ip is not an IPv4 address, To4 returns nil. </p>
<h3 id="IP.UnmarshalText">func (*IP) <span>UnmarshalText</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (ip *IP) UnmarshalText(text []byte) error</pre> <p>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by ParseIP. </p>
<h2 id="IPAddr">type <span>IPAddr</span>  </h2> <p>IPAddr represents the address of an IP end point. </p>
<pre data-language="go">type IPAddr struct {
    IP   IP
    Zone string // IPv6 scoped addressing zone; added in Go 1.1
}
</pre> <h3 id="ResolveIPAddr">func <span>ResolveIPAddr</span>  </h3> <pre data-language="go">func ResolveIPAddr(network, address string) (*IPAddr, error)</pre> <p>ResolveIPAddr returns an address of IP end point. </p>
<p>The network must be an IP network name. </p>
<p>If the host in the address parameter is not a literal IP address, ResolveIPAddr resolves the address to an address of IP end point. Otherwise, it parses the address as a literal IP address. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="IPAddr.Network">func (*IPAddr) <span>Network</span>  </h3> <pre data-language="go">func (a *IPAddr) Network() string</pre> <p>Network returns the address's network name, "ip". </p>
<h3 id="IPAddr.String">func (*IPAddr) <span>String</span>  </h3> <pre data-language="go">func (a *IPAddr) String() string</pre> <h2 id="IPConn">type <span>IPConn</span>  </h2> <p>IPConn is the implementation of the Conn and PacketConn interfaces for IP network connections. </p>
<pre data-language="go">type IPConn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="DialIP">func <span>DialIP</span>  </h3> <pre data-language="go">func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)</pre> <p>DialIP acts like Dial for IP networks. </p>
<p>The network must be an IP network name; see func Dial for details. </p>
<p>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. </p>
<h3 id="ListenIP">func <span>ListenIP</span>  </h3> <pre data-language="go">func ListenIP(network string, laddr *IPAddr) (*IPConn, error)</pre> <p>ListenIP acts like ListenPacket for IP networks. </p>
<p>The network must be an IP network name; see func Dial for details. </p>
<p>If the IP field of laddr is nil or an unspecified IP address, ListenIP listens on all available IP addresses of the local system except multicast IP addresses. </p>
<h3 id="IPConn.Close">func (*IPConn) <span>Close</span>  </h3> <pre data-language="go">func (c *IPConn) Close() error</pre> <p>Close closes the connection. </p>
<h3 id="IPConn.File">func (*IPConn) <span>File</span>  </h3> <pre data-language="go">func (c *IPConn) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="IPConn.LocalAddr">func (*IPConn) <span>LocalAddr</span>  </h3> <pre data-language="go">func (c *IPConn) LocalAddr() Addr</pre> <p>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p>
<h3 id="IPConn.Read">func (*IPConn) <span>Read</span>  </h3> <pre data-language="go">func (c *IPConn) Read(b []byte) (int, error)</pre> <p>Read implements the Conn Read method. </p>
<h3 id="IPConn.ReadFrom">func (*IPConn) <span>ReadFrom</span>  </h3> <pre data-language="go">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p>ReadFrom implements the PacketConn ReadFrom method. </p>
<h3 id="IPConn.ReadFromIP">func (*IPConn) <span>ReadFromIP</span>  </h3> <pre data-language="go">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</pre> <p>ReadFromIP acts like ReadFrom but returns an IPAddr. </p>
<h3 id="IPConn.ReadMsgIP">func (*IPConn) <span>ReadMsgIP</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</pre> <p>ReadMsgIP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. </p>
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. </p>
<h3 id="IPConn.RemoteAddr">func (*IPConn) <span>RemoteAddr</span>  </h3> <pre data-language="go">func (c *IPConn) RemoteAddr() Addr</pre> <p>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p>
<h3 id="IPConn.SetDeadline">func (*IPConn) <span>SetDeadline</span>  </h3> <pre data-language="go">func (c *IPConn) SetDeadline(t time.Time) error</pre> <p>SetDeadline implements the Conn SetDeadline method. </p>
<h3 id="IPConn.SetReadBuffer">func (*IPConn) <span>SetReadBuffer</span>  </h3> <pre data-language="go">func (c *IPConn) SetReadBuffer(bytes int) error</pre> <p>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p>
<h3 id="IPConn.SetReadDeadline">func (*IPConn) <span>SetReadDeadline</span>  </h3> <pre data-language="go">func (c *IPConn) SetReadDeadline(t time.Time) error</pre> <p>SetReadDeadline implements the Conn SetReadDeadline method. </p>
<h3 id="IPConn.SetWriteBuffer">func (*IPConn) <span>SetWriteBuffer</span>  </h3> <pre data-language="go">func (c *IPConn) SetWriteBuffer(bytes int) error</pre> <p>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p>
<h3 id="IPConn.SetWriteDeadline">func (*IPConn) <span>SetWriteDeadline</span>  </h3> <pre data-language="go">func (c *IPConn) SetWriteDeadline(t time.Time) error</pre> <p>SetWriteDeadline implements the Conn SetWriteDeadline method. </p>
<h3 id="IPConn.SyscallConn">func (*IPConn) <span>SyscallConn</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *IPConn) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<h3 id="IPConn.Write">func (*IPConn) <span>Write</span>  </h3> <pre data-language="go">func (c *IPConn) Write(b []byte) (int, error)</pre> <p>Write implements the Conn Write method. </p>
<h3 id="IPConn.WriteMsgIP">func (*IPConn) <span>WriteMsgIP</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</pre> <p>WriteMsgIP writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p>
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. </p>
<h3 id="IPConn.WriteTo">func (*IPConn) <span>WriteTo</span>  </h3> <pre data-language="go">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p>WriteTo implements the PacketConn WriteTo method. </p>
<h3 id="IPConn.WriteToIP">func (*IPConn) <span>WriteToIP</span>  </h3> <pre data-language="go">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</pre> <p>WriteToIP acts like WriteTo but takes an IPAddr. </p>
<h2 id="IPMask">type <span>IPMask</span>  </h2> <p>An IPMask is a bitmask that can be used to manipulate IP addresses for IP addressing and routing. </p>
<p>See type IPNet and func ParseCIDR for details. </p>
<pre data-language="go">type IPMask []byte</pre> <h3 id="CIDRMask">func <span>CIDRMask</span>  </h3> <pre data-language="go">func CIDRMask(ones, bits int) IPMask</pre> <p>CIDRMask returns an IPMask consisting of 'ones' 1 bits followed by 0s up to a total length of 'bits' bits. For a mask of this form, CIDRMask is the inverse of IPMask.Size. </p>   <h4 id="example_CIDRMask"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">// This mask corresponds to a /31 subnet for IPv4.
fmt.Println(net.CIDRMask(31, 32))

// This mask corresponds to a /64 subnet for IPv6.
fmt.Println(net.CIDRMask(64, 128))

</pre> <p>Output:</p> <pre class="output" data-language="go">fffffffe
ffffffffffffffff0000000000000000
</pre>   <h3 id="IPv4Mask">func <span>IPv4Mask</span>  </h3> <pre data-language="go">func IPv4Mask(a, b, c, d byte) IPMask</pre> <p>IPv4Mask returns the IP mask (in 4-byte form) of the IPv4 mask a.b.c.d. </p>   <h4 id="example_IPv4Mask"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(net.IPv4Mask(255, 255, 255, 0))

</pre> <p>Output:</p> <pre class="output" data-language="go">ffffff00
</pre>   <h3 id="IPMask.Size">func (IPMask) <span>Size</span>  </h3> <pre data-language="go">func (m IPMask) Size() (ones, bits int)</pre> <p>Size returns the number of leading ones and total bits in the mask. If the mask is not in the canonical form--ones followed by zeros--then Size returns 0, 0. </p>
<h3 id="IPMask.String">func (IPMask) <span>String</span>  </h3> <pre data-language="go">func (m IPMask) String() string</pre> <p>String returns the hexadecimal form of m, with no punctuation. </p>
<h2 id="IPNet">type <span>IPNet</span>  </h2> <p>An IPNet represents an IP network. </p>
<pre data-language="go">type IPNet struct {
    IP   IP     // network number
    Mask IPMask // network mask
}
</pre> <h3 id="IPNet.Contains">func (*IPNet) <span>Contains</span>  </h3> <pre data-language="go">func (n *IPNet) Contains(ip IP) bool</pre> <p>Contains reports whether the network includes ip. </p>
<h3 id="IPNet.Network">func (*IPNet) <span>Network</span>  </h3> <pre data-language="go">func (n *IPNet) Network() string</pre> <p>Network returns the address's network name, "ip+net". </p>
<h3 id="IPNet.String">func (*IPNet) <span>String</span>  </h3> <pre data-language="go">func (n *IPNet) String() string</pre> <p>String returns the CIDR notation of n like "192.0.2.0/24" or "2001:db8::/48" as defined in RFC 4632 and RFC 4291. If the mask is not in the canonical form, it returns the string which consists of an IP address, followed by a slash character and a mask expressed as hexadecimal form with no punctuation like "198.51.100.0/c000ff00". </p>
<h2 id="Interface">type <span>Interface</span>  </h2> <p>Interface represents a mapping between network interface name and index. It also represents network interface facility information. </p>
<pre data-language="go">type Interface struct {
    Index        int          // positive integer that starts at one, zero is never used
    MTU          int          // maximum transmission unit
    Name         string       // e.g., "en0", "lo0", "eth0.100"
    HardwareAddr HardwareAddr // IEEE MAC-48, EUI-48 and EUI-64 form
    Flags        Flags        // e.g., FlagUp, FlagLoopback, FlagMulticast
}
</pre> <h3 id="InterfaceByIndex">func <span>InterfaceByIndex</span>  </h3> <pre data-language="go">func InterfaceByIndex(index int) (*Interface, error)</pre> <p>InterfaceByIndex returns the interface specified by index. </p>
<p>On Solaris, it returns one of the logical network interfaces sharing the logical data link; for more precision use InterfaceByName. </p>
<h3 id="InterfaceByName">func <span>InterfaceByName</span>  </h3> <pre data-language="go">func InterfaceByName(name string) (*Interface, error)</pre> <p>InterfaceByName returns the interface specified by name. </p>
<h3 id="Interfaces">func <span>Interfaces</span>  </h3> <pre data-language="go">func Interfaces() ([]Interface, error)</pre> <p>Interfaces returns a list of the system's network interfaces. </p>
<h3 id="Interface.Addrs">func (*Interface) <span>Addrs</span>  </h3> <pre data-language="go">func (ifi *Interface) Addrs() ([]Addr, error)</pre> <p>Addrs returns a list of unicast interface addresses for a specific interface. </p>
<h3 id="Interface.MulticastAddrs">func (*Interface) <span>MulticastAddrs</span>  </h3> <pre data-language="go">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</pre> <p>MulticastAddrs returns a list of multicast, joined group addresses for a specific interface. </p>
<h2 id="InvalidAddrError">type <span>InvalidAddrError</span>  </h2> <pre data-language="go">type InvalidAddrError string</pre> <h3 id="InvalidAddrError.Error">func (InvalidAddrError) <span>Error</span>  </h3> <pre data-language="go">func (e InvalidAddrError) Error() string</pre> <h3 id="InvalidAddrError.Temporary">func (InvalidAddrError) <span>Temporary</span>  </h3> <pre data-language="go">func (e InvalidAddrError) Temporary() bool</pre> <h3 id="InvalidAddrError.Timeout">func (InvalidAddrError) <span>Timeout</span>  </h3> <pre data-language="go">func (e InvalidAddrError) Timeout() bool</pre> <h2 id="ListenConfig">type <span>ListenConfig</span>  <span title="Added in Go 1.11">1.11</span> </h2> <p>ListenConfig contains options for listening to an address. </p>
<pre data-language="go">type ListenConfig struct {
    // If Control is not nil, it is called after creating the network
    // connection but before binding it to the operating system.
    //
    // Network and address parameters passed to Control method are not
    // necessarily the ones passed to Listen. For example, passing "tcp" to
    // Listen will cause the Control function to be called with "tcp4" or "tcp6".
    Control func(network, address string, c syscall.RawConn) error

    // KeepAlive specifies the keep-alive period for network
    // connections accepted by this listener.
    // If zero, keep-alives are enabled if supported by the protocol
    // and operating system. Network protocols or operating systems
    // that do not support keep-alives ignore this field.
    // If negative, keep-alives are disabled.
    KeepAlive time.Duration // Go 1.13
    // contains filtered or unexported fields
}
</pre> <h3 id="ListenConfig.Listen">func (*ListenConfig) <span>Listen</span>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)</pre> <p>Listen announces on the local network address. </p>
<p>See func Listen for a description of the network and address parameters. </p>
<h3 id="ListenConfig.ListenPacket">func (*ListenConfig) <span>ListenPacket</span>  <span title="Added in Go 1.11">1.11</span> </h3> <pre data-language="go">func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)</pre> <p>ListenPacket announces on the local network address. </p>
<p>See func ListenPacket for a description of the network and address parameters. </p>
<h3 id="ListenConfig.MultipathTCP">func (*ListenConfig) <span>MultipathTCP</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (lc *ListenConfig) MultipathTCP() bool</pre> <p>MultipathTCP reports whether MPTCP will be used. </p>
<p>This method doesn't check if MPTCP is supported by the operating system or not. </p>
<h3 id="ListenConfig.SetMultipathTCP">func (*ListenConfig) <span>SetMultipathTCP</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (lc *ListenConfig) SetMultipathTCP(use bool)</pre> <p>SetMultipathTCP directs the Listen method to use, or not use, MPTCP, if supported by the operating system. This method overrides the system default and the GODEBUG=multipathtcp=... setting if any. </p>
<p>If MPTCP is not available on the host or not supported by the client, the Listen method will fall back to TCP. </p>
<h2 id="Listener">type <span>Listener</span>  </h2> <p>A Listener is a generic network listener for stream-oriented protocols. </p>
<p>Multiple goroutines may invoke methods on a Listener simultaneously. </p>
<pre data-language="go">type Listener interface {
    // Accept waits for and returns the next connection to the listener.
    Accept() (Conn, error)

    // Close closes the listener.
    // Any blocked Accept operations will be unblocked and return errors.
    Close() error

    // Addr returns the listener's network address.
    Addr() Addr
}</pre>    <h4 id="example_Listener"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Listen on TCP port 2000 on all available unicast and
// anycast IP addresses of the local system.
l, err := net.Listen("tcp", ":2000")
if err != nil {
    log.Fatal(err)
}
defer l.Close()
for {
    // Wait for a connection.
    conn, err := l.Accept()
    if err != nil {
        log.Fatal(err)
    }
    // Handle the connection in a new goroutine.
    // The loop then returns to accepting, so that
    // multiple connections may be served concurrently.
    go func(c net.Conn) {
        // Echo all incoming data.
        io.Copy(c, c)
        // Shut down the connection.
        c.Close()
    }(conn)
}
</pre>   <h3 id="FileListener">func <span>FileListener</span>  </h3> <pre data-language="go">func FileListener(f *os.File) (ln Listener, err error)</pre> <p>FileListener returns a copy of the network listener corresponding to the open file f. It is the caller's responsibility to close ln when finished. Closing ln does not affect f, and closing f does not affect ln. </p>
<h3 id="Listen">func <span>Listen</span>  </h3> <pre data-language="go">func Listen(network, address string) (Listener, error)</pre> <p>Listen announces on the local network address. </p>
<p>The network must be "tcp", "tcp4", "tcp6", "unix" or "unixpacket". </p>
<p>For TCP networks, if the host in the address parameter is empty or a literal unspecified IP address, Listen listens on all available unicast and anycast IP addresses of the local system. To only use IPv4, use network "tcp4". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or "0", as in "127.0.0.1:" or "[::1]:0", a port number is automatically chosen. The Addr method of Listener can be used to discover the chosen port. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<p>Listen uses context.Background internally; to specify the context, use ListenConfig.Listen. </p>
<h2 id="MX">type <span>MX</span>  </h2> <p>An MX represents a single DNS MX record. </p>
<pre data-language="go">type MX struct {
    Host string
    Pref uint16
}
</pre> <h3 id="LookupMX">func <span>LookupMX</span>  </h3> <pre data-language="go">func LookupMX(name string) ([]*MX, error)</pre> <p>LookupMX returns the DNS MX records for the given domain name sorted by preference. </p>
<p>The returned mail server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<p>LookupMX uses context.Background internally; to specify the context, use Resolver.LookupMX. </p>
<h2 id="NS">type <span>NS</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>An NS represents a single DNS NS record. </p>
<pre data-language="go">type NS struct {
    Host string
}
</pre> <h3 id="LookupNS">func <span>LookupNS</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func LookupNS(name string) ([]*NS, error)</pre> <p>LookupNS returns the DNS NS records for the given domain name. </p>
<p>The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<p>LookupNS uses context.Background internally; to specify the context, use Resolver.LookupNS. </p>
<h2 id="OpError">type <span>OpError</span>  </h2> <p>OpError is the error type usually returned by functions in the net package. It describes the operation, network type, and address of an error. </p>
<pre data-language="go">type OpError struct {
    // Op is the operation which caused the error, such as
    // "read" or "write".
    Op string

    // Net is the network type on which this error occurred,
    // such as "tcp" or "udp6".
    Net string

    // For operations involving a remote network connection, like
    // Dial, Read, or Write, Source is the corresponding local
    // network address.
    Source Addr // Go 1.5

    // Addr is the network address for which this error occurred.
    // For local operations, like Listen or SetDeadline, Addr is
    // the address of the local endpoint being manipulated.
    // For operations involving a remote network connection, like
    // Dial, Read, or Write, Addr is the remote address of that
    // connection.
    Addr Addr

    // Err is the error that occurred during the operation.
    // The Error method panics if the error is nil.
    Err error
}
</pre> <h3 id="OpError.Error">func (*OpError) <span>Error</span>  </h3> <pre data-language="go">func (e *OpError) Error() string</pre> <h3 id="OpError.Temporary">func (*OpError) <span>Temporary</span>  </h3> <pre data-language="go">func (e *OpError) Temporary() bool</pre> <h3 id="OpError.Timeout">func (*OpError) <span>Timeout</span>  </h3> <pre data-language="go">func (e *OpError) Timeout() bool</pre> <h3 id="OpError.Unwrap">func (*OpError) <span>Unwrap</span>  <span title="Added in Go 1.13">1.13</span> </h3> <pre data-language="go">func (e *OpError) Unwrap() error</pre> <h2 id="PacketConn">type <span>PacketConn</span>  </h2> <p>PacketConn is a generic packet-oriented network connection. </p>
<p>Multiple goroutines may invoke methods on a PacketConn simultaneously. </p>
<pre data-language="go">type PacketConn interface {
    // ReadFrom reads a packet from the connection,
    // copying the payload into p. It returns the number of
    // bytes copied into p and the return address that
    // was on the packet.
    // It returns the number of bytes read (0 &lt;= n &lt;= len(p))
    // and any error encountered. Callers should always process
    // the n &gt; 0 bytes returned before considering the error err.
    // ReadFrom can be made to time out and return an error after a
    // fixed time limit; see SetDeadline and SetReadDeadline.
    ReadFrom(p []byte) (n int, addr Addr, err error)

    // WriteTo writes a packet with payload p to addr.
    // WriteTo can be made to time out and return an Error after a
    // fixed time limit; see SetDeadline and SetWriteDeadline.
    // On packet-oriented connections, write timeouts are rare.
    WriteTo(p []byte, addr Addr) (n int, err error)

    // Close closes the connection.
    // Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.
    Close() error

    // LocalAddr returns the local network address, if known.
    LocalAddr() Addr

    // SetDeadline sets the read and write deadlines associated
    // with the connection. It is equivalent to calling both
    // SetReadDeadline and SetWriteDeadline.
    //
    // A deadline is an absolute time after which I/O operations
    // fail instead of blocking. The deadline applies to all future
    // and pending I/O, not just the immediately following call to
    // Read or Write. After a deadline has been exceeded, the
    // connection can be refreshed by setting a deadline in the future.
    //
    // If the deadline is exceeded a call to Read or Write or to other
    // I/O methods will return an error that wraps os.ErrDeadlineExceeded.
    // This can be tested using errors.Is(err, os.ErrDeadlineExceeded).
    // The error's Timeout method will return true, but note that there
    // are other possible errors for which the Timeout method will
    // return true even if the deadline has not been exceeded.
    //
    // An idle timeout can be implemented by repeatedly extending
    // the deadline after successful ReadFrom or WriteTo calls.
    //
    // A zero value for t means I/O operations will not time out.
    SetDeadline(t time.Time) error

    // SetReadDeadline sets the deadline for future ReadFrom calls
    // and any currently-blocked ReadFrom call.
    // A zero value for t means ReadFrom will not time out.
    SetReadDeadline(t time.Time) error

    // SetWriteDeadline sets the deadline for future WriteTo calls
    // and any currently-blocked WriteTo call.
    // Even if write times out, it may return n &gt; 0, indicating that
    // some of the data was successfully written.
    // A zero value for t means WriteTo will not time out.
    SetWriteDeadline(t time.Time) error
}</pre> <h3 id="FilePacketConn">func <span>FilePacketConn</span>  </h3> <pre data-language="go">func FilePacketConn(f *os.File) (c PacketConn, err error)</pre> <p>FilePacketConn returns a copy of the packet network connection corresponding to the open file f. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<h3 id="ListenPacket">func <span>ListenPacket</span>  </h3> <pre data-language="go">func ListenPacket(network, address string) (PacketConn, error)</pre> <p>ListenPacket announces on the local network address. </p>
<p>The network must be "udp", "udp4", "udp6", "unixgram", or an IP transport. The IP transports are "ip", "ip4", or "ip6" followed by a colon and a literal protocol number or a protocol name, as in "ip:1" or "ip:icmp". </p>
<p>For UDP and IP networks, if the host in the address parameter is empty or a literal unspecified IP address, ListenPacket listens on all available IP addresses of the local system except multicast IP addresses. To only use IPv4, use network "udp4" or "ip4:proto". The address can use a host name, but this is not recommended, because it will create a listener for at most one of the host's IP addresses. If the port in the address parameter is empty or "0", as in "127.0.0.1:" or "[::1]:0", a port number is automatically chosen. The LocalAddr method of PacketConn can be used to discover the chosen port. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<p>ListenPacket uses context.Background internally; to specify the context, use ListenConfig.ListenPacket. </p>
<h2 id="ParseError">type <span>ParseError</span>  </h2> <p>A ParseError is the error type of literal network address parsers. </p>
<pre data-language="go">type ParseError struct {
    // Type is the type of string that was expected, such as
    // "IP address", "CIDR address".
    Type string

    // Text is the malformed text string.
    Text string
}
</pre> <h3 id="ParseError.Error">func (*ParseError) <span>Error</span>  </h3> <pre data-language="go">func (e *ParseError) Error() string</pre> <h3 id="ParseError.Temporary">func (*ParseError) <span>Temporary</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (e *ParseError) Temporary() bool</pre> <h3 id="ParseError.Timeout">func (*ParseError) <span>Timeout</span>  <span title="Added in Go 1.17">1.17</span> </h3> <pre data-language="go">func (e *ParseError) Timeout() bool</pre> <h2 id="Resolver">type <span>Resolver</span>  <span title="Added in Go 1.8">1.8</span> </h2> <p>A Resolver looks up names and numbers. </p>
<p>A nil *Resolver is equivalent to a zero Resolver. </p>
<pre data-language="go">type Resolver struct {
    // PreferGo controls whether Go's built-in DNS resolver is preferred
    // on platforms where it's available. It is equivalent to setting
    // GODEBUG=netdns=go, but scoped to just this resolver.
    PreferGo bool

    // StrictErrors controls the behavior of temporary errors
    // (including timeout, socket errors, and SERVFAIL) when using
    // Go's built-in resolver. For a query composed of multiple
    // sub-queries (such as an A+AAAA address lookup, or walking the
    // DNS search list), this option causes such errors to abort the
    // whole query instead of returning a partial result. This is
    // not enabled by default because it may affect compatibility
    // with resolvers that process AAAA queries incorrectly.
    StrictErrors bool // Go 1.9

    // Dial optionally specifies an alternate dialer for use by
    // Go's built-in DNS resolver to make TCP and UDP connections
    // to DNS services. The host in the address parameter will
    // always be a literal IP address and not a host name, and the
    // port in the address parameter will be a literal port number
    // and not a service name.
    // If the Conn returned is also a PacketConn, sent and received DNS
    // messages must adhere to RFC 1035 section 4.2.1, "UDP usage".
    // Otherwise, DNS messages transmitted over Conn must adhere
    // to RFC 7766 section 5, "Transport Protocol Selection".
    // If nil, the default dialer is used.
    Dial func(ctx context.Context, network, address string) (Conn, error) // Go 1.9
    // contains filtered or unexported fields
}
</pre> <h3 id="Resolver.LookupAddr">func (*Resolver) <span>LookupAddr</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)</pre> <p>LookupAddr performs a reverse lookup for the given address, returning a list of names mapping to that address. </p>
<p>The returned names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<h3 id="Resolver.LookupCNAME">func (*Resolver) <span>LookupCNAME</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)</pre> <p>LookupCNAME returns the canonical name for the given host. Callers that do not care about the canonical name can call LookupHost or LookupIP directly; both take care of resolving the canonical name as part of the lookup. </p>
<p>A canonical name is the final name after following zero or more CNAME records. LookupCNAME does not return an error if host does not contain DNS "CNAME" records, as long as host resolves to address records. </p>
<p>The returned canonical name is validated to be a properly formatted presentation-format domain name. </p>
<h3 id="Resolver.LookupHost">func (*Resolver) <span>LookupHost</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</pre> <p>LookupHost looks up the given host using the local resolver. It returns a slice of that host's addresses. </p>
<h3 id="Resolver.LookupIP">func (*Resolver) <span>LookupIP</span>  <span title="Added in Go 1.15">1.15</span> </h3> <pre data-language="go">func (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)</pre> <p>LookupIP looks up host for the given network using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. network must be one of "ip", "ip4" or "ip6". </p>
<h3 id="Resolver.LookupIPAddr">func (*Resolver) <span>LookupIPAddr</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</pre> <p>LookupIPAddr looks up host using the local resolver. It returns a slice of that host's IPv4 and IPv6 addresses. </p>
<h3 id="Resolver.LookupMX">func (*Resolver) <span>LookupMX</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</pre> <p>LookupMX returns the DNS MX records for the given domain name sorted by preference. </p>
<p>The returned mail server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<h3 id="Resolver.LookupNS">func (*Resolver) <span>LookupNS</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</pre> <p>LookupNS returns the DNS NS records for the given domain name. </p>
<p>The returned name server names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<h3 id="Resolver.LookupNetIP">func (*Resolver) <span>LookupNetIP</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (r *Resolver) LookupNetIP(ctx context.Context, network, host string) ([]netip.Addr, error)</pre> <p>LookupNetIP looks up host using the local resolver. It returns a slice of that host's IP addresses of the type specified by network. The network must be one of "ip", "ip4" or "ip6". </p>
<h3 id="Resolver.LookupPort">func (*Resolver) <span>LookupPort</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)</pre> <p>LookupPort looks up the port for the given network and service. </p>
<h3 id="Resolver.LookupSRV">func (*Resolver) <span>LookupSRV</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)</pre> <p>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is "tcp" or "udp". The returned records are sorted by priority and randomized by weight within a priority. </p>
<p>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. </p>
<p>The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<h3 id="Resolver.LookupTXT">func (*Resolver) <span>LookupTXT</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</pre> <p>LookupTXT returns the DNS TXT records for the given domain name. </p>
<h2 id="SRV">type <span>SRV</span>  </h2> <p>An SRV represents a single DNS SRV record. </p>
<pre data-language="go">type SRV struct {
    Target   string
    Port     uint16
    Priority uint16
    Weight   uint16
}
</pre> <h3 id="LookupSRV">func <span>LookupSRV</span>  </h3> <pre data-language="go">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</pre> <p>LookupSRV tries to resolve an SRV query of the given service, protocol, and domain name. The proto is "tcp" or "udp". The returned records are sorted by priority and randomized by weight within a priority. </p>
<p>LookupSRV constructs the DNS name to look up following RFC 2782. That is, it looks up _service._proto.name. To accommodate services publishing SRV records under non-standard names, if both service and proto are empty strings, LookupSRV looks up name directly. </p>
<p>The returned service names are validated to be properly formatted presentation-format domain names. If the response contains invalid names, those records are filtered out and an error will be returned alongside the remaining results, if any. </p>
<h2 id="TCPAddr">type <span>TCPAddr</span>  </h2> <p>TCPAddr represents the address of a TCP end point. </p>
<pre data-language="go">type TCPAddr struct {
    IP   IP
    Port int
    Zone string // IPv6 scoped addressing zone; added in Go 1.1
}
</pre> <h3 id="ResolveTCPAddr">func <span>ResolveTCPAddr</span>  </h3> <pre data-language="go">func ResolveTCPAddr(network, address string) (*TCPAddr, error)</pre> <p>ResolveTCPAddr returns an address of TCP end point. </p>
<p>The network must be a TCP network name. </p>
<p>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveTCPAddr resolves the address to an address of TCP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="TCPAddrFromAddrPort">func <span>TCPAddrFromAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr</pre> <p>TCPAddrFromAddrPort returns addr as a TCPAddr. If addr.IsValid() is false, then the returned TCPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address. </p>
<h3 id="TCPAddr.AddrPort">func (*TCPAddr) <span>AddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (a *TCPAddr) AddrPort() netip.AddrPort</pre> <p>AddrPort returns the TCPAddr a as a netip.AddrPort. </p>
<p>If a.Port does not fit in a uint16, it's silently truncated. </p>
<p>If a is nil, a zero value is returned. </p>
<h3 id="TCPAddr.Network">func (*TCPAddr) <span>Network</span>  </h3> <pre data-language="go">func (a *TCPAddr) Network() string</pre> <p>Network returns the address's network name, "tcp". </p>
<h3 id="TCPAddr.String">func (*TCPAddr) <span>String</span>  </h3> <pre data-language="go">func (a *TCPAddr) String() string</pre> <h2 id="TCPConn">type <span>TCPConn</span>  </h2> <p>TCPConn is an implementation of the Conn interface for TCP network connections. </p>
<pre data-language="go">type TCPConn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="DialTCP">func <span>DialTCP</span>  </h3> <pre data-language="go">func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)</pre> <p>DialTCP acts like Dial for TCP networks. </p>
<p>The network must be a TCP network name; see func Dial for details. </p>
<p>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. </p>
<h3 id="TCPConn.Close">func (*TCPConn) <span>Close</span>  </h3> <pre data-language="go">func (c *TCPConn) Close() error</pre> <p>Close closes the connection. </p>
<h3 id="TCPConn.CloseRead">func (*TCPConn) <span>CloseRead</span>  </h3> <pre data-language="go">func (c *TCPConn) CloseRead() error</pre> <p>CloseRead shuts down the reading side of the TCP connection. Most callers should just use Close. </p>
<h3 id="TCPConn.CloseWrite">func (*TCPConn) <span>CloseWrite</span>  </h3> <pre data-language="go">func (c *TCPConn) CloseWrite() error</pre> <p>CloseWrite shuts down the writing side of the TCP connection. Most callers should just use Close. </p>
<h3 id="TCPConn.File">func (*TCPConn) <span>File</span>  </h3> <pre data-language="go">func (c *TCPConn) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="TCPConn.LocalAddr">func (*TCPConn) <span>LocalAddr</span>  </h3> <pre data-language="go">func (c *TCPConn) LocalAddr() Addr</pre> <p>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p>
<h3 id="TCPConn.MultipathTCP">func (*TCPConn) <span>MultipathTCP</span>  <span title="Added in Go 1.21">1.21</span> </h3> <pre data-language="go">func (c *TCPConn) MultipathTCP() (bool, error)</pre> <p>MultipathTCP reports whether the ongoing connection is using MPTCP. </p>
<p>If Multipath TCP is not supported by the host, by the other peer or intentionally / accidentally filtered out by a device in between, a fallback to TCP will be done. This method does its best to check if MPTCP is still being used or not. </p>
<p>On Linux, more conditions are verified on kernels &gt;= v5.16, improving the results. </p>
<h3 id="TCPConn.Read">func (*TCPConn) <span>Read</span>  </h3> <pre data-language="go">func (c *TCPConn) Read(b []byte) (int, error)</pre> <p>Read implements the Conn Read method. </p>
<h3 id="TCPConn.ReadFrom">func (*TCPConn) <span>ReadFrom</span>  </h3> <pre data-language="go">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</pre> <p>ReadFrom implements the io.ReaderFrom ReadFrom method. </p>
<h3 id="TCPConn.RemoteAddr">func (*TCPConn) <span>RemoteAddr</span>  </h3> <pre data-language="go">func (c *TCPConn) RemoteAddr() Addr</pre> <p>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p>
<h3 id="TCPConn.SetDeadline">func (*TCPConn) <span>SetDeadline</span>  </h3> <pre data-language="go">func (c *TCPConn) SetDeadline(t time.Time) error</pre> <p>SetDeadline implements the Conn SetDeadline method. </p>
<h3 id="TCPConn.SetKeepAlive">func (*TCPConn) <span>SetKeepAlive</span>  </h3> <pre data-language="go">func (c *TCPConn) SetKeepAlive(keepalive bool) error</pre> <p>SetKeepAlive sets whether the operating system should send keep-alive messages on the connection. </p>
<h3 id="TCPConn.SetKeepAlivePeriod">func (*TCPConn) <span>SetKeepAlivePeriod</span>  <span title="Added in Go 1.2">1.2</span> </h3> <pre data-language="go">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</pre> <p>SetKeepAlivePeriod sets period between keep-alives. </p>
<h3 id="TCPConn.SetLinger">func (*TCPConn) <span>SetLinger</span>  </h3> <pre data-language="go">func (c *TCPConn) SetLinger(sec int) error</pre> <p>SetLinger sets the behavior of Close on a connection which still has data waiting to be sent or to be acknowledged. </p>
<p>If sec &lt; 0 (the default), the operating system finishes sending the data in the background. </p>
<p>If sec == 0, the operating system discards any unsent or unacknowledged data. </p>
<p>If sec &gt; 0, the data is sent in the background as with sec &lt; 0. On some operating systems including Linux, this may cause Close to block until all data has been sent or discarded. On some operating systems after sec seconds have elapsed any remaining unsent data may be discarded. </p>
<h3 id="TCPConn.SetNoDelay">func (*TCPConn) <span>SetNoDelay</span>  </h3> <pre data-language="go">func (c *TCPConn) SetNoDelay(noDelay bool) error</pre> <p>SetNoDelay controls whether the operating system should delay packet transmission in hopes of sending fewer packets (Nagle's algorithm). The default is true (no delay), meaning that data is sent as soon as possible after a Write. </p>
<h3 id="TCPConn.SetReadBuffer">func (*TCPConn) <span>SetReadBuffer</span>  </h3> <pre data-language="go">func (c *TCPConn) SetReadBuffer(bytes int) error</pre> <p>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p>
<h3 id="TCPConn.SetReadDeadline">func (*TCPConn) <span>SetReadDeadline</span>  </h3> <pre data-language="go">func (c *TCPConn) SetReadDeadline(t time.Time) error</pre> <p>SetReadDeadline implements the Conn SetReadDeadline method. </p>
<h3 id="TCPConn.SetWriteBuffer">func (*TCPConn) <span>SetWriteBuffer</span>  </h3> <pre data-language="go">func (c *TCPConn) SetWriteBuffer(bytes int) error</pre> <p>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p>
<h3 id="TCPConn.SetWriteDeadline">func (*TCPConn) <span>SetWriteDeadline</span>  </h3> <pre data-language="go">func (c *TCPConn) SetWriteDeadline(t time.Time) error</pre> <p>SetWriteDeadline implements the Conn SetWriteDeadline method. </p>
<h3 id="TCPConn.SyscallConn">func (*TCPConn) <span>SyscallConn</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *TCPConn) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<h3 id="TCPConn.Write">func (*TCPConn) <span>Write</span>  </h3> <pre data-language="go">func (c *TCPConn) Write(b []byte) (int, error)</pre> <p>Write implements the Conn Write method. </p>
<h2 id="TCPListener">type <span>TCPListener</span>  </h2> <p>TCPListener is a TCP network listener. Clients should typically use variables of type Listener instead of assuming TCP. </p>
<pre data-language="go">type TCPListener struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="ListenTCP">func <span>ListenTCP</span>  </h3> <pre data-language="go">func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)</pre> <p>ListenTCP acts like Listen for TCP networks. </p>
<p>The network must be a TCP network name; see func Dial for details. </p>
<p>If the IP field of laddr is nil or an unspecified IP address, ListenTCP listens on all available unicast and anycast IP addresses of the local system. If the Port field of laddr is 0, a port number is automatically chosen. </p>
<h3 id="TCPListener.Accept">func (*TCPListener) <span>Accept</span>  </h3> <pre data-language="go">func (l *TCPListener) Accept() (Conn, error)</pre> <p>Accept implements the Accept method in the Listener interface; it waits for the next call and returns a generic Conn. </p>
<h3 id="TCPListener.AcceptTCP">func (*TCPListener) <span>AcceptTCP</span>  </h3> <pre data-language="go">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</pre> <p>AcceptTCP accepts the next incoming call and returns the new connection. </p>
<h3 id="TCPListener.Addr">func (*TCPListener) <span>Addr</span>  </h3> <pre data-language="go">func (l *TCPListener) Addr() Addr</pre> <p>Addr returns the listener's network address, a *TCPAddr. The Addr returned is shared by all invocations of Addr, so do not modify it. </p>
<h3 id="TCPListener.Close">func (*TCPListener) <span>Close</span>  </h3> <pre data-language="go">func (l *TCPListener) Close() error</pre> <p>Close stops listening on the TCP address. Already Accepted connections are not closed. </p>
<h3 id="TCPListener.File">func (*TCPListener) <span>File</span>  </h3> <pre data-language="go">func (l *TCPListener) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="TCPListener.SetDeadline">func (*TCPListener) <span>SetDeadline</span>  </h3> <pre data-language="go">func (l *TCPListener) SetDeadline(t time.Time) error</pre> <p>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p>
<h3 id="TCPListener.SyscallConn">func (*TCPListener) <span>SyscallConn</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (l *TCPListener) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<p>The returned RawConn only supports calling Control. Read and Write return an error. </p>
<h2 id="UDPAddr">type <span>UDPAddr</span>  </h2> <p>UDPAddr represents the address of a UDP end point. </p>
<pre data-language="go">type UDPAddr struct {
    IP   IP
    Port int
    Zone string // IPv6 scoped addressing zone; added in Go 1.1
}
</pre> <h3 id="ResolveUDPAddr">func <span>ResolveUDPAddr</span>  </h3> <pre data-language="go">func ResolveUDPAddr(network, address string) (*UDPAddr, error)</pre> <p>ResolveUDPAddr returns an address of UDP end point. </p>
<p>The network must be a UDP network name. </p>
<p>If the host in the address parameter is not a literal IP address or the port is not a literal port number, ResolveUDPAddr resolves the address to an address of UDP end point. Otherwise, it parses the address as a pair of literal IP address and port number. The address parameter can use a host name, but this is not recommended, because it will return at most one of the host name's IP addresses. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="UDPAddrFromAddrPort">func <span>UDPAddrFromAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr</pre> <p>UDPAddrFromAddrPort returns addr as a UDPAddr. If addr.IsValid() is false, then the returned UDPAddr will contain a nil IP field, indicating an address family-agnostic unspecified address. </p>
<h3 id="UDPAddr.AddrPort">func (*UDPAddr) <span>AddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (a *UDPAddr) AddrPort() netip.AddrPort</pre> <p>AddrPort returns the UDPAddr a as a netip.AddrPort. </p>
<p>If a.Port does not fit in a uint16, it's silently truncated. </p>
<p>If a is nil, a zero value is returned. </p>
<h3 id="UDPAddr.Network">func (*UDPAddr) <span>Network</span>  </h3> <pre data-language="go">func (a *UDPAddr) Network() string</pre> <p>Network returns the address's network name, "udp". </p>
<h3 id="UDPAddr.String">func (*UDPAddr) <span>String</span>  </h3> <pre data-language="go">func (a *UDPAddr) String() string</pre> <h2 id="UDPConn">type <span>UDPConn</span>  </h2> <p>UDPConn is the implementation of the Conn and PacketConn interfaces for UDP network connections. </p>
<pre data-language="go">type UDPConn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="DialUDP">func <span>DialUDP</span>  </h3> <pre data-language="go">func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)</pre> <p>DialUDP acts like Dial for UDP networks. </p>
<p>The network must be a UDP network name; see func Dial for details. </p>
<p>If laddr is nil, a local address is automatically chosen. If the IP field of raddr is nil or an unspecified IP address, the local system is assumed. </p>
<h3 id="ListenMulticastUDP">func <span>ListenMulticastUDP</span>  </h3> <pre data-language="go">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</pre> <p>ListenMulticastUDP acts like ListenPacket for UDP networks but takes a group address on a specific network interface. </p>
<p>The network must be a UDP network name; see func Dial for details. </p>
<p>ListenMulticastUDP listens on all available IP addresses of the local system including the group, multicast IP address. If ifi is nil, ListenMulticastUDP uses the system-assigned multicast interface, although this is not recommended because the assignment depends on platforms and sometimes it might require routing configuration. If the Port field of gaddr is 0, a port number is automatically chosen. </p>
<p>ListenMulticastUDP is just for convenience of simple, small applications. There are golang.org/x/net/ipv4 and golang.org/x/net/ipv6 packages for general purpose uses. </p>
<p>Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option to 0 under IPPROTO_IP, to disable loopback of multicast packets. </p>
<h3 id="ListenUDP">func <span>ListenUDP</span>  </h3> <pre data-language="go">func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)</pre> <p>ListenUDP acts like ListenPacket for UDP networks. </p>
<p>The network must be a UDP network name; see func Dial for details. </p>
<p>If the IP field of laddr is nil or an unspecified IP address, ListenUDP listens on all available IP addresses of the local system except multicast IP addresses. If the Port field of laddr is 0, a port number is automatically chosen. </p>
<h3 id="UDPConn.Close">func (*UDPConn) <span>Close</span>  </h3> <pre data-language="go">func (c *UDPConn) Close() error</pre> <p>Close closes the connection. </p>
<h3 id="UDPConn.File">func (*UDPConn) <span>File</span>  </h3> <pre data-language="go">func (c *UDPConn) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="UDPConn.LocalAddr">func (*UDPConn) <span>LocalAddr</span>  </h3> <pre data-language="go">func (c *UDPConn) LocalAddr() Addr</pre> <p>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p>
<h3 id="UDPConn.Read">func (*UDPConn) <span>Read</span>  </h3> <pre data-language="go">func (c *UDPConn) Read(b []byte) (int, error)</pre> <p>Read implements the Conn Read method. </p>
<h3 id="UDPConn.ReadFrom">func (*UDPConn) <span>ReadFrom</span>  </h3> <pre data-language="go">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p>ReadFrom implements the PacketConn ReadFrom method. </p>
<h3 id="UDPConn.ReadFromUDP">func (*UDPConn) <span>ReadFromUDP</span>  </h3> <pre data-language="go">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</pre> <p>ReadFromUDP acts like ReadFrom but returns a UDPAddr. </p>
<h3 id="UDPConn.ReadFromUDPAddrPort">func (*UDPConn) <span>ReadFromUDPAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *UDPConn) ReadFromUDPAddrPort(b []byte) (n int, addr netip.AddrPort, err error)</pre> <p>ReadFromUDPAddrPort acts like ReadFrom but returns a netip.AddrPort. </p>
<p>If c is bound to an unspecified address, the returned netip.AddrPort's address might be an IPv4-mapped IPv6 address. Use netip.Addr.Unmap to get the address without the IPv6 prefix. </p>
<h3 id="UDPConn.ReadMsgUDP">func (*UDPConn) <span>ReadMsgUDP</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</pre> <p>ReadMsgUDP reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. </p>
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. </p>
<h3 id="UDPConn.ReadMsgUDPAddrPort">func (*UDPConn) <span>ReadMsgUDPAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *UDPConn) ReadMsgUDPAddrPort(b, oob []byte) (n, oobn, flags int, addr netip.AddrPort, err error)</pre> <p>ReadMsgUDPAddrPort is like ReadMsgUDP but returns an netip.AddrPort instead of a UDPAddr. </p>
<h3 id="UDPConn.RemoteAddr">func (*UDPConn) <span>RemoteAddr</span>  </h3> <pre data-language="go">func (c *UDPConn) RemoteAddr() Addr</pre> <p>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p>
<h3 id="UDPConn.SetDeadline">func (*UDPConn) <span>SetDeadline</span>  </h3> <pre data-language="go">func (c *UDPConn) SetDeadline(t time.Time) error</pre> <p>SetDeadline implements the Conn SetDeadline method. </p>
<h3 id="UDPConn.SetReadBuffer">func (*UDPConn) <span>SetReadBuffer</span>  </h3> <pre data-language="go">func (c *UDPConn) SetReadBuffer(bytes int) error</pre> <p>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p>
<h3 id="UDPConn.SetReadDeadline">func (*UDPConn) <span>SetReadDeadline</span>  </h3> <pre data-language="go">func (c *UDPConn) SetReadDeadline(t time.Time) error</pre> <p>SetReadDeadline implements the Conn SetReadDeadline method. </p>
<h3 id="UDPConn.SetWriteBuffer">func (*UDPConn) <span>SetWriteBuffer</span>  </h3> <pre data-language="go">func (c *UDPConn) SetWriteBuffer(bytes int) error</pre> <p>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p>
<h3 id="UDPConn.SetWriteDeadline">func (*UDPConn) <span>SetWriteDeadline</span>  </h3> <pre data-language="go">func (c *UDPConn) SetWriteDeadline(t time.Time) error</pre> <p>SetWriteDeadline implements the Conn SetWriteDeadline method. </p>
<h3 id="UDPConn.SyscallConn">func (*UDPConn) <span>SyscallConn</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *UDPConn) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<h3 id="UDPConn.Write">func (*UDPConn) <span>Write</span>  </h3> <pre data-language="go">func (c *UDPConn) Write(b []byte) (int, error)</pre> <p>Write implements the Conn Write method. </p>
<h3 id="UDPConn.WriteMsgUDP">func (*UDPConn) <span>WriteMsgUDP</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</pre> <p>WriteMsgUDP writes a message to addr via c if c isn't connected, or to c's remote address if c is connected (in which case addr must be nil). The payload is copied from b and the associated out-of-band data is copied from oob. It returns the number of payload and out-of-band bytes written. </p>
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be used to manipulate IP-level socket options in oob. </p>
<h3 id="UDPConn.WriteMsgUDPAddrPort">func (*UDPConn) <span>WriteMsgUDPAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *UDPConn) WriteMsgUDPAddrPort(b, oob []byte, addr netip.AddrPort) (n, oobn int, err error)</pre> <p>WriteMsgUDPAddrPort is like WriteMsgUDP but takes a netip.AddrPort instead of a UDPAddr. </p>
<h3 id="UDPConn.WriteTo">func (*UDPConn) <span>WriteTo</span>  </h3> <pre data-language="go">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p>WriteTo implements the PacketConn WriteTo method. </p>   <h4 id="example_UDPConn_WriteTo"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">
// Unlike Dial, ListenPacket creates a connection without any
// association with peers.
conn, err := net.ListenPacket("udp", ":0")
if err != nil {
    log.Fatal(err)
}
defer conn.Close()

dst, err := net.ResolveUDPAddr("udp", "192.0.2.1:2000")
if err != nil {
    log.Fatal(err)
}

// The connection can write data to the desired address.
_, err = conn.WriteTo([]byte("data"), dst)
if err != nil {
    log.Fatal(err)
}
</pre>   <h3 id="UDPConn.WriteToUDP">func (*UDPConn) <span>WriteToUDP</span>  </h3> <pre data-language="go">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</pre> <p>WriteToUDP acts like WriteTo but takes a UDPAddr. </p>
<h3 id="UDPConn.WriteToUDPAddrPort">func (*UDPConn) <span>WriteToUDPAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (c *UDPConn) WriteToUDPAddrPort(b []byte, addr netip.AddrPort) (int, error)</pre> <p>WriteToUDPAddrPort acts like WriteTo but takes a netip.AddrPort. </p>
<h2 id="UnixAddr">type <span>UnixAddr</span>  </h2> <p>UnixAddr represents the address of a Unix domain socket end point. </p>
<pre data-language="go">type UnixAddr struct {
    Name string
    Net  string
}
</pre> <h3 id="ResolveUnixAddr">func <span>ResolveUnixAddr</span>  </h3> <pre data-language="go">func ResolveUnixAddr(network, address string) (*UnixAddr, error)</pre> <p>ResolveUnixAddr returns an address of Unix domain socket end point. </p>
<p>The network must be a Unix network name. </p>
<p>See func Dial for a description of the network and address parameters. </p>
<h3 id="UnixAddr.Network">func (*UnixAddr) <span>Network</span>  </h3> <pre data-language="go">func (a *UnixAddr) Network() string</pre> <p>Network returns the address's network name, "unix", "unixgram" or "unixpacket". </p>
<h3 id="UnixAddr.String">func (*UnixAddr) <span>String</span>  </h3> <pre data-language="go">func (a *UnixAddr) String() string</pre> <h2 id="UnixConn">type <span>UnixConn</span>  </h2> <p>UnixConn is an implementation of the Conn interface for connections to Unix domain sockets. </p>
<pre data-language="go">type UnixConn struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="DialUnix">func <span>DialUnix</span>  </h3> <pre data-language="go">func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)</pre> <p>DialUnix acts like Dial for Unix networks. </p>
<p>The network must be a Unix network name; see func Dial for details. </p>
<p>If laddr is non-nil, it is used as the local address for the connection. </p>
<h3 id="ListenUnixgram">func <span>ListenUnixgram</span>  </h3> <pre data-language="go">func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)</pre> <p>ListenUnixgram acts like ListenPacket for Unix networks. </p>
<p>The network must be "unixgram". </p>
<h3 id="UnixConn.Close">func (*UnixConn) <span>Close</span>  </h3> <pre data-language="go">func (c *UnixConn) Close() error</pre> <p>Close closes the connection. </p>
<h3 id="UnixConn.CloseRead">func (*UnixConn) <span>CloseRead</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *UnixConn) CloseRead() error</pre> <p>CloseRead shuts down the reading side of the Unix domain connection. Most callers should just use Close. </p>
<h3 id="UnixConn.CloseWrite">func (*UnixConn) <span>CloseWrite</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (c *UnixConn) CloseWrite() error</pre> <p>CloseWrite shuts down the writing side of the Unix domain connection. Most callers should just use Close. </p>
<h3 id="UnixConn.File">func (*UnixConn) <span>File</span>  </h3> <pre data-language="go">func (c *UnixConn) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing c does not affect f, and closing f does not affect c. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="UnixConn.LocalAddr">func (*UnixConn) <span>LocalAddr</span>  </h3> <pre data-language="go">func (c *UnixConn) LocalAddr() Addr</pre> <p>LocalAddr returns the local network address. The Addr returned is shared by all invocations of LocalAddr, so do not modify it. </p>
<h3 id="UnixConn.Read">func (*UnixConn) <span>Read</span>  </h3> <pre data-language="go">func (c *UnixConn) Read(b []byte) (int, error)</pre> <p>Read implements the Conn Read method. </p>
<h3 id="UnixConn.ReadFrom">func (*UnixConn) <span>ReadFrom</span>  </h3> <pre data-language="go">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</pre> <p>ReadFrom implements the PacketConn ReadFrom method. </p>
<h3 id="UnixConn.ReadFromUnix">func (*UnixConn) <span>ReadFromUnix</span>  </h3> <pre data-language="go">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</pre> <p>ReadFromUnix acts like ReadFrom but returns a UnixAddr. </p>
<h3 id="UnixConn.ReadMsgUnix">func (*UnixConn) <span>ReadMsgUnix</span>  </h3> <pre data-language="go">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</pre> <p>ReadMsgUnix reads a message from c, copying the payload into b and the associated out-of-band data into oob. It returns the number of bytes copied into b, the number of bytes copied into oob, the flags that were set on the message and the source address of the message. </p>
<p>Note that if len(b) == 0 and len(oob) &gt; 0, this function will still read (and discard) 1 byte from the connection. </p>
<h3 id="UnixConn.RemoteAddr">func (*UnixConn) <span>RemoteAddr</span>  </h3> <pre data-language="go">func (c *UnixConn) RemoteAddr() Addr</pre> <p>RemoteAddr returns the remote network address. The Addr returned is shared by all invocations of RemoteAddr, so do not modify it. </p>
<h3 id="UnixConn.SetDeadline">func (*UnixConn) <span>SetDeadline</span>  </h3> <pre data-language="go">func (c *UnixConn) SetDeadline(t time.Time) error</pre> <p>SetDeadline implements the Conn SetDeadline method. </p>
<h3 id="UnixConn.SetReadBuffer">func (*UnixConn) <span>SetReadBuffer</span>  </h3> <pre data-language="go">func (c *UnixConn) SetReadBuffer(bytes int) error</pre> <p>SetReadBuffer sets the size of the operating system's receive buffer associated with the connection. </p>
<h3 id="UnixConn.SetReadDeadline">func (*UnixConn) <span>SetReadDeadline</span>  </h3> <pre data-language="go">func (c *UnixConn) SetReadDeadline(t time.Time) error</pre> <p>SetReadDeadline implements the Conn SetReadDeadline method. </p>
<h3 id="UnixConn.SetWriteBuffer">func (*UnixConn) <span>SetWriteBuffer</span>  </h3> <pre data-language="go">func (c *UnixConn) SetWriteBuffer(bytes int) error</pre> <p>SetWriteBuffer sets the size of the operating system's transmit buffer associated with the connection. </p>
<h3 id="UnixConn.SetWriteDeadline">func (*UnixConn) <span>SetWriteDeadline</span>  </h3> <pre data-language="go">func (c *UnixConn) SetWriteDeadline(t time.Time) error</pre> <p>SetWriteDeadline implements the Conn SetWriteDeadline method. </p>
<h3 id="UnixConn.SyscallConn">func (*UnixConn) <span>SyscallConn</span>  <span title="Added in Go 1.9">1.9</span> </h3> <pre data-language="go">func (c *UnixConn) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<h3 id="UnixConn.Write">func (*UnixConn) <span>Write</span>  </h3> <pre data-language="go">func (c *UnixConn) Write(b []byte) (int, error)</pre> <p>Write implements the Conn Write method. </p>
<h3 id="UnixConn.WriteMsgUnix">func (*UnixConn) <span>WriteMsgUnix</span>  </h3> <pre data-language="go">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</pre> <p>WriteMsgUnix writes a message to addr via c, copying the payload from b and the associated out-of-band data from oob. It returns the number of payload and out-of-band bytes written. </p>
<p>Note that if len(b) == 0 and len(oob) &gt; 0, this function will still write 1 byte to the connection. </p>
<h3 id="UnixConn.WriteTo">func (*UnixConn) <span>WriteTo</span>  </h3> <pre data-language="go">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</pre> <p>WriteTo implements the PacketConn WriteTo method. </p>
<h3 id="UnixConn.WriteToUnix">func (*UnixConn) <span>WriteToUnix</span>  </h3> <pre data-language="go">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</pre> <p>WriteToUnix acts like WriteTo but takes a UnixAddr. </p>
<h2 id="UnixListener">type <span>UnixListener</span>  </h2> <p>UnixListener is a Unix domain socket listener. Clients should typically use variables of type Listener instead of assuming Unix domain sockets. </p>
<pre data-language="go">type UnixListener struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="ListenUnix">func <span>ListenUnix</span>  </h3> <pre data-language="go">func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)</pre> <p>ListenUnix acts like Listen for Unix networks. </p>
<p>The network must be "unix" or "unixpacket". </p>
<h3 id="UnixListener.Accept">func (*UnixListener) <span>Accept</span>  </h3> <pre data-language="go">func (l *UnixListener) Accept() (Conn, error)</pre> <p>Accept implements the Accept method in the Listener interface. Returned connections will be of type *UnixConn. </p>
<h3 id="UnixListener.AcceptUnix">func (*UnixListener) <span>AcceptUnix</span>  </h3> <pre data-language="go">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</pre> <p>AcceptUnix accepts the next incoming call and returns the new connection. </p>
<h3 id="UnixListener.Addr">func (*UnixListener) <span>Addr</span>  </h3> <pre data-language="go">func (l *UnixListener) Addr() Addr</pre> <p>Addr returns the listener's network address. The Addr returned is shared by all invocations of Addr, so do not modify it. </p>
<h3 id="UnixListener.Close">func (*UnixListener) <span>Close</span>  </h3> <pre data-language="go">func (l *UnixListener) Close() error</pre> <p>Close stops listening on the Unix address. Already accepted connections are not closed. </p>
<h3 id="UnixListener.File">func (*UnixListener) <span>File</span>  </h3> <pre data-language="go">func (l *UnixListener) File() (f *os.File, err error)</pre> <p>File returns a copy of the underlying os.File. It is the caller's responsibility to close f when finished. Closing l does not affect f, and closing f does not affect l. </p>
<p>The returned os.File's file descriptor is different from the connection's. Attempting to change properties of the original using this duplicate may or may not have the desired effect. </p>
<h3 id="UnixListener.SetDeadline">func (*UnixListener) <span>SetDeadline</span>  </h3> <pre data-language="go">func (l *UnixListener) SetDeadline(t time.Time) error</pre> <p>SetDeadline sets the deadline associated with the listener. A zero time value disables the deadline. </p>
<h3 id="UnixListener.SetUnlinkOnClose">func (*UnixListener) <span>SetUnlinkOnClose</span>  <span title="Added in Go 1.8">1.8</span> </h3> <pre data-language="go">func (l *UnixListener) SetUnlinkOnClose(unlink bool)</pre> <p>SetUnlinkOnClose sets whether the underlying socket file should be removed from the file system when the listener is closed. </p>
<p>The default behavior is to unlink the socket file only when package net created it. That is, when the listener and the underlying socket file were created by a call to Listen or ListenUnix, then by default closing the listener will remove the socket file. but if the listener was created by a call to FileListener to use an already existing socket file, then by default closing the listener will not remove the socket file. </p>
<h3 id="UnixListener.SyscallConn">func (*UnixListener) <span>SyscallConn</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (l *UnixListener) SyscallConn() (syscall.RawConn, error)</pre> <p>SyscallConn returns a raw network connection. This implements the syscall.Conn interface. </p>
<p>The returned RawConn only supports calling Control. Read and Write return an error. </p>
<h2 id="UnknownNetworkError">type <span>UnknownNetworkError</span>  </h2> <pre data-language="go">type UnknownNetworkError string</pre> <h3 id="UnknownNetworkError.Error">func (UnknownNetworkError) <span>Error</span>  </h3> <pre data-language="go">func (e UnknownNetworkError) Error() string</pre> <h3 id="UnknownNetworkError.Temporary">func (UnknownNetworkError) <span>Temporary</span>  </h3> <pre data-language="go">func (e UnknownNetworkError) Temporary() bool</pre> <h3 id="UnknownNetworkError.Timeout">func (UnknownNetworkError) <span>Timeout</span>  </h3> <pre data-language="go">func (e UnknownNetworkError) Timeout() bool</pre> <h2 id="pkg-note-BUG">Bugs</h2> <ul> <li> <p>On JS and Windows, the FileConn, FileListener and FilePacketConn functions are not implemented. </p>
</li> <li> <p>On JS, methods and functions related to Interface are not implemented. </p>
</li> <li> <p>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and Solaris, the MulticastAddrs method of Interface is not implemented. </p>
</li> <li> <p>On every POSIX platform, reads from the "ip4" network using the ReadFrom or ReadFromIP method might not return a complete IPv4 packet, including its header, even if there is space available. This can occur even in cases where Read or ReadMsgIP could return a complete packet. For this reason, it is recommended that you do not use these methods if it is important to receive a full packet. </p>
<p>The Go 1 compatibility guidelines make it impossible for us to change the behavior of these methods; use Read or ReadMsgIP instead. </p>
</li> <li> <p>On JS and Plan 9, methods and functions related to IPConn are not implemented. </p>
</li> <li> <p>On Windows, the File method of IPConn is not implemented. </p>
</li> <li> <p>On DragonFly BSD and OpenBSD, listening on the "tcp" and "udp" networks does not listen for both IPv4 and IPv6 connections. This is due to the fact that IPv4 traffic will not be routed to an IPv6 socket - two separate sockets are required if both address families are to be supported. See inet6(4) for details. </p>
</li> <li> <p>On Windows, the Write method of syscall.RawConn does not integrate with the runtime's network poller. It cannot wait for the connection to become writeable, and does not respect deadlines. If the user-provided callback returns false, the Write method will fail immediately. </p>
</li> <li> <p>On JS and Plan 9, the Control, Read and Write methods of syscall.RawConn are not implemented. </p>
</li> <li> <p>On JS and Windows, the File method of TCPConn and TCPListener is not implemented. </p>
</li> <li> <p>On Plan 9, the ReadMsgUDP and WriteMsgUDP methods of UDPConn are not implemented. </p>
</li> <li> <p>On Windows, the File method of UDPConn is not implemented. </p>
</li> <li> <p>On JS, methods and functions related to UDPConn are not implemented. </p>
</li> <li> <p>On JS, WASIP1 and Plan 9, methods and functions related to UnixConn and UnixListener are not implemented. </p>
</li> <li> <p>On Windows, methods and functions related to UnixConn and UnixListener don't work for "unixgram" and "unixpacket". </p>
</li> </ul> <h2 id="pkg-subdirectories">Subdirectories</h2> <div class="pkg-dir"> <table> <tr> <th class="pkg-name">Name</th> <th class="pkg-synopsis">Synopsis</th> </tr> <tr> <td colspan="2"><a href="../index.html">..</a></td> </tr> <tr> <td class="pkg-name"> <a href="http/index">http</a> </td> <td class="pkg-synopsis"> Package http provides HTTP client and server implementations. </td> </tr> <tr> <td class="pkg-name"> <a href="http/cgi/index">cgi</a> </td> <td class="pkg-synopsis"> Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875. </td> </tr> <tr> <td class="pkg-name"> <a href="http/cookiejar/index">cookiejar</a> </td> <td class="pkg-synopsis"> Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar. </td> </tr> <tr> <td class="pkg-name"> <a href="http/fcgi/index">fcgi</a> </td> <td class="pkg-synopsis"> Package fcgi implements the FastCGI protocol. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httptest/index">httptest</a> </td> <td class="pkg-synopsis"> Package httptest provides utilities for HTTP testing. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httptrace/index">httptrace</a> </td> <td class="pkg-synopsis"> Package httptrace provides mechanisms to trace the events within HTTP client requests. </td> </tr> <tr> <td class="pkg-name"> <a href="http/httputil/index">httputil</a> </td> <td class="pkg-synopsis"> Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package. </td> </tr> <tr> <td class="pkg-name"> <a href="http/pprof/index">pprof</a> </td> <td class="pkg-synopsis"> Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool. </td> </tr> <tr> <td class="pkg-name"> <a href="mail/index.html">mail</a> </td> <td class="pkg-synopsis"> Package mail implements parsing of mail messages. </td> </tr> <tr> <td class="pkg-name"> <a href="netip/index.html">netip</a> </td> <td class="pkg-synopsis"> Package netip defines an IP address type that's a small value type. </td> </tr> <tr> <td class="pkg-name"> <a href="rpc/index.html">rpc</a> </td> <td class="pkg-synopsis"> Package rpc provides access to the exported methods of an object across a network or other I/O connection. </td> </tr> <tr> <td class="pkg-name"> <a href="rpc/jsonrpc/index.html">jsonrpc</a> </td> <td class="pkg-synopsis"> Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package. </td> </tr> <tr> <td class="pkg-name"> <a href="smtp/index.html">smtp</a> </td> <td class="pkg-synopsis"> Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321. </td> </tr> <tr> <td class="pkg-name"> <a href="textproto/index.html">textproto</a> </td> <td class="pkg-synopsis"> Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP. </td> </tr> <tr> <td class="pkg-name"> <a href="url/index.html">url</a> </td> <td class="pkg-synopsis"> Package url parses URLs and implements query escaping. </td> </tr> </table> </div><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/net/" class="_attribution-link">http://golang.org/pkg/net/</a>
  </p>
</div>
