<h1> Package netip  </h1>     <ul id="short-nav">
<li><code>import "net/netip"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package netip defines an IP address type that's a small value type. Building on that <a href="#Addr">Addr</a> type, the package also defines <a href="#AddrPort">AddrPort</a> (an IP address and a port) and <a href="#Prefix">Prefix</a> (an IP address and a bit length prefix). </p>
<p>Compared to the <span>net.IP</span> type, <a href="#Addr">Addr</a> type takes less memory, is immutable, and is comparable (supports == and being a map key). </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#Addr">type Addr</a></li>
<li> <a href="#AddrFrom16">func AddrFrom16(addr [16]byte) Addr</a>
</li>
<li> <a href="#AddrFrom4">func AddrFrom4(addr [4]byte) Addr</a>
</li>
<li> <a href="#AddrFromSlice">func AddrFromSlice(slice []byte) (ip Addr, ok bool)</a>
</li>
<li> <a href="#IPv4Unspecified">func IPv4Unspecified() Addr</a>
</li>
<li> <a href="#IPv6LinkLocalAllNodes">func IPv6LinkLocalAllNodes() Addr</a>
</li>
<li> <a href="#IPv6LinkLocalAllRouters">func IPv6LinkLocalAllRouters() Addr</a>
</li>
<li> <a href="#IPv6Loopback">func IPv6Loopback() Addr</a>
</li>
<li> <a href="#IPv6Unspecified">func IPv6Unspecified() Addr</a>
</li>
<li> <a href="#MustParseAddr">func MustParseAddr(s string) Addr</a>
</li>
<li> <a href="#ParseAddr">func ParseAddr(s string) (Addr, error)</a>
</li>
<li> <a href="#Addr.AppendBinary">func (ip Addr) AppendBinary(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#Addr.AppendText">func (ip Addr) AppendText(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#Addr.AppendTo">func (ip Addr) AppendTo(b []byte) []byte</a>
</li>
<li> <a href="#Addr.As16">func (ip Addr) As16() (a16 [16]byte)</a>
</li>
<li> <a href="#Addr.As4">func (ip Addr) As4() (a4 [4]byte)</a>
</li>
<li> <a href="#Addr.AsSlice">func (ip Addr) AsSlice() []byte</a>
</li>
<li> <a href="#Addr.BitLen">func (ip Addr) BitLen() int</a>
</li>
<li> <a href="#Addr.Compare">func (ip Addr) Compare(ip2 Addr) int</a>
</li>
<li> <a href="#Addr.Is4">func (ip Addr) Is4() bool</a>
</li>
<li> <a href="#Addr.Is4In6">func (ip Addr) Is4In6() bool</a>
</li>
<li> <a href="#Addr.Is6">func (ip Addr) Is6() bool</a>
</li>
<li> <a href="#Addr.IsGlobalUnicast">func (ip Addr) IsGlobalUnicast() bool</a>
</li>
<li> <a href="#Addr.IsInterfaceLocalMulticast">func (ip Addr) IsInterfaceLocalMulticast() bool</a>
</li>
<li> <a href="#Addr.IsLinkLocalMulticast">func (ip Addr) IsLinkLocalMulticast() bool</a>
</li>
<li> <a href="#Addr.IsLinkLocalUnicast">func (ip Addr) IsLinkLocalUnicast() bool</a>
</li>
<li> <a href="#Addr.IsLoopback">func (ip Addr) IsLoopback() bool</a>
</li>
<li> <a href="#Addr.IsMulticast">func (ip Addr) IsMulticast() bool</a>
</li>
<li> <a href="#Addr.IsPrivate">func (ip Addr) IsPrivate() bool</a>
</li>
<li> <a href="#Addr.IsUnspecified">func (ip Addr) IsUnspecified() bool</a>
</li>
<li> <a href="#Addr.IsValid">func (ip Addr) IsValid() bool</a>
</li>
<li> <a href="#Addr.Less">func (ip Addr) Less(ip2 Addr) bool</a>
</li>
<li> <a href="#Addr.MarshalBinary">func (ip Addr) MarshalBinary() ([]byte, error)</a>
</li>
<li> <a href="#Addr.MarshalText">func (ip Addr) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#Addr.Next">func (ip Addr) Next() Addr</a>
</li>
<li> <a href="#Addr.Prefix">func (ip Addr) Prefix(b int) (Prefix, error)</a>
</li>
<li> <a href="#Addr.Prev">func (ip Addr) Prev() Addr</a>
</li>
<li> <a href="#Addr.String">func (ip Addr) String() string</a>
</li>
<li> <a href="#Addr.StringExpanded">func (ip Addr) StringExpanded() string</a>
</li>
<li> <a href="#Addr.Unmap">func (ip Addr) Unmap() Addr</a>
</li>
<li> <a href="#Addr.UnmarshalBinary">func (ip *Addr) UnmarshalBinary(b []byte) error</a>
</li>
<li> <a href="#Addr.UnmarshalText">func (ip *Addr) UnmarshalText(text []byte) error</a>
</li>
<li> <a href="#Addr.WithZone">func (ip Addr) WithZone(zone string) Addr</a>
</li>
<li> <a href="#Addr.Zone">func (ip Addr) Zone() string</a>
</li>
<li><a href="#AddrPort">type AddrPort</a></li>
<li> <a href="#AddrPortFrom">func AddrPortFrom(ip Addr, port uint16) AddrPort</a>
</li>
<li> <a href="#MustParseAddrPort">func MustParseAddrPort(s string) AddrPort</a>
</li>
<li> <a href="#ParseAddrPort">func ParseAddrPort(s string) (AddrPort, error)</a>
</li>
<li> <a href="#AddrPort.Addr">func (p AddrPort) Addr() Addr</a>
</li>
<li> <a href="#AddrPort.AppendBinary">func (p AddrPort) AppendBinary(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#AddrPort.AppendText">func (p AddrPort) AppendText(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#AddrPort.AppendTo">func (p AddrPort) AppendTo(b []byte) []byte</a>
</li>
<li> <a href="#AddrPort.Compare">func (p AddrPort) Compare(p2 AddrPort) int</a>
</li>
<li> <a href="#AddrPort.IsValid">func (p AddrPort) IsValid() bool</a>
</li>
<li> <a href="#AddrPort.MarshalBinary">func (p AddrPort) MarshalBinary() ([]byte, error)</a>
</li>
<li> <a href="#AddrPort.MarshalText">func (p AddrPort) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#AddrPort.Port">func (p AddrPort) Port() uint16</a>
</li>
<li> <a href="#AddrPort.String">func (p AddrPort) String() string</a>
</li>
<li> <a href="#AddrPort.UnmarshalBinary">func (p *AddrPort) UnmarshalBinary(b []byte) error</a>
</li>
<li> <a href="#AddrPort.UnmarshalText">func (p *AddrPort) UnmarshalText(text []byte) error</a>
</li>
<li><a href="#Prefix">type Prefix</a></li>
<li> <a href="#MustParsePrefix">func MustParsePrefix(s string) Prefix</a>
</li>
<li> <a href="#ParsePrefix">func ParsePrefix(s string) (Prefix, error)</a>
</li>
<li> <a href="#PrefixFrom">func PrefixFrom(ip Addr, bits int) Prefix</a>
</li>
<li> <a href="#Prefix.Addr">func (p Prefix) Addr() Addr</a>
</li>
<li> <a href="#Prefix.AppendBinary">func (p Prefix) AppendBinary(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#Prefix.AppendText">func (p Prefix) AppendText(b []byte) ([]byte, error)</a>
</li>
<li> <a href="#Prefix.AppendTo">func (p Prefix) AppendTo(b []byte) []byte</a>
</li>
<li> <a href="#Prefix.Bits">func (p Prefix) Bits() int</a>
</li>
<li> <a href="#Prefix.Contains">func (p Prefix) Contains(ip Addr) bool</a>
</li>
<li> <a href="#Prefix.IsSingleIP">func (p Prefix) IsSingleIP() bool</a>
</li>
<li> <a href="#Prefix.IsValid">func (p Prefix) IsValid() bool</a>
</li>
<li> <a href="#Prefix.MarshalBinary">func (p Prefix) MarshalBinary() ([]byte, error)</a>
</li>
<li> <a href="#Prefix.MarshalText">func (p Prefix) MarshalText() ([]byte, error)</a>
</li>
<li> <a href="#Prefix.Masked">func (p Prefix) Masked() Prefix</a>
</li>
<li> <a href="#Prefix.Overlaps">func (p Prefix) Overlaps(o Prefix) bool</a>
</li>
<li> <a href="#Prefix.String">func (p Prefix) String() string</a>
</li>
<li> <a href="#Prefix.UnmarshalBinary">func (p *Prefix) UnmarshalBinary(b []byte) error</a>
</li>
<li> <a href="#Prefix.UnmarshalText">func (p *Prefix) UnmarshalText(text []byte) error</a>
</li>
</ul> <h3>Package files</h3> <p>  <span>netip.go</span> <span>uint128.go</span>  </p>   <h2 id="Addr">type <span>Addr</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>Addr represents an IPv4 or IPv6 address (with or without a scoped addressing zone), similar to <span>net.IP</span> or <span>net.IPAddr</span>. </p>
<p>Unlike <span>net.IP</span> or <span>net.IPAddr</span>, Addr is a comparable value type (it supports == and can be a map key) and is immutable. </p>
<p>The zero Addr is not a valid IP address. Addr{} is distinct from both 0.0.0.0 and ::. </p>
<pre data-language="go">type Addr struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="AddrFrom16">func <span>AddrFrom16</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func AddrFrom16(addr [16]byte) Addr</pre> <p>AddrFrom16 returns the IPv6 address given by the bytes in addr. An IPv4-mapped IPv6 address is left as an IPv6 address. (Use Unmap to convert them if needed.) </p>
<h3 id="AddrFrom4">func <span>AddrFrom4</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func AddrFrom4(addr [4]byte) Addr</pre> <p>AddrFrom4 returns the address of the IPv4 address given by the bytes in addr. </p>
<h3 id="AddrFromSlice">func <span>AddrFromSlice</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func AddrFromSlice(slice []byte) (ip Addr, ok bool)</pre> <p>AddrFromSlice parses the 4- or 16-byte byte slice as an IPv4 or IPv6 address. Note that a <span>net.IP</span> can be passed directly as the []byte argument. If slice's length is not 4 or 16, AddrFromSlice returns <a href="#Addr">Addr</a>{}, false. </p>
<h3 id="IPv4Unspecified">func <span>IPv4Unspecified</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func IPv4Unspecified() Addr</pre> <p>IPv4Unspecified returns the IPv4 unspecified address "0.0.0.0". </p>
<h3 id="IPv6LinkLocalAllNodes">func <span>IPv6LinkLocalAllNodes</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func IPv6LinkLocalAllNodes() Addr</pre> <p>IPv6LinkLocalAllNodes returns the IPv6 link-local all nodes multicast address ff02::1. </p>
<h3 id="IPv6LinkLocalAllRouters">func <span>IPv6LinkLocalAllRouters</span>  <span title="Added in Go 1.20">1.20</span> </h3> <pre data-language="go">func IPv6LinkLocalAllRouters() Addr</pre> <p>IPv6LinkLocalAllRouters returns the IPv6 link-local all routers multicast address ff02::2. </p>
<h3 id="IPv6Loopback">func <span>IPv6Loopback</span>  <span title="Added in Go 1.20">1.20</span> </h3> <pre data-language="go">func IPv6Loopback() Addr</pre> <p>IPv6Loopback returns the IPv6 loopback address ::1. </p>
<h3 id="IPv6Unspecified">func <span>IPv6Unspecified</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func IPv6Unspecified() Addr</pre> <p>IPv6Unspecified returns the IPv6 unspecified address "::". </p>
<h3 id="MustParseAddr">func <span>MustParseAddr</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func MustParseAddr(s string) Addr</pre> <p>MustParseAddr calls <a href="#ParseAddr">ParseAddr</a>(s) and panics on error. It is intended for use in tests with hard-coded strings. </p>
<h3 id="ParseAddr">func <span>ParseAddr</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func ParseAddr(s string) (Addr, error)</pre> <p>ParseAddr parses s as an IP address, returning the result. The string s can be in dotted decimal ("192.0.2.1"), IPv6 ("2001:db8::68"), or IPv6 with a scoped addressing zone ("fe80::1cc0:3e8c:119f:c2e1%ens18"). </p>
<h3 id="Addr.AppendBinary">func (Addr) <span>AppendBinary</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (ip Addr) AppendBinary(b []byte) ([]byte, error)</pre> <p>AppendBinary implements the <span>encoding.BinaryAppender</span> interface. </p>
<h3 id="Addr.AppendText">func (Addr) <span>AppendText</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (ip Addr) AppendText(b []byte) ([]byte, error)</pre> <p>AppendText implements the <span>encoding.TextAppender</span> interface, It is the same as <a href="#Addr.AppendTo">Addr.AppendTo</a>. </p>
<h3 id="Addr.AppendTo">func (Addr) <span>AppendTo</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) AppendTo(b []byte) []byte</pre> <p>AppendTo appends a text encoding of ip, as generated by <a href="#Addr.MarshalText">Addr.MarshalText</a>, to b and returns the extended buffer. </p>
<h3 id="Addr.As16">func (Addr) <span>As16</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) As16() (a16 [16]byte)</pre> <p>As16 returns the IP address in its 16-byte representation. IPv4 addresses are returned as IPv4-mapped IPv6 addresses. IPv6 addresses with zones are returned without their zone (use the <a href="#Addr.Zone">Addr.Zone</a> method to get it). The ip zero value returns all zeroes. </p>
<h3 id="Addr.As4">func (Addr) <span>As4</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) As4() (a4 [4]byte)</pre> <p>As4 returns an IPv4 or IPv4-in-IPv6 address in its 4-byte representation. If ip is the zero <a href="#Addr">Addr</a> or an IPv6 address, As4 panics. Note that 0.0.0.0 is not the zero Addr. </p>
<h3 id="Addr.AsSlice">func (Addr) <span>AsSlice</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) AsSlice() []byte</pre> <p>AsSlice returns an IPv4 or IPv6 address in its respective 4-byte or 16-byte representation. </p>
<h3 id="Addr.BitLen">func (Addr) <span>BitLen</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) BitLen() int</pre> <p>BitLen returns the number of bits in the IP address: 128 for IPv6, 32 for IPv4, and 0 for the zero <a href="#Addr">Addr</a>. </p>
<p>Note that IPv4-mapped IPv6 addresses are considered IPv6 addresses and therefore have bit length 128. </p>
<h3 id="Addr.Compare">func (Addr) <span>Compare</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Compare(ip2 Addr) int</pre> <p>Compare returns an integer comparing two IPs. The result will be 0 if ip == ip2, -1 if ip &lt; ip2, and +1 if ip &gt; ip2. The definition of "less than" is the same as the <a href="#Addr.Less">Addr.Less</a> method. </p>
<h3 id="Addr.Is4">func (Addr) <span>Is4</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Is4() bool</pre> <p>Is4 reports whether ip is an IPv4 address. </p>
<p>It returns false for IPv4-mapped IPv6 addresses. See <a href="#Addr.Unmap">Addr.Unmap</a>. </p>
<h3 id="Addr.Is4In6">func (Addr) <span>Is4In6</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Is4In6() bool</pre> <p>Is4In6 reports whether ip is an "IPv4-mapped IPv6 address" as defined by RFC 4291. That is, it reports whether ip is in ::ffff:0:0/96. </p>
<h3 id="Addr.Is6">func (Addr) <span>Is6</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Is6() bool</pre> <p>Is6 reports whether ip is an IPv6 address, including IPv4-mapped IPv6 addresses. </p>
<h3 id="Addr.IsGlobalUnicast">func (Addr) <span>IsGlobalUnicast</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsGlobalUnicast() bool</pre> <p>IsGlobalUnicast reports whether ip is a global unicast address. </p>
<p>It returns true for IPv6 addresses which fall outside of the current IANA-allocated 2000::/3 global unicast space, with the exception of the link-local address space. It also returns true even if ip is in the IPv4 private address space or IPv6 unique local address space. It returns false for the zero <a href="#Addr">Addr</a>. </p>
<p>For reference, see RFC 1122, RFC 4291, and RFC 4632. </p>
<h3 id="Addr.IsInterfaceLocalMulticast">func (Addr) <span>IsInterfaceLocalMulticast</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsInterfaceLocalMulticast() bool</pre> <p>IsInterfaceLocalMulticast reports whether ip is an IPv6 interface-local multicast address. </p>
<h3 id="Addr.IsLinkLocalMulticast">func (Addr) <span>IsLinkLocalMulticast</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsLinkLocalMulticast() bool</pre> <p>IsLinkLocalMulticast reports whether ip is a link-local multicast address. </p>
<h3 id="Addr.IsLinkLocalUnicast">func (Addr) <span>IsLinkLocalUnicast</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsLinkLocalUnicast() bool</pre> <p>IsLinkLocalUnicast reports whether ip is a link-local unicast address. </p>
<h3 id="Addr.IsLoopback">func (Addr) <span>IsLoopback</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsLoopback() bool</pre> <p>IsLoopback reports whether ip is a loopback address. </p>
<h3 id="Addr.IsMulticast">func (Addr) <span>IsMulticast</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsMulticast() bool</pre> <p>IsMulticast reports whether ip is a multicast address. </p>
<h3 id="Addr.IsPrivate">func (Addr) <span>IsPrivate</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsPrivate() bool</pre> <p>IsPrivate reports whether ip is a private address, according to RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses). That is, it reports whether ip is in 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, or fc00::/7. This is the same as <span>net.IP.IsPrivate</span>. </p>
<h3 id="Addr.IsUnspecified">func (Addr) <span>IsUnspecified</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsUnspecified() bool</pre> <p>IsUnspecified reports whether ip is an unspecified address, either the IPv4 address "0.0.0.0" or the IPv6 address "::". </p>
<p>Note that the zero <a href="#Addr">Addr</a> is not an unspecified address. </p>
<h3 id="Addr.IsValid">func (Addr) <span>IsValid</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) IsValid() bool</pre> <p>IsValid reports whether the <a href="#Addr">Addr</a> is an initialized address (not the zero Addr). </p>
<p>Note that "0.0.0.0" and "::" are both valid values. </p>
<h3 id="Addr.Less">func (Addr) <span>Less</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Less(ip2 Addr) bool</pre> <p>Less reports whether ip sorts before ip2. IP addresses sort first by length, then their address. IPv6 addresses with zones sort just after the same address without a zone. </p>
<h3 id="Addr.MarshalBinary">func (Addr) <span>MarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) MarshalBinary() ([]byte, error)</pre> <p>MarshalBinary implements the <span>encoding.BinaryMarshaler</span> interface. It returns a zero-length slice for the zero <a href="#Addr">Addr</a>, the 4-byte form for an IPv4 address, and the 16-byte form with zone appended for an IPv6 address. </p>
<h3 id="Addr.MarshalText">func (Addr) <span>MarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) MarshalText() ([]byte, error)</pre> <p>MarshalText implements the <span>encoding.TextMarshaler</span> interface, The encoding is the same as returned by <a href="#Addr.String">Addr.String</a>, with one exception: If ip is the zero <a href="#Addr">Addr</a>, the encoding is the empty string. </p>
<h3 id="Addr.Next">func (Addr) <span>Next</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Next() Addr</pre> <p>Next returns the address following ip. If there is none, it returns the zero <a href="#Addr">Addr</a>. </p>
<h3 id="Addr.Prefix">func (Addr) <span>Prefix</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Prefix(b int) (Prefix, error)</pre> <p>Prefix keeps only the top b bits of IP, producing a Prefix of the specified length. If ip is a zero <a href="#Addr">Addr</a>, Prefix always returns a zero Prefix and a nil error. Otherwise, if bits is less than zero or greater than ip.BitLen(), Prefix returns an error. </p>
<h3 id="Addr.Prev">func (Addr) <span>Prev</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Prev() Addr</pre> <p>Prev returns the IP before ip. If there is none, it returns the IP zero value. </p>
<h3 id="Addr.String">func (Addr) <span>String</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) String() string</pre> <p>String returns the string form of the IP address ip. It returns one of 5 forms: </p>
<ul> <li>"invalid IP", if ip is the zero <a href="#Addr">Addr</a> </li>
<li>IPv4 dotted decimal ("192.0.2.1") </li>
<li>IPv6 ("2001:db8::1") </li>
<li>"::ffff:1.2.3.4" (if <a href="#Addr.Is4In6">Addr.Is4In6</a>) </li>
<li>IPv6 with zone ("fe80:db8::1%eth0") </li>
</ul> <p>Note that unlike package net's IP.String method, IPv4-mapped IPv6 addresses format with a "::ffff:" prefix before the dotted quad. </p>
<h3 id="Addr.StringExpanded">func (Addr) <span>StringExpanded</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) StringExpanded() string</pre> <p>StringExpanded is like <a href="#Addr.String">Addr.String</a> but IPv6 addresses are expanded with leading zeroes and no "::" compression. For example, "2001:db8::1" becomes "2001:0db8:0000:0000:0000:0000:0000:0001". </p>
<h3 id="Addr.Unmap">func (Addr) <span>Unmap</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Unmap() Addr</pre> <p>Unmap returns ip with any IPv4-mapped IPv6 address prefix removed. </p>
<p>That is, if ip is an IPv6 address wrapping an IPv4 address, it returns the wrapped IPv4 address. Otherwise it returns ip unmodified. </p>
<h3 id="Addr.UnmarshalBinary">func (*Addr) <span>UnmarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip *Addr) UnmarshalBinary(b []byte) error</pre> <p>UnmarshalBinary implements the <span>encoding.BinaryUnmarshaler</span> interface. It expects data in the form generated by MarshalBinary. </p>
<h3 id="Addr.UnmarshalText">func (*Addr) <span>UnmarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip *Addr) UnmarshalText(text []byte) error</pre> <p>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by <a href="#ParseAddr">ParseAddr</a>. </p>
<p>If text is empty, UnmarshalText sets *ip to the zero <a href="#Addr">Addr</a> and returns no error. </p>
<h3 id="Addr.WithZone">func (Addr) <span>WithZone</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) WithZone(zone string) Addr</pre> <p>WithZone returns an IP that's the same as ip but with the provided zone. If zone is empty, the zone is removed. If ip is an IPv4 address, WithZone is a no-op and returns ip unchanged. </p>
<h3 id="Addr.Zone">func (Addr) <span>Zone</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (ip Addr) Zone() string</pre> <p>Zone returns ip's IPv6 scoped addressing zone, if any. </p>
<h2 id="AddrPort">type <span>AddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>AddrPort is an IP and a port number. </p>
<pre data-language="go">type AddrPort struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="AddrPortFrom">func <span>AddrPortFrom</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func AddrPortFrom(ip Addr, port uint16) AddrPort</pre> <p>AddrPortFrom returns an <a href="#AddrPort">AddrPort</a> with the provided IP and port. It does not allocate. </p>
<h3 id="MustParseAddrPort">func <span>MustParseAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func MustParseAddrPort(s string) AddrPort</pre> <p>MustParseAddrPort calls <a href="#ParseAddrPort">ParseAddrPort</a>(s) and panics on error. It is intended for use in tests with hard-coded strings. </p>
<h3 id="ParseAddrPort">func <span>ParseAddrPort</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func ParseAddrPort(s string) (AddrPort, error)</pre> <p>ParseAddrPort parses s as an <a href="#AddrPort">AddrPort</a>. </p>
<p>It doesn't do any name resolution: both the address and the port must be numeric. </p>
<h3 id="AddrPort.Addr">func (AddrPort) <span>Addr</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) Addr() Addr</pre> <p>Addr returns p's IP address. </p>
<h3 id="AddrPort.AppendBinary">func (AddrPort) <span>AppendBinary</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (p AddrPort) AppendBinary(b []byte) ([]byte, error)</pre> <p>AppendBinary implements the <span>encoding.BinaryAppendler</span> interface. It returns <a href="#Addr.AppendBinary">Addr.AppendBinary</a> with an additional two bytes appended containing the port in little-endian. </p>
<h3 id="AddrPort.AppendText">func (AddrPort) <span>AppendText</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (p AddrPort) AppendText(b []byte) ([]byte, error)</pre> <p>AppendText implements the <span>encoding.TextAppender</span> interface. The encoding is the same as returned by <a href="#AddrPort.AppendTo">AddrPort.AppendTo</a>. </p>
<h3 id="AddrPort.AppendTo">func (AddrPort) <span>AppendTo</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) AppendTo(b []byte) []byte</pre> <p>AppendTo appends a text encoding of p, as generated by <a href="#AddrPort.MarshalText">AddrPort.MarshalText</a>, to b and returns the extended buffer. </p>
<h3 id="AddrPort.Compare">func (AddrPort) <span>Compare</span>  <span title="Added in Go 1.22">1.22</span> </h3> <pre data-language="go">func (p AddrPort) Compare(p2 AddrPort) int</pre> <p>Compare returns an integer comparing two AddrPorts. The result will be 0 if p == p2, -1 if p &lt; p2, and +1 if p &gt; p2. AddrPorts sort first by IP address, then port. </p>
<h3 id="AddrPort.IsValid">func (AddrPort) <span>IsValid</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) IsValid() bool</pre> <p>IsValid reports whether p.Addr() is valid. All ports are valid, including zero. </p>
<h3 id="AddrPort.MarshalBinary">func (AddrPort) <span>MarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) MarshalBinary() ([]byte, error)</pre> <p>MarshalBinary implements the <span>encoding.BinaryMarshaler</span> interface. It returns <a href="#Addr.MarshalBinary">Addr.MarshalBinary</a> with an additional two bytes appended containing the port in little-endian. </p>
<h3 id="AddrPort.MarshalText">func (AddrPort) <span>MarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) MarshalText() ([]byte, error)</pre> <p>MarshalText implements the <span>encoding.TextMarshaler</span> interface. The encoding is the same as returned by <a href="#AddrPort.String">AddrPort.String</a>, with one exception: if p.Addr() is the zero <a href="#Addr">Addr</a>, the encoding is the empty string. </p>
<h3 id="AddrPort.Port">func (AddrPort) <span>Port</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) Port() uint16</pre> <p>Port returns p's port. </p>
<h3 id="AddrPort.String">func (AddrPort) <span>String</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p AddrPort) String() string</pre> <h3 id="AddrPort.UnmarshalBinary">func (*AddrPort) <span>UnmarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p *AddrPort) UnmarshalBinary(b []byte) error</pre> <p>UnmarshalBinary implements the <span>encoding.BinaryUnmarshaler</span> interface. It expects data in the form generated by <a href="#AddrPort.MarshalBinary">AddrPort.MarshalBinary</a>. </p>
<h3 id="AddrPort.UnmarshalText">func (*AddrPort) <span>UnmarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p *AddrPort) UnmarshalText(text []byte) error</pre> <p>UnmarshalText implements the encoding.TextUnmarshaler interface. The <a href="#AddrPort">AddrPort</a> is expected in a form generated by <a href="#AddrPort.MarshalText">AddrPort.MarshalText</a> or accepted by <a href="#ParseAddrPort">ParseAddrPort</a>. </p>
<h2 id="Prefix">type <span>Prefix</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>Prefix is an IP address prefix (CIDR) representing an IP network. </p>
<p>The first <a href="#Prefix.Bits">Prefix.Bits</a>() of <a href="#Addr">Addr</a>() are specified. The remaining bits match any address. The range of Bits() is [0,32] for IPv4 or [0,128] for IPv6. </p>
<pre data-language="go">type Prefix struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="MustParsePrefix">func <span>MustParsePrefix</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func MustParsePrefix(s string) Prefix</pre> <p>MustParsePrefix calls <a href="#ParsePrefix">ParsePrefix</a>(s) and panics on error. It is intended for use in tests with hard-coded strings. </p>
<h3 id="ParsePrefix">func <span>ParsePrefix</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func ParsePrefix(s string) (Prefix, error)</pre> <p>ParsePrefix parses s as an IP address prefix. The string can be in the form "192.168.1.0/24" or "2001:db8::/32", the CIDR notation defined in RFC 4632 and RFC 4291. IPv6 zones are not permitted in prefixes, and an error will be returned if a zone is present. </p>
<p>Note that masked address bits are not zeroed. Use Masked for that. </p>
<h3 id="PrefixFrom">func <span>PrefixFrom</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func PrefixFrom(ip Addr, bits int) Prefix</pre> <p>PrefixFrom returns a <a href="#Prefix">Prefix</a> with the provided IP address and bit prefix length. </p>
<p>It does not allocate. Unlike <a href="#Addr.Prefix">Addr.Prefix</a>, <a href="#PrefixFrom">PrefixFrom</a> does not mask off the host bits of ip. </p>
<p>If bits is less than zero or greater than ip.BitLen, <a href="#Prefix.Bits">Prefix.Bits</a> will return an invalid value -1. </p>
<h3 id="Prefix.Addr">func (Prefix) <span>Addr</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) Addr() Addr</pre> <p>Addr returns p's IP address. </p>
<h3 id="Prefix.AppendBinary">func (Prefix) <span>AppendBinary</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (p Prefix) AppendBinary(b []byte) ([]byte, error)</pre> <p>AppendBinary implements the <span>encoding.AppendMarshaler</span> interface. It returns <a href="#Addr.AppendBinary">Addr.AppendBinary</a> with an additional byte appended containing the prefix bits. </p>
<h3 id="Prefix.AppendText">func (Prefix) <span>AppendText</span>  <span title="Added in Go 1.24">1.24</span> </h3> <pre data-language="go">func (p Prefix) AppendText(b []byte) ([]byte, error)</pre> <p>AppendText implements the <span>encoding.TextAppender</span> interface. It is the same as <a href="#Prefix.AppendTo">Prefix.AppendTo</a>. </p>
<h3 id="Prefix.AppendTo">func (Prefix) <span>AppendTo</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) AppendTo(b []byte) []byte</pre> <p>AppendTo appends a text encoding of p, as generated by <a href="#Prefix.MarshalText">Prefix.MarshalText</a>, to b and returns the extended buffer. </p>
<h3 id="Prefix.Bits">func (Prefix) <span>Bits</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) Bits() int</pre> <p>Bits returns p's prefix length. </p>
<p>It reports -1 if invalid. </p>
<h3 id="Prefix.Contains">func (Prefix) <span>Contains</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) Contains(ip Addr) bool</pre> <p>Contains reports whether the network p includes ip. </p>
<p>An IPv4 address will not match an IPv6 prefix. An IPv4-mapped IPv6 address will not match an IPv4 prefix. A zero-value IP will not match any prefix. If ip has an IPv6 zone, Contains returns false, because Prefixes strip zones. </p>
<h3 id="Prefix.IsSingleIP">func (Prefix) <span>IsSingleIP</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) IsSingleIP() bool</pre> <p>IsSingleIP reports whether p contains exactly one IP. </p>
<h3 id="Prefix.IsValid">func (Prefix) <span>IsValid</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) IsValid() bool</pre> <p>IsValid reports whether p.Bits() has a valid range for p.Addr(). If p.Addr() is the zero <a href="#Addr">Addr</a>, IsValid returns false. Note that if p is the zero <a href="#Prefix">Prefix</a>, then p.IsValid() == false. </p>
<h3 id="Prefix.MarshalBinary">func (Prefix) <span>MarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) MarshalBinary() ([]byte, error)</pre> <p>MarshalBinary implements the <span>encoding.BinaryMarshaler</span> interface. It returns <a href="#Addr.MarshalBinary">Addr.MarshalBinary</a> with an additional byte appended containing the prefix bits. </p>
<h3 id="Prefix.MarshalText">func (Prefix) <span>MarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) MarshalText() ([]byte, error)</pre> <p>MarshalText implements the <span>encoding.TextMarshaler</span> interface, The encoding is the same as returned by <a href="#Prefix.String">Prefix.String</a>, with one exception: If p is the zero value, the encoding is the empty string. </p>
<h3 id="Prefix.Masked">func (Prefix) <span>Masked</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) Masked() Prefix</pre> <p>Masked returns p in its canonical form, with all but the high p.Bits() bits of p.Addr() masked off. </p>
<p>If p is zero or otherwise invalid, Masked returns the zero <a href="#Prefix">Prefix</a>. </p>
<h3 id="Prefix.Overlaps">func (Prefix) <span>Overlaps</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) Overlaps(o Prefix) bool</pre> <p>Overlaps reports whether p and o contain any IP addresses in common. </p>
<p>If p and o are of different address families or either have a zero IP, it reports false. Like the Contains method, a prefix with an IPv4-mapped IPv6 address is still treated as an IPv6 mask. </p>
<h3 id="Prefix.String">func (Prefix) <span>String</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p Prefix) String() string</pre> <p>String returns the CIDR notation of p: "&lt;ip&gt;/&lt;bits&gt;". </p>
<h3 id="Prefix.UnmarshalBinary">func (*Prefix) <span>UnmarshalBinary</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p *Prefix) UnmarshalBinary(b []byte) error</pre> <p>UnmarshalBinary implements the <span>encoding.BinaryUnmarshaler</span> interface. It expects data in the form generated by <a href="#Prefix.MarshalBinary">Prefix.MarshalBinary</a>. </p>
<h3 id="Prefix.UnmarshalText">func (*Prefix) <span>UnmarshalText</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (p *Prefix) UnmarshalText(text []byte) error</pre> <p>UnmarshalText implements the encoding.TextUnmarshaler interface. The IP address is expected in a form accepted by <a href="#ParsePrefix">ParsePrefix</a> or generated by <a href="#Prefix.MarshalText">Prefix.MarshalText</a>. </p><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/net/netip/" class="_attribution-link">http://golang.org/pkg/net/netip/</a>
  </p>
</div>
