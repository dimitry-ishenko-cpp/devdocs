<h1> Package macho  </h1>     <ul id="short-nav">
<li><code>import "debug/macho"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package macho implements access to Mach-O object files. </p>
<h3 id="hdr-Security">Security</h3> <p>This package is not designed to be hardened against adversarial inputs, and is outside the scope of <a href="https://go.dev/security/policy">https://go.dev/security/policy</a>. In particular, only basic validation is done when parsing object files. As such, care should be taken when parsing untrusted inputs, as parsing malformed files may consume significant resources, or cause panics. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#pkg-constants">Constants</a></li>
<li><a href="#pkg-variables">Variables</a></li>
<li><a href="#Cpu">type Cpu</a></li>
<li> <a href="#Cpu.GoString">func (i Cpu) GoString() string</a>
</li>
<li> <a href="#Cpu.String">func (i Cpu) String() string</a>
</li>
<li><a href="#Dylib">type Dylib</a></li>
<li><a href="#DylibCmd">type DylibCmd</a></li>
<li><a href="#Dysymtab">type Dysymtab</a></li>
<li><a href="#DysymtabCmd">type DysymtabCmd</a></li>
<li><a href="#FatArch">type FatArch</a></li>
<li><a href="#FatArchHeader">type FatArchHeader</a></li>
<li><a href="#FatFile">type FatFile</a></li>
<li> <a href="#NewFatFile">func NewFatFile(r io.ReaderAt) (*FatFile, error)</a>
</li>
<li> <a href="#OpenFat">func OpenFat(name string) (*FatFile, error)</a>
</li>
<li> <a href="#FatFile.Close">func (ff *FatFile) Close() error</a>
</li>
<li><a href="#File">type File</a></li>
<li> <a href="#NewFile">func NewFile(r io.ReaderAt) (*File, error)</a>
</li>
<li> <a href="#Open">func Open(name string) (*File, error)</a>
</li>
<li> <a href="#File.Close">func (f *File) Close() error</a>
</li>
<li> <a href="#File.DWARF">func (f *File) DWARF() (*dwarf.Data, error)</a>
</li>
<li> <a href="#File.ImportedLibraries">func (f *File) ImportedLibraries() ([]string, error)</a>
</li>
<li> <a href="#File.ImportedSymbols">func (f *File) ImportedSymbols() ([]string, error)</a>
</li>
<li> <a href="#File.Section">func (f *File) Section(name string) *Section</a>
</li>
<li> <a href="#File.Segment">func (f *File) Segment(name string) *Segment</a>
</li>
<li><a href="#FileHeader">type FileHeader</a></li>
<li><a href="#FormatError">type FormatError</a></li>
<li> <a href="#FormatError.Error">func (e *FormatError) Error() string</a>
</li>
<li><a href="#Load">type Load</a></li>
<li><a href="#LoadBytes">type LoadBytes</a></li>
<li> <a href="#LoadBytes.Raw">func (b LoadBytes) Raw() []byte</a>
</li>
<li><a href="#LoadCmd">type LoadCmd</a></li>
<li> <a href="#LoadCmd.GoString">func (i LoadCmd) GoString() string</a>
</li>
<li> <a href="#LoadCmd.String">func (i LoadCmd) String() string</a>
</li>
<li><a href="#Nlist32">type Nlist32</a></li>
<li><a href="#Nlist64">type Nlist64</a></li>
<li><a href="#Regs386">type Regs386</a></li>
<li><a href="#RegsAMD64">type RegsAMD64</a></li>
<li><a href="#Reloc">type Reloc</a></li>
<li><a href="#RelocTypeARM">type RelocTypeARM</a></li>
<li> <a href="#RelocTypeARM.GoString">func (r RelocTypeARM) GoString() string</a>
</li>
<li> <a href="#RelocTypeARM.String">func (i RelocTypeARM) String() string</a>
</li>
<li><a href="#RelocTypeARM64">type RelocTypeARM64</a></li>
<li> <a href="#RelocTypeARM64.GoString">func (r RelocTypeARM64) GoString() string</a>
</li>
<li> <a href="#RelocTypeARM64.String">func (i RelocTypeARM64) String() string</a>
</li>
<li><a href="#RelocTypeGeneric">type RelocTypeGeneric</a></li>
<li> <a href="#RelocTypeGeneric.GoString">func (r RelocTypeGeneric) GoString() string</a>
</li>
<li> <a href="#RelocTypeGeneric.String">func (i RelocTypeGeneric) String() string</a>
</li>
<li><a href="#RelocTypeX86_64">type RelocTypeX86_64</a></li>
<li> <a href="#RelocTypeX86_64.GoString">func (r RelocTypeX86_64) GoString() string</a>
</li>
<li> <a href="#RelocTypeX86_64.String">func (i RelocTypeX86_64) String() string</a>
</li>
<li><a href="#Rpath">type Rpath</a></li>
<li><a href="#RpathCmd">type RpathCmd</a></li>
<li><a href="#Section">type Section</a></li>
<li> <a href="#Section.Data">func (s *Section) Data() ([]byte, error)</a>
</li>
<li> <a href="#Section.Open">func (s *Section) Open() io.ReadSeeker</a>
</li>
<li><a href="#Section32">type Section32</a></li>
<li><a href="#Section64">type Section64</a></li>
<li><a href="#SectionHeader">type SectionHeader</a></li>
<li><a href="#Segment">type Segment</a></li>
<li> <a href="#Segment.Data">func (s *Segment) Data() ([]byte, error)</a>
</li>
<li> <a href="#Segment.Open">func (s *Segment) Open() io.ReadSeeker</a>
</li>
<li><a href="#Segment32">type Segment32</a></li>
<li><a href="#Segment64">type Segment64</a></li>
<li><a href="#SegmentHeader">type SegmentHeader</a></li>
<li><a href="#Symbol">type Symbol</a></li>
<li><a href="#Symtab">type Symtab</a></li>
<li><a href="#SymtabCmd">type SymtabCmd</a></li>
<li><a href="#Thread">type Thread</a></li>
<li><a href="#Type">type Type</a></li>
<li> <a href="#Type.GoString">func (t Type) GoString() string</a>
</li>
<li> <a href="#Type.String">func (t Type) String() string</a>
</li>
</ul> <h3>Package files</h3> <p>  <span>fat.go</span> <span>file.go</span> <span>macho.go</span> <span>reloctype.go</span> <span>reloctype_string.go</span>  </p>   <h2 id="pkg-constants">Constants</h2> <pre data-language="go">const (
    Magic32  uint32 = 0xfeedface
    Magic64  uint32 = 0xfeedfacf
    MagicFat uint32 = 0xcafebabe
)</pre> <pre data-language="go">const (
    FlagNoUndefs              uint32 = 0x1
    FlagIncrLink              uint32 = 0x2
    FlagDyldLink              uint32 = 0x4
    FlagBindAtLoad            uint32 = 0x8
    FlagPrebound              uint32 = 0x10
    FlagSplitSegs             uint32 = 0x20
    FlagLazyInit              uint32 = 0x40
    FlagTwoLevel              uint32 = 0x80
    FlagForceFlat             uint32 = 0x100
    FlagNoMultiDefs           uint32 = 0x200
    FlagNoFixPrebinding       uint32 = 0x400
    FlagPrebindable           uint32 = 0x800
    FlagAllModsBound          uint32 = 0x1000
    FlagSubsectionsViaSymbols uint32 = 0x2000
    FlagCanonical             uint32 = 0x4000
    FlagWeakDefines           uint32 = 0x8000
    FlagBindsToWeak           uint32 = 0x10000
    FlagAllowStackExecution   uint32 = 0x20000
    FlagRootSafe              uint32 = 0x40000
    FlagSetuidSafe            uint32 = 0x80000
    FlagNoReexportedDylibs    uint32 = 0x100000
    FlagPIE                   uint32 = 0x200000
    FlagDeadStrippableDylib   uint32 = 0x400000
    FlagHasTLVDescriptors     uint32 = 0x800000
    FlagNoHeapExecution       uint32 = 0x1000000
    FlagAppExtensionSafe      uint32 = 0x2000000
)</pre> <h2 id="pkg-variables">Variables</h2> <p>ErrNotFat is returned from <a href="#NewFatFile">NewFatFile</a> or <a href="#OpenFat">OpenFat</a> when the file is not a universal binary but may be a thin binary, based on its magic number. </p>
<pre data-language="go">var ErrNotFat = &amp;FormatError{0, "not a fat Mach-O file", nil}</pre> <h2 id="Cpu">type <span>Cpu</span>  </h2> <p>A Cpu is a Mach-O cpu type. </p>
<pre data-language="go">type Cpu uint32</pre> <pre data-language="go">const (
    Cpu386   Cpu = 7
    CpuAmd64 Cpu = Cpu386 | cpuArch64
    CpuArm   Cpu = 12
    CpuArm64 Cpu = CpuArm | cpuArch64
    CpuPpc   Cpu = 18
    CpuPpc64 Cpu = CpuPpc | cpuArch64
)</pre> <h3 id="Cpu.GoString">func (Cpu) <span>GoString</span>  </h3> <pre data-language="go">func (i Cpu) GoString() string</pre> <h3 id="Cpu.String">func (Cpu) <span>String</span>  </h3> <pre data-language="go">func (i Cpu) String() string</pre> <h2 id="Dylib">type <span>Dylib</span>  </h2> <p>A Dylib represents a Mach-O load dynamic library command. </p>
<pre data-language="go">type Dylib struct {
    LoadBytes
    Name           string
    Time           uint32
    CurrentVersion uint32
    CompatVersion  uint32
}
</pre> <h2 id="DylibCmd">type <span>DylibCmd</span>  </h2> <p>A DylibCmd is a Mach-O load dynamic library command. </p>
<pre data-language="go">type DylibCmd struct {
    Cmd            LoadCmd
    Len            uint32
    Name           uint32
    Time           uint32
    CurrentVersion uint32
    CompatVersion  uint32
}
</pre> <h2 id="Dysymtab">type <span>Dysymtab</span>  </h2> <p>A Dysymtab represents a Mach-O dynamic symbol table command. </p>
<pre data-language="go">type Dysymtab struct {
    LoadBytes
    DysymtabCmd
    IndirectSyms []uint32 // indices into Symtab.Syms
}
</pre> <h2 id="DysymtabCmd">type <span>DysymtabCmd</span>  </h2> <p>A DysymtabCmd is a Mach-O dynamic symbol table command. </p>
<pre data-language="go">type DysymtabCmd struct {
    Cmd            LoadCmd
    Len            uint32
    Ilocalsym      uint32
    Nlocalsym      uint32
    Iextdefsym     uint32
    Nextdefsym     uint32
    Iundefsym      uint32
    Nundefsym      uint32
    Tocoffset      uint32
    Ntoc           uint32
    Modtaboff      uint32
    Nmodtab        uint32
    Extrefsymoff   uint32
    Nextrefsyms    uint32
    Indirectsymoff uint32
    Nindirectsyms  uint32
    Extreloff      uint32
    Nextrel        uint32
    Locreloff      uint32
    Nlocrel        uint32
}
</pre> <h2 id="FatArch">type <span>FatArch</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>A FatArch is a Mach-O File inside a FatFile. </p>
<pre data-language="go">type FatArch struct {
    FatArchHeader
    *File
}
</pre> <h2 id="FatArchHeader">type <span>FatArchHeader</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>A FatArchHeader represents a fat header for a specific image architecture. </p>
<pre data-language="go">type FatArchHeader struct {
    Cpu    Cpu
    SubCpu uint32
    Offset uint32
    Size   uint32
    Align  uint32
}
</pre> <h2 id="FatFile">type <span>FatFile</span>  <span title="Added in Go 1.3">1.3</span> </h2> <p>A FatFile is a Mach-O universal binary that contains at least one architecture. </p>
<pre data-language="go">type FatFile struct {
    Magic  uint32
    Arches []FatArch
    // contains filtered or unexported fields
}
</pre> <h3 id="NewFatFile">func <span>NewFatFile</span>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func NewFatFile(r io.ReaderAt) (*FatFile, error)</pre> <p>NewFatFile creates a new <a href="#FatFile">FatFile</a> for accessing all the Mach-O images in a universal binary. The Mach-O binary is expected to start at position 0 in the ReaderAt. </p>
<h3 id="OpenFat">func <span>OpenFat</span>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func OpenFat(name string) (*FatFile, error)</pre> <p>OpenFat opens the named file using <span>os.Open</span> and prepares it for use as a Mach-O universal binary. </p>
<h3 id="FatFile.Close">func (*FatFile) <span>Close</span>  <span title="Added in Go 1.3">1.3</span> </h3> <pre data-language="go">func (ff *FatFile) Close() error</pre> <h2 id="File">type <span>File</span>  </h2> <p>A File represents an open Mach-O file. </p>
<pre data-language="go">type File struct {
    FileHeader
    ByteOrder binary.ByteOrder
    Loads     []Load
    Sections  []*Section

    Symtab   *Symtab
    Dysymtab *Dysymtab
    // contains filtered or unexported fields
}
</pre> <h3 id="NewFile">func <span>NewFile</span>  </h3> <pre data-language="go">func NewFile(r io.ReaderAt) (*File, error)</pre> <p>NewFile creates a new <a href="#File">File</a> for accessing a Mach-O binary in an underlying reader. The Mach-O binary is expected to start at position 0 in the ReaderAt. </p>
<h3 id="Open">func <span>Open</span>  </h3> <pre data-language="go">func Open(name string) (*File, error)</pre> <p>Open opens the named file using <span>os.Open</span> and prepares it for use as a Mach-O binary. </p>
<h3 id="File.Close">func (*File) <span>Close</span>  </h3> <pre data-language="go">func (f *File) Close() error</pre> <p>Close closes the <a href="#File">File</a>. If the <a href="#File">File</a> was created using <a href="#NewFile">NewFile</a> directly instead of <a href="#Open">Open</a>, Close has no effect. </p>
<h3 id="File.DWARF">func (*File) <span>DWARF</span>  </h3> <pre data-language="go">func (f *File) DWARF() (*dwarf.Data, error)</pre> <p>DWARF returns the DWARF debug information for the Mach-O file. </p>
<h3 id="File.ImportedLibraries">func (*File) <span>ImportedLibraries</span>  </h3> <pre data-language="go">func (f *File) ImportedLibraries() ([]string, error)</pre> <p>ImportedLibraries returns the paths of all libraries referred to by the binary f that are expected to be linked with the binary at dynamic link time. </p>
<h3 id="File.ImportedSymbols">func (*File) <span>ImportedSymbols</span>  </h3> <pre data-language="go">func (f *File) ImportedSymbols() ([]string, error)</pre> <p>ImportedSymbols returns the names of all symbols referred to by the binary f that are expected to be satisfied by other libraries at dynamic load time. </p>
<h3 id="File.Section">func (*File) <span>Section</span>  </h3> <pre data-language="go">func (f *File) Section(name string) *Section</pre> <p>Section returns the first section with the given name, or nil if no such section exists. </p>
<h3 id="File.Segment">func (*File) <span>Segment</span>  </h3> <pre data-language="go">func (f *File) Segment(name string) *Segment</pre> <p>Segment returns the first Segment with the given name, or nil if no such segment exists. </p>
<h2 id="FileHeader">type <span>FileHeader</span>  </h2> <p>A FileHeader represents a Mach-O file header. </p>
<pre data-language="go">type FileHeader struct {
    Magic  uint32
    Cpu    Cpu
    SubCpu uint32
    Type   Type
    Ncmd   uint32
    Cmdsz  uint32
    Flags  uint32
}
</pre> <h2 id="FormatError">type <span>FormatError</span>  </h2> <p>FormatError is returned by some operations if the data does not have the correct format for an object file. </p>
<pre data-language="go">type FormatError struct {
    // contains filtered or unexported fields
}
</pre> <h3 id="FormatError.Error">func (*FormatError) <span>Error</span>  </h3> <pre data-language="go">func (e *FormatError) Error() string</pre> <h2 id="Load">type <span>Load</span>  </h2> <p>A Load represents any Mach-O load command. </p>
<pre data-language="go">type Load interface {
    Raw() []byte
}</pre> <h2 id="LoadBytes">type <span>LoadBytes</span>  </h2> <p>A LoadBytes is the uninterpreted bytes of a Mach-O load command. </p>
<pre data-language="go">type LoadBytes []byte</pre> <h3 id="LoadBytes.Raw">func (LoadBytes) <span>Raw</span>  </h3> <pre data-language="go">func (b LoadBytes) Raw() []byte</pre> <h2 id="LoadCmd">type <span>LoadCmd</span>  </h2> <p>A LoadCmd is a Mach-O load command. </p>
<pre data-language="go">type LoadCmd uint32</pre> <pre data-language="go">const (
    LoadCmdSegment    LoadCmd = 0x1
    LoadCmdSymtab     LoadCmd = 0x2
    LoadCmdThread     LoadCmd = 0x4
    LoadCmdUnixThread LoadCmd = 0x5 // thread+stack
    LoadCmdDysymtab   LoadCmd = 0xb
    LoadCmdDylib      LoadCmd = 0xc // load dylib command
    LoadCmdDylinker   LoadCmd = 0xf // id dylinker command (not load dylinker command)
    LoadCmdSegment64  LoadCmd = 0x19
    LoadCmdRpath      LoadCmd = 0x8000001c
)</pre> <h3 id="LoadCmd.GoString">func (LoadCmd) <span>GoString</span>  </h3> <pre data-language="go">func (i LoadCmd) GoString() string</pre> <h3 id="LoadCmd.String">func (LoadCmd) <span>String</span>  </h3> <pre data-language="go">func (i LoadCmd) String() string</pre> <h2 id="Nlist32">type <span>Nlist32</span>  </h2> <p>An Nlist32 is a Mach-O 32-bit symbol table entry. </p>
<pre data-language="go">type Nlist32 struct {
    Name  uint32
    Type  uint8
    Sect  uint8
    Desc  uint16
    Value uint32
}
</pre> <h2 id="Nlist64">type <span>Nlist64</span>  </h2> <p>An Nlist64 is a Mach-O 64-bit symbol table entry. </p>
<pre data-language="go">type Nlist64 struct {
    Name  uint32
    Type  uint8
    Sect  uint8
    Desc  uint16
    Value uint64
}
</pre> <h2 id="Regs386">type <span>Regs386</span>  </h2> <p>Regs386 is the Mach-O 386 register structure. </p>
<pre data-language="go">type Regs386 struct {
    AX    uint32
    BX    uint32
    CX    uint32
    DX    uint32
    DI    uint32
    SI    uint32
    BP    uint32
    SP    uint32
    SS    uint32
    FLAGS uint32
    IP    uint32
    CS    uint32
    DS    uint32
    ES    uint32
    FS    uint32
    GS    uint32
}
</pre> <h2 id="RegsAMD64">type <span>RegsAMD64</span>  </h2> <p>RegsAMD64 is the Mach-O AMD64 register structure. </p>
<pre data-language="go">type RegsAMD64 struct {
    AX    uint64
    BX    uint64
    CX    uint64
    DX    uint64
    DI    uint64
    SI    uint64
    BP    uint64
    SP    uint64
    R8    uint64
    R9    uint64
    R10   uint64
    R11   uint64
    R12   uint64
    R13   uint64
    R14   uint64
    R15   uint64
    IP    uint64
    FLAGS uint64
    CS    uint64
    FS    uint64
    GS    uint64
}
</pre> <h2 id="Reloc">type <span>Reloc</span>  <span title="Added in Go 1.10">1.10</span> </h2> <p>A Reloc represents a Mach-O relocation. </p>
<pre data-language="go">type Reloc struct {
    Addr  uint32
    Value uint32
    // when Scattered == false &amp;&amp; Extern == true, Value is the symbol number.
    // when Scattered == false &amp;&amp; Extern == false, Value is the section number.
    // when Scattered == true, Value is the value that this reloc refers to.
    Type      uint8
    Len       uint8 // 0=byte, 1=word, 2=long, 3=quad
    Pcrel     bool
    Extern    bool // valid if Scattered == false
    Scattered bool
}
</pre> <h2 id="RelocTypeARM">type <span>RelocTypeARM</span>  <span title="Added in Go 1.10">1.10</span> </h2> <pre data-language="go">type RelocTypeARM int</pre> <pre data-language="go">const (
    ARM_RELOC_VANILLA        RelocTypeARM = 0
    ARM_RELOC_PAIR           RelocTypeARM = 1
    ARM_RELOC_SECTDIFF       RelocTypeARM = 2
    ARM_RELOC_LOCAL_SECTDIFF RelocTypeARM = 3
    ARM_RELOC_PB_LA_PTR      RelocTypeARM = 4
    ARM_RELOC_BR24           RelocTypeARM = 5
    ARM_THUMB_RELOC_BR22     RelocTypeARM = 6
    ARM_THUMB_32BIT_BRANCH   RelocTypeARM = 7
    ARM_RELOC_HALF           RelocTypeARM = 8
    ARM_RELOC_HALF_SECTDIFF  RelocTypeARM = 9
)</pre> <h3 id="RelocTypeARM.GoString">func (RelocTypeARM) <span>GoString</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (r RelocTypeARM) GoString() string</pre> <h3 id="RelocTypeARM.String">func (RelocTypeARM) <span>String</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (i RelocTypeARM) String() string</pre> <h2 id="RelocTypeARM64">type <span>RelocTypeARM64</span>  <span title="Added in Go 1.10">1.10</span> </h2> <pre data-language="go">type RelocTypeARM64 int</pre> <pre data-language="go">const (
    ARM64_RELOC_UNSIGNED            RelocTypeARM64 = 0
    ARM64_RELOC_SUBTRACTOR          RelocTypeARM64 = 1
    ARM64_RELOC_BRANCH26            RelocTypeARM64 = 2
    ARM64_RELOC_PAGE21              RelocTypeARM64 = 3
    ARM64_RELOC_PAGEOFF12           RelocTypeARM64 = 4
    ARM64_RELOC_GOT_LOAD_PAGE21     RelocTypeARM64 = 5
    ARM64_RELOC_GOT_LOAD_PAGEOFF12  RelocTypeARM64 = 6
    ARM64_RELOC_POINTER_TO_GOT      RelocTypeARM64 = 7
    ARM64_RELOC_TLVP_LOAD_PAGE21    RelocTypeARM64 = 8
    ARM64_RELOC_TLVP_LOAD_PAGEOFF12 RelocTypeARM64 = 9
    ARM64_RELOC_ADDEND              RelocTypeARM64 = 10
)</pre> <h3 id="RelocTypeARM64.GoString">func (RelocTypeARM64) <span>GoString</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (r RelocTypeARM64) GoString() string</pre> <h3 id="RelocTypeARM64.String">func (RelocTypeARM64) <span>String</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (i RelocTypeARM64) String() string</pre> <h2 id="RelocTypeGeneric">type <span>RelocTypeGeneric</span>  <span title="Added in Go 1.10">1.10</span> </h2> <pre data-language="go">type RelocTypeGeneric int</pre> <pre data-language="go">const (
    GENERIC_RELOC_VANILLA        RelocTypeGeneric = 0
    GENERIC_RELOC_PAIR           RelocTypeGeneric = 1
    GENERIC_RELOC_SECTDIFF       RelocTypeGeneric = 2
    GENERIC_RELOC_PB_LA_PTR      RelocTypeGeneric = 3
    GENERIC_RELOC_LOCAL_SECTDIFF RelocTypeGeneric = 4
    GENERIC_RELOC_TLV            RelocTypeGeneric = 5
)</pre> <h3 id="RelocTypeGeneric.GoString">func (RelocTypeGeneric) <span>GoString</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (r RelocTypeGeneric) GoString() string</pre> <h3 id="RelocTypeGeneric.String">func (RelocTypeGeneric) <span>String</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (i RelocTypeGeneric) String() string</pre> <h2 id="RelocTypeX86_64">type <span>RelocTypeX86_64</span>  <span title="Added in Go 1.10">1.10</span> </h2> <pre data-language="go">type RelocTypeX86_64 int</pre> <pre data-language="go">const (
    X86_64_RELOC_UNSIGNED   RelocTypeX86_64 = 0
    X86_64_RELOC_SIGNED     RelocTypeX86_64 = 1
    X86_64_RELOC_BRANCH     RelocTypeX86_64 = 2
    X86_64_RELOC_GOT_LOAD   RelocTypeX86_64 = 3
    X86_64_RELOC_GOT        RelocTypeX86_64 = 4
    X86_64_RELOC_SUBTRACTOR RelocTypeX86_64 = 5
    X86_64_RELOC_SIGNED_1   RelocTypeX86_64 = 6
    X86_64_RELOC_SIGNED_2   RelocTypeX86_64 = 7
    X86_64_RELOC_SIGNED_4   RelocTypeX86_64 = 8
    X86_64_RELOC_TLV        RelocTypeX86_64 = 9
)</pre> <h3 id="RelocTypeX86_64.GoString">func (RelocTypeX86_64) <span>GoString</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (r RelocTypeX86_64) GoString() string</pre> <h3 id="RelocTypeX86_64.String">func (RelocTypeX86_64) <span>String</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (i RelocTypeX86_64) String() string</pre> <h2 id="Rpath">type <span>Rpath</span>  <span title="Added in Go 1.10">1.10</span> </h2> <p>A Rpath represents a Mach-O rpath command. </p>
<pre data-language="go">type Rpath struct {
    LoadBytes
    Path string
}
</pre> <h2 id="RpathCmd">type <span>RpathCmd</span>  <span title="Added in Go 1.10">1.10</span> </h2> <p>A RpathCmd is a Mach-O rpath command. </p>
<pre data-language="go">type RpathCmd struct {
    Cmd  LoadCmd
    Len  uint32
    Path uint32
}
</pre> <h2 id="Section">type <span>Section</span>  </h2> <pre data-language="go">type Section struct {
    SectionHeader
    Relocs []Reloc // Go 1.10

    // Embed ReaderAt for ReadAt method.
    // Do not embed SectionReader directly
    // to avoid having Read and Seek.
    // If a client wants Read and Seek it must use
    // Open() to avoid fighting over the seek offset
    // with other clients.
    io.ReaderAt
    // contains filtered or unexported fields
}
</pre> <h3 id="Section.Data">func (*Section) <span>Data</span>  </h3> <pre data-language="go">func (s *Section) Data() ([]byte, error)</pre> <p>Data reads and returns the contents of the Mach-O section. </p>
<h3 id="Section.Open">func (*Section) <span>Open</span>  </h3> <pre data-language="go">func (s *Section) Open() io.ReadSeeker</pre> <p>Open returns a new ReadSeeker reading the Mach-O section. </p>
<h2 id="Section32">type <span>Section32</span>  </h2> <p>A Section32 is a 32-bit Mach-O section header. </p>
<pre data-language="go">type Section32 struct {
    Name     [16]byte
    Seg      [16]byte
    Addr     uint32
    Size     uint32
    Offset   uint32
    Align    uint32
    Reloff   uint32
    Nreloc   uint32
    Flags    uint32
    Reserve1 uint32
    Reserve2 uint32
}
</pre> <h2 id="Section64">type <span>Section64</span>  </h2> <p>A Section64 is a 64-bit Mach-O section header. </p>
<pre data-language="go">type Section64 struct {
    Name     [16]byte
    Seg      [16]byte
    Addr     uint64
    Size     uint64
    Offset   uint32
    Align    uint32
    Reloff   uint32
    Nreloc   uint32
    Flags    uint32
    Reserve1 uint32
    Reserve2 uint32
    Reserve3 uint32
}
</pre> <h2 id="SectionHeader">type <span>SectionHeader</span>  </h2> <pre data-language="go">type SectionHeader struct {
    Name   string
    Seg    string
    Addr   uint64
    Size   uint64
    Offset uint32
    Align  uint32
    Reloff uint32
    Nreloc uint32
    Flags  uint32
}
</pre> <h2 id="Segment">type <span>Segment</span>  </h2> <p>A Segment represents a Mach-O 32-bit or 64-bit load segment command. </p>
<pre data-language="go">type Segment struct {
    LoadBytes
    SegmentHeader

    // Embed ReaderAt for ReadAt method.
    // Do not embed SectionReader directly
    // to avoid having Read and Seek.
    // If a client wants Read and Seek it must use
    // Open() to avoid fighting over the seek offset
    // with other clients.
    io.ReaderAt
    // contains filtered or unexported fields
}
</pre> <h3 id="Segment.Data">func (*Segment) <span>Data</span>  </h3> <pre data-language="go">func (s *Segment) Data() ([]byte, error)</pre> <p>Data reads and returns the contents of the segment. </p>
<h3 id="Segment.Open">func (*Segment) <span>Open</span>  </h3> <pre data-language="go">func (s *Segment) Open() io.ReadSeeker</pre> <p>Open returns a new ReadSeeker reading the segment. </p>
<h2 id="Segment32">type <span>Segment32</span>  </h2> <p>A Segment32 is a 32-bit Mach-O segment load command. </p>
<pre data-language="go">type Segment32 struct {
    Cmd     LoadCmd
    Len     uint32
    Name    [16]byte
    Addr    uint32
    Memsz   uint32
    Offset  uint32
    Filesz  uint32
    Maxprot uint32
    Prot    uint32
    Nsect   uint32
    Flag    uint32
}
</pre> <h2 id="Segment64">type <span>Segment64</span>  </h2> <p>A Segment64 is a 64-bit Mach-O segment load command. </p>
<pre data-language="go">type Segment64 struct {
    Cmd     LoadCmd
    Len     uint32
    Name    [16]byte
    Addr    uint64
    Memsz   uint64
    Offset  uint64
    Filesz  uint64
    Maxprot uint32
    Prot    uint32
    Nsect   uint32
    Flag    uint32
}
</pre> <h2 id="SegmentHeader">type <span>SegmentHeader</span>  </h2> <p>A SegmentHeader is the header for a Mach-O 32-bit or 64-bit load segment command. </p>
<pre data-language="go">type SegmentHeader struct {
    Cmd     LoadCmd
    Len     uint32
    Name    string
    Addr    uint64
    Memsz   uint64
    Offset  uint64
    Filesz  uint64
    Maxprot uint32
    Prot    uint32
    Nsect   uint32
    Flag    uint32
}
</pre> <h2 id="Symbol">type <span>Symbol</span>  </h2> <p>A Symbol is a Mach-O 32-bit or 64-bit symbol table entry. </p>
<pre data-language="go">type Symbol struct {
    Name  string
    Type  uint8
    Sect  uint8
    Desc  uint16
    Value uint64
}
</pre> <h2 id="Symtab">type <span>Symtab</span>  </h2> <p>A Symtab represents a Mach-O symbol table command. </p>
<pre data-language="go">type Symtab struct {
    LoadBytes
    SymtabCmd
    Syms []Symbol
}
</pre> <h2 id="SymtabCmd">type <span>SymtabCmd</span>  </h2> <p>A SymtabCmd is a Mach-O symbol table command. </p>
<pre data-language="go">type SymtabCmd struct {
    Cmd     LoadCmd
    Len     uint32
    Symoff  uint32
    Nsyms   uint32
    Stroff  uint32
    Strsize uint32
}
</pre> <h2 id="Thread">type <span>Thread</span>  </h2> <p>A Thread is a Mach-O thread state command. </p>
<pre data-language="go">type Thread struct {
    Cmd  LoadCmd
    Len  uint32
    Type uint32
    Data []uint32
}
</pre> <h2 id="Type">type <span>Type</span>  </h2> <p>A Type is the Mach-O file type, e.g. an object file, executable, or dynamic library. </p>
<pre data-language="go">type Type uint32</pre> <pre data-language="go">const (
    TypeObj    Type = 1
    TypeExec   Type = 2
    TypeDylib  Type = 6
    TypeBundle Type = 8
)</pre> <h3 id="Type.GoString">func (Type) <span>GoString</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (t Type) GoString() string</pre> <h3 id="Type.String">func (Type) <span>String</span>  <span title="Added in Go 1.10">1.10</span> </h3> <pre data-language="go">func (t Type) String() string</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/debug/macho/" class="_attribution-link">http://golang.org/pkg/debug/macho/</a>
  </p>
</div>
