<h1> Package ast  </h1>     <ul id="short-nav">
<li><code>import "go/ast"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package ast declares the types used to represent syntax trees for Go packages. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#FileExports">func FileExports(src *File) bool</a></li>
<li><a href="#FilterDecl">func FilterDecl(decl Decl, f Filter) bool</a></li>
<li><a href="#FilterFile">func FilterFile(src *File, f Filter) bool</a></li>
<li><a href="#FilterPackage">func FilterPackage(pkg *Package, f Filter) bool</a></li>
<li><a href="#Fprint">func Fprint(w io.Writer, fset *token.FileSet, x any, f FieldFilter) error</a></li>
<li><a href="#Inspect">func Inspect(node Node, f func(Node) bool)</a></li>
<li><a href="#IsExported">func IsExported(name string) bool</a></li>
<li><a href="#IsGenerated">func IsGenerated(file *File) bool</a></li>
<li><a href="#NotNilFilter">func NotNilFilter(_ string, v reflect.Value) bool</a></li>
<li><a href="#PackageExports">func PackageExports(pkg *Package) bool</a></li>
<li><a href="#Preorder">func Preorder(root Node) iter.Seq[Node]</a></li>
<li><a href="#Print">func Print(fset *token.FileSet, x any) error</a></li>
<li><a href="#SortImports">func SortImports(fset *token.FileSet, f *File)</a></li>
<li><a href="#Walk">func Walk(v Visitor, node Node)</a></li>
<li><a href="#ArrayType">type ArrayType</a></li>
<li> <a href="#ArrayType.End">func (x *ArrayType) End() token.Pos</a>
</li>
<li> <a href="#ArrayType.Pos">func (x *ArrayType) Pos() token.Pos</a>
</li>
<li><a href="#AssignStmt">type AssignStmt</a></li>
<li> <a href="#AssignStmt.End">func (s *AssignStmt) End() token.Pos</a>
</li>
<li> <a href="#AssignStmt.Pos">func (s *AssignStmt) Pos() token.Pos</a>
</li>
<li><a href="#BadDecl">type BadDecl</a></li>
<li> <a href="#BadDecl.End">func (d *BadDecl) End() token.Pos</a>
</li>
<li> <a href="#BadDecl.Pos">func (d *BadDecl) Pos() token.Pos</a>
</li>
<li><a href="#BadExpr">type BadExpr</a></li>
<li> <a href="#BadExpr.End">func (x *BadExpr) End() token.Pos</a>
</li>
<li> <a href="#BadExpr.Pos">func (x *BadExpr) Pos() token.Pos</a>
</li>
<li><a href="#BadStmt">type BadStmt</a></li>
<li> <a href="#BadStmt.End">func (s *BadStmt) End() token.Pos</a>
</li>
<li> <a href="#BadStmt.Pos">func (s *BadStmt) Pos() token.Pos</a>
</li>
<li><a href="#BasicLit">type BasicLit</a></li>
<li> <a href="#BasicLit.End">func (x *BasicLit) End() token.Pos</a>
</li>
<li> <a href="#BasicLit.Pos">func (x *BasicLit) Pos() token.Pos</a>
</li>
<li><a href="#BinaryExpr">type BinaryExpr</a></li>
<li> <a href="#BinaryExpr.End">func (x *BinaryExpr) End() token.Pos</a>
</li>
<li> <a href="#BinaryExpr.Pos">func (x *BinaryExpr) Pos() token.Pos</a>
</li>
<li><a href="#BlockStmt">type BlockStmt</a></li>
<li> <a href="#BlockStmt.End">func (s *BlockStmt) End() token.Pos</a>
</li>
<li> <a href="#BlockStmt.Pos">func (s *BlockStmt) Pos() token.Pos</a>
</li>
<li><a href="#BranchStmt">type BranchStmt</a></li>
<li> <a href="#BranchStmt.End">func (s *BranchStmt) End() token.Pos</a>
</li>
<li> <a href="#BranchStmt.Pos">func (s *BranchStmt) Pos() token.Pos</a>
</li>
<li><a href="#CallExpr">type CallExpr</a></li>
<li> <a href="#CallExpr.End">func (x *CallExpr) End() token.Pos</a>
</li>
<li> <a href="#CallExpr.Pos">func (x *CallExpr) Pos() token.Pos</a>
</li>
<li><a href="#CaseClause">type CaseClause</a></li>
<li> <a href="#CaseClause.End">func (s *CaseClause) End() token.Pos</a>
</li>
<li> <a href="#CaseClause.Pos">func (s *CaseClause) Pos() token.Pos</a>
</li>
<li><a href="#ChanDir">type ChanDir</a></li>
<li><a href="#ChanType">type ChanType</a></li>
<li> <a href="#ChanType.End">func (x *ChanType) End() token.Pos</a>
</li>
<li> <a href="#ChanType.Pos">func (x *ChanType) Pos() token.Pos</a>
</li>
<li><a href="#CommClause">type CommClause</a></li>
<li> <a href="#CommClause.End">func (s *CommClause) End() token.Pos</a>
</li>
<li> <a href="#CommClause.Pos">func (s *CommClause) Pos() token.Pos</a>
</li>
<li><a href="#Comment">type Comment</a></li>
<li> <a href="#Comment.End">func (c *Comment) End() token.Pos</a>
</li>
<li> <a href="#Comment.Pos">func (c *Comment) Pos() token.Pos</a>
</li>
<li><a href="#CommentGroup">type CommentGroup</a></li>
<li> <a href="#CommentGroup.End">func (g *CommentGroup) End() token.Pos</a>
</li>
<li> <a href="#CommentGroup.Pos">func (g *CommentGroup) Pos() token.Pos</a>
</li>
<li> <a href="#CommentGroup.Text">func (g *CommentGroup) Text() string</a>
</li>
<li><a href="#CommentMap">type CommentMap</a></li>
<li> <a href="#NewCommentMap">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</a>
</li>
<li> <a href="#CommentMap.Comments">func (cmap CommentMap) Comments() []*CommentGroup</a>
</li>
<li> <a href="#CommentMap.Filter">func (cmap CommentMap) Filter(node Node) CommentMap</a>
</li>
<li> <a href="#CommentMap.String">func (cmap CommentMap) String() string</a>
</li>
<li> <a href="#CommentMap.Update">func (cmap CommentMap) Update(old, new Node) Node</a>
</li>
<li><a href="#CompositeLit">type CompositeLit</a></li>
<li> <a href="#CompositeLit.End">func (x *CompositeLit) End() token.Pos</a>
</li>
<li> <a href="#CompositeLit.Pos">func (x *CompositeLit) Pos() token.Pos</a>
</li>
<li><a href="#Decl">type Decl</a></li>
<li><a href="#DeclStmt">type DeclStmt</a></li>
<li> <a href="#DeclStmt.End">func (s *DeclStmt) End() token.Pos</a>
</li>
<li> <a href="#DeclStmt.Pos">func (s *DeclStmt) Pos() token.Pos</a>
</li>
<li><a href="#DeferStmt">type DeferStmt</a></li>
<li> <a href="#DeferStmt.End">func (s *DeferStmt) End() token.Pos</a>
</li>
<li> <a href="#DeferStmt.Pos">func (s *DeferStmt) Pos() token.Pos</a>
</li>
<li><a href="#Ellipsis">type Ellipsis</a></li>
<li> <a href="#Ellipsis.End">func (x *Ellipsis) End() token.Pos</a>
</li>
<li> <a href="#Ellipsis.Pos">func (x *Ellipsis) Pos() token.Pos</a>
</li>
<li><a href="#EmptyStmt">type EmptyStmt</a></li>
<li> <a href="#EmptyStmt.End">func (s *EmptyStmt) End() token.Pos</a>
</li>
<li> <a href="#EmptyStmt.Pos">func (s *EmptyStmt) Pos() token.Pos</a>
</li>
<li><a href="#Expr">type Expr</a></li>
<li> <a href="#Unparen">func Unparen(e Expr) Expr</a>
</li>
<li><a href="#ExprStmt">type ExprStmt</a></li>
<li> <a href="#ExprStmt.End">func (s *ExprStmt) End() token.Pos</a>
</li>
<li> <a href="#ExprStmt.Pos">func (s *ExprStmt) Pos() token.Pos</a>
</li>
<li><a href="#Field">type Field</a></li>
<li> <a href="#Field.End">func (f *Field) End() token.Pos</a>
</li>
<li> <a href="#Field.Pos">func (f *Field) Pos() token.Pos</a>
</li>
<li><a href="#FieldFilter">type FieldFilter</a></li>
<li><a href="#FieldList">type FieldList</a></li>
<li> <a href="#FieldList.End">func (f *FieldList) End() token.Pos</a>
</li>
<li> <a href="#FieldList.NumFields">func (f *FieldList) NumFields() int</a>
</li>
<li> <a href="#FieldList.Pos">func (f *FieldList) Pos() token.Pos</a>
</li>
<li><a href="#File">type File</a></li>
<li> <a href="#MergePackageFiles">func MergePackageFiles(pkg *Package, mode MergeMode) *File</a>
</li>
<li> <a href="#File.End">func (f *File) End() token.Pos</a>
</li>
<li> <a href="#File.Pos">func (f *File) Pos() token.Pos</a>
</li>
<li><a href="#Filter">type Filter</a></li>
<li><a href="#ForStmt">type ForStmt</a></li>
<li> <a href="#ForStmt.End">func (s *ForStmt) End() token.Pos</a>
</li>
<li> <a href="#ForStmt.Pos">func (s *ForStmt) Pos() token.Pos</a>
</li>
<li><a href="#FuncDecl">type FuncDecl</a></li>
<li> <a href="#FuncDecl.End">func (d *FuncDecl) End() token.Pos</a>
</li>
<li> <a href="#FuncDecl.Pos">func (d *FuncDecl) Pos() token.Pos</a>
</li>
<li><a href="#FuncLit">type FuncLit</a></li>
<li> <a href="#FuncLit.End">func (x *FuncLit) End() token.Pos</a>
</li>
<li> <a href="#FuncLit.Pos">func (x *FuncLit) Pos() token.Pos</a>
</li>
<li><a href="#FuncType">type FuncType</a></li>
<li> <a href="#FuncType.End">func (x *FuncType) End() token.Pos</a>
</li>
<li> <a href="#FuncType.Pos">func (x *FuncType) Pos() token.Pos</a>
</li>
<li><a href="#GenDecl">type GenDecl</a></li>
<li> <a href="#GenDecl.End">func (d *GenDecl) End() token.Pos</a>
</li>
<li> <a href="#GenDecl.Pos">func (d *GenDecl) Pos() token.Pos</a>
</li>
<li><a href="#GoStmt">type GoStmt</a></li>
<li> <a href="#GoStmt.End">func (s *GoStmt) End() token.Pos</a>
</li>
<li> <a href="#GoStmt.Pos">func (s *GoStmt) Pos() token.Pos</a>
</li>
<li><a href="#Ident">type Ident</a></li>
<li> <a href="#NewIdent">func NewIdent(name string) *Ident</a>
</li>
<li> <a href="#Ident.End">func (x *Ident) End() token.Pos</a>
</li>
<li> <a href="#Ident.IsExported">func (id *Ident) IsExported() bool</a>
</li>
<li> <a href="#Ident.Pos">func (x *Ident) Pos() token.Pos</a>
</li>
<li> <a href="#Ident.String">func (id *Ident) String() string</a>
</li>
<li><a href="#IfStmt">type IfStmt</a></li>
<li> <a href="#IfStmt.End">func (s *IfStmt) End() token.Pos</a>
</li>
<li> <a href="#IfStmt.Pos">func (s *IfStmt) Pos() token.Pos</a>
</li>
<li><a href="#ImportSpec">type ImportSpec</a></li>
<li> <a href="#ImportSpec.End">func (s *ImportSpec) End() token.Pos</a>
</li>
<li> <a href="#ImportSpec.Pos">func (s *ImportSpec) Pos() token.Pos</a>
</li>
<li><a href="#Importer">type Importer</a></li>
<li><a href="#IncDecStmt">type IncDecStmt</a></li>
<li> <a href="#IncDecStmt.End">func (s *IncDecStmt) End() token.Pos</a>
</li>
<li> <a href="#IncDecStmt.Pos">func (s *IncDecStmt) Pos() token.Pos</a>
</li>
<li><a href="#IndexExpr">type IndexExpr</a></li>
<li> <a href="#IndexExpr.End">func (x *IndexExpr) End() token.Pos</a>
</li>
<li> <a href="#IndexExpr.Pos">func (x *IndexExpr) Pos() token.Pos</a>
</li>
<li><a href="#IndexListExpr">type IndexListExpr</a></li>
<li> <a href="#IndexListExpr.End">func (x *IndexListExpr) End() token.Pos</a>
</li>
<li> <a href="#IndexListExpr.Pos">func (x *IndexListExpr) Pos() token.Pos</a>
</li>
<li><a href="#InterfaceType">type InterfaceType</a></li>
<li> <a href="#InterfaceType.End">func (x *InterfaceType) End() token.Pos</a>
</li>
<li> <a href="#InterfaceType.Pos">func (x *InterfaceType) Pos() token.Pos</a>
</li>
<li><a href="#KeyValueExpr">type KeyValueExpr</a></li>
<li> <a href="#KeyValueExpr.End">func (x *KeyValueExpr) End() token.Pos</a>
</li>
<li> <a href="#KeyValueExpr.Pos">func (x *KeyValueExpr) Pos() token.Pos</a>
</li>
<li><a href="#LabeledStmt">type LabeledStmt</a></li>
<li> <a href="#LabeledStmt.End">func (s *LabeledStmt) End() token.Pos</a>
</li>
<li> <a href="#LabeledStmt.Pos">func (s *LabeledStmt) Pos() token.Pos</a>
</li>
<li><a href="#MapType">type MapType</a></li>
<li> <a href="#MapType.End">func (x *MapType) End() token.Pos</a>
</li>
<li> <a href="#MapType.Pos">func (x *MapType) Pos() token.Pos</a>
</li>
<li><a href="#MergeMode">type MergeMode</a></li>
<li><a href="#Node">type Node</a></li>
<li><a href="#ObjKind">type ObjKind</a></li>
<li> <a href="#ObjKind.String">func (kind ObjKind) String() string</a>
</li>
<li><a href="#Object">type Object</a></li>
<li> <a href="#NewObj">func NewObj(kind ObjKind, name string) *Object</a>
</li>
<li> <a href="#Object.Pos">func (obj *Object) Pos() token.Pos</a>
</li>
<li><a href="#Package">type Package</a></li>
<li> <a href="#NewPackage">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</a>
</li>
<li> <a href="#Package.End">func (p *Package) End() token.Pos</a>
</li>
<li> <a href="#Package.Pos">func (p *Package) Pos() token.Pos</a>
</li>
<li><a href="#ParenExpr">type ParenExpr</a></li>
<li> <a href="#ParenExpr.End">func (x *ParenExpr) End() token.Pos</a>
</li>
<li> <a href="#ParenExpr.Pos">func (x *ParenExpr) Pos() token.Pos</a>
</li>
<li><a href="#RangeStmt">type RangeStmt</a></li>
<li> <a href="#RangeStmt.End">func (s *RangeStmt) End() token.Pos</a>
</li>
<li> <a href="#RangeStmt.Pos">func (s *RangeStmt) Pos() token.Pos</a>
</li>
<li><a href="#ReturnStmt">type ReturnStmt</a></li>
<li> <a href="#ReturnStmt.End">func (s *ReturnStmt) End() token.Pos</a>
</li>
<li> <a href="#ReturnStmt.Pos">func (s *ReturnStmt) Pos() token.Pos</a>
</li>
<li><a href="#Scope">type Scope</a></li>
<li> <a href="#NewScope">func NewScope(outer *Scope) *Scope</a>
</li>
<li> <a href="#Scope.Insert">func (s *Scope) Insert(obj *Object) (alt *Object)</a>
</li>
<li> <a href="#Scope.Lookup">func (s *Scope) Lookup(name string) *Object</a>
</li>
<li> <a href="#Scope.String">func (s *Scope) String() string</a>
</li>
<li><a href="#SelectStmt">type SelectStmt</a></li>
<li> <a href="#SelectStmt.End">func (s *SelectStmt) End() token.Pos</a>
</li>
<li> <a href="#SelectStmt.Pos">func (s *SelectStmt) Pos() token.Pos</a>
</li>
<li><a href="#SelectorExpr">type SelectorExpr</a></li>
<li> <a href="#SelectorExpr.End">func (x *SelectorExpr) End() token.Pos</a>
</li>
<li> <a href="#SelectorExpr.Pos">func (x *SelectorExpr) Pos() token.Pos</a>
</li>
<li><a href="#SendStmt">type SendStmt</a></li>
<li> <a href="#SendStmt.End">func (s *SendStmt) End() token.Pos</a>
</li>
<li> <a href="#SendStmt.Pos">func (s *SendStmt) Pos() token.Pos</a>
</li>
<li><a href="#SliceExpr">type SliceExpr</a></li>
<li> <a href="#SliceExpr.End">func (x *SliceExpr) End() token.Pos</a>
</li>
<li> <a href="#SliceExpr.Pos">func (x *SliceExpr) Pos() token.Pos</a>
</li>
<li><a href="#Spec">type Spec</a></li>
<li><a href="#StarExpr">type StarExpr</a></li>
<li> <a href="#StarExpr.End">func (x *StarExpr) End() token.Pos</a>
</li>
<li> <a href="#StarExpr.Pos">func (x *StarExpr) Pos() token.Pos</a>
</li>
<li><a href="#Stmt">type Stmt</a></li>
<li><a href="#StructType">type StructType</a></li>
<li> <a href="#StructType.End">func (x *StructType) End() token.Pos</a>
</li>
<li> <a href="#StructType.Pos">func (x *StructType) Pos() token.Pos</a>
</li>
<li><a href="#SwitchStmt">type SwitchStmt</a></li>
<li> <a href="#SwitchStmt.End">func (s *SwitchStmt) End() token.Pos</a>
</li>
<li> <a href="#SwitchStmt.Pos">func (s *SwitchStmt) Pos() token.Pos</a>
</li>
<li><a href="#TypeAssertExpr">type TypeAssertExpr</a></li>
<li> <a href="#TypeAssertExpr.End">func (x *TypeAssertExpr) End() token.Pos</a>
</li>
<li> <a href="#TypeAssertExpr.Pos">func (x *TypeAssertExpr) Pos() token.Pos</a>
</li>
<li><a href="#TypeSpec">type TypeSpec</a></li>
<li> <a href="#TypeSpec.End">func (s *TypeSpec) End() token.Pos</a>
</li>
<li> <a href="#TypeSpec.Pos">func (s *TypeSpec) Pos() token.Pos</a>
</li>
<li><a href="#TypeSwitchStmt">type TypeSwitchStmt</a></li>
<li> <a href="#TypeSwitchStmt.End">func (s *TypeSwitchStmt) End() token.Pos</a>
</li>
<li> <a href="#TypeSwitchStmt.Pos">func (s *TypeSwitchStmt) Pos() token.Pos</a>
</li>
<li><a href="#UnaryExpr">type UnaryExpr</a></li>
<li> <a href="#UnaryExpr.End">func (x *UnaryExpr) End() token.Pos</a>
</li>
<li> <a href="#UnaryExpr.Pos">func (x *UnaryExpr) Pos() token.Pos</a>
</li>
<li><a href="#ValueSpec">type ValueSpec</a></li>
<li> <a href="#ValueSpec.End">func (s *ValueSpec) End() token.Pos</a>
</li>
<li> <a href="#ValueSpec.Pos">func (s *ValueSpec) Pos() token.Pos</a>
</li>
<li><a href="#Visitor">type Visitor</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_CommentMap">CommentMap</a></dd> <dd><a class="exampleLink" href="#example_Inspect">Inspect</a></dd> <dd><a class="exampleLink" href="#example_Preorder">Preorder</a></dd> <dd><a class="exampleLink" href="#example_Print">Print</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>ast.go</span> <span>commentmap.go</span> <span>filter.go</span> <span>import.go</span> <span>print.go</span> <span>resolve.go</span> <span>scope.go</span> <span>walk.go</span>  </p>   <h2 id="FileExports">func <span>FileExports</span>  </h2> <pre data-language="go">func FileExports(src *File) bool</pre> <p>FileExports trims the AST for a Go source file in place such that only exported nodes remain: all top-level identifiers which are not exported and their associated information (such as type, initial value, or function body) are removed. Non-exported fields and methods of exported types are stripped. The [File.Comments] list is not changed. </p>
<p>FileExports reports whether there are exported declarations. </p>
<h2 id="FilterDecl">func <span>FilterDecl</span>  </h2> <pre data-language="go">func FilterDecl(decl Decl, f Filter) bool</pre> <p>FilterDecl trims the AST for a Go declaration in place by removing all names (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. </p>
<p>FilterDecl reports whether there are any declared names left after filtering. </p>
<h2 id="FilterFile">func <span>FilterFile</span>  </h2> <pre data-language="go">func FilterFile(src *File, f Filter) bool</pre> <p>FilterFile trims the AST for a Go file in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. Import declarations are always removed. The [File.Comments] list is not changed. </p>
<p>FilterFile reports whether there are any top-level declarations left after filtering. </p>
<h2 id="FilterPackage">func <span>FilterPackage</span>  </h2> <pre data-language="go">func FilterPackage(pkg *Package, f Filter) bool</pre> <p>FilterPackage trims the AST for a Go package in place by removing all names from top-level declarations (including struct field and interface method names, but not from parameter lists) that don't pass through the filter f. If the declaration is empty afterwards, the declaration is removed from the AST. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p>
<p>FilterPackage reports whether there are any top-level declarations left after filtering. </p>
<h2 id="Fprint">func <span>Fprint</span>  </h2> <pre data-language="go">func Fprint(w io.Writer, fset *token.FileSet, x any, f FieldFilter) error</pre> <p>Fprint prints the (sub-)tree starting at AST node x to w. If fset != nil, position information is interpreted relative to that file set. Otherwise positions are printed as integer values (file set specific offsets). </p>
<p>A non-nil <a href="#FieldFilter">FieldFilter</a> f may be provided to control the output: struct fields for which f(fieldname, fieldvalue) is true are printed; all others are filtered from the output. Unexported struct fields are never printed. </p>
<h2 id="Inspect">func <span>Inspect</span>  </h2> <pre data-language="go">func Inspect(node Node, f func(Node) bool)</pre> <p>Inspect traverses an AST in depth-first order: It starts by calling f(node); node must not be nil. If f returns true, Inspect invokes f recursively for each of the non-nil children of node, followed by a call of f(nil). </p>   <h4 id="example_Inspect"> <span class="text">Example</span>
</h4> <p>This example demonstrates how to inspect the AST of a Go program. </p> <p>Code:</p> <pre class="code" data-language="go">// src is the input for which we want to inspect the AST.
src := `
package p
const c = 1.0
var X = f(3.14)*2 + c
`

// Create the AST by parsing src.
fset := token.NewFileSet() // positions are relative to fset
f, err := parser.ParseFile(fset, "src.go", src, 0)
if err != nil {
    panic(err)
}

// Inspect the AST and print all identifiers and literals.
ast.Inspect(f, func(n ast.Node) bool {
    var s string
    switch x := n.(type) {
    case *ast.BasicLit:
        s = x.Value
    case *ast.Ident:
        s = x.Name
    }
    if s != "" {
        fmt.Printf("%s:\t%s\n", fset.Position(n.Pos()), s)
    }
    return true
})

</pre> <p>Output:</p> <pre class="output" data-language="go">src.go:2:9:	p
src.go:3:7:	c
src.go:3:11:	1.0
src.go:4:5:	X
src.go:4:9:	f
src.go:4:11:	3.14
src.go:4:17:	2
src.go:4:21:	c
</pre>   <h2 id="IsExported">func <span>IsExported</span>  </h2> <pre data-language="go">func IsExported(name string) bool</pre> <p>IsExported reports whether name starts with an upper-case letter. </p>
<h2 id="IsGenerated">func <span>IsGenerated</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func IsGenerated(file *File) bool</pre> <p>IsGenerated reports whether the file was generated by a program, not handwritten, by detecting the special comment described at <a href="https://go.dev/s/generatedcode">https://go.dev/s/generatedcode</a>. </p>
<p>The syntax tree must have been parsed with the [parser.ParseComments] flag. Example: </p>
<pre data-language="go">f, err := parser.ParseFile(fset, filename, src, parser.ParseComments|parser.PackageClauseOnly)
if err != nil { ... }
gen := ast.IsGenerated(f)
</pre> <h2 id="NotNilFilter">func <span>NotNilFilter</span>  </h2> <pre data-language="go">func NotNilFilter(_ string, v reflect.Value) bool</pre> <p>NotNilFilter is a <a href="#FieldFilter">FieldFilter</a> that returns true for field values that are not nil; it returns false otherwise. </p>
<h2 id="PackageExports">func <span>PackageExports</span>  </h2> <pre data-language="go">func PackageExports(pkg *Package) bool</pre> <p>PackageExports trims the AST for a Go package in place such that only exported nodes remain. The pkg.Files list is not changed, so that file names and top-level package comments don't get lost. </p>
<p>PackageExports reports whether there are exported declarations; it returns false otherwise. </p>
<h2 id="Preorder">func <span>Preorder</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Preorder(root Node) iter.Seq[Node]</pre> <p>Preorder returns an iterator over all the nodes of the syntax tree beneath (and including) the specified root, in depth-first preorder. </p>
<p>For greater control over the traversal of each subtree, use <a href="#Inspect">Inspect</a>. </p>   <h4 id="example_Preorder"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">src := `
package p

func f(x, y int) {
    print(x + y)
}
`

fset := token.NewFileSet()
f, err := parser.ParseFile(fset, "", src, 0)
if err != nil {
    panic(err)
}

// Print identifiers in order
for n := range ast.Preorder(f) {
    id, ok := n.(*ast.Ident)
    if !ok {
        continue
    }
    fmt.Println(id.Name)
}

</pre> <p>Output:</p> <pre class="output" data-language="go">p
f
x
y
int
print
x
y
</pre>   <h2 id="Print">func <span>Print</span>  </h2> <pre data-language="go">func Print(fset *token.FileSet, x any) error</pre> <p>Print prints x to standard output, skipping nil fields. Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter). </p>   <h4 id="example_Print"> <span class="text">Example</span>
</h4> <p>This example shows what an AST looks like when printed for debugging. </p> <p>Code:</p> <pre class="code" data-language="go">// src is the input for which we want to print the AST.
src := `
package main
func main() {
    println("Hello, World!")
}
`

// Create the AST by parsing src.
fset := token.NewFileSet() // positions are relative to fset
f, err := parser.ParseFile(fset, "", src, 0)
if err != nil {
    panic(err)
}

// Print the AST.
ast.Print(fset, f)

</pre> <p>Output:</p> <pre class="output" data-language="go">     0  *ast.File {
     1  .  Package: 2:1
     2  .  Name: *ast.Ident {
     3  .  .  NamePos: 2:9
     4  .  .  Name: "main"
     5  .  }
     6  .  Decls: []ast.Decl (len = 1) {
     7  .  .  0: *ast.FuncDecl {
     8  .  .  .  Name: *ast.Ident {
     9  .  .  .  .  NamePos: 3:6
    10  .  .  .  .  Name: "main"
    11  .  .  .  .  Obj: *ast.Object {
    12  .  .  .  .  .  Kind: func
    13  .  .  .  .  .  Name: "main"
    14  .  .  .  .  .  Decl: *(obj @ 7)
    15  .  .  .  .  }
    16  .  .  .  }
    17  .  .  .  Type: *ast.FuncType {
    18  .  .  .  .  Func: 3:1
    19  .  .  .  .  Params: *ast.FieldList {
    20  .  .  .  .  .  Opening: 3:10
    21  .  .  .  .  .  Closing: 3:11
    22  .  .  .  .  }
    23  .  .  .  }
    24  .  .  .  Body: *ast.BlockStmt {
    25  .  .  .  .  Lbrace: 3:13
    26  .  .  .  .  List: []ast.Stmt (len = 1) {
    27  .  .  .  .  .  0: *ast.ExprStmt {
    28  .  .  .  .  .  .  X: *ast.CallExpr {
    29  .  .  .  .  .  .  .  Fun: *ast.Ident {
    30  .  .  .  .  .  .  .  .  NamePos: 4:2
    31  .  .  .  .  .  .  .  .  Name: "println"
    32  .  .  .  .  .  .  .  }
    33  .  .  .  .  .  .  .  Lparen: 4:9
    34  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {
    35  .  .  .  .  .  .  .  .  0: *ast.BasicLit {
    36  .  .  .  .  .  .  .  .  .  ValuePos: 4:10
    37  .  .  .  .  .  .  .  .  .  Kind: STRING
    38  .  .  .  .  .  .  .  .  .  Value: "\"Hello, World!\""
    39  .  .  .  .  .  .  .  .  }
    40  .  .  .  .  .  .  .  }
    41  .  .  .  .  .  .  .  Ellipsis: -
    42  .  .  .  .  .  .  .  Rparen: 4:25
    43  .  .  .  .  .  .  }
    44  .  .  .  .  .  }
    45  .  .  .  .  }
    46  .  .  .  .  Rbrace: 5:1
    47  .  .  .  }
    48  .  .  }
    49  .  }
    50  .  FileStart: 1:1
    51  .  FileEnd: 5:3
    52  .  Scope: *ast.Scope {
    53  .  .  Objects: map[string]*ast.Object (len = 1) {
    54  .  .  .  "main": *(obj @ 11)
    55  .  .  }
    56  .  }
    57  .  Unresolved: []*ast.Ident (len = 1) {
    58  .  .  0: *(obj @ 29)
    59  .  }
    60  .  GoVersion: ""
    61  }
</pre>   <h2 id="SortImports">func <span>SortImports</span>  </h2> <pre data-language="go">func SortImports(fset *token.FileSet, f *File)</pre> <p>SortImports sorts runs of consecutive import lines in import blocks in f. It also removes duplicate imports when it is possible to do so without data loss. </p>
<h2 id="Walk">func <span>Walk</span>  </h2> <pre data-language="go">func Walk(v Visitor, node Node)</pre> <p>Walk traverses an AST in depth-first order: It starts by calling v.Visit(node); node must not be nil. If the visitor w returned by v.Visit(node) is not nil, Walk is invoked recursively with visitor w for each of the non-nil children of node, followed by a call of w.Visit(nil). </p>
<h2 id="ArrayType">type <span>ArrayType</span>  </h2> <p>An ArrayType node represents an array or slice type. </p>
<pre data-language="go">type ArrayType struct {
    Lbrack token.Pos // position of "["
    Len    Expr      // Ellipsis node for [...]T array types, nil for slice types
    Elt    Expr      // element type
}
</pre> <h3 id="ArrayType.End">func (*ArrayType) <span>End</span>  </h3> <pre data-language="go">func (x *ArrayType) End() token.Pos</pre> <h3 id="ArrayType.Pos">func (*ArrayType) <span>Pos</span>  </h3> <pre data-language="go">func (x *ArrayType) Pos() token.Pos</pre> <h2 id="AssignStmt">type <span>AssignStmt</span>  </h2> <p>An AssignStmt node represents an assignment or a short variable declaration. </p>
<pre data-language="go">type AssignStmt struct {
    Lhs    []Expr
    TokPos token.Pos   // position of Tok
    Tok    token.Token // assignment token, DEFINE
    Rhs    []Expr
}
</pre> <h3 id="AssignStmt.End">func (*AssignStmt) <span>End</span>  </h3> <pre data-language="go">func (s *AssignStmt) End() token.Pos</pre> <h3 id="AssignStmt.Pos">func (*AssignStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *AssignStmt) Pos() token.Pos</pre> <h2 id="BadDecl">type <span>BadDecl</span>  </h2> <p>A BadDecl node is a placeholder for a declaration containing syntax errors for which a correct declaration node cannot be created. </p>
<pre data-language="go">type BadDecl struct {
    From, To token.Pos // position range of bad declaration
}
</pre> <h3 id="BadDecl.End">func (*BadDecl) <span>End</span>  </h3> <pre data-language="go">func (d *BadDecl) End() token.Pos</pre> <h3 id="BadDecl.Pos">func (*BadDecl) <span>Pos</span>  </h3> <pre data-language="go">func (d *BadDecl) Pos() token.Pos</pre> <h2 id="BadExpr">type <span>BadExpr</span>  </h2> <p>A BadExpr node is a placeholder for an expression containing syntax errors for which a correct expression node cannot be created. </p>
<pre data-language="go">type BadExpr struct {
    From, To token.Pos // position range of bad expression
}
</pre> <h3 id="BadExpr.End">func (*BadExpr) <span>End</span>  </h3> <pre data-language="go">func (x *BadExpr) End() token.Pos</pre> <h3 id="BadExpr.Pos">func (*BadExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *BadExpr) Pos() token.Pos</pre> <h2 id="BadStmt">type <span>BadStmt</span>  </h2> <p>A BadStmt node is a placeholder for statements containing syntax errors for which no correct statement nodes can be created. </p>
<pre data-language="go">type BadStmt struct {
    From, To token.Pos // position range of bad statement
}
</pre> <h3 id="BadStmt.End">func (*BadStmt) <span>End</span>  </h3> <pre data-language="go">func (s *BadStmt) End() token.Pos</pre> <h3 id="BadStmt.Pos">func (*BadStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *BadStmt) Pos() token.Pos</pre> <h2 id="BasicLit">type <span>BasicLit</span>  </h2> <p>A BasicLit node represents a literal of basic type. </p>
<p>Note that for the CHAR and STRING kinds, the literal is stored with its quotes. For example, for a double-quoted STRING, the first and the last rune in the Value field will be ". The <span>strconv.Unquote</span> and <span>strconv.UnquoteChar</span> functions can be used to unquote STRING and CHAR values, respectively. </p>
<p>For raw string literals (Kind == token.STRING &amp;&amp; Value[0] == '`'), the Value field contains the string text without carriage returns (\r) that may have been present in the source. Because the end position is computed using len(Value), the position reported by <a href="#BasicLit.End">BasicLit.End</a> does not match the true source end position for raw string literals containing carriage returns. </p>
<pre data-language="go">type BasicLit struct {
    ValuePos token.Pos   // literal position
    Kind     token.Token // token.INT, token.FLOAT, token.IMAG, token.CHAR, or token.STRING
    Value    string      // literal string; e.g. 42, 0x7f, 3.14, 1e-9, 2.4i, 'a', '\x7f', "foo" or `\m\n\o`
}
</pre> <h3 id="BasicLit.End">func (*BasicLit) <span>End</span>  </h3> <pre data-language="go">func (x *BasicLit) End() token.Pos</pre> <h3 id="BasicLit.Pos">func (*BasicLit) <span>Pos</span>  </h3> <pre data-language="go">func (x *BasicLit) Pos() token.Pos</pre> <h2 id="BinaryExpr">type <span>BinaryExpr</span>  </h2> <p>A BinaryExpr node represents a binary expression. </p>
<pre data-language="go">type BinaryExpr struct {
    X     Expr        // left operand
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    Y     Expr        // right operand
}
</pre> <h3 id="BinaryExpr.End">func (*BinaryExpr) <span>End</span>  </h3> <pre data-language="go">func (x *BinaryExpr) End() token.Pos</pre> <h3 id="BinaryExpr.Pos">func (*BinaryExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *BinaryExpr) Pos() token.Pos</pre> <h2 id="BlockStmt">type <span>BlockStmt</span>  </h2> <p>A BlockStmt node represents a braced statement list. </p>
<pre data-language="go">type BlockStmt struct {
    Lbrace token.Pos // position of "{"
    List   []Stmt
    Rbrace token.Pos // position of "}", if any (may be absent due to syntax error)
}
</pre> <h3 id="BlockStmt.End">func (*BlockStmt) <span>End</span>  </h3> <pre data-language="go">func (s *BlockStmt) End() token.Pos</pre> <h3 id="BlockStmt.Pos">func (*BlockStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *BlockStmt) Pos() token.Pos</pre> <h2 id="BranchStmt">type <span>BranchStmt</span>  </h2> <p>A BranchStmt node represents a break, continue, goto, or fallthrough statement. </p>
<pre data-language="go">type BranchStmt struct {
    TokPos token.Pos   // position of Tok
    Tok    token.Token // keyword token (BREAK, CONTINUE, GOTO, FALLTHROUGH)
    Label  *Ident      // label name; or nil
}
</pre> <h3 id="BranchStmt.End">func (*BranchStmt) <span>End</span>  </h3> <pre data-language="go">func (s *BranchStmt) End() token.Pos</pre> <h3 id="BranchStmt.Pos">func (*BranchStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *BranchStmt) Pos() token.Pos</pre> <h2 id="CallExpr">type <span>CallExpr</span>  </h2> <p>A CallExpr node represents an expression followed by an argument list. </p>
<pre data-language="go">type CallExpr struct {
    Fun      Expr      // function expression
    Lparen   token.Pos // position of "("
    Args     []Expr    // function arguments; or nil
    Ellipsis token.Pos // position of "..." (token.NoPos if there is no "...")
    Rparen   token.Pos // position of ")"
}
</pre> <h3 id="CallExpr.End">func (*CallExpr) <span>End</span>  </h3> <pre data-language="go">func (x *CallExpr) End() token.Pos</pre> <h3 id="CallExpr.Pos">func (*CallExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *CallExpr) Pos() token.Pos</pre> <h2 id="CaseClause">type <span>CaseClause</span>  </h2> <p>A CaseClause represents a case of an expression or type switch statement. </p>
<pre data-language="go">type CaseClause struct {
    Case  token.Pos // position of "case" or "default" keyword
    List  []Expr    // list of expressions or types; nil means default case
    Colon token.Pos // position of ":"
    Body  []Stmt    // statement list; or nil
}
</pre> <h3 id="CaseClause.End">func (*CaseClause) <span>End</span>  </h3> <pre data-language="go">func (s *CaseClause) End() token.Pos</pre> <h3 id="CaseClause.Pos">func (*CaseClause) <span>Pos</span>  </h3> <pre data-language="go">func (s *CaseClause) Pos() token.Pos</pre> <h2 id="ChanDir">type <span>ChanDir</span>  </h2> <p>The direction of a channel type is indicated by a bit mask including one or both of the following constants. </p>
<pre data-language="go">type ChanDir int</pre> <pre data-language="go">const (
    SEND ChanDir = 1 &lt;&lt; iota
    RECV
)</pre> <h2 id="ChanType">type <span>ChanType</span>  </h2> <p>A ChanType node represents a channel type. </p>
<pre data-language="go">type ChanType struct {
    Begin token.Pos // position of "chan" keyword or "&lt;-" (whichever comes first)
    Arrow token.Pos // position of "&lt;-" (token.NoPos if there is no "&lt;-"); added in Go 1.1
    Dir   ChanDir   // channel direction
    Value Expr      // value type
}
</pre> <h3 id="ChanType.End">func (*ChanType) <span>End</span>  </h3> <pre data-language="go">func (x *ChanType) End() token.Pos</pre> <h3 id="ChanType.Pos">func (*ChanType) <span>Pos</span>  </h3> <pre data-language="go">func (x *ChanType) Pos() token.Pos</pre> <h2 id="CommClause">type <span>CommClause</span>  </h2> <p>A CommClause node represents a case of a select statement. </p>
<pre data-language="go">type CommClause struct {
    Case  token.Pos // position of "case" or "default" keyword
    Comm  Stmt      // send or receive statement; nil means default case
    Colon token.Pos // position of ":"
    Body  []Stmt    // statement list; or nil
}
</pre> <h3 id="CommClause.End">func (*CommClause) <span>End</span>  </h3> <pre data-language="go">func (s *CommClause) End() token.Pos</pre> <h3 id="CommClause.Pos">func (*CommClause) <span>Pos</span>  </h3> <pre data-language="go">func (s *CommClause) Pos() token.Pos</pre> <h2 id="Comment">type <span>Comment</span>  </h2> <p>A Comment node represents a single //-style or /*-style comment. </p>
<p>The Text field contains the comment text without carriage returns (\r) that may have been present in the source. Because a comment's end position is computed using len(Text), the position reported by <a href="#Comment.End">Comment.End</a> does not match the true source end position for comments containing carriage returns. </p>
<pre data-language="go">type Comment struct {
    Slash token.Pos // position of "/" starting the comment
    Text  string    // comment text (excluding '\n' for //-style comments)
}
</pre> <h3 id="Comment.End">func (*Comment) <span>End</span>  </h3> <pre data-language="go">func (c *Comment) End() token.Pos</pre> <h3 id="Comment.Pos">func (*Comment) <span>Pos</span>  </h3> <pre data-language="go">func (c *Comment) Pos() token.Pos</pre> <h2 id="CommentGroup">type <span>CommentGroup</span>  </h2> <p>A CommentGroup represents a sequence of comments with no other tokens and no empty lines between. </p>
<pre data-language="go">type CommentGroup struct {
    List []*Comment // len(List) &gt; 0
}
</pre> <h3 id="CommentGroup.End">func (*CommentGroup) <span>End</span>  </h3> <pre data-language="go">func (g *CommentGroup) End() token.Pos</pre> <h3 id="CommentGroup.Pos">func (*CommentGroup) <span>Pos</span>  </h3> <pre data-language="go">func (g *CommentGroup) Pos() token.Pos</pre> <h3 id="CommentGroup.Text">func (*CommentGroup) <span>Text</span>  </h3> <pre data-language="go">func (g *CommentGroup) Text() string</pre> <p>Text returns the text of the comment. Comment markers (//, /*, and */), the first space of a line comment, and leading and trailing empty lines are removed. Comment directives like "//line" and "//go:noinline" are also removed. Multiple empty lines are reduced to one, and trailing space on lines is trimmed. Unless the result is empty, it is newline-terminated. </p>
<h2 id="CommentMap">type <span>CommentMap</span>  <span title="Added in Go 1.1">1.1</span> </h2> <p>A CommentMap maps an AST node to a list of comment groups associated with it. See <a href="#NewCommentMap">NewCommentMap</a> for a description of the association. </p>
<pre data-language="go">type CommentMap map[Node][]*CommentGroup</pre>    <h4 id="example_CommentMap"> <span class="text">Example</span>
</h4> <p>This example illustrates how to remove a variable declaration in a Go program while maintaining correct comment association using an ast.CommentMap. </p> <p>Code:</p> <pre class="code" data-language="go">// src is the input for which we create the AST that we
// are going to manipulate.
src := `
// This is the package comment.
package main

// This comment is associated with the hello constant.
const hello = "Hello, World!" // line comment 1

// This comment is associated with the foo variable.
var foo = hello // line comment 2

// This comment is associated with the main function.
func main() {
    fmt.Println(hello) // line comment 3
}
`

// Create the AST by parsing src.
fset := token.NewFileSet() // positions are relative to fset
f, err := parser.ParseFile(fset, "src.go", src, parser.ParseComments)
if err != nil {
    panic(err)
}

// Create an ast.CommentMap from the ast.File's comments.
// This helps keeping the association between comments
// and AST nodes.
cmap := ast.NewCommentMap(fset, f, f.Comments)

// Remove the first variable declaration from the list of declarations.
for i, decl := range f.Decls {
    if gen, ok := decl.(*ast.GenDecl); ok &amp;&amp; gen.Tok == token.VAR {
        copy(f.Decls[i:], f.Decls[i+1:])
        f.Decls = f.Decls[:len(f.Decls)-1]
        break
    }
}

// Use the comment map to filter comments that don't belong anymore
// (the comments associated with the variable declaration), and create
// the new comments list.
f.Comments = cmap.Filter(f).Comments()

// Print the modified AST.
var buf strings.Builder
if err := format.Node(&amp;buf, fset, f); err != nil {
    panic(err)
}
fmt.Printf("%s", buf.String())

</pre> <p>Output:</p> <pre class="output" data-language="go">// This is the package comment.
package main

// This comment is associated with the hello constant.
const hello = "Hello, World!" // line comment 1

// This comment is associated with the main function.
func main() {
	fmt.Println(hello) // line comment 3
}
</pre>   <h3 id="NewCommentMap">func <span>NewCommentMap</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func NewCommentMap(fset *token.FileSet, node Node, comments []*CommentGroup) CommentMap</pre> <p>NewCommentMap creates a new comment map by associating comment groups of the comments list with the nodes of the AST specified by node. </p>
<p>A comment group g is associated with a node n if: </p>
<ul> <li>g starts on the same line as n ends </li>
<li>g starts on the line immediately following n, and there is at least one empty line after g and before the next node </li>
<li>g starts before n and is not associated to the node before n via the previous rules </li>
</ul> <p>NewCommentMap tries to associate a comment group to the "largest" node possible: For instance, if the comment is a line comment trailing an assignment, the comment is associated with the entire assignment rather than just the last operand in the assignment. </p>
<h3 id="CommentMap.Comments">func (CommentMap) <span>Comments</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Comments() []*CommentGroup</pre> <p>Comments returns the list of comment groups in the comment map. The result is sorted in source order. </p>
<h3 id="CommentMap.Filter">func (CommentMap) <span>Filter</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Filter(node Node) CommentMap</pre> <p>Filter returns a new comment map consisting of only those entries of cmap for which a corresponding node exists in the AST specified by node. </p>
<h3 id="CommentMap.String">func (CommentMap) <span>String</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) String() string</pre> <h3 id="CommentMap.Update">func (CommentMap) <span>Update</span>  <span title="Added in Go 1.1">1.1</span> </h3> <pre data-language="go">func (cmap CommentMap) Update(old, new Node) Node</pre> <p>Update replaces an old node in the comment map with the new node and returns the new node. Comments that were associated with the old node are associated with the new node. </p>
<h2 id="CompositeLit">type <span>CompositeLit</span>  </h2> <p>A CompositeLit node represents a composite literal. </p>
<pre data-language="go">type CompositeLit struct {
    Type       Expr      // literal type; or nil
    Lbrace     token.Pos // position of "{"
    Elts       []Expr    // list of composite elements; or nil
    Rbrace     token.Pos // position of "}"
    Incomplete bool      // true if (source) expressions are missing in the Elts list; added in Go 1.11
}
</pre> <h3 id="CompositeLit.End">func (*CompositeLit) <span>End</span>  </h3> <pre data-language="go">func (x *CompositeLit) End() token.Pos</pre> <h3 id="CompositeLit.Pos">func (*CompositeLit) <span>Pos</span>  </h3> <pre data-language="go">func (x *CompositeLit) Pos() token.Pos</pre> <h2 id="Decl">type <span>Decl</span>  </h2> <p>All declaration nodes implement the Decl interface. </p>
<pre data-language="go">type Decl interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="DeclStmt">type <span>DeclStmt</span>  </h2> <p>A DeclStmt node represents a declaration in a statement list. </p>
<pre data-language="go">type DeclStmt struct {
    Decl Decl // *GenDecl with CONST, TYPE, or VAR token
}
</pre> <h3 id="DeclStmt.End">func (*DeclStmt) <span>End</span>  </h3> <pre data-language="go">func (s *DeclStmt) End() token.Pos</pre> <h3 id="DeclStmt.Pos">func (*DeclStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *DeclStmt) Pos() token.Pos</pre> <h2 id="DeferStmt">type <span>DeferStmt</span>  </h2> <p>A DeferStmt node represents a defer statement. </p>
<pre data-language="go">type DeferStmt struct {
    Defer token.Pos // position of "defer" keyword
    Call  *CallExpr
}
</pre> <h3 id="DeferStmt.End">func (*DeferStmt) <span>End</span>  </h3> <pre data-language="go">func (s *DeferStmt) End() token.Pos</pre> <h3 id="DeferStmt.Pos">func (*DeferStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *DeferStmt) Pos() token.Pos</pre> <h2 id="Ellipsis">type <span>Ellipsis</span>  </h2> <p>An Ellipsis node stands for the "..." type in a parameter list or the "..." length in an array type. </p>
<pre data-language="go">type Ellipsis struct {
    Ellipsis token.Pos // position of "..."
    Elt      Expr      // ellipsis element type (parameter lists only); or nil
}
</pre> <h3 id="Ellipsis.End">func (*Ellipsis) <span>End</span>  </h3> <pre data-language="go">func (x *Ellipsis) End() token.Pos</pre> <h3 id="Ellipsis.Pos">func (*Ellipsis) <span>Pos</span>  </h3> <pre data-language="go">func (x *Ellipsis) Pos() token.Pos</pre> <h2 id="EmptyStmt">type <span>EmptyStmt</span>  </h2> <p>An EmptyStmt node represents an empty statement. The "position" of the empty statement is the position of the immediately following (explicit or implicit) semicolon. </p>
<pre data-language="go">type EmptyStmt struct {
    Semicolon token.Pos // position of following ";"
    Implicit  bool      // if set, ";" was omitted in the source; added in Go 1.5
}
</pre> <h3 id="EmptyStmt.End">func (*EmptyStmt) <span>End</span>  </h3> <pre data-language="go">func (s *EmptyStmt) End() token.Pos</pre> <h3 id="EmptyStmt.Pos">func (*EmptyStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *EmptyStmt) Pos() token.Pos</pre> <h2 id="Expr">type <span>Expr</span>  </h2> <p>All expression nodes implement the Expr interface. </p>
<pre data-language="go">type Expr interface {
    Node
    // contains filtered or unexported methods
}</pre> <h3 id="Unparen">func <span>Unparen</span>  <span title="Added in Go 1.22">1.22</span> </h3> <pre data-language="go">func Unparen(e Expr) Expr</pre> <p>Unparen returns the expression with any enclosing parentheses removed. </p>
<h2 id="ExprStmt">type <span>ExprStmt</span>  </h2> <p>An ExprStmt node represents a (stand-alone) expression in a statement list. </p>
<pre data-language="go">type ExprStmt struct {
    X Expr // expression
}
</pre> <h3 id="ExprStmt.End">func (*ExprStmt) <span>End</span>  </h3> <pre data-language="go">func (s *ExprStmt) End() token.Pos</pre> <h3 id="ExprStmt.Pos">func (*ExprStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *ExprStmt) Pos() token.Pos</pre> <h2 id="Field">type <span>Field</span>  </h2> <p>A Field represents a Field declaration list in a struct type, a method list in an interface type, or a parameter/result declaration in a signature. [Field.Names] is nil for unnamed parameters (parameter lists which only contain types) and embedded struct fields. In the latter case, the field name is the type name. </p>
<pre data-language="go">type Field struct {
    Doc     *CommentGroup // associated documentation; or nil
    Names   []*Ident      // field/method/(type) parameter names; or nil
    Type    Expr          // field/method/parameter type; or nil
    Tag     *BasicLit     // field tag; or nil
    Comment *CommentGroup // line comments; or nil
}
</pre> <h3 id="Field.End">func (*Field) <span>End</span>  </h3> <pre data-language="go">func (f *Field) End() token.Pos</pre> <h3 id="Field.Pos">func (*Field) <span>Pos</span>  </h3> <pre data-language="go">func (f *Field) Pos() token.Pos</pre> <h2 id="FieldFilter">type <span>FieldFilter</span>  </h2> <p>A FieldFilter may be provided to <a href="#Fprint">Fprint</a> to control the output. </p>
<pre data-language="go">type FieldFilter func(name string, value reflect.Value) bool</pre> <h2 id="FieldList">type <span>FieldList</span>  </h2> <p>A FieldList represents a list of Fields, enclosed by parentheses, curly braces, or square brackets. </p>
<pre data-language="go">type FieldList struct {
    Opening token.Pos // position of opening parenthesis/brace/bracket, if any
    List    []*Field  // field list; or nil
    Closing token.Pos // position of closing parenthesis/brace/bracket, if any
}
</pre> <h3 id="FieldList.End">func (*FieldList) <span>End</span>  </h3> <pre data-language="go">func (f *FieldList) End() token.Pos</pre> <h3 id="FieldList.NumFields">func (*FieldList) <span>NumFields</span>  </h3> <pre data-language="go">func (f *FieldList) NumFields() int</pre> <p>NumFields returns the number of parameters or struct fields represented by a <a href="#FieldList">FieldList</a>. </p>
<h3 id="FieldList.Pos">func (*FieldList) <span>Pos</span>  </h3> <pre data-language="go">func (f *FieldList) Pos() token.Pos</pre> <h2 id="File">type <span>File</span>  </h2> <p>A File node represents a Go source file. </p>
<p>The Comments list contains all comments in the source file in order of appearance, including the comments that are pointed to from other nodes via Doc and Comment fields. </p>
<p>For correct printing of source code containing comments (using packages go/format and go/printer), special care must be taken to update comments when a File's syntax tree is modified: For printing, comments are interspersed between tokens based on their position. If syntax tree nodes are removed or moved, relevant comments in their vicinity must also be removed (from the [File.Comments] list) or moved accordingly (by updating their positions). A <a href="#CommentMap">CommentMap</a> may be used to facilitate some of these operations. </p>
<p>Whether and how a comment is associated with a node depends on the interpretation of the syntax tree by the manipulating program: except for Doc and <a href="#Comment">Comment</a> comments directly associated with nodes, the remaining comments are "free-floating" (see also issues <a href="https://go.dev/issue/18593">#18593</a>, <a href="https://go.dev/issue/20744">#20744</a>). </p>
<pre data-language="go">type File struct {
    Doc     *CommentGroup // associated documentation; or nil
    Package token.Pos     // position of "package" keyword
    Name    *Ident        // package name
    Decls   []Decl        // top-level declarations; or nil

    FileStart, FileEnd token.Pos       // start and end of entire file; added in Go 1.20
    Scope              *Scope          // package scope (this file only). Deprecated: see Object
    Imports            []*ImportSpec   // imports in this file
    Unresolved         []*Ident        // unresolved identifiers in this file. Deprecated: see Object
    Comments           []*CommentGroup // list of all comments in the source file
    GoVersion          string          // minimum Go version required by //go:build or // +build directives; added in Go 1.21
}
</pre> <h3 id="MergePackageFiles">func <span>MergePackageFiles</span>  </h3> <pre data-language="go">func MergePackageFiles(pkg *Package, mode MergeMode) *File</pre> <p>MergePackageFiles creates a file AST by merging the ASTs of the files belonging to a package. The mode flags control merging behavior. </p>
<h3 id="File.End">func (*File) <span>End</span>  </h3> <pre data-language="go">func (f *File) End() token.Pos</pre> <p>End returns the end of the last declaration in the file. It may be invalid, for example in an empty file. </p>
<p>(Use FileEnd for the end of the entire file. It is always valid.) </p>
<h3 id="File.Pos">func (*File) <span>Pos</span>  </h3> <pre data-language="go">func (f *File) Pos() token.Pos</pre> <p>Pos returns the position of the package declaration. It may be invalid, for example in an empty file. </p>
<p>(Use FileStart for the start of the entire file. It is always valid.) </p>
<h2 id="Filter">type <span>Filter</span>  </h2> <pre data-language="go">type Filter func(string) bool</pre> <h2 id="ForStmt">type <span>ForStmt</span>  </h2> <p>A ForStmt represents a for statement. </p>
<pre data-language="go">type ForStmt struct {
    For  token.Pos // position of "for" keyword
    Init Stmt      // initialization statement; or nil
    Cond Expr      // condition; or nil
    Post Stmt      // post iteration statement; or nil
    Body *BlockStmt
}
</pre> <h3 id="ForStmt.End">func (*ForStmt) <span>End</span>  </h3> <pre data-language="go">func (s *ForStmt) End() token.Pos</pre> <h3 id="ForStmt.Pos">func (*ForStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *ForStmt) Pos() token.Pos</pre> <h2 id="FuncDecl">type <span>FuncDecl</span>  </h2> <p>A FuncDecl node represents a function declaration. </p>
<pre data-language="go">type FuncDecl struct {
    Doc  *CommentGroup // associated documentation; or nil
    Recv *FieldList    // receiver (methods); or nil (functions)
    Name *Ident        // function/method name
    Type *FuncType     // function signature: type and value parameters, results, and position of "func" keyword
    Body *BlockStmt    // function body; or nil for external (non-Go) function
}
</pre> <h3 id="FuncDecl.End">func (*FuncDecl) <span>End</span>  </h3> <pre data-language="go">func (d *FuncDecl) End() token.Pos</pre> <h3 id="FuncDecl.Pos">func (*FuncDecl) <span>Pos</span>  </h3> <pre data-language="go">func (d *FuncDecl) Pos() token.Pos</pre> <h2 id="FuncLit">type <span>FuncLit</span>  </h2> <p>A FuncLit node represents a function literal. </p>
<pre data-language="go">type FuncLit struct {
    Type *FuncType  // function type
    Body *BlockStmt // function body
}
</pre> <h3 id="FuncLit.End">func (*FuncLit) <span>End</span>  </h3> <pre data-language="go">func (x *FuncLit) End() token.Pos</pre> <h3 id="FuncLit.Pos">func (*FuncLit) <span>Pos</span>  </h3> <pre data-language="go">func (x *FuncLit) Pos() token.Pos</pre> <h2 id="FuncType">type <span>FuncType</span>  </h2> <p>A FuncType node represents a function type. </p>
<pre data-language="go">type FuncType struct {
    Func       token.Pos  // position of "func" keyword (token.NoPos if there is no "func")
    TypeParams *FieldList // type parameters; or nil; added in Go 1.18
    Params     *FieldList // (incoming) parameters; non-nil
    Results    *FieldList // (outgoing) results; or nil
}
</pre> <h3 id="FuncType.End">func (*FuncType) <span>End</span>  </h3> <pre data-language="go">func (x *FuncType) End() token.Pos</pre> <h3 id="FuncType.Pos">func (*FuncType) <span>Pos</span>  </h3> <pre data-language="go">func (x *FuncType) Pos() token.Pos</pre> <h2 id="GenDecl">type <span>GenDecl</span>  </h2> <p>A GenDecl node (generic declaration node) represents an import, constant, type or variable declaration. A valid Lparen position (Lparen.IsValid()) indicates a parenthesized declaration. </p>
<p>Relationship between Tok value and Specs element type: </p>
<pre data-language="go">token.IMPORT  *ImportSpec
token.CONST   *ValueSpec
token.TYPE    *TypeSpec
token.VAR     *ValueSpec
</pre> <pre data-language="go">type GenDecl struct {
    Doc    *CommentGroup // associated documentation; or nil
    TokPos token.Pos     // position of Tok
    Tok    token.Token   // IMPORT, CONST, TYPE, or VAR
    Lparen token.Pos     // position of '(', if any
    Specs  []Spec
    Rparen token.Pos // position of ')', if any
}
</pre> <h3 id="GenDecl.End">func (*GenDecl) <span>End</span>  </h3> <pre data-language="go">func (d *GenDecl) End() token.Pos</pre> <h3 id="GenDecl.Pos">func (*GenDecl) <span>Pos</span>  </h3> <pre data-language="go">func (d *GenDecl) Pos() token.Pos</pre> <h2 id="GoStmt">type <span>GoStmt</span>  </h2> <p>A GoStmt node represents a go statement. </p>
<pre data-language="go">type GoStmt struct {
    Go   token.Pos // position of "go" keyword
    Call *CallExpr
}
</pre> <h3 id="GoStmt.End">func (*GoStmt) <span>End</span>  </h3> <pre data-language="go">func (s *GoStmt) End() token.Pos</pre> <h3 id="GoStmt.Pos">func (*GoStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *GoStmt) Pos() token.Pos</pre> <h2 id="Ident">type <span>Ident</span>  </h2> <p>An Ident node represents an identifier. </p>
<pre data-language="go">type Ident struct {
    NamePos token.Pos // identifier position
    Name    string    // identifier name
    Obj     *Object   // denoted object, or nil. Deprecated: see Object.
}
</pre> <h3 id="NewIdent">func <span>NewIdent</span>  </h3> <pre data-language="go">func NewIdent(name string) *Ident</pre> <p>NewIdent creates a new <a href="#Ident">Ident</a> without position. Useful for ASTs generated by code other than the Go parser. </p>
<h3 id="Ident.End">func (*Ident) <span>End</span>  </h3> <pre data-language="go">func (x *Ident) End() token.Pos</pre> <h3 id="Ident.IsExported">func (*Ident) <span>IsExported</span>  </h3> <pre data-language="go">func (id *Ident) IsExported() bool</pre> <p>IsExported reports whether id starts with an upper-case letter. </p>
<h3 id="Ident.Pos">func (*Ident) <span>Pos</span>  </h3> <pre data-language="go">func (x *Ident) Pos() token.Pos</pre> <h3 id="Ident.String">func (*Ident) <span>String</span>  </h3> <pre data-language="go">func (id *Ident) String() string</pre> <h2 id="IfStmt">type <span>IfStmt</span>  </h2> <p>An IfStmt node represents an if statement. </p>
<pre data-language="go">type IfStmt struct {
    If   token.Pos // position of "if" keyword
    Init Stmt      // initialization statement; or nil
    Cond Expr      // condition
    Body *BlockStmt
    Else Stmt // else branch; or nil
}
</pre> <h3 id="IfStmt.End">func (*IfStmt) <span>End</span>  </h3> <pre data-language="go">func (s *IfStmt) End() token.Pos</pre> <h3 id="IfStmt.Pos">func (*IfStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *IfStmt) Pos() token.Pos</pre> <h2 id="ImportSpec">type <span>ImportSpec</span>  </h2> <p>An ImportSpec node represents a single package import. </p>
<pre data-language="go">type ImportSpec struct {
    Doc     *CommentGroup // associated documentation; or nil
    Name    *Ident        // local package name (including "."); or nil
    Path    *BasicLit     // import path
    Comment *CommentGroup // line comments; or nil
    EndPos  token.Pos     // end of spec (overrides Path.Pos if nonzero)
}
</pre> <h3 id="ImportSpec.End">func (*ImportSpec) <span>End</span>  </h3> <pre data-language="go">func (s *ImportSpec) End() token.Pos</pre> <h3 id="ImportSpec.Pos">func (*ImportSpec) <span>Pos</span>  </h3> <pre data-language="go">func (s *ImportSpec) Pos() token.Pos</pre> <h2 id="Importer">type <span>Importer</span>  </h2> <p>An Importer resolves import paths to package Objects. The imports map records the packages already imported, indexed by package id (canonical import path). An Importer must determine the canonical import path and check the map to see if it is already present in the imports map. If so, the Importer can return the map entry. Otherwise, the Importer should load the package data for the given path into a new *<a href="#Object">Object</a> (pkg), record pkg in the imports map, and then return pkg. </p>
<p>Deprecated: use the type checker <span>go/types</span> instead; see <a href="#Object">Object</a>. </p>
<pre data-language="go">type Importer func(imports map[string]*Object, path string) (pkg *Object, err error)</pre> <h2 id="IncDecStmt">type <span>IncDecStmt</span>  </h2> <p>An IncDecStmt node represents an increment or decrement statement. </p>
<pre data-language="go">type IncDecStmt struct {
    X      Expr
    TokPos token.Pos   // position of Tok
    Tok    token.Token // INC or DEC
}
</pre> <h3 id="IncDecStmt.End">func (*IncDecStmt) <span>End</span>  </h3> <pre data-language="go">func (s *IncDecStmt) End() token.Pos</pre> <h3 id="IncDecStmt.Pos">func (*IncDecStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *IncDecStmt) Pos() token.Pos</pre> <h2 id="IndexExpr">type <span>IndexExpr</span>  </h2> <p>An IndexExpr node represents an expression followed by an index. </p>
<pre data-language="go">type IndexExpr struct {
    X      Expr      // expression
    Lbrack token.Pos // position of "["
    Index  Expr      // index expression
    Rbrack token.Pos // position of "]"
}
</pre> <h3 id="IndexExpr.End">func (*IndexExpr) <span>End</span>  </h3> <pre data-language="go">func (x *IndexExpr) End() token.Pos</pre> <h3 id="IndexExpr.Pos">func (*IndexExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *IndexExpr) Pos() token.Pos</pre> <h2 id="IndexListExpr">type <span>IndexListExpr</span>  <span title="Added in Go 1.18">1.18</span> </h2> <p>An IndexListExpr node represents an expression followed by multiple indices. </p>
<pre data-language="go">type IndexListExpr struct {
    X       Expr      // expression
    Lbrack  token.Pos // position of "["
    Indices []Expr    // index expressions
    Rbrack  token.Pos // position of "]"
}
</pre> <h3 id="IndexListExpr.End">func (*IndexListExpr) <span>End</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (x *IndexListExpr) End() token.Pos</pre> <h3 id="IndexListExpr.Pos">func (*IndexListExpr) <span>Pos</span>  <span title="Added in Go 1.18">1.18</span> </h3> <pre data-language="go">func (x *IndexListExpr) Pos() token.Pos</pre> <h2 id="InterfaceType">type <span>InterfaceType</span>  </h2> <p>An InterfaceType node represents an interface type. </p>
<pre data-language="go">type InterfaceType struct {
    Interface  token.Pos  // position of "interface" keyword
    Methods    *FieldList // list of embedded interfaces, methods, or types
    Incomplete bool       // true if (source) methods or types are missing in the Methods list
}
</pre> <h3 id="InterfaceType.End">func (*InterfaceType) <span>End</span>  </h3> <pre data-language="go">func (x *InterfaceType) End() token.Pos</pre> <h3 id="InterfaceType.Pos">func (*InterfaceType) <span>Pos</span>  </h3> <pre data-language="go">func (x *InterfaceType) Pos() token.Pos</pre> <h2 id="KeyValueExpr">type <span>KeyValueExpr</span>  </h2> <p>A KeyValueExpr node represents (key : value) pairs in composite literals. </p>
<pre data-language="go">type KeyValueExpr struct {
    Key   Expr
    Colon token.Pos // position of ":"
    Value Expr
}
</pre> <h3 id="KeyValueExpr.End">func (*KeyValueExpr) <span>End</span>  </h3> <pre data-language="go">func (x *KeyValueExpr) End() token.Pos</pre> <h3 id="KeyValueExpr.Pos">func (*KeyValueExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *KeyValueExpr) Pos() token.Pos</pre> <h2 id="LabeledStmt">type <span>LabeledStmt</span>  </h2> <p>A LabeledStmt node represents a labeled statement. </p>
<pre data-language="go">type LabeledStmt struct {
    Label *Ident
    Colon token.Pos // position of ":"
    Stmt  Stmt
}
</pre> <h3 id="LabeledStmt.End">func (*LabeledStmt) <span>End</span>  </h3> <pre data-language="go">func (s *LabeledStmt) End() token.Pos</pre> <h3 id="LabeledStmt.Pos">func (*LabeledStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *LabeledStmt) Pos() token.Pos</pre> <h2 id="MapType">type <span>MapType</span>  </h2> <p>A MapType node represents a map type. </p>
<pre data-language="go">type MapType struct {
    Map   token.Pos // position of "map" keyword
    Key   Expr
    Value Expr
}
</pre> <h3 id="MapType.End">func (*MapType) <span>End</span>  </h3> <pre data-language="go">func (x *MapType) End() token.Pos</pre> <h3 id="MapType.Pos">func (*MapType) <span>Pos</span>  </h3> <pre data-language="go">func (x *MapType) Pos() token.Pos</pre> <h2 id="MergeMode">type <span>MergeMode</span>  </h2> <p>The MergeMode flags control the behavior of <a href="#MergePackageFiles">MergePackageFiles</a>. </p>
<pre data-language="go">type MergeMode uint</pre> <pre data-language="go">const (
    // If set, duplicate function declarations are excluded.
    FilterFuncDuplicates MergeMode = 1 &lt;&lt; iota
    // If set, comments that are not associated with a specific
    // AST node (as Doc or Comment) are excluded.
    FilterUnassociatedComments
    // If set, duplicate import declarations are excluded.
    FilterImportDuplicates
)</pre> <h2 id="Node">type <span>Node</span>  </h2> <p>All node types implement the Node interface. </p>
<pre data-language="go">type Node interface {
    Pos() token.Pos // position of first character belonging to the node
    End() token.Pos // position of first character immediately after the node
}</pre> <h2 id="ObjKind">type <span>ObjKind</span>  </h2> <p>ObjKind describes what an <a href="#Object">Object</a> represents. </p>
<pre data-language="go">type ObjKind int</pre> <p>The list of possible <a href="#Object">Object</a> kinds. </p>
<pre data-language="go">const (
    Bad ObjKind = iota // for error handling
    Pkg                // package
    Con                // constant
    Typ                // type
    Var                // variable
    Fun                // function or method
    Lbl                // label
)</pre> <h3 id="ObjKind.String">func (ObjKind) <span>String</span>  </h3> <pre data-language="go">func (kind ObjKind) String() string</pre> <h2 id="Object">type <span>Object</span>  </h2> <p>An Object describes a named language entity such as a package, constant, type, variable, function (incl. methods), or label. </p>
<p>The Data fields contains object-specific data: </p>
<pre data-language="go">Kind    Data type         Data value
Pkg     *Scope            package scope
Con     int               iota for the respective declaration
</pre> <p>Deprecated: The relationship between Idents and Objects cannot be correctly computed without type information. For example, the expression T{K: 0} may denote a struct, map, slice, or array literal, depending on the type of T. If T is a struct, then K refers to a field of T, whereas for the other types it refers to a value in the environment. </p>
<p>New programs should set the [parser.SkipObjectResolution] parser flag to disable syntactic object resolution (which also saves CPU and memory), and instead use the type checker <span>go/types</span> if object resolution is desired. See the Defs, Uses, and Implicits fields of the [types.Info] struct for details. </p>
<pre data-language="go">type Object struct {
    Kind ObjKind
    Name string // declared name
    Decl any    // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil
    Data any    // object-specific data; or nil
    Type any    // placeholder for type information; may be nil
}
</pre> <h3 id="NewObj">func <span>NewObj</span>  </h3> <pre data-language="go">func NewObj(kind ObjKind, name string) *Object</pre> <p>NewObj creates a new object of a given kind and name. </p>
<h3 id="Object.Pos">func (*Object) <span>Pos</span>  </h3> <pre data-language="go">func (obj *Object) Pos() token.Pos</pre> <p>Pos computes the source position of the declaration of an object name. The result may be an invalid position if it cannot be computed (obj.Decl may be nil or not correct). </p>
<h2 id="Package">type <span>Package</span>  </h2> <p>A Package node represents a set of source files collectively building a Go package. </p>
<p>Deprecated: use the type checker <span>go/types</span> instead; see <a href="#Object">Object</a>. </p>
<pre data-language="go">type Package struct {
    Name    string             // package name
    Scope   *Scope             // package scope across all files
    Imports map[string]*Object // map of package id -&gt; package object
    Files   map[string]*File   // Go source files by filename
}
</pre> <h3 id="NewPackage">func <span>NewPackage</span>  </h3> <pre data-language="go">func NewPackage(fset *token.FileSet, files map[string]*File, importer Importer, universe *Scope) (*Package, error)</pre> <p>NewPackage creates a new <a href="#Package">Package</a> node from a set of <a href="#File">File</a> nodes. It resolves unresolved identifiers across files and updates each file's Unresolved list accordingly. If a non-nil importer and universe scope are provided, they are used to resolve identifiers not declared in any of the package files. Any remaining unresolved identifiers are reported as undeclared. If the files belong to different packages, one package name is selected and files with different package names are reported and then ignored. The result is a package node and a <span>scanner.ErrorList</span> if there were errors. </p>
<p>Deprecated: use the type checker <span>go/types</span> instead; see <a href="#Object">Object</a>. </p>
<h3 id="Package.End">func (*Package) <span>End</span>  </h3> <pre data-language="go">func (p *Package) End() token.Pos</pre> <h3 id="Package.Pos">func (*Package) <span>Pos</span>  </h3> <pre data-language="go">func (p *Package) Pos() token.Pos</pre> <h2 id="ParenExpr">type <span>ParenExpr</span>  </h2> <p>A ParenExpr node represents a parenthesized expression. </p>
<pre data-language="go">type ParenExpr struct {
    Lparen token.Pos // position of "("
    X      Expr      // parenthesized expression
    Rparen token.Pos // position of ")"
}
</pre> <h3 id="ParenExpr.End">func (*ParenExpr) <span>End</span>  </h3> <pre data-language="go">func (x *ParenExpr) End() token.Pos</pre> <h3 id="ParenExpr.Pos">func (*ParenExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *ParenExpr) Pos() token.Pos</pre> <h2 id="RangeStmt">type <span>RangeStmt</span>  </h2> <p>A RangeStmt represents a for statement with a range clause. </p>
<pre data-language="go">type RangeStmt struct {
    For        token.Pos   // position of "for" keyword
    Key, Value Expr        // Key, Value may be nil
    TokPos     token.Pos   // position of Tok; invalid if Key == nil
    Tok        token.Token // ILLEGAL if Key == nil, ASSIGN, DEFINE
    Range      token.Pos   // position of "range" keyword; added in Go 1.20
    X          Expr        // value to range over
    Body       *BlockStmt
}
</pre> <h3 id="RangeStmt.End">func (*RangeStmt) <span>End</span>  </h3> <pre data-language="go">func (s *RangeStmt) End() token.Pos</pre> <h3 id="RangeStmt.Pos">func (*RangeStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *RangeStmt) Pos() token.Pos</pre> <h2 id="ReturnStmt">type <span>ReturnStmt</span>  </h2> <p>A ReturnStmt node represents a return statement. </p>
<pre data-language="go">type ReturnStmt struct {
    Return  token.Pos // position of "return" keyword
    Results []Expr    // result expressions; or nil
}
</pre> <h3 id="ReturnStmt.End">func (*ReturnStmt) <span>End</span>  </h3> <pre data-language="go">func (s *ReturnStmt) End() token.Pos</pre> <h3 id="ReturnStmt.Pos">func (*ReturnStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *ReturnStmt) Pos() token.Pos</pre> <h2 id="Scope">type <span>Scope</span>  </h2> <p>A Scope maintains the set of named language entities declared in the scope and a link to the immediately surrounding (outer) scope. </p>
<p>Deprecated: use the type checker <span>go/types</span> instead; see <a href="#Object">Object</a>. </p>
<pre data-language="go">type Scope struct {
    Outer   *Scope
    Objects map[string]*Object
}
</pre> <h3 id="NewScope">func <span>NewScope</span>  </h3> <pre data-language="go">func NewScope(outer *Scope) *Scope</pre> <p>NewScope creates a new scope nested in the outer scope. </p>
<h3 id="Scope.Insert">func (*Scope) <span>Insert</span>  </h3> <pre data-language="go">func (s *Scope) Insert(obj *Object) (alt *Object)</pre> <p>Insert attempts to insert a named object obj into the scope s. If the scope already contains an object alt with the same name, Insert leaves the scope unchanged and returns alt. Otherwise it inserts obj and returns nil. </p>
<h3 id="Scope.Lookup">func (*Scope) <span>Lookup</span>  </h3> <pre data-language="go">func (s *Scope) Lookup(name string) *Object</pre> <p>Lookup returns the object with the given name if it is found in scope s, otherwise it returns nil. Outer scopes are ignored. </p>
<h3 id="Scope.String">func (*Scope) <span>String</span>  </h3> <pre data-language="go">func (s *Scope) String() string</pre> <p>Debugging support </p>
<h2 id="SelectStmt">type <span>SelectStmt</span>  </h2> <p>A SelectStmt node represents a select statement. </p>
<pre data-language="go">type SelectStmt struct {
    Select token.Pos  // position of "select" keyword
    Body   *BlockStmt // CommClauses only
}
</pre> <h3 id="SelectStmt.End">func (*SelectStmt) <span>End</span>  </h3> <pre data-language="go">func (s *SelectStmt) End() token.Pos</pre> <h3 id="SelectStmt.Pos">func (*SelectStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *SelectStmt) Pos() token.Pos</pre> <h2 id="SelectorExpr">type <span>SelectorExpr</span>  </h2> <p>A SelectorExpr node represents an expression followed by a selector. </p>
<pre data-language="go">type SelectorExpr struct {
    X   Expr   // expression
    Sel *Ident // field selector
}
</pre> <h3 id="SelectorExpr.End">func (*SelectorExpr) <span>End</span>  </h3> <pre data-language="go">func (x *SelectorExpr) End() token.Pos</pre> <h3 id="SelectorExpr.Pos">func (*SelectorExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *SelectorExpr) Pos() token.Pos</pre> <h2 id="SendStmt">type <span>SendStmt</span>  </h2> <p>A SendStmt node represents a send statement. </p>
<pre data-language="go">type SendStmt struct {
    Chan  Expr
    Arrow token.Pos // position of "&lt;-"
    Value Expr
}
</pre> <h3 id="SendStmt.End">func (*SendStmt) <span>End</span>  </h3> <pre data-language="go">func (s *SendStmt) End() token.Pos</pre> <h3 id="SendStmt.Pos">func (*SendStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *SendStmt) Pos() token.Pos</pre> <h2 id="SliceExpr">type <span>SliceExpr</span>  </h2> <p>A SliceExpr node represents an expression followed by slice indices. </p>
<pre data-language="go">type SliceExpr struct {
    X      Expr      // expression
    Lbrack token.Pos // position of "["
    Low    Expr      // begin of slice range; or nil
    High   Expr      // end of slice range; or nil
    Max    Expr      // maximum capacity of slice; or nil; added in Go 1.2
    Slice3 bool      // true if 3-index slice (2 colons present); added in Go 1.2
    Rbrack token.Pos // position of "]"
}
</pre> <h3 id="SliceExpr.End">func (*SliceExpr) <span>End</span>  </h3> <pre data-language="go">func (x *SliceExpr) End() token.Pos</pre> <h3 id="SliceExpr.Pos">func (*SliceExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *SliceExpr) Pos() token.Pos</pre> <h2 id="Spec">type <span>Spec</span>  </h2> <p>The Spec type stands for any of *ImportSpec, *ValueSpec, and *TypeSpec. </p>
<pre data-language="go">type Spec interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="StarExpr">type <span>StarExpr</span>  </h2> <p>A StarExpr node represents an expression of the form "*" Expression. Semantically it could be a unary "*" expression, or a pointer type. </p>
<pre data-language="go">type StarExpr struct {
    Star token.Pos // position of "*"
    X    Expr      // operand
}
</pre> <h3 id="StarExpr.End">func (*StarExpr) <span>End</span>  </h3> <pre data-language="go">func (x *StarExpr) End() token.Pos</pre> <h3 id="StarExpr.Pos">func (*StarExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *StarExpr) Pos() token.Pos</pre> <h2 id="Stmt">type <span>Stmt</span>  </h2> <p>All statement nodes implement the Stmt interface. </p>
<pre data-language="go">type Stmt interface {
    Node
    // contains filtered or unexported methods
}</pre> <h2 id="StructType">type <span>StructType</span>  </h2> <p>A StructType node represents a struct type. </p>
<pre data-language="go">type StructType struct {
    Struct     token.Pos  // position of "struct" keyword
    Fields     *FieldList // list of field declarations
    Incomplete bool       // true if (source) fields are missing in the Fields list
}
</pre> <h3 id="StructType.End">func (*StructType) <span>End</span>  </h3> <pre data-language="go">func (x *StructType) End() token.Pos</pre> <h3 id="StructType.Pos">func (*StructType) <span>Pos</span>  </h3> <pre data-language="go">func (x *StructType) Pos() token.Pos</pre> <h2 id="SwitchStmt">type <span>SwitchStmt</span>  </h2> <p>A SwitchStmt node represents an expression switch statement. </p>
<pre data-language="go">type SwitchStmt struct {
    Switch token.Pos  // position of "switch" keyword
    Init   Stmt       // initialization statement; or nil
    Tag    Expr       // tag expression; or nil
    Body   *BlockStmt // CaseClauses only
}
</pre> <h3 id="SwitchStmt.End">func (*SwitchStmt) <span>End</span>  </h3> <pre data-language="go">func (s *SwitchStmt) End() token.Pos</pre> <h3 id="SwitchStmt.Pos">func (*SwitchStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *SwitchStmt) Pos() token.Pos</pre> <h2 id="TypeAssertExpr">type <span>TypeAssertExpr</span>  </h2> <p>A TypeAssertExpr node represents an expression followed by a type assertion. </p>
<pre data-language="go">type TypeAssertExpr struct {
    X      Expr      // expression
    Lparen token.Pos // position of "("; added in Go 1.2
    Type   Expr      // asserted type; nil means type switch X.(type)
    Rparen token.Pos // position of ")"; added in Go 1.2
}
</pre> <h3 id="TypeAssertExpr.End">func (*TypeAssertExpr) <span>End</span>  </h3> <pre data-language="go">func (x *TypeAssertExpr) End() token.Pos</pre> <h3 id="TypeAssertExpr.Pos">func (*TypeAssertExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *TypeAssertExpr) Pos() token.Pos</pre> <h2 id="TypeSpec">type <span>TypeSpec</span>  </h2> <p>A TypeSpec node represents a type declaration (TypeSpec production). </p>
<pre data-language="go">type TypeSpec struct {
    Doc        *CommentGroup // associated documentation; or nil
    Name       *Ident        // type name
    TypeParams *FieldList    // type parameters; or nil; added in Go 1.18
    Assign     token.Pos     // position of '=', if any; added in Go 1.9
    Type       Expr          // *Ident, *ParenExpr, *SelectorExpr, *StarExpr, or any of the *XxxTypes
    Comment    *CommentGroup // line comments; or nil
}
</pre> <h3 id="TypeSpec.End">func (*TypeSpec) <span>End</span>  </h3> <pre data-language="go">func (s *TypeSpec) End() token.Pos</pre> <h3 id="TypeSpec.Pos">func (*TypeSpec) <span>Pos</span>  </h3> <pre data-language="go">func (s *TypeSpec) Pos() token.Pos</pre> <h2 id="TypeSwitchStmt">type <span>TypeSwitchStmt</span>  </h2> <p>A TypeSwitchStmt node represents a type switch statement. </p>
<pre data-language="go">type TypeSwitchStmt struct {
    Switch token.Pos  // position of "switch" keyword
    Init   Stmt       // initialization statement; or nil
    Assign Stmt       // x := y.(type) or y.(type)
    Body   *BlockStmt // CaseClauses only
}
</pre> <h3 id="TypeSwitchStmt.End">func (*TypeSwitchStmt) <span>End</span>  </h3> <pre data-language="go">func (s *TypeSwitchStmt) End() token.Pos</pre> <h3 id="TypeSwitchStmt.Pos">func (*TypeSwitchStmt) <span>Pos</span>  </h3> <pre data-language="go">func (s *TypeSwitchStmt) Pos() token.Pos</pre> <h2 id="UnaryExpr">type <span>UnaryExpr</span>  </h2> <p>A UnaryExpr node represents a unary expression. Unary "*" expressions are represented via StarExpr nodes. </p>
<pre data-language="go">type UnaryExpr struct {
    OpPos token.Pos   // position of Op
    Op    token.Token // operator
    X     Expr        // operand
}
</pre> <h3 id="UnaryExpr.End">func (*UnaryExpr) <span>End</span>  </h3> <pre data-language="go">func (x *UnaryExpr) End() token.Pos</pre> <h3 id="UnaryExpr.Pos">func (*UnaryExpr) <span>Pos</span>  </h3> <pre data-language="go">func (x *UnaryExpr) Pos() token.Pos</pre> <h2 id="ValueSpec">type <span>ValueSpec</span>  </h2> <p>A ValueSpec node represents a constant or variable declaration (ConstSpec or VarSpec production). </p>
<pre data-language="go">type ValueSpec struct {
    Doc     *CommentGroup // associated documentation; or nil
    Names   []*Ident      // value names (len(Names) &gt; 0)
    Type    Expr          // value type; or nil
    Values  []Expr        // initial values; or nil
    Comment *CommentGroup // line comments; or nil
}
</pre> <h3 id="ValueSpec.End">func (*ValueSpec) <span>End</span>  </h3> <pre data-language="go">func (s *ValueSpec) End() token.Pos</pre> <h3 id="ValueSpec.Pos">func (*ValueSpec) <span>Pos</span>  </h3> <pre data-language="go">func (s *ValueSpec) Pos() token.Pos</pre> <h2 id="Visitor">type <span>Visitor</span>  </h2> <p>A Visitor's Visit method is invoked for each node encountered by <a href="#Walk">Walk</a>. If the result visitor w is not nil, <a href="#Walk">Walk</a> visits each of the children of node with the visitor w, followed by a call of w.Visit(nil). </p>
<pre data-language="go">type Visitor interface {
    Visit(node Node) (w Visitor)
}</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/go/ast/" class="_attribution-link">http://golang.org/pkg/go/ast/</a>
  </p>
</div>
