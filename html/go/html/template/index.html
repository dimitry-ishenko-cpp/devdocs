<h1> Package template  </h1>     <ul id="short-nav">
<li><code>import "html/template"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package template (html/template) implements data-driven templates for generating HTML output safe against code injection. It provides the same interface as <span>text/template</span> and should be used instead of <span>text/template</span> whenever the output is HTML. </p>
<p>The documentation here focuses on the security features of the package. For information about how to program the templates themselves, see the documentation for <span>text/template</span>. </p>
<h3 id="hdr-Introduction">Introduction</h3> <p>This package wraps <span>text/template</span> so you can share its template API to parse and execute HTML templates safely. </p>
<pre data-language="go">tmpl, err := template.New("name").Parse(...)
// Error checking elided
err = tmpl.Execute(out, data)
</pre> <p>If successful, tmpl will now be injection-safe. Otherwise, err is an error defined in the docs for ErrorCode. </p>
<p>HTML templates treat data values as plain text which should be encoded so they can be safely embedded in an HTML document. The escaping is contextual, so actions can appear within JavaScript, CSS, and URI contexts. </p>
<p>The security model used by this package assumes that template authors are trusted, while Execute's data parameter is not. More details are provided below. </p>
<p>Example </p>
<pre data-language="go">import "text/template"
...
t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
err = t.ExecuteTemplate(out, "T", "&lt;script&gt;alert('you have been pwned')&lt;/script&gt;")
</pre> <p>produces </p>
<pre data-language="go">Hello, &lt;script&gt;alert('you have been pwned')&lt;/script&gt;!
</pre> <p>but the contextual autoescaping in html/template </p>
<pre data-language="go">import "html/template"
...
t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
err = t.ExecuteTemplate(out, "T", "&lt;script&gt;alert('you have been pwned')&lt;/script&gt;")
</pre> <p>produces safe, escaped HTML output </p>
<pre data-language="go">Hello, &amp;lt;script&amp;gt;alert(&amp;#39;you have been pwned&amp;#39;)&amp;lt;/script&amp;gt;!
</pre> <h3 id="hdr-Contexts">Contexts</h3> <p>This package understands HTML, CSS, JavaScript, and URIs. It adds sanitizing functions to each simple action pipeline, so given the excerpt </p>
<pre data-language="go">&lt;a href="/search?q={{.}}.html"&gt;{{.}}&lt;/a&gt;
</pre> <p>At parse time each {{.}} is overwritten to add escaping functions as necessary. In this case it becomes </p>
<pre data-language="go">&lt;a href="/search?q={{. | urlescaper | attrescaper}}.html"&gt;{{. | htmlescaper}}&lt;/a&gt;
</pre> <p>where urlescaper, attrescaper, and htmlescaper are aliases for internal escaping functions. </p>
<p>For these internal escaping functions, if an action pipeline evaluates to a nil interface value, it is treated as though it were an empty string. </p>
<h3 id="hdr-Namespaced_and_data__attributes">Namespaced and data- attributes</h3> <p>Attributes with a namespace are treated as if they had no namespace. Given the excerpt </p>
<pre data-language="go">&lt;a my:href="{{.}}.html"&gt;&lt;/a&gt;
</pre> <p>At parse time the attribute will be treated as if it were just "href". So at parse time the template becomes: </p>
<pre data-language="go">&lt;a my:href="{{. | urlescaper | attrescaper}}.html"&gt;&lt;/a&gt;
</pre> <p>Similarly to attributes with namespaces, attributes with a "data-" prefix are treated as if they had no "data-" prefix. So given </p>
<pre data-language="go">&lt;a data-href="{{.}}.html"&gt;&lt;/a&gt;
</pre> <p>At parse time this becomes </p>
<pre data-language="go">&lt;a data-href="{{. | urlescaper | attrescaper}}.html"&gt;&lt;/a&gt;
</pre> <p>If an attribute has both a namespace and a "data-" prefix, only the namespace will be removed when determining the context. For example </p>
<pre data-language="go">&lt;a my:data-href="{{.}}.html"&gt;&lt;/a&gt;
</pre> <p>This is handled as if "my:data-href" was just "data-href" and not "href" as it would be if the "data-" prefix were to be ignored too. Thus at parse time this becomes just </p>
<pre data-language="go">&lt;a my:data-href="{{. | attrescaper}}.html"&gt;&lt;/a&gt;
</pre> <p>As a special case, attributes with the namespace "xmlns" are always treated as containing URLs. Given the excerpts </p>
<pre data-language="go">&lt;a xmlns:title="{{.}}"&gt;&lt;/a&gt;
&lt;a xmlns:href="{{.}}.html"&gt;&lt;/a&gt;
&lt;a xmlns:onclick="{{.}}"&gt;&lt;/a&gt;
</pre> <p>At parse time they become: </p>
<pre data-language="go">&lt;a xmlns:title="{{. | urlescaper | attrescaper}}"&gt;&lt;/a&gt;
&lt;a xmlns:href="{{. | urlescaper | attrescaper}}.html"&gt;&lt;/a&gt;
&lt;a xmlns:onclick="{{. | urlescaper | attrescaper}}"&gt;&lt;/a&gt;
</pre> <h3 id="hdr-Errors">Errors</h3> <p>See the documentation of ErrorCode for details. </p>
<h3 id="hdr-A_fuller_picture">A fuller picture</h3> <p>The rest of this package comment may be skipped on first reading; it includes details necessary to understand escaping contexts and error messages. Most users will not need to understand these details. </p>
<h3 id="hdr-Contexts">Contexts</h3> <p>Assuming {{.}} is `O'Reilly: How are &lt;i&gt;you&lt;/i&gt;?`, the table below shows how {{.}} appears when used in the context to the left. </p>
<pre data-language="go">Context                          {{.}} After
{{.}}                            O'Reilly: How are &amp;lt;i&amp;gt;you&amp;lt;/i&amp;gt;?
&lt;a title='{{.}}'&gt;                O&amp;#39;Reilly: How are you?
&lt;a href="/{{.}}.html"&gt;                O&amp;#39;Reilly: How are %3ci%3eyou%3c/i%3e?
&lt;a href="?q={{.}}.html"&gt;              O&amp;#39;Reilly%3a%20How%20are%3ci%3e...%3f
&lt;a onx='f("{{.}}")'&gt;             O\x27Reilly: How are \x3ci\x3eyou...?
&lt;a onx='f({{.}})'&gt;               "O\x27Reilly: How are \x3ci\x3eyou...?"
&lt;a onx='pattern = /{{.}}/;'&gt;     O\x27Reilly: How are \x3ci\x3eyou...\x3f
</pre> <p>If used in an unsafe context, then the value might be filtered out: </p>
<pre data-language="go">Context                          {{.}} After
&lt;a href="{{.}}.html"&gt;                 #ZgotmplZ
</pre> <p>since "O'Reilly:" is not an allowed protocol like "http:". </p>
<p>If {{.}} is the innocuous word, `left`, then it can appear more widely, </p>
<pre data-language="go">Context                              {{.}} After
{{.}}                                left
&lt;a title='{{.}}'&gt;                    left
&lt;a href='{{.}}'&gt;                     left
&lt;a href='/{{.}}'&gt;                    left
&lt;a href='?dir={{.}}'&gt;                left
&lt;a style="border-{{.}}: 4px"&gt;        left
&lt;a style="align: {{.}}"&gt;             left
&lt;a style="background: '{{.}}'&gt;       left
&lt;a style="background: url('{{.}}')&gt;  left
&lt;style&gt;p.{{.}} {color:red}&lt;/style&gt;   left
</pre> <p>Non-string values can be used in JavaScript contexts. If {{.}} is </p>
<pre data-language="go">struct{A,B string}{ "foo", "bar" }
</pre> <p>in the escaped template </p>
<pre data-language="go">&lt;script&gt;var pair = {{.}};&lt;/script&gt;
</pre> <p>then the template output is </p>
<pre data-language="go">&lt;script&gt;var pair = {"A": "foo", "B": "bar"};&lt;/script&gt;
</pre> <p>See package json to understand how non-string content is marshaled for embedding in JavaScript contexts. </p>
<h3 id="hdr-Typed_Strings">Typed Strings</h3> <p>By default, this package assumes that all pipelines produce a plain text string. It adds escaping pipeline stages necessary to correctly and safely embed that plain text string in the appropriate context. </p>
<p>When a data value is not plain text, you can make sure it is not over-escaped by marking it with its type. </p>
<p>Types HTML, JS, URL, and others from content.go can carry safe content that is exempted from escaping. </p>
<p>The template </p>
<pre data-language="go">Hello, {{.}}!
</pre> <p>can be invoked with </p>
<pre data-language="go">tmpl.Execute(out, template.HTML(`&lt;b&gt;World&lt;/b&gt;`))
</pre> <p>to produce </p>
<pre data-language="go">Hello, &lt;b&gt;World&lt;/b&gt;!
</pre> <p>instead of the </p>
<pre data-language="go">Hello, &amp;lt;b&amp;gt;World&amp;lt;b&amp;gt;!
</pre> <p>that would have been produced if {{.}} was a regular string. </p>
<h3 id="hdr-Security_Model">Security Model</h3> <p><a href="https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition">https://rawgit.com/mikesamuel/sanitized-jquery-templates/trunk/safetemplate.html#problem_definition</a> defines "safe" as used by this package. </p>
<p>This package assumes that template authors are trusted, that Execute's data parameter is not, and seeks to preserve the properties below in the face of untrusted data: </p>
<p>Structure Preservation Property: "... when a template author writes an HTML tag in a safe templating language, the browser will interpret the corresponding portion of the output as a tag regardless of the values of untrusted data, and similarly for other structures such as attribute boundaries and JS and CSS string boundaries." </p>
<p>Code Effect Property: "... only code specified by the template author should run as a result of injecting the template output into a page and all code specified by the template author should run as a result of the same." </p>
<p>Least Surprise Property: "A developer (or code reviewer) familiar with HTML, CSS, and JavaScript, who knows that contextual autoescaping happens should be able to look at a {{.}} and correctly infer what sanitization happens." </p>
<p>As a consequence of the Least Surprise Property, template actions within an ECMAScript 6 template literal are disabled by default. Handling string interpolation within these literals is rather complex resulting in no clear safe way to support it. To re-enable template actions within ECMAScript 6 template literals, use the GODEBUG=jstmpllitinterp=1 environment variable. </p>   <h4 id="example_"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">const tpl = `
&lt;!DOCTYPE html&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;title&gt;{{.Title}}&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        {{range .Items}}&lt;div&gt;{{ . }}&lt;/div&gt;{{else}}&lt;div&gt;&lt;strong&gt;no rows&lt;/strong&gt;&lt;/div&gt;{{end}}
    &lt;/body&gt;
&lt;/html&gt;`

check := func(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
t, err := template.New("webpage").Parse(tpl)
check(err)

data := struct {
    Title string
    Items []string
}{
    Title: "My page",
    Items: []string{
        "My photos",
        "My blog",
    },
}

err = t.Execute(os.Stdout, data)
check(err)

noItems := struct {
    Title string
    Items []string
}{
    Title: "My another page",
    Items: []string{},
}

err = t.Execute(os.Stdout, noItems)
check(err)

</pre> <p>Output:</p> <pre class="output" data-language="go">&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;My page&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;My photos&lt;/div&gt;&lt;div&gt;My blog&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
	&lt;head&gt;
		&lt;meta charset="UTF-8"&gt;
		&lt;title&gt;My another page&lt;/title&gt;
	&lt;/head&gt;
	&lt;body&gt;
		&lt;div&gt;&lt;strong&gt;no rows&lt;/strong&gt;&lt;/div&gt;
	&lt;/body&gt;
&lt;/html&gt;
</pre>      <h4 id="example__autoescaping"> <span class="text">Example (Autoescaping)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">check := func(err error) {
    if err != nil {
        log.Fatal(err)
    }
}
t, err := template.New("foo").Parse(`{{define "T"}}Hello, {{.}}!{{end}}`)
check(err)
err = t.ExecuteTemplate(os.Stdout, "T", "&lt;script&gt;alert('you have been pwned')&lt;/script&gt;")
check(err)
</pre> <p>Output:</p> <pre class="output" data-language="go">Hello, &amp;lt;script&amp;gt;alert(&amp;#39;you have been pwned&amp;#39;)&amp;lt;/script&amp;gt;!
</pre>      <h4 id="example__escape"> <span class="text">Example (Escape)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">const s = `"Fran &amp; Freddie's Diner" &lt;tasty@example.com&gt;`
v := []any{`"Fran &amp; Freddie's Diner"`, ' ', `&lt;tasty@example.com&gt;`}

fmt.Println(template.HTMLEscapeString(s))
template.HTMLEscape(os.Stdout, []byte(s))
fmt.Fprintln(os.Stdout, "")
fmt.Println(template.HTMLEscaper(v...))

fmt.Println(template.JSEscapeString(s))
template.JSEscape(os.Stdout, []byte(s))
fmt.Fprintln(os.Stdout, "")
fmt.Println(template.JSEscaper(v...))

fmt.Println(template.URLQueryEscaper(v...))

</pre> <p>Output:</p> <pre class="output" data-language="go">&amp;#34;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;#34; &amp;lt;tasty@example.com&amp;gt;
&amp;#34;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;#34; &amp;lt;tasty@example.com&amp;gt;
&amp;#34;Fran &amp;amp; Freddie&amp;#39;s Diner&amp;#34;32&amp;lt;tasty@example.com&amp;gt;
\"Fran \u0026 Freddie\'s Diner\" \u003Ctasty@example.com\u003E
\"Fran \u0026 Freddie\'s Diner\" \u003Ctasty@example.com\u003E
\"Fran \u0026 Freddie\'s Diner\"32\u003Ctasty@example.com\u003E
%22Fran+%26+Freddie%27s+Diner%2232%3Ctasty%40example.com%3E
</pre>        <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#HTMLEscape">func HTMLEscape(w io.Writer, b []byte)</a></li>
<li><a href="#HTMLEscapeString">func HTMLEscapeString(s string) string</a></li>
<li><a href="#HTMLEscaper">func HTMLEscaper(args ...any) string</a></li>
<li><a href="#IsTrue">func IsTrue(val any) (truth, ok bool)</a></li>
<li><a href="#JSEscape">func JSEscape(w io.Writer, b []byte)</a></li>
<li><a href="#JSEscapeString">func JSEscapeString(s string) string</a></li>
<li><a href="#JSEscaper">func JSEscaper(args ...any) string</a></li>
<li><a href="#URLQueryEscaper">func URLQueryEscaper(args ...any) string</a></li>
<li><a href="#CSS">type CSS</a></li>
<li><a href="#Error">type Error</a></li>
<li> <a href="#Error.Error">func (e *Error) Error() string</a>
</li>
<li><a href="#ErrorCode">type ErrorCode</a></li>
<li><a href="#FuncMap">type FuncMap</a></li>
<li><a href="#HTML">type HTML</a></li>
<li><a href="#HTMLAttr">type HTMLAttr</a></li>
<li><a href="#JS">type JS</a></li>
<li><a href="#JSStr">type JSStr</a></li>
<li><a href="#Srcset">type Srcset</a></li>
<li><a href="#Template">type Template</a></li>
<li> <a href="#Must">func Must(t *Template, err error) *Template</a>
</li>
<li> <a href="#New">func New(name string) *Template</a>
</li>
<li> <a href="#ParseFS">func ParseFS(fs fs.FS, patterns ...string) (*Template, error)</a>
</li>
<li> <a href="#ParseFiles">func ParseFiles(filenames ...string) (*Template, error)</a>
</li>
<li> <a href="#ParseGlob">func ParseGlob(pattern string) (*Template, error)</a>
</li>
<li> <a href="#Template.AddParseTree">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</a>
</li>
<li> <a href="#Template.Clone">func (t *Template) Clone() (*Template, error)</a>
</li>
<li> <a href="#Template.DefinedTemplates">func (t *Template) DefinedTemplates() string</a>
</li>
<li> <a href="#Template.Delims">func (t *Template) Delims(left, right string) *Template</a>
</li>
<li> <a href="#Template.Execute">func (t *Template) Execute(wr io.Writer, data any) error</a>
</li>
<li> <a href="#Template.ExecuteTemplate">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error</a>
</li>
<li> <a href="#Template.Funcs">func (t *Template) Funcs(funcMap FuncMap) *Template</a>
</li>
<li> <a href="#Template.Lookup">func (t *Template) Lookup(name string) *Template</a>
</li>
<li> <a href="#Template.Name">func (t *Template) Name() string</a>
</li>
<li> <a href="#Template.New">func (t *Template) New(name string) *Template</a>
</li>
<li> <a href="#Template.Option">func (t *Template) Option(opt ...string) *Template</a>
</li>
<li> <a href="#Template.Parse">func (t *Template) Parse(text string) (*Template, error)</a>
</li>
<li> <a href="#Template.ParseFS">func (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error)</a>
</li>
<li> <a href="#Template.ParseFiles">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</a>
</li>
<li> <a href="#Template.ParseGlob">func (t *Template) ParseGlob(pattern string) (*Template, error)</a>
</li>
<li> <a href="#Template.Templates">func (t *Template) Templates() []*Template</a>
</li>
<li><a href="#URL">type URL</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_">Package</a></dd> <dd><a class="exampleLink" href="#example_Template_Delims">Template.Delims</a></dd> <dd><a class="exampleLink" href="#example_Template_block">Template (Block)</a></dd> <dd><a class="exampleLink" href="#example_Template_glob">Template (Glob)</a></dd> <dd><a class="exampleLink" href="#example_Template_helpers">Template (Helpers)</a></dd> <dd><a class="exampleLink" href="#example_Template_parsefiles">Template (Parsefiles)</a></dd> <dd><a class="exampleLink" href="#example_Template_share">Template (Share)</a></dd> <dd><a class="exampleLink" href="#example__autoescaping">Package (Autoescaping)</a></dd> <dd><a class="exampleLink" href="#example__escape">Package (Escape)</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>attr.go</span> <span>attr_string.go</span> <span>content.go</span> <span>context.go</span> <span>css.go</span> <span>delim_string.go</span> <span>doc.go</span> <span>element_string.go</span> <span>error.go</span> <span>escape.go</span> <span>html.go</span> <span>js.go</span> <span>jsctx_string.go</span> <span>state_string.go</span> <span>template.go</span> <span>transition.go</span> <span>url.go</span> <span>urlpart_string.go</span>  </p>   <h2 id="HTMLEscape">func <span>HTMLEscape</span>  </h2> <pre data-language="go">func HTMLEscape(w io.Writer, b []byte)</pre> <p>HTMLEscape writes to w the escaped HTML equivalent of the plain text data b. </p>
<h2 id="HTMLEscapeString">func <span>HTMLEscapeString</span>  </h2> <pre data-language="go">func HTMLEscapeString(s string) string</pre> <p>HTMLEscapeString returns the escaped HTML equivalent of the plain text data s. </p>
<h2 id="HTMLEscaper">func <span>HTMLEscaper</span>  </h2> <pre data-language="go">func HTMLEscaper(args ...any) string</pre> <p>HTMLEscaper returns the escaped HTML equivalent of the textual representation of its arguments. </p>
<h2 id="IsTrue">func <span>IsTrue</span>  <span title="Added in Go 1.6">1.6</span> </h2> <pre data-language="go">func IsTrue(val any) (truth, ok bool)</pre> <p>IsTrue reports whether the value is 'true', in the sense of not the zero of its type, and whether the value has a meaningful truth value. This is the definition of truth used by if and other such actions. </p>
<h2 id="JSEscape">func <span>JSEscape</span>  </h2> <pre data-language="go">func JSEscape(w io.Writer, b []byte)</pre> <p>JSEscape writes to w the escaped JavaScript equivalent of the plain text data b. </p>
<h2 id="JSEscapeString">func <span>JSEscapeString</span>  </h2> <pre data-language="go">func JSEscapeString(s string) string</pre> <p>JSEscapeString returns the escaped JavaScript equivalent of the plain text data s. </p>
<h2 id="JSEscaper">func <span>JSEscaper</span>  </h2> <pre data-language="go">func JSEscaper(args ...any) string</pre> <p>JSEscaper returns the escaped JavaScript equivalent of the textual representation of its arguments. </p>
<h2 id="URLQueryEscaper">func <span>URLQueryEscaper</span>  </h2> <pre data-language="go">func URLQueryEscaper(args ...any) string</pre> <p>URLQueryEscaper returns the escaped value of the textual representation of its arguments in a form suitable for embedding in a URL query. </p>
<h2 id="CSS">type <span>CSS</span>  </h2> <p>CSS encapsulates known safe content that matches any of: </p>
<ol> <li>The CSS3 stylesheet production, such as `p { color: purple }`. </li>
<li>The CSS3 rule production, such as `a[href=~"https:"].foo#bar`. </li>
<li>CSS3 declaration productions, such as `color: red; margin: 2px`. </li>
<li>The CSS3 value production, such as `rgba(0, 0, 255, 127)`. </li>
</ol> <p>See <a href="https://www.w3.org/TR/css3-syntax/#parsing">https://www.w3.org/TR/css3-syntax/#parsing</a> and <a href="https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style">https://web.archive.org/web/20090211114933/http://w3.org/TR/css3-syntax#style</a> </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type CSS string</pre> <h2 id="Error">type <span>Error</span>  </h2> <p>Error describes a problem encountered during template Escaping. </p>
<pre data-language="go">type Error struct {
    // ErrorCode describes the kind of error.
    ErrorCode ErrorCode
    // Node is the node that caused the problem, if known.
    // If not nil, it overrides Name and Line.
    Node parse.Node // Go 1.4
    // Name is the name of the template in which the error was encountered.
    Name string
    // Line is the line number of the error in the template source or 0.
    Line int
    // Description is a human-readable description of the problem.
    Description string
}
</pre> <h3 id="Error.Error">func (*Error) <span>Error</span>  </h3> <pre data-language="go">func (e *Error) Error() string</pre> <h2 id="ErrorCode">type <span>ErrorCode</span>  </h2> <p>ErrorCode is a code for a kind of error. </p>
<pre data-language="go">type ErrorCode int</pre> <p>We define codes for each error that manifests while escaping templates, but escaped templates may also fail at runtime. </p>
<p>Output: "ZgotmplZ" Example: </p>
<pre data-language="go">&lt;img src="{{.X}}"&gt;
where {{.X}} evaluates to `javascript:...`
</pre> <p>Discussion: </p>
<pre data-language="go">"ZgotmplZ" is a special value that indicates that unsafe content reached a
CSS or URL context at runtime. The output of the example will be
  &lt;img src="#ZgotmplZ"&gt;
If the data comes from a trusted source, use content types to exempt it
from filtering: URL(`javascript:...`).
</pre> <pre data-language="go">const (
    // OK indicates the lack of an error.
    OK ErrorCode = iota

    // ErrAmbigContext: "... appears in an ambiguous context within a URL"
    // Example:
    //   &lt;a href="
    //      {{if .C}}
    //        /path/
    //      {{else}}
    //        /search?q=
    //      {{end}}
    //      {{.X}}
    //   .html"&gt;
    // Discussion:
    //   {{.X}} is in an ambiguous URL context since, depending on {{.C}},
    //  it may be either a URL suffix or a query parameter.
    //   Moving {{.X}} into the condition removes the ambiguity:
    //   &lt;a href="{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}.html"&gt;
    ErrAmbigContext

    // ErrBadHTML: "expected space, attr name, or end of tag, but got ...",
    //   "... in unquoted attr", "... in attribute name"
    // Example:
    //   &lt;a href = /search?q=foo&gt;
    //   &lt;href=foo&gt;
    //   &lt;form na&lt;e=...&gt;
    //   &lt;option selected&lt;
    // Discussion:
    //   This is often due to a typo in an HTML element, but some runes
    //   are banned in tag names, attribute names, and unquoted attribute
    //   values because they can tickle parser ambiguities.
    //   Quoting all attributes is the best policy.
    ErrBadHTML

    // ErrBranchEnd: "{{if}} branches end in different contexts"
    // Example:
    //   {{if .C}}&lt;a href="{{end}}{{.X}}
    // Discussion:
    //   Package html/template statically examines each path through an
    //   {{if}}, {{range}}, or {{with}} to escape any following pipelines.
    //   The example is ambiguous since {{.X}} might be an HTML text node,
    //   or a URL prefix in an HTML attribute. The context of {{.X}} is
    //   used to figure out how to escape it, but that context depends on
    //   the run-time value of {{.C}} which is not statically known.
    //
    //   The problem is usually something like missing quotes or angle
    //   brackets, or can be avoided by refactoring to put the two contexts
    //   into different branches of an if, range or with. If the problem
    //   is in a {{range}} over a collection that should never be empty,
    //   adding a dummy {{else}} can help.
    ErrBranchEnd

    // ErrEndContext: .html"... ends in a non-text context: ..."
    // Examples:
    //   &lt;div
    //   &lt;div title="no close quote&gt;
    //   &lt;script&gt;f()
    // Discussion:
    //   Executed templates should produce a DocumentFragment of HTML.
    //   Templates that end without closing tags will trigger this error.
    //   Templates that should not be used in an HTML context or that
    //   produce incomplete Fragments should not be executed directly.
    //
    //   {{define "main"}} &lt;script&gt;{{template "helper"}}&lt;/script&gt; {{end}}
    //   {{define "helper"}} document.write(' &lt;div title=" ') {{end}}
    //
    //   "helper" does not produce a valid document fragment, so should
    //   not be Executed directly.
    ErrEndContext

    // ErrNoSuchTemplate: "no such template ..."
    // Examples:
    //   {{define "main"}}&lt;div {{template "attrs"}}&gt;{{end}}
    //   {{define "attrs"}}href="{{.URL}}.html"{{end}}
    // Discussion:
    //   Package html/template looks through template calls to compute the
    //   context.
    //   Here the {{.URL}} in "attrs" must be treated as a URL when called
    //   from "main", but you will get this error if "attrs" is not defined
    //   when "main" is parsed.
    ErrNoSuchTemplate

    // ErrOutputContext: "cannot compute output context for template ..."
    // Examples:
    //   {{define "t"}}{{if .T}}{{template "t" .T}}{{end}}{{.H}}",{{end}}
    // Discussion:
    //   A recursive template does not end in the same context in which it
    //   starts, and a reliable output context cannot be computed.
    //   Look for typos in the named template.
    //   If the template should not be called in the named start context,
    //   look for calls to that template in unexpected contexts.
    //   Maybe refactor recursive templates to not be recursive.
    ErrOutputContext

    // ErrPartialCharset: "unfinished JS regexp charset in ..."
    // Example:
    //     &lt;script&gt;var pattern = /foo[{{.Chars}}]/&lt;/script&gt;
    // Discussion:
    //   Package html/template does not support interpolation into regular
    //   expression literal character sets.
    ErrPartialCharset

    // ErrPartialEscape: "unfinished escape sequence in ..."
    // Example:
    //   &lt;script&gt;alert("\{{.X}}")&lt;/script&gt;
    // Discussion:
    //   Package html/template does not support actions following a
    //   backslash.
    //   This is usually an error and there are better solutions; for
    //   example
    //     &lt;script&gt;alert("{{.X}}")&lt;/script&gt;
    //   should work, and if {{.X}} is a partial escape sequence such as
    //   "xA0", mark the whole sequence as safe content: JSStr(`\xA0`)
    ErrPartialEscape

    // ErrRangeLoopReentry: "on range loop re-entry: ..."
    // Example:
    //   &lt;script&gt;var x = [{{range .}}'{{.}},{{end}}]&lt;/script&gt;
    // Discussion:
    //   If an iteration through a range would cause it to end in a
    //   different context than an earlier pass, there is no single context.
    //   In the example, there is missing a quote, so it is not clear
    //   whether {{.}} is meant to be inside a JS string or in a JS value
    //   context. The second iteration would produce something like
    //
    //     &lt;script&gt;var x = ['firstValue,'secondValue]&lt;/script&gt;
    ErrRangeLoopReentry

    // ErrSlashAmbig: '/' could start a division or regexp.
    // Example:
    //   &lt;script&gt;
    //     {{if .C}}var x = 1{{end}}
    //     /-{{.N}}/i.test(x) ? doThis : doThat();
    //   &lt;/script&gt;
    // Discussion:
    //   The example above could produce `var x = 1/-2/i.test(s)...`
    //   in which the first '/' is a mathematical division operator or it
    //   could produce `/-2/i.test(s)` in which the first '/' starts a
    //   regexp literal.
    //   Look for missing semicolons inside branches, and maybe add
    //   parentheses to make it clear which interpretation you intend.
    ErrSlashAmbig

    // ErrPredefinedEscaper: "predefined escaper ... disallowed in template"
    // Example:
    //   &lt;div class={{. | html}}&gt;Hello&lt;div&gt;
    // Discussion:
    //   Package html/template already contextually escapes all pipelines to
    //   produce HTML output safe against code injection. Manually escaping
    //   pipeline output using the predefined escapers "html" or "urlquery" is
    //   unnecessary, and may affect the correctness or safety of the escaped
    //   pipeline output in Go 1.8 and earlier.
    //
    //   In most cases, such as the given example, this error can be resolved by
    //   simply removing the predefined escaper from the pipeline and letting the
    //   contextual autoescaper handle the escaping of the pipeline. In other
    //   instances, where the predefined escaper occurs in the middle of a
    //   pipeline where subsequent commands expect escaped input, e.g.
    //     {{.X | html | makeALink}}
    //   where makeALink does
    //     return `&lt;a href="`+input+`.html"&gt;link&lt;/a&gt;`
    //   consider refactoring the surrounding template to make use of the
    //   contextual autoescaper, i.e.
    //     &lt;a href="{{.X}}.html"&gt;link&lt;/a&gt;
    //
    //   To ease migration to Go 1.9 and beyond, "html" and "urlquery" will
    //   continue to be allowed as the last command in a pipeline. However, if the
    //   pipeline occurs in an unquoted attribute value context, "html" is
    //   disallowed. Avoid using "html" and "urlquery" entirely in new templates.
    ErrPredefinedEscaper

    // ErrJSTemplate: "... appears in a JS template literal"
    // Example:
    //     &lt;script&gt;var tmpl = `{{.Interp}}`&lt;/script&gt;
    // Discussion:
    //   Package html/template does not support actions inside of JS template
    //   literals.
    ErrJSTemplate
)</pre> <h2 id="FuncMap">type <span>FuncMap</span>  </h2> <pre data-language="go">type FuncMap = template.FuncMap</pre> <h2 id="HTML">type <span>HTML</span>  </h2> <p>HTML encapsulates a known safe HTML document fragment. It should not be used for HTML from a third-party, or HTML with unclosed tags or comments. The outputs of a sound HTML sanitizer and a template escaped by this package are fine for use with HTML. </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type HTML string</pre> <h2 id="HTMLAttr">type <span>HTMLAttr</span>  </h2> <p>HTMLAttr encapsulates an HTML attribute from a trusted source, for example, ` dir="ltr"`. </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type HTMLAttr string</pre> <h2 id="JS">type <span>JS</span>  </h2> <p>JS encapsulates a known safe EcmaScript5 Expression, for example, `(x + y * z())`. Template authors are responsible for ensuring that typed expressions do not break the intended precedence and that there is no statement/expression ambiguity as when passing an expression like "{ foo: bar() }\n['foo']()", which is both a valid Expression and a valid Program with a very different meaning. </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<p>Using JS to include valid but untrusted JSON is not safe. A safe alternative is to parse the JSON with json.Unmarshal and then pass the resultant object into the template, where it will be converted to sanitized JSON when presented in a JavaScript context. </p>
<pre data-language="go">type JS string</pre> <h2 id="JSStr">type <span>JSStr</span>  </h2> <p>JSStr encapsulates a sequence of characters meant to be embedded between quotes in a JavaScript expression. The string must match a series of StringCharacters: </p>
<pre data-language="go">StringCharacter :: SourceCharacter but not `\` or LineTerminator
                 | EscapeSequence
</pre> <p>Note that LineContinuations are not allowed. JSStr("foo\\nbar") is fine, but JSStr("foo\\\nbar") is not. </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type JSStr string</pre> <h2 id="Srcset">type <span>Srcset</span>  <span title="Added in Go 1.10">1.10</span> </h2> <p>Srcset encapsulates a known safe srcset attribute (see <a href="https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset">https://w3c.github.io/html/semantics-embedded-content.html#element-attrdef-img-srcset</a>). </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type Srcset string</pre> <h2 id="Template">type <span>Template</span>  </h2> <p>Template is a specialized Template from "text/template" that produces a safe HTML document fragment. </p>
<pre data-language="go">type Template struct {

    // The underlying template's parse tree, updated to be HTML-safe.
    Tree *parse.Tree // Go 1.2
    // contains filtered or unexported fields
}
</pre>    <h4 id="example_Template_block"> <span class="text">Example (Block)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">const (
    master  = `Names:{{block "list" .}}{{"\n"}}{{range .}}{{println "-" .}}{{end}}{{end}}`
    overlay = `{{define "list"}} {{join . ", "}}{{end}} `
)
var (
    funcs     = template.FuncMap{"join": strings.Join}
    guardians = []string{"Gamora", "Groot", "Nebula", "Rocket", "Star-Lord"}
)
masterTmpl, err := template.New("master").Funcs(funcs).Parse(master)
if err != nil {
    log.Fatal(err)
}
overlayTmpl, err := template.Must(masterTmpl.Clone()).Parse(overlay)
if err != nil {
    log.Fatal(err)
}
if err := masterTmpl.Execute(os.Stdout, guardians); err != nil {
    log.Fatal(err)
}
if err := overlayTmpl.Execute(os.Stdout, guardians); err != nil {
    log.Fatal(err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">Names:
- Gamora
- Groot
- Nebula
- Rocket
- Star-Lord
Names: Gamora, Groot, Nebula, Rocket, Star-Lord
</pre>      <h4 id="example_Template_glob"> <span class="text">Example (Glob)</span>
</h4> <p>Here we demonstrate loading a set of templates from a directory. </p> <p>Code:</p> <pre class="code" data-language="go">// Here we create a temporary directory and populate it with our sample
// template definition files; usually the template files would already
// exist in some location known to the program.
dir := createTestDir([]templateFile{
    // T0.tmpl is a plain template file that just invokes T1.
    {"T0.tmpl", `T0 invokes T1: ({{template "T1"}})`},
    // T1.tmpl defines a template, T1 that invokes T2.
    {"T1.tmpl", `{{define "T1"}}T1 invokes T2: ({{template "T2"}}){{end}}`},
    // T2.tmpl defines a template T2.
    {"T2.tmpl", `{{define "T2"}}This is T2{{end}}`},
})
// Clean up after the test; another quirk of running as an example.
defer os.RemoveAll(dir)

// pattern is the glob pattern used to find all the template files.
pattern := filepath.Join(dir, "*.tmpl")

// Here starts the example proper.
// T0.tmpl is the first name matched, so it becomes the starting template,
// the value returned by ParseGlob.
tmpl := template.Must(template.ParseGlob(pattern))

err := tmpl.Execute(os.Stdout, nil)
if err != nil {
    log.Fatalf("template execution: %s", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">T0 invokes T1: (T1 invokes T2: (This is T2))
</pre>      <h4 id="example_Template_helpers"> <span class="text">Example (Helpers)</span>
</h4> <p>This example demonstrates one way to share some templates and use them in different contexts. In this variant we add multiple driver templates by hand to an existing bundle of templates. </p> <p>Code:</p> <pre class="code" data-language="go">// Here we create a temporary directory and populate it with our sample
// template definition files; usually the template files would already
// exist in some location known to the program.
dir := createTestDir([]templateFile{
    // T1.tmpl defines a template, T1 that invokes T2.
    {"T1.tmpl", `{{define "T1"}}T1 invokes T2: ({{template "T2"}}){{end}}`},
    // T2.tmpl defines a template T2.
    {"T2.tmpl", `{{define "T2"}}This is T2{{end}}`},
})
// Clean up after the test; another quirk of running as an example.
defer os.RemoveAll(dir)

// pattern is the glob pattern used to find all the template files.
pattern := filepath.Join(dir, "*.tmpl")

// Here starts the example proper.
// Load the helpers.
templates := template.Must(template.ParseGlob(pattern))
// Add one driver template to the bunch; we do this with an explicit template definition.
_, err := templates.Parse("{{define `driver1`}}Driver 1 calls T1: ({{template `T1`}})\n{{end}}")
if err != nil {
    log.Fatal("parsing driver1: ", err)
}
// Add another driver template.
_, err = templates.Parse("{{define `driver2`}}Driver 2 calls T2: ({{template `T2`}})\n{{end}}")
if err != nil {
    log.Fatal("parsing driver2: ", err)
}
// We load all the templates before execution. This package does not require
// that behavior but html/template's escaping does, so it's a good habit.
err = templates.ExecuteTemplate(os.Stdout, "driver1", nil)
if err != nil {
    log.Fatalf("driver1 execution: %s", err)
}
err = templates.ExecuteTemplate(os.Stdout, "driver2", nil)
if err != nil {
    log.Fatalf("driver2 execution: %s", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">Driver 1 calls T1: (T1 invokes T2: (This is T2))
Driver 2 calls T2: (This is T2)
</pre>      <h4 id="example_Template_parsefiles"> <span class="text">Example (Parsefiles)</span>
</h4> <p>Here we demonstrate loading a set of templates from files in different directories </p> <p>Code:</p> <pre class="code" data-language="go">// Here we create different temporary directories and populate them with our sample
// template definition files; usually the template files would already
// exist in some location known to the program.
dir1 := createTestDir([]templateFile{
    // T1.tmpl is a plain template file that just invokes T2.
    {"T1.tmpl", `T1 invokes T2: ({{template "T2"}})`},
})

dir2 := createTestDir([]templateFile{
    // T2.tmpl defines a template T2.
    {"T2.tmpl", `{{define "T2"}}This is T2{{end}}`},
})

// Clean up after the test; another quirk of running as an example.
defer func(dirs ...string) {
    for _, dir := range dirs {
        os.RemoveAll(dir)
    }
}(dir1, dir2)

// Here starts the example proper.
// Let's just parse only dir1/T0 and dir2/T2
paths := []string{
    filepath.Join(dir1, "T1.tmpl"),
    filepath.Join(dir2, "T2.tmpl"),
}
tmpl := template.Must(template.ParseFiles(paths...))

err := tmpl.Execute(os.Stdout, nil)
if err != nil {
    log.Fatalf("template execution: %s", err)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">T1 invokes T2: (This is T2)
</pre>      <h4 id="example_Template_share"> <span class="text">Example (Share)</span>
</h4> <p>This example demonstrates how to use one group of driver templates with distinct sets of helper templates. </p> <p>Code:</p> <pre class="code" data-language="go">// Here we create a temporary directory and populate it with our sample
// template definition files; usually the template files would already
// exist in some location known to the program.
dir := createTestDir([]templateFile{
    // T0.tmpl is a plain template file that just invokes T1.
    {"T0.tmpl", "T0 ({{.}} version) invokes T1: ({{template `T1`}})\n"},
    // T1.tmpl defines a template, T1 that invokes T2. Note T2 is not defined
    {"T1.tmpl", `{{define "T1"}}T1 invokes T2: ({{template "T2"}}){{end}}`},
})
// Clean up after the test; another quirk of running as an example.
defer os.RemoveAll(dir)

// pattern is the glob pattern used to find all the template files.
pattern := filepath.Join(dir, "*.tmpl")

// Here starts the example proper.
// Load the drivers.
drivers := template.Must(template.ParseGlob(pattern))

// We must define an implementation of the T2 template. First we clone
// the drivers, then add a definition of T2 to the template name space.

// 1. Clone the helper set to create a new name space from which to run them.
first, err := drivers.Clone()
if err != nil {
    log.Fatal("cloning helpers: ", err)
}
// 2. Define T2, version A, and parse it.
_, err = first.Parse("{{define `T2`}}T2, version A{{end}}")
if err != nil {
    log.Fatal("parsing T2: ", err)
}

// Now repeat the whole thing, using a different version of T2.
// 1. Clone the drivers.
second, err := drivers.Clone()
if err != nil {
    log.Fatal("cloning drivers: ", err)
}
// 2. Define T2, version B, and parse it.
_, err = second.Parse("{{define `T2`}}T2, version B{{end}}")
if err != nil {
    log.Fatal("parsing T2: ", err)
}

// Execute the templates in the reverse order to verify the
// first is unaffected by the second.
err = second.ExecuteTemplate(os.Stdout, "T0.tmpl", "second")
if err != nil {
    log.Fatalf("second execution: %s", err)
}
err = first.ExecuteTemplate(os.Stdout, "T0.tmpl", "first")
if err != nil {
    log.Fatalf("first: execution: %s", err)
}

</pre> <p>Output:</p> <pre class="output" data-language="go">T0 (second version) invokes T1: (T1 invokes T2: (T2, version B))
T0 (first version) invokes T1: (T1 invokes T2: (T2, version A))
</pre>   <h3 id="Must">func <span>Must</span>  </h3> <pre data-language="go">func Must(t *Template, err error) *Template</pre> <p>Must is a helper that wraps a call to a function returning (*Template, error) and panics if the error is non-nil. It is intended for use in variable initializations such as </p>
<pre data-language="go">var t = template.Must(template.New("name").Parse("html"))
</pre> <h3 id="New">func <span>New</span>  </h3> <pre data-language="go">func New(name string) *Template</pre> <p>New allocates a new HTML template with the given name. </p>
<h3 id="ParseFS">func <span>ParseFS</span>  <span title="Added in Go 1.16">1.16</span> </h3> <pre data-language="go">func ParseFS(fs fs.FS, patterns ...string) (*Template, error)</pre> <p>ParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) </p>
<h3 id="ParseFiles">func <span>ParseFiles</span>  </h3> <pre data-language="go">func ParseFiles(filenames ...string) (*Template, error)</pre> <p>ParseFiles creates a new Template and parses the template definitions from the named files. The returned template's name will have the (base) name and (parsed) contents of the first file. There must be at least one file. If an error occurs, parsing stops and the returned *Template is nil. </p>
<p>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. For instance, ParseFiles("a/foo", "b/foo") stores "b/foo" as the template named "foo", while "a/foo" is unavailable. </p>
<h3 id="ParseGlob">func <span>ParseGlob</span>  </h3> <pre data-language="go">func ParseGlob(pattern string) (*Template, error)</pre> <p>ParseGlob creates a new Template and parses the template definitions from the files identified by the pattern. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. The returned template will have the (base) name and (parsed) contents of the first file matched by the pattern. ParseGlob is equivalent to calling ParseFiles with the list of files matched by the pattern. </p>
<p>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p>
<h3 id="Template.AddParseTree">func (*Template) <span>AddParseTree</span>  </h3> <pre data-language="go">func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error)</pre> <p>AddParseTree creates a new template with the name and parse tree and associates it with t. </p>
<p>It returns an error if t or any associated template has already been executed. </p>
<h3 id="Template.Clone">func (*Template) <span>Clone</span>  </h3> <pre data-language="go">func (t *Template) Clone() (*Template, error)</pre> <p>Clone returns a duplicate of the template, including all associated templates. The actual representation is not copied, but the name space of associated templates is, so further calls to Parse in the copy will add templates to the copy but not to the original. Clone can be used to prepare common templates and use them with variant definitions for other templates by adding the variants after the clone is made. </p>
<p>It returns an error if t has already been executed. </p>
<h3 id="Template.DefinedTemplates">func (*Template) <span>DefinedTemplates</span>  <span title="Added in Go 1.6">1.6</span> </h3> <pre data-language="go">func (t *Template) DefinedTemplates() string</pre> <p>DefinedTemplates returns a string listing the defined templates, prefixed by the string "; defined templates are: ". If there are none, it returns the empty string. Used to generate an error message. </p>
<h3 id="Template.Delims">func (*Template) <span>Delims</span>  </h3> <pre data-language="go">func (t *Template) Delims(left, right string) *Template</pre> <p>Delims sets the action delimiters to the specified strings, to be used in subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template definitions will inherit the settings. An empty delimiter stands for the corresponding default: {{ or }}. The return value is the template, so calls can be chained. </p>   <h4 id="example_Template_Delims"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">const text = "&lt;&lt;.Greeting&gt;&gt; {{.Name}}"

data := struct {
    Greeting string
    Name     string
}{
    Greeting: "Hello",
    Name:     "Joe",
}

t := template.Must(template.New("tpl").Delims("&lt;&lt;", "&gt;&gt;").Parse(text))

err := t.Execute(os.Stdout, data)
if err != nil {
    log.Fatal(err)
}

</pre> <p>Output:</p> <pre class="output" data-language="go">Hello {{.Name}}
</pre>   <h3 id="Template.Execute">func (*Template) <span>Execute</span>  </h3> <pre data-language="go">func (t *Template) Execute(wr io.Writer, data any) error</pre> <p>Execute applies a parsed template to the specified data object, writing the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. </p>
<h3 id="Template.ExecuteTemplate">func (*Template) <span>ExecuteTemplate</span>  </h3> <pre data-language="go">func (t *Template) ExecuteTemplate(wr io.Writer, name string, data any) error</pre> <p>ExecuteTemplate applies the template associated with t that has the given name to the specified data object and writes the output to wr. If an error occurs executing the template or writing its output, execution stops, but partial results may already have been written to the output writer. A template may be executed safely in parallel, although if parallel executions share a Writer the output may be interleaved. </p>
<h3 id="Template.Funcs">func (*Template) <span>Funcs</span>  </h3> <pre data-language="go">func (t *Template) Funcs(funcMap FuncMap) *Template</pre> <p>Funcs adds the elements of the argument map to the template's function map. It must be called before the template is parsed. It panics if a value in the map is not a function with appropriate return type. However, it is legal to overwrite elements of the map. The return value is the template, so calls can be chained. </p>
<h3 id="Template.Lookup">func (*Template) <span>Lookup</span>  </h3> <pre data-language="go">func (t *Template) Lookup(name string) *Template</pre> <p>Lookup returns the template with the given name that is associated with t, or nil if there is no such template. </p>
<h3 id="Template.Name">func (*Template) <span>Name</span>  </h3> <pre data-language="go">func (t *Template) Name() string</pre> <p>Name returns the name of the template. </p>
<h3 id="Template.New">func (*Template) <span>New</span>  </h3> <pre data-language="go">func (t *Template) New(name string) *Template</pre> <p>New allocates a new HTML template associated with the given one and with the same delimiters. The association, which is transitive, allows one template to invoke another with a {{template}} action. </p>
<p>If a template with the given name already exists, the new HTML template will replace it. The existing template will be reset and disassociated with t. </p>
<h3 id="Template.Option">func (*Template) <span>Option</span>  <span title="Added in Go 1.5">1.5</span> </h3> <pre data-language="go">func (t *Template) Option(opt ...string) *Template</pre> <p>Option sets options for the template. Options are described by strings, either a simple string or "key=value". There can be at most one equals sign in an option string. If the option string is unrecognized or otherwise invalid, Option panics. </p>
<p>Known options: </p>
<p>missingkey: Control the behavior during execution if a map is indexed with a key that is not present in the map. </p>
<pre data-language="go">"missingkey=default" or "missingkey=invalid"
	The default behavior: Do nothing and continue execution.
	If printed, the result of the index operation is the string
	"&lt;no value&gt;".
"missingkey=zero"
	The operation returns the zero value for the map type's element.
"missingkey=error"
	Execution stops immediately with an error.
</pre> <h3 id="Template.Parse">func (*Template) <span>Parse</span>  </h3> <pre data-language="go">func (t *Template) Parse(text string) (*Template, error)</pre> <p>Parse parses text as a template body for t. Named template definitions ({{define ...}} or {{block ...}} statements) in text define additional templates associated with t and are removed from the definition of t itself. </p>
<p>Templates can be redefined in successive calls to Parse, before the first use of Execute on t or any associated template. A template definition with a body containing only white space and comments is considered empty and will not replace an existing template's body. This allows using Parse to add new named template definitions without overwriting the main template body. </p>
<h3 id="Template.ParseFS">func (*Template) <span>ParseFS</span>  <span title="Added in Go 1.16">1.16</span> </h3> <pre data-language="go">func (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error)</pre> <p>ParseFS is like ParseFiles or ParseGlob but reads from the file system fs instead of the host operating system's file system. It accepts a list of glob patterns. (Note that most file names serve as glob patterns matching only themselves.) </p>
<h3 id="Template.ParseFiles">func (*Template) <span>ParseFiles</span>  </h3> <pre data-language="go">func (t *Template) ParseFiles(filenames ...string) (*Template, error)</pre> <p>ParseFiles parses the named files and associates the resulting templates with t. If an error occurs, parsing stops and the returned template is nil; otherwise it is t. There must be at least one file. </p>
<p>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p>
<p>ParseFiles returns an error if t or any associated template has already been executed. </p>
<h3 id="Template.ParseGlob">func (*Template) <span>ParseGlob</span>  </h3> <pre data-language="go">func (t *Template) ParseGlob(pattern string) (*Template, error)</pre> <p>ParseGlob parses the template definitions in the files identified by the pattern and associates the resulting templates with t. The files are matched according to the semantics of filepath.Match, and the pattern must match at least one file. ParseGlob is equivalent to calling t.ParseFiles with the list of files matched by the pattern. </p>
<p>When parsing multiple files with the same name in different directories, the last one mentioned will be the one that results. </p>
<p>ParseGlob returns an error if t or any associated template has already been executed. </p>
<h3 id="Template.Templates">func (*Template) <span>Templates</span>  </h3> <pre data-language="go">func (t *Template) Templates() []*Template</pre> <p>Templates returns a slice of the templates associated with t, including t itself. </p>
<h2 id="URL">type <span>URL</span>  </h2> <p>URL encapsulates a known safe URL or URL substring (see RFC 3986). A URL like `javascript:checkThatFormNotEditedBeforeLeavingPage()` from a trusted source should go in the page, but by default dynamic `javascript:` URLs are filtered out since they are a frequently exploited injection vector. </p>
<p>Use of this type presents a security risk: the encapsulated content should come from a trusted source, as it will be included verbatim in the template output. </p>
<pre data-language="go">type URL string</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/html/template/" class="_attribution-link">http://golang.org/pkg/html/template/</a>
  </p>
</div>
