<h1> Package slices  </h1>     <ul id="short-nav">
<li><code>import "slices"</code></li>
<li><a href="#pkg-overview" class="overviewLink">Overview</a></li>
<li><a href="#pkg-index" class="indexLink">Index</a></li>
<li><a href="#pkg-examples" class="examplesLink">Examples</a></li>
</ul>     <h2 id="pkg-overview">Overview </h2> <p>Package slices defines various functions useful with slices of any type. </p>     <h2 id="pkg-index">Index </h2>  <ul id="manual-nav">
<li><a href="#All">func All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</a></li>
<li><a href="#AppendSeq">func AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice</a></li>
<li><a href="#Backward">func Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</a></li>
<li><a href="#BinarySearch">func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)</a></li>
<li><a href="#BinarySearchFunc">func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)</a></li>
<li><a href="#Chunk">func Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]</a></li>
<li><a href="#Clip">func Clip[S ~[]E, E any](s S) S</a></li>
<li><a href="#Clone">func Clone[S ~[]E, E any](s S) S</a></li>
<li><a href="#Collect">func Collect[E any](seq iter.Seq[E]) []E</a></li>
<li><a href="#Compact">func Compact[S ~[]E, E comparable](s S) S</a></li>
<li><a href="#CompactFunc">func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S</a></li>
<li><a href="#Compare">func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int</a></li>
<li><a href="#CompareFunc">func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int</a></li>
<li><a href="#Concat">func Concat[S ~[]E, E any](slices ...S) S</a></li>
<li><a href="#Contains">func Contains[S ~[]E, E comparable](s S, v E) bool</a></li>
<li><a href="#ContainsFunc">func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool</a></li>
<li><a href="#Delete">func Delete[S ~[]E, E any](s S, i, j int) S</a></li>
<li><a href="#DeleteFunc">func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S</a></li>
<li><a href="#Equal">func Equal[S ~[]E, E comparable](s1, s2 S) bool</a></li>
<li><a href="#EqualFunc">func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool</a></li>
<li><a href="#Grow">func Grow[S ~[]E, E any](s S, n int) S</a></li>
<li><a href="#Index">func Index[S ~[]E, E comparable](s S, v E) int</a></li>
<li><a href="#IndexFunc">func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int</a></li>
<li><a href="#Insert">func Insert[S ~[]E, E any](s S, i int, v ...E) S</a></li>
<li><a href="#IsSorted">func IsSorted[S ~[]E, E cmp.Ordered](x S) bool</a></li>
<li><a href="#IsSortedFunc">func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool</a></li>
<li><a href="#Max">func Max[S ~[]E, E cmp.Ordered](x S) E</a></li>
<li><a href="#MaxFunc">func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</a></li>
<li><a href="#Min">func Min[S ~[]E, E cmp.Ordered](x S) E</a></li>
<li><a href="#MinFunc">func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</a></li>
<li><a href="#Repeat">func Repeat[S ~[]E, E any](x S, count int) S</a></li>
<li><a href="#Replace">func Replace[S ~[]E, E any](s S, i, j int, v ...E) S</a></li>
<li><a href="#Reverse">func Reverse[S ~[]E, E any](s S)</a></li>
<li><a href="#Sort">func Sort[S ~[]E, E cmp.Ordered](x S)</a></li>
<li><a href="#SortFunc">func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</a></li>
<li><a href="#SortStableFunc">func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</a></li>
<li><a href="#Sorted">func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E</a></li>
<li><a href="#SortedFunc">func SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</a></li>
<li><a href="#SortedStableFunc">func SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</a></li>
<li><a href="#Values">func Values[Slice ~[]E, E any](s Slice) iter.Seq[E]</a></li>
</ul> <div id="pkg-examples"> <h3>Examples</h3>  <dl> <dd><a class="exampleLink" href="#example_All">All</a></dd> <dd><a class="exampleLink" href="#example_AppendSeq">AppendSeq</a></dd> <dd><a class="exampleLink" href="#example_Backward">Backward</a></dd> <dd><a class="exampleLink" href="#example_BinarySearch">BinarySearch</a></dd> <dd><a class="exampleLink" href="#example_BinarySearchFunc">BinarySearchFunc</a></dd> <dd><a class="exampleLink" href="#example_Chunk">Chunk</a></dd> <dd><a class="exampleLink" href="#example_Clip">Clip</a></dd> <dd><a class="exampleLink" href="#example_Clone">Clone</a></dd> <dd><a class="exampleLink" href="#example_Collect">Collect</a></dd> <dd><a class="exampleLink" href="#example_Compact">Compact</a></dd> <dd><a class="exampleLink" href="#example_CompactFunc">CompactFunc</a></dd> <dd><a class="exampleLink" href="#example_Compare">Compare</a></dd> <dd><a class="exampleLink" href="#example_CompareFunc">CompareFunc</a></dd> <dd><a class="exampleLink" href="#example_Concat">Concat</a></dd> <dd><a class="exampleLink" href="#example_Contains">Contains</a></dd> <dd><a class="exampleLink" href="#example_ContainsFunc">ContainsFunc</a></dd> <dd><a class="exampleLink" href="#example_Delete">Delete</a></dd> <dd><a class="exampleLink" href="#example_DeleteFunc">DeleteFunc</a></dd> <dd><a class="exampleLink" href="#example_Equal">Equal</a></dd> <dd><a class="exampleLink" href="#example_EqualFunc">EqualFunc</a></dd> <dd><a class="exampleLink" href="#example_Grow">Grow</a></dd> <dd><a class="exampleLink" href="#example_Index">Index</a></dd> <dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd> <dd><a class="exampleLink" href="#example_Insert">Insert</a></dd> <dd><a class="exampleLink" href="#example_IsSorted">IsSorted</a></dd> <dd><a class="exampleLink" href="#example_IsSortedFunc">IsSortedFunc</a></dd> <dd><a class="exampleLink" href="#example_Max">Max</a></dd> <dd><a class="exampleLink" href="#example_MaxFunc">MaxFunc</a></dd> <dd><a class="exampleLink" href="#example_Min">Min</a></dd> <dd><a class="exampleLink" href="#example_MinFunc">MinFunc</a></dd> <dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd> <dd><a class="exampleLink" href="#example_Replace">Replace</a></dd> <dd><a class="exampleLink" href="#example_Reverse">Reverse</a></dd> <dd><a class="exampleLink" href="#example_Sort">Sort</a></dd> <dd><a class="exampleLink" href="#example_SortFunc_caseInsensitive">SortFunc (CaseInsensitive)</a></dd> <dd><a class="exampleLink" href="#example_SortFunc_multiField">SortFunc (MultiField)</a></dd> <dd><a class="exampleLink" href="#example_SortStableFunc">SortStableFunc</a></dd> <dd><a class="exampleLink" href="#example_Sorted">Sorted</a></dd> <dd><a class="exampleLink" href="#example_SortedFunc">SortedFunc</a></dd> <dd><a class="exampleLink" href="#example_SortedStableFunc">SortedStableFunc</a></dd> <dd><a class="exampleLink" href="#example_Values">Values</a></dd> </dl> </div> <h3>Package files</h3> <p>  <span>iter.go</span> <span>slices.go</span> <span>sort.go</span> <span>zsortanyfunc.go</span> <span>zsortordered.go</span>  </p>   <h2 id="All">func <span>All</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</pre> <p>All returns an iterator over index-value pairs in the slice in the usual order. </p>   <h4 id="example_All"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
for i, v := range slices.All(names) {
    fmt.Println(i, ":", v)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">0 : Alice
1 : Bob
2 : Vera
</pre>   <h2 id="AppendSeq">func <span>AppendSeq</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice</pre> <p>AppendSeq appends the values from seq to the slice and returns the extended slice. </p>   <h4 id="example_AppendSeq"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := func(yield func(int) bool) {
    for i := 0; i &lt; 10; i += 2 {
        if !yield(i) {
            return
        }
    }
}

s := slices.AppendSeq([]int{1, 2}, seq)
fmt.Println(s)
</pre> <p>Output:</p> <pre class="output" data-language="go">[1 2 0 2 4 6 8]
</pre>   <h2 id="Backward">func <span>Backward</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</pre> <p>Backward returns an iterator over index-value pairs in the slice, traversing it backward with descending indices. </p>   <h4 id="example_Backward"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
for i, v := range slices.Backward(names) {
    fmt.Println(i, ":", v)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">2 : Vera
1 : Bob
0 : Alice
</pre>   <h2 id="BinarySearch">func <span>BinarySearch</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)</pre> <p>BinarySearch searches for target in a sorted slice and returns the earliest position where target is found, or the position where target would appear in the sort order; it also returns a bool saying whether the target is really found in the slice. The slice must be sorted in increasing order. </p>   <h4 id="example_BinarySearch"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
n, found := slices.BinarySearch(names, "Vera")
fmt.Println("Vera:", n, found)
n, found = slices.BinarySearch(names, "Bill")
fmt.Println("Bill:", n, found)
</pre> <p>Output:</p> <pre class="output" data-language="go">Vera: 2 true
Bill: 1 false
</pre>   <h2 id="BinarySearchFunc">func <span>BinarySearchFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)</pre> <p>BinarySearchFunc works like <a href="#BinarySearch">BinarySearch</a>, but uses a custom comparison function. The slice must be sorted in increasing order, where "increasing" is defined by cmp. cmp should return 0 if the slice element matches the target, a negative number if the slice element precedes the target, or a positive number if the slice element follows the target. cmp must implement the same ordering as the slice, such that if cmp(a, t) &lt; 0 and cmp(b, t) &gt;= 0, then a must precede b in the slice. </p>   <h4 id="example_BinarySearchFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {"Alice", 55},
    {"Bob", 24},
    {"Gopher", 13},
}
n, found := slices.BinarySearchFunc(people, Person{"Bob", 0}, func(a, b Person) int {
    return strings.Compare(a.Name, b.Name)
})
fmt.Println("Bob:", n, found)
</pre> <p>Output:</p> <pre class="output" data-language="go">Bob: 1 true
</pre>   <h2 id="Chunk">func <span>Chunk</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]</pre> <p>Chunk returns an iterator over consecutive sub-slices of up to n elements of s. All but the last sub-slice will have size n. All sub-slices are clipped to have no capacity beyond the length. If s is empty, the sequence is empty: there is no empty slice in the sequence. Chunk panics if n is less than 1. </p>   <h4 id="example_Chunk"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}

type People []Person

people := People{
    {"Gopher", 13},
    {"Alice", 20},
    {"Bob", 5},
    {"Vera", 24},
    {"Zac", 15},
}

// Chunk people into []Person 2 elements at a time.
for c := range slices.Chunk(people, 2) {
    fmt.Println(c)
}

</pre> <p>Output:</p> <pre class="output" data-language="go">[{Gopher 13} {Alice 20}]
[{Bob 5} {Vera 24}]
[{Zac 15}]
</pre>   <h2 id="Clip">func <span>Clip</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Clip[S ~[]E, E any](s S) S</pre> <p>Clip removes unused capacity from the slice, returning s[:len(s):len(s)]. </p>   <h4 id="example_Clip"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">a := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
s := a[:4:10]
clip := slices.Clip(s)
fmt.Println(cap(s))
fmt.Println(clip)
fmt.Println(len(clip))
fmt.Println(cap(clip))
</pre> <p>Output:</p> <pre class="output" data-language="go">10
[0 1 2 3]
4
4
</pre>   <h2 id="Clone">func <span>Clone</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Clone[S ~[]E, E any](s S) S</pre> <p>Clone returns a copy of the slice. The elements are copied using assignment, so this is a shallow clone. The result may have additional unused capacity. </p>   <h4 id="example_Clone"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
clone := slices.Clone(numbers)
fmt.Println(clone)
clone[2] = 10
fmt.Println(numbers)
fmt.Println(clone)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 42 -10 8]
[0 42 -10 8]
[0 42 10 8]
</pre>   <h2 id="Collect">func <span>Collect</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Collect[E any](seq iter.Seq[E]) []E</pre> <p>Collect collects values from seq into a new slice and returns it. </p>   <h4 id="example_Collect"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := func(yield func(int) bool) {
    for i := 0; i &lt; 10; i += 2 {
        if !yield(i) {
            return
        }
    }
}

s := slices.Collect(seq)
fmt.Println(s)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 2 4 6 8]
</pre>   <h2 id="Compact">func <span>Compact</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Compact[S ~[]E, E comparable](s S) S</pre> <p>Compact replaces consecutive runs of equal elements with a single copy. This is like the uniq command found on Unix. Compact modifies the contents of the slice s and returns the modified slice, which may have a smaller length. Compact zeroes the elements between the new length and the original length. </p>   <h4 id="example_Compact"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := []int{0, 1, 1, 2, 3, 5, 8}
seq = slices.Compact(seq)
fmt.Println(seq)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 1 2 3 5 8]
</pre>   <h2 id="CompactFunc">func <span>CompactFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S</pre> <p>CompactFunc is like <a href="#Compact">Compact</a> but uses an equality function to compare elements. For runs of elements that compare equal, CompactFunc keeps the first one. CompactFunc zeroes the elements between the new length and the original length. </p>   <h4 id="example_CompactFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"bob", "Bob", "alice", "Vera", "VERA"}
names = slices.CompactFunc(names, strings.EqualFold)
fmt.Println(names)
</pre> <p>Output:</p> <pre class="output" data-language="go">[bob alice Vera]
</pre>   <h2 id="Compare">func <span>Compare</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int</pre> <p>Compare compares the elements of s1 and s2, using <span>cmp.Compare</span> on each pair of elements. The elements are compared sequentially, starting at index 0, until one element is not equal to the other. The result of comparing the first non-matching elements is returned. If both slices are equal until one of them ends, the shorter slice is considered less than the longer one. The result is 0 if s1 == s2, -1 if s1 &lt; s2, and +1 if s1 &gt; s2. </p>   <h4 id="example_Compare"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
fmt.Println("Equal:", slices.Compare(names, []string{"Alice", "Bob", "Vera"}))
fmt.Println("V &lt; X:", slices.Compare(names, []string{"Alice", "Bob", "Xena"}))
fmt.Println("V &gt; C:", slices.Compare(names, []string{"Alice", "Bob", "Cat"}))
fmt.Println("3 &gt; 2:", slices.Compare(names, []string{"Alice", "Bob"}))
</pre> <p>Output:</p> <pre class="output" data-language="go">Equal: 0
V &lt; X: -1
V &gt; C: 1
3 &gt; 2: 1
</pre>   <h2 id="CompareFunc">func <span>CompareFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int</pre> <p>CompareFunc is like <a href="#Compare">Compare</a> but uses a custom comparison function on each pair of elements. The result is the first non-zero result of cmp; if cmp always returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) &lt; len(s2), and +1 if len(s1) &gt; len(s2). </p>   <h4 id="example_CompareFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 43, 8}
strings := []string{"0", "0", "8"}
result := slices.CompareFunc(numbers, strings, func(n int, s string) int {
    sn, err := strconv.Atoi(s)
    if err != nil {
        return 1
    }
    return cmp.Compare(n, sn)
})
fmt.Println(result)
</pre> <p>Output:</p> <pre class="output" data-language="go">1
</pre>   <h2 id="Concat">func <span>Concat</span>  <span title="Added in Go 1.22">1.22</span> </h2> <pre data-language="go">func Concat[S ~[]E, E any](slices ...S) S</pre> <p>Concat returns a new slice concatenating the passed in slices. </p>   <h4 id="example_Concat"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">s1 := []int{0, 1, 2, 3}
s2 := []int{4, 5, 6}
concat := slices.Concat(s1, s2)
fmt.Println(concat)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 1 2 3 4 5 6]
</pre>   <h2 id="Contains">func <span>Contains</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Contains[S ~[]E, E comparable](s S, v E) bool</pre> <p>Contains reports whether v is present in s. </p>   <h4 id="example_Contains"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 1, 2, 3}
fmt.Println(slices.Contains(numbers, 2))
fmt.Println(slices.Contains(numbers, 4))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
</pre>   <h2 id="ContainsFunc">func <span>ContainsFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool</pre> <p>ContainsFunc reports whether at least one element e of s satisfies f(e). </p>   <h4 id="example_ContainsFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
hasNegative := slices.ContainsFunc(numbers, func(n int) bool {
    return n &lt; 0
})
fmt.Println("Has a negative:", hasNegative)
hasOdd := slices.ContainsFunc(numbers, func(n int) bool {
    return n%2 != 0
})
fmt.Println("Has an odd number:", hasOdd)
</pre> <p>Output:</p> <pre class="output" data-language="go">Has a negative: true
Has an odd number: false
</pre>   <h2 id="Delete">func <span>Delete</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Delete[S ~[]E, E any](s S, i, j int) S</pre> <p>Delete removes the elements s[i:j] from s, returning the modified slice. Delete panics if j &gt; len(s) or s[i:j] is not a valid slice of s. Delete is O(len(s)-i), so if many items must be deleted, it is better to make a single call deleting them all together than to delete one at a time. Delete zeroes the elements s[len(s)-(j-i):len(s)]. </p>   <h4 id="example_Delete"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">letters := []string{"a", "b", "c", "d", "e"}
letters = slices.Delete(letters, 1, 4)
fmt.Println(letters)
</pre> <p>Output:</p> <pre class="output" data-language="go">[a e]
</pre>   <h2 id="DeleteFunc">func <span>DeleteFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S</pre> <p>DeleteFunc removes any elements from s for which del returns true, returning the modified slice. DeleteFunc zeroes the elements between the new length and the original length. </p>   <h4 id="example_DeleteFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := []int{0, 1, 1, 2, 3, 5, 8}
seq = slices.DeleteFunc(seq, func(n int) bool {
    return n%2 != 0 // delete the odd numbers
})
fmt.Println(seq)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 2 8]
</pre>   <h2 id="Equal">func <span>Equal</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Equal[S ~[]E, E comparable](s1, s2 S) bool</pre> <p>Equal reports whether two slices are equal: the same length and all elements equal. If the lengths are different, Equal returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first unequal pair. Empty and nil slices are considered equal. Floating point NaNs are not considered equal. </p>   <h4 id="example_Equal"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, 8}
fmt.Println(slices.Equal(numbers, []int{0, 42, 8}))
fmt.Println(slices.Equal(numbers, []int{10}))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
</pre>   <h2 id="EqualFunc">func <span>EqualFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool</pre> <p>EqualFunc reports whether two slices are equal using an equality function on each pair of elements. If the lengths are different, EqualFunc returns false. Otherwise, the elements are compared in increasing index order, and the comparison stops at the first index for which eq returns false. </p>   <h4 id="example_EqualFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, 8}
strings := []string{"000", "42", "0o10"}
equal := slices.EqualFunc(numbers, strings, func(n int, s string) bool {
    sn, err := strconv.ParseInt(s, 0, 64)
    if err != nil {
        return false
    }
    return n == int(sn)
})
fmt.Println(equal)
</pre> <p>Output:</p> <pre class="output" data-language="go">true
</pre>   <h2 id="Grow">func <span>Grow</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Grow[S ~[]E, E any](s S, n int) S</pre> <p>Grow increases the slice's capacity, if necessary, to guarantee space for another n elements. After Grow(n), at least n elements can be appended to the slice without another allocation. If n is negative or too large to allocate the memory, Grow panics. </p>   <h4 id="example_Grow"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
grow := slices.Grow(numbers, 2)
fmt.Println(cap(numbers))
fmt.Println(grow)
fmt.Println(len(grow))
fmt.Println(cap(grow))
</pre> <p>Output:</p> <pre class="output" data-language="go">4
[0 42 -10 8]
4
8
</pre>   <h2 id="Index">func <span>Index</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Index[S ~[]E, E comparable](s S, v E) int</pre> <p>Index returns the index of the first occurrence of v in s, or -1 if not present. </p>   <h4 id="example_Index"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, 8}
fmt.Println(slices.Index(numbers, 8))
fmt.Println(slices.Index(numbers, 7))
</pre> <p>Output:</p> <pre class="output" data-language="go">2
-1
</pre>   <h2 id="IndexFunc">func <span>IndexFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int</pre> <p>IndexFunc returns the first index i satisfying f(s[i]), or -1 if none do. </p>   <h4 id="example_IndexFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
i := slices.IndexFunc(numbers, func(n int) bool {
    return n &lt; 0
})
fmt.Println("First negative at index", i)
</pre> <p>Output:</p> <pre class="output" data-language="go">First negative at index 2
</pre>   <h2 id="Insert">func <span>Insert</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Insert[S ~[]E, E any](s S, i int, v ...E) S</pre> <p>Insert inserts the values v... into s at index i, returning the modified slice. The elements at s[i:] are shifted up to make room. In the returned slice r, r[i] == v[0], and, if i &lt; len(s), r[i+len(v)] == value originally at r[i]. Insert panics if i &gt; len(s). This function is O(len(s) + len(v)). </p>   <h4 id="example_Insert"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
names = slices.Insert(names, 1, "Bill", "Billie")
names = slices.Insert(names, len(names), "Zac")
fmt.Println(names)
</pre> <p>Output:</p> <pre class="output" data-language="go">[Alice Bill Billie Bob Vera Zac]
</pre>   <h2 id="IsSorted">func <span>IsSorted</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func IsSorted[S ~[]E, E cmp.Ordered](x S) bool</pre> <p>IsSorted reports whether x is sorted in ascending order. </p>   <h4 id="example_IsSorted"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">fmt.Println(slices.IsSorted([]string{"Alice", "Bob", "Vera"}))
fmt.Println(slices.IsSorted([]int{0, 2, 1}))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
</pre>   <h2 id="IsSortedFunc">func <span>IsSortedFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool</pre> <p>IsSortedFunc reports whether x is sorted in ascending order, with cmp as the comparison function as defined by <a href="#SortFunc">SortFunc</a>. </p>   <h4 id="example_IsSortedFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"alice", "Bob", "VERA"}
isSortedInsensitive := slices.IsSortedFunc(names, func(a, b string) int {
    return strings.Compare(strings.ToLower(a), strings.ToLower(b))
})
fmt.Println(isSortedInsensitive)
fmt.Println(slices.IsSorted(names))
</pre> <p>Output:</p> <pre class="output" data-language="go">true
false
</pre>   <h2 id="Max">func <span>Max</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Max[S ~[]E, E cmp.Ordered](x S) E</pre> <p>Max returns the maximal value in x. It panics if x is empty. For floating-point E, Max propagates NaNs (any NaN value in x forces the output to be NaN). </p>   <h4 id="example_Max"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
fmt.Println(slices.Max(numbers))
</pre> <p>Output:</p> <pre class="output" data-language="go">42
</pre>   <h2 id="MaxFunc">func <span>MaxFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</pre> <p>MaxFunc returns the maximal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one maximal element according to the cmp function, MaxFunc returns the first one. </p>   <h4 id="example_MaxFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {"Gopher", 13},
    {"Alice", 55},
    {"Vera", 24},
    {"Bob", 55},
}
firstOldest := slices.MaxFunc(people, func(a, b Person) int {
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(firstOldest.Name)
</pre> <p>Output:</p> <pre class="output" data-language="go">Alice
</pre>   <h2 id="Min">func <span>Min</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Min[S ~[]E, E cmp.Ordered](x S) E</pre> <p>Min returns the minimal value in x. It panics if x is empty. For floating-point numbers, Min propagates NaNs (any NaN value in x forces the output to be NaN). </p>   <h4 id="example_Min"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 42, -10, 8}
fmt.Println(slices.Min(numbers))
</pre> <p>Output:</p> <pre class="output" data-language="go">-10
</pre>   <h2 id="MinFunc">func <span>MinFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</pre> <p>MinFunc returns the minimal value in x, using cmp to compare elements. It panics if x is empty. If there is more than one minimal element according to the cmp function, MinFunc returns the first one. </p>   <h4 id="example_MinFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {"Gopher", 13},
    {"Bob", 5},
    {"Vera", 24},
    {"Bill", 5},
}
firstYoungest := slices.MinFunc(people, func(a, b Person) int {
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(firstYoungest.Name)
</pre> <p>Output:</p> <pre class="output" data-language="go">Bob
</pre>   <h2 id="Repeat">func <span>Repeat</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Repeat[S ~[]E, E any](x S, count int) S</pre> <p>Repeat returns a new slice that repeats the provided slice the given number of times. The result has length and capacity (len(x) * count). The result is never nil. Repeat panics if count is negative or if the result of (len(x) * count) overflows. </p>   <h4 id="example_Repeat"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">numbers := []int{0, 1, 2, 3}
repeat := slices.Repeat(numbers, 2)
fmt.Println(repeat)
</pre> <p>Output:</p> <pre class="output" data-language="go">[0 1 2 3 0 1 2 3]
</pre>   <h2 id="Replace">func <span>Replace</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Replace[S ~[]E, E any](s S, i, j int, v ...E) S</pre> <p>Replace replaces the elements s[i:j] by the given v, and returns the modified slice. Replace panics if j &gt; len(s) or s[i:j] is not a valid slice of s. When len(v) &lt; (j-i), Replace zeroes the elements between the new length and the original length. </p>   <h4 id="example_Replace"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera", "Zac"}
names = slices.Replace(names, 1, 3, "Bill", "Billie", "Cat")
fmt.Println(names)
</pre> <p>Output:</p> <pre class="output" data-language="go">[Alice Bill Billie Cat Zac]
</pre>   <h2 id="Reverse">func <span>Reverse</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Reverse[S ~[]E, E any](s S)</pre> <p>Reverse reverses the elements of the slice in place. </p>   <h4 id="example_Reverse"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"alice", "Bob", "VERA"}
slices.Reverse(names)
fmt.Println(names)
</pre> <p>Output:</p> <pre class="output" data-language="go">[VERA Bob alice]
</pre>   <h2 id="Sort">func <span>Sort</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func Sort[S ~[]E, E cmp.Ordered](x S)</pre> <p>Sort sorts a slice of any ordered type in ascending order. When sorting floating-point numbers, NaNs are ordered before other values. </p>   <h4 id="example_Sort"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">smallInts := []int8{0, 42, -10, 8}
slices.Sort(smallInts)
fmt.Println(smallInts)
</pre> <p>Output:</p> <pre class="output" data-language="go">[-10 0 8 42]
</pre>   <h2 id="SortFunc">func <span>SortFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</pre> <p>SortFunc sorts the slice x in ascending order as determined by the cmp function. This sort is not guaranteed to be stable. cmp(a, b) should return a negative number when a &lt; b, a positive number when a &gt; b and zero when a == b or a and b are incomparable in the sense of a strict weak ordering. </p>
<p>SortFunc requires that cmp is a strict weak ordering. See <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a>. The function should return 0 for incomparable items. </p>   <h4 id="example_SortFunc_caseInsensitive"> <span class="text">Example (CaseInsensitive)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Bob", "alice", "VERA"}
slices.SortFunc(names, func(a, b string) int {
    return strings.Compare(strings.ToLower(a), strings.ToLower(b))
})
fmt.Println(names)
</pre> <p>Output:</p> <pre class="output" data-language="go">[alice Bob VERA]
</pre>      <h4 id="example_SortFunc_multiField"> <span class="text">Example (MultiField)</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {"Gopher", 13},
    {"Alice", 55},
    {"Bob", 24},
    {"Alice", 20},
}
slices.SortFunc(people, func(a, b Person) int {
    if n := strings.Compare(a.Name, b.Name); n != 0 {
        return n
    }
    // If names are equal, order by age
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(people)
</pre> <p>Output:</p> <pre class="output" data-language="go">[{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
</pre>   <h2 id="SortStableFunc">func <span>SortStableFunc</span>  <span title="Added in Go 1.21">1.21</span> </h2> <pre data-language="go">func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</pre> <p>SortStableFunc sorts the slice x while keeping the original order of equal elements, using cmp to compare elements in the same way as <a href="#SortFunc">SortFunc</a>. </p>   <h4 id="example_SortStableFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {"Gopher", 13},
    {"Alice", 20},
    {"Bob", 24},
    {"Alice", 55},
}
// Stable sort by name, keeping age ordering of Alice intact
slices.SortStableFunc(people, func(a, b Person) int {
    return strings.Compare(a.Name, b.Name)
})
fmt.Println(people)
</pre> <p>Output:</p> <pre class="output" data-language="go">[{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
</pre>   <h2 id="Sorted">func <span>Sorted</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E</pre> <p>Sorted collects values from seq into a new slice, sorts the slice, and returns it. </p>   <h4 id="example_Sorted"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := func(yield func(int) bool) {
    flag := -1
    for i := 0; i &lt; 10; i += 2 {
        flag = -flag
        if !yield(i * flag) {
            return
        }
    }
}

s := slices.Sorted(seq)
fmt.Println(s)
fmt.Println(slices.IsSorted(s))
</pre> <p>Output:</p> <pre class="output" data-language="go">[-6 -2 0 4 8]
true
</pre>   <h2 id="SortedFunc">func <span>SortedFunc</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</pre> <p>SortedFunc collects values from seq into a new slice, sorts the slice using the comparison function, and returns it. </p>   <h4 id="example_SortedFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">seq := func(yield func(int) bool) {
    flag := -1
    for i := 0; i &lt; 10; i += 2 {
        flag = -flag
        if !yield(i * flag) {
            return
        }
    }
}

sortFunc := func(a, b int) int {
    return cmp.Compare(b, a) // the comparison is being done in reverse
}

s := slices.SortedFunc(seq, sortFunc)
fmt.Println(s)
</pre> <p>Output:</p> <pre class="output" data-language="go">[8 4 0 -2 -6]
</pre>   <h2 id="SortedStableFunc">func <span>SortedStableFunc</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</pre> <p>SortedStableFunc collects values from seq into a new slice. It then sorts the slice while keeping the original order of equal elements, using the comparison function to compare elements. It returns the new slice. </p>   <h4 id="example_SortedStableFunc"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">type Person struct {
    Name string
    Age  int
}

people := []Person{
    {"Gopher", 13},
    {"Alice", 20},
    {"Bob", 5},
    {"Vera", 24},
    {"Zac", 20},
}

sortFunc := func(x, y Person) int {
    return cmp.Compare(x.Age, y.Age)
}

s := slices.SortedStableFunc(slices.Values(people), sortFunc)
fmt.Println(s)
</pre> <p>Output:</p> <pre class="output" data-language="go">[{Bob 5} {Gopher 13} {Alice 20} {Zac 20} {Vera 24}]
</pre>   <h2 id="Values">func <span>Values</span>  <span title="Added in Go 1.23">1.23</span> </h2> <pre data-language="go">func Values[Slice ~[]E, E any](s Slice) iter.Seq[E]</pre> <p>Values returns an iterator that yields the slice elements in order. </p>   <h4 id="example_Values"> <span class="text">Example</span>
</h4> <p>Code:</p> <pre class="code" data-language="go">names := []string{"Alice", "Bob", "Vera"}
for v := range slices.Values(names) {
    fmt.Println(v)
}
</pre> <p>Output:</p> <pre class="output" data-language="go">Alice
Bob
Vera
</pre><div class="_attribution">
  <p class="_attribution-p">
    &copy; Google, Inc.<br>Licensed under the Creative Commons Attribution License 3.0.<br>
    <a href="http://golang.org/pkg/slices/" class="_attribution-link">http://golang.org/pkg/slices/</a>
  </p>
</div>
