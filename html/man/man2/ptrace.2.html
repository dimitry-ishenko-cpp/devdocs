<h1>ptrace(2) â€” Linux manual page</h1>   <pre>
<span class="headline"><i>ptrace</i>(2)                  System Calls Manual                 <i>ptrace</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       ptrace - process trace
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;sys/ptrace.h&gt;</b>

       <b>long ptrace(enum __ptrace_request </b><i>op</i><b>, pid_t </b><i>pid</i><b>,</b>
                   <b>void *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b>
</pre> <h2>
DESCRIPTION </h2>
<pre>
       The <b>ptrace</b>() system call provides a means by which one process
       (the "tracer") may observe and control the execution of another
       process (the "tracee"), and examine and change the tracee's
       memory and registers.  It is primarily used to implement
       breakpoint debugging and system call tracing.

       A tracee first needs to be attached to the tracer.  Attachment
       and subsequent commands are per thread: in a multithreaded
       process, every thread can be individually attached to a
       (potentially different) tracer, or left not attached and thus not
       debugged.  Therefore, "tracee" always means "(one) thread", never
       "a (possibly multithreaded) process".  Ptrace commands are always
       sent to a specific tracee using a call of the form

           ptrace(PTRACE_foo, pid, ...)

       where <i>pid</i> is the thread ID of the corresponding Linux thread.

       (Note that in this page, a "multithreaded process" means a thread
       group consisting of threads created using the <a href="clone.2.html">clone(2)</a>
       <b>CLONE_THREAD </b>flag.)

       A process can initiate a trace by calling <a href="fork.2.html">fork(2)</a> and having the
       resulting child do a <b>PTRACE_TRACEME</b>, followed (typically) by an
       <a href="execve.2.html">execve(2)</a>.  Alternatively, one process may commence tracing
       another process using <b>PTRACE_ATTACH </b>or <b>PTRACE_SEIZE</b>.

       While being traced, the tracee will stop each time a signal is
       delivered, even if the signal is being ignored.  (An exception is
       <b>SIGKILL</b>, which has its usual effect.)  The tracer will be
       notified at its next call to <a href="waitpid.2.html">waitpid(2)</a> (or one of the related
       "wait" system calls); that call will return a <i>status</i> value
       containing information that indicates the cause of the stop in
       the tracee.  While the tracee is stopped, the tracer can use
       various ptrace operations to inspect and modify the tracee.  The
       tracer then causes the tracee to continue, optionally ignoring
       the delivered signal (or even delivering a different signal
       instead).

       If the <b>PTRACE_O_TRACEEXEC </b>option is not in effect, all successful
       calls to <a href="execve.2.html">execve(2)</a> by the traced process will cause it to be sent
       a <b>SIGTRAP </b>signal, giving the parent a chance to gain control
       before the new program begins execution.

       When the tracer is finished tracing, it can cause the tracee to
       continue executing in a normal, untraced mode via <b>PTRACE_DETACH</b>.

       The value of <i>op</i> determines the operation to be performed:

       <b>PTRACE_TRACEME</b>
              Indicate that this process is to be traced by its parent.
              A process probably shouldn't make this operation if its
              parent isn't expecting to trace it.  (<i>pid</i>, <i>addr</i>, and <i>data</i>
              are ignored.)

              The <b>PTRACE_TRACEME </b>operation is used only by the tracee;
              the remaining operations are used only by the tracer.  In
              the following operations, <i>pid</i> specifies the thread ID of
              the tracee to be acted on.  For operations other than
              <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>, <b>PTRACE_INTERRUPT</b>, and
              <b>PTRACE_KILL</b>, the tracee must be stopped.

       <b>PTRACE_PEEKTEXT</b>
       <b>PTRACE_PEEKDATA</b>
              Read a word at the address <i>addr</i> in the tracee's memory,
              returning the word as the result of the <b>ptrace</b>() call.
              Linux does not have separate text and data address spaces,
              so these two operations are currently equivalent.  (<i>data</i>
              is ignored; but see NOTES.)

       <b>PTRACE_PEEKUSER</b>
              Read a word at offset <i>addr</i> in the tracee's USER area,
              which holds the registers and other information about the
              process (see <i>&lt;sys/user.h&gt;</i>).  The word is returned as the
              result of the <b>ptrace</b>() call.  Typically, the offset must
              be word-aligned, though this might vary by architecture.
              See NOTES.  (<i>data</i> is ignored; but see NOTES.)

       <b>PTRACE_POKETEXT</b>
       <b>PTRACE_POKEDATA</b>
              Copy the word <i>data</i> to the address <i>addr</i> in the tracee's
              memory.  As for <b>PTRACE_PEEKTEXT </b>and <b>PTRACE_PEEKDATA</b>, these
              two operations are currently equivalent.

       <b>PTRACE_POKEUSER</b>
              Copy the word <i>data</i> to offset <i>addr</i> in the tracee's USER
              area.  As for <b>PTRACE_PEEKUSER</b>, the offset must typically
              be word-aligned.  In order to maintain the integrity of
              the kernel, some modifications to the USER area are
              disallowed.

       <b>PTRACE_GETREGS</b>
       <b>PTRACE_GETFPREGS</b>
              Copy the tracee's general-purpose or floating-point
              registers, respectively, to the address <i>data</i> in the
              tracer.  See <i>&lt;sys/user.h&gt;</i> for information on the format of
              this data.  (<i>addr</i> is ignored.)  Note that SPARC systems
              have the meaning of <i>data</i> and <i>addr</i> reversed; that is, <i>data</i>
              is ignored and the registers are copied to the address
              <i>addr</i>.  <b>PTRACE_GETREGS </b>and <b>PTRACE_GETFPREGS </b>are not present
              on all architectures.

       <b>PTRACE_GETREGSET </b>(since Linux 2.6.34)
              Read the tracee's registers.  <i>addr</i> specifies, in an
              architecture-dependent way, the type of registers to be
              read.  <b>NT_PRSTATUS </b>(with numerical value 1) usually
              results in reading of general-purpose registers.  If the
              CPU has, for example, floating-point and/or vector
              registers, they can be retrieved by setting <i>addr</i> to the
              corresponding <b>NT_foo </b>constant.  <i>data</i> points to a <b>struct</b>
              <b>iovec</b>, which describes the destination buffer's location
              and length.  On return, the kernel modifies <b>iov.len </b>to
              indicate the actual number of bytes returned.

       <b>PTRACE_SETREGS</b>
       <b>PTRACE_SETFPREGS</b>
              Modify the tracee's general-purpose or floating-point
              registers, respectively, from the address <i>data</i> in the
              tracer.  As for <b>PTRACE_POKEUSER</b>, some general-purpose
              register modifications may be disallowed.  (<i>addr</i> is
              ignored.)  Note that SPARC systems have the meaning of
              <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is ignored and the
              registers are copied from the address <i>addr</i>.
              <b>PTRACE_SETREGS </b>and <b>PTRACE_SETFPREGS </b>are not present on all
              architectures.

       <b>PTRACE_SETREGSET </b>(since Linux 2.6.34)
              Modify the tracee's registers.  The meaning of <i>addr</i> and
              <i>data</i> is analogous to <b>PTRACE_GETREGSET</b>.

       <b>PTRACE_GETSIGINFO </b>(since Linux 2.3.99-pre6)
              Retrieve information about the signal that caused the
              stop.  Copy a <i>siginfo_t</i> structure (see <a href="sigaction.2.html">sigaction(2)</a>) from
              the tracee to the address <i>data</i> in the tracer.  (<i>addr</i> is
              ignored.)

       <b>PTRACE_SETSIGINFO </b>(since Linux 2.3.99-pre6)
              Set signal information: copy a <i>siginfo_t</i> structure from
              the address <i>data</i> in the tracer to the tracee.  This will
              affect only signals that would normally be delivered to
              the tracee and were caught by the tracer.  It may be
              difficult to tell these normal signals from synthetic
              signals generated by <b>ptrace</b>() itself.  (<i>addr</i> is ignored.)

       <b>PTRACE_PEEKSIGINFO </b>(since Linux 3.10)
              Retrieve <i>siginfo_t</i> structures without removing signals
              from a queue.  <i>addr</i> points to a <i>ptrace_peeksiginfo_args</i>
              structure that specifies the ordinal position from which
              copying of signals should start, and the number of signals
              to copy.  <i>siginfo_t</i> structures are copied into the buffer
              pointed to by <i>data</i>.  The return value contains the number
              of copied signals (zero indicates that there is no signal
              corresponding to the specified ordinal position).  Within
              the returned <i>siginfo</i> structures, the <i>si_code</i> field
              includes information (<b>__SI_CHLD</b>, <b>__SI_FAULT</b>, etc.) that
              are not otherwise exposed to user space.

           struct ptrace_peeksiginfo_args {
               u64 off;    /* Ordinal position in queue at which
                              to start copying signals */
               u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */
               s32 nr;     /* Number of signals to copy */
           };

              Currently, there is only one flag,
              <b>PTRACE_PEEKSIGINFO_SHARED</b>, for dumping signals from the
              process-wide signal queue.  If this flag is not set,
              signals are read from the per-thread queue of the
              specified thread.

       <b>PTRACE_GETSIGMASK </b>(since Linux 3.11)
              Place a copy of the mask of blocked signals (see
              <a href="sigprocmask.2.html">sigprocmask(2)</a>) in the buffer pointed to by <i>data</i>, which
              should be a pointer to a buffer of type <i>sigset_t</i>.  The
              <i>addr</i> argument contains the size of the buffer pointed to
              by <i>data</i> (i.e., <i>sizeof(sigset_t)</i>).

       <b>PTRACE_SETSIGMASK </b>(since Linux 3.11)
              Change the mask of blocked signals (see <a href="sigprocmask.2.html">sigprocmask(2)</a>) to
              the value specified in the buffer pointed to by <i>data</i>,
              which should be a pointer to a buffer of type <i>sigset_t</i>.
              The <i>addr</i> argument contains the size of the buffer pointed
              to by <i>data</i> (i.e., <i>sizeof(sigset_t)</i>).

       <b>PTRACE_SETOPTIONS </b>(since Linux 2.4.6; see BUGS for caveats)
              Set ptrace options from <i>data</i>.  (<i>addr</i> is ignored.)  <i>data</i> is
              interpreted as a bit mask of options, which are specified
              by the following flags:

              <b>PTRACE_O_EXITKILL </b>(since Linux 3.8)
                     Send a <b>SIGKILL </b>signal to the tracee if the tracer
                     exits.  This option is useful for ptrace jailers
                     that want to ensure that tracees can never escape
                     the tracer's control.

              <b>PTRACE_O_TRACECLONE </b>(since Linux 2.5.46)
                     Stop the tracee at the next <a href="clone.2.html">clone(2)</a> and
                     automatically start tracing the newly cloned
                     process, which will start with a <b>SIGSTOP</b>, or
                     <b>PTRACE_EVENT_STOP </b>if <b>PTRACE_SEIZE </b>was used.  A
                     <a href="waitpid.2.html">waitpid(2)</a> by the tracer will return a <i>status</i> value
                     such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))

                     The PID of the new process can be retrieved with
                     <b>PTRACE_GETEVENTMSG</b>.

                     This option may not catch <a href="clone.2.html">clone(2)</a> calls in all
                     cases.  If the tracee calls <a href="clone.2.html">clone(2)</a> with the
                     <b>CLONE_VFORK </b>flag, <b>PTRACE_EVENT_VFORK </b>will be
                     delivered instead if <b>PTRACE_O_TRACEVFORK </b>is set;
                     otherwise if the tracee calls <a href="clone.2.html">clone(2)</a> with the
                     exit signal set to <b>SIGCHLD</b>, <b>PTRACE_EVENT_FORK </b>will
                     be delivered if <b>PTRACE_O_TRACEFORK </b>is set.

              <b>PTRACE_O_TRACEEXEC </b>(since Linux 2.5.46)
                     Stop the tracee at the next <a href="execve.2.html">execve(2)</a>.  A
                     <a href="waitpid.2.html">waitpid(2)</a> by the tracer will return a <i>status</i> value
                     such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))

                     If the execing thread is not a thread group leader,
                     the thread ID is reset to thread group leader's ID
                     before this stop.  Since Linux 3.0, the former
                     thread ID can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACEEXIT </b>(since Linux 2.5.60)
                     Stop the tracee at exit.  A <a href="waitpid.2.html">waitpid(2)</a> by the
                     tracer will return a <i>status</i> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))

                     The tracee's exit status can be retrieved with
                     <b>PTRACE_GETEVENTMSG</b>.

                     The tracee is stopped early during process exit,
                     when registers are still available, allowing the
                     tracer to see where the exit occurred, whereas the
                     normal exit notification is done after the process
                     is finished exiting.  Even though context is
                     available, the tracer cannot prevent the exit from
                     happening at this point.

              <b>PTRACE_O_TRACEFORK </b>(since Linux 2.5.46)
                     Stop the tracee at the next <a href="fork.2.html">fork(2)</a> and
                     automatically start tracing the newly forked
                     process, which will start with a <b>SIGSTOP</b>, or
                     <b>PTRACE_EVENT_STOP </b>if <b>PTRACE_SEIZE </b>was used.  A
                     <a href="waitpid.2.html">waitpid(2)</a> by the tracer will return a <i>status</i> value
                     such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))

                     The PID of the new process can be retrieved with
                     <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACESYSGOOD </b>(since Linux 2.4.6)
                     When delivering system call traps, set bit 7 in the
                     signal number (i.e., deliver <i>SIGTRAP|0x80</i>).  This
                     makes it easy for the tracer to distinguish normal
                     traps from those caused by a system call.

              <b>PTRACE_O_TRACEVFORK </b>(since Linux 2.5.46)
                     Stop the tracee at the next <a href="vfork.2.html">vfork(2)</a> and
                     automatically start tracing the newly vforked
                     process, which will start with a <b>SIGSTOP</b>, or
                     <b>PTRACE_EVENT_STOP </b>if <b>PTRACE_SEIZE </b>was used.  A
                     <a href="waitpid.2.html">waitpid(2)</a> by the tracer will return a <i>status</i> value
                     such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))

                     The PID of the new process can be retrieved with
                     <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACEVFORKDONE </b>(since Linux 2.5.60)
                     Stop the tracee at the completion of the next
                     <a href="vfork.2.html">vfork(2)</a>.  A <a href="waitpid.2.html">waitpid(2)</a> by the tracer will return a
                     <i>status</i> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))

                     The PID of the new process can (since Linux 2.6.18)
                     be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_TRACESECCOMP </b>(since Linux 3.5)
                     Stop the tracee when a <a href="seccomp.2.html">seccomp(2)</a> <b>SECCOMP_RET_TRACE</b>
                     rule is triggered.  A <a href="waitpid.2.html">waitpid(2)</a> by the tracer will
                     return a <i>status</i> value such that

                       status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))

                     While this triggers a <b>PTRACE_EVENT </b>stop, it is
                     similar to a syscall-enter-stop.  For details, see
                     the note on <b>PTRACE_EVENT_SECCOMP </b>below.  The
                     seccomp event message data (from the
                     <b>SECCOMP_RET_DATA </b>portion of the seccomp filter
                     rule) can be retrieved with <b>PTRACE_GETEVENTMSG</b>.

              <b>PTRACE_O_SUSPEND_SECCOMP </b>(since Linux 4.3)
                     Suspend the tracee's seccomp protections.  This
                     applies regardless of mode, and can be used when
                     the tracee has not yet installed seccomp filters.
                     That is, a valid use case is to suspend a tracee's
                     seccomp protections before they are installed by
                     the tracee, let the tracee install the filters, and
                     then clear this flag when the filters should be
                     resumed.  Setting this option requires that the
                     tracer have the <b>CAP_SYS_ADMIN </b>capability, not have
                     any seccomp protections installed, and not have
                     <b>PTRACE_O_SUSPEND_SECCOMP </b>set on itself.

       <b>PTRACE_GETEVENTMSG </b>(since Linux 2.5.46)
              Retrieve a message (as an <i>unsigned long</i>) about the ptrace
              event that just happened, placing it at the address <i>data</i>
              in the tracer.  For <b>PTRACE_EVENT_EXIT</b>, this is the
              tracee's exit status.  For <b>PTRACE_EVENT_FORK</b>,
              <b>PTRACE_EVENT_VFORK</b>, <b>PTRACE_EVENT_VFORK_DONE</b>, and
              <b>PTRACE_EVENT_CLONE</b>, this is the PID of the new process.
              For <b>PTRACE_EVENT_SECCOMP</b>, this is the <a href="seccomp.2.html">seccomp(2)</a> filter's
              <b>SECCOMP_RET_DATA </b>associated with the triggered rule.
              (<i>addr</i> is ignored.)

       <b>PTRACE_CONT</b>
              Restart the stopped tracee process.  If <i>data</i> is nonzero,
              it is interpreted as the number of a signal to be
              delivered to the tracee; otherwise, no signal is
              delivered.  Thus, for example, the tracer can control
              whether a signal sent to the tracee is delivered or not.
              (<i>addr</i> is ignored.)

       <b>PTRACE_SYSCALL</b>
       <b>PTRACE_SINGLESTEP</b>
              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but arrange
              for the tracee to be stopped at the next entry to or exit
              from a system call, or after execution of a single
              instruction, respectively.  (The tracee will also, as
              usual, be stopped upon receipt of a signal.)  From the
              tracer's perspective, the tracee will appear to have been
              stopped by receipt of a <b>SIGTRAP</b>.  So, for <b>PTRACE_SYSCALL</b>,
              for example, the idea is to inspect the arguments to the
              system call at the first stop, then do another
              <b>PTRACE_SYSCALL </b>and inspect the return value of the system
              call at the second stop.  The <i>data</i> argument is treated as
              for <b>PTRACE_CONT</b>.  (<i>addr</i> is ignored.)

       <b>PTRACE_SET_SYSCALL </b>(since Linux 2.6.16)
              When in syscall-enter-stop, change the number of the
              system call that is about to be executed to the number
              specified in the <i>data</i> argument.  The <i>addr</i> argument is
              ignored.  This operation is currently supported only on
              arm (and arm64, though only for backwards compatibility),
              but most other architectures have other means of
              accomplishing this (usually by changing the register that
              the userland code passed the system call number in).

       <b>PTRACE_SYSEMU</b>
       <b>PTRACE_SYSEMU_SINGLESTEP </b>(since Linux 2.6.14)
              For <b>PTRACE_SYSEMU</b>, continue and stop on entry to the next
              system call, which will not be executed.  See the
              documentation on syscall-stops below.  For
              <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but also singlestep
              if not a system call.  This call is used by programs like
              User Mode Linux that want to emulate all the tracee's
              system calls.  The <i>data</i> argument is treated as for
              <b>PTRACE_CONT</b>.  The <i>addr</i> argument is ignored.  These
              operations are currently supported only on x86.

       <b>PTRACE_LISTEN </b>(since Linux 3.4)
              Restart the stopped tracee, but prevent it from executing.
              The resulting state of the tracee is similar to a process
              which has been stopped by a <b>SIGSTOP </b>(or other stopping
              signal).  See the "group-stop" subsection for additional
              information.  <b>PTRACE_LISTEN </b>works only on tracees attached
              by <b>PTRACE_SEIZE</b>.

       <b>PTRACE_KILL</b>
              Send the tracee a <b>SIGKILL </b>to terminate it.  (<i>addr</i> and <i>data</i>
              are ignored.)

              <i>This operation is deprecated; do not use it!</i>  Instead,
              send a <b>SIGKILL </b>directly using <a href="kill.2.html">kill(2)</a> or <a href="tgkill.2.html">tgkill(2)</a>.  The
              problem with <b>PTRACE_KILL </b>is that it requires the tracee to
              be in signal-delivery-stop, otherwise it may not work
              (i.e., may complete successfully but won't kill the
              tracee).  By contrast, sending a <b>SIGKILL </b>directly has no
              such limitation.

       <b>PTRACE_INTERRUPT </b>(since Linux 3.4)
              Stop a tracee.  If the tracee is running or sleeping in
              kernel space and <b>PTRACE_SYSCALL </b>is in effect, the system
              call is interrupted and syscall-exit-stop is reported.
              (The interrupted system call is restarted when the tracee
              is restarted.)  If the tracee was already stopped by a
              signal and <b>PTRACE_LISTEN </b>was sent to it, the tracee stops
              with <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns the
              stop signal.  If any other ptrace-stop is generated at the
              same time (for example, if a signal is sent to the
              tracee), this ptrace-stop happens.  If none of the above
              applies (for example, if the tracee is running in user
              space), it stops with <b>PTRACE_EVENT_STOP </b>with
              <i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>.  <b>PTRACE_INTERRUPT </b>only works
              on tracees attached by <b>PTRACE_SEIZE</b>.

       <b>PTRACE_ATTACH</b>
              Attach to the process specified in <i>pid</i>, making it a tracee
              of the calling process.  The tracee is sent a <b>SIGSTOP</b>, but
              will not necessarily have stopped by the completion of
              this call; use <a href="waitpid.2.html">waitpid(2)</a> to wait for the tracee to stop.
              See the "Attaching and detaching" subsection for
              additional information.  (<i>addr</i> and <i>data</i> are ignored.)

              Permission to perform a <b>PTRACE_ATTACH </b>is governed by a
              ptrace access mode <b>PTRACE_MODE_ATTACH_REALCREDS </b>check; see
              below.

       <b>PTRACE_SEIZE </b>(since Linux 3.4)
              Attach to the process specified in <i>pid</i>, making it a tracee
              of the calling process.  Unlike <b>PTRACE_ATTACH</b>,
              <b>PTRACE_SEIZE </b>does not stop the process.  Group-stops are
              reported as <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns
              the stop signal.  Automatically attached children stop
              with <b>PTRACE_EVENT_STOP </b>and <i>WSTOPSIG(status)</i> returns
              <b>SIGTRAP </b>instead of having <b>SIGSTOP </b>signal delivered to
              them.  <a href="execve.2.html">execve(2)</a> does not deliver an extra <b>SIGTRAP</b>.  Only
              a <b>PTRACE_SEIZE</b>d process can accept <b>PTRACE_INTERRUPT </b>and
              <b>PTRACE_LISTEN </b>commands.  The "seized" behavior just
              described is inherited by children that are automatically
              attached using <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>,
              and <b>PTRACE_O_TRACECLONE</b>.  <i>addr</i> must be zero.  <i>data</i>
              contains a bit mask of ptrace options to activate
              immediately.

              Permission to perform a <b>PTRACE_SEIZE </b>is governed by a
              ptrace access mode <b>PTRACE_MODE_ATTACH_REALCREDS </b>check; see
              below.

       <b>PTRACE_SECCOMP_GET_FILTER </b>(since Linux 4.4)
              This operation allows the tracer to dump the tracee's
              classic BPF filters.

              <i>addr</i> is an integer specifying the index of the filter to
              be dumped.  The most recently installed filter has the
              index 0.  If <i>addr</i> is greater than the number of installed
              filters, the operation fails with the error <b>ENOENT</b>.

              <i>data</i> is either a pointer to a <i>struct sock_filter</i> array
              that is large enough to store the BPF program, or NULL if
              the program is not to be stored.

              Upon success, the return value is the number of
              instructions in the BPF program.  If <i>data</i> was NULL, then
              this return value can be used to correctly size the <i>struct</i>
              <i>sock_filter</i> array passed in a subsequent call.

              This operation fails with the error <b>EACCES </b>if the caller
              does not have the <b>CAP_SYS_ADMIN </b>capability or if the
              caller is in strict or filter seccomp mode.  If the filter
              referred to by <i>addr</i> is not a classic BPF filter, the
              operation fails with the error <b>EMEDIUMTYPE</b>.

              This operation is available if the kernel was configured
              with both the <b>CONFIG_SECCOMP_FILTER </b>and the
              <b>CONFIG_CHECKPOINT_RESTORE </b>options.

       <b>PTRACE_DETACH</b>
              Restart the stopped tracee as for <b>PTRACE_CONT</b>, but first
              detach from it.  Under Linux, a tracee can be detached in
              this way regardless of which method was used to initiate
              tracing.  (<i>addr</i> is ignored.)

       <b>PTRACE_GET_THREAD_AREA </b>(since Linux 2.6.0)
              This operation performs a similar task to
              <a href="get_thread_area.2.html">get_thread_area(2)</a>.  It reads the TLS entry in the GDT
              whose index is given in <i>addr</i>, placing a copy of the entry
              into the <i>struct user_desc</i> pointed to by <i>data</i>.  (By
              contrast with <a href="get_thread_area.2.html">get_thread_area(2)</a>, the <i>entry_number</i> of the
              <i>struct user_desc</i> is ignored.)

       <b>PTRACE_SET_THREAD_AREA </b>(since Linux 2.6.0)
              This operation performs a similar task to
              <a href="set_thread_area.2.html">set_thread_area(2)</a>.  It sets the TLS entry in the GDT
              whose index is given in <i>addr</i>, assigning it the data
              supplied in the <i>struct user_desc</i> pointed to by <i>data</i>.  (By
              contrast with <a href="set_thread_area.2.html">set_thread_area(2)</a>, the <i>entry_number</i> of the
              <i>struct user_desc</i> is ignored; in other words, this ptrace
              operation can't be used to allocate a free TLS entry.)

       <b>PTRACE_GET_SYSCALL_INFO </b>(since Linux 5.3)
              Retrieve information about the system call that caused the
              stop.  The information is placed into the buffer pointed
              by the <i>data</i> argument, which should be a pointer to a
              buffer of type <i>struct ptrace_syscall_info</i>.  The <i>addr</i>
              argument contains the size of the buffer pointed to by the
              <i>data</i> argument (i.e., <i>sizeof(struct ptrace_syscall_info)</i>).
              The return value contains the number of bytes available to
              be written by the kernel.  If the size of the data to be
              written by the kernel exceeds the size specified by the
              <i>addr</i> argument, the output data is truncated.

              The <i>ptrace_syscall_info</i> structure contains the following
              fields:

                  struct ptrace_syscall_info {
                      __u8 op;        /* Type of system call stop */
                      __u32 arch;     /* AUDIT_ARCH_* value; see seccomp(2) */
                      __u64 instruction_pointer; /* CPU instruction pointer */
                      __u64 stack_pointer;    /* CPU stack pointer */
                      union {
                          struct {    /* op == PTRACE_SYSCALL_INFO_ENTRY */
                              __u64 nr;       /* System call number */
                              __u64 args[6];  /* System call arguments */
                          } entry;
                          struct {    /* op == PTRACE_SYSCALL_INFO_EXIT */
                              __s64 rval;     /* System call return value */
                              __u8 is_error;  /* System call error flag;
                                                 Boolean: does rval contain
                                                 an error value (-ERRCODE) or
                                                 a nonerror return value? */
                          } exit;
                          struct {    /* op == PTRACE_SYSCALL_INFO_SECCOMP */
                              __u64 nr;       /* System call number */
                              __u64 args[6];  /* System call arguments */
                              __u32 ret_data; /* SECCOMP_RET_DATA portion
                                                 of SECCOMP_RET_TRACE
                                                 return value */
                          } seccomp;
                      };
                  };

              The <i>op</i>, <i>arch</i>, <i>instruction_pointer</i>, and <i>stack_pointer</i>
              fields are defined for all kinds of ptrace system call
              stops.  The rest of the structure is a union; one should
              read only those fields that are meaningful for the kind of
              system call stop specified by the <i>op</i> field.

              The <i>op</i> field has one of the following values (defined in
              <i>&lt;linux/ptrace.h&gt;</i>) indicating what type of stop occurred
              and which part of the union is filled:

              <b>PTRACE_SYSCALL_INFO_ENTRY</b>
                     The <i>entry</i> component of the union contains
                     information relating to a system call entry stop.

              <b>PTRACE_SYSCALL_INFO_EXIT</b>
                     The <i>exit</i> component of the union contains
                     information relating to a system call exit stop.

              <b>PTRACE_SYSCALL_INFO_SECCOMP</b>
                     The <i>seccomp</i> component of the union contains
                     information relating to a <b>PTRACE_EVENT_SECCOMP</b>
                     stop.

              <b>PTRACE_SYSCALL_INFO_NONE</b>
                     No component of the union contains relevant
                     information.

              In case of system call entry or exit stops, the data
              returned by <b>PTRACE_GET_SYSCALL_INFO </b>is limited to type
              <b>PTRACE_SYSCALL_INFO_NONE </b>unless <b>PTRACE_O_TRACESYSGOOD</b>
              option is set before the corresponding system call stop
              has occurred.

   <b>Death under ptrace</b>
       When a (possibly multithreaded) process receives a killing signal
       (one whose disposition is set to <b>SIG_DFL </b>and whose default action
       is to kill the process), all threads exit.  Tracees report their
       death to their tracer(s).  Notification of this event is
       delivered via <a href="waitpid.2.html">waitpid(2)</a>.

       Note that the killing signal will first cause signal-delivery-
       stop (on one tracee only), and only after it is injected by the
       tracer (or after it was dispatched to a thread which isn't
       traced), will death from the signal happen on <i>all</i> tracees within
       a multithreaded process.  (The term "signal-delivery-stop" is
       explained below.)

       <b>SIGKILL </b>does not generate signal-delivery-stop and therefore the
       tracer can't suppress it.  <b>SIGKILL </b>kills even within system calls
       (syscall-exit-stop is not generated prior to death by <b>SIGKILL</b>).
       The net effect is that <b>SIGKILL </b>always kills the process (all its
       threads), even if some threads of the process are ptraced.

       When the tracee calls <a href="_exit.2.html">_exit(2)</a>, it reports its death to its
       tracer.  Other threads are not affected.

       When any thread executes <a href="exit_group.2.html">exit_group(2)</a>, every tracee in its
       thread group reports its death to its tracer.

       If the <b>PTRACE_O_TRACEEXIT </b>option is on, <b>PTRACE_EVENT_EXIT </b>will
       happen before actual death.  This applies to exits via <a href="exit.2.html">exit(2)</a>,
       <a href="exit_group.2.html">exit_group(2)</a>, and signal deaths (except <b>SIGKILL</b>, depending on
       the kernel version; see BUGS below), and when threads are torn
       down on <a href="execve.2.html">execve(2)</a> in a multithreaded process.

       The tracer cannot assume that the ptrace-stopped tracee exists.
       There are many scenarios when the tracee may die while stopped
       (such as <b>SIGKILL</b>).  Therefore, the tracer must be prepared to
       handle an <b>ESRCH </b>error on any ptrace operation.  Unfortunately,
       the same error is returned if the tracee exists but is not
       ptrace-stopped (for commands which require a stopped tracee), or
       if it is not traced by the process which issued the ptrace call.
       The tracer needs to keep track of the stopped/running state of
       the tracee, and interpret <b>ESRCH </b>as "tracee died unexpectedly"
       only if it knows that the tracee has been observed to enter
       ptrace-stop.  Note that there is no guarantee that
       <i>waitpid(WNOHANG)</i> will reliably report the tracee's death status
       if a ptrace operation returned <b>ESRCH</b>.  <i>waitpid(WNOHANG)</i> may
       return 0 instead.  In other words, the tracee may be "not yet
       fully dead", but already refusing ptrace operations.

       The tracer can't assume that the tracee <i>always</i> ends its life by
       reporting <i>WIFEXITED(status)</i> or <i>WIFSIGNALED(status)</i>; there are
       cases where this does not occur.  For example, if a thread other
       than thread group leader does an <a href="execve.2.html">execve(2)</a>, it disappears; its
       PID will never be seen again, and any subsequent ptrace stops
       will be reported under the thread group leader's PID.

   <b>Stopped states</b>
       A tracee can be in two states: running or stopped.  For the
       purposes of ptrace, a tracee which is blocked in a system call
       (such as <a href="read.2.html">read(2)</a>, <a href="pause.2.html">pause(2)</a>, etc.)  is nevertheless considered to
       be running, even if the tracee is blocked for a long time.  The
       state of the tracee after <b>PTRACE_LISTEN </b>is somewhat of a gray
       area: it is not in any ptrace-stop (ptrace commands won't work on
       it, and it will deliver <a href="waitpid.2.html">waitpid(2)</a> notifications), but it also
       may be considered "stopped" because it is not executing
       instructions (is not scheduled), and if it was in group-stop
       before <b>PTRACE_LISTEN</b>, it will not respond to signals until
       <b>SIGCONT </b>is received.

       There are many kinds of states when the tracee is stopped, and in
       ptrace discussions they are often conflated.  Therefore, it is
       important to use precise terms.

       In this manual page, any stopped state in which the tracee is
       ready to accept ptrace commands from the tracer is called <i>ptrace-</i>
       <i>stop</i>.  Ptrace-stops can be further subdivided into <i>signal-</i>
       <i>delivery-stop</i>, <i>group-stop</i>, <i>syscall-stop</i>, <i>PTRACE_EVENT stops</i>, and
       so on.  These stopped states are described in detail below.

       When the running tracee enters ptrace-stop, it notifies its
       tracer using <a href="waitpid.2.html">waitpid(2)</a> (or one of the other "wait" system
       calls).  Most of this manual page assumes that the tracer waits
       with:

           pid = waitpid(pid_or_minus_1, &amp;status, __WALL);

       Ptrace-stopped tracees are reported as returns with <i>pid</i> greater
       than 0 and <i>WIFSTOPPED(status)</i> true.

       The <b>__WALL </b>flag does not include the <b>WSTOPPED </b>and <b>WEXITED </b>flags,
       but implies their functionality.

       Setting the <b>WCONTINUED </b>flag when calling <a href="waitpid.2.html">waitpid(2)</a> is not
       recommended: the "continued" state is per-process and consuming
       it can confuse the real parent of the tracee.

       Use of the <b>WNOHANG </b>flag may cause <a href="waitpid.2.html">waitpid(2)</a> to return 0 ("no
       wait results available yet") even if the tracer knows there
       should be a notification.  Example:

           errno = 0;
           ptrace(PTRACE_CONT, pid, 0L, 0L);
           if (errno == ESRCH) {
               /* tracee is dead */
               r = waitpid(tracee, &amp;status, __WALL | WNOHANG);
               /* r can still be 0 here! */
           }

       The following kinds of ptrace-stops exist: signal-delivery-stops,
       group-stops, <b>PTRACE_EVENT </b>stops, syscall-stops.  They all are
       reported by <a href="waitpid.2.html">waitpid(2)</a> with <i>WIFSTOPPED(status)</i> true.  They may be
       differentiated by examining the value <i>status&gt;&gt;8</i>, and if there is
       ambiguity in that value, by querying <b>PTRACE_GETSIGINFO</b>.  (Note:
       the <i>WSTOPSIG(status)</i> macro can't be used to perform this
       examination, because it returns the value <i>(status&gt;&gt;8) &amp; 0xff</i>.)

   <b>Signal-delivery-stop</b>
       When a (possibly multithreaded) process receives any signal
       except <b>SIGKILL</b>, the kernel selects an arbitrary thread which
       handles the signal.  (If the signal is generated with <a href="tgkill.2.html">tgkill(2)</a>,
       the target thread can be explicitly selected by the caller.)  If
       the selected thread is traced, it enters signal-delivery-stop.
       At this point, the signal is not yet delivered to the process,
       and can be suppressed by the tracer.  If the tracer doesn't
       suppress the signal, it passes the signal to the tracee in the
       next ptrace restart operation.  This second step of signal
       delivery is called <i>signal injection</i> in this manual page.  Note
       that if the signal is blocked, signal-delivery-stop doesn't
       happen until the signal is unblocked, with the usual exception
       that <b>SIGSTOP </b>can't be blocked.

       Signal-delivery-stop is observed by the tracer as <a href="waitpid.2.html">waitpid(2)</a>
       returning with <i>WIFSTOPPED(status)</i> true, with the signal returned
       by <i>WSTOPSIG(status)</i>.  If the signal is <b>SIGTRAP</b>, this may be a
       different kind of ptrace-stop; see the "Syscall-stops" and
       "execve" sections below for details.  If <i>WSTOPSIG(status)</i> returns
       a stopping signal, this may be a group-stop; see below.

   <b>Signal injection and suppression</b>
       After signal-delivery-stop is observed by the tracer, the tracer
       should restart the tracee with the call

           ptrace(PTRACE_restart, pid, 0, sig)

       where <b>PTRACE_restart </b>is one of the restarting ptrace operations.
       If <i>sig</i> is 0, then a signal is not delivered.  Otherwise, the
       signal <i>sig</i> is delivered.  This operation is called <i>signal</i>
       <i>injection</i> in this manual page, to distinguish it from signal-
       delivery-stop.

       The <i>sig</i> value may be different from the <i>WSTOPSIG(status)</i> value:
       the tracer can cause a different signal to be injected.

       Note that a suppressed signal still causes system calls to return
       prematurely.  In this case, system calls will be restarted: the
       tracer will observe the tracee to reexecute the interrupted
       system call (or <a href="restart_syscall.2.html">restart_syscall(2)</a> system call for a few system
       calls which use a different mechanism for restarting) if the
       tracer uses <b>PTRACE_SYSCALL</b>.  Even system calls (such as <a href="poll.2.html">poll(2)</a>)
       which are not restartable after signal are restarted after signal
       is suppressed; however, kernel bugs exist which cause some system
       calls to fail with <b>EINTR </b>even though no observable signal is
       injected to the tracee.

       Restarting ptrace commands issued in ptrace-stops other than
       signal-delivery-stop are not guaranteed to inject a signal, even
       if <i>sig</i> is nonzero.  No error is reported; a nonzero <i>sig</i> may
       simply be ignored.  Ptrace users should not try to "create a new
       signal" this way: use <a href="tgkill.2.html">tgkill(2)</a> instead.

       The fact that signal injection operations may be ignored when
       restarting the tracee after ptrace stops that are not signal-
       delivery-stops is a cause of confusion among ptrace users.  One
       typical scenario is that the tracer observes group-stop, mistakes
       it for signal-delivery-stop, restarts the tracee with

           ptrace(PTRACE_restart, pid, 0, stopsig)

       with the intention of injecting <i>stopsig</i>, but <i>stopsig</i> gets ignored
       and the tracee continues to run.

       The <b>SIGCONT </b>signal has a side effect of waking up (all threads
       of) a group-stopped process.  This side effect happens before
       signal-delivery-stop.  The tracer can't suppress this side effect
       (it can only suppress signal injection, which only causes the
       <b>SIGCONT </b>handler to not be executed in the tracee, if such a
       handler is installed).  In fact, waking up from group-stop may be
       followed by signal-delivery-stop for signal(s) <i>other than</i>
       <b>SIGCONT</b>, if they were pending when <b>SIGCONT </b>was delivered.  In
       other words, <b>SIGCONT </b>may be not the first signal observed by the
       tracee after it was sent.

       Stopping signals cause (all threads of) a process to enter group-
       stop.  This side effect happens after signal injection, and
       therefore can be suppressed by the tracer.

       In Linux 2.4 and earlier, the <b>SIGSTOP </b>signal can't be injected.

       <b>PTRACE_GETSIGINFO </b>can be used to retrieve a <i>siginfo_t</i> structure
       which corresponds to the delivered signal.  <b>PTRACE_SETSIGINFO </b>may
       be used to modify it.  If <b>PTRACE_SETSIGINFO </b>has been used to
       alter <i>siginfo_t</i>, the <i>si_signo</i> field and the <i>sig</i> parameter in the
       restarting command must match, otherwise the result is undefined.

   <b>Group-stop</b>
       When a (possibly multithreaded) process receives a stopping
       signal, all threads stop.  If some threads are traced, they enter
       a group-stop.  Note that the stopping signal will first cause
       signal-delivery-stop (on one tracee only), and only after it is
       injected by the tracer (or after it was dispatched to a thread
       which isn't traced), will group-stop be initiated on <i>all</i> tracees
       within the multithreaded process.  As usual, every tracee reports
       its group-stop separately to the corresponding tracer.

       Group-stop is observed by the tracer as <a href="waitpid.2.html">waitpid(2)</a> returning with
       <i>WIFSTOPPED(status)</i> true, with the stopping signal available via
       <i>WSTOPSIG(status)</i>.  The same result is returned by some other
       classes of ptrace-stops, therefore the recommended practice is to
       perform the call

           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo)

       The call can be avoided if the signal is not <b>SIGSTOP</b>, <b>SIGTSTP</b>,
       <b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals are stopping
       signals.  If the tracer sees something else, it can't be a group-
       stop.  Otherwise, the tracer needs to call <b>PTRACE_GETSIGINFO</b>.  If
       <b>PTRACE_GETSIGINFO </b>fails with <b>EINVAL</b>, then it is definitely a
       group-stop.  (Other failure codes are possible, such as <b>ESRCH</b>
       ("no such process") if a <b>SIGKILL </b>killed the tracee.)

       If tracee was attached using <b>PTRACE_SEIZE</b>, group-stop is
       indicated by <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 == PTRACE_EVENT_STOP</i>.
       This allows detection of group-stops without requiring an extra
       <b>PTRACE_GETSIGINFO </b>call.

       As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop
       and until it restarts or kills it, the tracee will not run, and
       will not send notifications (except <b>SIGKILL </b>death) to the tracer,
       even if the tracer enters into another <a href="waitpid.2.html">waitpid(2)</a> call.

       The kernel behavior described in the previous paragraph causes a
       problem with transparent handling of stopping signals.  If the
       tracer restarts the tracee after group-stop, the stopping signal
       is effectively ignoredâ€”the tracee doesn't remain stopped, it
       runs.  If the tracer doesn't restart the tracee before entering
       into the next <a href="waitpid.2.html">waitpid(2)</a>, future <b>SIGCONT </b>signals will not be
       reported to the tracer; this would cause the <b>SIGCONT </b>signals to
       have no effect on the tracee.

       Since Linux 3.4, there is a method to overcome this problem:
       instead of <b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN </b>command can be used to
       restart a tracee in a way where it does not execute, but waits
       for a new event which it can report via <a href="waitpid.2.html">waitpid(2)</a> (such as when
       it is restarted by a <b>SIGCONT</b>).

   <b>PTRACE_EVENT stops</b>
       If the tracer sets <b>PTRACE_O_TRACE_* </b>options, the tracee will
       enter ptrace-stops called <b>PTRACE_EVENT </b>stops.

       <b>PTRACE_EVENT </b>stops are observed by the tracer as <a href="waitpid.2.html">waitpid(2)</a>
       returning with <i>WIFSTOPPED(status)</i>, and <i>WSTOPSIG(status)</i> returns
       <b>SIGTRAP </b>(or for <b>PTRACE_EVENT_STOP</b>, returns the stopping signal if
       tracee is in a group-stop).  An additional bit is set in the
       higher byte of the status word: the value <i>status&gt;&gt;8</i> will be

           ((PTRACE_EVENT_foo&lt;&lt;8) | SIGTRAP).

       The following events exist:

       <b>PTRACE_EVENT_VFORK</b>
              Stop before return from <a href="vfork.2.html">vfork(2)</a> or <a href="clone.2.html">clone(2)</a> with the
              <b>CLONE_VFORK </b>flag.  When the tracee is continued after this
              stop, it will wait for child to exit/exec before
              continuing its execution (in other words, the usual
              behavior on <a href="vfork.2.html">vfork(2)</a>).

       <b>PTRACE_EVENT_FORK</b>
              Stop before return from <a href="fork.2.html">fork(2)</a> or <a href="clone.2.html">clone(2)</a> with the exit
              signal set to <b>SIGCHLD</b>.

       <b>PTRACE_EVENT_CLONE</b>
              Stop before return from <a href="clone.2.html">clone(2)</a>.

       <b>PTRACE_EVENT_VFORK_DONE</b>
              Stop before return from <a href="vfork.2.html">vfork(2)</a> or <a href="clone.2.html">clone(2)</a> with the
              <b>CLONE_VFORK </b>flag, but after the child unblocked this
              tracee by exiting or execing.

       For all four stops described above, the stop occurs in the parent
       (i.e., the tracee), not in the newly created thread.
       <b>PTRACE_GETEVENTMSG </b>can be used to retrieve the new thread's ID.

       <b>PTRACE_EVENT_EXEC</b>
              Stop before return from <a href="execve.2.html">execve(2)</a>.  Since Linux 3.0,
              <b>PTRACE_GETEVENTMSG </b>returns the former thread ID.

       <b>PTRACE_EVENT_EXIT</b>
              Stop before exit (including death from <a href="exit_group.2.html">exit_group(2)</a>),
              signal death, or exit caused by <a href="execve.2.html">execve(2)</a> in a
              multithreaded process.  <b>PTRACE_GETEVENTMSG </b>returns the
              exit status.  Registers can be examined (unlike when
              "real" exit happens).  The tracee is still alive; it needs
              to be <b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to finish exiting.

       <b>PTRACE_EVENT_STOP</b>
              Stop induced by <b>PTRACE_INTERRUPT </b>command, or group-stop,
              or initial ptrace-stop when a new child is attached (only
              if attached using <b>PTRACE_SEIZE</b>).

       <b>PTRACE_EVENT_SECCOMP</b>
              Stop triggered by a <a href="seccomp.2.html">seccomp(2)</a> rule on tracee syscall
              entry when <b>PTRACE_O_TRACESECCOMP </b>has been set by the
              tracer.  The seccomp event message data (from the
              <b>SECCOMP_RET_DATA </b>portion of the seccomp filter rule) can
              be retrieved with <b>PTRACE_GETEVENTMSG</b>.  The semantics of
              this stop are described in detail in a separate section
              below.

       <b>PTRACE_GETSIGINFO </b>on <b>PTRACE_EVENT </b>stops returns <b>SIGTRAP </b>in
       <i>si_signo</i>, with <i>si_code</i> set to <i>(event&lt;&lt;8) | SIGTRAP</i>.

   <b>Syscall-stops</b>
       If the tracee was restarted by <b>PTRACE_SYSCALL </b>or <b>PTRACE_SYSEMU</b>,
       the tracee enters syscall-enter-stop just prior to entering any
       system call (which will not be executed if the restart was using
       <b>PTRACE_SYSEMU</b>, regardless of any change made to registers at this
       point or how the tracee is restarted after this stop).  No matter
       which method caused the syscall-entry-stop, if the tracer
       restarts the tracee with <b>PTRACE_SYSCALL</b>, the tracee enters
       syscall-exit-stop when the system call is finished, or if it is
       interrupted by a signal.  (That is, signal-delivery-stop never
       happens between syscall-enter-stop and syscall-exit-stop; it
       happens <i>after</i> syscall-exit-stop.).  If the tracee is continued
       using any other method (including <b>PTRACE_SYSEMU</b>), no syscall-
       exit-stop occurs.  Note that all mentions <b>PTRACE_SYSEMU </b>apply
       equally to <b>PTRACE_SYSEMU_SINGLESTEP</b>.

       However, even if the tracee was continued using <b>PTRACE_SYSCALL</b>,
       it is not guaranteed that the next stop will be a syscall-exit-
       stop.  Other possibilities are that the tracee may stop in a
       <b>PTRACE_EVENT </b>stop (including seccomp stops), exit (if it entered
       <a href="_exit.2.html">_exit(2)</a> or <a href="exit_group.2.html">exit_group(2)</a>), be killed by <b>SIGKILL</b>, or die silently
       (if it is a thread group leader, the <a href="execve.2.html">execve(2)</a> happened in
       another thread, and that thread is not traced by the same tracer;
       this situation is discussed later).

       Syscall-enter-stop and syscall-exit-stop are observed by the
       tracer as <a href="waitpid.2.html">waitpid(2)</a> returning with <i>WIFSTOPPED(status)</i> true, and
       <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>.  If the <b>PTRACE_O_TRACESYSGOOD</b>
       option was set by the tracer, then <i>WSTOPSIG(status)</i> will give the
       value <i>(SIGTRAP | 0x80)</i>.

       Syscall-stops can be distinguished from signal-delivery-stop with
       <b>SIGTRAP </b>by querying <b>PTRACE_GETSIGINFO </b>for the following cases:

       <i>si_code</i> &lt;= 0
              <b>SIGTRAP </b>was delivered as a result of a user-space action,
              for example, a system call (<a href="tgkill.2.html">tgkill(2)</a>, <a href="kill.2.html">kill(2)</a>,
              <a href="../man3/sigqueue.3.html">sigqueue(3)</a>, etc.), expiration of a POSIX timer, change of
              state on a POSIX message queue, or completion of an
              asynchronous I/O operation.

       <i>si_code</i> == SI_KERNEL (0x80)
              <b>SIGTRAP </b>was sent by the kernel.

       <i>si_code</i> == SIGTRAP or <i>si_code</i> == (SIGTRAP|0x80)
              This is a syscall-stop.

       However, syscall-stops happen very often (twice per system call),
       and performing <b>PTRACE_GETSIGINFO </b>for every syscall-stop may be
       somewhat expensive.

       Some architectures allow the cases to be distinguished by
       examining registers.  For example, on x86, <i>rax</i> == -<b>ENOSYS </b>in
       syscall-enter-stop.  Since <b>SIGTRAP </b>(like any other signal) always
       happens <i>after</i> syscall-exit-stop, and at this point <i>rax</i> almost
       never contains -<b>ENOSYS</b>, the <b>SIGTRAP </b>looks like "syscall-stop
       which is not syscall-enter-stop"; in other words, it looks like a
       "stray syscall-exit-stop" and can be detected this way.  But such
       detection is fragile and is best avoided.

       Using the <b>PTRACE_O_TRACESYSGOOD </b>option is the recommended method
       to distinguish syscall-stops from other kinds of ptrace-stops,
       since it is reliable and does not incur a performance penalty.

       Syscall-enter-stop and syscall-exit-stop are indistinguishable
       from each other by the tracer.  The tracer needs to keep track of
       the sequence of ptrace-stops in order to not misinterpret
       syscall-enter-stop as syscall-exit-stop or vice versa.  In
       general, a syscall-enter-stop is always followed by syscall-exit-
       stop, <b>PTRACE_EVENT </b>stop, or the tracee's death; no other kinds of
       ptrace-stop can occur in between.  However, note that seccomp
       stops (see below) can cause syscall-exit-stops, without preceding
       syscall-entry-stops.  If seccomp is in use, care needs to be
       taken not to misinterpret such stops as syscall-entry-stops.

       If after syscall-enter-stop, the tracer uses a restarting command
       other than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not generated.

       <b>PTRACE_GETSIGINFO </b>on syscall-stops returns <b>SIGTRAP </b>in <i>si_signo</i>,
       with <i>si_code</i> set to <b>SIGTRAP </b>or <i>(SIGTRAP|0x80)</i>.

   <b>PTRACE_EVENT_SECCOMP stops (Linux 3.5 to Linux 4.7)</b>
       The behavior of <b>PTRACE_EVENT_SECCOMP </b>stops and their interaction
       with other kinds of ptrace stops has changed between kernel
       versions.  This documents the behavior from their introduction
       until Linux 4.7 (inclusive).  The behavior in later kernel
       versions is documented in the next section.

       A <b>PTRACE_EVENT_SECCOMP </b>stop occurs whenever a <b>SECCOMP_RET_TRACE</b>
       rule is triggered.  This is independent of which methods was used
       to restart the system call.  Notably, seccomp still runs even if
       the tracee was restarted using <b>PTRACE_SYSEMU </b>and this system call
       is unconditionally skipped.

       Restarts from this stop will behave as if the stop had occurred
       right before the system call in question.  In particular, both
       <b>PTRACE_SYSCALL </b>and <b>PTRACE_SYSEMU </b>will normally cause a subsequent
       syscall-entry-stop.  However, if after the <b>PTRACE_EVENT_SECCOMP</b>
       the system call number is negative, both the syscall-entry-stop
       and the system call itself will be skipped.  This means that if
       the system call number is negative after a <b>PTRACE_EVENT_SECCOMP</b>
       and the tracee is restarted using <b>PTRACE_SYSCALL</b>, the next
       observed stop will be a syscall-exit-stop, rather than the
       syscall-entry-stop that might have been expected.

   <b>PTRACE_EVENT_SECCOMP stops (since Linux 4.8)</b>
       Starting with Linux 4.8, the <b>PTRACE_EVENT_SECCOMP </b>stop was
       reordered to occur between syscall-entry-stop and syscall-exit-
       stop.  Note that seccomp no longer runs (and no
       <b>PTRACE_EVENT_SECCOMP </b>will be reported) if the system call is
       skipped due to <b>PTRACE_SYSEMU</b>.

       Functionally, a <b>PTRACE_EVENT_SECCOMP </b>stop functions comparably to
       a syscall-entry-stop (i.e., continuations using <b>PTRACE_SYSCALL</b>
       will cause syscall-exit-stops, the system call number may be
       changed and any other modified registers are visible to the to-
       be-executed system call as well).  Note that there may be, but
       need not have been a preceding syscall-entry-stop.

       After a <b>PTRACE_EVENT_SECCOMP </b>stop, seccomp will be rerun, with a
       <b>SECCOMP_RET_TRACE </b>rule now functioning the same as a
       <b>SECCOMP_RET_ALLOW</b>.  Specifically, this means that if registers
       are not modified during the <b>PTRACE_EVENT_SECCOMP </b>stop, the system
       call will then be allowed.

   <b>PTRACE_SINGLESTEP stops</b>
       [Details of these kinds of stops are yet to be documented.]

   <b>Informational and restarting ptrace commands</b>
       Most ptrace commands (all except <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>,
       <b>PTRACE_TRACEME</b>, <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>) require the
       tracee to be in a ptrace-stop, otherwise they fail with <b>ESRCH</b>.

       When the tracee is in ptrace-stop, the tracer can read and write
       data to the tracee using informational commands.  These commands
       leave the tracee in ptrace-stopped state:

           ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);
           ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);
           ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct);
           ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct);
           ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov);
           ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov);
           ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo);
           ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo);
           ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var);
           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       Note that some errors are not reported.  For example, setting
       signal information (<i>siginfo</i>) may have no effect in some ptrace-
       stops, yet the call may succeed (return 0 and not set <i><a href="../man3/errno.3.html">errno</a></i>);
       querying <b>PTRACE_GETEVENTMSG </b>may succeed and return some random
       value if current ptrace-stop is not documented as returning a
       meaningful event message.

       The call

           ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);

       affects one tracee.  The tracee's current flags are replaced.
       Flags are inherited by new tracees created and "auto-attached"
       via active <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
       <b>PTRACE_O_TRACECLONE </b>options.

       Another group of commands makes the ptrace-stopped tracee run.
       They have the form:

           ptrace(cmd, pid, 0, sig);

       where <i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>, <b>PTRACE_DETACH</b>,
       <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b>, <b>PTRACE_SYSEMU</b>, or
       <b>PTRACE_SYSEMU_SINGLESTEP</b>.  If the tracee is in signal-delivery-
       stop, <i>sig</i> is the signal to be injected (if it is nonzero).
       Otherwise, <i>sig</i> may be ignored.  (When restarting a tracee from a
       ptrace-stop other than signal-delivery-stop, recommended practice
       is to always pass 0 in <i>sig</i>.)

   <b>Attaching and detaching</b>
       A thread can be attached to the tracer using the call

           ptrace(PTRACE_ATTACH, pid, 0, 0);

       or

           ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);

       <b>PTRACE_ATTACH </b>sends <b>SIGSTOP </b>to this thread.  If the tracer wants
       this <b>SIGSTOP </b>to have no effect, it needs to suppress it.  Note
       that if other signals are concurrently sent to this thread during
       attach, the tracer may see the tracee enter signal-delivery-stop
       with other signal(s) first!  The usual practice is to reinject
       these signals until <b>SIGSTOP </b>is seen, then suppress <b>SIGSTOP</b>
       injection.  The design bug here is that a ptrace attach and a
       concurrently delivered <b>SIGSTOP </b>may race and the concurrent
       <b>SIGSTOP </b>may be lost.

       Since attaching sends <b>SIGSTOP </b>and the tracer usually suppresses
       it, this may cause a stray <b>EINTR </b>return from the currently
       executing system call in the tracee, as described in the "Signal
       injection and suppression" section.

       Since Linux 3.4, <b>PTRACE_SEIZE </b>can be used instead of
       <b>PTRACE_ATTACH</b>.  <b>PTRACE_SEIZE </b>does not stop the attached process.
       If you need to stop it after attach (or at any other time)
       without sending it any signals, use <b>PTRACE_INTERRUPT </b>command.

       The operation

           ptrace(PTRACE_TRACEME, 0, 0, 0);

       turns the calling thread into a tracee.  The thread continues to
       run (doesn't enter ptrace-stop).  A common practice is to follow
       the <b>PTRACE_TRACEME </b>with

           raise(SIGSTOP);

       and allow the parent (which is our tracer now) to observe our
       signal-delivery-stop.

       If the <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
       <b>PTRACE_O_TRACECLONE </b>options are in effect, then children created
       by, respectively, <a href="vfork.2.html">vfork(2)</a> or <a href="clone.2.html">clone(2)</a> with the <b>CLONE_VFORK </b>flag,
       <a href="fork.2.html">fork(2)</a> or <a href="clone.2.html">clone(2)</a> with the exit signal set to <b>SIGCHLD</b>, and
       other kinds of <a href="clone.2.html">clone(2)</a>, are automatically attached to the same
       tracer which traced their parent.  <b>SIGSTOP </b>is delivered to the
       children, causing them to enter signal-delivery-stop after they
       exit the system call which created them.

       Detaching of the tracee is performed by:

           ptrace(PTRACE_DETACH, pid, 0, sig);

       <b>PTRACE_DETACH </b>is a restarting operation; therefore it requires
       the tracee to be in ptrace-stop.  If the tracee is in signal-
       delivery-stop, a signal can be injected.  Otherwise, the <i>sig</i>
       parameter may be silently ignored.

       If the tracee is running when the tracer wants to detach it, the
       usual solution is to send <b>SIGSTOP </b>(using <a href="tgkill.2.html">tgkill(2)</a>, to make sure
       it goes to the correct thread), wait for the tracee to stop in
       signal-delivery-stop for <b>SIGSTOP </b>and then detach it (suppressing
       <b>SIGSTOP </b>injection).  A design bug is that this can race with
       concurrent <b>SIGSTOP</b>s.  Another complication is that the tracee may
       enter other ptrace-stops and needs to be restarted and waited for
       again, until <b>SIGSTOP </b>is seen.  Yet another complication is to be
       sure that the tracee is not already ptrace-stopped, because no
       signal delivery happens while it isâ€”not even <b>SIGSTOP</b>.

       If the tracer dies, all tracees are automatically detached and
       restarted, unless they were in group-stop.  Handling of restart
       from group-stop is currently buggy, but the "as planned" behavior
       is to leave tracee stopped and waiting for <b>SIGCONT</b>.  If the
       tracee is restarted from signal-delivery-stop, the pending signal
       is injected.

   <b>execve(2) under ptrace</b>
       When one thread in a multithreaded process calls <a href="execve.2.html">execve(2)</a>, the
       kernel destroys all other threads in the process, and resets the
       thread ID of the execing thread to the thread group ID (process
       ID).  (Or, to put things another way, when a multithreaded
       process does an <a href="execve.2.html">execve(2)</a>, at completion of the call, it appears
       as though the <a href="execve.2.html">execve(2)</a> occurred in the thread group leader,
       regardless of which thread did the <a href="execve.2.html">execve(2)</a>.)  This resetting of
       the thread ID looks very confusing to tracers:

       â€¢  All other threads stop in <b>PTRACE_EVENT_EXIT </b>stop, if the
          <b>PTRACE_O_TRACEEXIT </b>option was turned on.  Then all other
          threads except the thread group leader report death as if they
          exited via <a href="_exit.2.html">_exit(2)</a> with exit code 0.

       â€¢  The execing tracee changes its thread ID while it is in the
          <a href="execve.2.html">execve(2)</a>.  (Remember, under ptrace, the "pid" returned from
          <a href="waitpid.2.html">waitpid(2)</a>, or fed into ptrace calls, is the tracee's thread
          ID.)  That is, the tracee's thread ID is reset to be the same
          as its process ID, which is the same as the thread group
          leader's thread ID.

       â€¢  Then a <b>PTRACE_EVENT_EXEC </b>stop happens, if the
          <b>PTRACE_O_TRACEEXEC </b>option was turned on.

       â€¢  If the thread group leader has reported its <b>PTRACE_EVENT_EXIT</b>
          stop by this time, it appears to the tracer that the dead
          thread leader "reappears from nowhere".  (Note: the thread
          group leader does not report death via <i>WIFEXITED(status)</i> until
          there is at least one other live thread.  This eliminates the
          possibility that the tracer will see it dying and then
          reappearing.)  If the thread group leader was still alive, for
          the tracer this may look as if thread group leader returns
          from a different system call than it entered, or even
          "returned from a system call even though it was not in any
          system call".  If the thread group leader was not traced (or
          was traced by a different tracer), then during <a href="execve.2.html">execve(2)</a> it
          will appear as if it has become a tracee of the tracer of the
          execing tracee.

       All of the above effects are the artifacts of the thread ID
       change in the tracee.

       The <b>PTRACE_O_TRACEEXEC </b>option is the recommended tool for dealing
       with this situation.  First, it enables <b>PTRACE_EVENT_EXEC </b>stop,
       which occurs before <a href="execve.2.html">execve(2)</a> returns.  In this stop, the tracer
       can use <b>PTRACE_GETEVENTMSG </b>to retrieve the tracee's former thread
       ID.  (This feature was introduced in Linux 3.0.)  Second, the
       <b>PTRACE_O_TRACEEXEC </b>option disables legacy <b>SIGTRAP </b>generation on
       <a href="execve.2.html">execve(2)</a>.

       When the tracer receives <b>PTRACE_EVENT_EXEC </b>stop notification, it
       is guaranteed that except this tracee and the thread group
       leader, no other threads from the process are alive.

       On receiving the <b>PTRACE_EVENT_EXEC </b>stop notification, the tracer
       should clean up all its internal data structures describing the
       threads of this process, and retain only one data structureâ€”one
       which describes the single still running tracee, with

           thread ID == thread group ID == process ID.

       Example: two threads call <a href="execve.2.html">execve(2)</a> at the same time:

       *** we get syscall-enter-stop in thread 1: **
       PID1 execve("/bin/foo", "foo" &lt;unfinished ...&gt;
       *** we issue PTRACE_SYSCALL for thread 1 **
       *** we get syscall-enter-stop in thread 2: **
       PID2 execve("/bin/bar", "bar" &lt;unfinished ...&gt;
       *** we issue PTRACE_SYSCALL for thread 2 **
       *** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **
       *** we get syscall-exit-stop for PID0: **
       PID0 &lt;... execve resumed&gt; )             = 0

       If the <b>PTRACE_O_TRACEEXEC </b>option is <i>not</i> in effect for the execing
       tracee, and if the tracee was <b>PTRACE_ATTACH</b>ed rather that
       <b>PTRACE_SEIZE</b>d, the kernel delivers an extra <b>SIGTRAP </b>to the tracee
       after <a href="execve.2.html">execve(2)</a> returns.  This is an ordinary signal (similar to
       one which can be generated by <i>kill -TRAP</i>), not a special kind of
       ptrace-stop.  Employing <b>PTRACE_GETSIGINFO </b>for this signal returns
       <i>si_code</i> set to 0 (<i>SI_USER</i>).  This signal may be blocked by signal
       mask, and thus may be delivered (much) later.

       Usually, the tracer (for example, <a href="../man1/strace.1.html">strace(1)</a>) would not want to
       show this extra post-execve <b>SIGTRAP </b>signal to the user, and would
       suppress its delivery to the tracee (if <b>SIGTRAP </b>is set to
       <b>SIG_DFL</b>, it is a killing signal).  However, determining <i>which</i>
       <b>SIGTRAP </b>to suppress is not easy.  Setting the <b>PTRACE_O_TRACEEXEC</b>
       option or using <b>PTRACE_SEIZE </b>and thus suppressing this extra
       <b>SIGTRAP </b>is the recommended approach.

   <b>Real parent</b>
       The ptrace API (ab)uses the standard UNIX parent/child signaling
       over <a href="waitpid.2.html">waitpid(2)</a>.  This used to cause the real parent of the
       process to stop receiving several kinds of <a href="waitpid.2.html">waitpid(2)</a>
       notifications when the child process is traced by some other
       process.

       Many of these bugs have been fixed, but as of Linux 2.6.38
       several still exist; see BUGS below.

       As of Linux 2.6.38, the following is believed to work correctly:

       â€¢  exit/death by signal is reported first to the tracer, then,
          when the tracer consumes the <a href="waitpid.2.html">waitpid(2)</a> result, to the real
          parent (to the real parent only when the whole multithreaded
          process exits).  If the tracer and the real parent are the
          same process, the report is sent only once.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       On success, the <b>PTRACE_PEEK* </b>operations return the requested data
       (but see NOTES), the <b>PTRACE_SECCOMP_GET_FILTER </b>operation returns
       the number of instructions in the BPF program, the
       <b>PTRACE_GET_SYSCALL_INFO </b>operation returns the number of bytes
       available to be written by the kernel, and other operations
       return zero.

       On error, all operations return -1, and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate
       the error.  Since the value returned by a successful <b>PTRACE_PEEK*</b>
       operation may be -1, the caller must clear <i><a href="../man3/errno.3.html">errno</a></i> before the call,
       and then check it afterward to determine whether or not an error
       occurred.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EBUSY  </b>(i386 only) There was an error with allocating or freeing
              a debug register.

       <b>EFAULT </b>There was an attempt to read from or write to an invalid
              area in the tracer's or the tracee's memory, probably
              because the area wasn't mapped or accessible.
              Unfortunately, under Linux, different variations of this
              fault will return <b>EIO </b>or <b>EFAULT </b>more or less arbitrarily.

       <b>EINVAL </b>An attempt was made to set an invalid option.

       <b>EIO    </b><i>op</i> is invalid, or an attempt was made to read from or
              write to an invalid area in the tracer's or the tracee's
              memory, or there was a word-alignment violation, or an
              invalid signal was specified during a restart operation.

       <b>EPERM  </b>The specified process cannot be traced.  This could be
              because the tracer has insufficient privileges (the
              required capability is <b>CAP_SYS_PTRACE</b>); unprivileged
              processes cannot trace processes that they cannot send
              signals to or those running set-user-ID/set-group-ID
              programs, for obvious reasons.  Alternatively, the process
              may already be being traced, or (before Linux 2.6.26) be
              <a href="../man1/init.1.html">init(1)</a> (PID 1).

       <b>ESRCH  </b>The specified process does not exist, or is not currently
              being traced by the caller, or is not stopped (for
              operations that require a stopped tracee).
</pre> <h2>
STANDARDS </h2>
<pre>
       None.
</pre> <h2>
HISTORY </h2>
<pre>
       SVr4, 4.3BSD.

       Before Linux 2.6.26, <a href="../man1/init.1.html">init(1)</a>, the process with PID 1, may not be
       traced.
</pre> <h2>
NOTES </h2>
<pre>
       Although arguments to <b>ptrace</b>() are interpreted according to the
       prototype given, glibc currently declares <b>ptrace</b>() as a variadic
       function with only the <i>op</i> argument fixed.  It is recommended to
       always supply four arguments, even if the requested operation
       does not use them, setting unused/ignored arguments to <i>0L</i> or
       <i>(void *) 0</i>.

       A tracees parent continues to be the tracer even if that tracer
       calls <a href="execve.2.html">execve(2)</a>.

       The layout of the contents of memory and the USER area are quite
       operating-system- and architecture-specific.  The offset
       supplied, and the data returned, might not entirely match with
       the definition of <i>struct user</i>.

       The size of a "word" is determined by the operating-system
       variant (e.g., for 32-bit Linux it is 32 bits).

       This page documents the way the <b>ptrace</b>() call works currently in
       Linux.  Its behavior differs significantly on other flavors of
       UNIX.  In any case, use of <b>ptrace</b>() is highly specific to the
       operating system and architecture.

   <b>Ptrace access mode checking</b>
       Various parts of the kernel-user-space API (not just <b>ptrace</b>()
       operations), require so-called "ptrace access mode" checks, whose
       outcome determines whether an operation is permitted (or, in a
       few cases, causes a "read" operation to return sanitized data).
       These checks are performed in cases where one process can inspect
       sensitive information about, or in some cases modify the state
       of, another process.  The checks are based on factors such as the
       credentials and capabilities of the two processes, whether or not
       the "target" process is dumpable, and the results of checks
       performed by any enabled Linux Security Module (LSM)â€”for example,
       SELinux, Yama, or Smackâ€”and by the commoncap LSM (which is always
       invoked).

       Prior to Linux 2.6.27, all access checks were of a single type.
       Since Linux 2.6.27, two access mode levels are distinguished:

       <b>PTRACE_MODE_READ</b>
              For "read" operations or other operations that are less
              dangerous, such as: <a href="get_robust_list.2.html">get_robust_list(2)</a>; <a href="kcmp.2.html">kcmp(2)</a>; reading
              <i>/proc/</i>pid<i>/auxv</i>, <i>/proc/</i>pid<i>/environ</i>, or <i>/proc/</i>pid<i>/stat</i>; or
              <a href="readlink.2.html">readlink(2)</a> of a <i>/proc/</i>pid<i>/ns/*</i> file.

       <b>PTRACE_MODE_ATTACH</b>
              For "write" operations, or other operations that are more
              dangerous, such as: ptrace attaching (<b>PTRACE_ATTACH</b>) to
              another process or calling <a href="process_vm_writev.2.html">process_vm_writev(2)</a>.
              (<b>PTRACE_MODE_ATTACH </b>was effectively the default before
              Linux 2.6.27.)

       Since Linux 4.5, the above access mode checks are combined (ORed)
       with one of the following modifiers:

       <b>PTRACE_MODE_FSCREDS</b>
              Use the caller's filesystem UID and GID (see
              <a href="../man7/credentials.7.html">credentials(7)</a>) or effective capabilities for LSM checks.

       <b>PTRACE_MODE_REALCREDS</b>
              Use the caller's real UID and GID or permitted
              capabilities for LSM checks.  This was effectively the
              default before Linux 4.5.

       Because combining one of the credential modifiers with one of the
       aforementioned access modes is typical, some macros are defined
       in the kernel sources for the combinations:

       <b>PTRACE_MODE_READ_FSCREDS</b>
              Defined as <b>PTRACE_MODE_READ | PTRACE_MODE_FSCREDS</b>.

       <b>PTRACE_MODE_READ_REALCREDS</b>
              Defined as <b>PTRACE_MODE_READ | PTRACE_MODE_REALCREDS</b>.

       <b>PTRACE_MODE_ATTACH_FSCREDS</b>
              Defined as <b>PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS</b>.

       <b>PTRACE_MODE_ATTACH_REALCREDS</b>
              Defined as <b>PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS</b>.

       One further modifier can be ORed with the access mode:

       <b>PTRACE_MODE_NOAUDIT </b>(since Linux 3.3)
              Don't audit this access mode check.  This modifier is
              employed for ptrace access mode checks (such as checks
              when reading <i>/proc/</i>pid<i>/stat</i>) that merely cause the output
              to be filtered or sanitized, rather than causing an error
              to be returned to the caller.  In these cases, accessing
              the file is not a security violation and there is no
              reason to generate a security audit record.  This modifier
              suppresses the generation of such an audit record for the
              particular access check.

       Note that all of the <b>PTRACE_MODE_* </b>constants described in this
       subsection are kernel-internal, and not visible to user space.
       The constant names are mentioned here in order to label the
       various kinds of ptrace access mode checks that are performed for
       various system calls and accesses to various pseudofiles (e.g.,
       under <i>/proc</i>).  These names are used in other manual pages to
       provide a simple shorthand for labeling the different kernel
       checks.

       The algorithm employed for ptrace access mode checking determines
       whether the calling process is allowed to perform the
       corresponding action on the target process.  (In the case of
       opening <i>/proc/</i>pid files, the "calling process" is the one opening
       the file, and the process with the corresponding PID is the
       "target process".)  The algorithm is as follows:

       (1)  If the calling thread and the target thread are in the same
            thread group, access is always allowed.

       (2)  If the access mode specifies <b>PTRACE_MODE_FSCREDS</b>, then, for
            the check in the next step, employ the caller's filesystem
            UID and GID.  (As noted in <a href="../man7/credentials.7.html">credentials(7)</a>, the filesystem
            UID and GID almost always have the same values as the
            corresponding effective IDs.)

            Otherwise, the access mode specifies <b>PTRACE_MODE_REALCREDS</b>,
            so use the caller's real UID and GID for the checks in the
            next step.  (Most APIs that check the caller's UID and GID
            use the effective IDs.  For historical reasons, the
            <b>PTRACE_MODE_REALCREDS </b>check uses the real IDs instead.)

       (3)  Deny access if <i>neither</i> of the following is true:

            â€¢  The real, effective, and saved-set user IDs of the target
               match the caller's user ID, <i>and</i> the real, effective, and
               saved-set group IDs of the target match the caller's
               group ID.

            â€¢  The caller has the <b>CAP_SYS_PTRACE </b>capability in the user
               namespace of the target.

       (4)  Deny access if the target process "dumpable" attribute has a
            value other than 1 (<b>SUID_DUMP_USER</b>; see the discussion of
            <b>PR_SET_DUMPABLE </b>in <a href="prctl.2.html">prctl(2)</a>), and the caller does not have
            the <b>CAP_SYS_PTRACE </b>capability in the user namespace of the
            target process.

       (5)  The kernel LSM <i>security_ptrace_access_check</i>() interface is
            invoked to see if ptrace access is permitted.  The results
            depend on the LSM(s).  The implementation of this interface
            in the commoncap LSM performs the following steps:

            (5.1)  If the access mode includes <b>PTRACE_MODE_FSCREDS</b>, then
                   use the caller's <i>effective</i> capability set in the
                   following check; otherwise (the access mode specifies
                   <b>PTRACE_MODE_REALCREDS</b>, so) use the caller's <i>permitted</i>
                   capability set.

            (5.2)  Deny access if <i>neither</i> of the following is true:

                   â€¢  The caller and the target process are in the same
                      user namespace, and the caller's capabilities are
                      a superset of the target process's <i>permitted</i>
                      capabilities.

                   â€¢  The caller has the <b>CAP_SYS_PTRACE </b>capability in
                      the target process's user namespace.

                   Note that the commoncap LSM does not distinguish
                   between <b>PTRACE_MODE_READ </b>and <b>PTRACE_MODE_ATTACH</b>.

       (6)  If access has not been denied by any of the preceding steps,
            then access is allowed.

   <b>/proc/sys/kernel/yama/ptrace_scope</b>
       On systems with the Yama Linux Security Module (LSM) installed
       (i.e., the kernel was configured with <b>CONFIG_SECURITY_YAMA</b>), the
       <i>/proc/sys/kernel/yama/ptrace_scope</i> file (available since Linux
       3.4) can be used to restrict the ability to trace a process with
       <b>ptrace</b>() (and thus also the ability to use tools such as
       <a href="../man1/strace.1.html">strace(1)</a> and <a href="../man1/gdb.1.html">gdb(1)</a>).  The goal of such restrictions is to
       prevent attack escalation whereby a compromised process can
       ptrace-attach to other sensitive processes (e.g., a GPG agent or
       an SSH session) owned by the user in order to gain additional
       credentials that may exist in memory and thus expand the scope of
       the attack.

       More precisely, the Yama LSM limits two types of operations:

       â€¢  Any operation that performs a ptrace access mode
          <b>PTRACE_MODE_ATTACH </b>checkâ€”for example, <b>ptrace</b>() <b>PTRACE_ATTACH</b>.
          (See the "Ptrace access mode checking" discussion above.)

       â€¢  <b>ptrace</b>() <b>PTRACE_TRACEME</b>.

       A process that has the <b>CAP_SYS_PTRACE </b>capability can update the
       <i>/proc/sys/kernel/yama/ptrace_scope</i> file with one of the following
       values:

       0 ("classic ptrace permissions")
              No additional restrictions on operations that perform
              <b>PTRACE_MODE_ATTACH </b>checks (beyond those imposed by the
              commoncap and other LSMs).

              The use of <b>PTRACE_TRACEME </b>is unchanged.

       1 ("restricted ptrace") [default value]
              When performing an operation that requires a
              <b>PTRACE_MODE_ATTACH </b>check, the calling process must either
              have the <b>CAP_SYS_PTRACE </b>capability in the user namespace
              of the target process or it must have a predefined
              relationship with the target process.  By default, the
              predefined relationship is that the target process must be
              a descendant of the caller.

              A target process can employ the <a href="prctl.2.html">prctl(2)</a> <b>PR_SET_PTRACER</b>
              operation to declare an additional PID that is allowed to
              perform <b>PTRACE_MODE_ATTACH </b>operations on the target.  See
              the kernel source file
              <i>Documentation/admin-guide/LSM/Yama.rst</i> (or
              <i>Documentation/security/Yama.txt</i> before Linux 4.13) for
              further details.

              The use of <b>PTRACE_TRACEME </b>is unchanged.

       2 ("admin-only attach")
              Only processes with the <b>CAP_SYS_PTRACE </b>capability in the
              user namespace of the target process may perform
              <b>PTRACE_MODE_ATTACH </b>operations or trace children that
              employ <b>PTRACE_TRACEME</b>.

       3 ("no attach")
              No process may perform <b>PTRACE_MODE_ATTACH </b>operations or
              trace children that employ <b>PTRACE_TRACEME</b>.

              Once this value has been written to the file, it cannot be
              changed.

       With respect to values 1 and 2, note that creating a new user
       namespace effectively removes the protection offered by Yama.
       This is because a process in the parent user namespace whose
       effective UID matches the UID of the creator of a child namespace
       has all capabilities (including <b>CAP_SYS_PTRACE</b>) when performing
       operations within the child user namespace (and further-removed
       descendants of that namespace).  Consequently, when a process
       tries to use user namespaces to sandbox itself, it inadvertently
       weakens the protections offered by the Yama LSM.

   <b>C library/kernel differences</b>
       At the system call level, the <b>PTRACE_PEEKTEXT</b>, <b>PTRACE_PEEKDATA</b>,
       and <b>PTRACE_PEEKUSER </b>operations have a different API: they store
       the result at the address specified by the <i>data</i> parameter, and
       the return value is the error flag.  The glibc wrapper function
       provides the API given in DESCRIPTION above, with the result
       being returned via the function return value.
</pre> <h2>
BUGS </h2>
<pre>
       On hosts with Linux 2.6 kernel headers, <b>PTRACE_SETOPTIONS </b>is
       declared with a different value than the one for Linux 2.4.  This
       leads to applications compiled with Linux 2.6 kernel headers
       failing when run on Linux 2.4.  This can be worked around by
       redefining <b>PTRACE_SETOPTIONS </b>to <b>PTRACE_OLDSETOPTIONS</b>, if that is
       defined.

       Group-stop notifications are sent to the tracer, but not to real
       parent.  Last confirmed on 2.6.38.6.

       If a thread group leader is traced and exits by calling <a href="_exit.2.html">_exit(2)</a>,
       a <b>PTRACE_EVENT_EXIT </b>stop will happen for it (if requested), but
       the subsequent <b>WIFEXITED </b>notification will not be delivered until
       all other threads exit.  As explained above, if one of other
       threads calls <a href="execve.2.html">execve(2)</a>, the death of the thread group leader
       will <i>never</i> be reported.  If the execed thread is not traced by
       this tracer, the tracer will never know that <a href="execve.2.html">execve(2)</a> happened.
       One possible workaround is to <b>PTRACE_DETACH </b>the thread group
       leader instead of restarting it in this case.  Last confirmed on
       2.6.38.6.

       A <b>SIGKILL </b>signal may still cause a <b>PTRACE_EVENT_EXIT </b>stop before
       actual signal death.  This may be changed in the future; <b>SIGKILL</b>
       is meant to always immediately kill tasks even under ptrace.
       Last confirmed on Linux 3.13.

       Some system calls return with <b>EINTR </b>if a signal was sent to a
       tracee, but delivery was suppressed by the tracer.  (This is very
       typical operation: it is usually done by debuggers on every
       attach, in order to not introduce a bogus <b>SIGSTOP</b>).  As of Linux
       3.2.9, the following system calls are affected (this list is
       likely incomplete): <a href="epoll_wait.2.html">epoll_wait(2)</a>, and <a href="read.2.html">read(2)</a> from an <a href="../man7/inotify.7.html">inotify(7)</a>
       file descriptor.  The usual symptom of this bug is that when you
       attach to a quiescent process with the command

           strace -p &lt;process-ID&gt;

       then, instead of the usual and expected one-line output such as

           restart_syscall(&lt;... resuming interrupted call ...&gt;_

       or

           select(6, [5], NULL, [5], NULL_

       ('_' denotes the cursor position), you observe more than one
       line.  For example:

               clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0
               epoll_wait(4,_

       What is not visible here is that the process was blocked in
       <a href="epoll_wait.2.html">epoll_wait(2)</a> before <a href="../man1/strace.1.html">strace(1)</a> has attached to it.  Attaching
       caused <a href="epoll_wait.2.html">epoll_wait(2)</a> to return to user space with the error
       <b>EINTR</b>.  In this particular case, the program reacted to <b>EINTR </b>by
       checking the current time, and then executing <a href="epoll_wait.2.html">epoll_wait(2)</a>
       again.  (Programs which do not expect such "stray" <b>EINTR </b>errors
       may behave in an unintended way upon an <a href="../man1/strace.1.html">strace(1)</a> attach.)

       Contrary to the normal rules, the glibc wrapper for <b>ptrace</b>() can
       set <i><a href="../man3/errno.3.html">errno</a></i> to zero.
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/gdb.1.html">gdb(1)</a>, <a href="../man1/ltrace.1.html">ltrace(1)</a>, <a href="../man1/strace.1.html">strace(1)</a>, <a href="clone.2.html">clone(2)</a>, <a href="execve.2.html">execve(2)</a>, <a href="fork.2.html">fork(2)</a>,
       <a href="gettid.2.html">gettid(2)</a>, <a href="prctl.2.html">prctl(2)</a>, <a href="seccomp.2.html">seccomp(2)</a>, <a href="sigaction.2.html">sigaction(2)</a>, <a href="tgkill.2.html">tgkill(2)</a>,
       <a href="vfork.2.html">vfork(2)</a>, <a href="waitpid.2.html">waitpid(2)</a>, <a href="../man3/exec.3.html">exec(3)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/signal.7.html">signal(7)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       âŸ¨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>âŸ©.  If you have a bug report
       for this manual page, see
       âŸ¨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>âŸ©.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       âŸ¨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>âŸ© on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-05-02                      <i>ptrace</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/coresched.1.html">coresched(1)</a>, <a href="../man1/ltrace.1.html">ltrace(1)</a>, <a href="../man1/strace.1.html">strace(1)</a>, <a href="clone.2.html">clone(2)</a>, <a href="execve.2.html">execve(2)</a>, <a href="get_robust_list.2.html">get_robust_list(2)</a>, <a href="kcmp.2.html">kcmp(2)</a>, <a href="memfd_secret.2.html">memfd_secret(2)</a>, <a href="move_pages.2.html">move_pages(2)</a>, <a href="perf_event_open.2.html">perf_event_open(2)</a>, <a href="pidfd_getfd.2.html">pidfd_getfd(2)</a>, <a href="process_madvise.2.html">process_madvise(2)</a>, <a href="process_vm_readv.2.html">process_vm_readv(2)</a>, <a href="pr_set_dumpable.2const.html">PR_SET_DUMPABLE(2const)</a>, <a href="pr_set_ptracer.2const.html">PR_SET_PTRACER(2const)</a>, <a href="seccomp.2.html">seccomp(2)</a>, <a href="set_thread_area.2.html">set_thread_area(2)</a>, <a href="sigaction.2.html">sigaction(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="wait.2.html">wait(2)</a>, <a href="../man3/exec.3.html">exec(3)</a>, <a href="../man3/seccomp_init.3.html">seccomp_init(3)</a>, <a href="../man3/seccomp_rule_add.3.html">seccomp_rule_add(3)</a>, <a href="../man5/proc_pid_auxv.5.html">proc_pid_auxv(5)</a>, <a href="../man5/proc_pid_cwd.5.html">proc_pid_cwd(5)</a>, <a href="../man5/proc_pid_environ.5.html">proc_pid_environ(5)</a>, <a href="../man5/proc_pid_exe.5.html">proc_pid_exe(5)</a>, <a href="../man5/proc_pid_fd.5.html">proc_pid_fd(5)</a>, <a href="../man5/proc_pid_io.5.html">proc_pid_io(5)</a>, <a href="../man5/proc_pid_map_files.5.html">proc_pid_map_files(5)</a>, <a href="../man5/proc_pid_maps.5.html">proc_pid_maps(5)</a>, <a href="../man5/proc_pid_mem.5.html">proc_pid_mem(5)</a>, <a href="../man5/proc_pid_pagemap.5.html">proc_pid_pagemap(5)</a>, <a href="../man5/proc_pid_personality.5.html">proc_pid_personality(5)</a>, <a href="../man5/proc_pid_root.5.html">proc_pid_root(5)</a>, <a href="../man5/proc_pid_stack.5.html">proc_pid_stack(5)</a>, <a href="../man5/proc_pid_stat.5.html">proc_pid_stat(5)</a>, <a href="../man5/proc_pid_syscall.5.html">proc_pid_syscall(5)</a>, <a href="../man5/proc_pid_timerslack_ns.5.html">proc_pid_timerslack_ns(5)</a>, <a href="../man5/proc_pid_wchan.5.html">proc_pid_wchan(5)</a>, <a href="../man5/proc_sys_fs.5.html">proc_sys_fs(5)</a>, <a href="../man5/proc_sys_kernel.5.html">proc_sys_kernel(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/credentials.7.html">credentials(7)</a>, <a href="../man7/landlock.7.html">landlock(7)</a>, <a href="../man7/namespaces.7.html">namespaces(7)</a>, <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>, <a href="../man8/stapdyn.8.html">stapdyn(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/ptrace.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/ptrace.2.html</a>
  </p>
</div>
