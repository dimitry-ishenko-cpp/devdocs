<h1>clone(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>clone</i>(2)                   System Calls Manual                  <i>clone</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       clone, __clone2, clone3 - create a child process
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)
</pre> <h2>
SYNOPSIS </h2>
<pre>
       /* Prototype for the glibc wrapper function */

       <b>#define _GNU_SOURCE</b>
       <b>#include &lt;sched.h&gt;</b>

       <b>int clone(int (*</b><i>fn</i><b>)(void *_Nullable), void *</b><i>stack</i><b>, int </b><i>flags</i><b>,</b>
                 <b>void *_Nullable </b><i>arg</i><b>, ...  </b>/* <b>pid_t *_Nullable </b><i>parent_tid</i><b>,</b>
                                              <b>void *_Nullable </b><i>tls</i><b>,</b>
                                              <b>pid_t *_Nullable </b><i>child_tid</i> */ <b>);</b>

       /* For the prototype of the raw clone() system call, see NOTES */

       <b>#include &lt;linux/sched.h&gt;    </b>/* Definition of <b>struct clone_args </b>*/
       <b>#include &lt;sched.h&gt;          </b>/* Definition of <b>CLONE_* </b>constants */
       <b>#include &lt;sys/syscall.h&gt;    </b>/* Definition of <b>SYS_* </b>constants */
       <b>#include &lt;unistd.h&gt;</b>

       <b>long syscall(SYS_clone3, struct clone_args *</b><i>cl_args</i><b>, size_t </b><i>size</i><b>);</b>

       <i>Note</i>: glibc provides no wrapper for <b>clone3</b>(), necessitating the
       use of <a href="syscall.2.html">syscall(2)</a>.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       These system calls create a new ("child") process, in a manner
       similar to <a href="fork.2.html">fork(2)</a>.

       By contrast with <a href="fork.2.html">fork(2)</a>, these system calls provide more precise
       control over what pieces of execution context are shared between
       the calling process and the child process.  For example, using
       these system calls, the caller can control whether or not the two
       processes share the virtual address space, the table of file
       descriptors, and the table of signal handlers.  These system
       calls also allow the new child process to be placed in separate
       <a href="../man7/namespaces.7.html">namespaces(7)</a>.

       Note that in this manual page, "calling process" normally
       corresponds to "parent process".  But see the descriptions of
       <b>CLONE_PARENT </b>and <b>CLONE_THREAD </b>below.

       This page describes the following interfaces:

       •  The glibc <b>clone</b>() wrapper function and the underlying system
          call on which it is based.  The main text describes the
          wrapper function; the differences for the raw system call are
          described toward the end of this page.

       •  The newer <b>clone3</b>() system call.

       In the remainder of this page, the terminology "the clone call"
       is used when noting details that apply to all of these
       interfaces.

   <b>The clone() wrapper function</b>
       When the child process is created with the <b>clone</b>() wrapper
       function, it commences execution by calling the function pointed
       to by the argument <i>fn</i>.  (This differs from <a href="fork.2.html">fork(2)</a>, where
       execution continues in the child from the point of the <a href="fork.2.html">fork(2)</a>
       call.)  The <i>arg</i> argument is passed as the argument of the
       function <i>fn</i>.

       When the <i>fn</i>(<i>arg</i>) function returns, the child process terminates.
       The integer returned by <i>fn</i> is the exit status for the child
       process.  The child process may also terminate explicitly by
       calling <a href="exit.2.html">exit(2)</a> or after receiving a fatal signal.

       The <i>stack</i> argument specifies the location of the stack used by
       the child process.  Since the child and calling process may share
       memory, it is not possible for the child process to execute in
       the same stack as the calling process.  The calling process must
       therefore set up memory space for the child stack and pass a
       pointer to this space to <b>clone</b>().  Stacks grow downward on all
       processors that run Linux (except the HP PA processors), so <i>stack</i>
       usually points to the topmost address of the memory space set up
       for the child stack.  Note that <b>clone</b>() does not provide a means
       whereby the caller can inform the kernel of the size of the stack
       area.

       The remaining arguments to <b>clone</b>() are discussed below.

   <b>clone3()</b>
       The <b>clone3</b>() system call provides a superset of the functionality
       of the older <b>clone</b>() interface.  It also provides a number of API
       improvements, including: space for additional flags bits; cleaner
       separation in the use of various arguments; and the ability to
       specify the size of the child's stack area.

       As with <a href="fork.2.html">fork(2)</a>, <b>clone3</b>() returns in both the parent and the
       child.  It returns 0 in the child process and returns the PID of
       the child in the parent.

       The <i>cl_args</i> argument of <b>clone3</b>() is a structure of the following
       form:

           struct clone_args {
               u64 flags;        /* Flags bit mask */
               u64 pidfd;        /* Where to store PID file descriptor
                                    (<i>int *</i>) */
               u64 child_tid;    /* Where to store child TID,
                                    in child's memory (<i>pid_t *</i>) */
               u64 parent_tid;   /* Where to store child TID,
                                    in parent's memory (<i>pid_t *</i>) */
               u64 exit_signal;  /* Signal to deliver to parent on
                                    child termination */
               u64 stack;        /* Pointer to lowest byte of stack */
               u64 stack_size;   /* Size of stack */
               u64 tls;          /* Location of new TLS */
               u64 set_tid;      /* Pointer to a <i>pid_t</i> array
                                    (since Linux 5.5) */
               u64 set_tid_size; /* Number of elements in <i>set_tid</i>
                                    (since Linux 5.5) */
               u64 cgroup;       /* File descriptor for target cgroup
                                    of child (since Linux 5.7) */
           };

       The <i>size</i> argument that is supplied to <b>clone3</b>() should be
       initialized to the size of this structure.  (The existence of the
       <i>size</i> argument permits future extensions to the <i>clone_args</i>
       structure.)

       The stack for the child process is specified via <i>cl_args.stack</i>,
       which points to the lowest byte of the stack area, and
       <i>cl_args.stack_size</i>, which specifies the size of the stack in
       bytes.  In the case where the <b>CLONE_VM </b>flag (see below) is
       specified, a stack must be explicitly allocated and specified.
       Otherwise, these two fields can be specified as NULL and 0, which
       causes the child to use the same stack area as the parent (in the
       child's own virtual address space).

       The remaining fields in the <i>cl_args</i> argument are discussed below.

   <b>Equivalence between clone() and clone3() arguments</b>
       Unlike the older <b>clone</b>() interface, where arguments are passed
       individually, in the newer <b>clone3</b>() interface the arguments are
       packaged into the <i>clone_args</i> structure shown above.  This
       structure allows for a superset of the information passed via the
       <b>clone</b>() arguments.

       The following table shows the equivalence between the arguments
       of <b>clone</b>() and the fields in the <i>clone_args</i> argument supplied to
       <b>clone3</b>():
           <b>clone()         clone3()        Notes</b>
                           <i>cl_args</i> field
           <i>flags &amp; ~0xff</i>   <i>flags</i>           For most flags; details
                                           below
           <i>parent_tid</i>      <i>pidfd</i>           See CLONE_PIDFD
           <i>child_tid</i>       <i>child_tid</i>       See CLONE_CHILD_SETTID
           <i>parent_tid</i>      <i>parent_tid</i>      See CLONE_PARENT_SETTID
           <i>flags &amp; 0xff</i>    <i>exit_signal</i>
           <i>stack</i>           <i>stack</i>
           ---             <i>stack_size</i>
           <i>tls</i>             <i>tls</i>             See CLONE_SETTLS
           ---             <i>set_tid</i>         See below for details
           ---             <i>set_tid_size</i>
           ---             <i>cgroup</i>          See CLONE_INTO_CGROUP

   <b>The child termination signal</b>
       When the child process terminates, a signal may be sent to the
       parent.  The termination signal is specified in the low byte of
       <i>flags</i> (<b>clone</b>()) or in <i>cl_args.exit_signal</i> (<b>clone3</b>()).  If this
       signal is specified as anything other than <b>SIGCHLD</b>, then the
       parent process must specify the <b>__WALL </b>or <b>__WCLONE </b>options when
       waiting for the child with <a href="wait.2.html">wait(2)</a>.  If no signal (i.e., zero) is
       specified, then the parent process is not signaled when the child
       terminates.

   <b>The set_tid array</b>
       By default, the kernel chooses the next sequential PID for the
       new process in each of the PID namespaces where it is present.
       When creating a process with <b>clone3</b>(), the <i>set_tid</i> array
       (available since Linux 5.5) can be used to select specific PIDs
       for the process in some or all of the PID namespaces where it is
       present.  If the PID of the newly created process should be set
       only for the current PID namespace or in the newly created PID
       namespace (if <i>flags</i> contains <b>CLONE_NEWPID</b>) then the first element
       in the <i>set_tid</i> array has to be the desired PID and <i>set_tid_size</i>
       needs to be 1.

       If the PID of the newly created process should have a certain
       value in multiple PID namespaces, then the <i>set_tid</i> array can have
       multiple entries.  The first entry defines the PID in the most
       deeply nested PID namespace and each of the following entries
       contains the PID in the corresponding ancestor PID namespace.
       The number of PID namespaces in which a PID should be set is
       defined by <i>set_tid_size</i> which cannot be larger than the number of
       currently nested PID namespaces.

       To create a process with the following PIDs in a PID namespace
       hierarchy:
           <b>PID NS level   Requested PID   Notes</b>
           0              31496           Outermost PID namespace
           1              42
           2              7               Innermost PID namespace

       Set the array to:

           set_tid[0] = 7;
           set_tid[1] = 42;
           set_tid[2] = 31496;
           set_tid_size = 3;

       If only the PIDs in the two innermost PID namespaces need to be
       specified, set the array to:

           set_tid[0] = 7;
           set_tid[1] = 42;
           set_tid_size = 2;

       The PID in the PID namespaces outside the two innermost PID
       namespaces is selected the same way as any other PID is selected.

       The <i>set_tid</i> feature requires <b>CAP_SYS_ADMIN </b>or (since Linux 5.9)
       <b>CAP_CHECKPOINT_RESTORE </b>in all owning user namespaces of the
       target PID namespaces.

       Callers may only choose a PID greater than 1 in a given PID
       namespace if an <b>init </b>process (i.e., a process with PID 1) already
       exists in that namespace.  Otherwise the PID entry for this PID
       namespace must be 1.

   <b>The flags mask</b>
       Both <b>clone</b>() and <b>clone3</b>() allow a flags bit mask that modifies
       their behavior and allows the caller to specify what is shared
       between the calling process and the child process.  This bit
       mask—the <i>flags</i> argument of <b>clone</b>() or the <i>cl_args.flags</i> field
       passed to <b>clone3</b>()—is referred to as the <i>flags</i> mask in the
       remainder of this page.

       The <i>flags</i> mask is specified as a bitwise OR of zero or more of
       the constants listed below.  Except as noted below, these flags
       are available (and have the same effect) in both <b>clone</b>() and
       <b>clone3</b>().

       <b>CLONE_CHILD_CLEARTID </b>(since Linux 2.5.49)
              Clear (zero) the child thread ID at the location pointed
              to by <i>child_tid</i> (<b>clone</b>()) or <i>cl_args.child_tid</i> (<b>clone3</b>())
              in child memory when the child exits, and do a wakeup on
              the futex at that address.  The address involved may be
              changed by the <a href="set_tid_address.2.html">set_tid_address(2)</a> system call.  This is
              used by threading libraries.

       <b>CLONE_CHILD_SETTID </b>(since Linux 2.5.49)
              Store the child thread ID at the location pointed to by
              <i>child_tid</i> (<b>clone</b>()) or <i>cl_args.child_tid</i> (<b>clone3</b>()) in the
              child's memory.  The store operation completes before the
              clone call returns control to user space in the child
              process.  (Note that the store operation may not have
              completed before the clone call returns in the parent
              process, which is relevant if the <b>CLONE_VM </b>flag is also
              employed.)

       <b>CLONE_CLEAR_SIGHAND </b>(since Linux 5.5)
              By default, signal dispositions in the child thread are
              the same as in the parent.  If this flag is specified,
              then all signals that are handled in the parent (and not
              set to <b>SIG_IGN</b>) are reset to their default dispositions
              (<b>SIG_DFL</b>) in the child.

              Specifying this flag together with <b>CLONE_SIGHAND </b>is
              nonsensical and disallowed.

       <b>CLONE_DETACHED </b>(historical)
              For a while (during the Linux 2.5 development series)
              there was a <b>CLONE_DETACHED </b>flag, which caused the parent
              not to receive a signal when the child terminated.
              Ultimately, the effect of this flag was subsumed under the
              <b>CLONE_THREAD </b>flag and by the time Linux 2.6.0 was
              released, this flag had no effect.  Starting in Linux
              2.6.2, the need to give this flag together with
              <b>CLONE_THREAD </b>disappeared.

              This flag is still defined, but it is usually ignored when
              calling <b>clone</b>().  However, see the description of
              <b>CLONE_PIDFD </b>for some exceptions.

       <b>CLONE_FILES </b>(since Linux 2.0)
              If <b>CLONE_FILES </b>is set, the calling process and the child
              process share the same file descriptor table.  Any file
              descriptor created by the calling process or by the child
              process is also valid in the other process.  Similarly, if
              one of the processes closes a file descriptor, or changes
              its associated flags (using the <a href="fcntl.2.html">fcntl(2)</a> <b>F_SETFD</b>
              operation), the other process is also affected.  If a
              process sharing a file descriptor table calls <a href="execve.2.html">execve(2)</a>,
              its file descriptor table is duplicated (unshared).

              If <b>CLONE_FILES </b>is not set, the child process inherits a
              copy of all file descriptors opened in the calling process
              at the time of the clone call.  Subsequent operations that
              open or close file descriptors, or change file descriptor
              flags, performed by either the calling process or the
              child process do not affect the other process.  Note,
              however, that the duplicated file descriptors in the child
              refer to the same open file descriptions as the
              corresponding file descriptors in the calling process, and
              thus share file offsets and file status flags (see
              <a href="open.2.html">open(2)</a>).

       <b>CLONE_FS </b>(since Linux 2.0)
              If <b>CLONE_FS </b>is set, the caller and the child process share
              the same filesystem information.  This includes the root
              of the filesystem, the current working directory, and the
              umask.  Any call to <a href="chroot.2.html">chroot(2)</a>, <a href="chdir.2.html">chdir(2)</a>, or <a href="umask.2.html">umask(2)</a>
              performed by the calling process or the child process also
              affects the other process.

              If <b>CLONE_FS </b>is not set, the child process works on a copy
              of the filesystem information of the calling process at
              the time of the clone call.  Calls to <a href="chroot.2.html">chroot(2)</a>, <a href="chdir.2.html">chdir(2)</a>,
              or <a href="umask.2.html">umask(2)</a> performed later by one of the processes do not
              affect the other process.

       <b>CLONE_INTO_CGROUP </b>(since Linux 5.7)
              By default, a child process is placed in the same version
              2 cgroup as its parent.  The <b>CLONE_INTO_CGROUP </b>flag allows
              the child process to be created in a different version 2
              cgroup.  (Note that <b>CLONE_INTO_CGROUP </b>has effect only for
              version 2 cgroups.)

              In order to place the child process in a different cgroup,
              the caller specifies <b>CLONE_INTO_CGROUP </b>in <i>cl_args.flags</i>
              and passes a file descriptor that refers to a version 2
              cgroup in the <i>cl_args.cgroup</i> field.  (This file descriptor
              can be obtained by opening a cgroup v2 directory using
              either the <b>O_RDONLY </b>or the <b>O_PATH </b>flag.)  Note that all of
              the usual restrictions (described in <a href="../man7/cgroups.7.html">cgroups(7)</a>) on
              placing a process into a version 2 cgroup apply.

              Among the possible use cases for <b>CLONE_INTO_CGROUP </b>are the
              following:

              •  Spawning a process into a cgroup different from the
                 parent's cgroup makes it possible for a service manager
                 to directly spawn new services into dedicated cgroups.
                 This eliminates the accounting jitter that would be
                 caused if the child process was first created in the
                 same cgroup as the parent and then moved into the
                 target cgroup.  Furthermore, spawning the child process
                 directly into a target cgroup is significantly cheaper
                 than moving the child process into the target cgroup
                 after it has been created.

              •  The <b>CLONE_INTO_CGROUP </b>flag also allows the creation of
                 frozen child processes by spawning them into a frozen
                 cgroup.  (See <a href="../man7/cgroups.7.html">cgroups(7)</a> for a description of the
                 freezer controller.)

              •  For threaded applications (or even thread
                 implementations which make use of cgroups to limit
                 individual threads), it is possible to establish a
                 fixed cgroup layout before spawning each thread
                 directly into its target cgroup.

       <b>CLONE_IO </b>(since Linux 2.6.25)
              If <b>CLONE_IO </b>is set, then the new process shares an I/O
              context with the calling process.  If this flag is not
              set, then (as with <a href="fork.2.html">fork(2)</a>) the new process has its own
              I/O context.

              The I/O context is the I/O scope of the disk scheduler
              (i.e., what the I/O scheduler uses to model scheduling of
              a process's I/O).  If processes share the same I/O
              context, they are treated as one by the I/O scheduler.  As
              a consequence, they get to share disk time.  For some I/O
              schedulers, if two processes share an I/O context, they
              will be allowed to interleave their disk access.  If
              several threads are doing I/O on behalf of the same
              process (<a href="../man3/aio_read.3.html">aio_read(3)</a>, for instance), they should employ
              <b>CLONE_IO </b>to get better I/O performance.

              If the kernel is not configured with the <b>CONFIG_BLOCK</b>
              option, this flag is a no-op.

       <b>CLONE_NEWCGROUP </b>(since Linux 4.6)
              Create the process in a new cgroup namespace.  If this
              flag is not set, then (as with <a href="fork.2.html">fork(2)</a>) the process is
              created in the same cgroup namespaces as the calling
              process.

              For further information on cgroup namespaces, see
              <a href="../man7/cgroup_namespaces.7.html">cgroup_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWCGROUP</b>.

       <b>CLONE_NEWIPC </b>(since Linux 2.6.19)
              If <b>CLONE_NEWIPC </b>is set, then create the process in a new
              IPC namespace.  If this flag is not set, then (as with
              <a href="fork.2.html">fork(2)</a>), the process is created in the same IPC namespace
              as the calling process.

              For further information on IPC namespaces, see
              <a href="../man7/ipc_namespaces.7.html">ipc_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWIPC</b>.  This flag can't be specified in conjunction
              with <b>CLONE_SYSVSEM</b>.

       <b>CLONE_NEWNET </b>(since Linux 2.6.24)
              (The implementation of this flag was completed only by
              about Linux 2.6.29.)

              If <b>CLONE_NEWNET </b>is set, then create the process in a new
              network namespace.  If this flag is not set, then (as with
              <a href="fork.2.html">fork(2)</a>) the process is created in the same network
              namespace as the calling process.

              For further information on network namespaces, see
              <a href="../man7/network_namespaces.7.html">network_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWNET</b>.

       <b>CLONE_NEWNS </b>(since Linux 2.4.19)
              If <b>CLONE_NEWNS </b>is set, the cloned child is started in a
              new mount namespace, initialized with a copy of the
              namespace of the parent.  If <b>CLONE_NEWNS </b>is not set, the
              child lives in the same mount namespace as the parent.

              For further information on mount namespaces, see
              <a href="../man7/namespaces.7.html">namespaces(7)</a> and <a href="../man7/mount_namespaces.7.html">mount_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWNS</b>.  It is not permitted to specify both
              <b>CLONE_NEWNS </b>and <b>CLONE_FS </b>in the same clone call.

       <b>CLONE_NEWPID </b>(since Linux 2.6.24)
              If <b>CLONE_NEWPID </b>is set, then create the process in a new
              PID namespace.  If this flag is not set, then (as with
              <a href="fork.2.html">fork(2)</a>) the process is created in the same PID namespace
              as the calling process.

              For further information on PID namespaces, see
              <a href="../man7/namespaces.7.html">namespaces(7)</a> and <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWPID</b>.  This flag can't be specified in conjunction
              with <b>CLONE_THREAD</b>.

       <b>CLONE_NEWUSER</b>
              (This flag first became meaningful for <b>clone</b>() in Linux
              2.6.23, the current <b>clone</b>() semantics were merged in Linux
              3.5, and the final pieces to make the user namespaces
              completely usable were merged in Linux 3.8.)

              If <b>CLONE_NEWUSER </b>is set, then create the process in a new
              user namespace.  If this flag is not set, then (as with
              <a href="fork.2.html">fork(2)</a>) the process is created in the same user namespace
              as the calling process.

              For further information on user namespaces, see
              <a href="../man7/namespaces.7.html">namespaces(7)</a> and <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>.

              Before Linux 3.8, use of <b>CLONE_NEWUSER </b>required that the
              caller have three capabilities: <b>CAP_SYS_ADMIN</b>, <b>CAP_SETUID</b>,
              and <b>CAP_SETGID</b>.  Starting with Linux 3.8, no privileges
              are needed to create a user namespace.

              This flag can't be specified in conjunction with
              <b>CLONE_THREAD </b>or <b>CLONE_PARENT</b>.  For security reasons,
              <b>CLONE_NEWUSER </b>cannot be specified in conjunction with
              <b>CLONE_FS</b>.

       <b>CLONE_NEWUTS </b>(since Linux 2.6.19)
              If <b>CLONE_NEWUTS </b>is set, then create the process in a new
              UTS namespace, whose identifiers are initialized by
              duplicating the identifiers from the UTS namespace of the
              calling process.  If this flag is not set, then (as with
              <a href="fork.2.html">fork(2)</a>) the process is created in the same UTS namespace
              as the calling process.

              For further information on UTS namespaces, see
              <a href="../man7/uts_namespaces.7.html">uts_namespaces(7)</a>.

              Only a privileged process (<b>CAP_SYS_ADMIN</b>) can employ
              <b>CLONE_NEWUTS</b>.

       <b>CLONE_PARENT </b>(since Linux 2.3.12)
              If <b>CLONE_PARENT </b>is set, then the parent of the new child
              (as returned by <a href="getppid.2.html">getppid(2)</a>) will be the same as that of
              the calling process.

              If <b>CLONE_PARENT </b>is not set, then (as with <a href="fork.2.html">fork(2)</a>) the
              child's parent is the calling process.

              Note that it is the parent process, as returned by
              <a href="getppid.2.html">getppid(2)</a>, which is signaled when the child terminates,
              so that if <b>CLONE_PARENT </b>is set, then the parent of the
              calling process, rather than the calling process itself,
              is signaled.

              The <b>CLONE_PARENT </b>flag can't be used in clone calls by the
              global init process (PID 1 in the initial PID namespace)
              and init processes in other PID namespaces.  This
              restriction prevents the creation of multi-rooted process
              trees as well as the creation of unreapable zombies in the
              initial PID namespace.

       <b>CLONE_PARENT_SETTID </b>(since Linux 2.5.49)
              Store the child thread ID at the location pointed to by
              <i>parent_tid</i> (<b>clone</b>()) or <i>cl_args.parent_tid</i> (<b>clone3</b>()) in
              the parent's memory.  (In Linux 2.5.32-2.5.48 there was a
              flag <b>CLONE_SETTID </b>that did this.)  The store operation
              completes before the clone call returns control to user
              space.

       <b>CLONE_PID </b>(Linux 2.0 to Linux 2.5.15)
              If <b>CLONE_PID </b>is set, the child process is created with the
              same process ID as the calling process.  This is good for
              hacking the system, but otherwise of not much use.  From
              Linux 2.3.21 onward, this flag could be specified only by
              the system boot process (PID 0).  The flag disappeared
              completely from the kernel sources in Linux 2.5.16.
              Subsequently, the kernel silently ignored this bit if it
              was specified in the <i>flags</i> mask.  Much later, the same bit
              was recycled for use as the <b>CLONE_PIDFD </b>flag.

       <b>CLONE_PIDFD </b>(since Linux 5.2)
              If this flag is specified, a PID file descriptor referring
              to the child process is allocated and placed at a
              specified location in the parent's memory.  The close-on-
              exec flag is set on this new file descriptor.  PID file
              descriptors can be used for the purposes described in
              <a href="pidfd_open.2.html">pidfd_open(2)</a>.

              •  When using <b>clone3</b>(), the PID file descriptor is placed
                 at the location pointed to by <i>cl_args.pidfd</i>.

              •  When using <b>clone</b>(), the PID file descriptor is placed
                 at the location pointed to by <i>parent_tid</i>.  Since the
                 <i>parent_tid</i> argument is used to return the PID file
                 descriptor, <b>CLONE_PIDFD </b>cannot be used with
                 <b>CLONE_PARENT_SETTID </b>when calling <b>clone</b>().

              It is currently not possible to use this flag together
              with <b>CLONE_THREAD.  </b>This means that the process identified
              by the PID file descriptor will always be a thread group
              leader.

              If the obsolete <b>CLONE_DETACHED </b>flag is specified alongside
              <b>CLONE_PIDFD </b>when calling <b>clone</b>(), an error is returned.
              An error also results if <b>CLONE_DETACHED </b>is specified when
              calling <b>clone3</b>().  This error behavior ensures that the
              bit corresponding to <b>CLONE_DETACHED </b>can be reused for
              further PID file descriptor features in the future.

       <b>CLONE_PTRACE </b>(since Linux 2.2)
              If <b>CLONE_PTRACE </b>is specified, and the calling process is
              being traced, then trace the child also (see <a href="ptrace.2.html">ptrace(2)</a>).

       <b>CLONE_SETTLS </b>(since Linux 2.5.32)
              The TLS (Thread Local Storage) descriptor is set to <i>tls</i>.

              The interpretation of <i>tls</i> and the resulting effect is
              architecture dependent.  On x86, <i>tls</i> is interpreted as a
              <i>struct user_desc *</i> (see <a href="set_thread_area.2.html">set_thread_area(2)</a>).  On x86-64 it
              is the new value to be set for the %fs base register (see
              the <b>ARCH_SET_FS </b>argument to <a href="arch_prctl.2.html">arch_prctl(2)</a>).  On
              architectures with a dedicated TLS register, it is the new
              value of that register.

              Use of this flag requires detailed knowledge and generally
              it should not be used except in libraries implementing
              threading.

       <b>CLONE_SIGHAND </b>(since Linux 2.0)
              If <b>CLONE_SIGHAND </b>is set, the calling process and the child
              process share the same table of signal handlers.  If the
              calling process or child process calls <a href="sigaction.2.html">sigaction(2)</a> to
              change the behavior associated with a signal, the behavior
              is changed in the other process as well.  However, the
              calling process and child processes still have distinct
              signal masks and sets of pending signals.  So, one of them
              may block or unblock signals using <a href="sigprocmask.2.html">sigprocmask(2)</a> without
              affecting the other process.

              If <b>CLONE_SIGHAND </b>is not set, the child process inherits a
              copy of the signal handlers of the calling process at the
              time of the clone call.  Calls to <a href="sigaction.2.html">sigaction(2)</a> performed
              later by one of the processes have no effect on the other
              process.

              Since Linux 2.6.0, the <i>flags</i> mask must also include
              <b>CLONE_VM </b>if <b>CLONE_SIGHAND </b>is specified.

       <b>CLONE_STOPPED </b>(since Linux 2.6.0)
              If <b>CLONE_STOPPED </b>is set, then the child is initially
              stopped (as though it was sent a <b>SIGSTOP </b>signal), and must
              be resumed by sending it a <b>SIGCONT </b>signal.

              This flag was <i>deprecated</i> from Linux 2.6.25 onward, and was
              <i>removed</i> altogether in Linux 2.6.38.  Since then, the
              kernel silently ignores it without error.  Starting with
              Linux 4.6, the same bit was reused for the <b>CLONE_NEWCGROUP</b>
              flag.

       <b>CLONE_SYSVSEM </b>(since Linux 2.5.10)
              If <b>CLONE_SYSVSEM </b>is set, then the child and the calling
              process share a single list of System V semaphore
              adjustment (<i>semadj</i>) values (see <a href="semop.2.html">semop(2)</a>).  In this case,
              the shared list accumulates <i>semadj</i> values across all
              processes sharing the list, and semaphore adjustments are
              performed only when the last process that is sharing the
              list terminates (or ceases sharing the list using
              <a href="unshare.2.html">unshare(2)</a>).  If this flag is not set, then the child has
              a separate <i>semadj</i> list that is initially empty.

       <b>CLONE_THREAD </b>(since Linux 2.4.0)
              If <b>CLONE_THREAD </b>is set, the child is placed in the same
              thread group as the calling process.  To make the
              remainder of the discussion of <b>CLONE_THREAD </b>more readable,
              the term "thread" is used to refer to the processes within
              a thread group.

              Thread groups were a feature added in Linux 2.4 to support
              the POSIX threads notion of a set of threads that share a
              single PID.  Internally, this shared PID is the so-called
              thread group identifier (TGID) for the thread group.
              Since Linux 2.4, calls to <a href="getpid.2.html">getpid(2)</a> return the TGID of the
              caller.

              The threads within a group can be distinguished by their
              (system-wide) unique thread IDs (TID).  A new thread's TID
              is available as the function result returned to the
              caller, and a thread can obtain its own TID using
              <a href="gettid.2.html">gettid(2)</a>.

              When a clone call is made without specifying <b>CLONE_THREAD</b>,
              then the resulting thread is placed in a new thread group
              whose TGID is the same as the thread's TID.  This thread
              is the <i>leader</i> of the new thread group.

              A new thread created with <b>CLONE_THREAD </b>has the same parent
              process as the process that made the clone call (i.e.,
              like <b>CLONE_PARENT</b>), so that calls to <a href="getppid.2.html">getppid(2)</a> return the
              same value for all of the threads in a thread group.  When
              a <b>CLONE_THREAD </b>thread terminates, the thread that created
              it is not sent a <b>SIGCHLD </b>(or other termination) signal;
              nor can the status of such a thread be obtained using
              <a href="wait.2.html">wait(2)</a>.  (The thread is said to be <i>detached</i>.)

              After all of the threads in a thread group terminate the
              parent process of the thread group is sent a <b>SIGCHLD </b>(or
              other termination) signal.

              If any of the threads in a thread group performs an
              <a href="execve.2.html">execve(2)</a>, then all threads other than the thread group
              leader are terminated, and the new program is executed in
              the thread group leader.

              If one of the threads in a thread group creates a child
              using <a href="fork.2.html">fork(2)</a>, then any thread in the group can <a href="wait.2.html">wait(2)</a>
              for that child.

              Since Linux 2.5.35, the <i>flags</i> mask must also include
              <b>CLONE_SIGHAND </b>if <b>CLONE_THREAD </b>is specified (and note that,
              since Linux 2.6.0, <b>CLONE_SIGHAND </b>also requires <b>CLONE_VM </b>to
              be included).

              Signal dispositions and actions are process-wide: if an
              unhandled signal is delivered to a thread, then it will
              affect (terminate, stop, continue, be ignored in) all
              members of the thread group.

              Each thread has its own signal mask, as set by
              <a href="sigprocmask.2.html">sigprocmask(2)</a>.

              A signal may be process-directed or thread-directed.  A
              process-directed signal is targeted at a thread group
              (i.e., a TGID), and is delivered to an arbitrarily
              selected thread from among those that are not blocking the
              signal.  A signal may be process-directed because it was
              generated by the kernel for reasons other than a hardware
              exception, or because it was sent using <a href="kill.2.html">kill(2)</a> or
              <a href="../man3/sigqueue.3.html">sigqueue(3)</a>.  A thread-directed signal is targeted at
              (i.e., delivered to) a specific thread.  A signal may be
              thread directed because it was sent using <a href="tgkill.2.html">tgkill(2)</a> or
              <a href="../man3/pthread_sigqueue.3.html">pthread_sigqueue(3)</a>, or because the thread executed a
              machine language instruction that triggered a hardware
              exception (e.g., invalid memory access triggering <b>SIGSEGV</b>
              or a floating-point exception triggering <b>SIGFPE</b>).

              A call to <a href="sigpending.2.html">sigpending(2)</a> returns a signal set that is the
              union of the pending process-directed signals and the
              signals that are pending for the calling thread.

              If a process-directed signal is delivered to a thread
              group, and the thread group has installed a handler for
              the signal, then the handler is invoked in exactly one,
              arbitrarily selected member of the thread group that has
              not blocked the signal.  If multiple threads in a group
              are waiting to accept the same signal using
              <a href="sigwaitinfo.2.html">sigwaitinfo(2)</a>, the kernel will arbitrarily select one of
              these threads to receive the signal.

       <b>CLONE_UNTRACED </b>(since Linux 2.5.46)
              If <b>CLONE_UNTRACED </b>is specified, then a tracing process
              cannot force <b>CLONE_PTRACE </b>on this child process.

       <b>CLONE_VFORK </b>(since Linux 2.2)
              If <b>CLONE_VFORK </b>is set, the execution of the calling
              process is suspended until the child releases its virtual
              memory resources via a call to <a href="execve.2.html">execve(2)</a> or <a href="_exit.2.html">_exit(2)</a> (as
              with <a href="vfork.2.html">vfork(2)</a>).

              If <b>CLONE_VFORK </b>is not set, then both the calling process
              and the child are schedulable after the call, and an
              application should not rely on execution occurring in any
              particular order.

       <b>CLONE_VM </b>(since Linux 2.0)
              If <b>CLONE_VM </b>is set, the calling process and the child
              process run in the same memory space.  In particular,
              memory writes performed by the calling process or by the
              child process are also visible in the other process.
              Moreover, any memory mapping or unmapping performed with
              <a href="mmap.2.html">mmap(2)</a> or <a href="munmap.2.html">munmap(2)</a> by the child or calling process also
              affects the other process.

              If <b>CLONE_VM </b>is not set, the child process runs in a
              separate copy of the memory space of the calling process
              at the time of the clone call.  Memory writes or file
              mappings/unmappings performed by one of the processes do
              not affect the other, as with <a href="fork.2.html">fork(2)</a>.

              If the <b>CLONE_VM </b>flag is specified and the <b>CLONE_VFORK </b>flag
              is not specified, then any alternate signal stack that was
              established by <a href="sigaltstack.2.html">sigaltstack(2)</a> is cleared in the child
              process.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       On success, the thread ID of the child process is returned in the
       caller's thread of execution.  On failure, -1 is returned in the
       caller's context, no child process is created, and <i><a href="../man3/errno.3.html">errno</a></i> is set
       to indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EACCES </b>(<b>clone3</b>() only)
              <b>CLONE_INTO_CGROUP </b>was specified in <i>cl_args.flags</i>, but the
              restrictions (described in <a href="../man7/cgroups.7.html">cgroups(7)</a>) on placing the
              child process into the version 2 cgroup referred to by
              <i>cl_args.cgroup</i> are not met.

       <b>EAGAIN </b>Too many processes are already running; see <a href="fork.2.html">fork(2)</a>.

       <b>EBUSY </b>(<b>clone3</b>() only)
              <b>CLONE_INTO_CGROUP </b>was specified in <i>cl_args.flags</i>, but the
              file descriptor specified in <i>cl_args.cgroup</i> refers to a
              version 2 cgroup in which a domain controller is enabled.

       <b>EEXIST </b>(<b>clone3</b>() only)
              One (or more) of the PIDs specified in <i>set_tid</i> already
              exists in the corresponding PID namespace.

       <b>EINVAL </b>Both <b>CLONE_SIGHAND </b>and <b>CLONE_CLEAR_SIGHAND </b>were specified
              in the <i>flags</i> mask.

       <b>EINVAL CLONE_SIGHAND </b>was specified in the <i>flags</i> mask, but
              <b>CLONE_VM </b>was not.  (Since Linux 2.6.0.)

       <b>EINVAL CLONE_THREAD </b>was specified in the <i>flags</i> mask, but
              <b>CLONE_SIGHAND </b>was not.  (Since Linux 2.5.35.)

       <b>EINVAL CLONE_THREAD </b>was specified in the <i>flags</i> mask, but the
              current process previously called <a href="unshare.2.html">unshare(2)</a> with the
              <b>CLONE_NEWPID </b>flag or used <a href="setns.2.html">setns(2)</a> to reassociate itself
              with a PID namespace.

       <b>EINVAL </b>Both <b>CLONE_FS </b>and <b>CLONE_NEWNS </b>were specified in the <i>flags</i>
              mask.

       <b>EINVAL </b>(since Linux 3.9)
              Both <b>CLONE_NEWUSER </b>and <b>CLONE_FS </b>were specified in the
              <i>flags</i> mask.

       <b>EINVAL </b>Both <b>CLONE_NEWIPC </b>and <b>CLONE_SYSVSEM </b>were specified in the
              <i>flags</i> mask.

       <b>EINVAL CLONE_NEWPID </b>and one (or both) of <b>CLONE_THREAD </b>or
              <b>CLONE_PARENT </b>were specified in the <i>flags</i> mask.

       <b>EINVAL CLONE_NEWUSER </b>and <b>CLONE_THREAD </b>were specified in the <i>flags</i>
              mask.

       <b>EINVAL </b>(since Linux 2.6.32)
              <b>CLONE_PARENT </b>was specified, and the caller is an init
              process.

       <b>EINVAL </b>Returned by the glibc <b>clone</b>() wrapper function when <i>fn</i> or
              <i>stack</i> is specified as NULL.

       <b>EINVAL CLONE_NEWIPC </b>was specified in the <i>flags</i> mask, but the
              kernel was not configured with the <b>CONFIG_SYSVIPC </b>and
              <b>CONFIG_IPC_NS </b>options.

       <b>EINVAL CLONE_NEWNET </b>was specified in the <i>flags</i> mask, but the
              kernel was not configured with the <b>CONFIG_NET_NS </b>option.

       <b>EINVAL CLONE_NEWPID </b>was specified in the <i>flags</i> mask, but the
              kernel was not configured with the <b>CONFIG_PID_NS </b>option.

       <b>EINVAL CLONE_NEWUSER </b>was specified in the <i>flags</i> mask, but the
              kernel was not configured with the <b>CONFIG_USER_NS </b>option.

       <b>EINVAL CLONE_NEWUTS </b>was specified in the <i>flags</i> mask, but the
              kernel was not configured with the <b>CONFIG_UTS_NS </b>option.

       <b>EINVAL </b><i>stack</i> is not aligned to a suitable boundary for this
              architecture.  For example, on aarch64, <i>stack</i> must be a
              multiple of 16.

       <b>EINVAL </b>(<b>clone3</b>() only)
              <b>CLONE_DETACHED </b>was specified in the <i>flags</i> mask.

       <b>EINVAL </b>(<b>clone</b>() only)
              <b>CLONE_PIDFD </b>was specified together with <b>CLONE_DETACHED </b>in
              the <i>flags</i> mask.

       <b>EINVAL CLONE_PIDFD </b>was specified together with <b>CLONE_THREAD </b>in
              the <i>flags</i> mask.

       <b>EINVAL </b>(<b>clone</b>() only)
              <b>CLONE_PIDFD </b>was specified together with
              <b>CLONE_PARENT_SETTID </b>in the <i>flags</i> mask.

       <b>EINVAL </b>(<b>clone3</b>() only)
              <i>set_tid_size</i> is greater than the number of nested PID
              namespaces.

       <b>EINVAL </b>(<b>clone3</b>() only)
              One of the PIDs specified in <i>set_tid</i> was an invalid.

       <b>EINVAL </b>(<b>clone3</b>() only)
              <b>CLONE_THREAD </b>or <b>CLONE_PARENT </b>was specified in the <i>flags</i>
              mask, but a signal was specified in <i>exit_signal</i>.

       <b>EINVAL </b>(AArch64 only, Linux 4.6 and earlier)
              <i>stack</i> was not aligned to a 128-bit boundary.

       <b>ENOMEM </b>Cannot allocate sufficient memory to allocate a task
              structure for the child, or to copy those parts of the
              caller's context that need to be copied.

       <b>ENOSPC </b>(since Linux 3.7)
              <b>CLONE_NEWPID </b>was specified in the <i>flags</i> mask, but the
              limit on the nesting depth of PID namespaces would have
              been exceeded; see <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>.

       <b>ENOSPC </b>(since Linux 4.9; beforehand <b>EUSERS</b>)
              <b>CLONE_NEWUSER </b>was specified in the <i>flags</i> mask, and the
              call would cause the limit on the number of nested user
              namespaces to be exceeded.  See <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>.

              From Linux 3.11 to Linux 4.8, the error diagnosed in this
              case was <b>EUSERS</b>.

       <b>ENOSPC </b>(since Linux 4.9)
              One of the values in the <i>flags</i> mask specified the creation
              of a new user namespace, but doing so would have caused
              the limit defined by the corresponding file in
              <i>/proc/sys/user</i> to be exceeded.  For further details, see
              <a href="../man7/namespaces.7.html">namespaces(7)</a>.

       <b>EOPNOTSUPP </b>(<b>clone3</b>() only)
              <b>CLONE_INTO_CGROUP </b>was specified in <i>cl_args.flags</i>, but the
              file descriptor specified in <i>cl_args.cgroup</i> refers to a
              version 2 cgroup that is in the <i>domain invalid</i> state.

       <b>EPERM  CLONE_NEWCGROUP</b>, <b>CLONE_NEWIPC</b>, <b>CLONE_NEWNET</b>, <b>CLONE_NEWNS</b>,
              <b>CLONE_NEWPID</b>, or <b>CLONE_NEWUTS </b>was specified by an
              unprivileged process (process without <b>CAP_SYS_ADMIN</b>).

       <b>EPERM  CLONE_PID </b>was specified by a process other than process 0.
              (This error occurs only on Linux 2.5.15 and earlier.)

       <b>EPERM  CLONE_NEWUSER </b>was specified in the <i>flags</i> mask, but either
              the effective user ID or the effective group ID of the
              caller does not have a mapping in the parent namespace
              (see <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>).

       <b>EPERM </b>(since Linux 3.9)
              <b>CLONE_NEWUSER </b>was specified in the <i>flags</i> mask and the
              caller is in a chroot environment (i.e., the caller's root
              directory does not match the root directory of the mount
              namespace in which it resides).

       <b>EPERM </b>(<b>clone3</b>() only)
              <i>set_tid_size</i> was greater than zero, and the caller lacks
              the <b>CAP_SYS_ADMIN </b>capability in one or more of the user
              namespaces that own the corresponding PID namespaces.

       <b>ERESTARTNOINTR </b>(since Linux 2.6.17)
              System call was interrupted by a signal and will be
              restarted.  (This can be seen only during a trace.)

       <b>EUSERS </b>(Linux 3.11 to Linux 4.8)
              <b>CLONE_NEWUSER </b>was specified in the <i>flags</i> mask, and the
              limit on the number of nested user namespaces would be
              exceeded.  See the discussion of the <b>ENOSPC </b>error above.
</pre> <h2>
VERSIONS </h2>
<pre>
       The glibc <b>clone</b>() wrapper function makes some changes in the
       memory pointed to by <i>stack</i> (changes required to set the stack up
       correctly for the child) <i>before</i> invoking the <b>clone</b>() system call.
       So, in cases where <b>clone</b>() is used to recursively create
       children, do not use the buffer employed for the parent's stack
       as the stack of the child.

       On i386, <b>clone</b>() should not be called through vsyscall, but
       directly through <i>int $0x80</i>.

   <b>C library/kernel differences</b>
       The raw <b>clone</b>() system call corresponds more closely to <a href="fork.2.html">fork(2)</a>
       in that execution in the child continues from the point of the
       call.  As such, the <i>fn</i> and <i>arg</i> arguments of the <b>clone</b>() wrapper
       function are omitted.

       In contrast to the glibc wrapper, the raw <b>clone</b>() system call
       accepts NULL as a <i>stack</i> argument (and <b>clone3</b>() likewise allows
       <i>cl_args.stack</i> to be NULL).  In this case, the child uses a
       duplicate of the parent's stack.  (Copy-on-write semantics ensure
       that the child gets separate copies of stack pages when either
       process modifies the stack.)  In this case, for correct
       operation, the <b>CLONE_VM </b>option should not be specified.  (If the
       child <i>shares</i> the parent's memory because of the use of the
       <b>CLONE_VM </b>flag, then no copy-on-write duplication occurs and chaos
       is likely to result.)

       The order of the arguments also differs in the raw system call,
       and there are variations in the arguments across architectures,
       as detailed in the following paragraphs.

       The raw system call interface on x86-64 and some other
       architectures (including sh, tile, and alpha) is:

           <b>long clone(unsigned long </b><i>flags</i><b>, void *</b><i>stack</i><b>,</b>
                      <b>int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,</b>
                      <b>unsigned long </b><i>tls</i><b>);</b>

       On x86-32, and several other common architectures (including
       score, ARM, ARM 64, PA-RISC, arc, Power PC, xtensa, and MIPS),
       the order of the last two arguments is reversed:

           <b>long clone(unsigned long </b><i>flags</i><b>, void *</b><i>stack</i><b>,</b>
                     <b>int *</b><i>parent_tid</i><b>, unsigned long </b><i>tls</i><b>,</b>
                     <b>int *</b><i>child_tid</i><b>);</b>

       On the cris and s390 architectures, the order of the first two
       arguments is reversed:

           <b>long clone(void *</b><i>stack</i><b>, unsigned long </b><i>flags</i><b>,</b>
                      <b>int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,</b>
                      <b>unsigned long </b><i>tls</i><b>);</b>

       On the microblaze architecture, an additional argument is
       supplied:

           <b>long clone(unsigned long </b><i>flags</i><b>, void *</b><i>stack</i><b>,</b>
                      <b>int </b><i>stack_size</i><b>,         </b>/* Size of stack */
                      <b>int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,</b>
                      <b>unsigned long </b><i>tls</i><b>);</b>

   <b>blackfin, m68k, and sparc</b>
       The argument-passing conventions on blackfin, m68k, and sparc are
       different from the descriptions above.  For details, see the
       kernel (and glibc) source.

   <b>ia64</b>
       On ia64, a different interface is used:

           <b>int __clone2(int (*</b><i>fn</i><b>)(void *),</b>
                        <b>void *</b><i>stack_base</i><b>, size_t </b><i>stack_size</i><b>,</b>
                        <b>int </b><i>flags</i><b>, void *</b><i>arg</i><b>, ...</b>
                     <b>/* pid_t *</b><i>parent_tid</i><b>, struct user_desc *</b><i>tls</i><b>,</b>
                        <b>pid_t *</b><i>child_tid</i> <b>*/ );</b>

       The prototype shown above is for the glibc wrapper function; for
       the system call itself, the prototype can be described as follows
       (it is identical to the <b>clone</b>() prototype on microblaze):

           <b>long clone2(unsigned long </b><i>flags</i><b>, void *</b><i>stack_base</i><b>,</b>
                       <b>int </b><i>stack_size</i><b>,         </b>/* Size of stack */
                       <b>int *</b><i>parent_tid</i><b>, int *</b><i>child_tid</i><b>,</b>
                       <b>unsigned long </b><i>tls</i><b>);</b>

       <b>__clone2</b>() operates in the same way as <b>clone</b>(), except that
       <i>stack_base</i> points to the lowest address of the child's stack
       area, and <i>stack_size</i> specifies the size of the stack pointed to
       by <i>stack_base</i>.
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       <b>clone3</b>()
              Linux 5.3.

   <b>Linux 2.4 and earlier</b>
       In the Linux 2.4.x series, <b>CLONE_THREAD </b>generally does not make
       the parent of the new thread the same as the parent of the
       calling process.  However, from Linux 2.4.7 to Linux 2.4.18 the
       <b>CLONE_THREAD </b>flag implied the <b>CLONE_PARENT </b>flag (as in Linux
       2.6.0 and later).

       In Linux 2.4 and earlier, <b>clone</b>() does not take arguments
       <i>parent_tid</i>, <i>tls</i>, and <i>child_tid</i>.
</pre> <h2>
NOTES </h2>
<pre>
       One use of these system calls is to implement threads: multiple
       flows of control in a program that run concurrently in a shared
       address space.

       The <a href="kcmp.2.html">kcmp(2)</a> system call can be used to test whether two processes
       share various resources such as a file descriptor table, System V
       semaphore undo operations, or a virtual address space.

       Handlers registered using <a href="../man3/pthread_atfork.3.html">pthread_atfork(3)</a> are not executed
       during a clone call.
</pre> <h2>
BUGS </h2>
<pre>
       GNU C library versions 2.3.4 up to and including 2.24 contained a
       wrapper function for <a href="getpid.2.html">getpid(2)</a> that performed caching of PIDs.
       This caching relied on support in the glibc wrapper for <b>clone</b>(),
       but limitations in the implementation meant that the cache was
       not up to date in some circumstances.  In particular, if a signal
       was delivered to the child immediately after the <b>clone</b>() call,
       then a call to <a href="getpid.2.html">getpid(2)</a> in a handler for the signal could return
       the PID of the calling process ("the parent"), if the clone
       wrapper had not yet had a chance to update the PID cache in the
       child.  (This discussion ignores the case where the child was
       created using <b>CLONE_THREAD</b>, when <a href="getpid.2.html">getpid(2)</a> <i>should</i> return the same
       value in the child and in the process that called <b>clone</b>(), since
       the caller and the child are in the same thread group.  The
       stale-cache problem also does not occur if the <i>flags</i> argument
       includes <b>CLONE_VM</b>.)  To get the truth, it was sometimes necessary
       to use code such as the following:

           #include &lt;syscall.h&gt;

           pid_t mypid;

           mypid = syscall(SYS_getpid);

       Because of the stale-cache problem, as well as other problems
       noted in <a href="getpid.2.html">getpid(2)</a>, the PID caching feature was removed in glibc
       2.25.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The following program demonstrates the use of <b>clone</b>() to create a
       child process that executes in a separate UTS namespace.  The
       child changes the hostname in its UTS namespace.  Both parent and
       child then display the system hostname, making it possible to see
       that the hostname differs in the UTS namespaces of the parent and
       child.  For an example of the use of this program, see <a href="setns.2.html">setns(2)</a>.

       Within the sample program, we allocate the memory that is to be
       used for the child's stack using <a href="mmap.2.html">mmap(2)</a> rather than <a href="../man3/malloc.3.html">malloc(3)</a>
       for the following reasons:

       •  <a href="mmap.2.html">mmap(2)</a> allocates a block of memory that starts on a page
          boundary and is a multiple of the page size.  This is useful
          if we want to establish a guard page (a page with protection
          <b>PROT_NONE</b>) at the end of the stack using <a href="mprotect.2.html">mprotect(2)</a>.

       •  We can specify the <b>MAP_STACK </b>flag to request a mapping that is
          suitable for a stack.  For the moment, this flag is a no-op on
          Linux, but it exists and has effect on some other systems, so
          we should include it for portability.

   <b>Program source</b>
       #define _GNU_SOURCE
       #include &lt;err.h&gt;
       #include &lt;sched.h&gt;
       #include &lt;signal.h&gt;
       #include &lt;stdint.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/mman.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;sys/utsname.h&gt;
       #include &lt;sys/wait.h&gt;
       #include &lt;unistd.h&gt;

       static int              /* Start function for cloned child */
       childFunc(void *arg)
       {
           struct utsname uts;

           /* Change hostname in UTS namespace of child. */

           if (sethostname(arg, strlen(arg)) == -1)
               err(EXIT_FAILURE, "sethostname");

           /* Retrieve and display hostname. */

           if (uname(&amp;uts) == -1)
               err(EXIT_FAILURE, "uname");
           printf("uts.nodename in child:  %s\n", uts.nodename);

           /* Keep the namespace open for a while, by sleeping.
              This allows some experimentation--for example, another
              process might join the namespace. */

           sleep(200);

           return 0;           /* Child terminates now */
       }

       #define STACK_SIZE (1024 * 1024)    /* Stack size for cloned child */

       int
       main(int argc, char *argv[])
       {
           char            *stack;         /* Start of stack buffer */
           char            *stackTop;      /* End of stack buffer */
           pid_t           pid;
           struct utsname  uts;

           if (argc &lt; 2) {
               fprintf(stderr, "Usage: %s &lt;child-hostname&gt;\n", argv[0]);
               exit(EXIT_SUCCESS);
           }

           /* Allocate memory to be used for the stack of the child. */

           stack = mmap(NULL, STACK_SIZE, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS | MAP_STACK, -1, 0);
           if (stack == MAP_FAILED)
               err(EXIT_FAILURE, "mmap");

           stackTop = stack + STACK_SIZE;  /* Assume stack grows downward */

           /* Create child that has its own UTS namespace;
              child commences execution in childFunc(). */

           pid = clone(childFunc, stackTop, CLONE_NEWUTS | SIGCHLD, argv[1]);
           if (pid == -1)
               err(EXIT_FAILURE, "clone");
           printf("clone() returned %jd\n", (intmax_t) pid);

           /* Parent falls through to here */

           sleep(1);           /* Give child time to change its hostname */

           /* Display hostname in parent's UTS namespace. This will be
              different from hostname in child's UTS namespace. */

           if (uname(&amp;uts) == -1)
               err(EXIT_FAILURE, "uname");
           printf("uts.nodename in parent: %s\n", uts.nodename);

           if (waitpid(pid, NULL, 0) == -1)    /* Wait for child */
               err(EXIT_FAILURE, "waitpid");
           printf("child has terminated\n");

           exit(EXIT_SUCCESS);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="fork.2.html">fork(2)</a>, <a href="futex.2.html">futex(2)</a>, <a href="getpid.2.html">getpid(2)</a>, <a href="gettid.2.html">gettid(2)</a>, <a href="kcmp.2.html">kcmp(2)</a>, <a href="mmap.2.html">mmap(2)</a>,
       <a href="pidfd_open.2.html">pidfd_open(2)</a>, <a href="set_thread_area.2.html">set_thread_area(2)</a>, <a href="set_tid_address.2.html">set_tid_address(2)</a>, <a href="setns.2.html">setns(2)</a>,
       <a href="tkill.2.html">tkill(2)</a>, <a href="unshare.2.html">unshare(2)</a>, <a href="wait.2.html">wait(2)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/namespaces.7.html">namespaces(7)</a>,
       <a href="../man7/pthreads.7.html">pthreads(7)</a>
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                       <i>clone</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/kill.1.html">kill(1)</a>, <a href="../man1/nsenter.1.html">nsenter(1)</a>, <a href="../man1/strace.1.html">strace(1)</a>, <a href="../man1/unshare.1.html">unshare(1)</a>, <a href="arch_prctl.2.html">arch_prctl(2)</a>, <a href="capget.2.html">capget(2)</a>, <a href="execve.2.html">execve(2)</a>, <a href="fcntl.2.html">fcntl(2)</a>, <a href="fork.2.html">fork(2)</a>, <a href="getpid.2.html">getpid(2)</a>, <a href="get_robust_list.2.html">get_robust_list(2)</a>, <a href="gettid.2.html">gettid(2)</a>, <a href="ioprio_set.2.html">ioprio_set(2)</a>, <a href="kcmp.2.html">kcmp(2)</a>, <a href="mount.2.html">mount(2)</a>, <a href="mount_setattr.2.html">mount_setattr(2)</a>, <a href="ns_get_nstype.2const.html">NS_GET_NSTYPE(2const)</a>, <a href="openat2.2.html">openat2(2)</a>, <a href="pidfd_getfd.2.html">pidfd_getfd(2)</a>, <a href="pidfd_open.2.html">pidfd_open(2)</a>, <a href="pidfd_send_signal.2.html">pidfd_send_signal(2)</a>, <a href="pivot_root.2.html">pivot_root(2)</a>, <a href="pr_get_tid_address.2const.html">PR_GET_TID_ADDRESS(2const)</a>, <a href="pr_set_child_subreaper.2const.html">PR_SET_CHILD_SUBREAPER(2const)</a>, <a href="pr_set_no_new_privs.2const.html">PR_SET_NO_NEW_PRIVS(2const)</a>, <a href="pr_set_syscall_user_dispatch.2const.html">PR_SET_SYSCALL_USER_DISPATCH(2const)</a>, <a href="pr_set_tagged_addr_ctrl.2const.html">PR_SET_TAGGED_ADDR_CTRL(2const)</a>, <a href="pr_sve_set_vl.2const.html">PR_SVE_SET_VL(2const)</a>, <a href="ptrace.2.html">ptrace(2)</a>, <a href="sched_setaffinity.2.html">sched_setaffinity(2)</a>, <a href="seccomp.2.html">seccomp(2)</a>, <a href="semop.2.html">semop(2)</a>, <a href="set_mempolicy.2.html">set_mempolicy(2)</a>, <a href="setns.2.html">setns(2)</a>, <a href="set_tid_address.2.html">set_tid_address(2)</a>, <a href="sigaltstack.2.html">sigaltstack(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="timer_create.2.html">timer_create(2)</a>, <a href="tkill.2.html">tkill(2)</a>, <a href="unshare.2.html">unshare(2)</a>, <a href="userfaultfd.2.html">userfaultfd(2)</a>, <a href="vfork.2.html">vfork(2)</a>, <a href="wait.2.html">wait(2)</a>, <a href="../man3/lttng-ust.3.html">lttng-ust(3)</a>, <a href="../man3/posix_spawn.3.html">posix_spawn(3)</a>, <a href="../man4/veth.4.html">veth(4)</a>, <a href="../man5/core.5.html">core(5)</a>, <a href="../man5/proc_pid_comm.5.html">proc_pid_comm(5)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/cgroup_namespaces.7.html">cgroup_namespaces(7)</a>, <a href="../man7/cgroups.7.html">cgroups(7)</a>, <a href="../man7/futex.7.html">futex(7)</a>, <a href="../man7/ipc_namespaces.7.html">ipc_namespaces(7)</a>, <a href="../man7/landlock.7.html">landlock(7)</a>, <a href="../man7/mount_namespaces.7.html">mount_namespaces(7)</a>, <a href="../man7/namespaces.7.html">namespaces(7)</a>, <a href="../man7/network_namespaces.7.html">network_namespaces(7)</a>, <a href="../man7/path_resolution.7.html">path_resolution(7)</a>, <a href="../man7/persistent-keyring.7.html">persistent-keyring(7)</a>, <a href="../man7/pid_namespaces.7.html">pid_namespaces(7)</a>, <a href="../man7/pkeys.7.html">pkeys(7)</a>, <a href="../man7/process-keyring.7.html">process-keyring(7)</a>, <a href="../man7/pthreads.7.html">pthreads(7)</a>, <a href="../man7/session-keyring.7.html">session-keyring(7)</a>, <a href="../man7/signal.7.html">signal(7)</a>, <a href="../man7/thread-keyring.7.html">thread-keyring(7)</a>, <a href="../man7/user-keyring.7.html">user-keyring(7)</a>, <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>, <a href="../man7/user-session-keyring.7.html">user-session-keyring(7)</a>, <a href="../man7/uts_namespaces.7.html">uts_namespaces(7)</a>, <a href="../man8/lsns.8.html">lsns(8)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/clone3.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/clone3.2.html</a>
  </p>
</div>
