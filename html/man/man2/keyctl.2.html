<h1>keyctl(2) — Linux manual page</h1>   <pre>
<span class="headline"><i>keyctl</i>(2)                  System Calls Manual                 <i>keyctl</i>(2)</span>
</pre> <h2>
NAME </h2>
<pre>
       keyctl - manipulate the kernel's key management facility
</pre> <h2>
LIBRARY </h2>
<pre>
       Standard C library (<i>libc</i>, <i>-lc</i>)

       Alternatively, Linux Key Management Utilities (<i>libkeyutils</i>,
       <i>-lkeyutils</i>); see VERSIONS.
</pre> <h2>
SYNOPSIS </h2>
<pre>
       <b>#include &lt;linux/keyctl.h&gt;     </b>/* Definition of <b>KEY* </b>constants */
       <b>#include &lt;sys/syscall.h&gt;      </b>/* Definition of <b>SYS_* </b>constants */
       <b>#include &lt;unistd.h&gt;</b>

       <b>long syscall(SYS_keyctl, int </b><i>operation</i><b>, unsigned long </b><i>arg2</i><b>,</b>
                    <b>unsigned long </b><i>arg3</i><b>, unsigned long </b><i>arg4</i><b>,</b>
                    <b>unsigned long </b><i>arg5</i><b>);</b>

       <i>Note</i>: glibc provides no wrapper for <b>keyctl</b>(), necessitating the
       use of <a href="syscall.2.html">syscall(2)</a>.
</pre> <h2>
DESCRIPTION </h2>
<pre>
       <b>keyctl</b>() allows user-space programs to perform key manipulation.

       The operation performed by <b>keyctl</b>() is determined by the value of
       the <i>operation</i> argument.  Each of these operations is wrapped by
       the <i>libkeyutils</i> library (provided by the <i>keyutils</i> package) into
       individual functions (noted below) to permit the compiler to
       check types.

       The permitted values for <i>operation</i> are:

       <b>KEYCTL_GET_KEYRING_ID </b>(since Linux 2.6.10)
              Map a special key ID to a real key ID for this process.

              This operation looks up the special key whose ID is
              provided in <i>arg2</i> (cast to <i>key_serial_t</i>).  If the special
              key is found, the ID of the corresponding real key is
              returned as the function result.  The following values may
              be specified in <i>arg2</i>:

              <b>KEY_SPEC_THREAD_KEYRING</b>
                     This specifies the calling thread's thread-specific
                     keyring.  See <a href="../man7/thread-keyring.7.html">thread-keyring(7)</a>.

              <b>KEY_SPEC_PROCESS_KEYRING</b>
                     This specifies the caller's process-specific
                     keyring.  See <a href="../man7/process-keyring.7.html">process-keyring(7)</a>.

              <b>KEY_SPEC_SESSION_KEYRING</b>
                     This specifies the caller's session-specific
                     keyring.  See <a href="../man7/session-keyring.7.html">session-keyring(7)</a>.

              <b>KEY_SPEC_USER_KEYRING</b>
                     This specifies the caller's UID-specific keyring.
                     See <a href="../man7/user-keyring.7.html">user-keyring(7)</a>.

              <b>KEY_SPEC_USER_SESSION_KEYRING</b>
                     This specifies the caller's UID-session keyring.
                     See <a href="../man7/user-session-keyring.7.html">user-session-keyring(7)</a>.

              <b>KEY_SPEC_REQKEY_AUTH_KEY </b>(since Linux 2.6.16)
                     This specifies the authorization key created by
                     <a href="request_key.2.html">request_key(2)</a> and passed to the process it spawns
                     to generate a key.  This key is available only in a
                     <a href="../man8/request-key.8.html">request-key(8)</a>-style program that was passed an
                     authorization key by the kernel and ceases to be
                     available once the requested key has been
                     instantiated; see <a href="request_key.2.html">request_key(2)</a>.

              <b>KEY_SPEC_REQUESTOR_KEYRING </b>(since Linux 2.6.29)
                     This specifies the key ID for the <a href="request_key.2.html">request_key(2)</a>
                     destination keyring.  This keyring is available
                     only in a <a href="../man8/request-key.8.html">request-key(8)</a>-style program that was
                     passed an authorization key by the kernel and
                     ceases to be available once the requested key has
                     been instantiated; see <a href="request_key.2.html">request_key(2)</a>.

              The behavior if the key specified in <i>arg2</i> does not exist
              depends on the value of <i>arg3</i> (cast to <i>int</i>).  If <i>arg3</i>
              contains a nonzero value, then—if it is appropriate to do
              so (e.g., when looking up the user, user-session, or
              session key)—a new key is created and its real key ID
              returned as the function result.  Otherwise, the operation
              fails with the error <b>ENOKEY</b>.

              If a valid key ID is specified in <i>arg2</i>, and the key
              exists, then this operation simply returns the key ID.  If
              the key does not exist, the call fails with error <b>ENOKEY</b>.

              The caller must have <i>search</i> permission on a keyring in
              order for it to be found.

              The arguments <i>arg4</i> and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_get_keyring_id.3.html">keyctl_get_keyring_ID(3)</a>.

       <b>KEYCTL_JOIN_SESSION_KEYRING </b>(since Linux 2.6.10)
              Replace the session keyring this process subscribes to
              with a new session keyring.

              If <i>arg2</i> is NULL, an anonymous keyring with the description
              "_ses" is created and the process is subscribed to that
              keyring as its session keyring, displacing the previous
              session keyring.

              Otherwise, <i>arg2</i> (cast to <i>char *</i>) is treated as the
              description (name) of a keyring, and the behavior is as
              follows:

              •  If a keyring with a matching description exists, the
                 process will attempt to subscribe to that keyring as
                 its session keyring if possible; if that is not
                 possible, an error is returned.  In order to subscribe
                 to the keyring, the caller must have <i>search</i> permission
                 on the keyring.

              •  If a keyring with a matching description does not
                 exist, then a new keyring with the specified
                 description is created, and the process is subscribed
                 to that keyring as its session keyring.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_join_session_keyring.3.html">keyctl_join_session_keyring(3)</a>.

       <b>KEYCTL_UPDATE </b>(since Linux 2.6.10)
              Update a key's data payload.

              The <i>arg2</i> argument (cast to <i>key_serial_t</i>) specifies the ID
              of the key to be updated.  The <i>arg3</i> argument (cast to
              <i>void *</i>) points to the new payload and <i>arg4</i> (cast to
              <i>size_t</i>) contains the new payload size in bytes.

              The caller must have <i>write</i> permission on the key specified
              and the key type must support updating.

              A negatively instantiated key (see the description of
              <b>KEYCTL_REJECT</b>) can be positively instantiated with this
              operation.

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_update.3.html">keyctl_update(3)</a>.

       <b>KEYCTL_REVOKE </b>(since Linux 2.6.10)
              Revoke the key with the ID provided in <i>arg2</i> (cast to
              <i>key_serial_t</i>).  The key is scheduled for garbage
              collection; it will no longer be findable, and will be
              unavailable for further operations.  Further attempts to
              use the key will fail with the error <b>EKEYREVOKED</b>.

              The caller must have <i>write</i> or <i>setattr</i> permission on the
              key.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_revoke.3.html">keyctl_revoke(3)</a>.

       <b>KEYCTL_CHOWN </b>(since Linux 2.6.10)
              Change the ownership (user and group ID) of a key.

              The <i>arg2</i> argument (cast to <i>key_serial_t</i>) contains the key
              ID.  The <i>arg3</i> argument (cast to <i>uid_t</i>) contains the new
              user ID (or -1 in case the user ID shouldn't be changed).
              The <i>arg4</i> argument (cast to <i>gid_t</i>) contains the new group
              ID (or -1 in case the group ID shouldn't be changed).

              The key must grant the caller <i>setattr</i> permission.

              For the UID to be changed, or for the GID to be changed to
              a group the caller is not a member of, the caller must
              have the <b>CAP_SYS_ADMIN </b>capability (see <a href="../man7/capabilities.7.html">capabilities(7)</a>).

              If the UID is to be changed, the new user must have
              sufficient quota to accept the key.  The quota deduction
              will be removed from the old user to the new user should
              the UID be changed.

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_chown.3.html">keyctl_chown(3)</a>.

       <b>KEYCTL_SETPERM </b>(since Linux 2.6.10)
              Change the permissions of the key with the ID provided in
              the <i>arg2</i> argument (cast to <i>key_serial_t</i>) to the
              permissions provided in the <i>arg3</i> argument (cast to
              <i>key_perm_t</i>).

              If the caller doesn't have the <b>CAP_SYS_ADMIN </b>capability,
              it can change permissions only for the keys it owns.
              (More precisely: the caller's filesystem UID must match
              the UID of the key.)

              The key must grant <i>setattr</i> permission to the caller
              <i>regardless</i> of the caller's capabilities.

              The permissions in <i>arg3</i> specify masks of available
              operations for each of the following user categories:

              <i>possessor</i> (since Linux 2.6.14)
                     This is the permission granted to a process that
                     possesses the key (has it attached searchably to
                     one of the process's keyrings); see <a href="../man7/keyrings.7.html">keyrings(7)</a>.

              <i>user</i>   This is the permission granted to a process whose
                     filesystem UID matches the UID of the key.

              <i>group</i>  This is the permission granted to a process whose
                     filesystem GID or any of its supplementary GIDs
                     matches the GID of the key.

              <i>other</i>  This is the permission granted to other processes
                     that do not match the <i>user</i> and <i>group</i> categories.

              The <i>user</i>, <i>group</i>, and <i>other</i> categories are exclusive: if a
              process matches the <i>user</i> category, it will not receive
              permissions granted in the <i>group</i> category; if a process
              matches the <i>user</i> or <i>group</i> category, then it will not
              receive permissions granted in the <i>other</i> category.

              The <i>possessor</i> category grants permissions that are
              cumulative with the grants from the <i>user</i>, <i>group</i>, or <i>other</i>
              category.

              Each permission mask is eight bits in size, with only six
              bits currently used.  The available permissions are:

              <i>view</i>   This permission allows reading attributes of a key.

                     This permission is required for the <b>KEYCTL_DESCRIBE</b>
                     operation.

                     The permission bits for each category are
                     <b>KEY_POS_VIEW</b>, <b>KEY_USR_VIEW</b>, <b>KEY_GRP_VIEW</b>, and
                     <b>KEY_OTH_VIEW</b>.

              <i>read</i>   This permission allows reading a key's payload.

                     This permission is required for the <b>KEYCTL_READ</b>
                     operation.

                     The permission bits for each category are
                     <b>KEY_POS_READ</b>, <b>KEY_USR_READ</b>, <b>KEY_GRP_READ</b>, and
                     <b>KEY_OTH_READ</b>.

              <i>write</i>  This permission allows update or instantiation of a
                     key's payload.  For a keyring, it allows keys to be
                     linked and unlinked from the keyring,

                     This permission is required for the <b>KEYCTL_UPDATE</b>,
                     <b>KEYCTL_REVOKE</b>, <b>KEYCTL_CLEAR</b>, <b>KEYCTL_LINK</b>, and
                     <b>KEYCTL_UNLINK </b>operations.

                     The permission bits for each category are
                     <b>KEY_POS_WRITE</b>, <b>KEY_USR_WRITE</b>, <b>KEY_GRP_WRITE</b>, and
                     <b>KEY_OTH_WRITE</b>.

              <i>search</i> This permission allows keyrings to be searched and
                     keys to be found.  Searches can recurse only into
                     nested keyrings that have <i>search</i> permission set.

                     This permission is required for the
                     <b>KEYCTL_GET_KEYRING_ID</b>, <b>KEYCTL_JOIN_SESSION_KEYRING</b>,
                     <b>KEYCTL_SEARCH</b>, and <b>KEYCTL_INVALIDATE </b>operations.

                     The permission bits for each category are
                     <b>KEY_POS_SEARCH</b>, <b>KEY_USR_SEARCH</b>, <b>KEY_GRP_SEARCH</b>, and
                     <b>KEY_OTH_SEARCH</b>.

              <i>link</i>   This permission allows a key or keyring to be
                     linked to.

                     This permission is required for the <b>KEYCTL_LINK </b>and
                     <b>KEYCTL_SESSION_TO_PARENT </b>operations.

                     The permission bits for each category are
                     <b>KEY_POS_LINK</b>, <b>KEY_USR_LINK</b>, <b>KEY_GRP_LINK</b>, and
                     <b>KEY_OTH_LINK</b>.

              <i>setattr</i> (since Linux 2.6.15).
                     This permission allows a key's UID, GID, and
                     permissions mask to be changed.

                     This permission is required for the <b>KEYCTL_REVOKE</b>,
                     <b>KEYCTL_CHOWN</b>, and <b>KEYCTL_SETPERM </b>operations.

                     The permission bits for each category are
                     <b>KEY_POS_SETATTR</b>, <b>KEY_USR_SETATTR</b>, <b>KEY_GRP_SETATTR</b>,
                     and <b>KEY_OTH_SETATTR</b>.

              As a convenience, the following macros are defined as
              masks for all of the permission bits in each of the user
              categories: <b>KEY_POS_ALL</b>, <b>KEY_USR_ALL</b>, <b>KEY_GRP_ALL</b>, and
              <b>KEY_OTH_ALL</b>.

              The <i>arg4</i> and <i>arg5</i> arguments are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_setperm.3.html">keyctl_setperm(3)</a>.

       <b>KEYCTL_DESCRIBE </b>(since Linux 2.6.10)
              Obtain a string describing the attributes of a specified
              key.

              The ID of the key to be described is specified in <i>arg2</i>
              (cast to <i>key_serial_t</i>).  The descriptive string is
              returned in the buffer pointed to by <i>arg3</i> (cast to
              <i>char *</i>); <i>arg4</i> (cast to <i>size_t</i>) specifies the size of that
              buffer in bytes.

              The key must grant the caller <i>view</i> permission.

              The returned string is null-terminated and contains the
              following information about the key:

                  <i>type</i>;<i>uid</i>;<i>gid</i>;<i>perm</i>;<i>description</i>

              In the above, <i>type</i> and <i>description</i> are strings, <i>uid</i> and
              <i>gid</i> are decimal strings, and <i>perm</i> is a hexadecimal
              permissions mask.  The descriptive string is written with
              the following format:

                  %s;%d;%d;%08x;%s

              <b>Note: the intention is that the descriptive string should</b>
              <b>be extensible in future kernel versions.  </b>In particular,
              the <i>description</i> field will not contain semicolons; it
              should be parsed by working backwards from the end of the
              string to find the last semicolon.  This allows future
              semicolon-delimited fields to be inserted in the
              descriptive string in the future.

              Writing to the buffer is attempted only when <i>arg3</i> is non-
              NULL and the specified buffer size is large enough to
              accept the descriptive string (including the terminating
              null byte).  In order to determine whether the buffer size
              was too small, check to see if the return value of the
              operation is greater than <i>arg4</i>.

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_describe.3.html">keyctl_describe(3)</a>.

       <b>KEYCTL_CLEAR</b>
              Clear the contents of (i.e., unlink all keys from) a
              keyring.

              The ID of the key (which must be of keyring type) is
              provided in <i>arg2</i> (cast to <i>key_serial_t</i>).

              The caller must have <i>write</i> permission on the keyring.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_clear.3.html">keyctl_clear(3)</a>.

       <b>KEYCTL_LINK </b>(since Linux 2.6.10)
              Create a link from a keyring to a key.

              The key to be linked is specified in <i>arg2</i> (cast to
              <i>key_serial_t</i>); the keyring is specified in <i>arg3</i> (cast to
              <i>key_serial_t</i>).

              If a key with the same type and description is already
              linked in the keyring, then that key is displaced from the
              keyring.

              Before creating the link, the kernel checks the nesting of
              the keyrings and returns appropriate errors if the link
              would produce a cycle or if the nesting of keyrings would
              be too deep (The limit on the nesting of keyrings is
              determined by the kernel constant
              <b>KEYRING_SEARCH_MAX_DEPTH</b>, defined with the value 6, and is
              necessary to prevent overflows on the kernel stack when
              recursively searching keyrings).

              The caller must have <i>link</i> permission on the key being
              added and <i>write</i> permission on the keyring.

              The arguments <i>arg4</i> and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_link.3.html">keyctl_link(3)</a>.

       <b>KEYCTL_UNLINK </b>(since Linux 2.6.10)
              Unlink a key from a keyring.

              The ID of the key to be unlinked is specified in <i>arg2</i>
              (cast to <i>key_serial_t</i>); the ID of the keyring from which
              it is to be unlinked is specified in <i>arg3</i> (cast to
              <i>key_serial_t</i>).

              If the key is not currently linked into the keyring, an
              error results.

              The caller must have <i>write</i> permission on the keyring from
              which the key is being removed.

              If the last link to a key is removed, then that key will
              be scheduled for destruction.

              The arguments <i>arg4</i> and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_unlink.3.html">keyctl_unlink(3)</a>.

       <b>KEYCTL_SEARCH </b>(since Linux 2.6.10)
              Search for a key in a keyring tree, returning its ID and
              optionally linking it to a specified keyring.

              The tree to be searched is specified by passing the ID of
              the head keyring in <i>arg2</i> (cast to <i>key_serial_t</i>).  The
              search is performed breadth-first and recursively.

              The <i>arg3</i> and <i>arg4</i> arguments specify the key to be searched
              for: <i>arg3</i> (cast as <i>char *</i>) contains the key type (a null-
              terminated character string up to 32 bytes in size,
              including the terminating null byte), and <i>arg4</i> (cast as
              <i>char *</i>) contains the description of the key (a null-
              terminated character string up to 4096 bytes in size,
              including the terminating null byte).

              The source keyring must grant <i>search</i> permission to the
              caller.  When performing the recursive search, only
              keyrings that grant the caller <i>search</i> permission will be
              searched.  Only keys with for which the caller has <i>search</i>
              permission can be found.

              If the key is found, its ID is returned as the function
              result.

              If the key is found and <i>arg5</i> (cast to <i>key_serial_t</i>) is
              nonzero, then, subject to the same constraints and rules
              as <b>KEYCTL_LINK</b>, the key is linked into the keyring whose
              ID is specified in <i>arg5</i>.  If the destination keyring
              specified in <i>arg5</i> already contains a link to a key that
              has the same type and description, then that link will be
              displaced by a link to the key found by this operation.

              Instead of valid existing keyring IDs, the source (<i>arg2</i>)
              and destination (<i>arg5</i>) keyrings can be one of the special
              keyring IDs listed under <b>KEYCTL_GET_KEYRING_ID</b>.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_search.3.html">keyctl_search(3)</a>.

       <b>KEYCTL_READ </b>(since Linux 2.6.10)
              Read the payload data of a key.

              The ID of the key whose payload is to be read is specified
              in <i>arg2</i> (cast to <i>key_serial_t</i>).  This can be the ID of an
              existing key, or any of the special key IDs listed for
              <b>KEYCTL_GET_KEYRING_ID</b>.

              The payload is placed in the buffer pointed by <i>arg3</i> (cast
              to <i>char *</i>); the size of that buffer must be specified in
              <i>arg4</i> (cast to <i>size_t</i>).

              The returned data will be processed for presentation
              according to the key type.  For example, a keyring will
              return an array of <i>key_serial_t</i> entries representing the
              IDs of all the keys that are linked to it.  The <i>user</i> key
              type will return its data as is.  If a key type does not
              implement this function, the operation fails with the
              error <b>EOPNOTSUPP</b>.

              If <i>arg3</i> is not NULL, as much of the payload data as will
              fit is copied into the buffer.  On a successful return,
              the return value is always the total size of the payload
              data.  To determine whether the buffer was of sufficient
              size, check to see that the return value is less than or
              equal to the value supplied in <i>arg4</i>.

              The key must either grant the caller <i>read</i> permission, or
              grant the caller <i>search</i> permission when searched for from
              the process keyrings (i.e., the key is possessed).

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_read.3.html">keyctl_read(3)</a>.

       <b>KEYCTL_INSTANTIATE </b>(since Linux 2.6.10)
              (Positively) instantiate an uninstantiated key with a
              specified payload.

              The ID of the key to be instantiated is provided in <i>arg2</i>
              (cast to <i>key_serial_t</i>).

              The key payload is specified in the buffer pointed to by
              <i>arg3</i> (cast to <i>void *</i>); the size of that buffer is
              specified in <i>arg4</i> (cast to <i>size_t</i>).

              The payload may be a null pointer and the buffer size may
              be 0 if this is supported by the key type (e.g., it is a
              keyring).

              The operation may be fail if the payload data is in the
              wrong format or is otherwise invalid.

              If <i>arg5</i> (cast to <i>key_serial_t</i>) is nonzero, then, subject
              to the same constraints and rules as <b>KEYCTL_LINK</b>, the
              instantiated key is linked into the keyring whose ID
              specified in <i>arg5</i>.

              The caller must have the appropriate authorization key,
              and once the uninstantiated key has been instantiated, the
              authorization key is revoked.  In other words, this
              operation is available only from a <a href="../man8/request-key.8.html">request-key(8)</a>-style
              program.  See <a href="request_key.2.html">request_key(2)</a> for an explanation of
              uninstantiated keys and key instantiation.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_instantiate.3.html">keyctl_instantiate(3)</a>.

       <b>KEYCTL_NEGATE </b>(since Linux 2.6.10)
              Negatively instantiate an uninstantiated key.

              This operation is equivalent to the call:

                  keyctl(KEYCTL_REJECT, arg2, arg3, ENOKEY, arg4);

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_negate.3.html">keyctl_negate(3)</a>.

       <b>KEYCTL_SET_REQKEY_KEYRING </b>(since Linux 2.6.13)
              Set the default keyring to which implicitly requested keys
              will be linked for this thread, and return the previous
              setting.  Implicit key requests are those made by internal
              kernel components, such as can occur when, for example,
              opening files on an AFS or NFS filesystem.  Setting the
              default keyring also has an effect when requesting a key
              from user space; see <a href="request_key.2.html">request_key(2)</a> for details.

              The <i>arg2</i> argument (cast to <i>int</i>) should contain one of the
              following values, to specify the new default keyring:

              <b>KEY_REQKEY_DEFL_NO_CHANGE</b>
                     Don't change the default keyring.  This can be used
                     to discover the current default keyring (without
                     changing it).

              <b>KEY_REQKEY_DEFL_DEFAULT</b>
                     This selects the default behaviour, which is to use
                     the thread-specific keyring if there is one,
                     otherwise the process-specific keyring if there is
                     one, otherwise the session keyring if there is one,
                     otherwise the UID-specific session keyring,
                     otherwise the user-specific keyring.

              <b>KEY_REQKEY_DEFL_THREAD_KEYRING</b>
                     Use the thread-specific keyring (<a href="../man7/thread-keyring.7.html">thread-keyring(7)</a>)
                     as the new default keyring.

              <b>KEY_REQKEY_DEFL_PROCESS_KEYRING</b>
                     Use the process-specific keyring
                     (<a href="../man7/process-keyring.7.html">process-keyring(7)</a>) as the new default keyring.

              <b>KEY_REQKEY_DEFL_SESSION_KEYRING</b>
                     Use the session-specific keyring
                     (<a href="../man7/session-keyring.7.html">session-keyring(7)</a>) as the new default keyring.

              <b>KEY_REQKEY_DEFL_USER_KEYRING</b>
                     Use the UID-specific keyring (<a href="../man7/user-keyring.7.html">user-keyring(7)</a>) as
                     the new default keyring.

              <b>KEY_REQKEY_DEFL_USER_SESSION_KEYRING</b>
                     Use the UID-specific session keyring
                     (<a href="../man7/user-session-keyring.7.html">user-session-keyring(7)</a>) as the new default
                     keyring.

              <b>KEY_REQKEY_DEFL_REQUESTOR_KEYRING </b>(since Linux 2.6.29)
                     Use the requestor keyring.

              All other values are invalid.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              The setting controlled by this operation is inherited by
              the child of <a href="fork.2.html">fork(2)</a> and preserved across <a href="execve.2.html">execve(2)</a>.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_set_reqkey_keyring.3.html">keyctl_set_reqkey_keyring(3)</a>.

       <b>KEYCTL_SET_TIMEOUT </b>(since Linux 2.6.16)
              Set a timeout on a key.

              The ID of the key is specified in <i>arg2</i> (cast to
              <i>key_serial_t</i>).  The timeout value, in seconds from the
              current time, is specified in <i>arg3</i> (cast to <i>unsigned int</i>).
              The timeout is measured against the realtime clock.

              Specifying the timeout value as 0 clears any existing
              timeout on the key.

              The <i>/proc/keys</i> file displays the remaining time until each
              key will expire.  (This is the only method of discovering
              the timeout on a key.)

              The caller must either have the <i>setattr</i> permission on the
              key or hold an instantiation authorization token for the
              key (see <a href="request_key.2.html">request_key(2)</a>).

              The key and any links to the key will be automatically
              garbage collected after the timeout expires.  Subsequent
              attempts to access the key will then fail with the error
              <b>EKEYEXPIRED</b>.

              This operation cannot be used to set timeouts on revoked,
              expired, or negatively instantiated keys.

              The arguments <i>arg4</i> and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_set_timeout.3.html">keyctl_set_timeout(3)</a>.

       <b>KEYCTL_ASSUME_AUTHORITY </b>(since Linux 2.6.16)
              Assume (or divest) the authority for the calling thread to
              instantiate a key.

              The <i>arg2</i> argument (cast to <i>key_serial_t</i>) specifies either
              a nonzero key ID to assume authority, or the value 0 to
              divest authority.

              If <i>arg2</i> is nonzero, then it specifies the ID of an
              uninstantiated key for which authority is to be assumed.
              That key can then be instantiated using one of
              <b>KEYCTL_INSTANTIATE</b>, <b>KEYCTL_INSTANTIATE_IOV</b>, <b>KEYCTL_REJECT</b>,
              or <b>KEYCTL_NEGATE</b>.  Once the key has been instantiated, the
              thread is automatically divested of authority to
              instantiate the key.

              Authority over a key can be assumed only if the calling
              thread has present in its keyrings the authorization key
              that is associated with the specified key.  (In other
              words, the <b>KEYCTL_ASSUME_AUTHORITY </b>operation is available
              only from a <a href="../man8/request-key.8.html">request-key(8)</a>-style program; see
              <a href="request_key.2.html">request_key(2)</a> for an explanation of how this operation is
              used.)  The caller must have <i>search</i> permission on the
              authorization key.

              If the specified key has a matching authorization key,
              then the ID of that key is returned.  The authorization
              key can be read (<b>KEYCTL_READ</b>) to obtain the callout
              information passed to <a href="request_key.2.html">request_key(2)</a>.

              If the ID given in <i>arg2</i> is 0, then the currently assumed
              authority is cleared (divested), and the value 0 is
              returned.

              The <b>KEYCTL_ASSUME_AUTHORITY </b>mechanism allows a program
              such as <a href="../man8/request-key.8.html">request-key(8)</a> to assume the necessary authority
              to instantiate a new uninstantiated key that was created
              as a consequence of a call to <a href="request_key.2.html">request_key(2)</a>.  For further
              information, see <a href="request_key.2.html">request_key(2)</a> and the kernel source file
              <i>Documentation/security/keys-request-key.txt</i>.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_assume_authority.3.html">keyctl_assume_authority(3)</a>.

       <b>KEYCTL_GET_SECURITY </b>(since Linux 2.6.26)
              Get the LSM (Linux Security Module) security label of the
              specified key.

              The ID of the key whose security label is to be fetched is
              specified in <i>arg2</i> (cast to <i>key_serial_t</i>).  The security
              label (terminated by a null byte) will be placed in the
              buffer pointed to by <i>arg3</i> argument (cast to <i>char *</i>); the
              size of the buffer must be provided in <i>arg4</i> (cast to
              <i>size_t</i>).

              If <i>arg3</i> is specified as NULL or the buffer size specified
              in <i>arg4</i> is too small, the full size of the security label
              string (including the terminating null byte) is returned
              as the function result, and nothing is copied to the
              buffer.

              The caller must have <i>view</i> permission on the specified key.

              The returned security label string will be rendered in a
              form appropriate to the LSM in force.  For example, with
              SELinux, it may look like:

                  unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023

              If no LSM is currently in force, then an empty string is
              placed in the buffer.

              The <i>arg5</i> argument is ignored.

              This operation is exposed by <i>libkeyutils</i> via the functions
              <a href="../man3/keyctl_get_security.3.html">keyctl_get_security(3)</a> and <b>keyctl_get_security_alloc</b>(3).

       <b>KEYCTL_SESSION_TO_PARENT </b>(since Linux 2.6.32)
              Replace the session keyring to which the <i>parent</i> of the
              calling process subscribes with the session keyring of the
              calling process.

              The keyring will be replaced in the parent process at the
              point where the parent next transitions from kernel space
              to user space.

              The keyring must exist and must grant the caller <i>link</i>
              permission.  The parent process must be single-threaded
              and have the same effective ownership as this process and
              must not be set-user-ID or set-group-ID.  The UID of the
              parent process's existing session keyring (f it has one),
              as well as the UID of the caller's session keyring much
              match the caller's effective UID.

              The fact that it is the parent process that is affected by
              this operation allows a program such as the shell to start
              a child process that uses this operation to change the
              shell's session keyring.  (This is what the <a href="../man1/keyctl.1.html">keyctl(1)</a>
              <b>new_session </b>command does.)

              The arguments <i>arg2</i>, <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_session_to_parent.3.html">keyctl_session_to_parent(3)</a>.

       <b>KEYCTL_REJECT </b>(since Linux 2.6.39)
              Mark a key as negatively instantiated and set an
              expiration timer on the key.  This operation provides a
              superset of the functionality of the earlier <b>KEYCTL_NEGATE</b>
              operation.

              The ID of the key that is to be negatively instantiated is
              specified in <i>arg2</i> (cast to <i>key_serial_t</i>).  The <i>arg3</i> (cast
              to <i>unsigned int</i>) argument specifies the lifetime of the
              key, in seconds.  The <i>arg4</i> argument (cast to <i>unsigned int</i>)
              specifies the error to be returned when a search hits this
              key; typically, this is one of <b>EKEYREJECTED</b>, <b>EKEYREVOKED</b>,
              or <b>EKEYEXPIRED</b>.

              If <i>arg5</i> (cast to <i>key_serial_t</i>) is nonzero, then, subject
              to the same constraints and rules as <b>KEYCTL_LINK</b>, the
              negatively instantiated key is linked into the keyring
              whose ID is specified in <i>arg5</i>.

              The caller must have the appropriate authorization key.
              In other words, this operation is available only from a
              <a href="../man8/request-key.8.html">request-key(8)</a>-style program.  See <a href="request_key.2.html">request_key(2)</a>.

              The caller must have the appropriate authorization key,
              and once the uninstantiated key has been instantiated, the
              authorization key is revoked.  In other words, this
              operation is available only from a <a href="../man8/request-key.8.html">request-key(8)</a>-style
              program.  See <a href="request_key.2.html">request_key(2)</a> for an explanation of
              uninstantiated keys and key instantiation.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_reject.3.html">keyctl_reject(3)</a>.

       <b>KEYCTL_INSTANTIATE_IOV </b>(since Linux 2.6.39)
              Instantiate an uninstantiated key with a payload specified
              via a vector of buffers.

              This operation is the same as <b>KEYCTL_INSTANTIATE</b>, but the
              payload data is specified as an array of <i>iovec</i> structures
              (see <a href="../man3/iovec.3type.html">iovec(3type)</a>).

              The pointer to the payload vector is specified in <i>arg3</i>
              (cast as <i>const struct iovec *</i>).  The number of items in
              the vector is specified in <i>arg4</i> (cast as <i>unsigned int</i>).

              The <i>arg2</i> (key ID) and <i>arg5</i> (keyring ID) are interpreted as
              for <b>KEYCTL_INSTANTIATE</b>.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_instantiate_iov.3.html">keyctl_instantiate_iov(3)</a>.

       <b>KEYCTL_INVALIDATE </b>(since Linux 3.5)
              Mark a key as invalid.

              The ID of the key to be invalidated is specified in <i>arg2</i>
              (cast to <i>key_serial_t</i>).

              To invalidate a key, the caller must have <i>search</i>
              permission on the key.

              This operation marks the key as invalid and schedules
              immediate garbage collection.  The garbage collector
              removes the invalidated key from all keyrings and deletes
              the key when its reference count reaches zero.  After this
              operation, the key will be ignored by all searches, even
              if it is not yet deleted.

              Keys that are marked invalid become invisible to normal
              key operations immediately, though they are still visible
              in <i>/proc/keys</i> (marked with an 'i' flag) until they are
              actually removed.

              The arguments <i>arg3</i>, <i>arg4</i>, and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_invalidate.3.html">keyctl_invalidate(3)</a>.

       <b>KEYCTL_GET_PERSISTENT </b>(since Linux 3.13)
              Get the persistent keyring (<a href="../man7/persistent-keyring.7.html">persistent-keyring(7)</a>) for a
              specified user and link it to a specified keyring.

              The user ID is specified in <i>arg2</i> (cast to <i>uid_t</i>).  If the
              value -1 is specified, the caller's real user ID is used.
              The ID of the destination keyring is specified in <i>arg3</i>
              (cast to <i>key_serial_t</i>).

              The caller must have the <b>CAP_SETUID </b>capability in its user
              namespace in order to fetch the persistent keyring for a
              user ID that does not match either the real or effective
              user ID of the caller.

              If the call is successful, a link to the persistent
              keyring is added to the keyring whose ID was specified in
              <i>arg3</i>.

              The caller must have <i>write</i> permission on the keyring.

              The persistent keyring will be created by the kernel if it
              does not yet exist.

              Each time the <b>KEYCTL_GET_PERSISTENT </b>operation is
              performed, the persistent keyring will have its expiration
              timeout reset to the value in:

                  /proc/sys/kernel/keys/persistent_keyring_expiry

              Should the timeout be reached, the persistent keyring will
              be removed and everything it pins can then be garbage
              collected.

              Persistent keyrings were added in Linux 3.13.

              The arguments <i>arg4</i> and <i>arg5</i> are ignored.

              This operation is exposed by <i>libkeyutils</i> via the function
              <a href="../man3/keyctl_get_persistent.3.html">keyctl_get_persistent(3)</a>.

       <b>KEYCTL_DH_COMPUTE </b>(since Linux 4.7)
              Compute a Diffie-Hellman shared secret or public key,
              optionally applying key derivation function (KDF) to the
              result.

              The <i>arg2</i> argument is a pointer to a set of parameters
              containing serial numbers for three <i>"user"</i> keys used in
              the Diffie-Hellman calculation, packaged in a structure of
              the following form:

                  struct keyctl_dh_params {
                      int32_t private; /* The local private key */
                      int32_t prime; /* The prime, known to both parties */
                      int32_t base;  /* The base integer: either a shared
                                        generator or the remote public key */
                  };

              Each of the three keys specified in this structure must
              grant the caller <i>read</i> permission.  The payloads of these
              keys are used to calculate the Diffie-Hellman result as:

                  base ^ private mod prime

              If the base is the shared generator, the result is the
              local public key.  If the base is the remote public key,
              the result is the shared secret.

              The <i>arg3</i> argument (cast to <i>char *</i>) points to a buffer
              where the result of the calculation is placed.  The size
              of that buffer is specified in <i>arg4</i> (cast to <i>size_t</i>).

              The buffer must be large enough to accommodate the output
              data, otherwise an error is returned.  If <i>arg4</i> is
              specified zero, in which case the buffer is not used and
              the operation returns the minimum required buffer size
              (i.e., the length of the prime).

              Diffie-Hellman computations can be performed in user
              space, but require a multiple-precision integer (MPI)
              library.  Moving the implementation into the kernel gives
              access to the kernel MPI implementation, and allows access
              to secure or acceleration hardware.

              Adding support for DH computation to the <b>keyctl</b>() system
              call was considered a good fit due to the DH algorithm's
              use for deriving shared keys; it also allows the type of
              the key to determine which DH implementation (software or
              hardware) is appropriate.

              If the <i>arg5</i> argument is <b>NULL</b>, then the DH result itself is
              returned.  Otherwise (since Linux 4.12), it is a pointer
              to a structure which specifies parameters of the KDF
              operation to be applied:

                  struct keyctl_kdf_params {
                      char *hashname;     /* Hash algorithm name */
                      char *otherinfo;    /* SP800-56A OtherInfo */
                      __u32 otherinfolen; /* Length of otherinfo data */
                      __u32 __spare[8];   /* Reserved */
                  };

              The <i>hashname</i> field is a null-terminated string which
              specifies a hash name (available in the kernel's crypto
              API; the list of the hashes available is rather tricky to
              observe; please refer to the "Kernel Crypto API
              Architecture" 
              ⟨<a href="https://www.kernel.org/doc/html/latest/crypto/architecture.html">https://www.kernel.org/doc/html/latest/crypto/architecture.html</a>⟩
              documentation for the information regarding how hash names
              are constructed and your kernel's source and configuration
              regarding what ciphers and templates with type
              <b>CRYPTO_ALG_TYPE_SHASH </b>are available) to be applied to DH
              result in KDF operation.

              The <i>otherinfo</i> field is an <i>OtherInfo</i> data as described in
              SP800-56A section 5.8.1.2 and is algorithm-specific.  This
              data is concatenated with the result of DH operation and
              is provided as an input to the KDF operation.  Its size is
              provided in the <i>otherinfolen</i> field and is limited by
              <b>KEYCTL_KDF_MAX_OI_LEN </b>constant that defined in
              <i>security/keys/internal.h</i> to a value of 64.

              The <b>__spare </b>field is currently unused.  It was ignored
              until Linux 4.13 (but still should be user-addressable
              since it is copied to the kernel), and should contain
              zeros since Linux 4.13.

              The KDF implementation complies with SP800-56A as well as
              with SP800-108 (the counter KDF).

              This operation is exposed by <i>libkeyutils</i> (from <i>libkeyutils</i>
              1.5.10 onwards) via the functions <a href="../man3/keyctl_dh_compute.3.html">keyctl_dh_compute(3)</a> and
              <b>keyctl_dh_compute_alloc</b>(3).

       <b>KEYCTL_RESTRICT_KEYRING </b>(since Linux 4.12)
              Apply a key-linking restriction to the keyring with the ID
              provided in <i>arg2</i> (cast to <i>key_serial_t</i>).  The caller must
              have <i>setattr</i> permission on the key.  If <i>arg3</i> is NULL, any
              attempt to add a key to the keyring is blocked; otherwise
              it contains a pointer to a string with a key type name and
              <i>arg4</i> contains a pointer to string that describes the type-
              specific restriction.  As of Linux 4.12, only the type
              "asymmetric" has restrictions defined:

              <b>builtin_trusted</b>
                     Allows only keys that are signed by a key linked to
                     the built-in keyring (".builtin_trusted_keys").

              <b>builtin_and_secondary_trusted</b>
                     Allows only keys that are signed by a key linked to
                     the secondary keyring (".secondary_trusted_keys")
                     or, by extension, a key in a built-in keyring, as
                     the latter is linked to the former.

              <b>key_or_keyring:</b><i>key</i>
              <b>key_or_keyring:</b><i>key</i><b>:chain</b>
                     If <i>key</i> specifies the ID of a key of type
                     "asymmetric", then only keys that are signed by
                     this key are allowed.

                     If <i>key</i> specifies the ID of a keyring, then only
                     keys that are signed by a key linked to this
                     keyring are allowed.

                     If ":chain" is specified, keys that are signed by a
                     keys linked to the destination keyring (that is,
                     the keyring with the ID specified in the <i>arg2</i>
                     argument) are also allowed.

              Note that a restriction can be configured only once for
              the specified keyring; once a restriction is set, it can't
              be overridden.

              The argument <i>arg5</i> is ignored.
</pre> <h2>
RETURN VALUE </h2>
<pre>
       For a successful call, the return value depends on the operation:

       <b>KEYCTL_GET_KEYRING_ID</b>
              The ID of the requested keyring.

       <b>KEYCTL_JOIN_SESSION_KEYRING</b>
              The ID of the joined session keyring.

       <b>KEYCTL_DESCRIBE</b>
              The size of the description (including the terminating
              null byte), irrespective of the provided buffer size.

       <b>KEYCTL_SEARCH</b>
              The ID of the key that was found.

       <b>KEYCTL_READ</b>
              The amount of data that is available in the key,
              irrespective of the provided buffer size.

       <b>KEYCTL_SET_REQKEY_KEYRING</b>
              The ID of the previous default keyring to which implicitly
              requested keys were linked (one of
              <b>KEY_REQKEY_DEFL_USER_*</b>).

       <b>KEYCTL_ASSUME_AUTHORITY</b>
              Either 0, if the ID given was 0, or the ID of the
              authorization key matching the specified key, if a nonzero
              key ID was provided.

       <b>KEYCTL_GET_SECURITY</b>
              The size of the LSM security label string (including the
              terminating null byte), irrespective of the provided
              buffer size.

       <b>KEYCTL_GET_PERSISTENT</b>
              The ID of the persistent keyring.

       <b>KEYCTL_DH_COMPUTE</b>
              The number of bytes copied to the buffer, or, if <i>arg4</i> is
              0, the required buffer size.

       All other operations
              Zero.

       On error, -1 is returned, and <i><a href="../man3/errno.3.html">errno</a></i> is set to indicate the error.
</pre> <h2>
ERRORS </h2>
<pre>
       <b>EACCES </b>The requested operation wasn't permitted.

       <b>EAGAIN </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and there was an error
              during crypto module initialization.

       <b>EDEADLK</b>
              <i>operation</i> was <b>KEYCTL_LINK </b>and the requested link would
              result in a cycle.

       <b>EDEADLK</b>
              <i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING </b>and the requested
              keyring restriction would result in a cycle.

       <b>EDQUOT </b>The key quota for the caller's user would be exceeded by
              creating a key or linking it to the keyring.

       <b>EEXIST </b><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING </b>and keyring provided
              in <i>arg2</i> argument already has a restriction set.

       <b>EFAULT </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and one of the following
              has failed:

              •  copying of the <i>struct keyctl_dh_params</i>, provided in the
                 <i>arg2</i> argument, from user space;

              •  copying of the <i>struct keyctl_kdf_params</i>, provided in
                 the non-NULL <i>arg5</i> argument, from user space (in case
                 kernel supports performing KDF operation on DH
                 operation result);

              •  copying of data pointed by the <i>hashname</i> field of the
                 <i>struct keyctl_kdf_params</i> from user space;

              •  copying of data pointed by the <i>otherinfo</i> field of the
                 <i>struct keyctl_kdf_params</i> from user space if the
                 <i>otherinfolen</i> field was nonzero;

              •  copying of the result to user space.

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_SETPERM </b>and an invalid permission bit
              was specified in <i>arg3</i>.

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_SEARCH </b>and the size of the
              description in <i>arg4</i> (including the terminating null byte)
              exceeded 4096 bytes.

       <b>EINVAL </b>size of the string (including the terminating null byte)
              specified in <i>arg3</i> (the key type) or <i>arg4</i> (the key
              description) exceeded the limit (32 bytes and 4096 bytes
              respectively).

       <b>EINVAL </b>(before Linux 4.12)
              <i>operation</i> was <b>KEYCTL_DH_COMPUTE</b>, argument <i>arg5</i> was non-
              NULL.

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>And the digest size of the
              hashing algorithm supplied is zero.

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the buffer size
              provided is not enough to hold the result.  Provide 0 as a
              buffer size in order to obtain the minimum buffer size.

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the hash name provided
              in the <i>hashname</i> field of the <i>struct keyctl_kdf_params</i>
              pointed by <i>arg5</i> argument is too big (the limit is
              implementation-specific and varies between kernel
              versions, but it is deemed big enough for all valid
              algorithm names).

       <b>EINVAL </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the <i>__spare</i> field of
              the <i>struct keyctl_kdf_params</i> provided in the <i>arg5</i> argument
              contains nonzero values.

       <b>EKEYEXPIRED</b>
              An expired key was found or specified.

       <b>EKEYREJECTED</b>
              A rejected key was found or specified.

       <b>EKEYREVOKED</b>
              A revoked key was found or specified.

       <b>ELOOP  </b><i>operation</i> was <b>KEYCTL_LINK </b>and the requested link would
              cause the maximum nesting depth for keyrings to be
              exceeded.

       <b>EMSGSIZE</b>
              <i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the buffer length
              exceeds <b>KEYCTL_KDF_MAX_OUTPUT_LEN </b>(which is 1024
              currently) or the <i>otherinfolen</i> field of the <i>struct</i>
              <i>keyctl_kdf_parms</i> passed in <i>arg5</i> exceeds
              <b>KEYCTL_KDF_MAX_OI_LEN </b>(which is 64 currently).

       <b>ENFILE </b>(before Linux 3.13)
              <i>operation</i> was <b>KEYCTL_LINK </b>and the keyring is full.
              (Before Linux 3.13, the available space for storing
              keyring links was limited to a single page of memory;
              since Linux 3.13, there is no fixed limit.)

       <b>ENOENT </b><i>operation</i> was <b>KEYCTL_UNLINK </b>and the key to be unlinked
              isn't linked to the keyring.

       <b>ENOENT </b><i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the hashing algorithm
              specified in the <i>hashname</i> field of the <i>struct</i>
              <i>keyctl_kdf_params</i> pointed by <i>arg5</i> argument hasn't been
              found.

       <b>ENOENT </b><i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING </b>and the type
              provided in <i>arg3</i> argument doesn't support setting key
              linking restrictions.

       <b>ENOKEY </b>No matching key was found or an invalid key was specified.

       <b>ENOKEY </b>The value <b>KEYCTL_GET_KEYRING_ID </b>was specified in
              <i>operation</i>, the key specified in <i>arg2</i> did not exist, and
              <i>arg3</i> was zero (meaning don't create the key if it didn't
              exist).

       <b>ENOMEM </b>One of kernel memory allocation routines failed during the
              execution of the syscall.

       <b>ENOTDIR</b>
              A key of keyring type was expected but the ID of a key
              with a different type was provided.

       <b>EOPNOTSUPP</b>
              <i>operation</i> was <b>KEYCTL_READ </b>and the key type does not
              support reading (e.g., the type is <i>"login"</i>).

       <b>EOPNOTSUPP</b>
              <i>operation</i> was <b>KEYCTL_UPDATE </b>and the key type does not
              support updating.

       <b>EOPNOTSUPP</b>
              <i>operation</i> was <b>KEYCTL_RESTRICT_KEYRING</b>, the type provided
              in <i>arg3</i> argument was "asymmetric", and the key specified
              in the restriction specification provided in <i>arg4</i> has type
              other than "asymmetric" or "keyring".

       <b>EPERM  </b><i>operation</i> was <b>KEYCTL_GET_PERSISTENT</b>, <i>arg2</i> specified a UID
              other than the calling thread's real or effective UID, and
              the caller did not have the <b>CAP_SETUID </b>capability.

       <b>EPERM  </b><i>operation</i> was <b>KEYCTL_SESSION_TO_PARENT </b>and either: all of
              the UIDs (GIDs) of the parent process do not match the
              effective UID (GID) of the calling process; the UID of the
              parent's existing session keyring or the UID of the
              caller's session keyring did not match the effective UID
              of the caller; the parent process is not single-thread; or
              the parent process is <a href="../man1/init.1.html">init(1)</a> or a kernel thread.

       <b>ETIMEDOUT</b>
              <i>operation</i> was <b>KEYCTL_DH_COMPUTE </b>and the initialization of
              crypto modules has timed out.
</pre> <h2>
VERSIONS </h2>
<pre>
       A wrapper is provided in the <i>libkeyutils</i> library.  (The
       accompanying package provides the <i>&lt;keyutils.h&gt;</i> header file.)
       However, rather than using this system call directly, you
       probably want to use the various library functions mentioned in
       the descriptions of individual operations above.
</pre> <h2>
STANDARDS </h2>
<pre>
       Linux.
</pre> <h2>
HISTORY </h2>
<pre>
       Linux 2.6.10.
</pre> <h2>
EXAMPLES </h2>
<pre>
       The program below provide subset of the functionality of the
       <a href="../man8/request-key.8.html">request-key(8)</a> program provided by the <i>keyutils</i> package.  For
       informational purposes, the program records various information
       in a log file.

       As described in <a href="request_key.2.html">request_key(2)</a>, the <a href="../man8/request-key.8.html">request-key(8)</a> program is
       invoked with command-line arguments that describe a key that is
       to be instantiated.  The example program fetches and logs these
       arguments.  The program assumes authority to instantiate the
       requested key, and then instantiates that key.

       The following shell session demonstrates the use of this program.
       In the session, we compile the program and then use it to
       temporarily replace the standard <a href="../man8/request-key.8.html">request-key(8)</a> program.  (Note
       that temporarily disabling the standard <a href="../man8/request-key.8.html">request-key(8)</a> program
       may not be safe on some systems.)  While our example program is
       installed, we use the example program shown in <a href="request_key.2.html">request_key(2)</a> to
       request a key.

           $ <b>cc -o key_instantiate key_instantiate.c -lkeyutils</b>
           $ <b>sudo mv /sbin/request-key /sbin/request-key.backup</b>
           $ <b>sudo cp key_instantiate /sbin/request-key</b>
           $ <b>./t_request_key user mykey somepayloaddata</b>
           Key ID is 20d035bf
           $ <b>sudo mv /sbin/request-key.backup /sbin/request-key</b>

       Looking at the log file created by this program, we can see the
       command-line arguments supplied to our example program:

           $ <b>cat /tmp/key_instantiate.log</b>
           Time: Mon Nov  7 13:06:47 2016

           Command line arguments:
             argv[0]:            /sbin/request-key
             operation:          create
             key_to_instantiate: 20d035bf
             UID:                1000
             GID:                1000
             thread_keyring:     0
             process_keyring:    0
             session_keyring:    256e6a6

           Key description:      user;1000;1000;3f010000;mykey
           Auth key payload:     somepayloaddata
           Destination keyring:  256e6a6
           Auth key description: .request_key_auth;1000;1000;0b010000;20d035bf

       The last few lines of the above output show that the example
       program was able to fetch:

       •  the description of the key to be instantiated, which included
          the name of the key (<i>mykey</i>);

       •  the payload of the authorization key, which consisted of the
          data (<i>somepayloaddata</i>) passed to <a href="request_key.2.html">request_key(2)</a>;

       •  the destination keyring that was specified in the call to
          <a href="request_key.2.html">request_key(2)</a>; and

       •  the description of the authorization key, where we can see
          that the name of the authorization key matches the ID of the
          key that is to be instantiated (<i>20d035bf</i>).

       The example program in <a href="request_key.2.html">request_key(2)</a> specified the destination
       keyring as <b>KEY_SPEC_SESSION_KEYRING</b>.  By examining the contents
       of <i>/proc/keys</i>, we can see that this was translated to the ID of
       the destination keyring (<i>0256e6a6</i>) shown in the log output above;
       we can also see the newly created key with the name <i>mykey</i> and ID
       <i>20d035bf</i>.

           $ <b>cat /proc/keys | egrep 'mykey|256e6a6'</b>
           0256e6a6 I--Q---  194 perm 3f030000  1000  1000 keyring  _ses: 3
           20d035bf I--Q---    1 perm 3f010000  1000  1000 user     mykey: 16

   <b>Program source</b>

       /* key_instantiate.c */

       #include &lt;errno.h&gt;
       #include &lt;keyutils.h&gt;
       #include &lt;stdint.h&gt;
       #include &lt;stdio.h&gt;
       #include &lt;stdlib.h&gt;
       #include &lt;string.h&gt;
       #include &lt;sys/types.h&gt;
       #include &lt;time.h&gt;

       #ifndef KEY_SPEC_REQUESTOR_KEYRING
       #define KEY_SPEC_REQUESTOR_KEYRING      (-8)
       #endif

       int
       main(int argc, char *argv[])
       {
           int           akp_size;       /* Size of auth_key_payload */
           int           auth_key;
           char          dbuf[256];
           char          auth_key_payload[256];
           char          *operation;
           FILE          *fp;
           gid_t         gid;
           uid_t         uid;
           time_t        t;
           key_serial_t  key_to_instantiate, dest_keyring;
           key_serial_t  thread_keyring, process_keyring, session_keyring;

           if (argc != 8) {
               fprintf(stderr, "Usage: %s op key uid gid thread_keyring "
                               "process_keyring session_keyring\n", argv[0]);
               exit(EXIT_FAILURE);
           }

           fp = fopen("/tmp/key_instantiate.log", "w");
           if (fp == NULL)
               exit(EXIT_FAILURE);

           setbuf(fp, NULL);

           t = time(NULL);
           fprintf(fp, "Time: %s\n", ctime(&amp;t));

           /*
            * The kernel passes a fixed set of arguments to the program
            * that it execs; fetch them.
            */
           operation = argv[1];
           key_to_instantiate = atoi(argv[2]);
           uid = atoi(argv[3]);
           gid = atoi(argv[4]);
           thread_keyring = atoi(argv[5]);
           process_keyring = atoi(argv[6]);
           session_keyring = atoi(argv[7]);

           fprintf(fp, "Command line arguments:\n");
           fprintf(fp, "  argv[0]:            %s\n", argv[0]);
           fprintf(fp, "  operation:          %s\n", operation);
           fprintf(fp, "  key_to_instantiate: %jx\n",
                   (uintmax_t) key_to_instantiate);
           fprintf(fp, "  UID:                %jd\n", (intmax_t) uid);
           fprintf(fp, "  GID:                %jd\n", (intmax_t) gid);
           fprintf(fp, "  thread_keyring:     %jx\n",
                   (uintmax_t) thread_keyring);
           fprintf(fp, "  process_keyring:    %jx\n",
                   (uintmax_t) process_keyring);
           fprintf(fp, "  session_keyring:    %jx\n",
                   (uintmax_t) session_keyring);
           fprintf(fp, "\n");

           /*
            * Assume the authority to instantiate the key named in argv[2].
            */
           if (keyctl(KEYCTL_ASSUME_AUTHORITY, key_to_instantiate) == -1) {
               fprintf(fp, "KEYCTL_ASSUME_AUTHORITY failed: %s\n",
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           /*
            * Fetch the description of the key that is to be instantiated.
            */
           if (keyctl(KEYCTL_DESCRIBE, key_to_instantiate,
                      dbuf, sizeof(dbuf)) == -1) {
               fprintf(fp, "KEYCTL_DESCRIBE failed: %s\n", strerror(errno));
               exit(EXIT_FAILURE);
           }

           fprintf(fp, "Key description:      %s\n", dbuf);

           /*
            * Fetch the payload of the authorization key, which is
            * actually the callout data given to request_key().
            */
           akp_size = keyctl(KEYCTL_READ, KEY_SPEC_REQKEY_AUTH_KEY,
                             auth_key_payload, sizeof(auth_key_payload));
           if (akp_size == -1) {
               fprintf(fp, "KEYCTL_READ failed: %s\n", strerror(errno));
               exit(EXIT_FAILURE);
           }

           auth_key_payload[akp_size] = '\0';
           fprintf(fp, "Auth key payload:     %s\n", auth_key_payload);

           /*
            * For interest, get the ID of the authorization key and
            * display it.
            */
           auth_key = keyctl(KEYCTL_GET_KEYRING_ID,
                             KEY_SPEC_REQKEY_AUTH_KEY);
           if (auth_key == -1) {
               fprintf(fp, "KEYCTL_GET_KEYRING_ID failed: %s\n",
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           fprintf(fp, "Auth key ID:          %jx\n", (uintmax_t) auth_key);

           /*
            * Fetch key ID for the request_key(2) destination keyring.
            */
           dest_keyring = keyctl(KEYCTL_GET_KEYRING_ID,
                                 KEY_SPEC_REQUESTOR_KEYRING);
           if (dest_keyring == -1) {
               fprintf(fp, "KEYCTL_GET_KEYRING_ID failed: %s\n",
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           fprintf(fp, "Destination keyring:  %jx\n", (uintmax_t) dest_keyring);

           /*
            * Fetch the description of the authorization key. This
            * allows us to see the key type, UID, GID, permissions,
            * and description (name) of the key. Among other things,
            * we will see that the name of the key is a hexadecimal
            * string representing the ID of the key to be instantiated.
            */
           if (keyctl(KEYCTL_DESCRIBE, KEY_SPEC_REQKEY_AUTH_KEY,
                      dbuf, sizeof(dbuf)) == -1)
           {
               fprintf(fp, "KEYCTL_DESCRIBE failed: %s\n", strerror(errno));
               exit(EXIT_FAILURE);
           }

           fprintf(fp, "Auth key description: %s\n", dbuf);

           /*
            * Instantiate the key using the callout data that was supplied
            * in the payload of the authorization key.
            */
           if (keyctl(KEYCTL_INSTANTIATE, key_to_instantiate,
                      auth_key_payload, akp_size + 1, dest_keyring) == -1)
           {
               fprintf(fp, "KEYCTL_INSTANTIATE failed: %s\n",
                       strerror(errno));
               exit(EXIT_FAILURE);
           }

           exit(EXIT_SUCCESS);
       }
</pre> <h2>
SEE ALSO </h2>
<pre>
       <a href="../man1/keyctl.1.html">keyctl(1)</a>, <a href="add_key.2.html">add_key(2)</a>, <a href="request_key.2.html">request_key(2)</a>, <a href="../man3/keyctl.3.html">keyctl(3)</a>,
       <a href="../man3/keyctl_assume_authority.3.html">keyctl_assume_authority(3)</a>, <a href="../man3/keyctl_chown.3.html">keyctl_chown(3)</a>, <a href="../man3/keyctl_clear.3.html">keyctl_clear(3)</a>,
       <a href="../man3/keyctl_describe.3.html">keyctl_describe(3)</a>, <b>keyctl_describe_alloc</b>(3),
       <a href="../man3/keyctl_dh_compute.3.html">keyctl_dh_compute(3)</a>, <b>keyctl_dh_compute_alloc</b>(3),
       <a href="../man3/keyctl_get_keyring_id.3.html">keyctl_get_keyring_ID(3)</a>, <a href="../man3/keyctl_get_persistent.3.html">keyctl_get_persistent(3)</a>,
       <a href="../man3/keyctl_get_security.3.html">keyctl_get_security(3)</a>, <b>keyctl_get_security_alloc</b>(3),
       <a href="../man3/keyctl_instantiate.3.html">keyctl_instantiate(3)</a>, <a href="../man3/keyctl_instantiate_iov.3.html">keyctl_instantiate_iov(3)</a>,
       <a href="../man3/keyctl_invalidate.3.html">keyctl_invalidate(3)</a>, <a href="../man3/keyctl_join_session_keyring.3.html">keyctl_join_session_keyring(3)</a>,
       <a href="../man3/keyctl_link.3.html">keyctl_link(3)</a>, <a href="../man3/keyctl_negate.3.html">keyctl_negate(3)</a>, <a href="../man3/keyctl_read.3.html">keyctl_read(3)</a>,
       <b>keyctl_read_alloc</b>(3), <a href="../man3/keyctl_reject.3.html">keyctl_reject(3)</a>, <a href="../man3/keyctl_revoke.3.html">keyctl_revoke(3)</a>,
       <a href="../man3/keyctl_search.3.html">keyctl_search(3)</a>, <a href="../man3/keyctl_session_to_parent.3.html">keyctl_session_to_parent(3)</a>,
       <a href="../man3/keyctl_set_reqkey_keyring.3.html">keyctl_set_reqkey_keyring(3)</a>, <a href="../man3/keyctl_set_timeout.3.html">keyctl_set_timeout(3)</a>,
       <a href="../man3/keyctl_setperm.3.html">keyctl_setperm(3)</a>, <a href="../man3/keyctl_unlink.3.html">keyctl_unlink(3)</a>, <a href="../man3/keyctl_update.3.html">keyctl_update(3)</a>,
       <a href="../man3/recursive_key_scan.3.html">recursive_key_scan(3)</a>, <a href="../man3/recursive_session_key_scan.3.html">recursive_session_key_scan(3)</a>,
       <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/credentials.7.html">credentials(7)</a>, <a href="../man7/keyrings.7.html">keyrings(7)</a>, <a href="../man7/keyutils.7.html">keyutils(7)</a>,
       <a href="../man7/persistent-keyring.7.html">persistent-keyring(7)</a>, <a href="../man7/process-keyring.7.html">process-keyring(7)</a>, <a href="../man7/session-keyring.7.html">session-keyring(7)</a>,
       <a href="../man7/thread-keyring.7.html">thread-keyring(7)</a>, <a href="../man7/user-keyring.7.html">user-keyring(7)</a>, <a href="../man7/user_namespaces.7.html">user_namespaces(7)</a>,
       <a href="../man7/user-session-keyring.7.html">user-session-keyring(7)</a>, <a href="../man8/request-key.8.html">request-key(8)</a>

       The kernel source files under <i>Documentation/security/keys/</i> (or,
       before Linux 4.13, in the file <i>Documentation/security/keys.txt</i>).
</pre> <h2>
COLOPHON </h2>
<pre>
       This page is part of the <i>man-pages</i> (Linux kernel and C library
       user-space interface documentation) project.  Information about
       the project can be found at 
       ⟨<a href="https://www.kernel.org/doc/man-pages/">https://www.kernel.org/doc/man-pages/</a>⟩.  If you have a bug report
       for this manual page, see
       ⟨<a href="https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING">https://git.kernel.org/pub/scm/docs/man-pages/man-pages.git/tree/CONTRIBUTING</a>⟩.
       This page was obtained from the tarball man-pages-6.9.1.tar.gz
       fetched from
       ⟨<a href="https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/">https://mirrors.edge.kernel.org/pub/linux/docs/man-pages/</a>⟩ on
       2024-06-26.  If you discover any rendering problems in this HTML
       version of the page, or you believe there is a better or more up-
       to-date source for the page, or you have corrections or
       improvements to the information in this COLOPHON (which is <i>not</i>
       part of the original manual page), send a mail to
       man-pages@man7.org

<span class="footline">Linux man-pages 6.9.1          2024-06-15                      <i>keyctl</i>(2)</span>
</pre>  <p>Pages that refer to this page: <a href="../man1/keyctl.1.html">keyctl(1)</a>, <a href="add_key.2.html">add_key(2)</a>, <a href="request_key.2.html">request_key(2)</a>, <a href="syscalls.2.html">syscalls(2)</a>, <a href="../man3/keyctl.3.html">keyctl(3)</a>, <a href="../man3/keyctl_capabilities.3.html">keyctl_capabilities(3)</a>, <a href="../man3/keyctl_chown.3.html">keyctl_chown(3)</a>, <a href="../man3/keyctl_clear.3.html">keyctl_clear(3)</a>, <a href="../man3/keyctl_describe.3.html">keyctl_describe(3)</a>, <a href="../man3/keyctl_dh_compute.3.html">keyctl_dh_compute(3)</a>, <a href="../man3/keyctl_get_keyring_id.3.html">keyctl_get_keyring_ID(3)</a>, <a href="../man3/keyctl_get_persistent.3.html">keyctl_get_persistent(3)</a>, <a href="../man3/keyctl_get_security.3.html">keyctl_get_security(3)</a>, <a href="../man3/keyctl_instantiate.3.html">keyctl_instantiate(3)</a>, <a href="../man3/keyctl_invalidate.3.html">keyctl_invalidate(3)</a>, <a href="../man3/keyctl_join_session_keyring.3.html">keyctl_join_session_keyring(3)</a>, <a href="../man3/keyctl_link.3.html">keyctl_link(3)</a>, <a href="../man3/keyctl_move.3.html">keyctl_move(3)</a>, <a href="../man3/keyctl_pkey_encrypt.3.html">keyctl_pkey_encrypt(3)</a>, <a href="../man3/keyctl_pkey_query.3.html">keyctl_pkey_query(3)</a>, <a href="../man3/keyctl_pkey_sign.3.html">keyctl_pkey_sign(3)</a>, <a href="../man3/keyctl_read.3.html">keyctl_read(3)</a>, <a href="../man3/keyctl_restrict_keyring.3.html">keyctl_restrict_keyring(3)</a>, <a href="../man3/keyctl_revoke.3.html">keyctl_revoke(3)</a>, <a href="../man3/keyctl_search.3.html">keyctl_search(3)</a>, <a href="../man3/keyctl_session_to_parent.3.html">keyctl_session_to_parent(3)</a>, <a href="../man3/keyctl_setperm.3.html">keyctl_setperm(3)</a>, <a href="../man3/keyctl_set_reqkey_keyring.3.html">keyctl_set_reqkey_keyring(3)</a>, <a href="../man3/keyctl_set_timeout.3.html">keyctl_set_timeout(3)</a>, <a href="../man3/keyctl_update.3.html">keyctl_update(3)</a>, <a href="../man3/keyctl_watch_key.3.html">keyctl_watch_key(3)</a>, <a href="../man5/systemd.exec.5.html">systemd.exec(5)</a>, <a href="../man7/address_families.7.html">address_families(7)</a>, <a href="../man7/capabilities.7.html">capabilities(7)</a>, <a href="../man7/keyrings.7.html">keyrings(7)</a>, <a href="../man7/keyutils.7.html">keyutils(7)</a>, <a href="../man7/persistent-keyring.7.html">persistent-keyring(7)</a>, <a href="../man7/session-keyring.7.html">session-keyring(7)</a> </p> <hr>         <div class="_attribution">
  <p class="_attribution-p">
    ...<br>
    <a href="https://man7.org/linux/man-pages/man2/keyctl.2.html" class="_attribution-link">https://man7.org/linux/man-pages/man2/keyctl.2.html</a>
  </p>
</div>
